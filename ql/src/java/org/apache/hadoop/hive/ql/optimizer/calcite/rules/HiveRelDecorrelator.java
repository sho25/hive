begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Function2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCostImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepRelVertex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|BiRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Correlate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|CorrelationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|RelFactories
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Values
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalAggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalCorrelate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMdUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterCorrelateRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCorrelVariable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexFieldAccess
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexSubQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexVisitorImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlCountAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlSingleValueAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Bug
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Holder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Litmus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ReflectUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ReflectiveVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Stacks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mappings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveAggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveSortLimit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticAnalyzer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSortedMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimaps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|SortedSetMultimap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|HiveRelShuttleImpl
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_comment
comment|/**  * NOTE: this whole logic is replicated from Calcite's RelDecorrelator  *  and is exteneded to make it suitable for HIVE  *  TODO:  *    We should get rid of this and replace it with Calcite's RelDecorrelator  *    once that works with Join, Project etc instead of LogicalJoin, LogicalProject.  *    Also we need to have CALCITE-1511 fixed  *  * RelDecorrelator replaces all correlated expressions (corExp) in a relational  * expression (RelNode) tree with non-correlated expressions that are produced  * from joining the RelNode that produces the corExp with the RelNode that  * references it.  *  *<p>TODO:</p>  *<ul>  *<li>replace {@code CorelMap} constructor parameter with a RelNode  *<li>make {@link #currentRel} immutable (would require a fresh  *      RelDecorrelator for each node being decorrelated)</li>  *<li>make fields of {@code CorelMap} immutable</li>  *<li>make sub-class rules static, and have them create their own  *   de-correlator</li>  *</ul>  */
end_comment

begin_class
specifier|public
class|class
name|HiveRelDecorrelator
implements|implements
name|ReflectiveVisitor
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|protected
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|HiveRelDecorrelator
operator|.
name|class
argument_list|)
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
specifier|private
specifier|final
name|RelBuilder
name|relBuilder
decl_stmt|;
comment|// map built during translation
specifier|private
name|CorelMap
name|cm
decl_stmt|;
specifier|private
specifier|final
name|ReflectUtil
operator|.
name|MethodDispatcher
argument_list|<
name|Frame
argument_list|>
name|dispatcher
init|=
name|ReflectUtil
operator|.
name|createMethodDispatcher
argument_list|(
name|Frame
operator|.
name|class
argument_list|,
name|this
argument_list|,
literal|"decorrelateRel"
argument_list|,
name|RelNode
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
comment|// The rel which is being visited
specifier|private
name|RelNode
name|currentRel
decl_stmt|;
specifier|private
specifier|final
name|Context
name|context
decl_stmt|;
comment|/** Built during decorrelation, of rel to all the newly created correlated    * variables in its output, and to map old input positions to new input    * positions. This is from the view point of the parent rel of a new rel. */
specifier|private
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|Frame
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|HashSet
argument_list|<
name|LogicalCorrelate
argument_list|>
name|generatedCorRels
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
specifier|private
name|HiveRelDecorrelator
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|CorelMap
name|cm
parameter_list|,
name|Context
name|context
parameter_list|)
block|{
name|this
operator|.
name|cm
operator|=
name|cm
expr_stmt|;
name|this
operator|.
name|rexBuilder
operator|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
expr_stmt|;
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|relBuilder
operator|=
name|RelFactories
operator|.
name|LOGICAL_BUILDER
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/** Decorrelates a query.    *    *<p>This is the main entry point to {@code RelDecorrelator}.    *    * @param rootRel Root node of the query    *    * @return Equivalent query with all    * {@link org.apache.calcite.rel.logical.LogicalCorrelate} instances removed    */
specifier|public
specifier|static
name|RelNode
name|decorrelateQuery
parameter_list|(
name|RelNode
name|rootRel
parameter_list|)
block|{
specifier|final
name|CorelMap
name|corelMap
init|=
operator|new
name|CorelMapBuilder
argument_list|()
operator|.
name|build
argument_list|(
name|rootRel
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|corelMap
operator|.
name|hasCorrelation
argument_list|()
condition|)
block|{
return|return
name|rootRel
return|;
block|}
specifier|final
name|RelOptCluster
name|cluster
init|=
name|rootRel
operator|.
name|getCluster
argument_list|()
decl_stmt|;
specifier|final
name|HiveRelDecorrelator
name|decorrelator
init|=
operator|new
name|HiveRelDecorrelator
argument_list|(
name|cluster
argument_list|,
name|corelMap
argument_list|,
name|cluster
operator|.
name|getPlanner
argument_list|()
operator|.
name|getContext
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|newRootRel
init|=
name|decorrelator
operator|.
name|removeCorrelationViaRule
argument_list|(
name|rootRel
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|decorrelator
operator|.
name|cm
operator|.
name|mapCorToCorRel
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|newRootRel
operator|=
name|decorrelator
operator|.
name|decorrelate
argument_list|(
name|newRootRel
argument_list|)
expr_stmt|;
block|}
return|return
name|newRootRel
return|;
block|}
specifier|private
name|void
name|setCurrent
parameter_list|(
name|RelNode
name|root
parameter_list|,
name|LogicalCorrelate
name|corRel
parameter_list|)
block|{
name|currentRel
operator|=
name|corRel
expr_stmt|;
if|if
condition|(
name|corRel
operator|!=
literal|null
condition|)
block|{
name|cm
operator|=
operator|new
name|CorelMapBuilder
argument_list|()
operator|.
name|build
argument_list|(
name|Util
operator|.
name|first
argument_list|(
name|root
argument_list|,
name|corRel
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|RelNode
name|decorrelate
parameter_list|(
name|RelNode
name|root
parameter_list|)
block|{
comment|// first adjust count() expression if any
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
operator|new
name|AdjustProjectForCountAggregateRule
argument_list|(
literal|false
argument_list|)
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
operator|new
name|AdjustProjectForCountAggregateRule
argument_list|(
literal|true
argument_list|)
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
comment|// FilterCorrelateRule rule mistakenly pushes a FILTER, consiting of correlated vars,
comment|// on top of LogicalCorrelate to within  left input for scalar corr queries
comment|// which causes exception during decorrelation. This has been disabled for now.
comment|//.addRuleInstance(FilterCorrelateRule.INSTANCE)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|planner
init|=
name|createPlanner
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|root
operator|=
name|planner
operator|.
name|findBestExp
argument_list|()
expr_stmt|;
comment|// Perform decorrelation.
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
specifier|final
name|Frame
name|frame
init|=
name|getInvoke
argument_list|(
name|root
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|frame
operator|!=
literal|null
condition|)
block|{
comment|// has been rewritten; apply rules post-decorrelation
specifier|final
name|HepProgram
name|program2
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepPlanner
name|planner2
init|=
name|createPlanner
argument_list|(
name|program2
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|newRoot
init|=
name|frame
operator|.
name|r
decl_stmt|;
name|planner2
operator|.
name|setRoot
argument_list|(
name|newRoot
argument_list|)
expr_stmt|;
return|return
name|planner2
operator|.
name|findBestExp
argument_list|()
return|;
block|}
return|return
name|root
return|;
block|}
specifier|private
name|Function2
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|,
name|Void
argument_list|>
name|createCopyHook
parameter_list|()
block|{
return|return
operator|new
name|Function2
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|RelNode
name|oldNode
parameter_list|,
name|RelNode
name|newNode
parameter_list|)
block|{
if|if
condition|(
name|cm
operator|.
name|mapRefRelToCorRef
operator|.
name|containsKey
argument_list|(
name|oldNode
argument_list|)
condition|)
block|{
name|cm
operator|.
name|mapRefRelToCorRef
operator|.
name|putAll
argument_list|(
name|newNode
argument_list|,
name|cm
operator|.
name|mapRefRelToCorRef
operator|.
name|get
argument_list|(
name|oldNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldNode
operator|instanceof
name|LogicalCorrelate
operator|&&
name|newNode
operator|instanceof
name|LogicalCorrelate
condition|)
block|{
name|LogicalCorrelate
name|oldCor
init|=
operator|(
name|LogicalCorrelate
operator|)
name|oldNode
decl_stmt|;
name|CorrelationId
name|c
init|=
name|oldCor
operator|.
name|getCorrelationId
argument_list|()
decl_stmt|;
if|if
condition|(
name|cm
operator|.
name|mapCorToCorRel
operator|.
name|get
argument_list|(
name|c
argument_list|)
operator|==
name|oldNode
condition|)
block|{
name|cm
operator|.
name|mapCorToCorRel
operator|.
name|put
argument_list|(
name|c
argument_list|,
name|newNode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|generatedCorRels
operator|.
name|contains
argument_list|(
name|oldNode
argument_list|)
condition|)
block|{
name|generatedCorRels
operator|.
name|add
argument_list|(
operator|(
name|LogicalCorrelate
operator|)
name|newNode
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
return|;
block|}
specifier|private
name|HepPlanner
name|createPlanner
parameter_list|(
name|HepProgram
name|program
parameter_list|)
block|{
comment|// Create a planner with a hook to update the mapping tables when a
comment|// node is copied when it is registered.
return|return
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|,
name|context
argument_list|,
literal|true
argument_list|,
name|createCopyHook
argument_list|()
argument_list|,
name|RelOptCostImpl
operator|.
name|FACTORY
argument_list|)
return|;
block|}
specifier|public
name|RelNode
name|removeCorrelationViaRule
parameter_list|(
name|RelNode
name|root
parameter_list|)
block|{
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
operator|new
name|RemoveSingleAggregateRule
argument_list|()
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
operator|new
name|RemoveCorrelationForScalarProjectRule
argument_list|()
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
operator|new
name|RemoveCorrelationForScalarAggregateRule
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|planner
init|=
name|createPlanner
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|root
argument_list|)
expr_stmt|;
return|return
name|planner
operator|.
name|findBestExp
argument_list|()
return|;
block|}
specifier|protected
name|RexNode
name|decorrelateExpr
parameter_list|(
name|RexNode
name|exp
parameter_list|)
block|{
name|DecorrelateRexShuttle
name|shuttle
init|=
operator|new
name|DecorrelateRexShuttle
argument_list|()
decl_stmt|;
return|return
name|exp
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
return|;
block|}
specifier|protected
name|RexNode
name|removeCorrelationExpr
parameter_list|(
name|RexNode
name|exp
parameter_list|,
name|boolean
name|projectPulledAboveLeftCorrelator
parameter_list|)
block|{
name|RemoveCorrelationRexShuttle
name|shuttle
init|=
operator|new
name|RemoveCorrelationRexShuttle
argument_list|(
name|rexBuilder
argument_list|,
name|projectPulledAboveLeftCorrelator
argument_list|,
literal|null
argument_list|,
name|ImmutableSet
operator|.
expr|<
name|Integer
operator|>
name|of
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|exp
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
return|;
block|}
specifier|protected
name|RexNode
name|removeCorrelationExpr
parameter_list|(
name|RexNode
name|exp
parameter_list|,
name|boolean
name|projectPulledAboveLeftCorrelator
parameter_list|,
name|RexInputRef
name|nullIndicator
parameter_list|)
block|{
name|RemoveCorrelationRexShuttle
name|shuttle
init|=
operator|new
name|RemoveCorrelationRexShuttle
argument_list|(
name|rexBuilder
argument_list|,
name|projectPulledAboveLeftCorrelator
argument_list|,
name|nullIndicator
argument_list|,
name|ImmutableSet
operator|.
expr|<
name|Integer
operator|>
name|of
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|exp
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
return|;
block|}
specifier|protected
name|RexNode
name|removeCorrelationExpr
parameter_list|(
name|RexNode
name|exp
parameter_list|,
name|boolean
name|projectPulledAboveLeftCorrelator
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|isCount
parameter_list|)
block|{
name|RemoveCorrelationRexShuttle
name|shuttle
init|=
operator|new
name|RemoveCorrelationRexShuttle
argument_list|(
name|rexBuilder
argument_list|,
name|projectPulledAboveLeftCorrelator
argument_list|,
literal|null
argument_list|,
name|isCount
argument_list|)
decl_stmt|;
return|return
name|exp
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
return|;
block|}
comment|/** Fallback if none of the other {@code decorrelateRel} methods match. */
specifier|public
name|Frame
name|decorrelateRel
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|RelNode
name|newRel
init|=
name|rel
operator|.
name|copy
argument_list|(
name|rel
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|rel
operator|.
name|getInputs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rel
operator|.
name|getInputs
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|List
argument_list|<
name|RelNode
argument_list|>
name|oldInputs
init|=
name|rel
operator|.
name|getInputs
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelNode
argument_list|>
name|newInputs
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|oldInputs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|Frame
name|frame
init|=
name|getInvoke
argument_list|(
name|oldInputs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|frame
operator|==
literal|null
operator|||
operator|!
name|frame
operator|.
name|corDefOutputs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// if input is not rewritten, or if it produces correlated
comment|// variables, terminate rewrite
return|return
literal|null
return|;
block|}
name|newInputs
operator|.
name|add
argument_list|(
name|frame
operator|.
name|r
argument_list|)
expr_stmt|;
name|newRel
operator|.
name|replaceInput
argument_list|(
name|i
argument_list|,
name|frame
operator|.
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Util
operator|.
name|equalShallow
argument_list|(
name|oldInputs
argument_list|,
name|newInputs
argument_list|)
condition|)
block|{
name|newRel
operator|=
name|rel
operator|.
name|copy
argument_list|(
name|rel
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|newInputs
argument_list|)
expr_stmt|;
block|}
block|}
comment|// the output position should not change since there are no corVars
comment|// coming from below.
return|return
name|register
argument_list|(
name|rel
argument_list|,
name|newRel
argument_list|,
name|identityMap
argument_list|(
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|,
name|ImmutableSortedMap
operator|.
expr|<
name|CorDef
argument_list|,
name|Integer
operator|>
name|of
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Rewrite Sort.    *    * @param rel Sort to be rewritten    */
specifier|public
name|Frame
name|decorrelateRel
parameter_list|(
name|HiveSortLimit
name|rel
parameter_list|)
block|{
comment|//
comment|// Rewrite logic:
comment|//
comment|// 1. change the collations field to reference the new input.
comment|//
comment|// Sort itself should not reference cor vars.
assert|assert
operator|!
name|cm
operator|.
name|mapRefRelToCorRef
operator|.
name|containsKey
argument_list|(
name|rel
argument_list|)
assert|;
comment|// Sort only references field positions in collations field.
comment|// The collations field in the newRel now need to refer to the
comment|// new output positions in its input.
comment|// Its output does not change the input ordering, so there's no
comment|// need to call propagateExpr.
specifier|final
name|RelNode
name|oldInput
init|=
name|rel
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|Frame
name|frame
init|=
name|getInvoke
argument_list|(
name|oldInput
argument_list|,
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|frame
operator|==
literal|null
condition|)
block|{
comment|// If input has not been rewritten, do not rewrite this rel.
return|return
literal|null
return|;
block|}
specifier|final
name|RelNode
name|newInput
init|=
name|frame
operator|.
name|r
decl_stmt|;
name|Mappings
operator|.
name|TargetMapping
name|mapping
init|=
name|Mappings
operator|.
name|target
argument_list|(
name|frame
operator|.
name|oldToNewOutputs
argument_list|,
name|oldInput
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|newInput
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
decl_stmt|;
name|RelCollation
name|oldCollation
init|=
name|rel
operator|.
name|getCollation
argument_list|()
decl_stmt|;
name|RelCollation
name|newCollation
init|=
name|RexUtil
operator|.
name|apply
argument_list|(
name|mapping
argument_list|,
name|oldCollation
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|newSort
init|=
name|HiveSortLimit
operator|.
name|create
argument_list|(
name|newInput
argument_list|,
name|newCollation
argument_list|,
name|rel
operator|.
name|offset
argument_list|,
name|rel
operator|.
name|fetch
argument_list|)
decl_stmt|;
comment|// Sort does not change input ordering
return|return
name|register
argument_list|(
name|rel
argument_list|,
name|newSort
argument_list|,
name|frame
operator|.
name|oldToNewOutputs
argument_list|,
name|frame
operator|.
name|corDefOutputs
argument_list|)
return|;
block|}
comment|/**    * Rewrite Sort.    *    * @param rel Sort to be rewritten    */
specifier|public
name|Frame
name|decorrelateRel
parameter_list|(
name|Sort
name|rel
parameter_list|)
block|{
comment|//
comment|// Rewrite logic:
comment|//
comment|// 1. change the collations field to reference the new input.
comment|//
comment|// Sort itself should not reference cor vars.
assert|assert
operator|!
name|cm
operator|.
name|mapRefRelToCorRef
operator|.
name|containsKey
argument_list|(
name|rel
argument_list|)
assert|;
comment|// Sort only references field positions in collations field.
comment|// The collations field in the newRel now need to refer to the
comment|// new output positions in its input.
comment|// Its output does not change the input ordering, so there's no
comment|// need to call propagateExpr.
specifier|final
name|RelNode
name|oldInput
init|=
name|rel
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|Frame
name|frame
init|=
name|getInvoke
argument_list|(
name|oldInput
argument_list|,
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|frame
operator|==
literal|null
condition|)
block|{
comment|// If input has not been rewritten, do not rewrite this rel.
return|return
literal|null
return|;
block|}
specifier|final
name|RelNode
name|newInput
init|=
name|frame
operator|.
name|r
decl_stmt|;
name|Mappings
operator|.
name|TargetMapping
name|mapping
init|=
name|Mappings
operator|.
name|target
argument_list|(
name|frame
operator|.
name|oldToNewOutputs
argument_list|,
name|oldInput
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|newInput
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
decl_stmt|;
name|RelCollation
name|oldCollation
init|=
name|rel
operator|.
name|getCollation
argument_list|()
decl_stmt|;
name|RelCollation
name|newCollation
init|=
name|RexUtil
operator|.
name|apply
argument_list|(
name|mapping
argument_list|,
name|oldCollation
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|newSort
init|=
name|HiveSortLimit
operator|.
name|create
argument_list|(
name|newInput
argument_list|,
name|newCollation
argument_list|,
name|rel
operator|.
name|offset
argument_list|,
name|rel
operator|.
name|fetch
argument_list|)
decl_stmt|;
comment|// Sort does not change input ordering
return|return
name|register
argument_list|(
name|rel
argument_list|,
name|newSort
argument_list|,
name|frame
operator|.
name|oldToNewOutputs
argument_list|,
name|frame
operator|.
name|corDefOutputs
argument_list|)
return|;
block|}
comment|/**    * Rewrites a {@link Values}.    *    * @param rel Values to be rewritten    */
specifier|public
name|Frame
name|decorrelateRel
parameter_list|(
name|Values
name|rel
parameter_list|)
block|{
comment|// There are no inputs, so rel does not need to be changed.
return|return
literal|null
return|;
block|}
comment|/**    * Rewrites a {@link LogicalAggregate}.    *    * @param rel Aggregate to rewrite    */
specifier|public
name|Frame
name|decorrelateRel
parameter_list|(
name|LogicalAggregate
name|rel
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|rel
operator|.
name|getGroupType
argument_list|()
operator|!=
name|Aggregate
operator|.
name|Group
operator|.
name|SIMPLE
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|Bug
operator|.
name|CALCITE_461_FIXED
argument_list|)
throw|;
block|}
comment|//
comment|// Rewrite logic:
comment|//
comment|// 1. Permute the group by keys to the front.
comment|// 2. If the input of an aggregate produces correlated variables,
comment|//    add them to the group list.
comment|// 3. Change aggCalls to reference the new project.
comment|//
comment|// Aggregate itself should not reference cor vars.
assert|assert
operator|!
name|cm
operator|.
name|mapRefRelToCorRef
operator|.
name|containsKey
argument_list|(
name|rel
argument_list|)
assert|;
specifier|final
name|RelNode
name|oldInput
init|=
name|rel
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|Frame
name|frame
init|=
name|getInvoke
argument_list|(
name|oldInput
argument_list|,
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|frame
operator|==
literal|null
condition|)
block|{
comment|// If input has not been rewritten, do not rewrite this rel.
return|return
literal|null
return|;
block|}
specifier|final
name|RelNode
name|newInput
init|=
name|frame
operator|.
name|r
decl_stmt|;
comment|// map from newInput
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|mapNewInputToProjOutputs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|int
name|oldGroupKeyCount
init|=
name|rel
operator|.
name|getGroupSet
argument_list|()
operator|.
name|cardinality
argument_list|()
decl_stmt|;
comment|// Project projects the original expressions,
comment|// plus any correlated variables the input wants to pass along.
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|projects
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|newInputOutput
init|=
name|newInput
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|int
name|newPos
init|=
literal|0
decl_stmt|;
comment|// oldInput has the original group by keys in the front.
specifier|final
name|NavigableMap
argument_list|<
name|Integer
argument_list|,
name|RexLiteral
argument_list|>
name|omittedConstants
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|oldGroupKeyCount
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RexLiteral
name|constant
init|=
name|projectedLiteral
argument_list|(
name|newInput
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|constant
operator|!=
literal|null
condition|)
block|{
comment|// Exclude constants. Aggregate({true}) occurs because Aggregate({})
comment|// would generate 1 row even when applied to an empty table.
name|omittedConstants
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|constant
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|int
name|newInputPos
init|=
name|frame
operator|.
name|oldToNewOutputs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|projects
operator|.
name|add
argument_list|(
name|RexInputRef
operator|.
name|of2
argument_list|(
name|newInputPos
argument_list|,
name|newInputOutput
argument_list|)
argument_list|)
expr_stmt|;
name|mapNewInputToProjOutputs
operator|.
name|put
argument_list|(
name|newInputPos
argument_list|,
name|newPos
argument_list|)
expr_stmt|;
name|newPos
operator|++
expr_stmt|;
block|}
specifier|final
name|SortedMap
argument_list|<
name|CorDef
argument_list|,
name|Integer
argument_list|>
name|corDefOutputs
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|frame
operator|.
name|corDefOutputs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// If input produces correlated variables, move them to the front,
comment|// right after any existing GROUP BY fields.
comment|// Now add the corVars from the input, starting from
comment|// position oldGroupKeyCount.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|CorDef
argument_list|,
name|Integer
argument_list|>
name|entry
range|:
name|frame
operator|.
name|corDefOutputs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|RexInputRef
operator|.
name|of2
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|newInputOutput
argument_list|)
argument_list|)
expr_stmt|;
name|corDefOutputs
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|newPos
argument_list|)
expr_stmt|;
name|mapNewInputToProjOutputs
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|newPos
argument_list|)
expr_stmt|;
name|newPos
operator|++
expr_stmt|;
block|}
block|}
comment|// add the remaining fields
specifier|final
name|int
name|newGroupKeyCount
init|=
name|newPos
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newInputOutput
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|mapNewInputToProjOutputs
operator|.
name|containsKey
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|RexInputRef
operator|.
name|of2
argument_list|(
name|i
argument_list|,
name|newInputOutput
argument_list|)
argument_list|)
expr_stmt|;
name|mapNewInputToProjOutputs
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|newPos
argument_list|)
expr_stmt|;
name|newPos
operator|++
expr_stmt|;
block|}
block|}
assert|assert
name|newPos
operator|==
name|newInputOutput
operator|.
name|size
argument_list|()
assert|;
comment|// This Project will be what the old input maps to,
comment|// replacing any previous mapping from old input).
name|RelNode
name|newProject
init|=
name|HiveProject
operator|.
name|create
argument_list|(
name|newInput
argument_list|,
name|Pair
operator|.
name|left
argument_list|(
name|projects
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|projects
argument_list|)
argument_list|)
decl_stmt|;
comment|// update mappings:
comment|// oldInput ----> newInput
comment|//
comment|//                newProject
comment|//                   |
comment|// oldInput ----> newInput
comment|//
comment|// is transformed to
comment|//
comment|// oldInput ----> newProject
comment|//                   |
comment|//                newInput
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|combinedMap
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|oldInputPos
range|:
name|frame
operator|.
name|oldToNewOutputs
operator|.
name|keySet
argument_list|()
control|)
block|{
name|combinedMap
operator|.
name|put
argument_list|(
name|oldInputPos
argument_list|,
name|mapNewInputToProjOutputs
operator|.
name|get
argument_list|(
name|frame
operator|.
name|oldToNewOutputs
operator|.
name|get
argument_list|(
name|oldInputPos
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|register
argument_list|(
name|oldInput
argument_list|,
name|newProject
argument_list|,
name|combinedMap
argument_list|,
name|corDefOutputs
argument_list|)
expr_stmt|;
comment|// now it's time to rewrite the Aggregate
specifier|final
name|ImmutableBitSet
name|newGroupSet
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|newGroupKeyCount
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|newAggCalls
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|oldAggCalls
init|=
name|rel
operator|.
name|getAggCallList
argument_list|()
decl_stmt|;
name|int
name|oldInputOutputFieldCount
init|=
name|rel
operator|.
name|getGroupSet
argument_list|()
operator|.
name|cardinality
argument_list|()
decl_stmt|;
name|int
name|newInputOutputFieldCount
init|=
name|newGroupSet
operator|.
name|cardinality
argument_list|()
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|AggregateCall
name|oldAggCall
range|:
name|oldAggCalls
control|)
block|{
operator|++
name|i
expr_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|oldAggArgs
init|=
name|oldAggCall
operator|.
name|getArgList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|aggArgs
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// Adjust the aggregator argument positions.
comment|// Note aggregator does not change input ordering, so the input
comment|// output position mapping can be used to derive the new positions
comment|// for the argument.
for|for
control|(
name|int
name|oldPos
range|:
name|oldAggArgs
control|)
block|{
name|aggArgs
operator|.
name|add
argument_list|(
name|combinedMap
operator|.
name|get
argument_list|(
name|oldPos
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|filterArg
init|=
name|oldAggCall
operator|.
name|filterArg
operator|<
literal|0
condition|?
name|oldAggCall
operator|.
name|filterArg
else|:
name|combinedMap
operator|.
name|get
argument_list|(
name|oldAggCall
operator|.
name|filterArg
argument_list|)
decl_stmt|;
name|newAggCalls
operator|.
name|add
argument_list|(
name|oldAggCall
operator|.
name|adaptTo
argument_list|(
name|newProject
argument_list|,
name|aggArgs
argument_list|,
name|filterArg
argument_list|,
name|oldGroupKeyCount
argument_list|,
name|newGroupKeyCount
argument_list|)
argument_list|)
expr_stmt|;
comment|// The old to new output position mapping will be the same as that
comment|// of newProject, plus any aggregates that the oldAgg produces.
name|combinedMap
operator|.
name|put
argument_list|(
name|oldInputOutputFieldCount
operator|+
name|i
argument_list|,
name|newInputOutputFieldCount
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|relBuilder
operator|.
name|push
argument_list|(
name|LogicalAggregate
operator|.
name|create
argument_list|(
name|newProject
argument_list|,
literal|false
argument_list|,
name|newGroupSet
argument_list|,
literal|null
argument_list|,
name|newAggCalls
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|omittedConstants
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|postProjects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|relBuilder
operator|.
name|fields
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|RexLiteral
argument_list|>
name|entry
range|:
name|omittedConstants
operator|.
name|descendingMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|postProjects
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|+
name|frame
operator|.
name|corDefOutputs
operator|.
name|size
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|relBuilder
operator|.
name|project
argument_list|(
name|postProjects
argument_list|)
expr_stmt|;
block|}
comment|// Aggregate does not change input ordering so corVars will be
comment|// located at the same position as the input newProject.
return|return
name|register
argument_list|(
name|rel
argument_list|,
name|relBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|combinedMap
argument_list|,
name|corDefOutputs
argument_list|)
return|;
block|}
specifier|public
name|Frame
name|getInvoke
parameter_list|(
name|RelNode
name|r
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
specifier|final
name|Frame
name|frame
init|=
name|dispatcher
operator|.
name|invoke
argument_list|(
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|frame
operator|!=
literal|null
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|r
argument_list|,
name|frame
argument_list|)
expr_stmt|;
block|}
name|currentRel
operator|=
name|parent
expr_stmt|;
return|return
name|frame
return|;
block|}
comment|/** Returns a literal output field, or null if it is not literal. */
specifier|private
specifier|static
name|RexLiteral
name|projectedLiteral
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|rel
operator|instanceof
name|Project
condition|)
block|{
specifier|final
name|Project
name|project
init|=
operator|(
name|Project
operator|)
name|rel
decl_stmt|;
specifier|final
name|RexNode
name|node
init|=
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|RexLiteral
condition|)
block|{
return|return
operator|(
name|RexLiteral
operator|)
name|node
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|Frame
name|decorrelateRel
parameter_list|(
name|HiveAggregate
name|rel
parameter_list|)
throws|throws
name|SemanticException
block|{
block|{
if|if
condition|(
name|rel
operator|.
name|getGroupType
argument_list|()
operator|!=
name|Aggregate
operator|.
name|Group
operator|.
name|SIMPLE
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|Bug
operator|.
name|CALCITE_461_FIXED
argument_list|)
throw|;
block|}
comment|//
comment|// Rewrite logic:
comment|//
comment|// 1. Permute the group by keys to the front.
comment|// 2. If the input of an aggregate produces correlated variables,
comment|//    add them to the group list.
comment|// 3. Change aggCalls to reference the new project.
comment|//
comment|// Aggregate itself should not reference cor vars.
assert|assert
operator|!
name|cm
operator|.
name|mapRefRelToCorRef
operator|.
name|containsKey
argument_list|(
name|rel
argument_list|)
assert|;
specifier|final
name|RelNode
name|oldInput
init|=
name|rel
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|Frame
name|frame
init|=
name|getInvoke
argument_list|(
name|oldInput
argument_list|,
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|frame
operator|==
literal|null
condition|)
block|{
comment|// If input has not been rewritten, do not rewrite this rel.
return|return
literal|null
return|;
block|}
comment|//assert !frame.corVarOutputPos.isEmpty();
specifier|final
name|RelNode
name|newInput
init|=
name|frame
operator|.
name|r
decl_stmt|;
comment|// map from newInput
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|mapNewInputToProjOutputs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|int
name|oldGroupKeyCount
init|=
name|rel
operator|.
name|getGroupSet
argument_list|()
operator|.
name|cardinality
argument_list|()
decl_stmt|;
comment|// Project projects the original expressions,
comment|// plus any correlated variables the input wants to pass along.
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|projects
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|newInputOutput
init|=
name|newInput
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|int
name|newPos
init|=
literal|0
decl_stmt|;
comment|// oldInput has the original group by keys in the front.
specifier|final
name|NavigableMap
argument_list|<
name|Integer
argument_list|,
name|RexLiteral
argument_list|>
name|omittedConstants
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|oldGroupKeyCount
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RexLiteral
name|constant
init|=
name|projectedLiteral
argument_list|(
name|newInput
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|constant
operator|!=
literal|null
condition|)
block|{
comment|// Exclude constants. Aggregate({true}) occurs because Aggregate({})
comment|// would generate 1 row even when applied to an empty table.
name|omittedConstants
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|constant
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|int
name|newInputPos
init|=
name|frame
operator|.
name|oldToNewOutputs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|projects
operator|.
name|add
argument_list|(
name|RexInputRef
operator|.
name|of2
argument_list|(
name|newInputPos
argument_list|,
name|newInputOutput
argument_list|)
argument_list|)
expr_stmt|;
name|mapNewInputToProjOutputs
operator|.
name|put
argument_list|(
name|newInputPos
argument_list|,
name|newPos
argument_list|)
expr_stmt|;
name|newPos
operator|++
expr_stmt|;
block|}
specifier|final
name|SortedMap
argument_list|<
name|CorDef
argument_list|,
name|Integer
argument_list|>
name|corDefOutputs
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|frame
operator|.
name|corDefOutputs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// If input produces correlated variables, move them to the front,
comment|// right after any existing GROUP BY fields.
comment|// Now add the corVars from the input, starting from
comment|// position oldGroupKeyCount.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|CorDef
argument_list|,
name|Integer
argument_list|>
name|entry
range|:
name|frame
operator|.
name|corDefOutputs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|RexInputRef
operator|.
name|of2
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|newInputOutput
argument_list|)
argument_list|)
expr_stmt|;
name|corDefOutputs
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|newPos
argument_list|)
expr_stmt|;
name|mapNewInputToProjOutputs
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|newPos
argument_list|)
expr_stmt|;
name|newPos
operator|++
expr_stmt|;
block|}
block|}
comment|// add the remaining fields
specifier|final
name|int
name|newGroupKeyCount
init|=
name|newPos
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newInputOutput
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|mapNewInputToProjOutputs
operator|.
name|containsKey
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|RexInputRef
operator|.
name|of2
argument_list|(
name|i
argument_list|,
name|newInputOutput
argument_list|)
argument_list|)
expr_stmt|;
name|mapNewInputToProjOutputs
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|newPos
argument_list|)
expr_stmt|;
name|newPos
operator|++
expr_stmt|;
block|}
block|}
assert|assert
name|newPos
operator|==
name|newInputOutput
operator|.
name|size
argument_list|()
assert|;
comment|// This Project will be what the old input maps to,
comment|// replacing any previous mapping from old input).
name|RelNode
name|newProject
init|=
name|HiveProject
operator|.
name|create
argument_list|(
name|newInput
argument_list|,
name|Pair
operator|.
name|left
argument_list|(
name|projects
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|projects
argument_list|)
argument_list|)
decl_stmt|;
comment|// update mappings:
comment|// oldInput ----> newInput
comment|//
comment|//                newProject
comment|//                   |
comment|// oldInput ----> newInput
comment|//
comment|// is transformed to
comment|//
comment|// oldInput ----> newProject
comment|//                   |
comment|//                newInput
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|combinedMap
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|oldInputPos
range|:
name|frame
operator|.
name|oldToNewOutputs
operator|.
name|keySet
argument_list|()
control|)
block|{
name|combinedMap
operator|.
name|put
argument_list|(
name|oldInputPos
argument_list|,
name|mapNewInputToProjOutputs
operator|.
name|get
argument_list|(
name|frame
operator|.
name|oldToNewOutputs
operator|.
name|get
argument_list|(
name|oldInputPos
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|register
argument_list|(
name|oldInput
argument_list|,
name|newProject
argument_list|,
name|combinedMap
argument_list|,
name|corDefOutputs
argument_list|)
expr_stmt|;
comment|// now it's time to rewrite the Aggregate
specifier|final
name|ImmutableBitSet
name|newGroupSet
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|newGroupKeyCount
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|newAggCalls
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|oldAggCalls
init|=
name|rel
operator|.
name|getAggCallList
argument_list|()
decl_stmt|;
name|int
name|oldInputOutputFieldCount
init|=
name|rel
operator|.
name|getGroupSet
argument_list|()
operator|.
name|cardinality
argument_list|()
decl_stmt|;
name|int
name|newInputOutputFieldCount
init|=
name|newGroupSet
operator|.
name|cardinality
argument_list|()
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|AggregateCall
name|oldAggCall
range|:
name|oldAggCalls
control|)
block|{
operator|++
name|i
expr_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|oldAggArgs
init|=
name|oldAggCall
operator|.
name|getArgList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|aggArgs
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// Adjust the aggregator argument positions.
comment|// Note aggregator does not change input ordering, so the input
comment|// output position mapping can be used to derive the new positions
comment|// for the argument.
for|for
control|(
name|int
name|oldPos
range|:
name|oldAggArgs
control|)
block|{
name|aggArgs
operator|.
name|add
argument_list|(
name|combinedMap
operator|.
name|get
argument_list|(
name|oldPos
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|filterArg
init|=
name|oldAggCall
operator|.
name|filterArg
operator|<
literal|0
condition|?
name|oldAggCall
operator|.
name|filterArg
else|:
name|combinedMap
operator|.
name|get
argument_list|(
name|oldAggCall
operator|.
name|filterArg
argument_list|)
decl_stmt|;
name|newAggCalls
operator|.
name|add
argument_list|(
name|oldAggCall
operator|.
name|adaptTo
argument_list|(
name|newProject
argument_list|,
name|aggArgs
argument_list|,
name|filterArg
argument_list|,
name|oldGroupKeyCount
argument_list|,
name|newGroupKeyCount
argument_list|)
argument_list|)
expr_stmt|;
comment|// The old to new output position mapping will be the same as that
comment|// of newProject, plus any aggregates that the oldAgg produces.
name|combinedMap
operator|.
name|put
argument_list|(
name|oldInputOutputFieldCount
operator|+
name|i
argument_list|,
name|newInputOutputFieldCount
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|relBuilder
operator|.
name|push
argument_list|(
operator|new
name|HiveAggregate
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|rel
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|newProject
argument_list|,
literal|false
argument_list|,
name|newGroupSet
argument_list|,
literal|null
argument_list|,
name|newAggCalls
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|omittedConstants
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|postProjects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|relBuilder
operator|.
name|fields
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|RexLiteral
argument_list|>
name|entry
range|:
name|omittedConstants
operator|.
name|descendingMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|postProjects
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|+
name|frame
operator|.
name|corDefOutputs
operator|.
name|size
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|relBuilder
operator|.
name|project
argument_list|(
name|postProjects
argument_list|)
expr_stmt|;
block|}
comment|// Aggregate does not change input ordering so corVars will be
comment|// located at the same position as the input newProject.
return|return
name|register
argument_list|(
name|rel
argument_list|,
name|relBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|combinedMap
argument_list|,
name|corDefOutputs
argument_list|)
return|;
block|}
block|}
specifier|public
name|Frame
name|decorrelateRel
parameter_list|(
name|HiveProject
name|rel
parameter_list|)
throws|throws
name|SemanticException
block|{
block|{
comment|//
comment|// Rewrite logic:
comment|//
comment|// 1. Pass along any correlated variables coming from the input.
comment|//
specifier|final
name|RelNode
name|oldInput
init|=
name|rel
operator|.
name|getInput
argument_list|()
decl_stmt|;
name|Frame
name|frame
init|=
name|getInvoke
argument_list|(
name|oldInput
argument_list|,
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|frame
operator|==
literal|null
condition|)
block|{
comment|// If input has not been rewritten, do not rewrite this rel.
return|return
literal|null
return|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|oldProjects
init|=
name|rel
operator|.
name|getProjects
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|relOutput
init|=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
comment|// LogicalProject projects the original expressions,
comment|// plus any correlated variables the input wants to pass along.
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|projects
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// If this LogicalProject has correlated reference, create value generator
comment|// and produce the correlated variables in the new output.
if|if
condition|(
name|cm
operator|.
name|mapRefRelToCorRef
operator|.
name|containsKey
argument_list|(
name|rel
argument_list|)
condition|)
block|{
name|frame
operator|=
name|decorrelateInputWithValueGenerator
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
comment|// LogicalProject projects the original expressions
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|mapOldToNewOutputs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|newPos
decl_stmt|;
for|for
control|(
name|newPos
operator|=
literal|0
init|;
name|newPos
operator|<
name|oldProjects
operator|.
name|size
argument_list|()
condition|;
name|newPos
operator|++
control|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|newPos
argument_list|,
name|Pair
operator|.
name|of
argument_list|(
name|decorrelateExpr
argument_list|(
name|oldProjects
operator|.
name|get
argument_list|(
name|newPos
argument_list|)
argument_list|)
argument_list|,
name|relOutput
operator|.
name|get
argument_list|(
name|newPos
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|mapOldToNewOutputs
operator|.
name|put
argument_list|(
name|newPos
argument_list|,
name|newPos
argument_list|)
expr_stmt|;
block|}
comment|// Project any correlated variables the input wants to pass along.
specifier|final
name|SortedMap
argument_list|<
name|CorDef
argument_list|,
name|Integer
argument_list|>
name|corDefOutputs
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|CorDef
argument_list|,
name|Integer
argument_list|>
name|entry
range|:
name|frame
operator|.
name|corDefOutputs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|RexInputRef
operator|.
name|of2
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|frame
operator|.
name|r
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|corDefOutputs
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|newPos
argument_list|)
expr_stmt|;
name|newPos
operator|++
expr_stmt|;
block|}
name|RelNode
name|newProject
init|=
name|HiveProject
operator|.
name|create
argument_list|(
name|frame
operator|.
name|r
argument_list|,
name|Pair
operator|.
name|left
argument_list|(
name|projects
argument_list|)
argument_list|,
name|SqlValidatorUtil
operator|.
name|uniquify
argument_list|(
name|Pair
operator|.
name|right
argument_list|(
name|projects
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|register
argument_list|(
name|rel
argument_list|,
name|newProject
argument_list|,
name|mapOldToNewOutputs
argument_list|,
name|corDefOutputs
argument_list|)
return|;
block|}
block|}
comment|/**    * Rewrite LogicalProject.    *    * @param rel the project rel to rewrite    */
specifier|public
name|Frame
name|decorrelateRel
parameter_list|(
name|LogicalProject
name|rel
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|//
comment|// Rewrite logic:
comment|//
comment|// 1. Pass along any correlated variables coming from the input.
comment|//
specifier|final
name|RelNode
name|oldInput
init|=
name|rel
operator|.
name|getInput
argument_list|()
decl_stmt|;
name|Frame
name|frame
init|=
name|getInvoke
argument_list|(
name|oldInput
argument_list|,
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|frame
operator|==
literal|null
condition|)
block|{
comment|// If input has not been rewritten, do not rewrite this rel.
return|return
literal|null
return|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|oldProjects
init|=
name|rel
operator|.
name|getProjects
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|relOutput
init|=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
comment|// LogicalProject projects the original expressions,
comment|// plus any correlated variables the input wants to pass along.
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|projects
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// If this LogicalProject has correlated reference, create value generator
comment|// and produce the correlated variables in the new output.
if|if
condition|(
name|cm
operator|.
name|mapRefRelToCorRef
operator|.
name|containsKey
argument_list|(
name|rel
argument_list|)
condition|)
block|{
name|frame
operator|=
name|decorrelateInputWithValueGenerator
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
comment|// LogicalProject projects the original expressions
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|mapOldToNewOutputs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|newPos
decl_stmt|;
for|for
control|(
name|newPos
operator|=
literal|0
init|;
name|newPos
operator|<
name|oldProjects
operator|.
name|size
argument_list|()
condition|;
name|newPos
operator|++
control|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|newPos
argument_list|,
name|Pair
operator|.
name|of
argument_list|(
name|decorrelateExpr
argument_list|(
name|oldProjects
operator|.
name|get
argument_list|(
name|newPos
argument_list|)
argument_list|)
argument_list|,
name|relOutput
operator|.
name|get
argument_list|(
name|newPos
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|mapOldToNewOutputs
operator|.
name|put
argument_list|(
name|newPos
argument_list|,
name|newPos
argument_list|)
expr_stmt|;
block|}
comment|// Project any correlated variables the input wants to pass along.
specifier|final
name|SortedMap
argument_list|<
name|CorDef
argument_list|,
name|Integer
argument_list|>
name|corDefOutputs
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|CorDef
argument_list|,
name|Integer
argument_list|>
name|entry
range|:
name|frame
operator|.
name|corDefOutputs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|RexInputRef
operator|.
name|of2
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|frame
operator|.
name|r
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|corDefOutputs
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|newPos
argument_list|)
expr_stmt|;
name|newPos
operator|++
expr_stmt|;
block|}
name|RelNode
name|newProject
init|=
name|HiveProject
operator|.
name|create
argument_list|(
name|frame
operator|.
name|r
argument_list|,
name|Pair
operator|.
name|left
argument_list|(
name|projects
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|projects
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|register
argument_list|(
name|rel
argument_list|,
name|newProject
argument_list|,
name|mapOldToNewOutputs
argument_list|,
name|corDefOutputs
argument_list|)
return|;
block|}
comment|/**    * Create RelNode tree that produces a list of correlated variables.    *    * @param correlations         correlated variables to generate    * @param valueGenFieldOffset  offset in the output that generated columns    *                             will start    * @param mapCorVarToOutputPos output positions for the correlated variables    *                             generated    * @return RelNode the root of the resultant RelNode tree    */
specifier|private
name|RelNode
name|createValueGenerator
parameter_list|(
name|Iterable
argument_list|<
name|CorRef
argument_list|>
name|correlations
parameter_list|,
name|int
name|valueGenFieldOffset
parameter_list|,
name|SortedMap
argument_list|<
name|CorDef
argument_list|,
name|Integer
argument_list|>
name|corDefOutputs
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|mapNewInputToOutputs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|Integer
argument_list|>
name|mapNewInputToNewOffset
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Input provides the definition of a correlated variable.
comment|// Add to map all the referenced positions (relative to each input rel).
for|for
control|(
name|CorRef
name|corVar
range|:
name|correlations
control|)
block|{
specifier|final
name|int
name|oldCorVarOffset
init|=
name|corVar
operator|.
name|field
decl_stmt|;
specifier|final
name|RelNode
name|oldInput
init|=
name|getCorRel
argument_list|(
name|corVar
argument_list|)
decl_stmt|;
assert|assert
name|oldInput
operator|!=
literal|null
assert|;
specifier|final
name|Frame
name|frame
init|=
name|map
operator|.
name|get
argument_list|(
name|oldInput
argument_list|)
decl_stmt|;
assert|assert
name|frame
operator|!=
literal|null
assert|;
specifier|final
name|RelNode
name|newInput
init|=
name|frame
operator|.
name|r
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|newLocalOutputs
decl_stmt|;
if|if
condition|(
operator|!
name|mapNewInputToOutputs
operator|.
name|containsKey
argument_list|(
name|newInput
argument_list|)
condition|)
block|{
name|newLocalOutputs
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|newLocalOutputs
operator|=
name|mapNewInputToOutputs
operator|.
name|get
argument_list|(
name|newInput
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|newCorVarOffset
init|=
name|frame
operator|.
name|oldToNewOutputs
operator|.
name|get
argument_list|(
name|oldCorVarOffset
argument_list|)
decl_stmt|;
comment|// Add all unique positions referenced.
if|if
condition|(
operator|!
name|newLocalOutputs
operator|.
name|contains
argument_list|(
name|newCorVarOffset
argument_list|)
condition|)
block|{
name|newLocalOutputs
operator|.
name|add
argument_list|(
name|newCorVarOffset
argument_list|)
expr_stmt|;
block|}
name|mapNewInputToOutputs
operator|.
name|put
argument_list|(
name|newInput
argument_list|,
name|newLocalOutputs
argument_list|)
expr_stmt|;
block|}
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|// Project only the correlated fields out of each inputRel
comment|// and join the projectRel together.
comment|// To make sure the plan does not change in terms of join order,
comment|// join these rels based on their occurrence in cor var list which
comment|// is sorted.
specifier|final
name|Set
argument_list|<
name|RelNode
argument_list|>
name|joinedInputs
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|RelNode
name|r
init|=
literal|null
decl_stmt|;
for|for
control|(
name|CorRef
name|corVar
range|:
name|correlations
control|)
block|{
specifier|final
name|RelNode
name|oldInput
init|=
name|getCorRel
argument_list|(
name|corVar
argument_list|)
decl_stmt|;
assert|assert
name|oldInput
operator|!=
literal|null
assert|;
specifier|final
name|RelNode
name|newInput
init|=
name|map
operator|.
name|get
argument_list|(
name|oldInput
argument_list|)
operator|.
name|r
decl_stmt|;
assert|assert
name|newInput
operator|!=
literal|null
assert|;
if|if
condition|(
operator|!
name|joinedInputs
operator|.
name|contains
argument_list|(
name|newInput
argument_list|)
condition|)
block|{
name|RelNode
name|project
init|=
name|RelOptUtil
operator|.
name|createProject
argument_list|(
name|newInput
argument_list|,
name|mapNewInputToOutputs
operator|.
name|get
argument_list|(
name|newInput
argument_list|)
argument_list|)
decl_stmt|;
name|RelNode
name|distinct
init|=
name|RelOptUtil
operator|.
name|createDistinctRel
argument_list|(
name|project
argument_list|)
decl_stmt|;
name|RelOptCluster
name|cluster
init|=
name|distinct
operator|.
name|getCluster
argument_list|()
decl_stmt|;
name|joinedInputs
operator|.
name|add
argument_list|(
name|newInput
argument_list|)
expr_stmt|;
name|mapNewInputToNewOffset
operator|.
name|put
argument_list|(
name|newInput
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|distinct
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|null
condition|)
block|{
name|r
operator|=
name|distinct
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|LogicalJoin
operator|.
name|create
argument_list|(
name|r
argument_list|,
name|distinct
argument_list|,
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|,
name|ImmutableSet
operator|.
expr|<
name|CorrelationId
operator|>
name|of
argument_list|()
argument_list|,
name|JoinRelType
operator|.
name|INNER
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Translate the positions of correlated variables to be relative to
comment|// the join output, leaving room for valueGenFieldOffset because
comment|// valueGenerators are joined with the original left input of the rel
comment|// referencing correlated variables.
for|for
control|(
name|CorRef
name|corRef
range|:
name|correlations
control|)
block|{
comment|// The first input of a Correlator is always the rel defining
comment|// the correlated variables.
specifier|final
name|RelNode
name|oldInput
init|=
name|getCorRel
argument_list|(
name|corRef
argument_list|)
decl_stmt|;
assert|assert
name|oldInput
operator|!=
literal|null
assert|;
specifier|final
name|Frame
name|frame
init|=
name|map
operator|.
name|get
argument_list|(
name|oldInput
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|newInput
init|=
name|frame
operator|.
name|r
decl_stmt|;
assert|assert
name|newInput
operator|!=
literal|null
assert|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|newLocalOutputs
init|=
name|mapNewInputToOutputs
operator|.
name|get
argument_list|(
name|newInput
argument_list|)
decl_stmt|;
specifier|final
name|int
name|newLocalOutput
init|=
name|frame
operator|.
name|oldToNewOutputs
operator|.
name|get
argument_list|(
name|corRef
operator|.
name|field
argument_list|)
decl_stmt|;
comment|// newOutput is the index of the cor var in the referenced
comment|// position list plus the offset of referenced position list of
comment|// each newInput.
specifier|final
name|int
name|newOutput
init|=
name|newLocalOutputs
operator|.
name|indexOf
argument_list|(
name|newLocalOutput
argument_list|)
operator|+
name|mapNewInputToNewOffset
operator|.
name|get
argument_list|(
name|newInput
argument_list|)
operator|+
name|valueGenFieldOffset
decl_stmt|;
name|corDefOutputs
operator|.
name|put
argument_list|(
name|corRef
operator|.
name|def
argument_list|()
argument_list|,
name|newOutput
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
comment|//this returns the source of corVar i.e. Rel which produces cor var
comment|// value. Therefore it is always LogicalCorrelate's left input which is outer query
specifier|private
name|RelNode
name|getCorRel
parameter_list|(
name|CorRef
name|corVar
parameter_list|)
block|{
specifier|final
name|RelNode
name|r
init|=
name|cm
operator|.
name|mapCorToCorRel
operator|.
name|get
argument_list|(
name|corVar
operator|.
name|corr
argument_list|)
decl_stmt|;
name|RelNode
name|ret
init|=
name|r
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
decl_stmt|;
return|return
name|ret
return|;
block|}
specifier|private
name|Frame
name|decorrelateInputWithValueGenerator
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
comment|// currently only handles one input input
assert|assert
name|rel
operator|.
name|getInputs
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
name|RelNode
name|oldInput
init|=
name|rel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Frame
name|frame
init|=
name|map
operator|.
name|get
argument_list|(
name|oldInput
argument_list|)
decl_stmt|;
specifier|final
name|SortedMap
argument_list|<
name|CorDef
argument_list|,
name|Integer
argument_list|>
name|corDefOutputs
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|frame
operator|.
name|corDefOutputs
argument_list|)
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|CorRef
argument_list|>
name|corVarList
init|=
name|cm
operator|.
name|mapRefRelToCorRef
operator|.
name|get
argument_list|(
name|rel
argument_list|)
decl_stmt|;
comment|// Try to populate correlation variables using local fields.
comment|// This means that we do not need a value generator.
if|if
condition|(
name|rel
operator|instanceof
name|Filter
condition|)
block|{
name|SortedMap
argument_list|<
name|CorDef
argument_list|,
name|Integer
argument_list|>
name|map
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|CorRef
name|correlation
range|:
name|corVarList
control|)
block|{
specifier|final
name|CorDef
name|def
init|=
name|correlation
operator|.
name|def
argument_list|()
decl_stmt|;
if|if
condition|(
name|corDefOutputs
operator|.
name|containsKey
argument_list|(
name|def
argument_list|)
operator|||
name|map
operator|.
name|containsKey
argument_list|(
name|def
argument_list|)
condition|)
block|{
continue|continue;
block|}
try|try
block|{
name|findCorrelationEquivalent
argument_list|(
name|correlation
argument_list|,
operator|(
operator|(
name|Filter
operator|)
name|rel
operator|)
operator|.
name|getCondition
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
name|map
operator|.
name|put
argument_list|(
name|def
argument_list|,
operator|(
name|Integer
operator|)
name|e
operator|.
name|getNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If all correlation variables are now satisfied, skip creating a value
comment|// generator.
if|if
condition|(
name|map
operator|.
name|size
argument_list|()
operator|==
name|corVarList
operator|.
name|size
argument_list|()
condition|)
block|{
name|map
operator|.
name|putAll
argument_list|(
name|frame
operator|.
name|corDefOutputs
argument_list|)
expr_stmt|;
return|return
name|register
argument_list|(
name|oldInput
argument_list|,
name|frame
operator|.
name|r
argument_list|,
name|frame
operator|.
name|oldToNewOutputs
argument_list|,
name|map
argument_list|)
return|;
block|}
block|}
name|int
name|leftInputOutputCount
init|=
name|frame
operator|.
name|r
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
comment|// can directly add positions into corDefOutputs since join
comment|// does not change the output ordering from the inputs.
name|RelNode
name|valueGen
init|=
name|createValueGenerator
argument_list|(
name|corVarList
argument_list|,
name|leftInputOutputCount
argument_list|,
name|corDefOutputs
argument_list|)
decl_stmt|;
name|RelNode
name|join
init|=
name|LogicalJoin
operator|.
name|create
argument_list|(
name|frame
operator|.
name|r
argument_list|,
name|valueGen
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|,
name|ImmutableSet
operator|.
expr|<
name|CorrelationId
operator|>
name|of
argument_list|()
argument_list|,
name|JoinRelType
operator|.
name|INNER
argument_list|)
decl_stmt|;
comment|// LogicalJoin or LogicalFilter does not change the old input ordering. All
comment|// input fields from newLeftInput(i.e. the original input to the old
comment|// LogicalFilter) are in the output and in the same position.
return|return
name|register
argument_list|(
name|oldInput
argument_list|,
name|join
argument_list|,
name|frame
operator|.
name|oldToNewOutputs
argument_list|,
name|corDefOutputs
argument_list|)
return|;
block|}
comment|/** Finds a {@link RexInputRef} that is equivalent to a {@link CorRef},    * and if found, throws a {@link Util.FoundOne}. */
specifier|private
name|void
name|findCorrelationEquivalent
parameter_list|(
name|CorRef
name|correlation
parameter_list|,
name|RexNode
name|e
parameter_list|)
throws|throws
name|Util
operator|.
name|FoundOne
block|{
switch|switch
condition|(
name|e
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|e
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
if|if
condition|(
name|references
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|correlation
argument_list|)
operator|&&
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|RexInputRef
condition|)
block|{
throw|throw
operator|new
name|Util
operator|.
name|FoundOne
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|references
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|correlation
argument_list|)
operator|&&
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|RexInputRef
condition|)
block|{
throw|throw
operator|new
name|Util
operator|.
name|FoundOne
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
throw|;
block|}
break|break;
case|case
name|AND
case|:
for|for
control|(
name|RexNode
name|operand
range|:
operator|(
operator|(
name|RexCall
operator|)
name|e
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|findCorrelationEquivalent
argument_list|(
name|correlation
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|boolean
name|references
parameter_list|(
name|RexNode
name|e
parameter_list|,
name|CorRef
name|correlation
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|CAST
case|:
specifier|final
name|RexNode
name|operand
init|=
operator|(
operator|(
name|RexCall
operator|)
name|e
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|isWidening
argument_list|(
name|e
operator|.
name|getType
argument_list|()
argument_list|,
name|operand
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|references
argument_list|(
name|operand
argument_list|,
name|correlation
argument_list|)
return|;
block|}
return|return
literal|false
return|;
case|case
name|FIELD_ACCESS
case|:
specifier|final
name|RexFieldAccess
name|f
init|=
operator|(
name|RexFieldAccess
operator|)
name|e
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|getField
argument_list|()
operator|.
name|getIndex
argument_list|()
operator|==
name|correlation
operator|.
name|field
operator|&&
name|f
operator|.
name|getReferenceExpr
argument_list|()
operator|instanceof
name|RexCorrelVariable
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|RexCorrelVariable
operator|)
name|f
operator|.
name|getReferenceExpr
argument_list|()
operator|)
operator|.
name|id
operator|==
name|correlation
operator|.
name|corr
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|// fall through
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/** Returns whether one type is just a widening of another.    *    *<p>For example:<ul>    *<li>{@code VARCHAR(10)} is a widening of {@code VARCHAR(5)}.    *<li>{@code VARCHAR(10)} is a widening of {@code VARCHAR(10) NOT NULL}.    *</ul>    */
specifier|private
name|boolean
name|isWidening
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|RelDataType
name|type1
parameter_list|)
block|{
return|return
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|type1
operator|.
name|getSqlTypeName
argument_list|()
operator|&&
name|type
operator|.
name|getPrecision
argument_list|()
operator|>=
name|type1
operator|.
name|getPrecision
argument_list|()
return|;
block|}
specifier|public
name|Frame
name|decorrelateRel
parameter_list|(
name|HiveFilter
name|rel
parameter_list|)
throws|throws
name|SemanticException
block|{
block|{
comment|//
comment|// Rewrite logic:
comment|//
comment|// 1. If a LogicalFilter references a correlated field in its filter
comment|// condition, rewrite the LogicalFilter to be
comment|//   LogicalFilter
comment|//     LogicalJoin(cross product)
comment|//       OriginalFilterInput
comment|//       ValueGenerator(produces distinct sets of correlated variables)
comment|// and rewrite the correlated fieldAccess in the filter condition to
comment|// reference the LogicalJoin output.
comment|//
comment|// 2. If LogicalFilter does not reference correlated variables, simply
comment|// rewrite the filter condition using new input.
comment|//
specifier|final
name|RelNode
name|oldInput
init|=
name|rel
operator|.
name|getInput
argument_list|()
decl_stmt|;
name|Frame
name|frame
init|=
name|getInvoke
argument_list|(
name|oldInput
argument_list|,
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|frame
operator|==
literal|null
condition|)
block|{
comment|// If input has not been rewritten, do not rewrite this rel.
return|return
literal|null
return|;
block|}
comment|// If this LogicalFilter has correlated reference, create value generator
comment|// and produce the correlated variables in the new output.
if|if
condition|(
name|cm
operator|.
name|mapRefRelToCorRef
operator|.
name|containsKey
argument_list|(
name|rel
argument_list|)
condition|)
block|{
name|frame
operator|=
name|decorrelateInputWithValueGenerator
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
comment|// Replace the filter expression to reference output of the join
comment|// Map filter to the new filter over join
name|relBuilder
operator|.
name|push
argument_list|(
name|frame
operator|.
name|r
argument_list|)
operator|.
name|filter
argument_list|(
name|decorrelateExpr
argument_list|(
name|rel
operator|.
name|getCondition
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Filter does not change the input ordering.
comment|// Filter rel does not permute the input.
comment|// All corvars produced by filter will have the same output positions in the
comment|// input rel.
return|return
name|register
argument_list|(
name|rel
argument_list|,
name|relBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|frame
operator|.
name|oldToNewOutputs
argument_list|,
name|frame
operator|.
name|corDefOutputs
argument_list|)
return|;
block|}
block|}
comment|/**    * Rewrite LogicalFilter.    *    * @param rel the filter rel to rewrite    */
specifier|public
name|Frame
name|decorrelateRel
parameter_list|(
name|LogicalFilter
name|rel
parameter_list|)
block|{
comment|//
comment|// Rewrite logic:
comment|//
comment|// 1. If a LogicalFilter references a correlated field in its filter
comment|// condition, rewrite the LogicalFilter to be
comment|//   LogicalFilter
comment|//     LogicalJoin(cross product)
comment|//       OriginalFilterInput
comment|//       ValueGenerator(produces distinct sets of correlated variables)
comment|// and rewrite the correlated fieldAccess in the filter condition to
comment|// reference the LogicalJoin output.
comment|//
comment|// 2. If LogicalFilter does not reference correlated variables, simply
comment|// rewrite the filter condition using new input.
comment|//
specifier|final
name|RelNode
name|oldInput
init|=
name|rel
operator|.
name|getInput
argument_list|()
decl_stmt|;
name|Frame
name|frame
init|=
name|getInvoke
argument_list|(
name|oldInput
argument_list|,
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|frame
operator|==
literal|null
condition|)
block|{
comment|// If input has not been rewritten, do not rewrite this rel.
return|return
literal|null
return|;
block|}
comment|// If this LogicalFilter has correlated reference, create value generator
comment|// and produce the correlated variables in the new output.
if|if
condition|(
name|cm
operator|.
name|mapRefRelToCorRef
operator|.
name|containsKey
argument_list|(
name|rel
argument_list|)
condition|)
block|{
name|frame
operator|=
name|decorrelateInputWithValueGenerator
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
comment|// Replace the filter expression to reference output of the join
comment|// Map filter to the new filter over join
name|relBuilder
operator|.
name|push
argument_list|(
name|frame
operator|.
name|r
argument_list|)
operator|.
name|filter
argument_list|(
name|decorrelateExpr
argument_list|(
name|rel
operator|.
name|getCondition
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Filter does not change the input ordering.
comment|// Filter rel does not permute the input.
comment|// All corvars produced by filter will have the same output positions in the
comment|// input rel.
return|return
name|register
argument_list|(
name|rel
argument_list|,
name|relBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|frame
operator|.
name|oldToNewOutputs
argument_list|,
name|frame
operator|.
name|corDefOutputs
argument_list|)
return|;
block|}
comment|/**    * Rewrite Correlator into a left outer join.    *    * @param rel Correlator    */
specifier|public
name|Frame
name|decorrelateRel
parameter_list|(
name|LogicalCorrelate
name|rel
parameter_list|)
block|{
comment|//
comment|// Rewrite logic:
comment|//
comment|// The original left input will be joined with the new right input that
comment|// has generated correlated variables propagated up. For any generated
comment|// cor vars that are not used in the join key, pass them along to be
comment|// joined later with the CorrelatorRels that produce them.
comment|//
comment|// the right input to Correlator should produce correlated variables
specifier|final
name|RelNode
name|oldLeft
init|=
name|rel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|oldRight
init|=
name|rel
operator|.
name|getInput
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|Frame
name|leftFrame
init|=
name|getInvoke
argument_list|(
name|oldLeft
argument_list|,
name|rel
argument_list|)
decl_stmt|;
specifier|final
name|Frame
name|rightFrame
init|=
name|getInvoke
argument_list|(
name|oldRight
argument_list|,
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftFrame
operator|==
literal|null
operator|||
name|rightFrame
operator|==
literal|null
condition|)
block|{
comment|// If any input has not been rewritten, do not rewrite this rel.
return|return
literal|null
return|;
block|}
if|if
condition|(
name|rightFrame
operator|.
name|corDefOutputs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
assert|assert
name|rel
operator|.
name|getRequiredColumns
argument_list|()
operator|.
name|cardinality
argument_list|()
operator|<=
name|rightFrame
operator|.
name|corDefOutputs
operator|.
name|keySet
argument_list|()
operator|.
name|size
argument_list|()
assert|;
comment|// Change correlator rel into a join.
comment|// Join all the correlated variables produced by this correlator rel
comment|// with the values generated and propagated from the right input
specifier|final
name|SortedMap
argument_list|<
name|CorDef
argument_list|,
name|Integer
argument_list|>
name|corDefOutputs
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|rightFrame
operator|.
name|corDefOutputs
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|conditions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|newLeftOutput
init|=
name|leftFrame
operator|.
name|r
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|int
name|newLeftFieldCount
init|=
name|newLeftOutput
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|newRightOutput
init|=
name|rightFrame
operator|.
name|r
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|CorDef
argument_list|,
name|Integer
argument_list|>
name|rightOutput
range|:
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|corDefOutputs
operator|.
name|entrySet
argument_list|()
argument_list|)
control|)
block|{
specifier|final
name|CorDef
name|corDef
init|=
name|rightOutput
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|corDef
operator|.
name|corr
operator|.
name|equals
argument_list|(
name|rel
operator|.
name|getCorrelationId
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
specifier|final
name|int
name|newLeftPos
init|=
name|leftFrame
operator|.
name|oldToNewOutputs
operator|.
name|get
argument_list|(
name|corDef
operator|.
name|field
argument_list|)
decl_stmt|;
specifier|final
name|int
name|newRightPos
init|=
name|rightOutput
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|conditions
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|RexInputRef
operator|.
name|of
argument_list|(
name|newLeftPos
argument_list|,
name|newLeftOutput
argument_list|)
argument_list|,
operator|new
name|RexInputRef
argument_list|(
name|newLeftFieldCount
operator|+
name|newRightPos
argument_list|,
name|newRightOutput
operator|.
name|get
argument_list|(
name|newRightPos
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// remove this cor var from output position mapping
name|corDefOutputs
operator|.
name|remove
argument_list|(
name|corDef
argument_list|)
expr_stmt|;
block|}
comment|// Update the output position for the cor vars: only pass on the cor
comment|// vars that are not used in the join key.
for|for
control|(
name|CorDef
name|corDef
range|:
name|corDefOutputs
operator|.
name|keySet
argument_list|()
control|)
block|{
name|int
name|newPos
init|=
name|corDefOutputs
operator|.
name|get
argument_list|(
name|corDef
argument_list|)
operator|+
name|newLeftFieldCount
decl_stmt|;
name|corDefOutputs
operator|.
name|put
argument_list|(
name|corDef
argument_list|,
name|newPos
argument_list|)
expr_stmt|;
block|}
comment|// then add any cor var from the left input. Do not need to change
comment|// output positions.
name|corDefOutputs
operator|.
name|putAll
argument_list|(
name|leftFrame
operator|.
name|corDefOutputs
argument_list|)
expr_stmt|;
comment|// Create the mapping between the output of the old correlation rel
comment|// and the new join rel
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|mapOldToNewOutputs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|oldLeftFieldCount
init|=
name|oldLeft
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|oldRightFieldCount
init|=
name|oldRight
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
assert|assert
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|==
name|oldLeftFieldCount
operator|+
name|oldRightFieldCount
assert|;
comment|// Left input positions are not changed.
name|mapOldToNewOutputs
operator|.
name|putAll
argument_list|(
name|leftFrame
operator|.
name|oldToNewOutputs
argument_list|)
expr_stmt|;
comment|// Right input positions are shifted by newLeftFieldCount.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|oldRightFieldCount
condition|;
name|i
operator|++
control|)
block|{
name|mapOldToNewOutputs
operator|.
name|put
argument_list|(
name|i
operator|+
name|oldLeftFieldCount
argument_list|,
name|rightFrame
operator|.
name|oldToNewOutputs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|+
name|newLeftFieldCount
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RexNode
name|condition
init|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|conditions
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|RelNode
name|newJoin
init|=
name|LogicalJoin
operator|.
name|create
argument_list|(
name|leftFrame
operator|.
name|r
argument_list|,
name|rightFrame
operator|.
name|r
argument_list|,
name|condition
argument_list|,
name|ImmutableSet
operator|.
expr|<
name|CorrelationId
operator|>
name|of
argument_list|()
argument_list|,
name|rel
operator|.
name|getJoinType
argument_list|()
operator|.
name|toJoinType
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|register
argument_list|(
name|rel
argument_list|,
name|newJoin
argument_list|,
name|mapOldToNewOutputs
argument_list|,
name|corDefOutputs
argument_list|)
return|;
block|}
specifier|public
name|Frame
name|decorrelateRel
parameter_list|(
name|HiveJoin
name|rel
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|//
comment|// Rewrite logic:
comment|//
comment|// 1. rewrite join condition.
comment|// 2. map output positions and produce cor vars if any.
comment|//
specifier|final
name|RelNode
name|oldLeft
init|=
name|rel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|oldRight
init|=
name|rel
operator|.
name|getInput
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|Frame
name|leftFrame
init|=
name|getInvoke
argument_list|(
name|oldLeft
argument_list|,
name|rel
argument_list|)
decl_stmt|;
specifier|final
name|Frame
name|rightFrame
init|=
name|getInvoke
argument_list|(
name|oldRight
argument_list|,
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftFrame
operator|==
literal|null
operator|||
name|rightFrame
operator|==
literal|null
condition|)
block|{
comment|// If any input has not been rewritten, do not rewrite this rel.
return|return
literal|null
return|;
block|}
specifier|final
name|RelNode
name|newJoin
init|=
name|HiveJoin
operator|.
name|getJoin
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|leftFrame
operator|.
name|r
argument_list|,
name|rightFrame
operator|.
name|r
argument_list|,
name|decorrelateExpr
argument_list|(
name|rel
operator|.
name|getCondition
argument_list|()
argument_list|)
argument_list|,
name|rel
operator|.
name|getJoinType
argument_list|()
argument_list|)
decl_stmt|;
comment|// Create the mapping between the output of the old correlation rel
comment|// and the new join rel
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|mapOldToNewOutputs
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|int
name|oldLeftFieldCount
init|=
name|oldLeft
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|newLeftFieldCount
init|=
name|leftFrame
operator|.
name|r
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|oldRightFieldCount
init|=
name|oldRight
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
assert|assert
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|==
name|oldLeftFieldCount
operator|+
name|oldRightFieldCount
assert|;
comment|// Left input positions are not changed.
name|mapOldToNewOutputs
operator|.
name|putAll
argument_list|(
name|leftFrame
operator|.
name|oldToNewOutputs
argument_list|)
expr_stmt|;
comment|// Right input positions are shifted by newLeftFieldCount.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|oldRightFieldCount
condition|;
name|i
operator|++
control|)
block|{
name|mapOldToNewOutputs
operator|.
name|put
argument_list|(
name|i
operator|+
name|oldLeftFieldCount
argument_list|,
name|rightFrame
operator|.
name|oldToNewOutputs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|+
name|newLeftFieldCount
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SortedMap
argument_list|<
name|CorDef
argument_list|,
name|Integer
argument_list|>
name|corDefOutputs
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|leftFrame
operator|.
name|corDefOutputs
argument_list|)
decl_stmt|;
comment|// Right input positions are shifted by newLeftFieldCount.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|CorDef
argument_list|,
name|Integer
argument_list|>
name|entry
range|:
name|rightFrame
operator|.
name|corDefOutputs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|corDefOutputs
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
operator|+
name|newLeftFieldCount
argument_list|)
expr_stmt|;
block|}
return|return
name|register
argument_list|(
name|rel
argument_list|,
name|newJoin
argument_list|,
name|mapOldToNewOutputs
argument_list|,
name|corDefOutputs
argument_list|)
return|;
block|}
comment|/**    * Rewrite LogicalJoin.    *    * @param rel LogicalJoin    */
specifier|public
name|Frame
name|decorrelateRel
parameter_list|(
name|LogicalJoin
name|rel
parameter_list|)
block|{
comment|//
comment|// Rewrite logic:
comment|//
comment|// 1. rewrite join condition.
comment|// 2. map output positions and produce cor vars if any.
comment|//
specifier|final
name|RelNode
name|oldLeft
init|=
name|rel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|oldRight
init|=
name|rel
operator|.
name|getInput
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|Frame
name|leftFrame
init|=
name|getInvoke
argument_list|(
name|oldLeft
argument_list|,
name|rel
argument_list|)
decl_stmt|;
specifier|final
name|Frame
name|rightFrame
init|=
name|getInvoke
argument_list|(
name|oldRight
argument_list|,
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftFrame
operator|==
literal|null
operator|||
name|rightFrame
operator|==
literal|null
condition|)
block|{
comment|// If any input has not been rewritten, do not rewrite this rel.
return|return
literal|null
return|;
block|}
specifier|final
name|RelNode
name|newJoin
init|=
name|HiveJoin
operator|.
name|getJoin
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|leftFrame
operator|.
name|r
argument_list|,
name|rightFrame
operator|.
name|r
argument_list|,
name|decorrelateExpr
argument_list|(
name|rel
operator|.
name|getCondition
argument_list|()
argument_list|)
argument_list|,
name|rel
operator|.
name|getJoinType
argument_list|()
argument_list|)
decl_stmt|;
comment|// Create the mapping between the output of the old correlation rel
comment|// and the new join rel
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|mapOldToNewOutputs
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|int
name|oldLeftFieldCount
init|=
name|oldLeft
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|newLeftFieldCount
init|=
name|leftFrame
operator|.
name|r
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|oldRightFieldCount
init|=
name|oldRight
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
assert|assert
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|==
name|oldLeftFieldCount
operator|+
name|oldRightFieldCount
assert|;
comment|// Left input positions are not changed.
name|mapOldToNewOutputs
operator|.
name|putAll
argument_list|(
name|leftFrame
operator|.
name|oldToNewOutputs
argument_list|)
expr_stmt|;
comment|// Right input positions are shifted by newLeftFieldCount.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|oldRightFieldCount
condition|;
name|i
operator|++
control|)
block|{
name|mapOldToNewOutputs
operator|.
name|put
argument_list|(
name|i
operator|+
name|oldLeftFieldCount
argument_list|,
name|rightFrame
operator|.
name|oldToNewOutputs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|+
name|newLeftFieldCount
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SortedMap
argument_list|<
name|CorDef
argument_list|,
name|Integer
argument_list|>
name|corDefOutputs
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|leftFrame
operator|.
name|corDefOutputs
argument_list|)
decl_stmt|;
comment|// Right input positions are shifted by newLeftFieldCount.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|CorDef
argument_list|,
name|Integer
argument_list|>
name|entry
range|:
name|rightFrame
operator|.
name|corDefOutputs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|corDefOutputs
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
operator|+
name|newLeftFieldCount
argument_list|)
expr_stmt|;
block|}
return|return
name|register
argument_list|(
name|rel
argument_list|,
name|newJoin
argument_list|,
name|mapOldToNewOutputs
argument_list|,
name|corDefOutputs
argument_list|)
return|;
block|}
specifier|private
name|RexInputRef
name|getNewForOldInputRef
parameter_list|(
name|RexInputRef
name|oldInputRef
parameter_list|)
block|{
assert|assert
name|currentRel
operator|!=
literal|null
assert|;
name|int
name|oldOrdinal
init|=
name|oldInputRef
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|int
name|newOrdinal
init|=
literal|0
decl_stmt|;
comment|// determine which input rel oldOrdinal references, and adjust
comment|// oldOrdinal to be relative to that input rel
name|RelNode
name|oldInput
init|=
literal|null
decl_stmt|;
for|for
control|(
name|RelNode
name|oldInput0
range|:
name|currentRel
operator|.
name|getInputs
argument_list|()
control|)
block|{
name|RelDataType
name|oldInputType
init|=
name|oldInput0
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|int
name|n
init|=
name|oldInputType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldOrdinal
operator|<
name|n
condition|)
block|{
name|oldInput
operator|=
name|oldInput0
expr_stmt|;
break|break;
block|}
name|RelNode
name|newInput
init|=
name|map
operator|.
name|get
argument_list|(
name|oldInput0
argument_list|)
operator|.
name|r
decl_stmt|;
name|newOrdinal
operator|+=
name|newInput
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
name|oldOrdinal
operator|-=
name|n
expr_stmt|;
block|}
assert|assert
name|oldInput
operator|!=
literal|null
assert|;
specifier|final
name|Frame
name|frame
init|=
name|map
operator|.
name|get
argument_list|(
name|oldInput
argument_list|)
decl_stmt|;
assert|assert
name|frame
operator|!=
literal|null
assert|;
comment|// now oldOrdinal is relative to oldInput
name|int
name|oldLocalOrdinal
init|=
name|oldOrdinal
decl_stmt|;
comment|// figure out the newLocalOrdinal, relative to the newInput.
name|int
name|newLocalOrdinal
init|=
name|oldLocalOrdinal
decl_stmt|;
if|if
condition|(
operator|!
name|frame
operator|.
name|oldToNewOutputs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|newLocalOrdinal
operator|=
name|frame
operator|.
name|oldToNewOutputs
operator|.
name|get
argument_list|(
name|oldLocalOrdinal
argument_list|)
expr_stmt|;
block|}
name|newOrdinal
operator|+=
name|newLocalOrdinal
expr_stmt|;
return|return
operator|new
name|RexInputRef
argument_list|(
name|newOrdinal
argument_list|,
name|frame
operator|.
name|r
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|newLocalOrdinal
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Pulls project above the join from its RHS input. Enforces nullability    * for join output.    *    * @param join          Join    * @param project       Original project as the right-hand input of the join    * @param nullIndicatorPos Position of null indicator    * @return the subtree with the new LogicalProject at the root    */
specifier|private
name|RelNode
name|projectJoinOutputWithNullability
parameter_list|(
name|LogicalJoin
name|join
parameter_list|,
name|LogicalProject
name|project
parameter_list|,
name|int
name|nullIndicatorPos
parameter_list|)
block|{
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|join
operator|.
name|getCluster
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|left
init|=
name|join
operator|.
name|getLeft
argument_list|()
decl_stmt|;
specifier|final
name|JoinRelType
name|joinType
init|=
name|join
operator|.
name|getJoinType
argument_list|()
decl_stmt|;
name|RexInputRef
name|nullIndicator
init|=
operator|new
name|RexInputRef
argument_list|(
name|nullIndicatorPos
argument_list|,
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|join
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|nullIndicatorPos
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
comment|// now create the new project
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|newProjExprs
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// project everything from the LHS and then those from the original
comment|// projRel
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|leftInputFields
init|=
name|left
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftInputFields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|newProjExprs
operator|.
name|add
argument_list|(
name|RexInputRef
operator|.
name|of2
argument_list|(
name|i
argument_list|,
name|leftInputFields
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Marked where the projected expr is coming from so that the types will
comment|// become nullable for the original projections which are now coming out
comment|// of the nullable side of the OJ.
name|boolean
name|projectPulledAboveLeftCorrelator
init|=
name|joinType
operator|.
name|generatesNullsOnRight
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
name|pair
range|:
name|project
operator|.
name|getNamedProjects
argument_list|()
control|)
block|{
name|RexNode
name|newProjExpr
init|=
name|removeCorrelationExpr
argument_list|(
name|pair
operator|.
name|left
argument_list|,
name|projectPulledAboveLeftCorrelator
argument_list|,
name|nullIndicator
argument_list|)
decl_stmt|;
name|newProjExprs
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|newProjExpr
argument_list|,
name|pair
operator|.
name|right
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|RelOptUtil
operator|.
name|createProject
argument_list|(
name|join
argument_list|,
name|newProjExprs
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Pulls a {@link Project} above a {@link Correlate} from its RHS input.    * Enforces nullability for join output.    *    * @param correlate  Correlate    * @param project the original project as the RHS input of the join    * @param isCount Positions which are calls to the<code>COUNT</code>    *                aggregation function    * @return the subtree with the new LogicalProject at the root    */
specifier|private
name|RelNode
name|aggregateCorrelatorOutput
parameter_list|(
name|Correlate
name|correlate
parameter_list|,
name|LogicalProject
name|project
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|isCount
parameter_list|)
block|{
specifier|final
name|RelNode
name|left
init|=
name|correlate
operator|.
name|getLeft
argument_list|()
decl_stmt|;
specifier|final
name|JoinRelType
name|joinType
init|=
name|correlate
operator|.
name|getJoinType
argument_list|()
operator|.
name|toJoinType
argument_list|()
decl_stmt|;
comment|// now create the new project
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|newProjects
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// Project everything from the LHS and then those from the original
comment|// project
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|leftInputFields
init|=
name|left
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftInputFields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|newProjects
operator|.
name|add
argument_list|(
name|RexInputRef
operator|.
name|of2
argument_list|(
name|i
argument_list|,
name|leftInputFields
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Marked where the projected expr is coming from so that the types will
comment|// become nullable for the original projections which are now coming out
comment|// of the nullable side of the OJ.
name|boolean
name|projectPulledAboveLeftCorrelator
init|=
name|joinType
operator|.
name|generatesNullsOnRight
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
name|pair
range|:
name|project
operator|.
name|getNamedProjects
argument_list|()
control|)
block|{
name|RexNode
name|newProjExpr
init|=
name|removeCorrelationExpr
argument_list|(
name|pair
operator|.
name|left
argument_list|,
name|projectPulledAboveLeftCorrelator
argument_list|,
name|isCount
argument_list|)
decl_stmt|;
name|newProjects
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|newProjExpr
argument_list|,
name|pair
operator|.
name|right
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|RelOptUtil
operator|.
name|createProject
argument_list|(
name|correlate
argument_list|,
name|newProjects
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Checks whether the correlations in projRel and filter are related to    * the correlated variables provided by corRel.    *    * @param correlate    Correlate    * @param project   The original Project as the RHS input of the join    * @param filter    Filter    * @param correlatedJoinKeys Correlated join keys    * @return true if filter and proj only references corVar provided by corRel    */
specifier|private
name|boolean
name|checkCorVars
parameter_list|(
name|LogicalCorrelate
name|correlate
parameter_list|,
name|LogicalProject
name|project
parameter_list|,
name|LogicalFilter
name|filter
parameter_list|,
name|List
argument_list|<
name|RexFieldAccess
argument_list|>
name|correlatedJoinKeys
parameter_list|)
block|{
if|if
condition|(
name|filter
operator|!=
literal|null
condition|)
block|{
assert|assert
name|correlatedJoinKeys
operator|!=
literal|null
assert|;
comment|// check that all correlated refs in the filter condition are
comment|// used in the join(as field access).
name|Set
argument_list|<
name|CorRef
argument_list|>
name|corVarInFilter
init|=
name|Sets
operator|.
name|newHashSet
argument_list|(
name|cm
operator|.
name|mapRefRelToCorRef
operator|.
name|get
argument_list|(
name|filter
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|RexFieldAccess
name|correlatedJoinKey
range|:
name|correlatedJoinKeys
control|)
block|{
name|corVarInFilter
operator|.
name|remove
argument_list|(
name|cm
operator|.
name|mapFieldAccessToCorRef
operator|.
name|get
argument_list|(
name|correlatedJoinKey
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|corVarInFilter
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Check that the correlated variables referenced in these
comment|// comparisons do come from the correlatorRel.
name|corVarInFilter
operator|.
name|addAll
argument_list|(
name|cm
operator|.
name|mapRefRelToCorRef
operator|.
name|get
argument_list|(
name|filter
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|CorRef
name|corVar
range|:
name|corVarInFilter
control|)
block|{
if|if
condition|(
name|cm
operator|.
name|mapCorToCorRel
operator|.
name|get
argument_list|(
name|corVar
operator|.
name|corr
argument_list|)
operator|!=
name|correlate
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
comment|// if project has any correlated reference, make sure they are also
comment|// provided by the current correlate. They will be projected out of the LHS
comment|// of the correlate.
if|if
condition|(
operator|(
name|project
operator|!=
literal|null
operator|)
operator|&&
name|cm
operator|.
name|mapRefRelToCorRef
operator|.
name|containsKey
argument_list|(
name|project
argument_list|)
condition|)
block|{
for|for
control|(
name|CorRef
name|corVar
range|:
name|cm
operator|.
name|mapRefRelToCorRef
operator|.
name|get
argument_list|(
name|project
argument_list|)
control|)
block|{
if|if
condition|(
name|cm
operator|.
name|mapCorToCorRel
operator|.
name|get
argument_list|(
name|corVar
operator|.
name|corr
argument_list|)
operator|!=
name|correlate
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Remove correlated variables from the tree at root corRel    *    * @param correlate Correlator    */
specifier|private
name|void
name|removeCorVarFromTree
parameter_list|(
name|LogicalCorrelate
name|correlate
parameter_list|)
block|{
if|if
condition|(
name|cm
operator|.
name|mapCorToCorRel
operator|.
name|get
argument_list|(
name|correlate
operator|.
name|getCorrelationId
argument_list|()
argument_list|)
operator|==
name|correlate
condition|)
block|{
name|cm
operator|.
name|mapCorToCorRel
operator|.
name|remove
argument_list|(
name|correlate
operator|.
name|getCorrelationId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Projects all {@code input} output fields plus the additional expressions.    *    * @param input        Input relational expression    * @param additionalExprs Additional expressions and names    * @return the new LogicalProject    */
specifier|private
name|RelNode
name|createProjectWithAdditionalExprs
parameter_list|(
name|RelNode
name|input
parameter_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|additionalExprs
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fieldList
init|=
name|input
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|projects
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|RelDataTypeField
argument_list|>
name|field
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|fieldList
argument_list|)
control|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
operator|(
name|RexNode
operator|)
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|e
operator|.
name|getType
argument_list|()
argument_list|,
name|field
operator|.
name|i
argument_list|)
argument_list|,
name|field
operator|.
name|e
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|projects
operator|.
name|addAll
argument_list|(
name|additionalExprs
argument_list|)
expr_stmt|;
return|return
name|RelOptUtil
operator|.
name|createProject
argument_list|(
name|input
argument_list|,
name|projects
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/* Returns an immutable map with the identity [0: 0, .., count-1: count-1]. */
specifier|static
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|identityMap
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|builder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Registers a relational expression and the relational expression it became    * after decorrelation. */
name|Frame
name|register
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelNode
name|newRel
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|oldToNewOutputs
parameter_list|,
name|SortedMap
argument_list|<
name|CorDef
argument_list|,
name|Integer
argument_list|>
name|corDefOutputs
parameter_list|)
block|{
specifier|final
name|Frame
name|frame
init|=
operator|new
name|Frame
argument_list|(
name|rel
argument_list|,
name|newRel
argument_list|,
name|corDefOutputs
argument_list|,
name|oldToNewOutputs
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|frame
argument_list|)
expr_stmt|;
return|return
name|frame
return|;
block|}
specifier|static
name|boolean
name|allLessThan
parameter_list|(
name|Collection
argument_list|<
name|Integer
argument_list|>
name|integers
parameter_list|,
name|int
name|limit
parameter_list|,
name|Litmus
name|ret
parameter_list|)
block|{
for|for
control|(
name|int
name|value
range|:
name|integers
control|)
block|{
if|if
condition|(
name|value
operator|>=
name|limit
condition|)
block|{
return|return
name|ret
operator|.
name|fail
argument_list|(
literal|"out of range; value: "
operator|+
name|value
operator|+
literal|", limit: "
operator|+
name|limit
argument_list|)
return|;
block|}
block|}
return|return
name|ret
operator|.
name|succeed
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|RelNode
name|stripHep
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
if|if
condition|(
name|rel
operator|instanceof
name|HepRelVertex
condition|)
block|{
name|HepRelVertex
name|hepRelVertex
init|=
operator|(
name|HepRelVertex
operator|)
name|rel
decl_stmt|;
name|rel
operator|=
name|hepRelVertex
operator|.
name|getCurrentRel
argument_list|()
expr_stmt|;
block|}
return|return
name|rel
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/** Shuttle that decorrelates. */
specifier|private
class|class
name|DecorrelateRexShuttle
extends|extends
name|RexShuttle
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
name|int
name|newInputOutputOffset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RelNode
name|input
range|:
name|currentRel
operator|.
name|getInputs
argument_list|()
control|)
block|{
specifier|final
name|Frame
name|frame
init|=
name|map
operator|.
name|get
argument_list|(
name|input
argument_list|)
decl_stmt|;
if|if
condition|(
name|frame
operator|!=
literal|null
condition|)
block|{
comment|// try to find in this input rel the position of cor var
specifier|final
name|CorRef
name|corRef
init|=
name|cm
operator|.
name|mapFieldAccessToCorRef
operator|.
name|get
argument_list|(
name|fieldAccess
argument_list|)
decl_stmt|;
if|if
condition|(
name|corRef
operator|!=
literal|null
condition|)
block|{
name|Integer
name|newInputPos
init|=
name|frame
operator|.
name|corDefOutputs
operator|.
name|get
argument_list|(
name|corRef
operator|.
name|def
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|newInputPos
operator|!=
literal|null
condition|)
block|{
comment|// This input rel does produce the cor var referenced.
comment|// Assume fieldAccess has the correct type info.
return|return
operator|new
name|RexInputRef
argument_list|(
name|newInputPos
operator|+
name|newInputOutputOffset
argument_list|,
name|frame
operator|.
name|r
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|newInputPos
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|// this input rel does not produce the cor var needed
name|newInputOutputOffset
operator|+=
name|frame
operator|.
name|r
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// this input rel is not rewritten
name|newInputOutputOffset
operator|+=
name|input
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|fieldAccess
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
specifier|final
name|RexInputRef
name|ref
init|=
name|getNewForOldInputRef
argument_list|(
name|inputRef
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref
operator|.
name|getIndex
argument_list|()
operator|==
name|inputRef
operator|.
name|getIndex
argument_list|()
operator|&&
name|ref
operator|.
name|getType
argument_list|()
operator|==
name|inputRef
operator|.
name|getType
argument_list|()
condition|)
block|{
return|return
name|inputRef
return|;
comment|// re-use old object, to prevent needless expr cloning
block|}
return|return
name|ref
return|;
block|}
block|}
comment|/** Shuttle that removes correlations. */
specifier|private
class|class
name|RemoveCorrelationRexShuttle
extends|extends
name|RexShuttle
block|{
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
specifier|final
name|RelDataTypeFactory
name|typeFactory
decl_stmt|;
specifier|final
name|boolean
name|projectPulledAboveLeftCorrelator
decl_stmt|;
specifier|final
name|RexInputRef
name|nullIndicator
decl_stmt|;
specifier|final
name|ImmutableSet
argument_list|<
name|Integer
argument_list|>
name|isCount
decl_stmt|;
specifier|public
name|RemoveCorrelationRexShuttle
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|boolean
name|projectPulledAboveLeftCorrelator
parameter_list|,
name|RexInputRef
name|nullIndicator
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|isCount
parameter_list|)
block|{
name|this
operator|.
name|projectPulledAboveLeftCorrelator
operator|=
name|projectPulledAboveLeftCorrelator
expr_stmt|;
name|this
operator|.
name|nullIndicator
operator|=
name|nullIndicator
expr_stmt|;
comment|// may be null
name|this
operator|.
name|isCount
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|isCount
argument_list|)
expr_stmt|;
name|this
operator|.
name|rexBuilder
operator|=
name|rexBuilder
expr_stmt|;
name|this
operator|.
name|typeFactory
operator|=
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
expr_stmt|;
block|}
specifier|private
name|RexNode
name|createCaseExpression
parameter_list|(
name|RexInputRef
name|nullInputRef
parameter_list|,
name|RexLiteral
name|lit
parameter_list|,
name|RexNode
name|rexNode
parameter_list|)
block|{
name|RexNode
index|[]
name|caseOperands
init|=
operator|new
name|RexNode
index|[
literal|3
index|]
decl_stmt|;
comment|// Construct a CASE expression to handle the null indicator.
comment|//
comment|// This also covers the case where a left correlated subquery
comment|// projects fields from outer relation. Since LOJ cannot produce
comment|// nulls on the LHS, the projection now need to make a nullable LHS
comment|// reference using a nullability indicator. If this this indicator
comment|// is null, it means the subquery does not produce any value. As a
comment|// result, any RHS ref by this usbquery needs to produce null value.
comment|// WHEN indicator IS NULL
name|caseOperands
index|[
literal|0
index|]
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|,
operator|new
name|RexInputRef
argument_list|(
name|nullInputRef
operator|.
name|getIndex
argument_list|()
argument_list|,
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|nullInputRef
operator|.
name|getType
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// THEN CAST(NULL AS newInputTypeNullable)
name|caseOperands
index|[
literal|1
index|]
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|rexNode
operator|.
name|getType
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|,
name|lit
argument_list|)
expr_stmt|;
comment|// ELSE cast (newInput AS newInputTypeNullable) END
name|caseOperands
index|[
literal|2
index|]
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|rexNode
operator|.
name|getType
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|,
name|rexNode
argument_list|)
expr_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|caseOperands
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
if|if
condition|(
name|cm
operator|.
name|mapFieldAccessToCorRef
operator|.
name|containsKey
argument_list|(
name|fieldAccess
argument_list|)
condition|)
block|{
comment|// if it is a corVar, change it to be input ref.
name|CorRef
name|corVar
init|=
name|cm
operator|.
name|mapFieldAccessToCorRef
operator|.
name|get
argument_list|(
name|fieldAccess
argument_list|)
decl_stmt|;
comment|// corVar offset should point to the leftInput of currentRel,
comment|// which is the Correlator.
name|RexNode
name|newRexNode
init|=
operator|new
name|RexInputRef
argument_list|(
name|corVar
operator|.
name|field
argument_list|,
name|fieldAccess
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|projectPulledAboveLeftCorrelator
operator|&&
operator|(
name|nullIndicator
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// need to enforce nullability by applying an additional
comment|// cast operator over the transformed expression.
name|newRexNode
operator|=
name|createCaseExpression
argument_list|(
name|nullIndicator
argument_list|,
name|rexBuilder
operator|.
name|constantNull
argument_list|()
argument_list|,
name|newRexNode
argument_list|)
expr_stmt|;
block|}
return|return
name|newRexNode
return|;
block|}
return|return
name|fieldAccess
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
if|if
condition|(
name|currentRel
operator|instanceof
name|LogicalCorrelate
condition|)
block|{
comment|// if this rel references corVar
comment|// and now it needs to be rewritten
comment|// it must have been pulled above the Correlator
comment|// replace the input ref to account for the LHS of the
comment|// Correlator
specifier|final
name|int
name|leftInputFieldCount
init|=
operator|(
operator|(
name|LogicalCorrelate
operator|)
name|currentRel
operator|)
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|RelDataType
name|newType
init|=
name|inputRef
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|projectPulledAboveLeftCorrelator
condition|)
block|{
name|newType
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|newType
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|int
name|pos
init|=
name|inputRef
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|RexInputRef
name|newInputRef
init|=
operator|new
name|RexInputRef
argument_list|(
name|leftInputFieldCount
operator|+
name|pos
argument_list|,
name|newType
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|isCount
operator|!=
literal|null
operator|)
operator|&&
name|isCount
operator|.
name|contains
argument_list|(
name|pos
argument_list|)
condition|)
block|{
return|return
name|createCaseExpression
argument_list|(
name|newInputRef
argument_list|,
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ZERO
argument_list|)
argument_list|,
name|newInputRef
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|newInputRef
return|;
block|}
block|}
return|return
name|inputRef
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitLiteral
parameter_list|(
name|RexLiteral
name|literal
parameter_list|)
block|{
comment|// Use nullIndicator to decide whether to project null.
comment|// Do nothing if the literal is null.
if|if
condition|(
operator|!
name|RexUtil
operator|.
name|isNull
argument_list|(
name|literal
argument_list|)
operator|&&
name|projectPulledAboveLeftCorrelator
operator|&&
operator|(
name|nullIndicator
operator|!=
literal|null
operator|)
condition|)
block|{
return|return
name|createCaseExpression
argument_list|(
name|nullIndicator
argument_list|,
name|rexBuilder
operator|.
name|constantNull
argument_list|()
argument_list|,
name|literal
argument_list|)
return|;
block|}
return|return
name|literal
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitCall
parameter_list|(
specifier|final
name|RexCall
name|call
parameter_list|)
block|{
name|RexNode
name|newCall
decl_stmt|;
name|boolean
index|[]
name|update
init|=
block|{
literal|false
block|}
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|clonedOperands
init|=
name|visitList
argument_list|(
name|call
operator|.
name|operands
argument_list|,
name|update
argument_list|)
decl_stmt|;
if|if
condition|(
name|update
index|[
literal|0
index|]
condition|)
block|{
name|SqlOperator
name|operator
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
name|boolean
name|isSpecialCast
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|operator
operator|instanceof
name|SqlFunction
condition|)
block|{
name|SqlFunction
name|function
init|=
operator|(
name|SqlFunction
operator|)
name|operator
decl_stmt|;
if|if
condition|(
name|function
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|CAST
condition|)
block|{
if|if
condition|(
name|call
operator|.
name|operands
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
name|isSpecialCast
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
specifier|final
name|RelDataType
name|newType
decl_stmt|;
if|if
condition|(
operator|!
name|isSpecialCast
condition|)
block|{
comment|// TODO: ideally this only needs to be called if the result
comment|// type will also change. However, since that requires
comment|// support from type inference rules to tell whether a rule
comment|// decides return type based on input types, for now all
comment|// operators will be recreated with new type if any operand
comment|// changed, unless the operator has "built-in" type.
name|newType
operator|=
name|rexBuilder
operator|.
name|deriveReturnType
argument_list|(
name|operator
argument_list|,
name|clonedOperands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Use the current return type when creating a new call, for
comment|// operators with return type built into the operator
comment|// definition, and with no type inference rules, such as
comment|// cast function with less than 2 operands.
comment|// TODO: Comments in RexShuttle.visitCall() mention other
comment|// types in this category. Need to resolve those together
comment|// and preferably in the base class RexShuttle.
name|newType
operator|=
name|call
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
name|newCall
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|newType
argument_list|,
name|operator
argument_list|,
name|clonedOperands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newCall
operator|=
name|call
expr_stmt|;
block|}
if|if
condition|(
name|projectPulledAboveLeftCorrelator
operator|&&
operator|(
name|nullIndicator
operator|!=
literal|null
operator|)
condition|)
block|{
return|return
name|createCaseExpression
argument_list|(
name|nullIndicator
argument_list|,
name|rexBuilder
operator|.
name|constantNull
argument_list|()
argument_list|,
name|newCall
argument_list|)
return|;
block|}
return|return
name|newCall
return|;
block|}
block|}
comment|/**    * Rule to remove single_value rel. For cases like    *    *<blockquote>AggRel single_value proj/filter/agg/ join on unique LHS key    * AggRel single group</blockquote>    */
specifier|private
specifier|final
class|class
name|RemoveSingleAggregateRule
extends|extends
name|RelOptRule
block|{
specifier|public
name|RemoveSingleAggregateRule
parameter_list|()
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
name|LogicalAggregate
name|singleAggregate
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|LogicalProject
name|project
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|LogicalAggregate
name|aggregate
init|=
name|call
operator|.
name|rel
argument_list|(
literal|2
argument_list|)
decl_stmt|;
comment|// check singleAggRel is single_value agg
if|if
condition|(
operator|(
operator|!
name|singleAggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|||
operator|(
name|singleAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|)
operator|||
operator|!
operator|(
name|singleAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getAggregation
argument_list|()
operator|instanceof
name|SqlSingleValueAggFunction
operator|)
condition|)
block|{
return|return;
block|}
comment|// check projRel only projects one expression
comment|// check this project only projects one expression, i.e. scalar
comment|// subqueries.
name|List
argument_list|<
name|RexNode
argument_list|>
name|projExprs
init|=
name|project
operator|.
name|getProjects
argument_list|()
decl_stmt|;
if|if
condition|(
name|projExprs
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
return|return;
block|}
comment|// check the input to projRel is an aggregate on the entire input
if|if
condition|(
operator|!
name|aggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// singleAggRel produces a nullable type, so create the new
comment|// projection that casts proj expr to a nullable type.
specifier|final
name|RelOptCluster
name|cluster
init|=
name|project
operator|.
name|getCluster
argument_list|()
decl_stmt|;
name|RelNode
name|newProject
init|=
name|RelOptUtil
operator|.
name|createProject
argument_list|(
name|aggregate
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|projExprs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|,
name|projExprs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|newProject
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Planner rule that removes correlations for scalar projects. */
specifier|private
specifier|final
class|class
name|RemoveCorrelationForScalarProjectRule
extends|extends
name|RelOptRule
block|{
specifier|public
name|RemoveCorrelationForScalarProjectRule
parameter_list|()
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|LogicalCorrelate
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|RelNode
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|,
name|operand
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|RelNode
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|LogicalCorrelate
name|correlate
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|left
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|LogicalAggregate
name|aggregate
init|=
name|call
operator|.
name|rel
argument_list|(
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|LogicalProject
name|project
init|=
name|call
operator|.
name|rel
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|RelNode
name|right
init|=
name|call
operator|.
name|rel
argument_list|(
literal|4
argument_list|)
decl_stmt|;
specifier|final
name|RelOptCluster
name|cluster
init|=
name|correlate
operator|.
name|getCluster
argument_list|()
decl_stmt|;
name|setCurrent
argument_list|(
name|call
operator|.
name|getPlanner
argument_list|()
operator|.
name|getRoot
argument_list|()
argument_list|,
name|correlate
argument_list|)
expr_stmt|;
comment|// Check for this pattern.
comment|// The pattern matching could be simplified if rules can be applied
comment|// during decorrelation.
comment|//
comment|// CorrelateRel(left correlation, condition = true)
comment|//   LeftInputRel
comment|//   LogicalAggregate (groupby (0) single_value())
comment|//     LogicalProject-A (may reference coVar)
comment|//       RightInputRel
specifier|final
name|JoinRelType
name|joinType
init|=
name|correlate
operator|.
name|getJoinType
argument_list|()
operator|.
name|toJoinType
argument_list|()
decl_stmt|;
comment|// corRel.getCondition was here, however Correlate was updated so it
comment|// never includes a join condition. The code was not modified for brevity.
name|RexNode
name|joinCond
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|joinType
operator|!=
name|JoinRelType
operator|.
name|LEFT
operator|)
operator|||
operator|(
name|joinCond
operator|!=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
operator|)
condition|)
block|{
return|return;
block|}
comment|// check that the agg is of the following type:
comment|// doing a single_value() on the entire input
if|if
condition|(
operator|(
operator|!
name|aggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|||
operator|(
name|aggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|)
operator|||
operator|!
operator|(
name|aggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getAggregation
argument_list|()
operator|instanceof
name|SqlSingleValueAggFunction
operator|)
condition|)
block|{
return|return;
block|}
comment|// check this project only projects one expression, i.e. scalar
comment|// subqueries.
if|if
condition|(
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
return|return;
block|}
name|int
name|nullIndicatorPos
decl_stmt|;
if|if
condition|(
operator|(
name|right
operator|instanceof
name|LogicalFilter
operator|)
operator|&&
name|cm
operator|.
name|mapRefRelToCorRef
operator|.
name|containsKey
argument_list|(
name|right
argument_list|)
condition|)
block|{
comment|// rightInputRel has this shape:
comment|//
comment|//       LogicalFilter (references corvar)
comment|//         FilterInputRel
comment|// If rightInputRel is a filter and contains correlated
comment|// reference, make sure the correlated keys in the filter
comment|// condition forms a unique key of the RHS.
name|LogicalFilter
name|filter
init|=
operator|(
name|LogicalFilter
operator|)
name|right
decl_stmt|;
name|right
operator|=
name|filter
operator|.
name|getInput
argument_list|()
expr_stmt|;
assert|assert
name|right
operator|instanceof
name|HepRelVertex
assert|;
name|right
operator|=
operator|(
operator|(
name|HepRelVertex
operator|)
name|right
operator|)
operator|.
name|getCurrentRel
argument_list|()
expr_stmt|;
comment|// check filter input contains no correlation
if|if
condition|(
name|RelOptUtil
operator|.
name|getVariablesUsed
argument_list|(
name|right
argument_list|)
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return;
block|}
comment|// extract the correlation out of the filter
comment|// First breaking up the filter conditions into equality
comment|// comparisons between rightJoinKeys(from the original
comment|// filterInputRel) and correlatedJoinKeys. correlatedJoinKeys
comment|// can be expressions, while rightJoinKeys need to be input
comment|// refs. These comparisons are AND'ed together.
name|List
argument_list|<
name|RexNode
argument_list|>
name|tmpRightJoinKeys
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|correlatedJoinKeys
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|RelOptUtil
operator|.
name|splitCorrelatedFilterCondition
argument_list|(
name|filter
argument_list|,
name|tmpRightJoinKeys
argument_list|,
name|correlatedJoinKeys
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// check that the columns referenced in these comparisons form
comment|// an unique key of the filterInputRel
specifier|final
name|List
argument_list|<
name|RexInputRef
argument_list|>
name|rightJoinKeys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|key
range|:
name|tmpRightJoinKeys
control|)
block|{
assert|assert
name|key
operator|instanceof
name|RexInputRef
assert|;
name|rightJoinKeys
operator|.
name|add
argument_list|(
operator|(
name|RexInputRef
operator|)
name|key
argument_list|)
expr_stmt|;
block|}
comment|// check that the columns referenced in rightJoinKeys form an
comment|// unique key of the filterInputRel
if|if
condition|(
name|rightJoinKeys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// The join filters out the nulls.  So, it's ok if there are
comment|// nulls in the join keys.
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|RelMdUtil
operator|.
name|areColumnsDefinitelyUniqueWhenNullsFiltered
argument_list|(
name|mq
argument_list|,
name|right
argument_list|,
name|rightJoinKeys
argument_list|)
condition|)
block|{
comment|//SQL2REL_LOGGER.fine(rightJoinKeys.toString()
comment|//       + "are not unique keys for "
comment|//      + right.toString());
return|return;
block|}
name|RexUtil
operator|.
name|FieldAccessFinder
name|visitor
init|=
operator|new
name|RexUtil
operator|.
name|FieldAccessFinder
argument_list|()
decl_stmt|;
name|RexUtil
operator|.
name|apply
argument_list|(
name|visitor
argument_list|,
name|correlatedJoinKeys
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RexFieldAccess
argument_list|>
name|correlatedKeyList
init|=
name|visitor
operator|.
name|getFieldAccessList
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|checkCorVars
argument_list|(
name|correlate
argument_list|,
name|project
argument_list|,
name|filter
argument_list|,
name|correlatedKeyList
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Change the plan to this structure.
comment|// Note that the aggregateRel is removed.
comment|//
comment|// LogicalProject-A' (replace corvar to input ref from the LogicalJoin)
comment|//   LogicalJoin (replace corvar to input ref from LeftInputRel)
comment|//     LeftInputRel
comment|//     RightInputRel(oreviously FilterInputRel)
comment|// Change the filter condition into a join condition
name|joinCond
operator|=
name|removeCorrelationExpr
argument_list|(
name|filter
operator|.
name|getCondition
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|nullIndicatorPos
operator|=
name|left
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|+
name|rightJoinKeys
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getIndex
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cm
operator|.
name|mapRefRelToCorRef
operator|.
name|containsKey
argument_list|(
name|project
argument_list|)
condition|)
block|{
comment|// check filter input contains no correlation
if|if
condition|(
name|RelOptUtil
operator|.
name|getVariablesUsed
argument_list|(
name|right
argument_list|)
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|checkCorVars
argument_list|(
name|correlate
argument_list|,
name|project
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Change the plan to this structure.
comment|//
comment|// LogicalProject-A' (replace corvar to input ref from LogicalJoin)
comment|//   LogicalJoin (left, condition = true)
comment|//     LeftInputRel
comment|//     LogicalAggregate(groupby(0), single_value(0), s_v(1)....)
comment|//       LogicalProject-B (everything from input plus literal true)
comment|//         ProjInputRel
comment|// make the new projRel to provide a null indicator
name|right
operator|=
name|createProjectWithAdditionalExprs
argument_list|(
name|right
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|Pair
operator|.
expr|<
name|RexNode
argument_list|,
name|String
operator|>
name|of
argument_list|(
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|,
literal|"nullIndicator"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// make the new aggRel
name|right
operator|=
name|RelOptUtil
operator|.
name|createSingleValueAggRel
argument_list|(
name|cluster
argument_list|,
name|right
argument_list|)
expr_stmt|;
comment|// The last field:
comment|//     single_value(true)
comment|// is the nullIndicator
name|nullIndicatorPos
operator|=
name|left
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|+
name|right
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
comment|// make the new join rel
name|LogicalJoin
name|join
init|=
name|LogicalJoin
operator|.
name|create
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|joinCond
argument_list|,
name|ImmutableSet
operator|.
expr|<
name|CorrelationId
operator|>
name|of
argument_list|()
argument_list|,
name|joinType
argument_list|)
decl_stmt|;
name|RelNode
name|newProject
init|=
name|projectJoinOutputWithNullability
argument_list|(
name|join
argument_list|,
name|project
argument_list|,
name|nullIndicatorPos
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|newProject
argument_list|)
expr_stmt|;
name|removeCorVarFromTree
argument_list|(
name|correlate
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Planner rule that removes correlations for scalar aggregates. */
specifier|private
specifier|final
class|class
name|RemoveCorrelationForScalarAggregateRule
extends|extends
name|RelOptRule
block|{
specifier|public
name|RemoveCorrelationForScalarAggregateRule
parameter_list|()
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|LogicalCorrelate
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|RelNode
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|,
name|operand
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
literal|null
argument_list|,
name|Aggregate
operator|.
name|IS_SIMPLE
argument_list|,
name|operand
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|RelNode
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|LogicalCorrelate
name|correlate
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|left
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|LogicalProject
name|aggOutputProject
init|=
name|call
operator|.
name|rel
argument_list|(
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|LogicalAggregate
name|aggregate
init|=
name|call
operator|.
name|rel
argument_list|(
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|LogicalProject
name|aggInputProject
init|=
name|call
operator|.
name|rel
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|RelNode
name|right
init|=
name|call
operator|.
name|rel
argument_list|(
literal|5
argument_list|)
decl_stmt|;
specifier|final
name|RelOptCluster
name|cluster
init|=
name|correlate
operator|.
name|getCluster
argument_list|()
decl_stmt|;
name|setCurrent
argument_list|(
name|call
operator|.
name|getPlanner
argument_list|()
operator|.
name|getRoot
argument_list|()
argument_list|,
name|correlate
argument_list|)
expr_stmt|;
comment|// check for this pattern
comment|// The pattern matching could be simplified if rules can be applied
comment|// during decorrelation,
comment|//
comment|// CorrelateRel(left correlation, condition = true)
comment|//   LeftInputRel
comment|//   LogicalProject-A (a RexNode)
comment|//     LogicalAggregate (groupby (0), agg0(), agg1()...)
comment|//       LogicalProject-B (references coVar)
comment|//         rightInputRel
comment|// check aggOutputProject projects only one expression
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|aggOutputProjects
init|=
name|aggOutputProject
operator|.
name|getProjects
argument_list|()
decl_stmt|;
if|if
condition|(
name|aggOutputProjects
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
return|return;
block|}
specifier|final
name|JoinRelType
name|joinType
init|=
name|correlate
operator|.
name|getJoinType
argument_list|()
operator|.
name|toJoinType
argument_list|()
decl_stmt|;
comment|// corRel.getCondition was here, however Correlate was updated so it
comment|// never includes a join condition. The code was not modified for brevity.
name|RexNode
name|joinCond
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|joinType
operator|!=
name|JoinRelType
operator|.
name|LEFT
operator|)
operator|||
operator|(
name|joinCond
operator|!=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
operator|)
condition|)
block|{
return|return;
block|}
comment|// check that the agg is on the entire input
if|if
condition|(
operator|!
name|aggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|aggInputProjects
init|=
name|aggInputProject
operator|.
name|getProjects
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggCalls
init|=
name|aggregate
operator|.
name|getAggCallList
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|isCountStar
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
comment|// mark if agg produces count(*) which needs to reference the
comment|// nullIndicator after the transformation.
name|int
name|k
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|AggregateCall
name|aggCall
range|:
name|aggCalls
control|)
block|{
operator|++
name|k
expr_stmt|;
if|if
condition|(
operator|(
name|aggCall
operator|.
name|getAggregation
argument_list|()
operator|instanceof
name|SqlCountAggFunction
operator|)
operator|&&
operator|(
name|aggCall
operator|.
name|getArgList
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
name|isCountStar
operator|.
name|add
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|right
operator|instanceof
name|LogicalFilter
operator|)
operator|&&
name|cm
operator|.
name|mapRefRelToCorRef
operator|.
name|containsKey
argument_list|(
name|right
argument_list|)
condition|)
block|{
comment|// rightInputRel has this shape:
comment|//
comment|//       LogicalFilter (references corvar)
comment|//         FilterInputRel
name|LogicalFilter
name|filter
init|=
operator|(
name|LogicalFilter
operator|)
name|right
decl_stmt|;
name|right
operator|=
name|filter
operator|.
name|getInput
argument_list|()
expr_stmt|;
assert|assert
name|right
operator|instanceof
name|HepRelVertex
assert|;
name|right
operator|=
operator|(
operator|(
name|HepRelVertex
operator|)
name|right
operator|)
operator|.
name|getCurrentRel
argument_list|()
expr_stmt|;
comment|// check filter input contains no correlation
if|if
condition|(
name|RelOptUtil
operator|.
name|getVariablesUsed
argument_list|(
name|right
argument_list|)
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return;
block|}
comment|// check filter condition type First extract the correlation out
comment|// of the filter
comment|// First breaking up the filter conditions into equality
comment|// comparisons between rightJoinKeys(from the original
comment|// filterInputRel) and correlatedJoinKeys. correlatedJoinKeys
comment|// can only be RexFieldAccess, while rightJoinKeys can be
comment|// expressions. These comparisons are AND'ed together.
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightJoinKeys
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|tmpCorrelatedJoinKeys
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|RelOptUtil
operator|.
name|splitCorrelatedFilterCondition
argument_list|(
name|filter
argument_list|,
name|rightJoinKeys
argument_list|,
name|tmpCorrelatedJoinKeys
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// make sure the correlated reference forms a unique key check
comment|// that the columns referenced in these comparisons form an
comment|// unique key of the leftInputRel
name|List
argument_list|<
name|RexFieldAccess
argument_list|>
name|correlatedJoinKeys
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexInputRef
argument_list|>
name|correlatedInputRefJoinKeys
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|joinKey
range|:
name|tmpCorrelatedJoinKeys
control|)
block|{
assert|assert
name|joinKey
operator|instanceof
name|RexFieldAccess
assert|;
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
operator|(
name|RexFieldAccess
operator|)
name|joinKey
argument_list|)
expr_stmt|;
name|RexNode
name|correlatedInputRef
init|=
name|removeCorrelationExpr
argument_list|(
name|joinKey
argument_list|,
literal|false
argument_list|)
decl_stmt|;
assert|assert
name|correlatedInputRef
operator|instanceof
name|RexInputRef
assert|;
name|correlatedInputRefJoinKeys
operator|.
name|add
argument_list|(
operator|(
name|RexInputRef
operator|)
name|correlatedInputRef
argument_list|)
expr_stmt|;
block|}
comment|// check that the columns referenced in rightJoinKeys form an
comment|// unique key of the filterInputRel
if|if
condition|(
name|correlatedInputRefJoinKeys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// The join filters out the nulls.  So, it's ok if there are
comment|// nulls in the join keys.
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|RelMdUtil
operator|.
name|areColumnsDefinitelyUniqueWhenNullsFiltered
argument_list|(
name|mq
argument_list|,
name|left
argument_list|,
name|correlatedInputRefJoinKeys
argument_list|)
condition|)
block|{
comment|//SQL2REL_LOGGER.fine(correlatedJoinKeys.toString()
comment|//       + "are not unique keys for "
comment|//      + left.toString());
return|return;
block|}
comment|// check cor var references are valid
if|if
condition|(
operator|!
name|checkCorVars
argument_list|(
name|correlate
argument_list|,
name|aggInputProject
argument_list|,
name|filter
argument_list|,
name|correlatedJoinKeys
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Rewrite the above plan:
comment|//
comment|// CorrelateRel(left correlation, condition = true)
comment|//   LeftInputRel
comment|//   LogicalProject-A (a RexNode)
comment|//     LogicalAggregate (groupby(0), agg0(),agg1()...)
comment|//       LogicalProject-B (may reference coVar)
comment|//         LogicalFilter (references corVar)
comment|//           RightInputRel (no correlated reference)
comment|//
comment|// to this plan:
comment|//
comment|// LogicalProject-A' (all gby keys + rewritten nullable ProjExpr)
comment|//   LogicalAggregate (groupby(all left input refs)
comment|//                 agg0(rewritten expression),
comment|//                 agg1()...)
comment|//     LogicalProject-B' (rewriten original projected exprs)
comment|//       LogicalJoin(replace corvar w/ input ref from LeftInputRel)
comment|//         LeftInputRel
comment|//         RightInputRel
comment|//
comment|// In the case where agg is count(*) or count($corVar), it is
comment|// changed to count(nullIndicator).
comment|// Note:  any non-nullable field from the RHS can be used as
comment|// the indicator however a "true" field is added to the
comment|// projection list from the RHS for simplicity to avoid
comment|// searching for non-null fields.
comment|//
comment|// LogicalProject-A' (all gby keys + rewritten nullable ProjExpr)
comment|//   LogicalAggregate (groupby(all left input refs),
comment|//                 count(nullIndicator), other aggs...)
comment|//     LogicalProject-B' (all left input refs plus
comment|//                    the rewritten original projected exprs)
comment|//       LogicalJoin(replace corvar to input ref from LeftInputRel)
comment|//         LeftInputRel
comment|//         LogicalProject (everything from RightInputRel plus
comment|//                     the nullIndicator "true")
comment|//           RightInputRel
comment|//
comment|// first change the filter condition into a join condition
name|joinCond
operator|=
name|removeCorrelationExpr
argument_list|(
name|filter
operator|.
name|getCondition
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cm
operator|.
name|mapRefRelToCorRef
operator|.
name|containsKey
argument_list|(
name|aggInputProject
argument_list|)
condition|)
block|{
comment|// check rightInputRel contains no correlation
if|if
condition|(
name|RelOptUtil
operator|.
name|getVariablesUsed
argument_list|(
name|right
argument_list|)
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return;
block|}
comment|// check cor var references are valid
if|if
condition|(
operator|!
name|checkCorVars
argument_list|(
name|correlate
argument_list|,
name|aggInputProject
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
condition|)
block|{
return|return;
block|}
name|int
name|nFields
init|=
name|left
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|ImmutableBitSet
name|allCols
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|nFields
argument_list|)
decl_stmt|;
comment|// leftInputRel contains unique keys
comment|// i.e. each row is distinct and can group by on all the left
comment|// fields
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|RelMdUtil
operator|.
name|areColumnsDefinitelyUnique
argument_list|(
name|mq
argument_list|,
name|left
argument_list|,
name|allCols
argument_list|)
condition|)
block|{
comment|//SQL2REL_LOGGER.fine("There are no unique keys for " + left);
return|return;
block|}
comment|//
comment|// Rewrite the above plan:
comment|//
comment|// CorrelateRel(left correlation, condition = true)
comment|//   LeftInputRel
comment|//   LogicalProject-A (a RexNode)
comment|//     LogicalAggregate (groupby(0), agg0(), agg1()...)
comment|//       LogicalProject-B (references coVar)
comment|//         RightInputRel (no correlated reference)
comment|//
comment|// to this plan:
comment|//
comment|// LogicalProject-A' (all gby keys + rewritten nullable ProjExpr)
comment|//   LogicalAggregate (groupby(all left input refs)
comment|//                 agg0(rewritten expression),
comment|//                 agg1()...)
comment|//     LogicalProject-B' (rewriten original projected exprs)
comment|//       LogicalJoin (LOJ cond = true)
comment|//         LeftInputRel
comment|//         RightInputRel
comment|//
comment|// In the case where agg is count($corVar), it is changed to
comment|// count(nullIndicator).
comment|// Note:  any non-nullable field from the RHS can be used as
comment|// the indicator however a "true" field is added to the
comment|// projection list from the RHS for simplicity to avoid
comment|// searching for non-null fields.
comment|//
comment|// LogicalProject-A' (all gby keys + rewritten nullable ProjExpr)
comment|//   LogicalAggregate (groupby(all left input refs),
comment|//                 count(nullIndicator), other aggs...)
comment|//     LogicalProject-B' (all left input refs plus
comment|//                    the rewritten original projected exprs)
comment|//       LogicalJoin(replace corvar to input ref from LeftInputRel)
comment|//         LeftInputRel
comment|//         LogicalProject (everything from RightInputRel plus
comment|//                     the nullIndicator "true")
comment|//           RightInputRel
block|}
else|else
block|{
return|return;
block|}
name|RelDataType
name|leftInputFieldType
init|=
name|left
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|int
name|leftInputFieldCount
init|=
name|leftInputFieldType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|joinOutputProjExprCount
init|=
name|leftInputFieldCount
operator|+
name|aggInputProjects
operator|.
name|size
argument_list|()
operator|+
literal|1
decl_stmt|;
name|right
operator|=
name|createProjectWithAdditionalExprs
argument_list|(
name|right
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|Pair
operator|.
expr|<
name|RexNode
argument_list|,
name|String
operator|>
name|of
argument_list|(
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|,
literal|"nullIndicator"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|LogicalJoin
name|join
init|=
name|LogicalJoin
operator|.
name|create
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|joinCond
argument_list|,
name|ImmutableSet
operator|.
expr|<
name|CorrelationId
operator|>
name|of
argument_list|()
argument_list|,
name|joinType
argument_list|)
decl_stmt|;
comment|// To the consumer of joinOutputProjRel, nullIndicator is located
comment|// at the end
name|int
name|nullIndicatorPos
init|=
name|join
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|-
literal|1
decl_stmt|;
name|RexInputRef
name|nullIndicator
init|=
operator|new
name|RexInputRef
argument_list|(
name|nullIndicatorPos
argument_list|,
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|join
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|nullIndicatorPos
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
comment|// first project all group-by keys plus the transformed agg input
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinOutputProjects
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// LOJ Join preserves LHS types
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftInputFieldCount
condition|;
name|i
operator|++
control|)
block|{
name|joinOutputProjects
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|leftInputFieldType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|RexNode
name|aggInputProjExpr
range|:
name|aggInputProjects
control|)
block|{
name|joinOutputProjects
operator|.
name|add
argument_list|(
name|removeCorrelationExpr
argument_list|(
name|aggInputProjExpr
argument_list|,
name|joinType
operator|.
name|generatesNullsOnRight
argument_list|()
argument_list|,
name|nullIndicator
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|joinOutputProjects
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|join
argument_list|,
name|nullIndicatorPos
argument_list|)
argument_list|)
expr_stmt|;
name|RelNode
name|joinOutputProject
init|=
name|RelOptUtil
operator|.
name|createProject
argument_list|(
name|join
argument_list|,
name|joinOutputProjects
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// nullIndicator is now at a different location in the output of
comment|// the join
name|nullIndicatorPos
operator|=
name|joinOutputProjExprCount
operator|-
literal|1
expr_stmt|;
specifier|final
name|int
name|groupCount
init|=
name|leftInputFieldCount
decl_stmt|;
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|newAggCalls
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|k
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|AggregateCall
name|aggCall
range|:
name|aggCalls
control|)
block|{
operator|++
name|k
expr_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|argList
decl_stmt|;
if|if
condition|(
name|isCountStar
operator|.
name|contains
argument_list|(
name|k
argument_list|)
condition|)
block|{
comment|// this is a count(*), transform it to count(nullIndicator)
comment|// the null indicator is located at the end
name|argList
operator|=
name|Collections
operator|.
name|singletonList
argument_list|(
name|nullIndicatorPos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|argList
operator|=
name|Lists
operator|.
name|newArrayList
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|aggArg
range|:
name|aggCall
operator|.
name|getArgList
argument_list|()
control|)
block|{
name|argList
operator|.
name|add
argument_list|(
name|aggArg
operator|+
name|groupCount
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|filterArg
init|=
name|aggCall
operator|.
name|filterArg
operator|<
literal|0
condition|?
name|aggCall
operator|.
name|filterArg
else|:
name|aggCall
operator|.
name|filterArg
operator|+
name|groupCount
decl_stmt|;
name|newAggCalls
operator|.
name|add
argument_list|(
name|aggCall
operator|.
name|adaptTo
argument_list|(
name|joinOutputProject
argument_list|,
name|argList
argument_list|,
name|filterArg
argument_list|,
name|aggregate
operator|.
name|getGroupCount
argument_list|()
argument_list|,
name|groupCount
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ImmutableBitSet
name|groupSet
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|groupCount
argument_list|)
decl_stmt|;
name|LogicalAggregate
name|newAggregate
init|=
name|LogicalAggregate
operator|.
name|create
argument_list|(
name|joinOutputProject
argument_list|,
literal|false
argument_list|,
name|groupSet
argument_list|,
literal|null
argument_list|,
name|newAggCalls
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|newAggOutputProjectList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
range|:
name|groupSet
control|)
block|{
name|newAggOutputProjectList
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|newAggregate
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RexNode
name|newAggOutputProjects
init|=
name|removeCorrelationExpr
argument_list|(
name|aggOutputProjects
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|newAggOutputProjectList
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|newAggOutputProjects
operator|.
name|getType
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|,
name|newAggOutputProjects
argument_list|)
argument_list|)
expr_stmt|;
name|RelNode
name|newAggOutputProject
init|=
name|RelOptUtil
operator|.
name|createProject
argument_list|(
name|newAggregate
argument_list|,
name|newAggOutputProjectList
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|newAggOutputProject
argument_list|)
expr_stmt|;
name|removeCorVarFromTree
argument_list|(
name|correlate
argument_list|)
expr_stmt|;
block|}
block|}
comment|// REVIEW jhyde 29-Oct-2007: This rule is non-static, depends on the state
comment|// of members in RelDecorrelator, and has side-effects in the decorrelator.
comment|// This breaks the contract of a planner rule, and the rule will not be
comment|// reusable in other planners.
comment|// REVIEW jvs 29-Oct-2007:  Shouldn't it also be incorporating
comment|// the flavor attribute into the description?
comment|/** Planner rule that adjusts projects when counts are added. */
specifier|private
specifier|final
class|class
name|AdjustProjectForCountAggregateRule
extends|extends
name|RelOptRule
block|{
specifier|final
name|boolean
name|flavor
decl_stmt|;
specifier|public
name|AdjustProjectForCountAggregateRule
parameter_list|(
name|boolean
name|flavor
parameter_list|)
block|{
name|super
argument_list|(
name|flavor
condition|?
name|operand
argument_list|(
name|LogicalCorrelate
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|RelNode
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|,
name|operand
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|)
else|:
name|operand
argument_list|(
name|LogicalCorrelate
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|RelNode
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|,
name|operand
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|flavor
operator|=
name|flavor
expr_stmt|;
block|}
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|LogicalCorrelate
name|correlate
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|left
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|LogicalProject
name|aggOutputProject
decl_stmt|;
specifier|final
name|LogicalAggregate
name|aggregate
decl_stmt|;
if|if
condition|(
name|flavor
condition|)
block|{
name|aggOutputProject
operator|=
name|call
operator|.
name|rel
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|aggregate
operator|=
name|call
operator|.
name|rel
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aggregate
operator|=
name|call
operator|.
name|rel
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|// Create identity projection
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|projects
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|aggregate
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|RexInputRef
operator|.
name|of2
argument_list|(
name|projects
operator|.
name|size
argument_list|()
argument_list|,
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|aggOutputProject
operator|=
operator|(
name|LogicalProject
operator|)
name|RelOptUtil
operator|.
name|createProject
argument_list|(
name|aggregate
argument_list|,
name|projects
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|onMatch2
argument_list|(
name|call
argument_list|,
name|correlate
argument_list|,
name|left
argument_list|,
name|aggOutputProject
argument_list|,
name|aggregate
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|onMatch2
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|,
name|LogicalCorrelate
name|correlate
parameter_list|,
name|RelNode
name|leftInput
parameter_list|,
name|LogicalProject
name|aggOutputProject
parameter_list|,
name|LogicalAggregate
name|aggregate
parameter_list|)
block|{
if|if
condition|(
name|generatedCorRels
operator|.
name|contains
argument_list|(
name|correlate
argument_list|)
condition|)
block|{
comment|// This correlator was generated by a previous invocation of
comment|// this rule. No further work to do.
return|return;
block|}
name|setCurrent
argument_list|(
name|call
operator|.
name|getPlanner
argument_list|()
operator|.
name|getRoot
argument_list|()
argument_list|,
name|correlate
argument_list|)
expr_stmt|;
comment|// check for this pattern
comment|// The pattern matching could be simplified if rules can be applied
comment|// during decorrelation,
comment|//
comment|// CorrelateRel(left correlation, condition = true)
comment|//   LeftInputRel
comment|//   LogicalProject-A (a RexNode)
comment|//     LogicalAggregate (groupby (0), agg0(), agg1()...)
comment|// check aggOutputProj projects only one expression
name|List
argument_list|<
name|RexNode
argument_list|>
name|aggOutputProjExprs
init|=
name|aggOutputProject
operator|.
name|getProjects
argument_list|()
decl_stmt|;
if|if
condition|(
name|aggOutputProjExprs
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
return|return;
block|}
name|JoinRelType
name|joinType
init|=
name|correlate
operator|.
name|getJoinType
argument_list|()
operator|.
name|toJoinType
argument_list|()
decl_stmt|;
comment|// corRel.getCondition was here, however Correlate was updated so it
comment|// never includes a join condition. The code was not modified for brevity.
name|RexNode
name|joinCond
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|joinType
operator|!=
name|JoinRelType
operator|.
name|LEFT
operator|)
operator|||
operator|(
name|joinCond
operator|!=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
operator|)
condition|)
block|{
return|return;
block|}
comment|// check that the agg is on the entire input
if|if
condition|(
operator|!
name|aggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggCalls
init|=
name|aggregate
operator|.
name|getAggCallList
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|isCount
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
comment|// remember the count() positions
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|AggregateCall
name|aggCall
range|:
name|aggCalls
control|)
block|{
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|aggCall
operator|.
name|getAggregation
argument_list|()
operator|instanceof
name|SqlCountAggFunction
condition|)
block|{
name|isCount
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|// now rewrite the plan to
comment|//
comment|// Project-A' (all LHS plus transformed original projections,
comment|//             replacing references to count() with case statement)
comment|//   Correlator(left correlation, condition = true)
comment|//     LeftInputRel
comment|//     LogicalAggregate (groupby (0), agg0(), agg1()...)
comment|//
name|LogicalCorrelate
name|newCorrelate
init|=
name|LogicalCorrelate
operator|.
name|create
argument_list|(
name|leftInput
argument_list|,
name|aggregate
argument_list|,
name|correlate
operator|.
name|getCorrelationId
argument_list|()
argument_list|,
name|correlate
operator|.
name|getRequiredColumns
argument_list|()
argument_list|,
name|correlate
operator|.
name|getJoinType
argument_list|()
argument_list|)
decl_stmt|;
comment|// remember this rel so we don't fire rule on it again
comment|// REVIEW jhyde 29-Oct-2007: rules should not save state; rule
comment|// should recognize patterns where it does or does not need to do
comment|// work
name|generatedCorRels
operator|.
name|add
argument_list|(
name|newCorrelate
argument_list|)
expr_stmt|;
comment|// need to update the mapCorVarToCorRel Update the output position
comment|// for the cor vars: only pass on the cor vars that are not used in
comment|// the join key.
if|if
condition|(
name|cm
operator|.
name|mapCorToCorRel
operator|.
name|get
argument_list|(
name|correlate
operator|.
name|getCorrelationId
argument_list|()
argument_list|)
operator|==
name|correlate
condition|)
block|{
name|cm
operator|.
name|mapCorToCorRel
operator|.
name|put
argument_list|(
name|correlate
operator|.
name|getCorrelationId
argument_list|()
argument_list|,
name|newCorrelate
argument_list|)
expr_stmt|;
block|}
name|RelNode
name|newOutput
init|=
name|aggregateCorrelatorOutput
argument_list|(
name|newCorrelate
argument_list|,
name|aggOutputProject
argument_list|,
name|isCount
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|newOutput
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * A unique reference to a correlation field.    *    *<p>For instance, if a RelNode references emp.name multiple times, it would    * result in multiple {@code CorRef} objects that differ just in    * {@link CorRef#uniqueKey}.    */
specifier|static
class|class
name|CorRef
implements|implements
name|Comparable
argument_list|<
name|CorRef
argument_list|>
block|{
specifier|public
specifier|final
name|int
name|uniqueKey
decl_stmt|;
specifier|public
specifier|final
name|CorrelationId
name|corr
decl_stmt|;
specifier|public
specifier|final
name|int
name|field
decl_stmt|;
name|CorRef
parameter_list|(
name|CorrelationId
name|corr
parameter_list|,
name|int
name|field
parameter_list|,
name|int
name|uniqueKey
parameter_list|)
block|{
name|this
operator|.
name|corr
operator|=
name|corr
expr_stmt|;
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
name|this
operator|.
name|uniqueKey
operator|=
name|uniqueKey
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|corr
operator|.
name|getName
argument_list|()
operator|+
literal|'.'
operator|+
name|field
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|uniqueKey
argument_list|,
name|corr
argument_list|,
name|field
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|this
operator|==
name|o
operator|||
name|o
operator|instanceof
name|CorRef
operator|&&
name|uniqueKey
operator|==
operator|(
operator|(
name|CorRef
operator|)
name|o
operator|)
operator|.
name|uniqueKey
operator|&&
name|corr
operator|==
operator|(
operator|(
name|CorRef
operator|)
name|o
operator|)
operator|.
name|corr
operator|&&
name|field
operator|==
operator|(
operator|(
name|CorRef
operator|)
name|o
operator|)
operator|.
name|field
return|;
block|}
specifier|public
name|int
name|compareTo
parameter_list|(
annotation|@
name|Nonnull
name|CorRef
name|o
parameter_list|)
block|{
name|int
name|c
init|=
name|corr
operator|.
name|compareTo
argument_list|(
name|o
operator|.
name|corr
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
return|return
name|c
return|;
block|}
name|c
operator|=
name|Integer
operator|.
name|compare
argument_list|(
name|field
argument_list|,
name|o
operator|.
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
return|return
name|c
return|;
block|}
return|return
name|Integer
operator|.
name|compare
argument_list|(
name|uniqueKey
argument_list|,
name|o
operator|.
name|uniqueKey
argument_list|)
return|;
block|}
specifier|public
name|CorDef
name|def
parameter_list|()
block|{
return|return
operator|new
name|CorDef
argument_list|(
name|corr
argument_list|,
name|field
argument_list|)
return|;
block|}
block|}
comment|/** A correlation and a field. */
specifier|static
class|class
name|CorDef
implements|implements
name|Comparable
argument_list|<
name|CorDef
argument_list|>
block|{
specifier|public
specifier|final
name|CorrelationId
name|corr
decl_stmt|;
specifier|public
specifier|final
name|int
name|field
decl_stmt|;
name|CorDef
parameter_list|(
name|CorrelationId
name|corr
parameter_list|,
name|int
name|field
parameter_list|)
block|{
name|this
operator|.
name|corr
operator|=
name|corr
expr_stmt|;
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|corr
operator|.
name|getName
argument_list|()
operator|+
literal|'.'
operator|+
name|field
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|corr
argument_list|,
name|field
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|this
operator|==
name|o
operator|||
name|o
operator|instanceof
name|CorDef
operator|&&
name|corr
operator|==
operator|(
operator|(
name|CorDef
operator|)
name|o
operator|)
operator|.
name|corr
operator|&&
name|field
operator|==
operator|(
operator|(
name|CorDef
operator|)
name|o
operator|)
operator|.
name|field
return|;
block|}
specifier|public
name|int
name|compareTo
parameter_list|(
annotation|@
name|Nonnull
name|CorDef
name|o
parameter_list|)
block|{
name|int
name|c
init|=
name|corr
operator|.
name|compareTo
argument_list|(
name|o
operator|.
name|corr
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
return|return
name|c
return|;
block|}
return|return
name|Integer
operator|.
name|compare
argument_list|(
name|field
argument_list|,
name|o
operator|.
name|field
argument_list|)
return|;
block|}
block|}
comment|/** A map of the locations of    * {@link org.apache.calcite.rel.logical.LogicalCorrelate}    * in a tree of {@link RelNode}s.    *    *<p>It is used to drive the decorrelation process.    * Treat it as immutable; rebuild if you modify the tree.    *    *<p>There are three maps:<ol>    *    *<li>{@link #mapRefRelToCorRef} maps a {@link RelNode} to the correlated    * variables it references;    *    *<li>{@link #mapCorToCorRel} maps a correlated variable to the    * {@link Correlate} providing it;    *    *<li>{@link #mapFieldAccessToCorRef} maps a rex field access to    * the corVar it represents. Because typeFlattener does not clone or    * modify a correlated field access this map does not need to be    * updated.    *    *</ol> */
specifier|private
specifier|static
class|class
name|CorelMap
block|{
specifier|private
specifier|final
name|Multimap
argument_list|<
name|RelNode
argument_list|,
name|CorRef
argument_list|>
name|mapRefRelToCorRef
decl_stmt|;
specifier|private
specifier|final
name|SortedMap
argument_list|<
name|CorrelationId
argument_list|,
name|RelNode
argument_list|>
name|mapCorToCorRel
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|RexFieldAccess
argument_list|,
name|CorRef
argument_list|>
name|mapFieldAccessToCorRef
decl_stmt|;
comment|// TODO: create immutable copies of all maps
specifier|private
name|CorelMap
parameter_list|(
name|Multimap
argument_list|<
name|RelNode
argument_list|,
name|CorRef
argument_list|>
name|mapRefRelToCorRef
parameter_list|,
name|SortedMap
argument_list|<
name|CorrelationId
argument_list|,
name|RelNode
argument_list|>
name|mapCorToCorRel
parameter_list|,
name|Map
argument_list|<
name|RexFieldAccess
argument_list|,
name|CorRef
argument_list|>
name|mapFieldAccessToCorRef
parameter_list|)
block|{
name|this
operator|.
name|mapRefRelToCorRef
operator|=
name|mapRefRelToCorRef
expr_stmt|;
name|this
operator|.
name|mapCorToCorRel
operator|=
name|mapCorToCorRel
expr_stmt|;
name|this
operator|.
name|mapFieldAccessToCorRef
operator|=
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|mapFieldAccessToCorRef
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"mapRefRelToCorRef="
operator|+
name|mapRefRelToCorRef
operator|+
literal|"\nmapCorToCorRel="
operator|+
name|mapCorToCorRel
operator|+
literal|"\nmapFieldAccessToCorRef="
operator|+
name|mapFieldAccessToCorRef
operator|+
literal|"\n"
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|obj
operator|==
name|this
operator|||
name|obj
operator|instanceof
name|CorelMap
operator|&&
name|mapRefRelToCorRef
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|CorelMap
operator|)
name|obj
operator|)
operator|.
name|mapRefRelToCorRef
argument_list|)
operator|&&
name|mapCorToCorRel
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|CorelMap
operator|)
name|obj
operator|)
operator|.
name|mapCorToCorRel
argument_list|)
operator|&&
name|mapFieldAccessToCorRef
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|CorelMap
operator|)
name|obj
operator|)
operator|.
name|mapFieldAccessToCorRef
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|mapRefRelToCorRef
argument_list|,
name|mapCorToCorRel
argument_list|,
name|mapFieldAccessToCorRef
argument_list|)
return|;
block|}
comment|/** Creates a CorelMap with given contents. */
specifier|public
specifier|static
name|CorelMap
name|of
parameter_list|(
name|SortedSetMultimap
argument_list|<
name|RelNode
argument_list|,
name|CorRef
argument_list|>
name|mapRefRelToCorVar
parameter_list|,
name|SortedMap
argument_list|<
name|CorrelationId
argument_list|,
name|RelNode
argument_list|>
name|mapCorToCorRel
parameter_list|,
name|Map
argument_list|<
name|RexFieldAccess
argument_list|,
name|CorRef
argument_list|>
name|mapFieldAccessToCorVar
parameter_list|)
block|{
return|return
operator|new
name|CorelMap
argument_list|(
name|mapRefRelToCorVar
argument_list|,
name|mapCorToCorRel
argument_list|,
name|mapFieldAccessToCorVar
argument_list|)
return|;
block|}
comment|/**      * Returns whether there are any correlating variables in this statement.      *      * @return whether there are any correlating variables      */
specifier|public
name|boolean
name|hasCorrelation
parameter_list|()
block|{
return|return
operator|!
name|mapCorToCorRel
operator|.
name|isEmpty
argument_list|()
return|;
block|}
block|}
comment|/** Builds a {@link org.apache.calcite.sql2rel.RelDecorrelator.CorelMap}. */
specifier|private
specifier|static
class|class
name|CorelMapBuilder
extends|extends
name|HiveRelShuttleImpl
block|{
specifier|final
name|SortedMap
argument_list|<
name|CorrelationId
argument_list|,
name|RelNode
argument_list|>
name|mapCorToCorRel
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|SortedSetMultimap
argument_list|<
name|RelNode
argument_list|,
name|CorRef
argument_list|>
name|mapRefRelToCorRef
init|=
name|Multimaps
operator|.
name|newSortedSetMultimap
argument_list|(
operator|new
name|HashMap
argument_list|<
name|RelNode
argument_list|,
name|Collection
argument_list|<
name|CorRef
argument_list|>
argument_list|>
argument_list|()
argument_list|,
operator|new
name|Supplier
argument_list|<
name|TreeSet
argument_list|<
name|CorRef
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|TreeSet
argument_list|<
name|CorRef
argument_list|>
name|get
parameter_list|()
block|{
name|Bug
operator|.
name|upgrade
argument_list|(
literal|"use MultimapBuilder when we're on Guava-16"
argument_list|)
expr_stmt|;
return|return
name|Sets
operator|.
name|newTreeSet
argument_list|()
return|;
block|}
block|}
argument_list|)
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|RexFieldAccess
argument_list|,
name|CorRef
argument_list|>
name|mapFieldAccessToCorVar
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Holder
argument_list|<
name|Integer
argument_list|>
name|offset
init|=
name|Holder
operator|.
name|of
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|corrIdGenerator
init|=
literal|0
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|stack
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Creates a CorelMap by iterating over a {@link RelNode} tree. */
name|CorelMap
name|build
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|stripHep
argument_list|(
name|rel
argument_list|)
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
operator|new
name|CorelMap
argument_list|(
name|mapRefRelToCorRef
argument_list|,
name|mapCorToCorRel
argument_list|,
name|mapFieldAccessToCorVar
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RelNode
name|visit
parameter_list|(
name|LogicalJoin
name|join
parameter_list|)
block|{
try|try
block|{
name|Stacks
operator|.
name|push
argument_list|(
name|stack
argument_list|,
name|join
argument_list|)
expr_stmt|;
name|join
operator|.
name|getCondition
argument_list|()
operator|.
name|accept
argument_list|(
name|rexVisitor
argument_list|(
name|join
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|Stacks
operator|.
name|pop
argument_list|(
name|stack
argument_list|,
name|join
argument_list|)
expr_stmt|;
block|}
return|return
name|visitJoin
argument_list|(
name|join
argument_list|)
return|;
block|}
specifier|public
name|RelNode
name|visit
parameter_list|(
name|HiveJoin
name|join
parameter_list|)
block|{
try|try
block|{
name|Stacks
operator|.
name|push
argument_list|(
name|stack
argument_list|,
name|join
argument_list|)
expr_stmt|;
name|join
operator|.
name|getCondition
argument_list|()
operator|.
name|accept
argument_list|(
name|rexVisitor
argument_list|(
name|join
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|Stacks
operator|.
name|pop
argument_list|(
name|stack
argument_list|,
name|join
argument_list|)
expr_stmt|;
block|}
return|return
name|visitJoin
argument_list|(
name|join
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|RelNode
name|visitChild
parameter_list|(
name|RelNode
name|parent
parameter_list|,
name|int
name|i
parameter_list|,
name|RelNode
name|input
parameter_list|)
block|{
return|return
name|super
operator|.
name|visitChild
argument_list|(
name|parent
argument_list|,
name|i
argument_list|,
name|stripHep
argument_list|(
name|input
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RelNode
name|visit
parameter_list|(
name|LogicalCorrelate
name|correlate
parameter_list|)
block|{
name|mapCorToCorRel
operator|.
name|put
argument_list|(
name|correlate
operator|.
name|getCorrelationId
argument_list|()
argument_list|,
name|correlate
argument_list|)
expr_stmt|;
return|return
name|visitJoin
argument_list|(
name|correlate
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|visitJoin
parameter_list|(
name|BiRel
name|join
parameter_list|)
block|{
specifier|final
name|int
name|x
init|=
name|offset
operator|.
name|get
argument_list|()
decl_stmt|;
name|visitChild
argument_list|(
name|join
argument_list|,
literal|0
argument_list|,
name|join
operator|.
name|getLeft
argument_list|()
argument_list|)
expr_stmt|;
name|offset
operator|.
name|set
argument_list|(
name|x
operator|+
name|join
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
expr_stmt|;
name|visitChild
argument_list|(
name|join
argument_list|,
literal|1
argument_list|,
name|join
operator|.
name|getRight
argument_list|()
argument_list|)
expr_stmt|;
name|offset
operator|.
name|set
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|join
return|;
block|}
specifier|public
name|RelNode
name|visit
parameter_list|(
specifier|final
name|HiveProject
name|project
parameter_list|)
block|{
try|try
block|{
name|Stacks
operator|.
name|push
argument_list|(
name|stack
argument_list|,
name|project
argument_list|)
expr_stmt|;
for|for
control|(
name|RexNode
name|node
range|:
name|project
operator|.
name|getProjects
argument_list|()
control|)
block|{
name|node
operator|.
name|accept
argument_list|(
name|rexVisitor
argument_list|(
name|project
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|Stacks
operator|.
name|pop
argument_list|(
name|stack
argument_list|,
name|project
argument_list|)
expr_stmt|;
block|}
return|return
name|super
operator|.
name|visit
argument_list|(
name|project
argument_list|)
return|;
block|}
specifier|public
name|RelNode
name|visit
parameter_list|(
specifier|final
name|HiveFilter
name|filter
parameter_list|)
block|{
try|try
block|{
name|Stacks
operator|.
name|push
argument_list|(
name|stack
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|filter
operator|.
name|getCondition
argument_list|()
operator|.
name|accept
argument_list|(
name|rexVisitor
argument_list|(
name|filter
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|Stacks
operator|.
name|pop
argument_list|(
name|stack
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
return|return
name|super
operator|.
name|visit
argument_list|(
name|filter
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RelNode
name|visit
parameter_list|(
specifier|final
name|LogicalFilter
name|filter
parameter_list|)
block|{
try|try
block|{
name|Stacks
operator|.
name|push
argument_list|(
name|stack
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|filter
operator|.
name|getCondition
argument_list|()
operator|.
name|accept
argument_list|(
name|rexVisitor
argument_list|(
name|filter
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|Stacks
operator|.
name|pop
argument_list|(
name|stack
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
return|return
name|super
operator|.
name|visit
argument_list|(
name|filter
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RelNode
name|visit
parameter_list|(
name|LogicalProject
name|project
parameter_list|)
block|{
try|try
block|{
name|Stacks
operator|.
name|push
argument_list|(
name|stack
argument_list|,
name|project
argument_list|)
expr_stmt|;
for|for
control|(
name|RexNode
name|node
range|:
name|project
operator|.
name|getProjects
argument_list|()
control|)
block|{
name|node
operator|.
name|accept
argument_list|(
name|rexVisitor
argument_list|(
name|project
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|Stacks
operator|.
name|pop
argument_list|(
name|stack
argument_list|,
name|project
argument_list|)
expr_stmt|;
block|}
return|return
name|super
operator|.
name|visit
argument_list|(
name|project
argument_list|)
return|;
block|}
specifier|private
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
name|rexVisitor
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|)
block|{
return|return
operator|new
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
argument_list|(
literal|true
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
specifier|final
name|RexNode
name|ref
init|=
name|fieldAccess
operator|.
name|getReferenceExpr
argument_list|()
decl_stmt|;
if|if
condition|(
name|ref
operator|instanceof
name|RexCorrelVariable
condition|)
block|{
specifier|final
name|RexCorrelVariable
name|var
init|=
operator|(
name|RexCorrelVariable
operator|)
name|ref
decl_stmt|;
if|if
condition|(
name|mapFieldAccessToCorVar
operator|.
name|containsKey
argument_list|(
name|fieldAccess
argument_list|)
condition|)
block|{
comment|//for cases where different Rel nodes are referring to
comment|// same correlation var (e.g. in case of NOT IN)
comment|// avoid generating another correlation var
comment|// and record the 'rel' is using the same correlation
name|mapRefRelToCorRef
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|mapFieldAccessToCorVar
operator|.
name|get
argument_list|(
name|fieldAccess
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|CorRef
name|correlation
init|=
operator|new
name|CorRef
argument_list|(
name|var
operator|.
name|id
argument_list|,
name|fieldAccess
operator|.
name|getField
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|,
name|corrIdGenerator
operator|++
argument_list|)
decl_stmt|;
name|mapFieldAccessToCorVar
operator|.
name|put
argument_list|(
name|fieldAccess
argument_list|,
name|correlation
argument_list|)
expr_stmt|;
name|mapRefRelToCorRef
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|correlation
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|super
operator|.
name|visitFieldAccess
argument_list|(
name|fieldAccess
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visitSubQuery
parameter_list|(
name|RexSubQuery
name|subQuery
parameter_list|)
block|{
name|subQuery
operator|.
name|rel
operator|.
name|accept
argument_list|(
name|CorelMapBuilder
operator|.
name|this
argument_list|)
expr_stmt|;
return|return
name|super
operator|.
name|visitSubQuery
argument_list|(
name|subQuery
argument_list|)
return|;
block|}
block|}
return|;
block|}
block|}
comment|/** Frame describing the relational expression after decorrelation    * and where to find the output fields and correlation variables    * among its output fields. */
specifier|static
class|class
name|Frame
block|{
specifier|final
name|RelNode
name|r
decl_stmt|;
specifier|final
name|ImmutableSortedMap
argument_list|<
name|CorDef
argument_list|,
name|Integer
argument_list|>
name|corDefOutputs
decl_stmt|;
specifier|final
name|ImmutableSortedMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|oldToNewOutputs
decl_stmt|;
name|Frame
parameter_list|(
name|RelNode
name|oldRel
parameter_list|,
name|RelNode
name|r
parameter_list|,
name|SortedMap
argument_list|<
name|CorDef
argument_list|,
name|Integer
argument_list|>
name|corDefOutputs
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|oldToNewOutputs
parameter_list|)
block|{
name|this
operator|.
name|r
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|this
operator|.
name|corDefOutputs
operator|=
name|ImmutableSortedMap
operator|.
name|copyOf
argument_list|(
name|corDefOutputs
argument_list|)
expr_stmt|;
name|this
operator|.
name|oldToNewOutputs
operator|=
name|ImmutableSortedMap
operator|.
name|copyOf
argument_list|(
name|oldToNewOutputs
argument_list|)
expr_stmt|;
assert|assert
name|allLessThan
argument_list|(
name|corDefOutputs
operator|.
name|values
argument_list|()
argument_list|,
name|r
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|Litmus
operator|.
name|THROW
argument_list|)
assert|;
assert|assert
name|allLessThan
argument_list|(
name|oldToNewOutputs
operator|.
name|keySet
argument_list|()
argument_list|,
name|oldRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|Litmus
operator|.
name|THROW
argument_list|)
assert|;
assert|assert
name|allLessThan
argument_list|(
name|oldToNewOutputs
operator|.
name|values
argument_list|()
argument_list|,
name|r
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|Litmus
operator|.
name|THROW
argument_list|)
assert|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End RelDecorrelator.java
end_comment

end_unit

