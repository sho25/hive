begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|AppMasterEventOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|DummyStoreOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FilterOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|MapJoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RowSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TableScanOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|UDFArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|UnionOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ParseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemiJoinBranchInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DynamicPruningEventDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FilterDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|stats
operator|.
name|StatsUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPAnd
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPOr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ArrayListMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|HashMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_comment
comment|/**  * Shared scan optimizer. This rule finds scan operator over the same table  * in the query plan and merges them if they meet some preconditions.  *  *  TS   TS             TS  *  |    |     ->      /  \  *  Op   Op           Op  Op  *  *<p>Currently it only works with the Tez execution engine.  */
end_comment

begin_class
specifier|public
class|class
name|SharedScanOptimizer
extends|extends
name|Transform
block|{
specifier|private
specifier|final
specifier|static
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SharedScanOptimizer
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|ParseContext
name|transform
parameter_list|(
name|ParseContext
name|pctx
parameter_list|)
throws|throws
name|SemanticException
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|topOps
init|=
name|pctx
operator|.
name|getTopOps
argument_list|()
decl_stmt|;
if|if
condition|(
name|topOps
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
comment|// Nothing to do, bail out
return|return
name|pctx
return|;
block|}
comment|// Cache to use during optimization
name|SharedScanOptimizerCache
name|optimizerCache
init|=
operator|new
name|SharedScanOptimizerCache
argument_list|()
decl_stmt|;
comment|// We will not apply this optimization on some table scan operators.
name|Set
argument_list|<
name|TableScanOperator
argument_list|>
name|excludeTableScanOps
init|=
name|gatherNotValidTableScanOps
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exclude TableScan ops: {}"
argument_list|,
name|excludeTableScanOps
argument_list|)
expr_stmt|;
comment|// Map of dbName.TblName -> Pair(tableAlias, TSOperator)
name|Multimap
argument_list|<
name|String
argument_list|,
name|Entry
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
argument_list|>
name|tableNameToOps
init|=
name|splitTableScanOpsByTable
argument_list|(
name|pctx
argument_list|)
decl_stmt|;
comment|// We enforce a certain order when we do the reutilization.
comment|// In particular, we use size of table x number of reads to
comment|// rank the tables.
name|List
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|>
name|sortedTables
init|=
name|rankTablesByAccumulatedSize
argument_list|(
name|pctx
argument_list|,
name|excludeTableScanOps
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sorted tables by size: {}"
argument_list|,
name|sortedTables
argument_list|)
expr_stmt|;
comment|// Execute optimization
name|Multimap
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|existingOps
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|entriesToRemove
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|tablePair
range|:
name|sortedTables
control|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|tableScanOpPair
range|:
name|tableNameToOps
operator|.
name|get
argument_list|(
name|tablePair
operator|.
name|getKey
argument_list|()
argument_list|)
control|)
block|{
name|TableScanOperator
name|tsOp
init|=
name|tableScanOpPair
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|excludeTableScanOps
operator|.
name|contains
argument_list|(
name|tsOp
argument_list|)
condition|)
block|{
comment|// Skip operator, currently we do not merge
continue|continue;
block|}
name|String
name|tableName
init|=
name|tablePair
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|TableScanOperator
argument_list|>
name|prevTsOps
init|=
name|existingOps
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|prevTsOps
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|TableScanOperator
name|prevTsOp
range|:
name|prevTsOps
control|)
block|{
comment|// First we check if the two table scan operators can actually be merged
comment|// If schemas do not match, we currently do not merge
name|List
argument_list|<
name|String
argument_list|>
name|prevTsOpNeededColumns
init|=
name|prevTsOp
operator|.
name|getNeededColumns
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|tsOpNeededColumns
init|=
name|tsOp
operator|.
name|getNeededColumns
argument_list|()
decl_stmt|;
if|if
condition|(
name|prevTsOpNeededColumns
operator|.
name|size
argument_list|()
operator|!=
name|tsOpNeededColumns
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// Skip
continue|continue;
block|}
name|boolean
name|notEqual
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|prevTsOpNeededColumns
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|prevTsOpNeededColumns
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|equals
argument_list|(
name|tsOpNeededColumns
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|notEqual
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|notEqual
condition|)
block|{
comment|// Skip
continue|continue;
block|}
comment|// If row limit does not match, we currently do not merge
if|if
condition|(
name|prevTsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getRowLimit
argument_list|()
operator|!=
name|tsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getRowLimit
argument_list|()
condition|)
block|{
comment|// Skip
continue|continue;
block|}
comment|// It seems these two operators can be merged.
comment|// Check that plan meets some preconditions before doing it.
comment|// In particular, in the presence of map joins in the upstream plan:
comment|// - we cannot exceed the noconditional task size, and
comment|// - if we already merged the big table, we cannot merge the broadcast
comment|// tables.
if|if
condition|(
operator|!
name|validPreConditions
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|prevTsOp
argument_list|,
name|tsOp
argument_list|)
condition|)
block|{
comment|// Skip
name|LOG
operator|.
name|debug
argument_list|(
literal|"{} does not meet preconditions"
argument_list|,
name|tsOp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// We can merge
name|ExprNodeGenericFuncDesc
name|exprNode
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|prevTsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getFilterExpr
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// Push filter on top of children
name|pushFilterToTopOfTableScan
argument_list|(
name|optimizerCache
argument_list|,
name|prevTsOp
argument_list|)
expr_stmt|;
comment|// Clone to push to table scan
name|exprNode
operator|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|prevTsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getFilterExpr
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getFilterExpr
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// Push filter on top
name|pushFilterToTopOfTableScan
argument_list|(
name|optimizerCache
argument_list|,
name|tsOp
argument_list|)
expr_stmt|;
name|ExprNodeGenericFuncDesc
name|tsExprNode
init|=
name|tsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getFilterExpr
argument_list|()
decl_stmt|;
if|if
condition|(
name|exprNode
operator|!=
literal|null
operator|&&
operator|!
name|exprNode
operator|.
name|isSame
argument_list|(
name|tsExprNode
argument_list|)
condition|)
block|{
comment|// We merge filters from previous scan by ORing with filters from current scan
if|if
condition|(
name|exprNode
operator|.
name|getGenericUDF
argument_list|()
operator|instanceof
name|GenericUDFOPOr
condition|)
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|newChildren
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|exprNode
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|childExprNode
range|:
name|exprNode
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
name|childExprNode
operator|.
name|isSame
argument_list|(
name|tsExprNode
argument_list|)
condition|)
block|{
comment|// We do not need to do anything, it is in the OR expression
break|break;
block|}
name|newChildren
operator|.
name|add
argument_list|(
name|childExprNode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exprNode
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|==
name|newChildren
operator|.
name|size
argument_list|()
condition|)
block|{
name|newChildren
operator|.
name|add
argument_list|(
name|tsExprNode
argument_list|)
expr_stmt|;
name|exprNode
operator|=
name|ExprNodeGenericFuncDesc
operator|.
name|newInstance
argument_list|(
operator|new
name|GenericUDFOPOr
argument_list|()
argument_list|,
name|newChildren
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|exprNode
operator|=
name|ExprNodeGenericFuncDesc
operator|.
name|newInstance
argument_list|(
operator|new
name|GenericUDFOPOr
argument_list|()
argument_list|,
name|Arrays
operator|.
expr|<
name|ExprNodeDesc
operator|>
name|asList
argument_list|(
name|exprNode
argument_list|,
name|tsExprNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Replace filter
name|prevTsOp
operator|.
name|getConf
argument_list|()
operator|.
name|setFilterExpr
argument_list|(
name|exprNode
argument_list|)
expr_stmt|;
comment|// Replace table scan operator
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|allChildren
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|tsOp
operator|.
name|getChildOperators
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|allChildren
control|)
block|{
name|tsOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|remove
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|op
operator|.
name|replaceParent
argument_list|(
name|tsOp
argument_list|,
name|prevTsOp
argument_list|)
expr_stmt|;
name|prevTsOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
name|entriesToRemove
operator|.
name|add
argument_list|(
name|tableScanOpPair
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
comment|// Remove and combine
name|optimizerCache
operator|.
name|removeOpAndCombineWork
argument_list|(
name|tsOp
argument_list|,
name|prevTsOp
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Merged {} into {}"
argument_list|,
name|tsOp
argument_list|,
name|prevTsOp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|entriesToRemove
operator|.
name|contains
argument_list|(
name|tableScanOpPair
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|existingOps
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|tsOp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Add to existing ops
name|existingOps
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|tsOp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Remove unused operators
for|for
control|(
name|String
name|key
range|:
name|entriesToRemove
control|)
block|{
name|topOps
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
return|return
name|pctx
return|;
block|}
specifier|private
specifier|static
name|Set
argument_list|<
name|TableScanOperator
argument_list|>
name|gatherNotValidTableScanOps
parameter_list|(
name|ParseContext
name|pctx
parameter_list|,
name|SharedScanOptimizerCache
name|optimizerCache
parameter_list|)
block|{
comment|// Find TS operators with partition pruning enabled in plan
comment|// because these TS may potentially read different data for
comment|// different pipeline.
comment|// These can be:
comment|// 1) TS with static partitioning.
comment|//    TODO: Check partition list of different TS and do not add if they are identical
comment|// 2) TS with DPP.
comment|//    TODO: Check if dynamic filters are identical and do not add.
comment|// 3) TS with semijoin DPP.
comment|//    TODO: Check for dynamic filters.
name|Set
argument_list|<
name|TableScanOperator
argument_list|>
name|notValidTableScanOps
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// 1) TS with static partitioning.
name|Map
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|topOps
init|=
name|pctx
operator|.
name|getTopOps
argument_list|()
decl_stmt|;
for|for
control|(
name|TableScanOperator
name|tsOp
range|:
name|topOps
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|tsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getPartColumns
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|tsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getPartColumns
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|notValidTableScanOps
operator|.
name|add
argument_list|(
name|tsOp
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 2) TS with DPP.
name|Collection
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|tableScanOps
init|=
name|Lists
operator|.
expr|<
name|Operator
argument_list|<
name|?
argument_list|>
operator|>
name|newArrayList
argument_list|(
name|topOps
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|AppMasterEventOperator
argument_list|>
name|s
init|=
name|OperatorUtils
operator|.
name|findOperators
argument_list|(
name|tableScanOps
argument_list|,
name|AppMasterEventOperator
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|AppMasterEventOperator
name|a
range|:
name|s
control|)
block|{
if|if
condition|(
name|a
operator|.
name|getConf
argument_list|()
operator|instanceof
name|DynamicPruningEventDesc
condition|)
block|{
name|DynamicPruningEventDesc
name|dped
init|=
operator|(
name|DynamicPruningEventDesc
operator|)
name|a
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|notValidTableScanOps
operator|.
name|add
argument_list|(
name|dped
operator|.
name|getTableScan
argument_list|()
argument_list|)
expr_stmt|;
name|optimizerCache
operator|.
name|tableScanToDPPSource
operator|.
name|put
argument_list|(
name|dped
operator|.
name|getTableScan
argument_list|()
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 3) TS with semijoin DPP.
for|for
control|(
name|Entry
argument_list|<
name|ReduceSinkOperator
argument_list|,
name|SemiJoinBranchInfo
argument_list|>
name|e
range|:
name|pctx
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|notValidTableScanOps
operator|.
name|add
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getTsOp
argument_list|()
argument_list|)
expr_stmt|;
name|optimizerCache
operator|.
name|tableScanToDPPSource
operator|.
name|put
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getTsOp
argument_list|()
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|notValidTableScanOps
return|;
block|}
specifier|private
specifier|static
name|Multimap
argument_list|<
name|String
argument_list|,
name|Entry
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
argument_list|>
name|splitTableScanOpsByTable
parameter_list|(
name|ParseContext
name|pctx
parameter_list|)
block|{
name|Multimap
argument_list|<
name|String
argument_list|,
name|Entry
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
argument_list|>
name|tableNameToOps
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|e
range|:
name|pctx
operator|.
name|getTopOps
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|TableScanOperator
name|tsOp
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|tableNameToOps
operator|.
name|put
argument_list|(
name|tsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getTableMetadata
argument_list|()
operator|.
name|getDbName
argument_list|()
operator|+
literal|"."
operator|+
name|tsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getTableMetadata
argument_list|()
operator|.
name|getTableName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|tableNameToOps
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|>
name|rankTablesByAccumulatedSize
parameter_list|(
name|ParseContext
name|pctx
parameter_list|,
name|Set
argument_list|<
name|TableScanOperator
argument_list|>
name|excludeTables
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|tableToTotalSize
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|e
range|:
name|pctx
operator|.
name|getTopOps
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|TableScanOperator
name|tsOp
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|excludeTables
operator|.
name|contains
argument_list|(
name|tsOp
argument_list|)
condition|)
block|{
comment|// Skip operator, currently we do not merge
continue|continue;
block|}
name|String
name|tableName
init|=
name|tsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getTableMetadata
argument_list|()
operator|.
name|getDbName
argument_list|()
operator|+
literal|"."
operator|+
name|tsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getTableMetadata
argument_list|()
operator|.
name|getTableName
argument_list|()
decl_stmt|;
name|long
name|tableSize
init|=
name|tsOp
operator|.
name|getStatistics
argument_list|()
operator|!=
literal|null
condition|?
name|tsOp
operator|.
name|getStatistics
argument_list|()
operator|.
name|getDataSize
argument_list|()
else|:
literal|0L
decl_stmt|;
name|Long
name|totalSize
init|=
name|tableToTotalSize
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|totalSize
operator|!=
literal|null
condition|)
block|{
name|tableToTotalSize
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|StatsUtils
operator|.
name|safeAdd
argument_list|(
name|totalSize
argument_list|,
name|tableSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tableToTotalSize
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|tableSize
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|>
name|sortedTables
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|(
name|tableToTotalSize
operator|.
name|entrySet
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|sortedTables
argument_list|,
name|Collections
operator|.
name|reverseOrder
argument_list|(
operator|new
name|Comparator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|o1
parameter_list|,
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|o2
parameter_list|)
block|{
return|return
operator|(
name|o1
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sortedTables
return|;
block|}
specifier|private
specifier|static
name|boolean
name|validPreConditions
parameter_list|(
name|ParseContext
name|pctx
parameter_list|,
name|SharedScanOptimizerCache
name|optimizerCache
parameter_list|,
name|TableScanOperator
name|prevTsOp
parameter_list|,
name|TableScanOperator
name|tsOp
parameter_list|)
block|{
comment|// 1) The set of operators in the works of the TS operators need to meet
comment|// some requirements. In particular:
comment|// 1.1. None of the works that contain the TS operators can contain a Union
comment|// operator. This is not supported yet as we might end up with cycles in
comment|// the Tez DAG.
comment|// 1.2. There cannot be more than one DummyStore operator in the new resulting
comment|// work when the TS operators are merged. This is due to an assumption in
comment|// MergeJoinProc that needs to be further explored.
comment|// If any of these conditions are not met, we cannot merge.
comment|// TODO: Extend rule so it can be apply for these cases.
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|workOps1
init|=
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|prevTsOp
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|workOps2
init|=
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|tsOp
argument_list|)
decl_stmt|;
name|boolean
name|foundDummyStoreOp
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|workOps1
control|)
block|{
if|if
condition|(
name|op
operator|instanceof
name|UnionOperator
condition|)
block|{
comment|// We cannot merge (1.1)
return|return
literal|false
return|;
block|}
if|if
condition|(
name|op
operator|instanceof
name|DummyStoreOperator
condition|)
block|{
name|foundDummyStoreOp
operator|=
literal|true
expr_stmt|;
block|}
block|}
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|workOps2
control|)
block|{
if|if
condition|(
name|op
operator|instanceof
name|UnionOperator
condition|)
block|{
comment|// We cannot merge (1.1)
return|return
literal|false
return|;
block|}
if|if
condition|(
name|foundDummyStoreOp
operator|&&
name|op
operator|instanceof
name|DummyStoreOperator
condition|)
block|{
comment|// We cannot merge (1.2)
return|return
literal|false
return|;
block|}
block|}
comment|// 2) We check whether output works when we merge the operators will collide.
comment|//
comment|//   Work1   Work2    (merge TS in W1& W2)        Work1
comment|//       \   /                  ->                  | |       X
comment|//       Work3                                     Work3
comment|//
comment|// If we do, we cannot merge. The reason is that Tez currently does
comment|// not support parallel edges, i.e., multiple edges from same work x
comment|// into same work y.
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|outputWorksOps1
init|=
name|findChildWorkOperators
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|prevTsOp
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|outputWorksOps2
init|=
name|findChildWorkOperators
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|tsOp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Collections
operator|.
name|disjoint
argument_list|(
name|outputWorksOps1
argument_list|,
name|outputWorksOps2
argument_list|)
condition|)
block|{
comment|// We cannot merge
return|return
literal|false
return|;
block|}
comment|// 3) We check whether we will end up with same operators inputing on same work.
comment|//
comment|//       Work1        (merge TS in W2& W3)        Work1
comment|//       /   \                  ->                  | |       X
comment|//   Work2   Work3                                 Work2
comment|//
comment|// If we do, we cannot merge. The reason is the same as above, currently
comment|// Tez currently does not support parallel edges.
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|inputWorksOps1
init|=
name|findParentWorkOperators
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|prevTsOp
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|inputWorksOps2
init|=
name|findParentWorkOperators
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|tsOp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Collections
operator|.
name|disjoint
argument_list|(
name|inputWorksOps1
argument_list|,
name|inputWorksOps2
argument_list|)
condition|)
block|{
comment|// We cannot merge
return|return
literal|false
return|;
block|}
comment|// 4) We check whether one of the operators is part of a work that is an input for
comment|// the work of the other operator.
comment|//
comment|//   Work1            (merge TS in W1& W3)        Work1
comment|//     |                        ->                   |        X
comment|//   Work2                                         Work2
comment|//     |                                             |
comment|//   Work3                                         Work1
comment|//
comment|// If we do, we cannot merge, as we would end up with a cycle in the DAG.
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|descendantWorksOps1
init|=
name|findDescendantWorkOperators
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|prevTsOp
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|descendantWorksOps2
init|=
name|findDescendantWorkOperators
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|tsOp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Collections
operator|.
name|disjoint
argument_list|(
name|descendantWorksOps1
argument_list|,
name|workOps2
argument_list|)
operator|||
operator|!
name|Collections
operator|.
name|disjoint
argument_list|(
name|workOps1
argument_list|,
name|descendantWorksOps2
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// 5) We check whether merging the works would cause the size of
comment|// the data in memory grow too large.
comment|// TODO: Currently ignores GBY and PTF which may also buffer data in memory.
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|newWorkOps
init|=
name|workOps1
decl_stmt|;
name|newWorkOps
operator|.
name|addAll
argument_list|(
name|workOps2
argument_list|)
expr_stmt|;
name|long
name|dataSize
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|newWorkOps
control|)
block|{
if|if
condition|(
name|op
operator|instanceof
name|MapJoinOperator
condition|)
block|{
name|MapJoinOperator
name|mop
init|=
operator|(
name|MapJoinOperator
operator|)
name|op
decl_stmt|;
name|dataSize
operator|=
name|StatsUtils
operator|.
name|safeAdd
argument_list|(
name|dataSize
argument_list|,
name|mop
operator|.
name|getConf
argument_list|()
operator|.
name|getInMemoryDataSize
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|dataSize
operator|>
name|mop
operator|.
name|getConf
argument_list|()
operator|.
name|getNoConditionalTaskSize
argument_list|()
condition|)
block|{
comment|// Size surpasses limit, we cannot convert
name|LOG
operator|.
name|debug
argument_list|(
literal|"accumulated data size: {} / max size: {}"
argument_list|,
name|dataSize
argument_list|,
name|mop
operator|.
name|getConf
argument_list|()
operator|.
name|getNoConditionalTaskSize
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
specifier|static
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|findParentWorkOperators
parameter_list|(
name|ParseContext
name|pctx
parameter_list|,
name|SharedScanOptimizerCache
name|optimizerCache
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|start
parameter_list|)
block|{
comment|// Find operators in work
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|workOps
init|=
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|start
argument_list|)
decl_stmt|;
comment|// Gather input works operators
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|workOps
control|)
block|{
if|if
condition|(
name|op
operator|.
name|getParentOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
range|:
name|op
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
if|if
condition|(
name|parent
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|instanceof
name|TableScanOperator
condition|)
block|{
comment|// Check for DPP and semijoin DPP
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
range|:
name|optimizerCache
operator|.
name|tableScanToDPPSource
operator|.
name|get
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|op
argument_list|)
control|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|set
return|;
block|}
specifier|private
specifier|static
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|findChildWorkOperators
parameter_list|(
name|ParseContext
name|pctx
parameter_list|,
name|SharedScanOptimizerCache
name|optimizerCache
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|start
parameter_list|)
block|{
comment|// Find operators in work
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|workOps
init|=
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|start
argument_list|)
decl_stmt|;
comment|// Gather output works operators
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|workOps
control|)
block|{
if|if
condition|(
name|op
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
if|if
condition|(
name|op
operator|.
name|getChildOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// All children of RS are descendants
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|child
range|:
name|op
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|child
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Semijoin DPP work is considered an child because work needs
comment|// to finish for it to execute
name|SemiJoinBranchInfo
name|sjbi
init|=
name|pctx
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|get
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|sjbi
operator|!=
literal|null
condition|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|sjbi
operator|.
name|getTsOp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|.
name|getConf
argument_list|()
operator|instanceof
name|DynamicPruningEventDesc
condition|)
block|{
comment|// DPP work is considered an child because work needs
comment|// to finish for it to execute
name|set
operator|.
name|addAll
argument_list|(
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
operator|(
operator|(
name|DynamicPruningEventDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
operator|)
operator|.
name|getTableScan
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|set
return|;
block|}
specifier|private
specifier|static
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|findDescendantWorkOperators
parameter_list|(
name|ParseContext
name|pctx
parameter_list|,
name|SharedScanOptimizerCache
name|optimizerCache
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|start
parameter_list|)
block|{
comment|// Find operators in work
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|workOps
init|=
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|start
argument_list|)
decl_stmt|;
comment|// Gather output works operators
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|HashSet
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|set
decl_stmt|;
while|while
condition|(
operator|!
name|workOps
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|set
operator|=
operator|new
name|HashSet
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|workOps
control|)
block|{
if|if
condition|(
name|op
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
if|if
condition|(
name|op
operator|.
name|getChildOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// All children of RS are descendants
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|child
range|:
name|op
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|child
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Semijoin DPP work is considered a descendant because work needs
comment|// to finish for it to execute
name|SemiJoinBranchInfo
name|sjbi
init|=
name|pctx
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|get
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|sjbi
operator|!=
literal|null
condition|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|sjbi
operator|.
name|getTsOp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|.
name|getConf
argument_list|()
operator|instanceof
name|DynamicPruningEventDesc
condition|)
block|{
comment|// DPP work is considered a descendant because work needs
comment|// to finish for it to execute
name|set
operator|.
name|addAll
argument_list|(
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
operator|(
operator|(
name|DynamicPruningEventDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
operator|)
operator|.
name|getTableScan
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|workOps
operator|=
name|set
expr_stmt|;
name|result
operator|.
name|addAll
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|// Stores result in cache
specifier|private
specifier|static
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|findWorkOperators
parameter_list|(
name|SharedScanOptimizerCache
name|optimizerCache
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|start
parameter_list|)
block|{
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|c
init|=
name|optimizerCache
operator|.
name|operatorToWorkOperators
operator|.
name|get
argument_list|(
name|start
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|c
return|;
block|}
name|c
operator|=
name|findWorkOperators
argument_list|(
name|start
argument_list|,
operator|new
name|HashSet
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|c
control|)
block|{
name|optimizerCache
operator|.
name|operatorToWorkOperators
operator|.
name|putAll
argument_list|(
name|op
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
specifier|private
specifier|static
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|findWorkOperators
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|start
parameter_list|,
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|found
parameter_list|)
block|{
name|found
operator|.
name|add
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|.
name|getParentOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
range|:
name|start
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
if|if
condition|(
name|parent
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|found
operator|.
name|contains
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|findWorkOperators
argument_list|(
name|parent
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|start
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
return|return
name|found
return|;
block|}
if|if
condition|(
name|start
operator|.
name|getChildOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|child
range|:
name|start
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|found
operator|.
name|contains
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|findWorkOperators
argument_list|(
name|child
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|found
return|;
block|}
specifier|private
specifier|static
name|void
name|pushFilterToTopOfTableScan
parameter_list|(
name|SharedScanOptimizerCache
name|optimizerCache
parameter_list|,
name|TableScanOperator
name|tsOp
parameter_list|)
throws|throws
name|UDFArgumentException
block|{
name|ExprNodeGenericFuncDesc
name|tableScanExprNode
init|=
name|tsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getFilterExpr
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|allChildren
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|tsOp
operator|.
name|getChildOperators
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|allChildren
control|)
block|{
if|if
condition|(
name|op
operator|instanceof
name|FilterOperator
condition|)
block|{
name|FilterOperator
name|filterOp
init|=
operator|(
name|FilterOperator
operator|)
name|op
decl_stmt|;
name|ExprNodeDesc
name|filterExprNode
init|=
name|filterOp
operator|.
name|getConf
argument_list|()
operator|.
name|getPredicate
argument_list|()
decl_stmt|;
if|if
condition|(
name|tableScanExprNode
operator|.
name|isSame
argument_list|(
name|filterExprNode
argument_list|)
condition|)
block|{
comment|// We do not need to do anything
return|return;
block|}
if|if
condition|(
name|tableScanExprNode
operator|.
name|getGenericUDF
argument_list|()
operator|instanceof
name|GenericUDFOPOr
condition|)
block|{
for|for
control|(
name|ExprNodeDesc
name|childExprNode
range|:
name|tableScanExprNode
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
name|childExprNode
operator|.
name|isSame
argument_list|(
name|filterExprNode
argument_list|)
condition|)
block|{
comment|// We do not need to do anything, it is in the OR expression
comment|// so probably we pushed previously
return|return;
block|}
block|}
block|}
name|ExprNodeGenericFuncDesc
name|newPred
init|=
name|ExprNodeGenericFuncDesc
operator|.
name|newInstance
argument_list|(
operator|new
name|GenericUDFOPAnd
argument_list|()
argument_list|,
name|Arrays
operator|.
expr|<
name|ExprNodeDesc
operator|>
name|asList
argument_list|(
name|tableScanExprNode
operator|.
name|clone
argument_list|()
argument_list|,
name|filterExprNode
argument_list|)
argument_list|)
decl_stmt|;
name|filterOp
operator|.
name|getConf
argument_list|()
operator|.
name|setPredicate
argument_list|(
name|newPred
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Operator
argument_list|<
name|FilterDesc
argument_list|>
name|newOp
init|=
name|OperatorFactory
operator|.
name|get
argument_list|(
name|tsOp
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
operator|new
name|FilterDesc
argument_list|(
name|tableScanExprNode
operator|.
name|clone
argument_list|()
argument_list|,
literal|false
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|tsOp
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|tsOp
operator|.
name|replaceChild
argument_list|(
name|op
argument_list|,
name|newOp
argument_list|)
expr_stmt|;
name|newOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|add
argument_list|(
name|tsOp
argument_list|)
expr_stmt|;
name|op
operator|.
name|replaceParent
argument_list|(
name|tsOp
argument_list|,
name|newOp
argument_list|)
expr_stmt|;
name|newOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|// Add to cache (same group as tsOp)
name|optimizerCache
operator|.
name|putIfWorkExists
argument_list|(
name|newOp
argument_list|,
name|tsOp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Cache to accelerate optimization */
specifier|private
specifier|static
class|class
name|SharedScanOptimizerCache
block|{
comment|// Operators that belong to each work
specifier|final
name|HashMultimap
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|operatorToWorkOperators
init|=
name|HashMultimap
operator|.
expr|<
name|Operator
argument_list|<
name|?
argument_list|>
condition|,
name|Operator
argument_list|<
name|?
argument_list|>
operator|>
name|create
argument_list|()
decl_stmt|;
comment|// Table scan operators to DPP sources
specifier|final
name|Multimap
argument_list|<
name|TableScanOperator
argument_list|,
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|tableScanToDPPSource
init|=
name|HashMultimap
operator|.
expr|<
name|TableScanOperator
decl_stmt|,
name|Operator
argument_list|<
name|?
argument_list|>
decl|>
name|create
argument_list|()
decl_stmt|;
comment|// Add new operator to cache work group of existing operator (if group exists)
name|void
name|putIfWorkExists
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|opToAdd
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|existingOp
parameter_list|)
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|c
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operatorToWorkOperators
operator|.
name|get
argument_list|(
name|existingOp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|c
control|)
block|{
name|operatorToWorkOperators
operator|.
name|get
argument_list|(
name|op
argument_list|)
operator|.
name|add
argument_list|(
name|opToAdd
argument_list|)
expr_stmt|;
block|}
name|operatorToWorkOperators
operator|.
name|putAll
argument_list|(
name|opToAdd
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|operatorToWorkOperators
operator|.
name|put
argument_list|(
name|opToAdd
argument_list|,
name|opToAdd
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Remove operator and combine
name|void
name|removeOpAndCombineWork
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|opToRemove
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|replacementOp
parameter_list|)
block|{
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|s
init|=
name|operatorToWorkOperators
operator|.
name|get
argument_list|(
name|opToRemove
argument_list|)
decl_stmt|;
name|s
operator|.
name|remove
argument_list|(
name|opToRemove
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|c1
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|c2
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operatorToWorkOperators
operator|.
name|get
argument_list|(
name|replacementOp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c1
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|c2
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op1
range|:
name|c1
control|)
block|{
name|operatorToWorkOperators
operator|.
name|remove
argument_list|(
name|op1
argument_list|,
name|opToRemove
argument_list|)
expr_stmt|;
comment|// Remove operator
name|operatorToWorkOperators
operator|.
name|putAll
argument_list|(
name|op1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
comment|// Add ops of new collection
block|}
name|operatorToWorkOperators
operator|.
name|removeAll
argument_list|(
name|opToRemove
argument_list|)
expr_stmt|;
comment|// Remove entry for operator
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op2
range|:
name|c2
control|)
block|{
name|operatorToWorkOperators
operator|.
name|putAll
argument_list|(
name|op2
argument_list|,
name|c1
argument_list|)
expr_stmt|;
comment|// Add ops to existing collection
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

