begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFBloomFilter
operator|.
name|GenericUDAFBloomFilterEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|QueryState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|tez
operator|.
name|TezTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|ReadEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|WriteEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|log
operator|.
name|PerfLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Hive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|ConstantPropagate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|ConstantPropagateProcCtx
operator|.
name|ConstantPropagateOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|ConvertJoinMapJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|DynamicPartitionPruningOptimization
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|MergeJoinProc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|ReduceSinkMapJoinProc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|RemoveDynamicPruningBySize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|SetReducerParallelism
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|metainfo
operator|.
name|annotation
operator|.
name|AnnotateWithOpTraits
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|AnnotateRunTimeStatsOptimizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|CrossProductCheck
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|LlapDecider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|MemoryDecider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|MetadataOnlyOptimizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|NullScanOptimizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|PhysicalContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|SerializeFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|StageIDsRearranger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|Vectorizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|stats
operator|.
name|annotation
operator|.
name|AnnotateWithStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
operator|.
name|LogHelper
import|;
end_import

begin_comment
comment|/**  * TezCompiler translates the operator plan into TezTasks.  */
end_comment

begin_class
specifier|public
class|class
name|TezCompiler
extends|extends
name|TaskCompiler
block|{
specifier|protected
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TezCompiler
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
name|TezCompiler
parameter_list|()
block|{   }
annotation|@
name|Override
specifier|public
name|void
name|init
parameter_list|(
name|QueryState
name|queryState
parameter_list|,
name|LogHelper
name|console
parameter_list|,
name|Hive
name|db
parameter_list|)
block|{
name|super
operator|.
name|init
argument_list|(
name|queryState
argument_list|,
name|console
argument_list|,
name|db
argument_list|)
expr_stmt|;
comment|// Tez requires us to use RPC for the query plan
name|HiveConf
operator|.
name|setBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_RPC_QUERY_PLAN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// We require the use of recursive input dirs for union processing
name|conf
operator|.
name|setBoolean
argument_list|(
literal|"mapred.input.dir.recursive"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|optimizeOperatorPlan
parameter_list|(
name|ParseContext
name|pCtx
parameter_list|,
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
parameter_list|,
name|Set
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|PerfLogger
name|perfLogger
init|=
name|SessionState
operator|.
name|getPerfLogger
argument_list|()
decl_stmt|;
comment|// Create the context for the walker
name|OptimizeTezProcContext
name|procCtx
init|=
operator|new
name|OptimizeTezProcContext
argument_list|(
name|conf
argument_list|,
name|pCtx
argument_list|,
name|inputs
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
comment|// setup dynamic partition pruning where possible
name|runDynamicPartitionPruning
argument_list|(
name|procCtx
argument_list|,
name|inputs
argument_list|,
name|outputs
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Setup dynamic partition pruning"
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
comment|// setup stats in the operator plan
name|runStatsAnnotation
argument_list|(
name|procCtx
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Setup stats in the operator plan"
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
comment|// run the optimizations that use stats for optimization
name|runStatsDependentOptimizations
argument_list|(
name|procCtx
argument_list|,
name|inputs
argument_list|,
name|outputs
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Run the optimizations that use stats for optimization"
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
comment|// after the stats phase we might have some cyclic dependencies that we need
comment|// to take care of.
name|runCycleAnalysisForPartitionPruning
argument_list|(
name|procCtx
argument_list|,
name|inputs
argument_list|,
name|outputs
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Run cycle analysis for partition pruning"
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
comment|// Remove semijoin optimization if it creates a cycle with mapside joins
name|removeSemiJoinCyclesDueToMapsideJoins
argument_list|(
name|procCtx
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Remove semijoin optimizations if it creates a cycle with mapside join"
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
comment|// Remove semijoin optimization if SMB join is created.
name|removeSemijoinOptimizationFromSMBJoins
argument_list|(
name|procCtx
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Remove semijoin optimizations if needed"
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
comment|// Remove bloomfilter if no stats generated
name|removeSemiJoinIfNoStats
argument_list|(
name|procCtx
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Remove bloom filter optimizations if needed"
argument_list|)
expr_stmt|;
comment|// need a new run of the constant folding because we might have created lots
comment|// of "and true and true" conditions.
comment|// Rather than run the full constant folding just need to shortcut AND/OR expressions
comment|// involving constant true/false values.
if|if
condition|(
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVEOPTCONSTANTPROPAGATION
argument_list|)
condition|)
block|{
operator|new
name|ConstantPropagate
argument_list|(
name|ConstantPropagateOption
operator|.
name|SHORTCUT
argument_list|)
operator|.
name|transform
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|runCycleAnalysisForPartitionPruning
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|,
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
parameter_list|,
name|Set
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_DYNAMIC_PARTITION_PRUNING
argument_list|)
condition|)
block|{
return|return;
block|}
name|boolean
name|cycleFree
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|cycleFree
condition|)
block|{
name|cycleFree
operator|=
literal|true
expr_stmt|;
name|Set
argument_list|<
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
name|components
init|=
name|getComponents
argument_list|(
name|procCtx
argument_list|)
decl_stmt|;
for|for
control|(
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|component
range|:
name|components
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Component: "
argument_list|)
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|co
range|:
name|component
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Operator: "
operator|+
name|co
operator|.
name|getName
argument_list|()
operator|+
literal|", "
operator|+
name|co
operator|.
name|getIdentifier
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|component
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Found cycle in operator plan..."
argument_list|)
expr_stmt|;
name|cycleFree
operator|=
literal|false
expr_stmt|;
name|removeCycleOperator
argument_list|(
name|component
argument_list|,
name|procCtx
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Cycle free: "
operator|+
name|cycleFree
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|removeCycleOperator
parameter_list|(
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|component
parameter_list|,
name|OptimizeTezProcContext
name|context
parameter_list|)
throws|throws
name|SemanticException
block|{
name|AppMasterEventOperator
name|victimAM
init|=
literal|null
decl_stmt|;
name|TableScanOperator
name|victimTS
init|=
literal|null
decl_stmt|;
name|ReduceSinkOperator
name|victimRS
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|o
range|:
name|component
control|)
block|{
comment|// Look for AppMasterEventOperator or ReduceSinkOperator
if|if
condition|(
name|o
operator|instanceof
name|AppMasterEventOperator
condition|)
block|{
if|if
condition|(
name|victimAM
operator|==
literal|null
operator|||
name|o
operator|.
name|getStatistics
argument_list|()
operator|.
name|getDataSize
argument_list|()
operator|<
name|victimAM
operator|.
name|getStatistics
argument_list|()
operator|.
name|getDataSize
argument_list|()
condition|)
block|{
name|victimAM
operator|=
operator|(
name|AppMasterEventOperator
operator|)
name|o
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|TableScanOperator
name|ts
init|=
name|context
operator|.
name|parseContext
operator|.
name|getRsOpToTsOpMap
argument_list|()
operator|.
name|get
argument_list|(
name|o
argument_list|)
decl_stmt|;
if|if
condition|(
name|ts
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
comment|// Sanity check
assert|assert
name|component
operator|.
name|contains
argument_list|(
name|ts
argument_list|)
assert|;
if|if
condition|(
name|victimRS
operator|==
literal|null
operator|||
name|ts
operator|.
name|getStatistics
argument_list|()
operator|.
name|getDataSize
argument_list|()
operator|<
name|victimTS
operator|.
name|getStatistics
argument_list|()
operator|.
name|getDataSize
argument_list|()
condition|)
block|{
name|victimRS
operator|=
operator|(
name|ReduceSinkOperator
operator|)
name|o
expr_stmt|;
name|victimTS
operator|=
name|ts
expr_stmt|;
block|}
block|}
block|}
comment|// Always set the min/max optimization as victim.
name|Operator
argument_list|<
name|?
argument_list|>
name|victim
init|=
name|victimRS
decl_stmt|;
if|if
condition|(
name|victimRS
operator|==
literal|null
operator|&&
name|victimAM
operator|!=
literal|null
condition|)
block|{
name|victim
operator|=
name|victimAM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|victimAM
operator|==
literal|null
condition|)
block|{
comment|// do nothing
block|}
else|else
block|{
comment|// Cycle consists of atleast one dynamic partition pruning(DPP)
comment|// optimization and atleast one min/max optimization.
comment|// DPP is a better optimization unless it ends up scanning the
comment|// bigger table for keys instead of the smaller table.
comment|// Get the parent TS of victimRS.
name|Operator
argument_list|<
name|?
argument_list|>
name|op
init|=
name|victimRS
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|op
operator|instanceof
name|TableScanOperator
operator|)
condition|)
block|{
name|op
operator|=
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|2
operator|*
name|op
operator|.
name|getStatistics
argument_list|()
operator|.
name|getDataSize
argument_list|()
operator|)
operator|<
name|victimAM
operator|.
name|getStatistics
argument_list|()
operator|.
name|getDataSize
argument_list|()
condition|)
block|{
name|victim
operator|=
name|victimAM
expr_stmt|;
block|}
block|}
if|if
condition|(
name|victim
operator|==
literal|null
operator|||
operator|(
operator|!
name|context
operator|.
name|pruningOpsRemovedByPriorOpt
operator|.
name|isEmpty
argument_list|()
operator|&&
name|context
operator|.
name|pruningOpsRemovedByPriorOpt
operator|.
name|contains
argument_list|(
name|victim
argument_list|)
operator|)
condition|)
block|{
return|return;
block|}
name|GenTezUtils
operator|.
name|removeBranch
argument_list|(
name|victim
argument_list|)
expr_stmt|;
if|if
condition|(
name|victim
operator|==
name|victimRS
condition|)
block|{
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|context
operator|.
name|parseContext
argument_list|,
name|victimRS
argument_list|,
name|victimTS
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// Tarjan's algo
specifier|private
name|Set
argument_list|<
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
name|getComponents
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
block|{
name|Deque
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|deque
init|=
operator|new
name|LinkedList
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|deque
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|AtomicInteger
name|index
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|indexes
init|=
operator|new
name|HashMap
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|lowLinks
init|=
operator|new
name|HashMap
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|Stack
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|nodes
init|=
operator|new
name|Stack
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
name|components
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|o
range|:
name|deque
control|)
block|{
if|if
condition|(
operator|!
name|indexes
operator|.
name|containsKey
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|connect
argument_list|(
name|o
argument_list|,
name|index
argument_list|,
name|nodes
argument_list|,
name|indexes
argument_list|,
name|lowLinks
argument_list|,
name|components
argument_list|,
name|procCtx
operator|.
name|parseContext
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|components
return|;
block|}
specifier|private
name|void
name|connect
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|o
parameter_list|,
name|AtomicInteger
name|index
parameter_list|,
name|Stack
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|nodes
parameter_list|,
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|indexes
parameter_list|,
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|lowLinks
parameter_list|,
name|Set
argument_list|<
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
name|components
parameter_list|,
name|ParseContext
name|parseContext
parameter_list|)
block|{
name|indexes
operator|.
name|put
argument_list|(
name|o
argument_list|,
name|index
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lowLinks
operator|.
name|put
argument_list|(
name|o
argument_list|,
name|index
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|index
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|nodes
operator|.
name|push
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|children
decl_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|AppMasterEventOperator
condition|)
block|{
name|children
operator|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|children
operator|.
name|addAll
argument_list|(
name|o
operator|.
name|getChildOperators
argument_list|()
argument_list|)
expr_stmt|;
name|TableScanOperator
name|ts
init|=
operator|(
operator|(
name|DynamicPruningEventDesc
operator|)
name|o
operator|.
name|getConf
argument_list|()
operator|)
operator|.
name|getTableScan
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding special edge: "
operator|+
name|o
operator|.
name|getName
argument_list|()
operator|+
literal|" --> "
operator|+
name|ts
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|children
operator|.
name|add
argument_list|(
name|ts
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
comment|// min/max case
name|children
operator|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|children
operator|.
name|addAll
argument_list|(
name|o
operator|.
name|getChildOperators
argument_list|()
argument_list|)
expr_stmt|;
name|TableScanOperator
name|ts
init|=
name|parseContext
operator|.
name|getRsOpToTsOpMap
argument_list|()
operator|.
name|get
argument_list|(
name|o
argument_list|)
decl_stmt|;
if|if
condition|(
name|ts
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding special edge: "
operator|+
name|o
operator|.
name|getName
argument_list|()
operator|+
literal|" --> "
operator|+
name|ts
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|children
operator|.
name|add
argument_list|(
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|children
operator|=
name|o
operator|.
name|getChildOperators
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|child
range|:
name|children
control|)
block|{
if|if
condition|(
operator|!
name|indexes
operator|.
name|containsKey
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|connect
argument_list|(
name|child
argument_list|,
name|index
argument_list|,
name|nodes
argument_list|,
name|indexes
argument_list|,
name|lowLinks
argument_list|,
name|components
argument_list|,
name|parseContext
argument_list|)
expr_stmt|;
name|lowLinks
operator|.
name|put
argument_list|(
name|o
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|lowLinks
operator|.
name|get
argument_list|(
name|o
argument_list|)
argument_list|,
name|lowLinks
operator|.
name|get
argument_list|(
name|child
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nodes
operator|.
name|contains
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|lowLinks
operator|.
name|put
argument_list|(
name|o
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|lowLinks
operator|.
name|get
argument_list|(
name|o
argument_list|)
argument_list|,
name|indexes
operator|.
name|get
argument_list|(
name|child
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lowLinks
operator|.
name|get
argument_list|(
name|o
argument_list|)
operator|.
name|equals
argument_list|(
name|indexes
operator|.
name|get
argument_list|(
name|o
argument_list|)
argument_list|)
condition|)
block|{
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|component
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|components
operator|.
name|add
argument_list|(
name|component
argument_list|)
expr_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|current
decl_stmt|;
do|do
block|{
name|current
operator|=
name|nodes
operator|.
name|pop
argument_list|()
expr_stmt|;
name|component
operator|.
name|add
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|current
operator|!=
name|o
condition|)
do|;
block|}
block|}
specifier|private
name|void
name|runStatsAnnotation
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
operator|new
name|AnnotateWithStatistics
argument_list|()
operator|.
name|transform
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|)
expr_stmt|;
operator|new
name|AnnotateWithOpTraits
argument_list|()
operator|.
name|transform
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|runStatsDependentOptimizations
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|,
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
parameter_list|,
name|Set
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Sequence of TableScan operators to be walked
name|Deque
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|deque
init|=
operator|new
name|LinkedList
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|deque
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
comment|// create a walker which walks the tree in a DFS manner while maintaining
comment|// the operator stack.
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Set parallelism - ReduceSink"
argument_list|,
name|ReduceSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|SetReducerParallelism
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Convert Join to Map-join"
argument_list|,
name|JoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|ConvertJoinMapJoin
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Remove dynamic pruning by size"
argument_list|,
name|AppMasterEventOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|RemoveDynamicPruningBySize
argument_list|()
argument_list|)
expr_stmt|;
comment|// The dispatcher fires the processor corresponding to the closest matching
comment|// rule and passes the context along
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|ForwardWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|runDynamicPartitionPruning
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|,
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
parameter_list|,
name|Set
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_DYNAMIC_PARTITION_PRUNING
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Sequence of TableScan operators to be walked
name|Deque
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|deque
init|=
operator|new
name|LinkedList
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|deque
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"Dynamic Partition Pruning"
argument_list|)
argument_list|,
name|FilterOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|DynamicPartitionPruningOptimization
argument_list|()
argument_list|)
expr_stmt|;
comment|// The dispatcher fires the processor corresponding to the closest matching
comment|// rule and passes the context along
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|ForwardWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|generateTaskTree
parameter_list|(
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|rootTasks
parameter_list|,
name|ParseContext
name|pCtx
parameter_list|,
name|List
argument_list|<
name|Task
argument_list|<
name|MoveWork
argument_list|>
argument_list|>
name|mvTask
parameter_list|,
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
parameter_list|,
name|Set
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|PerfLogger
name|perfLogger
init|=
name|SessionState
operator|.
name|getPerfLogger
argument_list|()
decl_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
name|ParseContext
name|tempParseContext
init|=
name|getParseContext
argument_list|(
name|pCtx
argument_list|,
name|rootTasks
argument_list|)
decl_stmt|;
name|GenTezUtils
name|utils
init|=
operator|new
name|GenTezUtils
argument_list|()
decl_stmt|;
name|GenTezWork
name|genTezWork
init|=
operator|new
name|GenTezWork
argument_list|(
name|utils
argument_list|)
decl_stmt|;
name|GenTezProcContext
name|procCtx
init|=
operator|new
name|GenTezProcContext
argument_list|(
name|conf
argument_list|,
name|tempParseContext
argument_list|,
name|mvTask
argument_list|,
name|rootTasks
argument_list|,
name|inputs
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
comment|// create a walker which walks the tree in a DFS manner while maintaining
comment|// the operator stack.
comment|// The dispatcher generates the plan from the operator tree
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Split Work - ReduceSink"
argument_list|,
name|ReduceSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
name|genTezWork
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"No more walking on ReduceSink-MapJoin"
argument_list|,
name|MapJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|ReduceSinkMapJoinProc
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Recognize a Sorted Merge Join operator to setup the right edge and"
operator|+
literal|" stop traversing the DummyStore-MapJoin"
argument_list|,
name|CommonMergeJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|MergeJoinProc
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Split Work + Move/Merge - FileSink"
argument_list|,
name|FileSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|CompositeProcessor
argument_list|(
operator|new
name|FileSinkProcessor
argument_list|()
argument_list|,
name|genTezWork
argument_list|)
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Split work - DummyStore"
argument_list|,
name|DummyStoreOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
name|genTezWork
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Handle Potential Analyze Command"
argument_list|,
name|TableScanOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|ProcessAnalyzeTable
argument_list|(
name|utils
argument_list|)
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Remember union"
argument_list|,
name|UnionOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|UnionProcessor
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"AppMasterEventOperator"
argument_list|,
name|AppMasterEventOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|AppMasterEventProcessor
argument_list|()
argument_list|)
expr_stmt|;
comment|// The dispatcher fires the processor corresponding to the closest matching
comment|// rule and passes the context along
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|pCtx
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|GenTezWorkWalker
argument_list|(
name|disp
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// we need to specify the reserved memory for each work that contains Map Join
for|for
control|(
name|List
argument_list|<
name|BaseWork
argument_list|>
name|baseWorkList
range|:
name|procCtx
operator|.
name|mapJoinWorkMap
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|BaseWork
name|w
range|:
name|baseWorkList
control|)
block|{
comment|// work should be the smallest unit for memory allocation
name|w
operator|.
name|setReservedMemoryMB
argument_list|(
call|(
name|int
call|)
argument_list|(
name|conf
operator|.
name|getLongVar
argument_list|(
name|ConfVars
operator|.
name|HIVECONVERTJOINNOCONDITIONALTASKTHRESHOLD
argument_list|)
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// we need to clone some operator plans and remove union operators still
name|int
name|indexForTezUnion
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BaseWork
name|w
range|:
name|procCtx
operator|.
name|workWithUnionOperators
control|)
block|{
name|GenTezUtils
operator|.
name|removeUnionOperators
argument_list|(
name|procCtx
argument_list|,
name|w
argument_list|,
name|indexForTezUnion
operator|++
argument_list|)
expr_stmt|;
block|}
comment|// then we make sure the file sink operators are set up right
for|for
control|(
name|FileSinkOperator
name|fileSink
range|:
name|procCtx
operator|.
name|fileSinkSet
control|)
block|{
name|GenTezUtils
operator|.
name|processFileSink
argument_list|(
name|procCtx
argument_list|,
name|fileSink
argument_list|)
expr_stmt|;
block|}
comment|// Connect any edges required for min/max pushdown
if|if
condition|(
name|pCtx
operator|.
name|getRsToRuntimeValuesInfoMap
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|ReduceSinkOperator
name|rs
range|:
name|pCtx
operator|.
name|getRsToRuntimeValuesInfoMap
argument_list|()
operator|.
name|keySet
argument_list|()
control|)
block|{
comment|// Process min/max
name|GenTezUtils
operator|.
name|processDynamicMinMaxPushDownOperator
argument_list|(
name|procCtx
argument_list|,
name|pCtx
operator|.
name|getRsToRuntimeValuesInfoMap
argument_list|()
operator|.
name|get
argument_list|(
name|rs
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
block|}
comment|// and finally we hook up any events that need to be sent to the tez AM
name|LOG
operator|.
name|debug
argument_list|(
literal|"There are "
operator|+
name|procCtx
operator|.
name|eventOperatorSet
operator|.
name|size
argument_list|()
operator|+
literal|" app master events."
argument_list|)
expr_stmt|;
for|for
control|(
name|AppMasterEventOperator
name|event
range|:
name|procCtx
operator|.
name|eventOperatorSet
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Handling AppMasterEventOperator: "
operator|+
name|event
argument_list|)
expr_stmt|;
name|GenTezUtils
operator|.
name|processAppMasterEvent
argument_list|(
name|procCtx
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"generateTaskTree"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|setInputFormat
parameter_list|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
parameter_list|)
block|{
if|if
condition|(
name|task
operator|instanceof
name|TezTask
condition|)
block|{
name|TezWork
name|work
init|=
operator|(
operator|(
name|TezTask
operator|)
name|task
operator|)
operator|.
name|getWork
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|BaseWork
argument_list|>
name|all
init|=
name|work
operator|.
name|getAllWork
argument_list|()
decl_stmt|;
for|for
control|(
name|BaseWork
name|w
range|:
name|all
control|)
block|{
if|if
condition|(
name|w
operator|instanceof
name|MapWork
condition|)
block|{
name|MapWork
name|mapWork
init|=
operator|(
name|MapWork
operator|)
name|w
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|opMap
init|=
name|mapWork
operator|.
name|getAliasToWork
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|opMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|opMap
operator|.
name|values
argument_list|()
control|)
block|{
name|setInputFormat
argument_list|(
name|mapWork
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|task
operator|instanceof
name|ConditionalTask
condition|)
block|{
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|listTasks
init|=
operator|(
operator|(
name|ConditionalTask
operator|)
name|task
operator|)
operator|.
name|getListTasks
argument_list|()
decl_stmt|;
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|tsk
range|:
name|listTasks
control|)
block|{
name|setInputFormat
argument_list|(
name|tsk
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|task
operator|.
name|getChildTasks
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|childTask
range|:
name|task
operator|.
name|getChildTasks
argument_list|()
control|)
block|{
name|setInputFormat
argument_list|(
name|childTask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|setInputFormat
parameter_list|(
name|MapWork
name|work
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
block|{
if|if
condition|(
name|op
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|op
operator|.
name|isUseBucketizedHiveInputFormat
argument_list|()
condition|)
block|{
name|work
operator|.
name|setUseBucketizedHiveInputFormat
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|op
operator|.
name|getChildOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|childOp
range|:
name|op
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|setInputFormat
argument_list|(
name|work
argument_list|,
name|childOp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|decideExecMode
parameter_list|(
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|rootTasks
parameter_list|,
name|Context
name|ctx
parameter_list|,
name|GlobalLimitCtx
name|globalLimitCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// currently all Tez work is on the cluster
return|return;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|optimizeTaskPlan
parameter_list|(
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|rootTasks
parameter_list|,
name|ParseContext
name|pCtx
parameter_list|,
name|Context
name|ctx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|PerfLogger
name|perfLogger
init|=
name|SessionState
operator|.
name|getPerfLogger
argument_list|()
decl_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
name|PhysicalContext
name|physicalCtx
init|=
operator|new
name|PhysicalContext
argument_list|(
name|conf
argument_list|,
name|pCtx
argument_list|,
name|pCtx
operator|.
name|getContext
argument_list|()
argument_list|,
name|rootTasks
argument_list|,
name|pCtx
operator|.
name|getFetchTask
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVENULLSCANOPTIMIZE
argument_list|)
condition|)
block|{
name|physicalCtx
operator|=
operator|new
name|NullScanOptimizer
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping null scan query optimization"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMETADATAONLYQUERIES
argument_list|)
condition|)
block|{
name|physicalCtx
operator|=
operator|new
name|MetadataOnlyOptimizer
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping metadata only query optimization"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_CHECK_CROSS_PRODUCT
argument_list|)
condition|)
block|{
name|physicalCtx
operator|=
operator|new
name|CrossProductCheck
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping cross product analysis"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_ENABLED
argument_list|)
operator|&&
name|ctx
operator|.
name|getExplainAnalyze
argument_list|()
operator|==
literal|null
condition|)
block|{
name|physicalCtx
operator|=
operator|new
name|Vectorizer
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping vectorization"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
literal|"none"
operator|.
name|equalsIgnoreCase
argument_list|(
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESTAGEIDREARRANGE
argument_list|)
argument_list|)
condition|)
block|{
name|physicalCtx
operator|=
operator|new
name|StageIDsRearranger
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping stage id rearranger"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_TEZ_ENABLE_MEMORY_MANAGER
argument_list|)
operator|)
operator|&&
operator|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEUSEHYBRIDGRACEHASHJOIN
argument_list|)
operator|)
condition|)
block|{
name|physicalCtx
operator|=
operator|new
name|MemoryDecider
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|"llap"
operator|.
name|equalsIgnoreCase
argument_list|(
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_EXECUTION_MODE
argument_list|)
argument_list|)
condition|)
block|{
name|physicalCtx
operator|=
operator|new
name|LlapDecider
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping llap decider"
argument_list|)
expr_stmt|;
block|}
comment|//  This optimizer will serialize all filters that made it to the
comment|//  table scan operator to avoid having to do it multiple times on
comment|//  the backend. If you have a physical optimization that changes
comment|//  table scans or filters, you have to invoke it before this one.
name|physicalCtx
operator|=
operator|new
name|SerializeFilter
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|physicalCtx
operator|.
name|getContext
argument_list|()
operator|.
name|getExplainAnalyze
argument_list|()
operator|!=
literal|null
condition|)
block|{
operator|new
name|AnnotateRunTimeStatsOptimizer
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"optimizeTaskPlan"
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|private
specifier|static
class|class
name|SemijoinRemovalContext
implements|implements
name|NodeProcessorCtx
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|parents
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
block|}
specifier|private
specifier|static
class|class
name|SemijoinRemovalProc
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|SemijoinRemovalContext
name|ctx
init|=
operator|(
name|SemijoinRemovalContext
operator|)
name|procCtx
decl_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
init|=
operator|(
name|Operator
argument_list|<
name|?
argument_list|>
operator|)
name|stack
operator|.
name|get
argument_list|(
name|stack
operator|.
name|size
argument_list|()
operator|-
literal|2
argument_list|)
decl_stmt|;
name|ctx
operator|.
name|parents
operator|.
name|add
argument_list|(
name|parent
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
specifier|private
specifier|static
name|void
name|collectSemijoinOps
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|ts
parameter_list|,
name|NodeProcessorCtx
name|ctx
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// create a walker which walks the tree in a DFS manner while maintaining
comment|// the operator stack. The dispatcher
comment|// generates the plan from the operator tree
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R1"
argument_list|,
name|SelectOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|TezDummyStoreOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|SemijoinRemovalProc
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R2"
argument_list|,
name|SelectOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|CommonMergeJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|SemijoinRemovalProc
argument_list|()
argument_list|)
expr_stmt|;
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|ctx
argument_list|)
decl_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|PreOrderOnceWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|startNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|startNodes
operator|.
name|add
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
name|outputMap
init|=
operator|new
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|startNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
class|class
name|SMBJoinOpProc
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|TableScanOperator
argument_list|>
name|tsOps
init|=
operator|new
name|ArrayList
argument_list|<
name|TableScanOperator
argument_list|>
argument_list|()
decl_stmt|;
comment|// Get one top level TS Op directly from the stack
name|tsOps
operator|.
name|add
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|stack
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Get the other one by examining Join Op
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|parents
init|=
operator|(
operator|(
name|CommonMergeJoinOperator
operator|)
name|nd
operator|)
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
range|:
name|parents
control|)
block|{
if|if
condition|(
name|parent
operator|instanceof
name|TezDummyStoreOperator
condition|)
block|{
comment|// already accounted for
continue|continue;
block|}
assert|assert
name|parent
operator|instanceof
name|SelectOperator
assert|;
while|while
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|parent
operator|instanceof
name|TableScanOperator
condition|)
block|{
name|tsOps
operator|.
name|add
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|parent
argument_list|)
expr_stmt|;
break|break;
block|}
name|parent
operator|=
name|parent
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Now the relevant TableScanOperators are known, find if there exists
comment|// a semijoin filter on any of them, if so, remove it.
name|ParseContext
name|pctx
init|=
operator|(
operator|(
name|OptimizeTezProcContext
operator|)
name|procCtx
operator|)
operator|.
name|parseContext
decl_stmt|;
for|for
control|(
name|TableScanOperator
name|ts
range|:
name|tsOps
control|)
block|{
for|for
control|(
name|ReduceSinkOperator
name|rs
range|:
name|pctx
operator|.
name|getRsOpToTsOpMap
argument_list|()
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|ts
operator|==
name|pctx
operator|.
name|getRsOpToTsOpMap
argument_list|()
operator|.
name|get
argument_list|(
name|rs
argument_list|)
condition|)
block|{
comment|// match!
name|GenTezUtils
operator|.
name|removeBranch
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|pctx
argument_list|,
name|rs
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
specifier|private
specifier|static
name|void
name|removeSemijoinOptimizationFromSMBJoins
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_DYNAMIC_SEMIJOIN_REDUCTION
argument_list|)
operator|||
name|procCtx
operator|.
name|parseContext
operator|.
name|getRsOpToTsOpMap
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R1"
argument_list|,
name|TableScanOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
literal|".*"
operator|+
name|TezDummyStoreOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|CommonMergeJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|SMBJoinOpProc
argument_list|()
argument_list|)
expr_stmt|;
comment|// The dispatcher finds SMB and if there is semijoin optimization before it, removes it.
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|PreOrderOnceWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
class|class
name|SemiJoinCycleRemovalDueToMapsideJoins
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ParseContext
name|pCtx
init|=
operator|(
operator|(
name|OptimizeTezProcContext
operator|)
name|procCtx
operator|)
operator|.
name|parseContext
decl_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|childJoin
init|=
operator|(
operator|(
name|Operator
argument_list|<
name|?
argument_list|>
operator|)
name|nd
operator|)
decl_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|parentJoin
init|=
operator|(
operator|(
name|Operator
argument_list|<
name|?
argument_list|>
operator|)
name|stack
operator|.
name|get
argument_list|(
name|stack
operator|.
name|size
argument_list|()
operator|-
literal|2
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|parentJoin
operator|.
name|getChildOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// Nothing to do here
return|return
literal|null
return|;
block|}
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|child
range|:
name|parentJoin
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|child
operator|instanceof
name|SelectOperator
operator|)
condition|)
block|{
continue|continue;
block|}
while|while
condition|(
name|child
operator|.
name|getChildOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|child
operator|=
name|child
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|child
operator|instanceof
name|ReduceSinkOperator
operator|)
condition|)
block|{
continue|continue;
block|}
name|ReduceSinkOperator
name|rs
init|=
operator|(
operator|(
name|ReduceSinkOperator
operator|)
name|child
operator|)
decl_stmt|;
name|TableScanOperator
name|ts
init|=
name|pCtx
operator|.
name|getRsOpToTsOpMap
argument_list|()
operator|.
name|get
argument_list|(
name|rs
argument_list|)
decl_stmt|;
if|if
condition|(
name|ts
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
comment|// This is a semijoin branch. Find if this is creating a potential
comment|// cycle with childJoin.
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
range|:
name|childJoin
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
if|if
condition|(
name|parent
operator|==
name|parentJoin
condition|)
block|{
continue|continue;
block|}
assert|assert
name|parent
operator|instanceof
name|ReduceSinkOperator
assert|;
while|while
condition|(
name|parent
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|parent
operator|=
name|parent
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parent
operator|==
name|ts
condition|)
block|{
comment|// We have a cycle!
name|GenTezUtils
operator|.
name|removeBranch
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|pCtx
argument_list|,
name|rs
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
specifier|private
specifier|static
name|void
name|removeSemiJoinCyclesDueToMapsideJoins
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_DYNAMIC_SEMIJOIN_REDUCTION
argument_list|)
operator|||
name|procCtx
operator|.
name|parseContext
operator|.
name|getRsOpToTsOpMap
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R1"
argument_list|,
name|MapJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|MapJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|SemiJoinCycleRemovalDueToMapsideJoins
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R2"
argument_list|,
name|MapJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|CommonMergeJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|SemiJoinCycleRemovalDueToMapsideJoins
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R3"
argument_list|,
name|CommonMergeJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|MapJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|SemiJoinCycleRemovalDueToMapsideJoins
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R4"
argument_list|,
name|CommonMergeJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|CommonMergeJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|SemiJoinCycleRemovalDueToMapsideJoins
argument_list|()
argument_list|)
expr_stmt|;
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|PreOrderOnceWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
class|class
name|SemiJoinRemovalIfNoStatsProc
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
assert|assert
name|nd
operator|instanceof
name|ReduceSinkOperator
assert|;
name|ReduceSinkOperator
name|rs
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|nd
decl_stmt|;
name|ParseContext
name|pCtx
init|=
operator|(
operator|(
name|OptimizeTezProcContext
operator|)
name|procCtx
operator|)
operator|.
name|parseContext
decl_stmt|;
name|TableScanOperator
name|ts
init|=
name|pCtx
operator|.
name|getRsOpToTsOpMap
argument_list|()
operator|.
name|get
argument_list|(
name|rs
argument_list|)
decl_stmt|;
if|if
condition|(
name|ts
operator|==
literal|null
condition|)
block|{
comment|// nothing to do here.
return|return
literal|null
return|;
block|}
comment|// This is a semijoin branch. The stack should look like,
comment|//<Parent Ops>-SEL-GB1-RS1-GB2-RS2
name|GroupByOperator
name|gbOp
init|=
call|(
name|GroupByOperator
call|)
argument_list|(
name|stack
operator|.
name|get
argument_list|(
name|stack
operator|.
name|size
argument_list|()
operator|-
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|GroupByDesc
name|gbDesc
init|=
name|gbOp
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
name|aggregationDescs
init|=
name|gbDesc
operator|.
name|getAggregators
argument_list|()
decl_stmt|;
name|boolean
name|removeSemiJoin
init|=
literal|false
decl_stmt|;
for|for
control|(
name|AggregationDesc
name|agg
range|:
name|aggregationDescs
control|)
block|{
if|if
condition|(
name|agg
operator|.
name|getGenericUDAFName
argument_list|()
operator|!=
literal|"bloom_filter"
condition|)
block|{
continue|continue;
block|}
name|GenericUDAFBloomFilterEvaluator
name|udafBloomFilterEvaluator
init|=
operator|(
name|GenericUDAFBloomFilterEvaluator
operator|)
name|agg
operator|.
name|getGenericUDAFEvaluator
argument_list|()
decl_stmt|;
name|long
name|expectedEntries
init|=
name|udafBloomFilterEvaluator
operator|.
name|getExpectedEntries
argument_list|()
decl_stmt|;
if|if
condition|(
name|expectedEntries
operator|==
operator|-
literal|1
operator|||
name|expectedEntries
operator|>
name|pCtx
operator|.
name|getConf
argument_list|()
operator|.
name|getLongVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_MAX_BLOOM_FILTER_ENTRIES
argument_list|)
condition|)
block|{
name|removeSemiJoin
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|removeSemiJoin
condition|)
block|{
comment|// The stats are not annotated, remove the semijoin operator
name|GenTezUtils
operator|.
name|removeBranch
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|pCtx
argument_list|,
name|rs
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
specifier|private
name|void
name|removeSemiJoinIfNoStats
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_DYNAMIC_SEMIJOIN_REDUCTION
argument_list|)
condition|)
block|{
comment|// Not needed without semi-join reduction
return|return;
block|}
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R1"
argument_list|,
name|GroupByOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|ReduceSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|GroupByOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|ReduceSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|SemiJoinRemovalIfNoStatsProc
argument_list|()
argument_list|)
expr_stmt|;
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|PreOrderOnceWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

