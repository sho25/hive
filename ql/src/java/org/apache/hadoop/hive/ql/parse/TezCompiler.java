begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|QueryState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|AppMasterEventOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|CommonMergeJoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ConditionalTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|DummyStoreOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FileSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FilterOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|GroupByOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|JoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|MapJoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|SelectOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TableScanOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Task
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TezDummyStoreOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|UnionOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|tez
operator|.
name|TezTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|ReadEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|WriteEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|CompositeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|DefaultRuleDispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Dispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|ForwardWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|GraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessorCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|PreOrderOnceWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|RuleRegExp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|log
operator|.
name|PerfLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Hive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|ConstantPropagate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|ConstantPropagateProcCtx
operator|.
name|ConstantPropagateOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|ConvertJoinMapJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|DynamicPartitionPruningOptimization
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|MergeJoinProc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|ReduceSinkMapJoinProc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|RemoveDynamicPruningBySize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|SetReducerParallelism
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|SharedWorkOptimizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|correlation
operator|.
name|ReduceSinkJoinDeDuplication
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|metainfo
operator|.
name|annotation
operator|.
name|AnnotateWithOpTraits
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|AnnotateRunTimeStatsOptimizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|CrossProductCheck
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|LlapClusterStateForCompile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|LlapDecider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|LlapPreVectorizationPass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|MemoryDecider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|MetadataOnlyOptimizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|NullScanOptimizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|PhysicalContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|SerializeFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|StageIDsRearranger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|Vectorizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|stats
operator|.
name|annotation
operator|.
name|AnnotateWithStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AggregationDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|BaseWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ColStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DynamicPruningEventDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDescUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|GroupByDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MapWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MoveWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|Statistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TezWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
operator|.
name|LogHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|stats
operator|.
name|StatsUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFBloomFilter
operator|.
name|GenericUDAFBloomFilterEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * TezCompiler translates the operator plan into TezTasks.  */
end_comment

begin_class
specifier|public
class|class
name|TezCompiler
extends|extends
name|TaskCompiler
block|{
specifier|protected
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TezCompiler
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
name|TezCompiler
parameter_list|()
block|{   }
annotation|@
name|Override
specifier|public
name|void
name|init
parameter_list|(
name|QueryState
name|queryState
parameter_list|,
name|LogHelper
name|console
parameter_list|,
name|Hive
name|db
parameter_list|)
block|{
name|super
operator|.
name|init
argument_list|(
name|queryState
argument_list|,
name|console
argument_list|,
name|db
argument_list|)
expr_stmt|;
comment|// Tez requires us to use RPC for the query plan
name|HiveConf
operator|.
name|setBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_RPC_QUERY_PLAN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// We require the use of recursive input dirs for union processing
name|conf
operator|.
name|setBoolean
argument_list|(
literal|"mapred.input.dir.recursive"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|optimizeOperatorPlan
parameter_list|(
name|ParseContext
name|pCtx
parameter_list|,
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
parameter_list|,
name|Set
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|PerfLogger
name|perfLogger
init|=
name|SessionState
operator|.
name|getPerfLogger
argument_list|()
decl_stmt|;
comment|// Create the context for the walker
name|OptimizeTezProcContext
name|procCtx
init|=
operator|new
name|OptimizeTezProcContext
argument_list|(
name|conf
argument_list|,
name|pCtx
argument_list|,
name|inputs
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
comment|// setup dynamic partition pruning where possible
name|runDynamicPartitionPruning
argument_list|(
name|procCtx
argument_list|,
name|inputs
argument_list|,
name|outputs
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Setup dynamic partition pruning"
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
comment|// setup stats in the operator plan
name|runStatsAnnotation
argument_list|(
name|procCtx
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Setup stats in the operator plan"
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
comment|// run the optimizations that use stats for optimization
name|runStatsDependentOptimizations
argument_list|(
name|procCtx
argument_list|,
name|inputs
argument_list|,
name|outputs
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Run the optimizations that use stats for optimization"
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
if|if
condition|(
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVEOPTJOINREDUCEDEDUPLICATION
argument_list|)
condition|)
block|{
operator|new
name|ReduceSinkJoinDeDuplication
argument_list|()
operator|.
name|transform
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|)
expr_stmt|;
block|}
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Run reduce sink after join algorithm selection"
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
name|runRemoveDynamicPruningOptimization
argument_list|(
name|procCtx
argument_list|,
name|inputs
argument_list|,
name|outputs
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Run remove dynamic pruning by size"
argument_list|)
expr_stmt|;
comment|// Removing semijoin optimization when it may not be beneficial
name|removeSemijoinOptimizationByBenefit
argument_list|(
name|procCtx
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
comment|// Remove any parallel edge between semijoin and mapjoin.
name|removeSemijoinsParallelToMapJoin
argument_list|(
name|procCtx
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Run the optimizations that use stats for optimization"
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
comment|// Remove semijoin optimization if it creates a cycle with mapside joins
name|removeSemiJoinCyclesDueToMapsideJoins
argument_list|(
name|procCtx
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Remove semijoin optimizations if it creates a cycle with mapside join"
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
comment|// Remove semijoin optimization if SMB join is created.
name|removeSemijoinOptimizationFromSMBJoins
argument_list|(
name|procCtx
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Remove semijoin optimizations if needed"
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
comment|// Remove bloomfilter if no stats generated
name|removeSemiJoinIfNoStats
argument_list|(
name|procCtx
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Remove bloom filter optimizations if needed"
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
comment|// after the stats phase we might have some cyclic dependencies that we need
comment|// to take care of.
name|runCycleAnalysisForPartitionPruning
argument_list|(
name|procCtx
argument_list|,
name|inputs
argument_list|,
name|outputs
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Run cycle analysis for partition pruning"
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
if|if
condition|(
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_SHARED_WORK_OPTIMIZATION
argument_list|)
condition|)
block|{
operator|new
name|SharedWorkOptimizer
argument_list|()
operator|.
name|transform
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|)
expr_stmt|;
block|}
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Shared scans optimization"
argument_list|)
expr_stmt|;
comment|// need a new run of the constant folding because we might have created lots
comment|// of "and true and true" conditions.
comment|// Rather than run the full constant folding just need to shortcut AND/OR expressions
comment|// involving constant true/false values.
if|if
condition|(
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVEOPTCONSTANTPROPAGATION
argument_list|)
condition|)
block|{
operator|new
name|ConstantPropagate
argument_list|(
name|ConstantPropagateOption
operator|.
name|SHORTCUT
argument_list|)
operator|.
name|transform
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|runCycleAnalysisForPartitionPruning
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|,
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
parameter_list|,
name|Set
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_DYNAMIC_PARTITION_PRUNING
argument_list|)
condition|)
block|{
return|return;
block|}
name|boolean
name|cycleFree
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|cycleFree
condition|)
block|{
name|cycleFree
operator|=
literal|true
expr_stmt|;
name|Set
argument_list|<
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
name|components
init|=
name|getComponents
argument_list|(
name|procCtx
argument_list|)
decl_stmt|;
for|for
control|(
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|component
range|:
name|components
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Component: "
argument_list|)
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|co
range|:
name|component
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Operator: "
operator|+
name|co
operator|.
name|getName
argument_list|()
operator|+
literal|", "
operator|+
name|co
operator|.
name|getIdentifier
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|component
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Found cycle in operator plan..."
argument_list|)
expr_stmt|;
name|cycleFree
operator|=
literal|false
expr_stmt|;
name|removeCycleOperator
argument_list|(
name|component
argument_list|,
name|procCtx
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Cycle free: "
operator|+
name|cycleFree
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|removeCycleOperator
parameter_list|(
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|component
parameter_list|,
name|OptimizeTezProcContext
name|context
parameter_list|)
throws|throws
name|SemanticException
block|{
name|AppMasterEventOperator
name|victimAM
init|=
literal|null
decl_stmt|;
name|TableScanOperator
name|victimTS
init|=
literal|null
decl_stmt|;
name|ReduceSinkOperator
name|victimRS
init|=
literal|null
decl_stmt|;
comment|// If there is a hint and no operator is removed then throw error
name|boolean
name|hasHint
init|=
literal|false
decl_stmt|;
name|boolean
name|removed
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|o
range|:
name|component
control|)
block|{
comment|// Look for AppMasterEventOperator or ReduceSinkOperator
if|if
condition|(
name|o
operator|instanceof
name|AppMasterEventOperator
condition|)
block|{
if|if
condition|(
name|victimAM
operator|==
literal|null
operator|||
name|o
operator|.
name|getStatistics
argument_list|()
operator|.
name|getDataSize
argument_list|()
operator|<
name|victimAM
operator|.
name|getStatistics
argument_list|()
operator|.
name|getDataSize
argument_list|()
condition|)
block|{
name|victimAM
operator|=
operator|(
name|AppMasterEventOperator
operator|)
name|o
expr_stmt|;
name|removed
operator|=
literal|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|SemiJoinBranchInfo
name|sjInfo
init|=
name|context
operator|.
name|parseContext
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|get
argument_list|(
name|o
argument_list|)
decl_stmt|;
if|if
condition|(
name|sjInfo
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
name|sjInfo
operator|.
name|getIsHint
argument_list|()
condition|)
block|{
comment|// Skipping because of hint. Mark this info,
name|hasHint
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
name|TableScanOperator
name|ts
init|=
name|sjInfo
operator|.
name|getTsOp
argument_list|()
decl_stmt|;
comment|// Sanity check
assert|assert
name|component
operator|.
name|contains
argument_list|(
name|ts
argument_list|)
assert|;
if|if
condition|(
name|victimRS
operator|==
literal|null
operator|||
name|ts
operator|.
name|getStatistics
argument_list|()
operator|.
name|getDataSize
argument_list|()
operator|<
name|victimTS
operator|.
name|getStatistics
argument_list|()
operator|.
name|getDataSize
argument_list|()
condition|)
block|{
name|victimRS
operator|=
operator|(
name|ReduceSinkOperator
operator|)
name|o
expr_stmt|;
name|victimTS
operator|=
name|ts
expr_stmt|;
name|removed
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
comment|// Always set the semijoin optimization as victim.
name|Operator
argument_list|<
name|?
argument_list|>
name|victim
init|=
name|victimRS
decl_stmt|;
if|if
condition|(
name|victimRS
operator|==
literal|null
operator|&&
name|victimAM
operator|!=
literal|null
condition|)
block|{
name|victim
operator|=
name|victimAM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|victimAM
operator|==
literal|null
condition|)
block|{
comment|// do nothing
block|}
else|else
block|{
comment|// Cycle consists of atleast one dynamic partition pruning(DPP)
comment|// optimization and atleast one min/max optimization.
comment|// DPP is a better optimization unless it ends up scanning the
comment|// bigger table for keys instead of the smaller table.
comment|// Get the parent TS of victimRS.
name|Operator
argument_list|<
name|?
argument_list|>
name|op
init|=
name|victimRS
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|op
operator|instanceof
name|TableScanOperator
operator|)
condition|)
block|{
name|op
operator|=
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|2
operator|*
name|op
operator|.
name|getStatistics
argument_list|()
operator|.
name|getDataSize
argument_list|()
operator|)
operator|<
name|victimAM
operator|.
name|getStatistics
argument_list|()
operator|.
name|getDataSize
argument_list|()
condition|)
block|{
name|victim
operator|=
name|victimAM
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hasHint
operator|&&
operator|!
name|removed
condition|)
block|{
comment|// There is hint but none of the operators removed. Throw error
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"The user hint is causing an operator cycle. Please fix it and retry"
argument_list|)
throw|;
block|}
if|if
condition|(
name|victim
operator|==
literal|null
operator|||
operator|(
operator|!
name|context
operator|.
name|pruningOpsRemovedByPriorOpt
operator|.
name|isEmpty
argument_list|()
operator|&&
name|context
operator|.
name|pruningOpsRemovedByPriorOpt
operator|.
name|contains
argument_list|(
name|victim
argument_list|)
operator|)
condition|)
block|{
return|return;
block|}
name|GenTezUtils
operator|.
name|removeBranch
argument_list|(
name|victim
argument_list|)
expr_stmt|;
if|if
condition|(
name|victim
operator|==
name|victimRS
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Cycle found. Removing semijoin "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|victimRS
argument_list|)
operator|+
literal|" - "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|victimTS
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|context
operator|.
name|parseContext
argument_list|,
name|victimRS
argument_list|,
name|victimTS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// at this point we've found the fork in the op pipeline that has the pruning as a child plan.
name|LOG
operator|.
name|info
argument_list|(
literal|"Disabling dynamic pruning for: "
operator|+
operator|(
operator|(
name|DynamicPruningEventDesc
operator|)
name|victim
operator|.
name|getConf
argument_list|()
operator|)
operator|.
name|getTableScan
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|". Needed to break cyclic dependency"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// Tarjan's algo
specifier|private
name|Set
argument_list|<
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
name|getComponents
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
block|{
name|Deque
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|deque
init|=
operator|new
name|LinkedList
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|deque
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|AtomicInteger
name|index
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|indexes
init|=
operator|new
name|HashMap
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|lowLinks
init|=
operator|new
name|HashMap
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|Stack
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|nodes
init|=
operator|new
name|Stack
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
name|components
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|o
range|:
name|deque
control|)
block|{
if|if
condition|(
operator|!
name|indexes
operator|.
name|containsKey
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|connect
argument_list|(
name|o
argument_list|,
name|index
argument_list|,
name|nodes
argument_list|,
name|indexes
argument_list|,
name|lowLinks
argument_list|,
name|components
argument_list|,
name|procCtx
operator|.
name|parseContext
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|components
return|;
block|}
specifier|private
name|void
name|connect
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|o
parameter_list|,
name|AtomicInteger
name|index
parameter_list|,
name|Stack
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|nodes
parameter_list|,
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|indexes
parameter_list|,
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|lowLinks
parameter_list|,
name|Set
argument_list|<
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
name|components
parameter_list|,
name|ParseContext
name|parseContext
parameter_list|)
block|{
name|indexes
operator|.
name|put
argument_list|(
name|o
argument_list|,
name|index
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lowLinks
operator|.
name|put
argument_list|(
name|o
argument_list|,
name|index
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|index
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|nodes
operator|.
name|push
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|children
decl_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|AppMasterEventOperator
condition|)
block|{
name|children
operator|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|children
operator|.
name|addAll
argument_list|(
name|o
operator|.
name|getChildOperators
argument_list|()
argument_list|)
expr_stmt|;
name|TableScanOperator
name|ts
init|=
operator|(
operator|(
name|DynamicPruningEventDesc
operator|)
name|o
operator|.
name|getConf
argument_list|()
operator|)
operator|.
name|getTableScan
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding special edge: "
operator|+
name|o
operator|.
name|getName
argument_list|()
operator|+
literal|" --> "
operator|+
name|ts
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|children
operator|.
name|add
argument_list|(
name|ts
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
comment|// semijoin case
name|children
operator|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|children
operator|.
name|addAll
argument_list|(
name|o
operator|.
name|getChildOperators
argument_list|()
argument_list|)
expr_stmt|;
name|SemiJoinBranchInfo
name|sjInfo
init|=
name|parseContext
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|get
argument_list|(
name|o
argument_list|)
decl_stmt|;
if|if
condition|(
name|sjInfo
operator|!=
literal|null
condition|)
block|{
name|TableScanOperator
name|ts
init|=
name|sjInfo
operator|.
name|getTsOp
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding special edge: "
operator|+
name|o
operator|.
name|getName
argument_list|()
operator|+
literal|" --> "
operator|+
name|ts
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|children
operator|.
name|add
argument_list|(
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|children
operator|=
name|o
operator|.
name|getChildOperators
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|child
range|:
name|children
control|)
block|{
if|if
condition|(
operator|!
name|indexes
operator|.
name|containsKey
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|connect
argument_list|(
name|child
argument_list|,
name|index
argument_list|,
name|nodes
argument_list|,
name|indexes
argument_list|,
name|lowLinks
argument_list|,
name|components
argument_list|,
name|parseContext
argument_list|)
expr_stmt|;
name|lowLinks
operator|.
name|put
argument_list|(
name|o
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|lowLinks
operator|.
name|get
argument_list|(
name|o
argument_list|)
argument_list|,
name|lowLinks
operator|.
name|get
argument_list|(
name|child
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nodes
operator|.
name|contains
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|lowLinks
operator|.
name|put
argument_list|(
name|o
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|lowLinks
operator|.
name|get
argument_list|(
name|o
argument_list|)
argument_list|,
name|indexes
operator|.
name|get
argument_list|(
name|child
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lowLinks
operator|.
name|get
argument_list|(
name|o
argument_list|)
operator|.
name|equals
argument_list|(
name|indexes
operator|.
name|get
argument_list|(
name|o
argument_list|)
argument_list|)
condition|)
block|{
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|component
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|components
operator|.
name|add
argument_list|(
name|component
argument_list|)
expr_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|current
decl_stmt|;
do|do
block|{
name|current
operator|=
name|nodes
operator|.
name|pop
argument_list|()
expr_stmt|;
name|component
operator|.
name|add
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|current
operator|!=
name|o
condition|)
do|;
block|}
block|}
specifier|private
name|void
name|runStatsAnnotation
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
operator|new
name|AnnotateWithStatistics
argument_list|()
operator|.
name|transform
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|)
expr_stmt|;
operator|new
name|AnnotateWithOpTraits
argument_list|()
operator|.
name|transform
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|runStatsDependentOptimizations
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|,
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
parameter_list|,
name|Set
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Sequence of TableScan operators to be walked
name|Deque
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|deque
init|=
operator|new
name|LinkedList
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|deque
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
comment|// create a walker which walks the tree in a DFS manner while maintaining
comment|// the operator stack.
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Set parallelism - ReduceSink"
argument_list|,
name|ReduceSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|SetReducerParallelism
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Convert Join to Map-join"
argument_list|,
name|JoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|ConvertJoinMapJoin
argument_list|()
argument_list|)
expr_stmt|;
comment|// The dispatcher fires the processor corresponding to the closest matching
comment|// rule and passes the context along
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|ForwardWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|runRemoveDynamicPruningOptimization
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|,
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
parameter_list|,
name|Set
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Sequence of TableScan operators to be walked
name|Deque
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|deque
init|=
operator|new
name|LinkedList
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|deque
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
comment|// create a walker which walks the tree in a DFS manner while maintaining
comment|// the operator stack.
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Remove dynamic pruning by size"
argument_list|,
name|AppMasterEventOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|RemoveDynamicPruningBySize
argument_list|()
argument_list|)
expr_stmt|;
comment|// The dispatcher fires the processor corresponding to the closest matching
comment|// rule and passes the context along
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|ForwardWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|runDynamicPartitionPruning
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|,
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
parameter_list|,
name|Set
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_DYNAMIC_PARTITION_PRUNING
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Sequence of TableScan operators to be walked
name|Deque
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|deque
init|=
operator|new
name|LinkedList
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|deque
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"Dynamic Partition Pruning"
argument_list|)
argument_list|,
name|FilterOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|DynamicPartitionPruningOptimization
argument_list|()
argument_list|)
expr_stmt|;
comment|// The dispatcher fires the processor corresponding to the closest matching
comment|// rule and passes the context along
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|ForwardWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|generateTaskTree
parameter_list|(
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|rootTasks
parameter_list|,
name|ParseContext
name|pCtx
parameter_list|,
name|List
argument_list|<
name|Task
argument_list|<
name|MoveWork
argument_list|>
argument_list|>
name|mvTask
parameter_list|,
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
parameter_list|,
name|Set
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|PerfLogger
name|perfLogger
init|=
name|SessionState
operator|.
name|getPerfLogger
argument_list|()
decl_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
name|ParseContext
name|tempParseContext
init|=
name|getParseContext
argument_list|(
name|pCtx
argument_list|,
name|rootTasks
argument_list|)
decl_stmt|;
name|GenTezUtils
name|utils
init|=
operator|new
name|GenTezUtils
argument_list|()
decl_stmt|;
name|GenTezWork
name|genTezWork
init|=
operator|new
name|GenTezWork
argument_list|(
name|utils
argument_list|)
decl_stmt|;
name|GenTezProcContext
name|procCtx
init|=
operator|new
name|GenTezProcContext
argument_list|(
name|conf
argument_list|,
name|tempParseContext
argument_list|,
name|mvTask
argument_list|,
name|rootTasks
argument_list|,
name|inputs
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
comment|// create a walker which walks the tree in a DFS manner while maintaining
comment|// the operator stack.
comment|// The dispatcher generates the plan from the operator tree
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Split Work - ReduceSink"
argument_list|,
name|ReduceSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
name|genTezWork
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"No more walking on ReduceSink-MapJoin"
argument_list|,
name|MapJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|ReduceSinkMapJoinProc
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Recognize a Sorted Merge Join operator to setup the right edge and"
operator|+
literal|" stop traversing the DummyStore-MapJoin"
argument_list|,
name|CommonMergeJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|MergeJoinProc
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Split Work + Move/Merge - FileSink"
argument_list|,
name|FileSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|CompositeProcessor
argument_list|(
operator|new
name|FileSinkProcessor
argument_list|()
argument_list|,
name|genTezWork
argument_list|)
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Split work - DummyStore"
argument_list|,
name|DummyStoreOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
name|genTezWork
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Handle Potential Analyze Command"
argument_list|,
name|TableScanOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|ProcessAnalyzeTable
argument_list|(
name|utils
argument_list|)
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Remember union"
argument_list|,
name|UnionOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|UnionProcessor
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"AppMasterEventOperator"
argument_list|,
name|AppMasterEventOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|AppMasterEventProcessor
argument_list|()
argument_list|)
expr_stmt|;
comment|// The dispatcher fires the processor corresponding to the closest matching
comment|// rule and passes the context along
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|pCtx
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|GenTezWorkWalker
argument_list|(
name|disp
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// we need to specify the reserved memory for each work that contains Map Join
for|for
control|(
name|List
argument_list|<
name|BaseWork
argument_list|>
name|baseWorkList
range|:
name|procCtx
operator|.
name|mapJoinWorkMap
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|BaseWork
name|w
range|:
name|baseWorkList
control|)
block|{
comment|// work should be the smallest unit for memory allocation
name|w
operator|.
name|setReservedMemoryMB
argument_list|(
call|(
name|int
call|)
argument_list|(
name|conf
operator|.
name|getLongVar
argument_list|(
name|ConfVars
operator|.
name|HIVECONVERTJOINNOCONDITIONALTASKTHRESHOLD
argument_list|)
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// we need to clone some operator plans and remove union operators still
name|int
name|indexForTezUnion
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BaseWork
name|w
range|:
name|procCtx
operator|.
name|workWithUnionOperators
control|)
block|{
name|GenTezUtils
operator|.
name|removeUnionOperators
argument_list|(
name|procCtx
argument_list|,
name|w
argument_list|,
name|indexForTezUnion
operator|++
argument_list|)
expr_stmt|;
block|}
comment|// then we make sure the file sink operators are set up right
for|for
control|(
name|FileSinkOperator
name|fileSink
range|:
name|procCtx
operator|.
name|fileSinkSet
control|)
block|{
name|GenTezUtils
operator|.
name|processFileSink
argument_list|(
name|procCtx
argument_list|,
name|fileSink
argument_list|)
expr_stmt|;
block|}
comment|// Connect any edges required for min/max pushdown
if|if
condition|(
name|pCtx
operator|.
name|getRsToRuntimeValuesInfoMap
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|ReduceSinkOperator
name|rs
range|:
name|pCtx
operator|.
name|getRsToRuntimeValuesInfoMap
argument_list|()
operator|.
name|keySet
argument_list|()
control|)
block|{
comment|// Process min/max
name|GenTezUtils
operator|.
name|processDynamicSemiJoinPushDownOperator
argument_list|(
name|procCtx
argument_list|,
name|pCtx
operator|.
name|getRsToRuntimeValuesInfoMap
argument_list|()
operator|.
name|get
argument_list|(
name|rs
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
block|}
comment|// and finally we hook up any events that need to be sent to the tez AM
name|LOG
operator|.
name|debug
argument_list|(
literal|"There are "
operator|+
name|procCtx
operator|.
name|eventOperatorSet
operator|.
name|size
argument_list|()
operator|+
literal|" app master events."
argument_list|)
expr_stmt|;
for|for
control|(
name|AppMasterEventOperator
name|event
range|:
name|procCtx
operator|.
name|eventOperatorSet
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Handling AppMasterEventOperator: "
operator|+
name|event
argument_list|)
expr_stmt|;
name|GenTezUtils
operator|.
name|processAppMasterEvent
argument_list|(
name|procCtx
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"generateTaskTree"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|setInputFormat
parameter_list|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
parameter_list|)
block|{
if|if
condition|(
name|task
operator|instanceof
name|TezTask
condition|)
block|{
name|TezWork
name|work
init|=
operator|(
operator|(
name|TezTask
operator|)
name|task
operator|)
operator|.
name|getWork
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|BaseWork
argument_list|>
name|all
init|=
name|work
operator|.
name|getAllWork
argument_list|()
decl_stmt|;
for|for
control|(
name|BaseWork
name|w
range|:
name|all
control|)
block|{
if|if
condition|(
name|w
operator|instanceof
name|MapWork
condition|)
block|{
name|MapWork
name|mapWork
init|=
operator|(
name|MapWork
operator|)
name|w
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|opMap
init|=
name|mapWork
operator|.
name|getAliasToWork
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|opMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|opMap
operator|.
name|values
argument_list|()
control|)
block|{
name|setInputFormat
argument_list|(
name|mapWork
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|task
operator|instanceof
name|ConditionalTask
condition|)
block|{
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|listTasks
init|=
operator|(
operator|(
name|ConditionalTask
operator|)
name|task
operator|)
operator|.
name|getListTasks
argument_list|()
decl_stmt|;
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|tsk
range|:
name|listTasks
control|)
block|{
name|setInputFormat
argument_list|(
name|tsk
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|task
operator|.
name|getChildTasks
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|childTask
range|:
name|task
operator|.
name|getChildTasks
argument_list|()
control|)
block|{
name|setInputFormat
argument_list|(
name|childTask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|setInputFormat
parameter_list|(
name|MapWork
name|work
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
block|{
if|if
condition|(
name|op
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|op
operator|.
name|isUseBucketizedHiveInputFormat
argument_list|()
condition|)
block|{
name|work
operator|.
name|setUseBucketizedHiveInputFormat
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|op
operator|.
name|getChildOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|childOp
range|:
name|op
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|setInputFormat
argument_list|(
name|work
argument_list|,
name|childOp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|decideExecMode
parameter_list|(
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|rootTasks
parameter_list|,
name|Context
name|ctx
parameter_list|,
name|GlobalLimitCtx
name|globalLimitCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// currently all Tez work is on the cluster
return|return;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|optimizeTaskPlan
parameter_list|(
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|rootTasks
parameter_list|,
name|ParseContext
name|pCtx
parameter_list|,
name|Context
name|ctx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|PerfLogger
name|perfLogger
init|=
name|SessionState
operator|.
name|getPerfLogger
argument_list|()
decl_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
name|PhysicalContext
name|physicalCtx
init|=
operator|new
name|PhysicalContext
argument_list|(
name|conf
argument_list|,
name|pCtx
argument_list|,
name|pCtx
operator|.
name|getContext
argument_list|()
argument_list|,
name|rootTasks
argument_list|,
name|pCtx
operator|.
name|getFetchTask
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVENULLSCANOPTIMIZE
argument_list|)
condition|)
block|{
name|physicalCtx
operator|=
operator|new
name|NullScanOptimizer
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping null scan query optimization"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMETADATAONLYQUERIES
argument_list|)
condition|)
block|{
name|physicalCtx
operator|=
operator|new
name|MetadataOnlyOptimizer
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping metadata only query optimization"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_CHECK_CROSS_PRODUCT
argument_list|)
condition|)
block|{
name|physicalCtx
operator|=
operator|new
name|CrossProductCheck
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping cross product analysis"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|"llap"
operator|.
name|equalsIgnoreCase
argument_list|(
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_EXECUTION_MODE
argument_list|)
argument_list|)
condition|)
block|{
name|physicalCtx
operator|=
operator|new
name|LlapPreVectorizationPass
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping llap pre-vectorization pass"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_ENABLED
argument_list|)
operator|&&
name|ctx
operator|.
name|getExplainAnalyze
argument_list|()
operator|==
literal|null
condition|)
block|{
name|physicalCtx
operator|=
operator|new
name|Vectorizer
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping vectorization"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
literal|"none"
operator|.
name|equalsIgnoreCase
argument_list|(
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESTAGEIDREARRANGE
argument_list|)
argument_list|)
condition|)
block|{
name|physicalCtx
operator|=
operator|new
name|StageIDsRearranger
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping stage id rearranger"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_TEZ_ENABLE_MEMORY_MANAGER
argument_list|)
operator|)
operator|&&
operator|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEUSEHYBRIDGRACEHASHJOIN
argument_list|)
operator|)
condition|)
block|{
name|physicalCtx
operator|=
operator|new
name|MemoryDecider
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|"llap"
operator|.
name|equalsIgnoreCase
argument_list|(
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_EXECUTION_MODE
argument_list|)
argument_list|)
condition|)
block|{
name|LlapClusterStateForCompile
name|llapInfo
init|=
name|LlapClusterStateForCompile
operator|.
name|getClusterInfo
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|physicalCtx
operator|=
operator|new
name|LlapDecider
argument_list|(
name|llapInfo
argument_list|)
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping llap decider"
argument_list|)
expr_stmt|;
block|}
comment|//  This optimizer will serialize all filters that made it to the
comment|//  table scan operator to avoid having to do it multiple times on
comment|//  the backend. If you have a physical optimization that changes
comment|//  table scans or filters, you have to invoke it before this one.
name|physicalCtx
operator|=
operator|new
name|SerializeFilter
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|physicalCtx
operator|.
name|getContext
argument_list|()
operator|.
name|getExplainAnalyze
argument_list|()
operator|!=
literal|null
condition|)
block|{
operator|new
name|AnnotateRunTimeStatsOptimizer
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"optimizeTaskPlan"
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|private
specifier|static
class|class
name|SMBJoinOpProcContext
implements|implements
name|NodeProcessorCtx
block|{
name|HashMap
argument_list|<
name|CommonMergeJoinOperator
argument_list|,
name|TableScanOperator
argument_list|>
name|JoinOpToTsOpMap
init|=
operator|new
name|HashMap
argument_list|<
name|CommonMergeJoinOperator
argument_list|,
name|TableScanOperator
argument_list|>
argument_list|()
decl_stmt|;
block|}
specifier|private
specifier|static
class|class
name|SMBJoinOpProc
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|SMBJoinOpProcContext
name|ctx
init|=
operator|(
name|SMBJoinOpProcContext
operator|)
name|procCtx
decl_stmt|;
name|ctx
operator|.
name|JoinOpToTsOpMap
operator|.
name|put
argument_list|(
operator|(
name|CommonMergeJoinOperator
operator|)
name|nd
argument_list|,
operator|(
name|TableScanOperator
operator|)
name|stack
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
specifier|private
specifier|static
name|void
name|removeSemijoinOptimizationFromSMBJoins
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_DYNAMIC_SEMIJOIN_REDUCTION
argument_list|)
operator|||
name|procCtx
operator|.
name|parseContext
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R1"
argument_list|,
name|TableScanOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
literal|".*"
operator|+
name|TezDummyStoreOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|CommonMergeJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|SMBJoinOpProc
argument_list|()
argument_list|)
expr_stmt|;
name|SMBJoinOpProcContext
name|ctx
init|=
operator|new
name|SMBJoinOpProcContext
argument_list|()
decl_stmt|;
comment|// The dispatcher finds SMB and if there is semijoin optimization before it, removes it.
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|ctx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|PreOrderOnceWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|TableScanOperator
argument_list|>
name|tsOps
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Iterate over the map and remove semijoin optimizations if needed.
for|for
control|(
name|CommonMergeJoinOperator
name|joinOp
range|:
name|ctx
operator|.
name|JoinOpToTsOpMap
operator|.
name|keySet
argument_list|()
control|)
block|{
comment|// Get one top level TS Op directly from the stack
name|tsOps
operator|.
name|add
argument_list|(
name|ctx
operator|.
name|JoinOpToTsOpMap
operator|.
name|get
argument_list|(
name|joinOp
argument_list|)
argument_list|)
expr_stmt|;
comment|// Get the other one by examining Join Op
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|parents
init|=
name|joinOp
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
range|:
name|parents
control|)
block|{
if|if
condition|(
name|parent
operator|instanceof
name|TezDummyStoreOperator
condition|)
block|{
comment|// already accounted for
continue|continue;
block|}
while|while
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|parent
operator|instanceof
name|TableScanOperator
condition|)
block|{
name|tsOps
operator|.
name|add
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|parent
argument_list|)
expr_stmt|;
break|break;
block|}
name|parent
operator|=
name|parent
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Now the relevant TableScanOperators are known, find if there exists
comment|// a semijoin filter on any of them, if so, remove it.
name|ParseContext
name|pctx
init|=
name|procCtx
operator|.
name|parseContext
decl_stmt|;
name|Set
argument_list|<
name|ReduceSinkOperator
argument_list|>
name|rsSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|pctx
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|TableScanOperator
name|ts
range|:
name|tsOps
control|)
block|{
for|for
control|(
name|ReduceSinkOperator
name|rs
range|:
name|rsSet
control|)
block|{
name|SemiJoinBranchInfo
name|sjInfo
init|=
name|pctx
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|get
argument_list|(
name|rs
argument_list|)
decl_stmt|;
if|if
condition|(
name|sjInfo
operator|!=
literal|null
operator|&&
name|ts
operator|==
name|sjInfo
operator|.
name|getTsOp
argument_list|()
condition|)
block|{
comment|// match!
if|if
condition|(
name|sjInfo
operator|.
name|getIsHint
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Removing hinted semijoin as it is with SMB join "
operator|+
name|rs
operator|+
literal|" : "
operator|+
name|ts
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Semijoin optimization found going to SMB join. Removing semijoin "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|rs
argument_list|)
operator|+
literal|" - "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|GenTezUtils
operator|.
name|removeBranch
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|pctx
argument_list|,
name|rs
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
specifier|static
class|class
name|SemiJoinCycleRemovalDueTOMapsideJoinContext
implements|implements
name|NodeProcessorCtx
block|{
name|HashMap
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|childParentMap
init|=
operator|new
name|HashMap
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
block|}
specifier|private
specifier|static
class|class
name|SemiJoinCycleRemovalDueToMapsideJoins
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|SemiJoinCycleRemovalDueTOMapsideJoinContext
name|ctx
init|=
operator|(
name|SemiJoinCycleRemovalDueTOMapsideJoinContext
operator|)
name|procCtx
decl_stmt|;
name|ctx
operator|.
name|childParentMap
operator|.
name|put
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
argument_list|>
operator|)
name|stack
operator|.
name|get
argument_list|(
name|stack
operator|.
name|size
argument_list|()
operator|-
literal|2
argument_list|)
argument_list|,
operator|(
name|Operator
argument_list|<
name|?
argument_list|>
operator|)
name|nd
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
specifier|private
specifier|static
name|void
name|removeSemiJoinCyclesDueToMapsideJoins
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_DYNAMIC_SEMIJOIN_REDUCTION
argument_list|)
operator|||
name|procCtx
operator|.
name|parseContext
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R1"
argument_list|,
name|MapJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|MapJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|SemiJoinCycleRemovalDueToMapsideJoins
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R2"
argument_list|,
name|MapJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|CommonMergeJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|SemiJoinCycleRemovalDueToMapsideJoins
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R3"
argument_list|,
name|CommonMergeJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|MapJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|SemiJoinCycleRemovalDueToMapsideJoins
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R4"
argument_list|,
name|CommonMergeJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|CommonMergeJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|SemiJoinCycleRemovalDueToMapsideJoins
argument_list|()
argument_list|)
expr_stmt|;
name|SemiJoinCycleRemovalDueTOMapsideJoinContext
name|ctx
init|=
operator|new
name|SemiJoinCycleRemovalDueTOMapsideJoinContext
argument_list|()
decl_stmt|;
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|ctx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|PreOrderOnceWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// process the list
name|ParseContext
name|pCtx
init|=
name|procCtx
operator|.
name|parseContext
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|parentJoin
range|:
name|ctx
operator|.
name|childParentMap
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|childJoin
init|=
name|ctx
operator|.
name|childParentMap
operator|.
name|get
argument_list|(
name|parentJoin
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentJoin
operator|.
name|getChildOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|child
range|:
name|parentJoin
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|child
operator|instanceof
name|SelectOperator
operator|)
condition|)
block|{
continue|continue;
block|}
while|while
condition|(
name|child
operator|.
name|getChildOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|child
operator|=
name|child
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|child
operator|instanceof
name|ReduceSinkOperator
operator|)
condition|)
block|{
continue|continue;
block|}
name|ReduceSinkOperator
name|rs
init|=
operator|(
operator|(
name|ReduceSinkOperator
operator|)
name|child
operator|)
decl_stmt|;
name|SemiJoinBranchInfo
name|sjInfo
init|=
name|pCtx
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|get
argument_list|(
name|rs
argument_list|)
decl_stmt|;
if|if
condition|(
name|sjInfo
operator|==
literal|null
condition|)
continue|continue;
name|TableScanOperator
name|ts
init|=
name|sjInfo
operator|.
name|getTsOp
argument_list|()
decl_stmt|;
comment|// This is a semijoin branch. Find if this is creating a potential
comment|// cycle with childJoin.
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
range|:
name|childJoin
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
if|if
condition|(
name|parent
operator|==
name|parentJoin
condition|)
block|{
continue|continue;
block|}
assert|assert
name|parent
operator|instanceof
name|ReduceSinkOperator
assert|;
while|while
condition|(
name|parent
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|parent
operator|=
name|parent
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parent
operator|==
name|ts
condition|)
block|{
comment|// We have a cycle!
if|if
condition|(
name|sjInfo
operator|.
name|getIsHint
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Removing hinted semijoin as it is creating cycles with mapside joins "
operator|+
name|rs
operator|+
literal|" : "
operator|+
name|ts
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Semijoin cycle due to mapjoin. Removing semijoin "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|rs
argument_list|)
operator|+
literal|" - "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|GenTezUtils
operator|.
name|removeBranch
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|pCtx
argument_list|,
name|rs
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
specifier|private
specifier|static
class|class
name|SemiJoinRemovalIfNoStatsProc
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
assert|assert
name|nd
operator|instanceof
name|ReduceSinkOperator
assert|;
name|ReduceSinkOperator
name|rs
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|nd
decl_stmt|;
name|ParseContext
name|pCtx
init|=
operator|(
operator|(
name|OptimizeTezProcContext
operator|)
name|procCtx
operator|)
operator|.
name|parseContext
decl_stmt|;
name|SemiJoinBranchInfo
name|sjInfo
init|=
name|pCtx
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|get
argument_list|(
name|rs
argument_list|)
decl_stmt|;
if|if
condition|(
name|sjInfo
operator|==
literal|null
condition|)
block|{
comment|// nothing to do here.
return|return
literal|null
return|;
block|}
comment|// This is a semijoin branch. The stack should look like,
comment|//<Parent Ops>-SEL-GB1-RS1-GB2-RS2
name|GroupByOperator
name|gbOp
init|=
call|(
name|GroupByOperator
call|)
argument_list|(
name|stack
operator|.
name|get
argument_list|(
name|stack
operator|.
name|size
argument_list|()
operator|-
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|GroupByDesc
name|gbDesc
init|=
name|gbOp
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
name|aggregationDescs
init|=
name|gbDesc
operator|.
name|getAggregators
argument_list|()
decl_stmt|;
for|for
control|(
name|AggregationDesc
name|agg
range|:
name|aggregationDescs
control|)
block|{
if|if
condition|(
name|agg
operator|.
name|getGenericUDAFName
argument_list|()
operator|!=
literal|"bloom_filter"
condition|)
block|{
continue|continue;
block|}
name|GenericUDAFBloomFilterEvaluator
name|udafBloomFilterEvaluator
init|=
operator|(
name|GenericUDAFBloomFilterEvaluator
operator|)
name|agg
operator|.
name|getGenericUDAFEvaluator
argument_list|()
decl_stmt|;
if|if
condition|(
name|udafBloomFilterEvaluator
operator|.
name|hasHintEntries
argument_list|()
condition|)
return|return
literal|null
return|;
comment|// Created using hint, skip it
name|long
name|expectedEntries
init|=
name|udafBloomFilterEvaluator
operator|.
name|getExpectedEntries
argument_list|()
decl_stmt|;
if|if
condition|(
name|expectedEntries
operator|==
operator|-
literal|1
operator|||
name|expectedEntries
operator|>
name|pCtx
operator|.
name|getConf
argument_list|()
operator|.
name|getLongVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_MAX_BLOOM_FILTER_ENTRIES
argument_list|)
condition|)
block|{
if|if
condition|(
name|sjInfo
operator|.
name|getIsHint
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Removing hinted semijoin due to lack to stats"
operator|+
literal|" or exceeding max bloom filter entries"
argument_list|)
throw|;
block|}
comment|// Remove the semijoin optimization branch along with ALL the mappings
comment|// The parent GB2 has all the branches. Collect them and remove them.
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|gbOp
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|ReduceSinkOperator
name|rsFinal
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|op
decl_stmt|;
name|TableScanOperator
name|ts
init|=
name|pCtx
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|get
argument_list|(
name|rsFinal
argument_list|)
operator|.
name|getTsOp
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"expectedEntries="
operator|+
name|expectedEntries
operator|+
literal|". "
operator|+
literal|"Either stats unavailable or expectedEntries exceeded max allowable bloomfilter size. "
operator|+
literal|"Removing semijoin "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|rs
argument_list|)
operator|+
literal|" - "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|GenTezUtils
operator|.
name|removeBranch
argument_list|(
name|rsFinal
argument_list|)
expr_stmt|;
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|pCtx
argument_list|,
name|rsFinal
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|// At this point, hinted semijoin case has been handled already
comment|// Check if big table is big enough that runtime filtering is
comment|// worth it.
name|TableScanOperator
name|ts
init|=
name|sjInfo
operator|.
name|getTsOp
argument_list|()
decl_stmt|;
if|if
condition|(
name|ts
operator|.
name|getStatistics
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|long
name|numRows
init|=
name|ts
operator|.
name|getStatistics
argument_list|()
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
if|if
condition|(
name|numRows
operator|<
name|pCtx
operator|.
name|getConf
argument_list|()
operator|.
name|getLongVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_BIGTABLE_MIN_SIZE_SEMIJOIN_REDUCTION
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Insufficient rows ("
operator|+
name|numRows
operator|+
literal|") to justify semijoin optimization. Removing semijoin "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|rs
argument_list|)
operator|+
literal|" - "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|GenTezUtils
operator|.
name|removeBranch
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|pCtx
argument_list|,
name|rs
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
specifier|private
name|void
name|removeSemiJoinIfNoStats
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_DYNAMIC_SEMIJOIN_REDUCTION
argument_list|)
condition|)
block|{
comment|// Not needed without semi-join reduction
return|return;
block|}
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R1"
argument_list|,
name|GroupByOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|ReduceSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|GroupByOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|ReduceSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|SemiJoinRemovalIfNoStatsProc
argument_list|()
argument_list|)
expr_stmt|;
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|PreOrderOnceWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|findParallelSemiJoinBranch
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|mapjoin
parameter_list|,
name|TableScanOperator
name|bigTableTS
parameter_list|,
name|ParseContext
name|parseContext
parameter_list|,
name|Map
argument_list|<
name|ReduceSinkOperator
argument_list|,
name|TableScanOperator
argument_list|>
name|semijoins
parameter_list|)
block|{
name|boolean
name|parallelEdges
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|mapjoin
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|op
operator|instanceof
name|ReduceSinkOperator
operator|)
condition|)
block|{
continue|continue;
block|}
name|op
operator|=
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// Follow the Reducesink operator upstream which is on small table side.
while|while
condition|(
operator|!
operator|(
name|op
operator|instanceof
name|ReduceSinkOperator
operator|)
operator|&&
operator|!
operator|(
name|op
operator|instanceof
name|TableScanOperator
operator|)
operator|&&
operator|!
operator|(
name|op
operator|.
name|getChildren
argument_list|()
operator|!=
literal|null
operator|&&
name|op
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|)
condition|)
block|{
name|op
operator|=
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// Bail out if RS or TS is encountered.
if|if
condition|(
name|op
operator|instanceof
name|ReduceSinkOperator
operator|||
name|op
operator|instanceof
name|TableScanOperator
condition|)
block|{
continue|continue;
block|}
comment|// A branch is hit.
for|for
control|(
name|Node
name|nd
range|:
name|op
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
name|nd
operator|instanceof
name|SelectOperator
condition|)
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|child
init|=
operator|(
name|Operator
argument_list|<
name|?
argument_list|>
operator|)
name|nd
decl_stmt|;
while|while
condition|(
name|child
operator|.
name|getChildOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|child
operator|=
name|child
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// If not ReduceSink Op, skip
if|if
condition|(
operator|!
operator|(
name|child
operator|instanceof
name|ReduceSinkOperator
operator|)
condition|)
block|{
continue|continue;
block|}
name|ReduceSinkOperator
name|rs
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|child
decl_stmt|;
name|SemiJoinBranchInfo
name|sjInfo
init|=
name|parseContext
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|get
argument_list|(
name|rs
argument_list|)
decl_stmt|;
if|if
condition|(
name|sjInfo
operator|==
literal|null
condition|)
continue|continue;
name|TableScanOperator
name|ts
init|=
name|sjInfo
operator|.
name|getTsOp
argument_list|()
decl_stmt|;
if|if
condition|(
name|ts
operator|!=
name|bigTableTS
condition|)
block|{
comment|// skip, not the one we are looking for.
continue|continue;
block|}
name|parallelEdges
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|sjInfo
operator|.
name|getIsHint
argument_list|()
condition|)
block|{
comment|// Created by hint, skip it
continue|continue;
block|}
comment|// Add the semijoin branch to the map
name|semijoins
operator|.
name|put
argument_list|(
name|rs
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|parallelEdges
return|;
block|}
comment|/*    *  The algorithm looks at all the mapjoins in the operator pipeline until    *  it hits RS Op and for each mapjoin examines if it has paralllel semijoin    *  edge.    */
specifier|private
name|void
name|removeSemijoinsParallelToMapJoin
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_DYNAMIC_SEMIJOIN_REDUCTION
argument_list|)
operator|||
operator|!
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVECONVERTJOIN
argument_list|)
operator|||
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_DYNAMIC_SEMIJOIN_REDUCTION_FOR_MAPJOIN
argument_list|)
condition|)
block|{
comment|// Not needed without semi-join reduction or mapjoins or when semijoins
comment|// are enabled for parallel mapjoins.
return|return;
block|}
comment|// Get all the TS ops.
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|topOps
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|topOps
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|ReduceSinkOperator
argument_list|,
name|TableScanOperator
argument_list|>
name|semijoins
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
range|:
name|topOps
control|)
block|{
comment|// A TS can have multiple branches due to DPP Or Semijoin Opt.
comment|// USe DFS to traverse all the branches until RS is hit.
name|Deque
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|deque
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|deque
operator|.
name|add
argument_list|(
name|parent
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|deque
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|op
init|=
name|deque
operator|.
name|poll
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
comment|// Done with this branch
continue|continue;
block|}
if|if
condition|(
name|op
operator|instanceof
name|MapJoinOperator
condition|)
block|{
comment|// A candidate.
if|if
condition|(
operator|!
name|findParallelSemiJoinBranch
argument_list|(
name|op
argument_list|,
operator|(
name|TableScanOperator
operator|)
name|parent
argument_list|,
name|procCtx
operator|.
name|parseContext
argument_list|,
name|semijoins
argument_list|)
condition|)
block|{
comment|// No parallel edge was found for the given mapjoin op,
comment|// no need to go down further, skip this TS operator pipeline.
break|break;
block|}
block|}
name|deque
operator|.
name|addAll
argument_list|(
name|op
operator|.
name|getChildOperators
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|semijoins
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|ReduceSinkOperator
name|rs
range|:
name|semijoins
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Semijoin optimization with parallel edge to map join. Removing semijoin "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|rs
argument_list|)
operator|+
literal|" - "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|semijoins
operator|.
name|get
argument_list|(
name|rs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|GenTezUtils
operator|.
name|removeBranch
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|,
name|rs
argument_list|,
name|semijoins
operator|.
name|get
argument_list|(
name|rs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
name|boolean
name|canUseNDV
parameter_list|(
name|ColStatistics
name|colStats
parameter_list|)
block|{
return|return
operator|(
name|colStats
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|colStats
operator|.
name|getCountDistint
argument_list|()
operator|>=
literal|0
operator|)
return|;
block|}
specifier|private
specifier|static
name|double
name|getBloomFilterCost
parameter_list|(
name|SelectOperator
name|sel
parameter_list|,
name|FilterOperator
name|fil
parameter_list|)
block|{
name|double
name|cost
init|=
operator|-
literal|1
decl_stmt|;
name|Statistics
name|selStats
init|=
name|sel
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
if|if
condition|(
name|selStats
operator|!=
literal|null
condition|)
block|{
name|cost
operator|=
name|selStats
operator|.
name|getNumRows
argument_list|()
expr_stmt|;
comment|// Some other things that could be added here to model cost:
comment|// Cost of computing/sending partial BloomFilter results? BloomFilterSize * # mappers
comment|// For reduce-side join, add the cost of the semijoin table scan/dependent tablescans?
block|}
return|return
name|cost
return|;
block|}
specifier|private
specifier|static
name|long
name|getCombinedKeyDomainCardinality
parameter_list|(
name|ColStatistics
name|selColStat
parameter_list|,
name|ColStatistics
name|selColSourceStat
parameter_list|,
name|ColStatistics
name|tsColStat
parameter_list|)
block|{
name|long
name|keyDomainCardinality
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|canUseNDV
argument_list|(
name|selColStat
argument_list|)
operator|||
operator|!
name|canUseNDV
argument_list|(
name|tsColStat
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|long
name|selColSourceNdv
init|=
name|canUseNDV
argument_list|(
name|selColSourceStat
argument_list|)
condition|?
name|selColSourceStat
operator|.
name|getCountDistint
argument_list|()
else|:
operator|-
literal|1
decl_stmt|;
name|boolean
name|semiJoinKeyIsPK
init|=
name|StatsUtils
operator|.
name|inferForeignKey
argument_list|(
name|selColStat
argument_list|,
name|tsColStat
argument_list|)
decl_stmt|;
if|if
condition|(
name|semiJoinKeyIsPK
condition|)
block|{
comment|// PK/FQ relationship: NDV of selColSourceStat is a superset of what is in tsColStat
if|if
condition|(
name|selColSourceNdv
operator|>=
literal|0
condition|)
block|{
comment|// Most accurate domain cardinality would be source column NDV if available.
name|keyDomainCardinality
operator|=
name|selColSourceNdv
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|selColSourceNdv
operator|>=
literal|0
condition|)
block|{
comment|// If semijoin keys and ts keys completely unrelated, the cardinality of both sets
comment|// could be obtained by adding both cardinalities. Would there be an average case?
name|keyDomainCardinality
operator|=
name|selColSourceNdv
operator|+
name|tsColStat
operator|.
name|getCountDistint
argument_list|()
expr_stmt|;
comment|// Don't exceed the range if we have one.
if|if
condition|(
name|StatsUtils
operator|.
name|hasDiscreteRange
argument_list|(
name|selColStat
argument_list|)
operator|&&
name|StatsUtils
operator|.
name|hasDiscreteRange
argument_list|(
name|tsColStat
argument_list|)
condition|)
block|{
name|long
name|range
init|=
literal|0
decl_stmt|;
comment|// Trying using the cardinality from the value range.
name|ColStatistics
operator|.
name|Range
name|combinedRange
init|=
name|StatsUtils
operator|.
name|combineRange
argument_list|(
name|selColStat
operator|.
name|getRange
argument_list|()
argument_list|,
name|tsColStat
operator|.
name|getRange
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|combinedRange
operator|!=
literal|null
condition|)
block|{
name|range
operator|=
name|StatsUtils
operator|.
name|getRangeDelta
argument_list|(
name|combinedRange
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|range
operator|=
name|StatsUtils
operator|.
name|getRangeDelta
argument_list|(
name|selColStat
operator|.
name|getRange
argument_list|()
argument_list|)
operator|+
name|StatsUtils
operator|.
name|getRangeDelta
argument_list|(
name|tsColStat
operator|.
name|getRange
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|keyDomainCardinality
operator|=
name|Math
operator|.
name|min
argument_list|(
name|keyDomainCardinality
argument_list|,
name|range
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Otherwise, we tried ..
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Computing key domain cardinality, keyDomainCardinality="
operator|+
name|keyDomainCardinality
operator|+
literal|", semiJoinKeyIsPK="
operator|+
name|semiJoinKeyIsPK
operator|+
literal|", selColStat="
operator|+
name|selColStat
operator|+
literal|", selColSourceStat="
operator|+
name|selColSourceStat
operator|+
literal|", tsColStat="
operator|+
name|tsColStat
argument_list|)
expr_stmt|;
block|}
return|return
name|keyDomainCardinality
return|;
block|}
specifier|private
specifier|static
name|double
name|getBloomFilterBenefit
parameter_list|(
name|SelectOperator
name|sel
parameter_list|,
name|ExprNodeDesc
name|selExpr
parameter_list|,
name|FilterOperator
name|fil
parameter_list|,
name|ExprNodeDesc
name|tsExpr
parameter_list|)
block|{
name|double
name|benefit
init|=
operator|-
literal|1
decl_stmt|;
name|Statistics
name|selStats
init|=
name|sel
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
name|Statistics
name|filStats
init|=
name|fil
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
if|if
condition|(
name|selStats
operator|==
literal|null
operator|||
name|filStats
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No stats available to compute BloomFilter benefit"
argument_list|)
expr_stmt|;
return|return
name|benefit
return|;
block|}
comment|// For cardinality values use numRows as default, try to use ColStats if available
name|long
name|selKeyCardinality
init|=
name|selStats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
name|long
name|tsKeyCardinality
init|=
name|filStats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
name|long
name|tsRows
init|=
name|filStats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
name|long
name|tsRowSize
init|=
name|filStats
operator|.
name|getAvgRowSize
argument_list|()
decl_stmt|;
name|long
name|keyDomainCardinality
init|=
name|selKeyCardinality
operator|+
name|tsKeyCardinality
decl_stmt|;
name|ExprNodeColumnDesc
name|selCol
init|=
name|ExprNodeDescUtils
operator|.
name|getColumnExpr
argument_list|(
name|selExpr
argument_list|)
decl_stmt|;
name|ExprNodeColumnDesc
name|tsCol
init|=
name|ExprNodeDescUtils
operator|.
name|getColumnExpr
argument_list|(
name|tsExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|selCol
operator|!=
literal|null
operator|&&
name|tsCol
operator|!=
literal|null
condition|)
block|{
comment|// Check if there are column stats available for these columns
name|ColStatistics
name|selColStat
init|=
name|selStats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|selCol
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|ColStatistics
name|filColStat
init|=
name|filStats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|tsCol
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|canUseNDV
argument_list|(
name|selColStat
argument_list|)
condition|)
block|{
name|selKeyCardinality
operator|=
name|selColStat
operator|.
name|getCountDistint
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|canUseNDV
argument_list|(
name|filColStat
argument_list|)
condition|)
block|{
name|tsKeyCardinality
operator|=
name|filColStat
operator|.
name|getCountDistint
argument_list|()
expr_stmt|;
block|}
comment|// Get colstats for the original table column for selCol if possible, this would have
comment|// more accurate information about the original NDV of the column before any filtering.
name|ColStatistics
name|selColSourceStat
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|selColStat
operator|!=
literal|null
condition|)
block|{
name|ExprNodeDescUtils
operator|.
name|ColumnOrigin
name|selColSource
init|=
name|ExprNodeDescUtils
operator|.
name|findColumnOrigin
argument_list|(
name|selCol
argument_list|,
name|sel
argument_list|)
decl_stmt|;
if|if
condition|(
name|selColSource
operator|!=
literal|null
operator|&&
name|selColSource
operator|.
name|op
operator|.
name|getStatistics
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|selColSourceStat
operator|=
name|selColSource
operator|.
name|op
operator|.
name|getStatistics
argument_list|()
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|selColSource
operator|.
name|col
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|domainCardinalityFromColStats
init|=
name|getCombinedKeyDomainCardinality
argument_list|(
name|selColStat
argument_list|,
name|selColSourceStat
argument_list|,
name|filColStat
argument_list|)
decl_stmt|;
if|if
condition|(
name|domainCardinalityFromColStats
operator|>=
literal|0
condition|)
block|{
name|keyDomainCardinality
operator|=
name|domainCardinalityFromColStats
expr_stmt|;
block|}
block|}
comment|// Selectivity: key cardinality of semijoin / domain cardinality
comment|// Benefit (rows filtered from ts): (1 - selectivity) * # ts rows
name|double
name|selectivity
init|=
name|selKeyCardinality
operator|/
operator|(
name|double
operator|)
name|keyDomainCardinality
decl_stmt|;
name|selectivity
operator|=
name|Math
operator|.
name|min
argument_list|(
name|selectivity
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|benefit
operator|=
name|tsRows
operator|*
operator|(
literal|1
operator|-
name|selectivity
operator|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"BloomFilter benefit for "
operator|+
name|selCol
operator|+
literal|" to "
operator|+
name|tsCol
operator|+
literal|", selKeyCardinality="
operator|+
name|selKeyCardinality
operator|+
literal|", tsKeyCardinality="
operator|+
name|tsKeyCardinality
operator|+
literal|", tsRows="
operator|+
name|tsRows
operator|+
literal|", keyDomainCardinality="
operator|+
name|keyDomainCardinality
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"SemiJoin key selectivity="
operator|+
name|selectivity
operator|+
literal|", benefit="
operator|+
name|benefit
argument_list|)
expr_stmt|;
block|}
return|return
name|benefit
return|;
block|}
specifier|private
specifier|static
name|double
name|computeBloomFilterNetBenefit
parameter_list|(
name|SelectOperator
name|sel
parameter_list|,
name|ExprNodeDesc
name|selExpr
parameter_list|,
name|FilterOperator
name|fil
parameter_list|,
name|ExprNodeDesc
name|tsExpr
parameter_list|)
block|{
name|double
name|netBenefit
init|=
operator|-
literal|1
decl_stmt|;
name|double
name|benefit
init|=
name|getBloomFilterBenefit
argument_list|(
name|sel
argument_list|,
name|selExpr
argument_list|,
name|fil
argument_list|,
name|tsExpr
argument_list|)
decl_stmt|;
name|Statistics
name|filStats
init|=
name|fil
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
if|if
condition|(
name|benefit
operator|>
literal|0
operator|&&
name|filStats
operator|!=
literal|null
condition|)
block|{
name|double
name|cost
init|=
name|getBloomFilterCost
argument_list|(
name|sel
argument_list|,
name|fil
argument_list|)
decl_stmt|;
if|if
condition|(
name|cost
operator|>
literal|0
condition|)
block|{
name|long
name|filDataSize
init|=
name|filStats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
name|netBenefit
operator|=
operator|(
name|benefit
operator|-
name|cost
operator|)
operator|/
name|filDataSize
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"BloomFilter benefit="
operator|+
name|benefit
operator|+
literal|", cost="
operator|+
name|cost
operator|+
literal|", tsDataSize="
operator|+
name|filDataSize
operator|+
literal|", netBenefit="
operator|+
operator|(
name|benefit
operator|-
name|cost
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"netBenefit="
operator|+
name|netBenefit
argument_list|)
expr_stmt|;
return|return
name|netBenefit
return|;
block|}
specifier|private
name|void
name|removeSemijoinOptimizationByBenefit
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_DYNAMIC_SEMIJOIN_REDUCTION
argument_list|)
condition|)
block|{
comment|// Not needed without semi-join reduction
return|return;
block|}
name|List
argument_list|<
name|ReduceSinkOperator
argument_list|>
name|semijoinRsToRemove
init|=
operator|new
name|ArrayList
argument_list|<
name|ReduceSinkOperator
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|ReduceSinkOperator
argument_list|,
name|SemiJoinBranchInfo
argument_list|>
name|map
init|=
name|procCtx
operator|.
name|parseContext
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
decl_stmt|;
name|double
name|semijoinReductionThreshold
init|=
name|procCtx
operator|.
name|conf
operator|.
name|getFloatVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|TEZ_DYNAMIC_SEMIJOIN_REDUCTION_THRESHOLD
argument_list|)
decl_stmt|;
for|for
control|(
name|ReduceSinkOperator
name|rs
range|:
name|map
operator|.
name|keySet
argument_list|()
control|)
block|{
name|SemiJoinBranchInfo
name|sjInfo
init|=
name|map
operator|.
name|get
argument_list|(
name|rs
argument_list|)
decl_stmt|;
if|if
condition|(
name|sjInfo
operator|.
name|getIsHint
argument_list|()
condition|)
block|{
comment|// Semijoin created using hint, skip it
continue|continue;
block|}
comment|// rs is semijoin optimization branch, which should look like<Parent>-SEL-GB1-RS1-GB2-RS2
comment|// Get to the SelectOperator ancestor
name|SelectOperator
name|sel
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|currOp
init|=
name|rs
init|;
name|currOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|;
name|currOp
operator|=
name|currOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
control|)
block|{
if|if
condition|(
name|currOp
operator|instanceof
name|SelectOperator
condition|)
block|{
name|sel
operator|=
operator|(
name|SelectOperator
operator|)
name|currOp
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sel
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unexpected error - could not find SEL ancestor from semijoin branch of "
operator|+
name|rs
argument_list|)
throw|;
block|}
comment|// Check the ndv/rows from the SEL vs the destination tablescan the semijoin opt is going to.
name|TableScanOperator
name|ts
init|=
name|sjInfo
operator|.
name|getTsOp
argument_list|()
decl_stmt|;
name|RuntimeValuesInfo
name|rti
init|=
name|procCtx
operator|.
name|parseContext
operator|.
name|getRsToRuntimeValuesInfoMap
argument_list|()
operator|.
name|get
argument_list|(
name|rs
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|tsExpr
init|=
name|rti
operator|.
name|getTsColExpr
argument_list|()
decl_stmt|;
comment|// In the SEL operator of the semijoin branch, there should be only one column in the operator
name|ExprNodeDesc
name|selExpr
init|=
name|sel
operator|.
name|getConf
argument_list|()
operator|.
name|getColList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Computing BloomFilter cost/benefit for "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|rs
argument_list|)
operator|+
literal|" - "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|ts
argument_list|)
operator|+
literal|" ("
operator|+
name|tsExpr
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
name|double
name|reductionFactor
init|=
name|computeBloomFilterNetBenefit
argument_list|(
name|sel
argument_list|,
name|selExpr
argument_list|,
operator|(
name|FilterOperator
operator|)
name|ts
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|tsExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|reductionFactor
operator|<
name|semijoinReductionThreshold
condition|)
block|{
comment|// This semijoin optimization should be removed. Do it after we're done iterating
name|semijoinRsToRemove
operator|.
name|add
argument_list|(
name|rs
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|ReduceSinkOperator
name|rs
range|:
name|semijoinRsToRemove
control|)
block|{
name|TableScanOperator
name|ts
init|=
name|map
operator|.
name|get
argument_list|(
name|rs
argument_list|)
operator|.
name|getTsOp
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reduction factor not satisfied for "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|rs
argument_list|)
operator|+
literal|"-"
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|ts
argument_list|)
operator|+
literal|". Removing semijoin optimization."
argument_list|)
expr_stmt|;
block|}
name|GenTezUtils
operator|.
name|removeBranch
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|,
name|rs
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

