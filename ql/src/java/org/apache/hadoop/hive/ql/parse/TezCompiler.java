begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ArrayListMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|QueryState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|AppMasterEventOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|CommonMergeJoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ConditionalTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|DummyStoreOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FileSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FilterOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|GroupByOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|JoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|MapJoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|SelectOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TableScanOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Task
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TerminalOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TezDummyStoreOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|UnionOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|tez
operator|.
name|TezTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|ReadEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|WriteEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|CompositeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|DefaultGraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|DefaultRuleDispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Dispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|ForwardWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|GraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessorCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|PreOrderOnceWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|RuleRegExp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|log
operator|.
name|PerfLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Hive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|ConstantPropagate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|ConstantPropagateProcCtx
operator|.
name|ConstantPropagateOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|ConvertJoinMapJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|DynamicPartitionPruningOptimization
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|MergeJoinProc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|NonBlockingOpDeDupProc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|ReduceSinkMapJoinProc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|RemoveDynamicPruningBySize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|SetHashGroupByMinReduction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|SetReducerParallelism
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|SharedWorkOptimizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|SortedDynPartitionOptimizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|TopNKeyProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|correlation
operator|.
name|ReduceSinkDeDuplication
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|correlation
operator|.
name|ReduceSinkJoinDeDuplication
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|metainfo
operator|.
name|annotation
operator|.
name|AnnotateWithOpTraits
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|AnnotateRunTimeStatsOptimizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|CrossProductHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|LlapClusterStateForCompile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|LlapDecider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|LlapPreVectorizationPass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|MemoryDecider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|MetadataOnlyOptimizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|NullScanOptimizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|PhysicalContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|SerializeFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|StageIDsRearranger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|Vectorizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|signature
operator|.
name|OpTreeSignature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|stats
operator|.
name|annotation
operator|.
name|AnnotateWithStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AggregationDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AppMasterEventDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|BaseWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ColStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DynamicPruningEventDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDescUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|GroupByDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MapWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MoveWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|Statistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TezWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|mapper
operator|.
name|AuxOpTreeSignature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|mapper
operator|.
name|PlanMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|mapper
operator|.
name|PlanMapper
operator|.
name|EquivGroup
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
operator|.
name|LogHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|stats
operator|.
name|OperatorStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|stats
operator|.
name|StatsUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFBloomFilter
operator|.
name|GenericUDAFBloomFilterEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * TezCompiler translates the operator plan into TezTasks.  */
end_comment

begin_class
specifier|public
class|class
name|TezCompiler
extends|extends
name|TaskCompiler
block|{
specifier|protected
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TezCompiler
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
name|TezCompiler
parameter_list|()
block|{   }
annotation|@
name|Override
specifier|public
name|void
name|init
parameter_list|(
name|QueryState
name|queryState
parameter_list|,
name|LogHelper
name|console
parameter_list|,
name|Hive
name|db
parameter_list|)
block|{
name|super
operator|.
name|init
argument_list|(
name|queryState
argument_list|,
name|console
argument_list|,
name|db
argument_list|)
expr_stmt|;
comment|// Tez requires us to use RPC for the query plan
name|HiveConf
operator|.
name|setBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_RPC_QUERY_PLAN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// We require the use of recursive input dirs for union processing
name|conf
operator|.
name|setBoolean
argument_list|(
literal|"mapred.input.dir.recursive"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|optimizeOperatorPlan
parameter_list|(
name|ParseContext
name|pCtx
parameter_list|,
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
parameter_list|,
name|Set
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|PerfLogger
name|perfLogger
init|=
name|SessionState
operator|.
name|getPerfLogger
argument_list|()
decl_stmt|;
comment|// Create the context for the walker
name|OptimizeTezProcContext
name|procCtx
init|=
operator|new
name|OptimizeTezProcContext
argument_list|(
name|conf
argument_list|,
name|pCtx
argument_list|,
name|inputs
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
name|runTopNKeyOptimization
argument_list|(
name|procCtx
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Run top n key optimization"
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
comment|// setup dynamic partition pruning where possible
name|runDynamicPartitionPruning
argument_list|(
name|procCtx
argument_list|,
name|inputs
argument_list|,
name|outputs
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Setup dynamic partition pruning"
argument_list|)
expr_stmt|;
comment|// need to run this; to get consistent filterop conditions(for operator tree matching)
if|if
condition|(
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVEOPTCONSTANTPROPAGATION
argument_list|)
condition|)
block|{
operator|new
name|ConstantPropagate
argument_list|(
name|ConstantPropagateOption
operator|.
name|SHORTCUT
argument_list|)
operator|.
name|transform
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|)
expr_stmt|;
block|}
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
comment|// setup stats in the operator plan
name|runStatsAnnotation
argument_list|(
name|procCtx
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Setup stats in the operator plan"
argument_list|)
expr_stmt|;
comment|// run Sorted dynamic partition optimization
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|procCtx
operator|.
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONING
argument_list|)
operator|&&
name|HiveConf
operator|.
name|getVar
argument_list|(
name|procCtx
operator|.
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONINGMODE
argument_list|)
operator|.
name|equals
argument_list|(
literal|"nonstrict"
argument_list|)
operator|&&
operator|!
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|procCtx
operator|.
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTLISTBUCKETING
argument_list|)
condition|)
block|{
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
operator|new
name|SortedDynPartitionOptimizer
argument_list|()
operator|.
name|transform
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Sorted dynamic partition optimization"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|procCtx
operator|.
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTREDUCEDEDUPLICATION
argument_list|)
operator|||
name|procCtx
operator|.
name|parseContext
operator|.
name|hasAcidWrite
argument_list|()
condition|)
block|{
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
comment|// Dynamic sort partition adds an extra RS therefore need to de-dup
operator|new
name|ReduceSinkDeDuplication
argument_list|()
operator|.
name|transform
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|)
expr_stmt|;
comment|// there is an issue with dedup logic wherein SELECT is created with wrong columns
comment|// NonBlockingOpDeDupProc fixes that
comment|// (kind of hackish, the issue in de-dup should be fixed but it needs more investigation)
operator|new
name|NonBlockingOpDeDupProc
argument_list|()
operator|.
name|transform
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Reduce Sink de-duplication"
argument_list|)
expr_stmt|;
block|}
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
comment|// run the optimizations that use stats for optimization
name|runStatsDependentOptimizations
argument_list|(
name|procCtx
argument_list|,
name|inputs
argument_list|,
name|outputs
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Run the optimizations that use stats for optimization"
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
if|if
condition|(
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVEOPTJOINREDUCEDEDUPLICATION
argument_list|)
condition|)
block|{
operator|new
name|ReduceSinkJoinDeDuplication
argument_list|()
operator|.
name|transform
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|)
expr_stmt|;
block|}
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Run reduce sink after join algorithm selection"
argument_list|)
expr_stmt|;
name|semijoinRemovalBasedTransformations
argument_list|(
name|procCtx
argument_list|,
name|inputs
argument_list|,
name|outputs
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
if|if
condition|(
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_SHARED_WORK_OPTIMIZATION
argument_list|)
condition|)
block|{
operator|new
name|SharedWorkOptimizer
argument_list|()
operator|.
name|transform
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|)
expr_stmt|;
block|}
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Shared scans optimization"
argument_list|)
expr_stmt|;
comment|// need a new run of the constant folding because we might have created lots
comment|// of "and true and true" conditions.
comment|// Rather than run the full constant folding just need to shortcut AND/OR expressions
comment|// involving constant true/false values.
if|if
condition|(
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVEOPTCONSTANTPROPAGATION
argument_list|)
condition|)
block|{
operator|new
name|ConstantPropagate
argument_list|(
name|ConstantPropagateOption
operator|.
name|SHORTCUT
argument_list|)
operator|.
name|transform
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|)
expr_stmt|;
block|}
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
name|AuxOpTreeSignature
operator|.
name|linkAuxSignatures
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|)
expr_stmt|;
name|markOperatorsWithUnstableRuntimeStats
argument_list|(
name|procCtx
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"markOperatorsWithUnstableRuntimeStats"
argument_list|)
expr_stmt|;
comment|// ATTENTION : DO NOT, I REPEAT, DO NOT WRITE ANYTHING AFTER updateBucketingVersionForUpgrade()
comment|// ANYTHING WHICH NEEDS TO BE ADDED MUST BE ADDED ABOVE
comment|// This call updates the bucketing version of final ReduceSinkOp based on
comment|// the bucketing version of FileSinkOp. This operation must happen at the
comment|// end to ensure there is no further rewrite of plan which may end up
comment|// removing/updating the ReduceSinkOp as was the case with SortedDynPartitionOptimizer
comment|// Update bucketing version of ReduceSinkOp if needed
name|updateBucketingVersionForUpgrade
argument_list|(
name|procCtx
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|runCycleAnalysisForPartitionPruning
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|,
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
parameter_list|,
name|Set
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Semijoins may have created task level cycles, examine those
name|connectTerminalOps
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|)
expr_stmt|;
name|boolean
name|cycleFree
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|cycleFree
condition|)
block|{
name|cycleFree
operator|=
literal|true
expr_stmt|;
name|Set
argument_list|<
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
name|components
init|=
name|getComponents
argument_list|(
name|procCtx
argument_list|)
decl_stmt|;
for|for
control|(
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|component
range|:
name|components
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Component: "
argument_list|)
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|co
range|:
name|component
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Operator: "
operator|+
name|co
operator|.
name|getName
argument_list|()
operator|+
literal|", "
operator|+
name|co
operator|.
name|getIdentifier
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|component
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Found cycle in operator plan..."
argument_list|)
expr_stmt|;
name|cycleFree
operator|=
literal|false
expr_stmt|;
name|removeCycleOperator
argument_list|(
name|component
argument_list|,
name|procCtx
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Cycle free: "
operator|+
name|cycleFree
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|removeCycleOperator
parameter_list|(
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|component
parameter_list|,
name|OptimizeTezProcContext
name|context
parameter_list|)
throws|throws
name|SemanticException
block|{
name|AppMasterEventOperator
name|victimAM
init|=
literal|null
decl_stmt|;
name|TableScanOperator
name|victimTS
init|=
literal|null
decl_stmt|;
name|ReduceSinkOperator
name|victimRS
init|=
literal|null
decl_stmt|;
comment|// If there is a hint and no operator is removed then throw error
name|boolean
name|hasHint
init|=
literal|false
decl_stmt|;
name|boolean
name|removed
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|o
range|:
name|component
control|)
block|{
comment|// Look for AppMasterEventOperator or ReduceSinkOperator
if|if
condition|(
name|o
operator|instanceof
name|AppMasterEventOperator
condition|)
block|{
if|if
condition|(
name|victimAM
operator|==
literal|null
operator|||
name|o
operator|.
name|getStatistics
argument_list|()
operator|.
name|getDataSize
argument_list|()
operator|<
name|victimAM
operator|.
name|getStatistics
argument_list|()
operator|.
name|getDataSize
argument_list|()
condition|)
block|{
name|victimAM
operator|=
operator|(
name|AppMasterEventOperator
operator|)
name|o
expr_stmt|;
name|removed
operator|=
literal|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|SemiJoinBranchInfo
name|sjInfo
init|=
name|context
operator|.
name|parseContext
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|get
argument_list|(
name|o
argument_list|)
decl_stmt|;
if|if
condition|(
name|sjInfo
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|sjInfo
operator|.
name|getIsHint
argument_list|()
condition|)
block|{
comment|// Skipping because of hint. Mark this info,
name|hasHint
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
name|TableScanOperator
name|ts
init|=
name|sjInfo
operator|.
name|getTsOp
argument_list|()
decl_stmt|;
comment|// Sanity check
assert|assert
name|component
operator|.
name|contains
argument_list|(
name|ts
argument_list|)
assert|;
if|if
condition|(
name|victimRS
operator|==
literal|null
operator|||
name|ts
operator|.
name|getStatistics
argument_list|()
operator|.
name|getDataSize
argument_list|()
operator|<
name|victimTS
operator|.
name|getStatistics
argument_list|()
operator|.
name|getDataSize
argument_list|()
condition|)
block|{
name|victimRS
operator|=
operator|(
name|ReduceSinkOperator
operator|)
name|o
expr_stmt|;
name|victimTS
operator|=
name|ts
expr_stmt|;
name|removed
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
comment|// Always set the semijoin optimization as victim.
name|Operator
argument_list|<
name|?
argument_list|>
name|victim
init|=
name|victimRS
decl_stmt|;
if|if
condition|(
name|victimRS
operator|==
literal|null
operator|&&
name|victimAM
operator|!=
literal|null
condition|)
block|{
name|victim
operator|=
name|victimAM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|victimAM
operator|==
literal|null
condition|)
block|{
comment|// do nothing
block|}
else|else
block|{
comment|// Cycle consists of atleast one dynamic partition pruning(DPP)
comment|// optimization and atleast one min/max optimization.
comment|// DPP is a better optimization unless it ends up scanning the
comment|// bigger table for keys instead of the smaller table.
comment|// Get the parent TS of victimRS.
name|Operator
argument_list|<
name|?
argument_list|>
name|op
init|=
name|victimRS
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|op
operator|instanceof
name|TableScanOperator
operator|)
condition|)
block|{
name|op
operator|=
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|2
operator|*
name|op
operator|.
name|getStatistics
argument_list|()
operator|.
name|getDataSize
argument_list|()
operator|)
operator|<
name|victimAM
operator|.
name|getStatistics
argument_list|()
operator|.
name|getDataSize
argument_list|()
condition|)
block|{
name|victim
operator|=
name|victimAM
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hasHint
operator|&&
operator|!
name|removed
condition|)
block|{
comment|// There is hint but none of the operators removed. Throw error
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"The user hint is causing an operator cycle. Please fix it and retry"
argument_list|)
throw|;
block|}
if|if
condition|(
name|victim
operator|==
literal|null
operator|||
operator|(
operator|!
name|context
operator|.
name|pruningOpsRemovedByPriorOpt
operator|.
name|isEmpty
argument_list|()
operator|&&
name|context
operator|.
name|pruningOpsRemovedByPriorOpt
operator|.
name|contains
argument_list|(
name|victim
argument_list|)
operator|)
condition|)
block|{
return|return;
block|}
name|GenTezUtils
operator|.
name|removeBranch
argument_list|(
name|victim
argument_list|)
expr_stmt|;
if|if
condition|(
name|victim
operator|==
name|victimRS
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Cycle found. Removing semijoin "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|victimRS
argument_list|)
operator|+
literal|" - "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|victimTS
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|context
operator|.
name|parseContext
argument_list|,
name|victimRS
argument_list|,
name|victimTS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// at this point we've found the fork in the op pipeline that has the pruning as a child plan.
name|LOG
operator|.
name|info
argument_list|(
literal|"Disabling dynamic pruning for: "
operator|+
operator|(
operator|(
name|DynamicPruningEventDesc
operator|)
name|victim
operator|.
name|getConf
argument_list|()
operator|)
operator|.
name|getTableScan
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|". Needed to break cyclic dependency"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Tarjan's algo
specifier|private
name|Set
argument_list|<
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
name|getComponents
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
block|{
name|Deque
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|deque
init|=
operator|new
name|LinkedList
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|deque
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|AtomicInteger
name|index
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|indexes
init|=
operator|new
name|HashMap
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|lowLinks
init|=
operator|new
name|HashMap
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|Stack
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|nodes
init|=
operator|new
name|Stack
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
name|components
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|o
range|:
name|deque
control|)
block|{
if|if
condition|(
operator|!
name|indexes
operator|.
name|containsKey
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|connect
argument_list|(
name|o
argument_list|,
name|index
argument_list|,
name|nodes
argument_list|,
name|indexes
argument_list|,
name|lowLinks
argument_list|,
name|components
argument_list|,
name|procCtx
operator|.
name|parseContext
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|components
return|;
block|}
specifier|private
name|void
name|connect
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|o
parameter_list|,
name|AtomicInteger
name|index
parameter_list|,
name|Stack
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|nodes
parameter_list|,
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|indexes
parameter_list|,
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|lowLinks
parameter_list|,
name|Set
argument_list|<
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
name|components
parameter_list|,
name|ParseContext
name|parseContext
parameter_list|)
block|{
name|indexes
operator|.
name|put
argument_list|(
name|o
argument_list|,
name|index
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lowLinks
operator|.
name|put
argument_list|(
name|o
argument_list|,
name|index
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|index
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|nodes
operator|.
name|push
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|children
decl_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|AppMasterEventOperator
condition|)
block|{
name|children
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
operator|(
name|o
operator|.
name|getChildOperators
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|TableScanOperator
name|ts
init|=
operator|(
operator|(
name|DynamicPruningEventDesc
operator|)
name|o
operator|.
name|getConf
argument_list|()
operator|)
operator|.
name|getTableScan
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding special edge: "
operator|+
name|o
operator|.
name|getName
argument_list|()
operator|+
literal|" --> "
operator|+
name|ts
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|children
operator|.
name|add
argument_list|(
name|ts
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|TerminalOperator
condition|)
block|{
name|children
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
operator|(
name|o
operator|.
name|getChildOperators
argument_list|()
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ReduceSinkOperator
name|rs
range|:
name|parseContext
operator|.
name|getTerminalOpToRSMap
argument_list|()
operator|.
name|get
argument_list|(
operator|(
name|TerminalOperator
argument_list|<
name|?
argument_list|>
operator|)
name|o
argument_list|)
control|)
block|{
comment|// add an edge
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding special edge: From terminal op to semijoin edge "
operator|+
name|o
operator|.
name|getName
argument_list|()
operator|+
literal|" --> "
operator|+
name|rs
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|children
operator|.
name|add
argument_list|(
name|rs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
comment|// semijoin case
name|SemiJoinBranchInfo
name|sjInfo
init|=
name|parseContext
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|get
argument_list|(
name|o
argument_list|)
decl_stmt|;
if|if
condition|(
name|sjInfo
operator|!=
literal|null
condition|)
block|{
name|TableScanOperator
name|ts
init|=
name|sjInfo
operator|.
name|getTsOp
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding special edge: "
operator|+
name|o
operator|.
name|getName
argument_list|()
operator|+
literal|" --> "
operator|+
name|ts
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|children
operator|.
name|add
argument_list|(
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|children
operator|=
name|o
operator|.
name|getChildOperators
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|child
range|:
name|children
control|)
block|{
if|if
condition|(
operator|!
name|indexes
operator|.
name|containsKey
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|connect
argument_list|(
name|child
argument_list|,
name|index
argument_list|,
name|nodes
argument_list|,
name|indexes
argument_list|,
name|lowLinks
argument_list|,
name|components
argument_list|,
name|parseContext
argument_list|)
expr_stmt|;
name|lowLinks
operator|.
name|put
argument_list|(
name|o
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|lowLinks
operator|.
name|get
argument_list|(
name|o
argument_list|)
argument_list|,
name|lowLinks
operator|.
name|get
argument_list|(
name|child
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nodes
operator|.
name|contains
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|lowLinks
operator|.
name|put
argument_list|(
name|o
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|lowLinks
operator|.
name|get
argument_list|(
name|o
argument_list|)
argument_list|,
name|indexes
operator|.
name|get
argument_list|(
name|child
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lowLinks
operator|.
name|get
argument_list|(
name|o
argument_list|)
operator|.
name|equals
argument_list|(
name|indexes
operator|.
name|get
argument_list|(
name|o
argument_list|)
argument_list|)
condition|)
block|{
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|component
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|components
operator|.
name|add
argument_list|(
name|component
argument_list|)
expr_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|current
decl_stmt|;
do|do
block|{
name|current
operator|=
name|nodes
operator|.
name|pop
argument_list|()
expr_stmt|;
name|component
operator|.
name|add
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|current
operator|!=
name|o
condition|)
do|;
block|}
block|}
specifier|private
name|void
name|runStatsAnnotation
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
operator|new
name|AnnotateWithStatistics
argument_list|()
operator|.
name|transform
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|)
expr_stmt|;
operator|new
name|AnnotateWithOpTraits
argument_list|()
operator|.
name|transform
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|runStatsDependentOptimizations
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|,
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
parameter_list|,
name|Set
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Sequence of TableScan operators to be walked
name|Deque
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|deque
init|=
operator|new
name|LinkedList
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|deque
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
comment|// create a walker which walks the tree in a DFS manner while maintaining
comment|// the operator stack.
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Set parallelism - ReduceSink"
argument_list|,
name|ReduceSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|SetReducerParallelism
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Convert Join to Map-join"
argument_list|,
name|JoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|ConvertJoinMapJoin
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVEMAPAGGRHASHMINREDUCTIONSTATSADJUST
argument_list|)
condition|)
block|{
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Set min reduction - GBy (Hash)"
argument_list|,
name|GroupByOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|SetHashGroupByMinReduction
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// The dispatcher fires the processor corresponding to the closest matching
comment|// rule and passes the context along
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|ForwardWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|semijoinRemovalBasedTransformations
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|,
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
parameter_list|,
name|Set
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|PerfLogger
name|perfLogger
init|=
name|SessionState
operator|.
name|getPerfLogger
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|dynamicPartitionPruningEnabled
init|=
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_DYNAMIC_PARTITION_PRUNING
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|semiJoinReductionEnabled
init|=
name|dynamicPartitionPruningEnabled
operator|&&
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_DYNAMIC_SEMIJOIN_REDUCTION
argument_list|)
operator|&&
name|procCtx
operator|.
name|parseContext
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|0
decl_stmt|;
specifier|final
name|boolean
name|extendedReductionEnabled
init|=
name|dynamicPartitionPruningEnabled
operator|&&
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_DYNAMIC_PARTITION_PRUNING_EXTENDED
argument_list|)
decl_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamicPartitionPruningEnabled
condition|)
block|{
name|runRemoveDynamicPruningOptimization
argument_list|(
name|procCtx
argument_list|,
name|inputs
argument_list|,
name|outputs
argument_list|)
expr_stmt|;
block|}
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Run remove dynamic pruning by size"
argument_list|)
expr_stmt|;
if|if
condition|(
name|semiJoinReductionEnabled
condition|)
block|{
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
name|markSemiJoinForDPP
argument_list|(
name|procCtx
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Mark certain semijoin edges important based "
argument_list|)
expr_stmt|;
comment|// Remove any semi join edges from Union Op
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
name|removeSemiJoinEdgesForUnion
argument_list|(
name|procCtx
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Remove any semi join edge between Union and RS"
argument_list|)
expr_stmt|;
comment|// Remove any parallel edge between semijoin and mapjoin.
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
name|removeSemijoinsParallelToMapJoin
argument_list|(
name|procCtx
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Remove any parallel edge between semijoin and mapjoin"
argument_list|)
expr_stmt|;
comment|// Remove semijoin optimization if SMB join is created.
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
name|removeSemijoinOptimizationFromSMBJoins
argument_list|(
name|procCtx
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Remove semijoin optimizations if needed"
argument_list|)
expr_stmt|;
comment|// Remove bloomfilter if no stats generated
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
name|removeSemiJoinIfNoStats
argument_list|(
name|procCtx
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Remove bloom filter optimizations if needed"
argument_list|)
expr_stmt|;
comment|// Removing semijoin optimization when it may not be beneficial
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
name|removeSemijoinOptimizationByBenefit
argument_list|(
name|procCtx
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Remove Semijoins based on cost benefits"
argument_list|)
expr_stmt|;
block|}
comment|// after the stats phase we might have some cyclic dependencies that we need
comment|// to take care of.
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamicPartitionPruningEnabled
condition|)
block|{
name|runCycleAnalysisForPartitionPruning
argument_list|(
name|procCtx
argument_list|,
name|inputs
argument_list|,
name|outputs
argument_list|)
expr_stmt|;
block|}
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Run cycle analysis for partition pruning"
argument_list|)
expr_stmt|;
comment|// remove redundant dpp and semijoins
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
if|if
condition|(
name|extendedReductionEnabled
condition|)
block|{
name|removeRedundantSemijoinAndDpp
argument_list|(
name|procCtx
argument_list|)
expr_stmt|;
block|}
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"Remove redundant semijoin reduction"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|runRemoveDynamicPruningOptimization
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|,
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
parameter_list|,
name|Set
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Sequence of TableScan operators to be walked
name|Deque
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|deque
init|=
operator|new
name|LinkedList
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|deque
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
comment|// create a walker which walks the tree in a DFS manner while maintaining
comment|// the operator stack.
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Remove dynamic pruning by size"
argument_list|,
name|AppMasterEventOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|RemoveDynamicPruningBySize
argument_list|()
argument_list|)
expr_stmt|;
comment|// The dispatcher fires the processor corresponding to the closest matching
comment|// rule and passes the context along
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|ForwardWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|runDynamicPartitionPruning
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|,
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
parameter_list|,
name|Set
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_DYNAMIC_PARTITION_PRUNING
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Sequence of TableScan operators to be walked
name|Deque
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|deque
init|=
operator|new
name|LinkedList
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|deque
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"Dynamic Partition Pruning"
argument_list|)
argument_list|,
name|FilterOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|DynamicPartitionPruningOptimization
argument_list|()
argument_list|)
expr_stmt|;
comment|// The dispatcher fires the processor corresponding to the closest matching
comment|// rule and passes the context along
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|ForwardWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|generateTaskTree
parameter_list|(
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|rootTasks
parameter_list|,
name|ParseContext
name|pCtx
parameter_list|,
name|List
argument_list|<
name|Task
argument_list|<
name|MoveWork
argument_list|>
argument_list|>
name|mvTask
parameter_list|,
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
parameter_list|,
name|Set
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|PerfLogger
name|perfLogger
init|=
name|SessionState
operator|.
name|getPerfLogger
argument_list|()
decl_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
name|ParseContext
name|tempParseContext
init|=
name|getParseContext
argument_list|(
name|pCtx
argument_list|,
name|rootTasks
argument_list|)
decl_stmt|;
name|GenTezUtils
name|utils
init|=
operator|new
name|GenTezUtils
argument_list|()
decl_stmt|;
name|GenTezWork
name|genTezWork
init|=
operator|new
name|GenTezWork
argument_list|(
name|utils
argument_list|)
decl_stmt|;
name|GenTezProcContext
name|procCtx
init|=
operator|new
name|GenTezProcContext
argument_list|(
name|conf
argument_list|,
name|tempParseContext
argument_list|,
name|mvTask
argument_list|,
name|rootTasks
argument_list|,
name|inputs
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
comment|// create a walker which walks the tree in a DFS manner while maintaining
comment|// the operator stack.
comment|// The dispatcher generates the plan from the operator tree
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Split Work - ReduceSink"
argument_list|,
name|ReduceSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
name|genTezWork
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"No more walking on ReduceSink-MapJoin"
argument_list|,
name|MapJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|ReduceSinkMapJoinProc
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Recognize a Sorted Merge Join operator to setup the right edge and"
operator|+
literal|" stop traversing the DummyStore-MapJoin"
argument_list|,
name|CommonMergeJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|MergeJoinProc
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Split Work + Move/Merge - FileSink"
argument_list|,
name|FileSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|CompositeProcessor
argument_list|(
operator|new
name|FileSinkProcessor
argument_list|()
argument_list|,
name|genTezWork
argument_list|)
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Split work - DummyStore"
argument_list|,
name|DummyStoreOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
name|genTezWork
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Handle Potential Analyze Command"
argument_list|,
name|TableScanOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|ProcessAnalyzeTable
argument_list|(
name|utils
argument_list|)
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Remember union"
argument_list|,
name|UnionOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|UnionProcessor
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"AppMasterEventOperator"
argument_list|,
name|AppMasterEventOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|AppMasterEventProcessor
argument_list|()
argument_list|)
expr_stmt|;
comment|// The dispatcher fires the processor corresponding to the closest matching
comment|// rule and passes the context along
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|pCtx
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|GenTezWorkWalker
argument_list|(
name|disp
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// we need to specify the reserved memory for each work that contains Map Join
for|for
control|(
name|List
argument_list|<
name|BaseWork
argument_list|>
name|baseWorkList
range|:
name|procCtx
operator|.
name|mapJoinWorkMap
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|BaseWork
name|w
range|:
name|baseWorkList
control|)
block|{
comment|// work should be the smallest unit for memory allocation
name|w
operator|.
name|setReservedMemoryMB
argument_list|(
call|(
name|int
call|)
argument_list|(
name|conf
operator|.
name|getLongVar
argument_list|(
name|ConfVars
operator|.
name|HIVECONVERTJOINNOCONDITIONALTASKTHRESHOLD
argument_list|)
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// we need to clone some operator plans and remove union operators still
name|int
name|indexForTezUnion
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BaseWork
name|w
range|:
name|procCtx
operator|.
name|workWithUnionOperators
control|)
block|{
name|GenTezUtils
operator|.
name|removeUnionOperators
argument_list|(
name|procCtx
argument_list|,
name|w
argument_list|,
name|indexForTezUnion
operator|++
argument_list|)
expr_stmt|;
block|}
comment|// then we make sure the file sink operators are set up right
for|for
control|(
name|FileSinkOperator
name|fileSink
range|:
name|procCtx
operator|.
name|fileSinkSet
control|)
block|{
name|GenTezUtils
operator|.
name|processFileSink
argument_list|(
name|procCtx
argument_list|,
name|fileSink
argument_list|)
expr_stmt|;
block|}
comment|// Connect any edges required for min/max pushdown
if|if
condition|(
name|pCtx
operator|.
name|getRsToRuntimeValuesInfoMap
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|ReduceSinkOperator
name|rs
range|:
name|pCtx
operator|.
name|getRsToRuntimeValuesInfoMap
argument_list|()
operator|.
name|keySet
argument_list|()
control|)
block|{
comment|// Process min/max
name|GenTezUtils
operator|.
name|processDynamicSemiJoinPushDownOperator
argument_list|(
name|procCtx
argument_list|,
name|pCtx
operator|.
name|getRsToRuntimeValuesInfoMap
argument_list|()
operator|.
name|get
argument_list|(
name|rs
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
block|}
comment|// and finally we hook up any events that need to be sent to the tez AM
name|LOG
operator|.
name|debug
argument_list|(
literal|"There are "
operator|+
name|procCtx
operator|.
name|eventOperatorSet
operator|.
name|size
argument_list|()
operator|+
literal|" app master events."
argument_list|)
expr_stmt|;
for|for
control|(
name|AppMasterEventOperator
name|event
range|:
name|procCtx
operator|.
name|eventOperatorSet
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Handling AppMasterEventOperator: "
operator|+
name|event
argument_list|)
expr_stmt|;
name|GenTezUtils
operator|.
name|processAppMasterEvent
argument_list|(
name|procCtx
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"generateTaskTree"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|setInputFormat
parameter_list|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
parameter_list|)
block|{
if|if
condition|(
name|task
operator|instanceof
name|TezTask
condition|)
block|{
name|TezWork
name|work
init|=
operator|(
operator|(
name|TezTask
operator|)
name|task
operator|)
operator|.
name|getWork
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|BaseWork
argument_list|>
name|all
init|=
name|work
operator|.
name|getAllWork
argument_list|()
decl_stmt|;
for|for
control|(
name|BaseWork
name|w
range|:
name|all
control|)
block|{
if|if
condition|(
name|w
operator|instanceof
name|MapWork
condition|)
block|{
name|MapWork
name|mapWork
init|=
operator|(
name|MapWork
operator|)
name|w
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|opMap
init|=
name|mapWork
operator|.
name|getAliasToWork
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|opMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|opMap
operator|.
name|values
argument_list|()
control|)
block|{
name|setInputFormat
argument_list|(
name|mapWork
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|task
operator|instanceof
name|ConditionalTask
condition|)
block|{
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|listTasks
init|=
operator|(
operator|(
name|ConditionalTask
operator|)
name|task
operator|)
operator|.
name|getListTasks
argument_list|()
decl_stmt|;
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|tsk
range|:
name|listTasks
control|)
block|{
name|setInputFormat
argument_list|(
name|tsk
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|task
operator|.
name|getChildTasks
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|childTask
range|:
name|task
operator|.
name|getChildTasks
argument_list|()
control|)
block|{
name|setInputFormat
argument_list|(
name|childTask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|setInputFormat
parameter_list|(
name|MapWork
name|work
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
block|{
if|if
condition|(
name|op
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|op
operator|.
name|isUseBucketizedHiveInputFormat
argument_list|()
condition|)
block|{
name|work
operator|.
name|setUseBucketizedHiveInputFormat
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|op
operator|.
name|getChildOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|childOp
range|:
name|op
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|setInputFormat
argument_list|(
name|work
argument_list|,
name|childOp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|decideExecMode
parameter_list|(
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|rootTasks
parameter_list|,
name|Context
name|ctx
parameter_list|,
name|GlobalLimitCtx
name|globalLimitCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// currently all Tez work is on the cluster
return|return;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|optimizeTaskPlan
parameter_list|(
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|rootTasks
parameter_list|,
name|ParseContext
name|pCtx
parameter_list|,
name|Context
name|ctx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|PerfLogger
name|perfLogger
init|=
name|SessionState
operator|.
name|getPerfLogger
argument_list|()
decl_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|)
expr_stmt|;
name|PhysicalContext
name|physicalCtx
init|=
operator|new
name|PhysicalContext
argument_list|(
name|conf
argument_list|,
name|pCtx
argument_list|,
name|pCtx
operator|.
name|getContext
argument_list|()
argument_list|,
name|rootTasks
argument_list|,
name|pCtx
operator|.
name|getFetchTask
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVENULLSCANOPTIMIZE
argument_list|)
condition|)
block|{
name|physicalCtx
operator|=
operator|new
name|NullScanOptimizer
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping null scan query optimization"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMETADATAONLYQUERIES
argument_list|)
condition|)
block|{
name|physicalCtx
operator|=
operator|new
name|MetadataOnlyOptimizer
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping metadata only query optimization"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_CHECK_CROSS_PRODUCT
argument_list|)
condition|)
block|{
name|physicalCtx
operator|=
operator|new
name|CrossProductHandler
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping cross product analysis"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|"llap"
operator|.
name|equalsIgnoreCase
argument_list|(
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_EXECUTION_MODE
argument_list|)
argument_list|)
condition|)
block|{
name|physicalCtx
operator|=
operator|new
name|LlapPreVectorizationPass
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping llap pre-vectorization pass"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_ENABLED
argument_list|)
condition|)
block|{
name|physicalCtx
operator|=
operator|new
name|Vectorizer
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping vectorization"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
literal|"none"
operator|.
name|equalsIgnoreCase
argument_list|(
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESTAGEIDREARRANGE
argument_list|)
argument_list|)
condition|)
block|{
name|physicalCtx
operator|=
operator|new
name|StageIDsRearranger
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping stage id rearranger"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_TEZ_ENABLE_MEMORY_MANAGER
argument_list|)
operator|)
operator|&&
operator|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEUSEHYBRIDGRACEHASHJOIN
argument_list|)
operator|)
condition|)
block|{
name|physicalCtx
operator|=
operator|new
name|MemoryDecider
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|"llap"
operator|.
name|equalsIgnoreCase
argument_list|(
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_EXECUTION_MODE
argument_list|)
argument_list|)
condition|)
block|{
name|LlapClusterStateForCompile
name|llapInfo
init|=
name|LlapClusterStateForCompile
operator|.
name|getClusterInfo
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|physicalCtx
operator|=
operator|new
name|LlapDecider
argument_list|(
name|llapInfo
argument_list|)
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping llap decider"
argument_list|)
expr_stmt|;
block|}
comment|//  This optimizer will serialize all filters that made it to the
comment|//  table scan operator to avoid having to do it multiple times on
comment|//  the backend. If you have a physical optimization that changes
comment|//  table scans or filters, you have to invoke it before this one.
name|physicalCtx
operator|=
operator|new
name|SerializeFilter
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|physicalCtx
operator|.
name|getContext
argument_list|()
operator|.
name|getExplainAnalyze
argument_list|()
operator|!=
literal|null
condition|)
block|{
operator|new
name|AnnotateRunTimeStatsOptimizer
argument_list|()
operator|.
name|resolve
argument_list|(
name|physicalCtx
argument_list|)
expr_stmt|;
block|}
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|TEZ_COMPILER
argument_list|,
literal|"optimizeTaskPlan"
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|private
specifier|static
class|class
name|SMBJoinOpProcContext
implements|implements
name|NodeProcessorCtx
block|{
name|HashMap
argument_list|<
name|CommonMergeJoinOperator
argument_list|,
name|TableScanOperator
argument_list|>
name|JoinOpToTsOpMap
init|=
operator|new
name|HashMap
argument_list|<
name|CommonMergeJoinOperator
argument_list|,
name|TableScanOperator
argument_list|>
argument_list|()
decl_stmt|;
block|}
specifier|private
specifier|static
class|class
name|SMBJoinOpProc
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|SMBJoinOpProcContext
name|ctx
init|=
operator|(
name|SMBJoinOpProcContext
operator|)
name|procCtx
decl_stmt|;
name|ctx
operator|.
name|JoinOpToTsOpMap
operator|.
name|put
argument_list|(
operator|(
name|CommonMergeJoinOperator
operator|)
name|nd
argument_list|,
operator|(
name|TableScanOperator
operator|)
name|stack
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
specifier|private
specifier|static
name|void
name|removeSemijoinOptimizationFromSMBJoins
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R1"
argument_list|,
name|TableScanOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
literal|".*"
operator|+
name|TezDummyStoreOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|CommonMergeJoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|SMBJoinOpProc
argument_list|()
argument_list|)
expr_stmt|;
name|SMBJoinOpProcContext
name|ctx
init|=
operator|new
name|SMBJoinOpProcContext
argument_list|()
decl_stmt|;
comment|// The dispatcher finds SMB and if there is semijoin optimization before it, removes it.
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|ctx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|PreOrderOnceWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|TableScanOperator
argument_list|>
name|tsOps
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Iterate over the map and remove semijoin optimizations if needed.
for|for
control|(
name|CommonMergeJoinOperator
name|joinOp
range|:
name|ctx
operator|.
name|JoinOpToTsOpMap
operator|.
name|keySet
argument_list|()
control|)
block|{
comment|// Get one top level TS Op directly from the stack
name|tsOps
operator|.
name|add
argument_list|(
name|ctx
operator|.
name|JoinOpToTsOpMap
operator|.
name|get
argument_list|(
name|joinOp
argument_list|)
argument_list|)
expr_stmt|;
comment|// Get the other one by examining Join Op
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|parents
init|=
name|joinOp
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
range|:
name|parents
control|)
block|{
if|if
condition|(
name|parent
operator|instanceof
name|TezDummyStoreOperator
condition|)
block|{
comment|// already accounted for
continue|continue;
block|}
while|while
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|parent
operator|instanceof
name|TableScanOperator
condition|)
block|{
name|tsOps
operator|.
name|add
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|parent
argument_list|)
expr_stmt|;
break|break;
block|}
name|parent
operator|=
name|parent
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Now the relevant TableScanOperators are known, find if there exists
comment|// a semijoin filter on any of them, if so, remove it.
name|ParseContext
name|pctx
init|=
name|procCtx
operator|.
name|parseContext
decl_stmt|;
name|Set
argument_list|<
name|ReduceSinkOperator
argument_list|>
name|rsSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|pctx
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|TableScanOperator
name|ts
range|:
name|tsOps
control|)
block|{
for|for
control|(
name|ReduceSinkOperator
name|rs
range|:
name|rsSet
control|)
block|{
name|SemiJoinBranchInfo
name|sjInfo
init|=
name|pctx
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|get
argument_list|(
name|rs
argument_list|)
decl_stmt|;
if|if
condition|(
name|sjInfo
operator|!=
literal|null
operator|&&
name|ts
operator|==
name|sjInfo
operator|.
name|getTsOp
argument_list|()
condition|)
block|{
comment|// match!
if|if
condition|(
name|sjInfo
operator|.
name|getIsHint
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Removing hinted semijoin as it is with SMB join "
operator|+
name|rs
operator|+
literal|" : "
operator|+
name|ts
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Semijoin optimization found going to SMB join. Removing semijoin "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|rs
argument_list|)
operator|+
literal|" - "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|GenTezUtils
operator|.
name|removeBranch
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|pctx
argument_list|,
name|rs
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
specifier|static
class|class
name|TerminalOpsInfo
block|{
specifier|public
name|Set
argument_list|<
name|TerminalOperator
argument_list|<
name|?
argument_list|>
argument_list|>
name|terminalOps
decl_stmt|;
specifier|public
name|Set
argument_list|<
name|ReduceSinkOperator
argument_list|>
name|rsOps
decl_stmt|;
name|TerminalOpsInfo
parameter_list|(
name|Set
argument_list|<
name|TerminalOperator
argument_list|<
name|?
argument_list|>
argument_list|>
name|terminalOps
parameter_list|,
name|Set
argument_list|<
name|ReduceSinkOperator
argument_list|>
name|rsOps
parameter_list|)
block|{
name|this
operator|.
name|terminalOps
operator|=
name|terminalOps
expr_stmt|;
name|this
operator|.
name|rsOps
operator|=
name|rsOps
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|connectTerminalOps
parameter_list|(
name|ParseContext
name|pCtx
parameter_list|)
block|{
comment|// The map which contains the virtual edges from non-semijoin terminal ops to semjoin RSs.
name|Multimap
argument_list|<
name|TerminalOperator
argument_list|<
name|?
argument_list|>
argument_list|,
name|ReduceSinkOperator
argument_list|>
name|terminalOpToRSMap
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
comment|// Map of semijoin RS to work ops to ensure no work is examined more than once.
name|Map
argument_list|<
name|ReduceSinkOperator
argument_list|,
name|TerminalOpsInfo
argument_list|>
name|rsToTerminalOpsInfo
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Get all the terminal ops
for|for
control|(
name|ReduceSinkOperator
name|rs
range|:
name|pCtx
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|keySet
argument_list|()
control|)
block|{
name|TerminalOpsInfo
name|terminalOpsInfo
init|=
name|rsToTerminalOpsInfo
operator|.
name|get
argument_list|(
name|rs
argument_list|)
decl_stmt|;
if|if
condition|(
name|terminalOpsInfo
operator|!=
literal|null
condition|)
block|{
continue|continue;
comment|// done with this one
block|}
name|Set
argument_list|<
name|ReduceSinkOperator
argument_list|>
name|workRSOps
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|TerminalOperator
argument_list|<
name|?
argument_list|>
argument_list|>
name|workTerminalOps
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Get the SEL Op in the semijoin-branch, SEL->GBY1->RS1->GBY2->RS2
name|Operator
argument_list|<
name|?
argument_list|>
name|selOp
init|=
name|rs
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|OperatorUtils
operator|.
name|findWorkOperatorsAndSemiJoinEdges
argument_list|(
name|selOp
argument_list|,
name|pCtx
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
argument_list|,
name|workRSOps
argument_list|,
name|workTerminalOps
argument_list|)
expr_stmt|;
name|TerminalOpsInfo
name|candidate
init|=
operator|new
name|TerminalOpsInfo
argument_list|(
name|workTerminalOps
argument_list|,
name|workRSOps
argument_list|)
decl_stmt|;
comment|// A work may contain multiple semijoin edges, traverse rsOps and add for each
for|for
control|(
name|ReduceSinkOperator
name|rsFound
range|:
name|workRSOps
control|)
block|{
name|rsToTerminalOpsInfo
operator|.
name|put
argument_list|(
name|rsFound
argument_list|,
name|candidate
argument_list|)
expr_stmt|;
for|for
control|(
name|TerminalOperator
argument_list|<
name|?
argument_list|>
name|terminalOp
range|:
name|candidate
operator|.
name|terminalOps
control|)
block|{
name|terminalOpToRSMap
operator|.
name|put
argument_list|(
name|terminalOp
argument_list|,
name|rsFound
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|pCtx
operator|.
name|setTerminalOpToRSMap
argument_list|(
name|terminalOpToRSMap
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|removeSemiJoinIfNoStats
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R1"
argument_list|,
name|GroupByOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|ReduceSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|GroupByOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|ReduceSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|SemiJoinRemovalProc
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|SemiJoinRemovalContext
name|ctx
init|=
operator|new
name|SemiJoinRemovalContext
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|)
decl_stmt|;
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|ctx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|PreOrderOnceWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
class|class
name|CollectAll
implements|implements
name|NodeProcessor
block|{
specifier|private
name|PlanMapper
name|planMapper
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ParseContext
name|pCtx
init|=
operator|(
operator|(
name|OptimizeTezProcContext
operator|)
name|procCtx
operator|)
operator|.
name|parseContext
decl_stmt|;
name|planMapper
operator|=
name|pCtx
operator|.
name|getContext
argument_list|()
operator|.
name|getPlanMapper
argument_list|()
expr_stmt|;
name|FilterOperator
name|fop
init|=
operator|(
name|FilterOperator
operator|)
name|nd
decl_stmt|;
name|OpTreeSignature
name|sig
init|=
name|planMapper
operator|.
name|getSignatureOf
argument_list|(
name|fop
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|EquivGroup
argument_list|>
name|ar
init|=
name|getGroups
argument_list|(
name|planMapper
argument_list|,
name|HiveFilter
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|nd
return|;
block|}
specifier|private
name|List
argument_list|<
name|EquivGroup
argument_list|>
name|getGroups
parameter_list|(
name|PlanMapper
name|planMapper2
parameter_list|,
name|Class
argument_list|<
name|HiveFilter
argument_list|>
name|class1
parameter_list|)
block|{
name|Iterator
argument_list|<
name|EquivGroup
argument_list|>
name|it
init|=
name|planMapper
operator|.
name|iterateGroups
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|EquivGroup
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<
name|PlanMapper
operator|.
name|EquivGroup
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|EquivGroup
name|g
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|g
operator|.
name|getAll
argument_list|(
name|class1
argument_list|)
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|ret
operator|.
name|add
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|MarkRuntimeStatsAsIncorrect
implements|implements
name|NodeProcessor
block|{
specifier|private
name|PlanMapper
name|planMapper
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ParseContext
name|pCtx
init|=
operator|(
operator|(
name|OptimizeTezProcContext
operator|)
name|procCtx
operator|)
operator|.
name|parseContext
decl_stmt|;
name|planMapper
operator|=
name|pCtx
operator|.
name|getContext
argument_list|()
operator|.
name|getPlanMapper
argument_list|()
expr_stmt|;
if|if
condition|(
name|nd
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|ReduceSinkOperator
name|rs
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|nd
decl_stmt|;
name|SemiJoinBranchInfo
name|sjInfo
init|=
name|pCtx
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|get
argument_list|(
name|rs
argument_list|)
decl_stmt|;
if|if
condition|(
name|sjInfo
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|walkSubtree
argument_list|(
name|sjInfo
operator|.
name|getTsOp
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|instanceof
name|AppMasterEventOperator
condition|)
block|{
name|AppMasterEventOperator
name|ame
init|=
operator|(
name|AppMasterEventOperator
operator|)
name|nd
decl_stmt|;
name|AppMasterEventDesc
name|c
init|=
name|ame
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|instanceof
name|DynamicPruningEventDesc
condition|)
block|{
name|DynamicPruningEventDesc
name|dped
init|=
operator|(
name|DynamicPruningEventDesc
operator|)
name|c
decl_stmt|;
name|mark
argument_list|(
name|dped
operator|.
name|getTableScan
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nd
operator|instanceof
name|TableScanOperator
condition|)
block|{
comment|// If the tablescan operator is making use of filtering capabilities of readers then
comment|// we will not see the actual incoming rowcount which was processed - so we may not use it for relNodes
name|TableScanOperator
name|ts
init|=
operator|(
name|TableScanOperator
operator|)
name|nd
decl_stmt|;
if|if
condition|(
name|ts
operator|.
name|getConf
argument_list|()
operator|.
name|getPredicateString
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|planMapper
operator|.
name|link
argument_list|(
name|ts
argument_list|,
operator|new
name|OperatorStats
operator|.
name|MayNotUseForRelNodes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|void
name|walkSubtree
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|root
parameter_list|)
block|{
name|Deque
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|deque
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|deque
operator|.
name|add
argument_list|(
name|root
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|deque
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|op
init|=
name|deque
operator|.
name|pollLast
argument_list|()
decl_stmt|;
name|mark
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
comment|// Done with this branch
block|}
else|else
block|{
name|deque
operator|.
name|addAll
argument_list|(
name|op
operator|.
name|getChildOperators
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|mark
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
parameter_list|)
block|{
name|planMapper
operator|.
name|link
argument_list|(
name|op
argument_list|,
operator|new
name|OperatorStats
operator|.
name|IncorrectRuntimeStatsMarker
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|markOperatorsWithUnstableRuntimeStats
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R1"
argument_list|,
name|ReduceSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|MarkRuntimeStatsAsIncorrect
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R2"
argument_list|,
name|AppMasterEventOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|MarkRuntimeStatsAsIncorrect
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R3"
argument_list|,
name|TableScanOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|MarkRuntimeStatsAsIncorrect
argument_list|()
argument_list|)
expr_stmt|;
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|PreOrderOnceWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
class|class
name|SemiJoinRemovalProc
implements|implements
name|NodeProcessor
block|{
specifier|private
specifier|final
name|boolean
name|removeBasedOnStats
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|removeRedundant
decl_stmt|;
specifier|private
name|SemiJoinRemovalProc
parameter_list|(
name|boolean
name|removeBasedOnStats
parameter_list|,
name|boolean
name|removeRedundant
parameter_list|)
block|{
name|this
operator|.
name|removeBasedOnStats
operator|=
name|removeBasedOnStats
expr_stmt|;
name|this
operator|.
name|removeRedundant
operator|=
name|removeRedundant
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ReduceSinkOperator
name|rs
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|nd
decl_stmt|;
name|SemiJoinRemovalContext
name|rCtx
init|=
operator|(
name|SemiJoinRemovalContext
operator|)
name|procCtx
decl_stmt|;
name|ParseContext
name|pCtx
init|=
name|rCtx
operator|.
name|parseContext
decl_stmt|;
name|SemiJoinBranchInfo
name|sjInfo
init|=
name|pCtx
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|get
argument_list|(
name|rs
argument_list|)
decl_stmt|;
if|if
condition|(
name|sjInfo
operator|==
literal|null
condition|)
block|{
comment|// nothing to do here.
return|return
literal|null
return|;
block|}
name|TableScanOperator
name|targetTSOp
init|=
name|sjInfo
operator|.
name|getTsOp
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|targetColExpr
init|=
name|pCtx
operator|.
name|getRsToRuntimeValuesInfoMap
argument_list|()
operator|.
name|get
argument_list|(
name|rs
argument_list|)
operator|.
name|getTsColExpr
argument_list|()
decl_stmt|;
comment|// This is a semijoin branch. The stack should look like,
comment|//<Parent Ops>-SEL-GB1-RS1-GB2-RS2
name|GroupByOperator
name|gbOp
init|=
operator|(
name|GroupByOperator
operator|)
name|stack
operator|.
name|get
argument_list|(
name|stack
operator|.
name|size
argument_list|()
operator|-
literal|2
argument_list|)
decl_stmt|;
name|GroupByDesc
name|gbDesc
init|=
name|gbOp
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
name|aggregationDescs
init|=
name|gbDesc
operator|.
name|getAggregators
argument_list|()
decl_stmt|;
for|for
control|(
name|AggregationDesc
name|agg
range|:
name|aggregationDescs
control|)
block|{
if|if
condition|(
operator|!
name|isBloomFilterAgg
argument_list|(
name|agg
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|GenericUDAFBloomFilterEvaluator
name|udafBloomFilterEvaluator
init|=
operator|(
name|GenericUDAFBloomFilterEvaluator
operator|)
name|agg
operator|.
name|getGenericUDAFEvaluator
argument_list|()
decl_stmt|;
if|if
condition|(
name|udafBloomFilterEvaluator
operator|.
name|hasHintEntries
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
comment|// Created using hint, skip it
block|}
if|if
condition|(
name|removeBasedOnStats
condition|)
block|{
name|long
name|expectedEntries
init|=
name|udafBloomFilterEvaluator
operator|.
name|getExpectedEntries
argument_list|()
decl_stmt|;
if|if
condition|(
name|expectedEntries
operator|==
operator|-
literal|1
operator|||
name|expectedEntries
operator|>
name|pCtx
operator|.
name|getConf
argument_list|()
operator|.
name|getLongVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_MAX_BLOOM_FILTER_ENTRIES
argument_list|)
condition|)
block|{
if|if
condition|(
name|sjInfo
operator|.
name|getIsHint
argument_list|()
operator|&&
name|expectedEntries
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Removing hinted semijoin due to lack to stats"
operator|+
literal|" or exceeding max bloom filter entries"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|sjInfo
operator|.
name|getIsHint
argument_list|()
condition|)
block|{
comment|// do not remove if hint is provided
continue|continue;
block|}
comment|// Remove the semijoin optimization branch along with ALL the mappings
comment|// The parent GB2 has all the branches. Collect them and remove them.
for|for
control|(
name|Node
name|node
range|:
name|gbOp
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|ReduceSinkOperator
name|rsFinal
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|node
decl_stmt|;
name|TableScanOperator
name|ts
init|=
name|pCtx
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|get
argument_list|(
name|rsFinal
argument_list|)
operator|.
name|getTsOp
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"expectedEntries="
operator|+
name|expectedEntries
operator|+
literal|". "
operator|+
literal|"Either stats unavailable or expectedEntries exceeded max allowable bloomfilter size. "
operator|+
literal|"Removing semijoin "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|rs
argument_list|)
operator|+
literal|" - "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|GenTezUtils
operator|.
name|removeBranch
argument_list|(
name|rsFinal
argument_list|)
expr_stmt|;
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|pCtx
argument_list|,
name|rsFinal
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
block|}
if|if
condition|(
name|removeBasedOnStats
condition|)
block|{
comment|// At this point, hinted semijoin case has been handled already
comment|// Check if big table is big enough that runtime filtering is
comment|// worth it.
name|TableScanOperator
name|ts
init|=
name|sjInfo
operator|.
name|getTsOp
argument_list|()
decl_stmt|;
if|if
condition|(
name|ts
operator|.
name|getStatistics
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|long
name|numRows
init|=
name|ts
operator|.
name|getStatistics
argument_list|()
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
if|if
condition|(
name|numRows
operator|<
name|pCtx
operator|.
name|getConf
argument_list|()
operator|.
name|getLongVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_BIGTABLE_MIN_SIZE_SEMIJOIN_REDUCTION
argument_list|)
condition|)
block|{
if|if
condition|(
name|sjInfo
operator|.
name|getShouldRemove
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Insufficient rows ("
operator|+
name|numRows
operator|+
literal|") to justify semijoin optimization. Removing semijoin "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|rs
argument_list|)
operator|+
literal|" - "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|GenTezUtils
operator|.
name|removeBranch
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|pCtx
argument_list|,
name|rs
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|removeRedundant
condition|)
block|{
comment|// Look for RS ops above the current semijoin branch
name|Set
argument_list|<
name|ReduceSinkOperator
argument_list|>
name|rsOps
init|=
name|OperatorUtils
operator|.
name|findOperators
argument_list|(
operator|(
operator|(
name|Operator
argument_list|<
name|?
argument_list|>
operator|)
name|stack
operator|.
name|get
argument_list|(
name|stack
operator|.
name|size
argument_list|()
operator|-
literal|5
argument_list|)
operator|)
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|ReduceSinkOperator
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|otherRSOp
range|:
name|rsOps
control|)
block|{
name|SemiJoinBranchInfo
name|otherSjInfo
init|=
name|pCtx
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|get
argument_list|(
name|otherRSOp
argument_list|)
decl_stmt|;
comment|// First conjunct prevents SJ RS from removing itself
if|if
condition|(
name|otherRSOp
operator|!=
name|rs
operator|&&
name|otherSjInfo
operator|!=
literal|null
operator|&&
name|otherSjInfo
operator|.
name|getTsOp
argument_list|()
operator|==
name|targetTSOp
condition|)
block|{
if|if
condition|(
name|rCtx
operator|.
name|opsToRemove
operator|.
name|containsKey
argument_list|(
name|otherRSOp
argument_list|)
condition|)
block|{
comment|// We found siblings, since we are removing the other operator, no need to remove this one
continue|continue;
block|}
name|ExprNodeDesc
name|otherColExpr
init|=
name|pCtx
operator|.
name|getRsToRuntimeValuesInfoMap
argument_list|()
operator|.
name|get
argument_list|(
name|otherRSOp
argument_list|)
operator|.
name|getTsColExpr
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|otherColExpr
operator|.
name|isSame
argument_list|(
name|targetColExpr
argument_list|)
condition|)
block|{
comment|// Filter should be on the same column, otherwise we do not proceed
continue|continue;
block|}
name|rCtx
operator|.
name|opsToRemove
operator|.
name|put
argument_list|(
name|rs
argument_list|,
name|targetTSOp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
specifier|private
specifier|static
name|boolean
name|isBloomFilterAgg
parameter_list|(
name|AggregationDesc
name|agg
parameter_list|)
block|{
return|return
literal|"bloom_filter"
operator|.
name|equals
argument_list|(
name|agg
operator|.
name|getGenericUDAFName
argument_list|()
argument_list|)
return|;
block|}
specifier|private
specifier|static
class|class
name|DynamicPruningRemovalRedundantProc
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|AppMasterEventOperator
name|event
init|=
operator|(
name|AppMasterEventOperator
operator|)
name|nd
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|event
operator|.
name|getConf
argument_list|()
operator|instanceof
name|DynamicPruningEventDesc
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|SemiJoinRemovalContext
name|rCtx
init|=
operator|(
name|SemiJoinRemovalContext
operator|)
name|procCtx
decl_stmt|;
name|DynamicPruningEventDesc
name|desc
init|=
operator|(
name|DynamicPruningEventDesc
operator|)
name|event
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|TableScanOperator
name|targetTSOp
init|=
name|desc
operator|.
name|getTableScan
argument_list|()
decl_stmt|;
name|String
name|targetColumnName
init|=
name|desc
operator|.
name|getTargetColumnName
argument_list|()
decl_stmt|;
comment|// Look for event ops above the current event op branch
name|Operator
argument_list|<
name|?
argument_list|>
name|op
init|=
name|event
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|op
operator|.
name|getChildOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
name|op
operator|=
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|AppMasterEventOperator
argument_list|>
name|eventOps
init|=
name|OperatorUtils
operator|.
name|findOperators
argument_list|(
name|op
argument_list|,
name|AppMasterEventOperator
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|AppMasterEventOperator
name|otherEvent
range|:
name|eventOps
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|otherEvent
operator|.
name|getConf
argument_list|()
operator|instanceof
name|DynamicPruningEventDesc
operator|)
condition|)
block|{
continue|continue;
block|}
name|DynamicPruningEventDesc
name|otherDesc
init|=
operator|(
name|DynamicPruningEventDesc
operator|)
name|otherEvent
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|otherEvent
operator|!=
name|event
operator|&&
name|otherDesc
operator|.
name|getTableScan
argument_list|()
operator|==
name|targetTSOp
operator|&&
name|otherDesc
operator|.
name|getTargetColumnName
argument_list|()
operator|.
name|equals
argument_list|(
name|targetColumnName
argument_list|)
condition|)
block|{
if|if
condition|(
name|rCtx
operator|.
name|opsToRemove
operator|.
name|containsKey
argument_list|(
name|otherEvent
argument_list|)
condition|)
block|{
comment|// We found siblings, since we are removing the other operator, no need to remove this one
continue|continue;
block|}
name|rCtx
operator|.
name|opsToRemove
operator|.
name|put
argument_list|(
name|event
argument_list|,
name|targetTSOp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
specifier|private
name|void
name|removeRedundantSemijoinAndDpp
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R1"
argument_list|,
name|GroupByOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|ReduceSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|GroupByOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|ReduceSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|SemiJoinRemovalProc
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R2"
argument_list|,
name|AppMasterEventOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|DynamicPruningRemovalRedundantProc
argument_list|()
argument_list|)
expr_stmt|;
comment|// Gather
name|SemiJoinRemovalContext
name|ctx
init|=
operator|new
name|SemiJoinRemovalContext
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|)
decl_stmt|;
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|ctx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|PreOrderOnceWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// Remove
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|TableScanOperator
argument_list|>
name|p
range|:
name|ctx
operator|.
name|opsToRemove
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing redundant "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|p
operator|.
name|getKey
argument_list|()
argument_list|)
operator|+
literal|" - "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|p
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|GenTezUtils
operator|.
name|removeBranch
argument_list|(
name|p
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|getKey
argument_list|()
operator|instanceof
name|AppMasterEventOperator
condition|)
block|{
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|,
operator|(
name|AppMasterEventOperator
operator|)
name|p
operator|.
name|getKey
argument_list|()
argument_list|,
name|p
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|.
name|getKey
argument_list|()
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|,
operator|(
name|ReduceSinkOperator
operator|)
name|p
operator|.
name|getKey
argument_list|()
argument_list|,
name|p
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unexpected error - type for branch could not be recognized"
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
class|class
name|SemiJoinRemovalContext
implements|implements
name|NodeProcessorCtx
block|{
specifier|private
specifier|final
name|ParseContext
name|parseContext
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|TableScanOperator
argument_list|>
name|opsToRemove
decl_stmt|;
specifier|private
name|SemiJoinRemovalContext
parameter_list|(
specifier|final
name|ParseContext
name|parseContext
parameter_list|)
block|{
name|this
operator|.
name|parseContext
operator|=
name|parseContext
expr_stmt|;
name|this
operator|.
name|opsToRemove
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|runTopNKeyOptimization
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_OPTIMIZE_TOPNKEY
argument_list|)
condition|)
block|{
return|return;
block|}
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Top n key optimization"
argument_list|,
name|GroupByOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|ReduceSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|TopNKeyProcessor
argument_list|()
argument_list|)
expr_stmt|;
comment|// The dispatcher fires the processor corresponding to the closest matching
comment|// rule and passes the context along
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|DefaultGraphWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|findParallelSemiJoinBranch
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|mapjoin
parameter_list|,
name|TableScanOperator
name|bigTableTS
parameter_list|,
name|ParseContext
name|parseContext
parameter_list|,
name|Map
argument_list|<
name|ReduceSinkOperator
argument_list|,
name|TableScanOperator
argument_list|>
name|semijoins
parameter_list|)
block|{
name|boolean
name|parallelEdges
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|mapjoin
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|op
operator|instanceof
name|ReduceSinkOperator
operator|)
condition|)
block|{
continue|continue;
block|}
name|op
operator|=
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// Follow the Reducesink operator upstream which is on small table side.
while|while
condition|(
operator|!
operator|(
name|op
operator|instanceof
name|ReduceSinkOperator
operator|)
operator|&&
operator|!
operator|(
name|op
operator|instanceof
name|TableScanOperator
operator|)
operator|&&
operator|!
operator|(
name|op
operator|.
name|getChildren
argument_list|()
operator|!=
literal|null
operator|&&
name|op
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|op
operator|instanceof
name|MapJoinOperator
condition|)
block|{
comment|// Pick the correct parent, only one of the parents is not
comment|// ReduceSink, that is what we are looking for.
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|parentOp
range|:
name|op
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
if|if
condition|(
name|parentOp
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
continue|continue;
block|}
name|op
operator|=
name|parentOp
expr_stmt|;
comment|// parent in current pipeline
continue|continue;
block|}
block|}
name|op
operator|=
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// Bail out if RS or TS is encountered.
if|if
condition|(
name|op
operator|instanceof
name|ReduceSinkOperator
operator|||
name|op
operator|instanceof
name|TableScanOperator
condition|)
block|{
continue|continue;
block|}
comment|// A branch is hit.
for|for
control|(
name|Node
name|nd
range|:
name|op
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
name|nd
operator|instanceof
name|SelectOperator
condition|)
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|child
init|=
operator|(
name|Operator
argument_list|<
name|?
argument_list|>
operator|)
name|nd
decl_stmt|;
while|while
condition|(
name|child
operator|.
name|getChildOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|child
operator|=
name|child
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// If not ReduceSink Op, skip
if|if
condition|(
operator|!
operator|(
name|child
operator|instanceof
name|ReduceSinkOperator
operator|)
condition|)
block|{
comment|// This still could be DPP.
if|if
condition|(
name|child
operator|instanceof
name|AppMasterEventOperator
operator|&&
operator|(
operator|(
name|AppMasterEventOperator
operator|)
name|child
operator|)
operator|.
name|getConf
argument_list|()
operator|instanceof
name|DynamicPruningEventDesc
condition|)
block|{
comment|// DPP indeed, Set parallel edges true
name|parallelEdges
operator|=
literal|true
expr_stmt|;
block|}
continue|continue;
block|}
name|ReduceSinkOperator
name|rs
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|child
decl_stmt|;
name|SemiJoinBranchInfo
name|sjInfo
init|=
name|parseContext
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|get
argument_list|(
name|rs
argument_list|)
decl_stmt|;
if|if
condition|(
name|sjInfo
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|TableScanOperator
name|ts
init|=
name|sjInfo
operator|.
name|getTsOp
argument_list|()
decl_stmt|;
if|if
condition|(
name|ts
operator|!=
name|bigTableTS
condition|)
block|{
comment|// skip, not the one we are looking for.
continue|continue;
block|}
name|parallelEdges
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|sjInfo
operator|.
name|getIsHint
argument_list|()
operator|||
operator|!
name|sjInfo
operator|.
name|getShouldRemove
argument_list|()
condition|)
block|{
comment|// Created by hint, skip it
continue|continue;
block|}
comment|// Add the semijoin branch to the map
name|semijoins
operator|.
name|put
argument_list|(
name|rs
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|parallelEdges
return|;
block|}
comment|/*    * Given an operator this method removes all semi join edges downstream (children) until it hits RS    */
specifier|private
name|void
name|removeSemiJoinEdges
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
parameter_list|,
name|OptimizeTezProcContext
name|procCtx
parameter_list|,
name|Map
argument_list|<
name|ReduceSinkOperator
argument_list|,
name|TableScanOperator
argument_list|>
name|sjToRemove
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|op
operator|instanceof
name|ReduceSinkOperator
operator|&&
name|op
operator|.
name|getNumChild
argument_list|()
operator|==
literal|0
condition|)
block|{
name|Map
argument_list|<
name|ReduceSinkOperator
argument_list|,
name|SemiJoinBranchInfo
argument_list|>
name|sjMap
init|=
name|procCtx
operator|.
name|parseContext
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|sjMap
operator|.
name|get
argument_list|(
name|op
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|sjToRemove
operator|.
name|put
argument_list|(
operator|(
name|ReduceSinkOperator
operator|)
name|op
argument_list|,
name|sjMap
operator|.
name|get
argument_list|(
name|op
argument_list|)
operator|.
name|getTsOp
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|child
range|:
name|op
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|removeSemiJoinEdges
argument_list|(
name|child
argument_list|,
name|procCtx
argument_list|,
name|sjToRemove
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|removeSemiJoinEdgesForUnion
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Get all the TS ops.
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|topOps
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|topOps
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|unionOps
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|ReduceSinkOperator
argument_list|,
name|TableScanOperator
argument_list|>
name|sjToRemove
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
range|:
name|topOps
control|)
block|{
name|Deque
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|deque
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|deque
operator|.
name|add
argument_list|(
name|parent
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|deque
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|op
init|=
name|deque
operator|.
name|pollLast
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|instanceof
name|UnionOperator
operator|&&
operator|!
name|unionOps
operator|.
name|contains
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|unionOps
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|removeSemiJoinEdges
argument_list|(
name|op
argument_list|,
name|procCtx
argument_list|,
name|sjToRemove
argument_list|)
expr_stmt|;
block|}
name|deque
operator|.
name|addAll
argument_list|(
name|op
operator|.
name|getChildOperators
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// remove sj
if|if
condition|(
name|sjToRemove
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ReduceSinkOperator
argument_list|,
name|TableScanOperator
argument_list|>
name|entry
range|:
name|sjToRemove
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Semijoin optimization with Union operator. Removing semijoin "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|+
literal|" - "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|sjToRemove
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|GenTezUtils
operator|.
name|removeBranch
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*    *  The algorithm looks at all the mapjoins in the operator pipeline until    *  it hits RS Op and for each mapjoin examines if it has paralllel semijoin    *  edge or dynamic partition pruning.    */
specifier|private
name|void
name|removeSemijoinsParallelToMapJoin
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVECONVERTJOIN
argument_list|)
operator|||
name|procCtx
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_DYNAMIC_SEMIJOIN_REDUCTION_FOR_MAPJOIN
argument_list|)
condition|)
block|{
comment|// Not needed without semi-join reduction or mapjoins or when semijoins
comment|// are enabled for parallel mapjoins.
return|return;
block|}
comment|// Get all the TS ops.
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|topOps
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|topOps
operator|.
name|addAll
argument_list|(
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|ReduceSinkOperator
argument_list|,
name|TableScanOperator
argument_list|>
name|semijoins
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
range|:
name|topOps
control|)
block|{
comment|// A TS can have multiple branches due to DPP Or Semijoin Opt.
comment|// USe DFS to traverse all the branches until RS is hit.
name|Deque
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|deque
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|deque
operator|.
name|add
argument_list|(
name|parent
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|deque
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|op
init|=
name|deque
operator|.
name|pollLast
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
comment|// Done with this branch
continue|continue;
block|}
if|if
condition|(
name|op
operator|instanceof
name|MapJoinOperator
condition|)
block|{
comment|// A candidate.
if|if
condition|(
operator|!
name|findParallelSemiJoinBranch
argument_list|(
name|op
argument_list|,
operator|(
name|TableScanOperator
operator|)
name|parent
argument_list|,
name|procCtx
operator|.
name|parseContext
argument_list|,
name|semijoins
argument_list|)
condition|)
block|{
comment|// No parallel edge was found for the given mapjoin op,
comment|// no need to go down further, skip this TS operator pipeline.
break|break;
block|}
block|}
name|deque
operator|.
name|addAll
argument_list|(
name|op
operator|.
name|getChildOperators
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|semijoins
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|ReduceSinkOperator
name|rs
range|:
name|semijoins
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Semijoin optimization with parallel edge to map join. Removing semijoin "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|rs
argument_list|)
operator|+
literal|" - "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|semijoins
operator|.
name|get
argument_list|(
name|rs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|GenTezUtils
operator|.
name|removeBranch
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|,
name|rs
argument_list|,
name|semijoins
operator|.
name|get
argument_list|(
name|rs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
name|boolean
name|canUseNDV
parameter_list|(
name|ColStatistics
name|colStats
parameter_list|)
block|{
return|return
operator|(
name|colStats
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|colStats
operator|.
name|getCountDistint
argument_list|()
operator|>=
literal|0
operator|)
return|;
block|}
specifier|private
specifier|static
name|double
name|getBloomFilterCost
parameter_list|(
name|SelectOperator
name|sel
parameter_list|)
block|{
name|double
name|cost
init|=
operator|-
literal|1
decl_stmt|;
name|Statistics
name|selStats
init|=
name|sel
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
if|if
condition|(
name|selStats
operator|!=
literal|null
condition|)
block|{
name|cost
operator|=
name|selStats
operator|.
name|getNumRows
argument_list|()
expr_stmt|;
comment|// Some other things that could be added here to model cost:
comment|// Cost of computing/sending partial BloomFilter results? BloomFilterSize * # mappers
comment|// For reduce-side join, add the cost of the semijoin table scan/dependent tablescans?
block|}
return|return
name|cost
return|;
block|}
specifier|private
specifier|static
name|long
name|getCombinedKeyDomainCardinality
parameter_list|(
name|ColStatistics
name|selColStat
parameter_list|,
name|ColStatistics
name|selColSourceStat
parameter_list|,
name|ColStatistics
name|tsColStat
parameter_list|)
block|{
name|long
name|keyDomainCardinality
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|canUseNDV
argument_list|(
name|selColStat
argument_list|)
operator|||
operator|!
name|canUseNDV
argument_list|(
name|tsColStat
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|long
name|selColSourceNdv
init|=
name|canUseNDV
argument_list|(
name|selColSourceStat
argument_list|)
condition|?
name|selColSourceStat
operator|.
name|getCountDistint
argument_list|()
else|:
operator|-
literal|1
decl_stmt|;
name|boolean
name|semiJoinKeyIsPK
init|=
name|StatsUtils
operator|.
name|inferForeignKey
argument_list|(
name|selColStat
argument_list|,
name|tsColStat
argument_list|)
decl_stmt|;
if|if
condition|(
name|semiJoinKeyIsPK
condition|)
block|{
comment|// PK/FQ relationship: NDV of selColSourceStat is a superset of what is in tsColStat
if|if
condition|(
name|selColSourceNdv
operator|>=
literal|0
condition|)
block|{
comment|// Most accurate domain cardinality would be source column NDV if available.
name|keyDomainCardinality
operator|=
name|selColSourceNdv
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|selColSourceNdv
operator|>=
literal|0
condition|)
block|{
comment|// If semijoin keys and ts keys completely unrelated, the cardinality of both sets
comment|// could be obtained by adding both cardinalities. Would there be an average case?
name|keyDomainCardinality
operator|=
name|selColSourceNdv
operator|+
name|tsColStat
operator|.
name|getCountDistint
argument_list|()
expr_stmt|;
comment|// Don't exceed the range if we have one.
if|if
condition|(
name|StatsUtils
operator|.
name|hasDiscreteRange
argument_list|(
name|selColStat
argument_list|)
operator|&&
name|StatsUtils
operator|.
name|hasDiscreteRange
argument_list|(
name|tsColStat
argument_list|)
condition|)
block|{
name|long
name|range
init|=
literal|0
decl_stmt|;
comment|// Trying using the cardinality from the value range.
name|ColStatistics
operator|.
name|Range
name|combinedRange
init|=
name|StatsUtils
operator|.
name|combineRange
argument_list|(
name|selColStat
operator|.
name|getRange
argument_list|()
argument_list|,
name|tsColStat
operator|.
name|getRange
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|combinedRange
operator|!=
literal|null
condition|)
block|{
name|range
operator|=
name|StatsUtils
operator|.
name|getRangeDelta
argument_list|(
name|combinedRange
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|range
operator|=
name|StatsUtils
operator|.
name|getRangeDelta
argument_list|(
name|selColStat
operator|.
name|getRange
argument_list|()
argument_list|)
operator|+
name|StatsUtils
operator|.
name|getRangeDelta
argument_list|(
name|tsColStat
operator|.
name|getRange
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|keyDomainCardinality
operator|=
name|Math
operator|.
name|min
argument_list|(
name|keyDomainCardinality
argument_list|,
name|range
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Otherwise, we tried ..
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Computing key domain cardinality, keyDomainCardinality="
operator|+
name|keyDomainCardinality
operator|+
literal|", semiJoinKeyIsPK="
operator|+
name|semiJoinKeyIsPK
operator|+
literal|", selColStat="
operator|+
name|selColStat
operator|+
literal|", selColSourceStat="
operator|+
name|selColSourceStat
operator|+
literal|", tsColStat="
operator|+
name|tsColStat
argument_list|)
expr_stmt|;
block|}
return|return
name|keyDomainCardinality
return|;
block|}
specifier|private
specifier|static
name|double
name|getBloomFilterBenefit
parameter_list|(
name|SelectOperator
name|sel
parameter_list|,
name|ExprNodeDesc
name|selExpr
parameter_list|,
name|Statistics
name|filStats
parameter_list|,
name|ExprNodeDesc
name|tsExpr
parameter_list|)
block|{
name|double
name|benefit
init|=
operator|-
literal|1
decl_stmt|;
name|Statistics
name|selStats
init|=
name|sel
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
if|if
condition|(
name|selStats
operator|==
literal|null
operator|||
name|filStats
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No stats available to compute BloomFilter benefit"
argument_list|)
expr_stmt|;
return|return
name|benefit
return|;
block|}
comment|// For cardinality values use numRows as default, try to use ColStats if available
name|long
name|selKeyCardinality
init|=
name|selStats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
name|long
name|tsKeyCardinality
init|=
name|filStats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
name|long
name|tsRows
init|=
name|filStats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
name|long
name|tsRowSize
init|=
name|filStats
operator|.
name|getAvgRowSize
argument_list|()
decl_stmt|;
name|long
name|keyDomainCardinality
init|=
name|selKeyCardinality
operator|+
name|tsKeyCardinality
decl_stmt|;
name|ExprNodeColumnDesc
name|selCol
init|=
name|ExprNodeDescUtils
operator|.
name|getColumnExpr
argument_list|(
name|selExpr
argument_list|)
decl_stmt|;
name|ExprNodeColumnDesc
name|tsCol
init|=
name|ExprNodeDescUtils
operator|.
name|getColumnExpr
argument_list|(
name|tsExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|selCol
operator|!=
literal|null
operator|&&
name|tsCol
operator|!=
literal|null
condition|)
block|{
comment|// Check if there are column stats available for these columns
name|ColStatistics
name|selColStat
init|=
name|selStats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|selCol
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|ColStatistics
name|filColStat
init|=
name|filStats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|tsCol
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|canUseNDV
argument_list|(
name|selColStat
argument_list|)
condition|)
block|{
name|selKeyCardinality
operator|=
name|selColStat
operator|.
name|getCountDistint
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|canUseNDV
argument_list|(
name|filColStat
argument_list|)
condition|)
block|{
name|tsKeyCardinality
operator|=
name|filColStat
operator|.
name|getCountDistint
argument_list|()
expr_stmt|;
block|}
comment|// Get colstats for the original table column for selCol if possible, this would have
comment|// more accurate information about the original NDV of the column before any filtering.
name|ColStatistics
name|selColSourceStat
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|selColStat
operator|!=
literal|null
condition|)
block|{
name|ExprNodeDescUtils
operator|.
name|ColumnOrigin
name|selColSource
init|=
name|ExprNodeDescUtils
operator|.
name|findColumnOrigin
argument_list|(
name|selCol
argument_list|,
name|sel
argument_list|)
decl_stmt|;
if|if
condition|(
name|selColSource
operator|!=
literal|null
operator|&&
name|selColSource
operator|.
name|op
operator|.
name|getStatistics
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|selColSourceStat
operator|=
name|selColSource
operator|.
name|op
operator|.
name|getStatistics
argument_list|()
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|selColSource
operator|.
name|col
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|domainCardinalityFromColStats
init|=
name|getCombinedKeyDomainCardinality
argument_list|(
name|selColStat
argument_list|,
name|selColSourceStat
argument_list|,
name|filColStat
argument_list|)
decl_stmt|;
if|if
condition|(
name|domainCardinalityFromColStats
operator|>=
literal|0
condition|)
block|{
name|keyDomainCardinality
operator|=
name|domainCardinalityFromColStats
expr_stmt|;
block|}
block|}
comment|// Selectivity: key cardinality of semijoin / domain cardinality
comment|// Benefit (rows filtered from ts): (1 - selectivity) * # ts rows
name|double
name|selectivity
init|=
name|selKeyCardinality
operator|/
operator|(
name|double
operator|)
name|keyDomainCardinality
decl_stmt|;
name|selectivity
operator|=
name|Math
operator|.
name|min
argument_list|(
name|selectivity
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|benefit
operator|=
name|tsRows
operator|*
operator|(
literal|1
operator|-
name|selectivity
operator|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"BloomFilter benefit for "
operator|+
name|selCol
operator|+
literal|" to "
operator|+
name|tsCol
operator|+
literal|", selKeyCardinality="
operator|+
name|selKeyCardinality
operator|+
literal|", tsKeyCardinality="
operator|+
name|tsKeyCardinality
operator|+
literal|", tsRows="
operator|+
name|tsRows
operator|+
literal|", keyDomainCardinality="
operator|+
name|keyDomainCardinality
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"SemiJoin key selectivity="
operator|+
name|selectivity
operator|+
literal|", benefit="
operator|+
name|benefit
argument_list|)
expr_stmt|;
block|}
return|return
name|benefit
return|;
block|}
specifier|private
specifier|static
name|double
name|computeBloomFilterNetBenefit
parameter_list|(
name|SelectOperator
name|sel
parameter_list|,
name|ExprNodeDesc
name|selExpr
parameter_list|,
name|Statistics
name|filStats
parameter_list|,
name|ExprNodeDesc
name|tsExpr
parameter_list|)
block|{
name|double
name|netBenefit
init|=
operator|-
literal|1
decl_stmt|;
name|double
name|benefit
init|=
name|getBloomFilterBenefit
argument_list|(
name|sel
argument_list|,
name|selExpr
argument_list|,
name|filStats
argument_list|,
name|tsExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|benefit
operator|>
literal|0
operator|&&
name|filStats
operator|!=
literal|null
condition|)
block|{
name|double
name|cost
init|=
name|getBloomFilterCost
argument_list|(
name|sel
argument_list|)
decl_stmt|;
if|if
condition|(
name|cost
operator|>
literal|0
condition|)
block|{
name|long
name|filDataSize
init|=
name|filStats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
name|netBenefit
operator|=
operator|(
name|benefit
operator|-
name|cost
operator|)
operator|/
name|filDataSize
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"BloomFilter benefit="
operator|+
name|benefit
operator|+
literal|", cost="
operator|+
name|cost
operator|+
literal|", tsDataSize="
operator|+
name|filDataSize
operator|+
literal|", netBenefit="
operator|+
operator|(
name|benefit
operator|-
name|cost
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"netBenefit="
operator|+
name|netBenefit
argument_list|)
expr_stmt|;
return|return
name|netBenefit
return|;
block|}
specifier|private
name|void
name|removeSemijoinOptimizationByBenefit
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Map
argument_list|<
name|ReduceSinkOperator
argument_list|,
name|SemiJoinBranchInfo
argument_list|>
name|map
init|=
name|procCtx
operator|.
name|parseContext
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|map
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Nothing to do
return|return;
block|}
comment|// Scale down stats for tables with DPP
name|Map
argument_list|<
name|FilterOperator
argument_list|,
name|Statistics
argument_list|>
name|adjustedStatsMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ReduceSinkOperator
argument_list|>
name|semijoinRsToRemove
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|double
name|semijoinReductionThreshold
init|=
name|procCtx
operator|.
name|conf
operator|.
name|getFloatVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|TEZ_DYNAMIC_SEMIJOIN_REDUCTION_THRESHOLD
argument_list|)
decl_stmt|;
comment|// Using SortedSet to make iteration order deterministic
specifier|final
name|Comparator
argument_list|<
name|ReduceSinkOperator
argument_list|>
name|rsOpComp
init|=
parameter_list|(
name|ReduceSinkOperator
name|o1
parameter_list|,
name|ReduceSinkOperator
name|o2
parameter_list|)
lambda|->
operator|(
name|o1
operator|.
name|toString
argument_list|()
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|toString
argument_list|()
argument_list|)
operator|)
decl_stmt|;
name|SortedSet
argument_list|<
name|ReduceSinkOperator
argument_list|>
name|semiJoinRsOps
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|rsOpComp
argument_list|)
decl_stmt|;
name|semiJoinRsOps
operator|.
name|addAll
argument_list|(
name|map
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|semiJoinRsOps
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// We will gather the SJs to keep in the plan in the following map
name|Map
argument_list|<
name|FilterOperator
argument_list|,
name|SemijoinOperatorInfo
argument_list|>
name|reductionFactorMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|SortedSet
argument_list|<
name|ReduceSinkOperator
argument_list|>
name|semiJoinRsOpsNewIter
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|rsOpComp
argument_list|)
decl_stmt|;
for|for
control|(
name|ReduceSinkOperator
name|rs
range|:
name|semiJoinRsOps
control|)
block|{
name|SemiJoinBranchInfo
name|sjInfo
init|=
name|map
operator|.
name|get
argument_list|(
name|rs
argument_list|)
decl_stmt|;
if|if
condition|(
name|sjInfo
operator|.
name|getIsHint
argument_list|()
operator|||
operator|!
name|sjInfo
operator|.
name|getShouldRemove
argument_list|()
condition|)
block|{
comment|// Semijoin created using hint or marked useful, skip it
continue|continue;
block|}
comment|// rs is semijoin optimization branch, which should look like<Parent>-SEL-GB1-RS1-GB2-RS2
comment|// Get to the SelectOperator ancestor
name|SelectOperator
name|sel
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|currOp
init|=
name|rs
init|;
name|currOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|;
name|currOp
operator|=
name|currOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
control|)
block|{
if|if
condition|(
name|currOp
operator|instanceof
name|SelectOperator
condition|)
block|{
name|sel
operator|=
operator|(
name|SelectOperator
operator|)
name|currOp
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sel
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unexpected error - could not find SEL ancestor from semijoin branch of "
operator|+
name|rs
argument_list|)
throw|;
block|}
comment|// Check the ndv/rows from the SEL vs the destination tablescan the semijoin opt is going to.
name|TableScanOperator
name|ts
init|=
name|sjInfo
operator|.
name|getTsOp
argument_list|()
decl_stmt|;
name|RuntimeValuesInfo
name|rti
init|=
name|procCtx
operator|.
name|parseContext
operator|.
name|getRsToRuntimeValuesInfoMap
argument_list|()
operator|.
name|get
argument_list|(
name|rs
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|tsExpr
init|=
name|rti
operator|.
name|getTsColExpr
argument_list|()
decl_stmt|;
comment|// In the SEL operator of the semijoin branch, there should be only one column in the operator
name|ExprNodeDesc
name|selExpr
init|=
name|sel
operator|.
name|getConf
argument_list|()
operator|.
name|getColList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Computing BloomFilter cost/benefit for "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|rs
argument_list|)
operator|+
literal|" - "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|ts
argument_list|)
operator|+
literal|" ("
operator|+
name|tsExpr
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
name|FilterOperator
name|filterOperator
init|=
operator|(
name|FilterOperator
operator|)
name|ts
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Statistics
name|filterStats
init|=
name|adjustedStatsMap
operator|.
name|get
argument_list|(
name|filterOperator
argument_list|)
decl_stmt|;
if|if
condition|(
name|filterStats
operator|==
literal|null
operator|&&
name|filterOperator
operator|.
name|getStatistics
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|filterStats
operator|=
name|filterOperator
operator|.
name|getStatistics
argument_list|()
operator|.
name|clone
argument_list|()
expr_stmt|;
name|adjustedStatsMap
operator|.
name|put
argument_list|(
name|filterOperator
argument_list|,
name|filterStats
argument_list|)
expr_stmt|;
block|}
name|double
name|reductionFactor
init|=
name|computeBloomFilterNetBenefit
argument_list|(
name|sel
argument_list|,
name|selExpr
argument_list|,
name|filterStats
argument_list|,
name|tsExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|reductionFactor
operator|<
name|semijoinReductionThreshold
condition|)
block|{
comment|// This semijoin optimization should be removed. Do it after we're done iterating
name|semijoinRsToRemove
operator|.
name|add
argument_list|(
name|rs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// This semijoin qualifies, add it to the result set
if|if
condition|(
name|filterStats
operator|!=
literal|null
condition|)
block|{
name|String
name|colName
init|=
name|ExprNodeDescUtils
operator|.
name|getColumnExpr
argument_list|(
name|tsExpr
argument_list|)
operator|.
name|getColumn
argument_list|()
decl_stmt|;
comment|// We check whether there was already another SJ over this TS that was selected
comment|// in previous iteration
name|SemijoinOperatorInfo
name|prevResult
init|=
name|reductionFactorMap
operator|.
name|get
argument_list|(
name|filterOperator
argument_list|)
decl_stmt|;
if|if
condition|(
name|prevResult
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|prevResult
operator|.
name|reductionFactor
operator|<
name|reductionFactor
condition|)
block|{
comment|// We should pick up new SJ as its reduction factor is greater than the previous one
comment|// that we found. We add the previous RS where SJ was originating to RS ops for new
comment|// iteration
name|reductionFactorMap
operator|.
name|put
argument_list|(
name|filterOperator
argument_list|,
operator|new
name|SemijoinOperatorInfo
argument_list|(
name|rs
argument_list|,
name|filterOperator
argument_list|,
name|filterStats
argument_list|,
name|colName
argument_list|,
name|reductionFactor
argument_list|)
argument_list|)
expr_stmt|;
name|semiJoinRsOpsNewIter
operator|.
name|add
argument_list|(
name|prevResult
operator|.
name|rsOperator
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|prevResult
operator|.
name|rsOperator
argument_list|)
operator|+
literal|" for re-iteration"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// We should pick up old SJ. We just need to add new RS where SJ was originating
comment|// to RS ops for new iteration
name|semiJoinRsOpsNewIter
operator|.
name|add
argument_list|(
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|rs
argument_list|)
operator|+
literal|" for re-iteration"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// Another SJ did not exist for this TS, hence just add it to SJs to keep
name|reductionFactorMap
operator|.
name|put
argument_list|(
name|filterOperator
argument_list|,
operator|new
name|SemijoinOperatorInfo
argument_list|(
name|rs
argument_list|,
name|filterOperator
argument_list|,
name|filterStats
argument_list|,
name|colName
argument_list|,
name|reductionFactor
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
for|for
control|(
name|SemijoinOperatorInfo
name|roi
range|:
name|reductionFactorMap
operator|.
name|values
argument_list|()
control|)
block|{
comment|// This semijoin will be kept
comment|// We are going to adjust the filter statistics
name|long
name|newNumRows
init|=
call|(
name|long
call|)
argument_list|(
literal|1.0
operator|-
name|roi
operator|.
name|reductionFactor
argument_list|)
operator|*
name|roi
operator|.
name|filterStats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Old stats for {}: {}"
argument_list|,
name|roi
operator|.
name|filterOperator
argument_list|,
name|roi
operator|.
name|filterStats
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Number of rows reduction: {}/{}"
argument_list|,
name|newNumRows
argument_list|,
name|roi
operator|.
name|filterStats
operator|.
name|getNumRows
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|StatsUtils
operator|.
name|updateStats
argument_list|(
name|roi
operator|.
name|filterStats
argument_list|,
name|newNumRows
argument_list|,
literal|true
argument_list|,
name|roi
operator|.
name|filterOperator
argument_list|,
name|Sets
operator|.
name|newHashSet
argument_list|(
name|roi
operator|.
name|colName
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"New stats for {}: {}"
argument_list|,
name|roi
operator|.
name|filterOperator
argument_list|,
name|roi
operator|.
name|filterStats
argument_list|)
expr_stmt|;
block|}
name|adjustedStatsMap
operator|.
name|put
argument_list|(
name|roi
operator|.
name|filterOperator
argument_list|,
name|roi
operator|.
name|filterStats
argument_list|)
expr_stmt|;
block|}
name|semiJoinRsOps
operator|=
name|semiJoinRsOpsNewIter
expr_stmt|;
block|}
for|for
control|(
name|ReduceSinkOperator
name|rs
range|:
name|semijoinRsToRemove
control|)
block|{
name|TableScanOperator
name|ts
init|=
name|map
operator|.
name|get
argument_list|(
name|rs
argument_list|)
operator|.
name|getTsOp
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reduction factor not satisfied for "
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|rs
argument_list|)
operator|+
literal|"-"
operator|+
name|OperatorUtils
operator|.
name|getOpNamePretty
argument_list|(
name|ts
argument_list|)
operator|+
literal|". Removing semijoin optimization."
argument_list|)
expr_stmt|;
block|}
name|GenTezUtils
operator|.
name|removeBranch
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|procCtx
operator|.
name|parseContext
argument_list|,
name|rs
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Internal class to encapsulate information needed to evaluate stats    * about a SJ that will be kept in the tree.    */
specifier|private
class|class
name|SemijoinOperatorInfo
block|{
specifier|final
name|ReduceSinkOperator
name|rsOperator
decl_stmt|;
specifier|final
name|FilterOperator
name|filterOperator
decl_stmt|;
specifier|final
name|String
name|colName
decl_stmt|;
specifier|final
name|Statistics
name|filterStats
decl_stmt|;
specifier|final
name|double
name|reductionFactor
decl_stmt|;
specifier|private
name|SemijoinOperatorInfo
parameter_list|(
name|ReduceSinkOperator
name|rsOperator
parameter_list|,
name|FilterOperator
name|filterOperator
parameter_list|,
name|Statistics
name|filterStats
parameter_list|,
name|String
name|colName
parameter_list|,
name|double
name|reductionFactor
parameter_list|)
block|{
name|this
operator|.
name|rsOperator
operator|=
name|rsOperator
expr_stmt|;
name|this
operator|.
name|filterOperator
operator|=
name|filterOperator
expr_stmt|;
name|this
operator|.
name|colName
operator|=
name|colName
expr_stmt|;
name|this
operator|.
name|filterStats
operator|=
name|filterStats
expr_stmt|;
name|this
operator|.
name|reductionFactor
operator|=
name|reductionFactor
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|markSemiJoinForDPP
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Stores the Tablescan operators processed to avoid redoing them.
name|Map
argument_list|<
name|ReduceSinkOperator
argument_list|,
name|SemiJoinBranchInfo
argument_list|>
name|map
init|=
name|procCtx
operator|.
name|parseContext
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
decl_stmt|;
for|for
control|(
name|ReduceSinkOperator
name|rs
range|:
name|map
operator|.
name|keySet
argument_list|()
control|)
block|{
name|SemiJoinBranchInfo
name|sjInfo
init|=
name|map
operator|.
name|get
argument_list|(
name|rs
argument_list|)
decl_stmt|;
name|TableScanOperator
name|ts
init|=
name|sjInfo
operator|.
name|getTsOp
argument_list|()
decl_stmt|;
if|if
condition|(
name|sjInfo
operator|.
name|getIsHint
argument_list|()
operator|||
operator|!
name|sjInfo
operator|.
name|getShouldRemove
argument_list|()
condition|)
block|{
continue|continue;
block|}
comment|// A TS can have multiple branches due to DPP Or Semijoin Opt.
comment|// Use DFS to traverse all the branches until RS or DPP is hit.
name|Deque
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|deque
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|deque
operator|.
name|add
argument_list|(
name|ts
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|deque
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|op
init|=
name|deque
operator|.
name|pollLast
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|instanceof
name|AppMasterEventOperator
operator|&&
operator|(
operator|(
name|AppMasterEventOperator
operator|)
name|op
operator|)
operator|.
name|getConf
argument_list|()
operator|instanceof
name|DynamicPruningEventDesc
condition|)
block|{
comment|// DPP. Now look up nDVs on both sides to see the selectivity.
comment|//<Parent Ops>-SEL-GB1-RS1-GB2-RS2
name|SelectOperator
name|selOp
init|=
call|(
name|SelectOperator
call|)
argument_list|(
name|rs
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
comment|// Get nDVs on Semijoin edge side
name|Statistics
name|stats
init|=
name|selOp
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
if|if
condition|(
name|stats
operator|==
literal|null
condition|)
block|{
comment|// No stats found on semijoin edge, do nothing
break|break;
block|}
name|String
name|selCol
init|=
name|ExprNodeDescUtils
operator|.
name|extractColName
argument_list|(
name|selOp
operator|.
name|getConf
argument_list|()
operator|.
name|getColList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|ColStatistics
name|colStatisticsSJ
init|=
name|stats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|selCol
argument_list|)
decl_stmt|;
if|if
condition|(
name|colStatisticsSJ
operator|==
literal|null
condition|)
block|{
comment|// No column stats found for semijoin edge
break|break;
block|}
name|long
name|nDVs
init|=
name|colStatisticsSJ
operator|.
name|getCountDistint
argument_list|()
decl_stmt|;
if|if
condition|(
name|nDVs
operator|>
literal|0
condition|)
block|{
comment|// Lookup nDVs on TS side.
name|RuntimeValuesInfo
name|rti
init|=
name|procCtx
operator|.
name|parseContext
operator|.
name|getRsToRuntimeValuesInfoMap
argument_list|()
operator|.
name|get
argument_list|(
name|rs
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|tsExpr
init|=
name|rti
operator|.
name|getTsColExpr
argument_list|()
decl_stmt|;
name|FilterOperator
name|fil
init|=
call|(
name|FilterOperator
call|)
argument_list|(
name|ts
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|Statistics
name|filStats
init|=
name|fil
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
if|if
condition|(
name|filStats
operator|==
literal|null
condition|)
block|{
comment|// No stats found on target, do nothing
break|break;
block|}
name|String
name|colName
init|=
name|ExprNodeDescUtils
operator|.
name|extractColName
argument_list|(
name|tsExpr
argument_list|)
decl_stmt|;
name|ColStatistics
name|colStatisticsTarget
init|=
name|filStats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|colName
argument_list|)
decl_stmt|;
if|if
condition|(
name|colStatisticsTarget
operator|==
literal|null
condition|)
block|{
comment|// No column stats found on target
break|break;
block|}
name|long
name|nDVsOfTS
init|=
name|colStatisticsTarget
operator|.
name|getCountDistint
argument_list|()
decl_stmt|;
name|double
name|nDVsOfTSFactored
init|=
name|nDVsOfTS
operator|*
name|procCtx
operator|.
name|conf
operator|.
name|getFloatVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_DYNAMIC_SEMIJOIN_REDUCTION_FOR_DPP_FACTOR
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|nDVsOfTSFactored
operator|>
name|nDVs
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"nDVs = "
operator|+
name|nDVs
operator|+
literal|", nDVsOfTS = "
operator|+
name|nDVsOfTS
operator|+
literal|" and nDVsOfTSFactored = "
operator|+
name|nDVsOfTSFactored
operator|+
literal|"Adding semijoin branch from ReduceSink "
operator|+
name|rs
operator|+
literal|" to TS "
operator|+
name|sjInfo
operator|.
name|getTsOp
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sjInfo
operator|.
name|setShouldRemove
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
comment|// Do nothing
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Caught NPE in markSemiJoinForDPP from ReduceSink "
operator|+
name|rs
operator|+
literal|" to TS "
operator|+
name|sjInfo
operator|.
name|getTsOp
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|op
operator|instanceof
name|TerminalOperator
condition|)
block|{
comment|// Done with this branch
continue|continue;
block|}
name|deque
operator|.
name|addAll
argument_list|(
name|op
operator|.
name|getChildOperators
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|updateBucketingVersionForUpgrade
parameter_list|(
name|OptimizeTezProcContext
name|procCtx
parameter_list|)
block|{
comment|// Fetch all the FileSinkOperators.
name|Set
argument_list|<
name|FileSinkOperator
argument_list|>
name|fsOpsAll
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|TableScanOperator
name|ts
range|:
name|procCtx
operator|.
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|Set
argument_list|<
name|FileSinkOperator
argument_list|>
name|fsOps
init|=
name|OperatorUtils
operator|.
name|findOperators
argument_list|(
name|ts
argument_list|,
name|FileSinkOperator
operator|.
name|class
argument_list|)
decl_stmt|;
name|fsOpsAll
operator|.
name|addAll
argument_list|(
name|fsOps
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|FileSinkOperator
name|fsOp
range|:
name|fsOpsAll
control|)
block|{
if|if
condition|(
operator|!
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getTableInfo
argument_list|()
operator|.
name|isSetBucketingVersion
argument_list|()
condition|)
block|{
continue|continue;
block|}
comment|// Look for direct parent ReduceSinkOp
comment|// If there are more than 1 parent, bail out.
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
init|=
name|fsOp
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|parentOps
init|=
name|parent
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
while|while
condition|(
name|parentOps
operator|!=
literal|null
operator|&&
name|parentOps
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|parent
operator|=
name|parentOps
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|parent
operator|instanceof
name|ReduceSinkOperator
operator|)
condition|)
block|{
name|parentOps
operator|=
name|parent
operator|.
name|getParentOperators
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|// Found the target RSOp
name|parent
operator|.
name|setBucketingVersion
argument_list|(
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getTableInfo
argument_list|()
operator|.
name|getBucketingVersion
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_class

end_unit

