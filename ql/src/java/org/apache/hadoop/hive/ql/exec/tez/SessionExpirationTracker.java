begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|tez
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|PriorityBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
class|class
name|SessionExpirationTracker
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SessionExpirationTracker
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Random
name|rdm
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
comment|/** Priority queue sorted by expiration time of live sessions that could be expired. */
specifier|private
specifier|final
name|PriorityBlockingQueue
argument_list|<
name|TezSessionPoolSession
argument_list|>
name|expirationQueue
decl_stmt|;
comment|/** The background restart queue that is populated when expiration is triggered by a foreground    * thread (i.e. getting or returning a session), to avoid delaying it. */
specifier|private
specifier|final
name|BlockingQueue
argument_list|<
name|TezSessionPoolSession
argument_list|>
name|restartQueue
decl_stmt|;
specifier|private
specifier|final
name|Thread
name|expirationThread
decl_stmt|;
specifier|private
specifier|final
name|Thread
name|restartThread
decl_stmt|;
specifier|private
specifier|final
name|long
name|sessionLifetimeMs
decl_stmt|;
specifier|private
specifier|final
name|long
name|sessionLifetimeJitterMs
decl_stmt|;
specifier|private
specifier|final
name|RestartImpl
name|sessionRestartImpl
decl_stmt|;
specifier|private
specifier|volatile
name|SessionState
name|initSessionState
decl_stmt|;
interface|interface
name|RestartImpl
block|{
name|void
name|closeAndReopenPoolSession
parameter_list|(
name|TezSessionPoolSession
name|session
parameter_list|)
throws|throws
name|Exception
function_decl|;
block|}
specifier|public
specifier|static
name|SessionExpirationTracker
name|create
parameter_list|(
name|HiveConf
name|conf
parameter_list|,
name|RestartImpl
name|restartImpl
parameter_list|)
block|{
name|long
name|sessionLifetimeMs
init|=
name|conf
operator|.
name|getTimeVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_SERVER2_TEZ_SESSION_LIFETIME
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
if|if
condition|(
name|sessionLifetimeMs
operator|==
literal|0
condition|)
return|return
literal|null
return|;
return|return
operator|new
name|SessionExpirationTracker
argument_list|(
name|sessionLifetimeMs
argument_list|,
name|conf
operator|.
name|getTimeVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_SERVER2_TEZ_SESSION_LIFETIME_JITTER
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
argument_list|,
name|restartImpl
argument_list|)
return|;
block|}
specifier|private
name|SessionExpirationTracker
parameter_list|(
name|long
name|sessionLifetimeMs
parameter_list|,
name|long
name|sessionLifetimeJitterMs
parameter_list|,
name|RestartImpl
name|restartImpl
parameter_list|)
block|{
name|this
operator|.
name|sessionRestartImpl
operator|=
name|restartImpl
expr_stmt|;
name|this
operator|.
name|sessionLifetimeMs
operator|=
name|sessionLifetimeMs
expr_stmt|;
name|this
operator|.
name|sessionLifetimeJitterMs
operator|=
name|sessionLifetimeJitterMs
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Session expiration is enabled; session lifetime is "
operator|+
name|sessionLifetimeMs
operator|+
literal|" + [0, "
operator|+
name|sessionLifetimeJitterMs
operator|+
literal|") ms"
argument_list|)
expr_stmt|;
block|}
name|expirationQueue
operator|=
operator|new
name|PriorityBlockingQueue
argument_list|<>
argument_list|(
literal|11
argument_list|,
operator|new
name|Comparator
argument_list|<
name|TezSessionPoolSession
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|TezSessionPoolSession
name|o1
parameter_list|,
name|TezSessionPoolSession
name|o2
parameter_list|)
block|{
assert|assert
name|o1
operator|.
name|getExpirationNs
argument_list|()
operator|!=
literal|null
operator|&&
name|o2
operator|.
name|getExpirationNs
argument_list|()
operator|!=
literal|null
assert|;
return|return
name|o1
operator|.
name|getExpirationNs
argument_list|()
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|getExpirationNs
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|restartQueue
operator|=
operator|new
name|LinkedBlockingQueue
argument_list|<>
argument_list|()
expr_stmt|;
name|expirationThread
operator|=
operator|new
name|Thread
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|SessionState
operator|.
name|setCurrentSessionState
argument_list|(
name|initSessionState
argument_list|)
expr_stmt|;
name|runExpirationThread
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception in TezSessionPool-expiration thread. Thread will shut down"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"TezSessionPool-expiration thread exiting"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|,
literal|"TezSessionPool-expiration"
argument_list|)
expr_stmt|;
name|restartThread
operator|=
operator|new
name|Thread
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|SessionState
operator|.
name|setCurrentSessionState
argument_list|(
name|initSessionState
argument_list|)
expr_stmt|;
name|runRestartThread
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception in TezSessionPool-cleanup thread. Thread will shut down"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"TezSessionPool-cleanup thread exiting"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|,
literal|"TezSessionPool-cleanup"
argument_list|)
expr_stmt|;
block|}
comment|/** Logic for the thread that restarts the sessions expired during foreground operations. */
specifier|private
name|void
name|runRestartThread
parameter_list|()
block|{
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|TezSessionPoolSession
name|next
init|=
name|restartQueue
operator|.
name|take
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Restarting the expired session ["
operator|+
name|next
operator|+
literal|"]"
argument_list|)
expr_stmt|;
try|try
block|{
name|sessionRestartImpl
operator|.
name|closeAndReopenPoolSession
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
name|ie
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to close or restart a session, ignoring"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Restart thread is exiting due to an interruption"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Logic for the thread that tracks session expiration and restarts sessions in background. */
specifier|private
name|void
name|runExpirationThread
parameter_list|()
block|{
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|TezSessionPoolSession
name|nextToExpire
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// Restart the sessions until one of them refuses to restart.
name|nextToExpire
operator|=
name|expirationQueue
operator|.
name|take
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Seeing if we can expire ["
operator|+
name|nextToExpire
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
operator|!
name|nextToExpire
operator|.
name|tryExpire
argument_list|(
literal|false
argument_list|)
condition|)
break|break;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// Reopen happens even when close fails, so there's not much to do here.
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to expire session "
operator|+
name|nextToExpire
operator|+
literal|"; ignoring"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|nextToExpire
operator|=
literal|null
expr_stmt|;
break|break;
comment|// Not strictly necessary; do the whole queue check again.
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Tez session ["
operator|+
name|nextToExpire
operator|+
literal|"] has expired"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nextToExpire
operator|!=
literal|null
operator|&&
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"["
operator|+
name|nextToExpire
operator|+
literal|"] is not ready to expire; adding it back"
argument_list|)
expr_stmt|;
block|}
comment|// See addToExpirationQueue for why we re-check the queue.
synchronized|synchronized
init|(
name|expirationQueue
init|)
block|{
comment|// Add back the non-expired session. No need to notify, we are the only ones waiting.
if|if
condition|(
name|nextToExpire
operator|!=
literal|null
condition|)
block|{
name|expirationQueue
operator|.
name|add
argument_list|(
name|nextToExpire
argument_list|)
expr_stmt|;
block|}
name|nextToExpire
operator|=
name|expirationQueue
operator|.
name|peek
argument_list|()
expr_stmt|;
if|if
condition|(
name|nextToExpire
operator|!=
literal|null
condition|)
block|{
comment|// Add some margin to the wait to avoid rechecking close to the boundary.
name|long
name|timeToWaitMs
init|=
operator|(
name|nextToExpire
operator|.
name|getExpirationNs
argument_list|()
operator|-
name|System
operator|.
name|nanoTime
argument_list|()
operator|)
operator|/
literal|1000000L
decl_stmt|;
name|timeToWaitMs
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|timeToWaitMs
operator|+
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting for ~"
operator|+
name|timeToWaitMs
operator|+
literal|"ms to expire ["
operator|+
name|nextToExpire
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
name|expirationQueue
operator|.
name|wait
argument_list|(
name|timeToWaitMs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
comment|// Don't wait if empty - go to take() above, that will wait for us.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Expiration queue is empty"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Expiration thread is exiting due to an interruption"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|start
parameter_list|()
block|{
name|initSessionState
operator|=
name|SessionState
operator|.
name|get
argument_list|()
expr_stmt|;
name|expirationThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|restartThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|stop
parameter_list|()
block|{
if|if
condition|(
name|expirationThread
operator|!=
literal|null
condition|)
block|{
name|expirationThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|restartThread
operator|!=
literal|null
condition|)
block|{
name|restartThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|addToExpirationQueue
parameter_list|(
name|TezSessionPoolSession
name|session
parameter_list|)
block|{
name|long
name|jitterModMs
init|=
call|(
name|long
call|)
argument_list|(
name|sessionLifetimeJitterMs
operator|*
name|rdm
operator|.
name|nextFloat
argument_list|()
argument_list|)
decl_stmt|;
name|session
operator|.
name|setExpirationNs
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
operator|(
name|sessionLifetimeMs
operator|+
name|jitterModMs
operator|)
operator|*
literal|1000000L
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding a pool session ["
operator|+
name|this
operator|+
literal|"] to expiration queue"
argument_list|)
expr_stmt|;
block|}
comment|// Expiration queue is synchronized and notified upon when adding elements. Without jitter, we
comment|// wouldn't need this, and could simple look at the first element and sleep for the wait time.
comment|// However, when many things are added at once, it may happen that we will see the one that
comment|// expires later first, and will sleep past the earlier expiration times. When we wake up we
comment|// may kill many sessions at once. To avoid this, we will add to queue under lock and recheck
comment|// time before we wait. We don't have to worry about removals; at worst we'd wake up in vain.
comment|// Example: expirations of 1:03:00, 1:00:00, 1:02:00 are added (in this order due to jitter).
comment|// If the expiration threads sees that 1:03 first, it will sleep for 1:03, then wake up and
comment|// kill all 3 sessions at once because they all have expired, removing any effect from jitter.
comment|// Instead, expiration thread rechecks the first queue item and waits on the queue. If nothing
comment|// is added to the queue, the item examined is still the earliest to be expired. If someone
comment|// adds to the queue while it is waiting, it will notify the thread and it would wake up and
comment|// recheck the queue.
synchronized|synchronized
init|(
name|expirationQueue
init|)
block|{
name|expirationQueue
operator|.
name|add
argument_list|(
name|session
argument_list|)
expr_stmt|;
name|expirationQueue
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|removeFromExpirationQueue
parameter_list|(
name|TezSessionPoolSession
name|session
parameter_list|)
block|{
name|expirationQueue
operator|.
name|remove
argument_list|(
name|session
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|closeAndRestartExpiredSession
parameter_list|(
name|TezSessionPoolSession
name|session
parameter_list|,
name|boolean
name|isAsync
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|isAsync
condition|)
block|{
name|restartQueue
operator|.
name|add
argument_list|(
name|session
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sessionRestartImpl
operator|.
name|closeAndReopenPoolSession
argument_list|(
name|session
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

