begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
operator|.
name|InputFinder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
operator|.
name|InputReferencedVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|RelFactories
operator|.
name|ProjectFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCorrelVariable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexDynamicParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexFieldAccess
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLocalRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexOver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexRangeRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexVisitorImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|VirtualColumn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveMultiJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
operator|.
name|ExprNodeConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ASTNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ParseUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
operator|.
name|Builder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_comment
comment|/**  * Generic utility functions needed for Calcite based Hive CBO.  */
end_comment

begin_class
specifier|public
class|class
name|HiveCalciteUtil
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HiveCalciteUtil
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Get list of virtual columns from the given list of projections.    *<p>    *    * @param exps    *          list of rex nodes representing projections    * @return List of Virtual Columns, will not be null.    */
specifier|public
specifier|static
name|List
argument_list|<
name|Integer
argument_list|>
name|getVirtualCols
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exps
parameter_list|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|vCols
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exps
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|exps
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
name|vCols
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|vCols
return|;
block|}
specifier|public
specifier|static
name|boolean
name|validateASTForUnsupportedTokens
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
block|{
if|if
condition|(
name|ParseUtils
operator|.
name|containsTokenOfType
argument_list|(
name|ast
argument_list|,
name|HiveParser
operator|.
name|TOK_CHARSETLITERAL
argument_list|,
name|HiveParser
operator|.
name|TOK_TABLESPLITSAMPLE
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|getProjsFromBelowAsInputRef
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|projectList
init|=
name|Lists
operator|.
name|transform
argument_list|(
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|,
operator|new
name|Function
argument_list|<
name|RelDataTypeField
argument_list|,
name|RexNode
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|apply
parameter_list|(
name|RelDataTypeField
name|field
parameter_list|)
block|{
return|return
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|field
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
return|return
name|projectList
return|;
block|}
specifier|public
specifier|static
name|List
argument_list|<
name|Integer
argument_list|>
name|translateBitSetToProjIndx
parameter_list|(
name|ImmutableBitSet
name|projBitSet
parameter_list|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|projIndxLst
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|projBitSet
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|projBitSet
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|projIndxLst
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|projIndxLst
return|;
block|}
comment|/**    * Push any equi join conditions that are not column references as Projections    * on top of the children.    *    * @param factory    *          Project factory to use.    * @param inputRels    *          inputs to a join    * @param leftJoinKeys    *          expressions for LHS of join key    * @param rightJoinKeys    *          expressions for RHS of join key    * @param systemColCount    *          number of system columns, usually zero. These columns are    *          projected at the leading edge of the output row.    * @param leftKeys    *          on return this contains the join key positions from the new    *          project rel on the LHS.    * @param rightKeys    *          on return this contains the join key positions from the new    *          project rel on the RHS.    * @return the join condition after the equi expressions pushed down.    */
specifier|public
specifier|static
name|RexNode
name|projectNonColumnEquiConditions
parameter_list|(
name|ProjectFactory
name|factory
parameter_list|,
name|RelNode
index|[]
name|inputRels
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftJoinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightJoinKeys
parameter_list|,
name|int
name|systemColCount
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
parameter_list|)
block|{
name|RelNode
name|leftRel
init|=
name|inputRels
index|[
literal|0
index|]
decl_stmt|;
name|RelNode
name|rightRel
init|=
name|inputRels
index|[
literal|1
index|]
decl_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|leftRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RexNode
name|outJoinCond
init|=
literal|null
decl_stmt|;
name|int
name|origLeftInputSize
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|origRightInputSize
init|=
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|newLeftFields
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|newLeftFieldNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|newRightFields
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|newRightFieldNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|leftKeyCount
init|=
name|leftJoinKeys
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|origLeftInputSize
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|newLeftFields
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|newLeftFieldNames
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|origRightInputSize
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|newRightFields
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|newRightFieldNames
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|newKeyCount
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|origColEqConds
init|=
operator|new
name|ArrayList
argument_list|<
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|leftKeyCount
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|leftKey
init|=
name|leftJoinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RexNode
name|rightKey
init|=
name|rightJoinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftKey
operator|instanceof
name|RexInputRef
operator|&&
name|rightKey
operator|instanceof
name|RexInputRef
condition|)
block|{
name|origColEqConds
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|leftKey
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|,
operator|(
operator|(
name|RexInputRef
operator|)
name|rightKey
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newLeftFields
operator|.
name|add
argument_list|(
name|leftKey
argument_list|)
expr_stmt|;
name|newLeftFieldNames
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|newRightFields
operator|.
name|add
argument_list|(
name|rightKey
argument_list|)
expr_stmt|;
name|newRightFieldNames
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|newKeyCount
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|origColEqConds
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|p
init|=
name|origColEqConds
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RexNode
name|leftKey
init|=
name|leftJoinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RexNode
name|rightKey
init|=
name|rightJoinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|leftKeys
operator|.
name|add
argument_list|(
name|p
operator|.
name|left
argument_list|)
expr_stmt|;
name|rightKeys
operator|.
name|add
argument_list|(
name|p
operator|.
name|right
argument_list|)
expr_stmt|;
name|RexNode
name|cond
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|leftKey
operator|.
name|getType
argument_list|()
argument_list|,
name|systemColCount
operator|+
name|p
operator|.
name|left
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|rightKey
operator|.
name|getType
argument_list|()
argument_list|,
name|systemColCount
operator|+
name|origLeftInputSize
operator|+
name|newKeyCount
operator|+
name|p
operator|.
name|right
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|outJoinCond
operator|==
literal|null
condition|)
block|{
name|outJoinCond
operator|=
name|cond
expr_stmt|;
block|}
else|else
block|{
name|outJoinCond
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|outJoinCond
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newKeyCount
operator|==
literal|0
condition|)
block|{
return|return
name|outJoinCond
return|;
block|}
name|int
name|newLeftOffset
init|=
name|systemColCount
operator|+
name|origLeftInputSize
decl_stmt|;
name|int
name|newRightOffset
init|=
name|systemColCount
operator|+
name|origLeftInputSize
operator|+
name|origRightInputSize
operator|+
name|newKeyCount
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|newKeyCount
condition|;
name|i
operator|++
control|)
block|{
name|leftKeys
operator|.
name|add
argument_list|(
name|origLeftInputSize
operator|+
name|i
argument_list|)
expr_stmt|;
name|rightKeys
operator|.
name|add
argument_list|(
name|origRightInputSize
operator|+
name|i
argument_list|)
expr_stmt|;
name|RexNode
name|cond
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|newLeftFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|newLeftOffset
operator|+
name|i
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|newLeftFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|newRightOffset
operator|+
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|outJoinCond
operator|==
literal|null
condition|)
block|{
name|outJoinCond
operator|=
name|cond
expr_stmt|;
block|}
else|else
block|{
name|outJoinCond
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|outJoinCond
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
block|}
comment|// added project if need to produce new keys than the original input
comment|// fields
if|if
condition|(
name|newKeyCount
operator|>
literal|0
condition|)
block|{
name|leftRel
operator|=
name|factory
operator|.
name|createProject
argument_list|(
name|leftRel
argument_list|,
name|newLeftFields
argument_list|,
name|SqlValidatorUtil
operator|.
name|uniquify
argument_list|(
name|newLeftFieldNames
argument_list|)
argument_list|)
expr_stmt|;
name|rightRel
operator|=
name|factory
operator|.
name|createProject
argument_list|(
name|rightRel
argument_list|,
name|newRightFields
argument_list|,
name|SqlValidatorUtil
operator|.
name|uniquify
argument_list|(
name|newRightFieldNames
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|inputRels
index|[
literal|0
index|]
operator|=
name|leftRel
expr_stmt|;
name|inputRels
index|[
literal|1
index|]
operator|=
name|rightRel
expr_stmt|;
return|return
name|outJoinCond
return|;
block|}
comment|/**    * JoinPredicateInfo represents Join condition; JoinPredicate Info uses    * JoinLeafPredicateInfo to represent individual conjunctive elements in the    * predicate.<br>    * JoinPredicateInfo = JoinLeafPredicateInfo1 and JoinLeafPredicateInfo2...<br>    *<p>    * JoinPredicateInfo:<br>    * 1. preserves the order of conjuctive elements for    * equi-join(equiJoinPredicateElements)<br>    * 2. Stores set of projection indexes from left and right child which is part    * of equi join keys; the indexes are both in child and Join node schema.<br>    * 3. Keeps a map of projection indexes that are part of join keys to list of    * conjuctive elements(JoinLeafPredicateInfo) that uses them.    *    */
specifier|public
specifier|static
class|class
name|JoinPredicateInfo
block|{
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|nonEquiJoinPredicateElements
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|equiJoinPredicateElements
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|projsJoinKeysInChildSchema
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|projsJoinKeysInJoinSchema
decl_stmt|;
specifier|private
specifier|final
name|ImmutableMap
argument_list|<
name|Integer
argument_list|,
name|ImmutableList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
name|mapOfProjIndxInJoinSchemaToLeafPInfo
decl_stmt|;
specifier|public
name|JoinPredicateInfo
parameter_list|(
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|nonEquiJoinPredicateElements
parameter_list|,
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|equiJoinPredicateElements
parameter_list|,
name|List
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|projsJoinKeysInChildSchema
parameter_list|,
name|List
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|projsJoinKeysInJoinSchema
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|ImmutableList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
name|mapOfProjIndxInJoinSchemaToLeafPInfo
parameter_list|)
block|{
name|this
operator|.
name|nonEquiJoinPredicateElements
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nonEquiJoinPredicateElements
argument_list|)
expr_stmt|;
name|this
operator|.
name|equiJoinPredicateElements
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|equiJoinPredicateElements
argument_list|)
expr_stmt|;
name|this
operator|.
name|projsJoinKeysInChildSchema
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|projsJoinKeysInChildSchema
argument_list|)
expr_stmt|;
name|this
operator|.
name|projsJoinKeysInJoinSchema
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|projsJoinKeysInJoinSchema
argument_list|)
expr_stmt|;
name|this
operator|.
name|mapOfProjIndxInJoinSchemaToLeafPInfo
operator|=
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|mapOfProjIndxInJoinSchemaToLeafPInfo
argument_list|)
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|getNonEquiJoinPredicateElements
parameter_list|()
block|{
return|return
name|this
operator|.
name|nonEquiJoinPredicateElements
return|;
block|}
specifier|public
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|getEquiJoinPredicateElements
parameter_list|()
block|{
return|return
name|this
operator|.
name|equiJoinPredicateElements
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromLeftPartOfJoinKeysInChildSchema
parameter_list|()
block|{
assert|assert
name|projsJoinKeysInChildSchema
operator|.
name|size
argument_list|()
operator|==
literal|2
assert|;
return|return
name|this
operator|.
name|projsJoinKeysInChildSchema
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromRightPartOfJoinKeysInChildSchema
parameter_list|()
block|{
assert|assert
name|projsJoinKeysInChildSchema
operator|.
name|size
argument_list|()
operator|==
literal|2
assert|;
return|return
name|this
operator|.
name|projsJoinKeysInChildSchema
operator|.
name|get
argument_list|(
literal|1
argument_list|)
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsJoinKeysInChildSchema
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|this
operator|.
name|projsJoinKeysInChildSchema
operator|.
name|get
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|/**      * NOTE: Join Schema = left Schema + (right Schema offset by      * left.fieldcount). Hence its ok to return projections from left in child      * schema.      */
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromLeftPartOfJoinKeysInJoinSchema
parameter_list|()
block|{
assert|assert
name|projsJoinKeysInJoinSchema
operator|.
name|size
argument_list|()
operator|==
literal|2
assert|;
return|return
name|this
operator|.
name|projsJoinKeysInJoinSchema
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromRightPartOfJoinKeysInJoinSchema
parameter_list|()
block|{
assert|assert
name|projsJoinKeysInJoinSchema
operator|.
name|size
argument_list|()
operator|==
literal|2
assert|;
return|return
name|this
operator|.
name|projsJoinKeysInJoinSchema
operator|.
name|get
argument_list|(
literal|1
argument_list|)
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsJoinKeysInJoinSchema
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|this
operator|.
name|projsJoinKeysInJoinSchema
operator|.
name|get
argument_list|(
name|i
argument_list|)
return|;
block|}
specifier|public
name|Map
argument_list|<
name|Integer
argument_list|,
name|ImmutableList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
name|getMapOfProjIndxToLeafPInfo
parameter_list|()
block|{
return|return
name|this
operator|.
name|mapOfProjIndxInJoinSchemaToLeafPInfo
return|;
block|}
specifier|public
specifier|static
name|JoinPredicateInfo
name|constructJoinPredicateInfo
parameter_list|(
name|Join
name|j
parameter_list|)
throws|throws
name|CalciteSemanticException
block|{
return|return
name|constructJoinPredicateInfo
argument_list|(
name|j
argument_list|,
name|j
operator|.
name|getCondition
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|JoinPredicateInfo
name|constructJoinPredicateInfo
parameter_list|(
name|HiveMultiJoin
name|mj
parameter_list|)
throws|throws
name|CalciteSemanticException
block|{
return|return
name|constructJoinPredicateInfo
argument_list|(
name|mj
argument_list|,
name|mj
operator|.
name|getCondition
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|JoinPredicateInfo
name|constructJoinPredicateInfo
parameter_list|(
name|Join
name|j
parameter_list|,
name|RexNode
name|predicate
parameter_list|)
throws|throws
name|CalciteSemanticException
block|{
return|return
name|constructJoinPredicateInfo
argument_list|(
name|j
operator|.
name|getInputs
argument_list|()
argument_list|,
name|j
operator|.
name|getSystemFieldList
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|JoinPredicateInfo
name|constructJoinPredicateInfo
parameter_list|(
name|HiveMultiJoin
name|mj
parameter_list|,
name|RexNode
name|predicate
parameter_list|)
throws|throws
name|CalciteSemanticException
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|systemFieldList
init|=
name|ImmutableList
operator|.
name|of
argument_list|()
decl_stmt|;
return|return
name|constructJoinPredicateInfo
argument_list|(
name|mj
operator|.
name|getInputs
argument_list|()
argument_list|,
name|systemFieldList
argument_list|,
name|predicate
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|JoinPredicateInfo
name|constructJoinPredicateInfo
parameter_list|(
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|systemFieldList
parameter_list|,
name|RexNode
name|predicate
parameter_list|)
throws|throws
name|CalciteSemanticException
block|{
name|JoinPredicateInfo
name|jpi
init|=
literal|null
decl_stmt|;
name|JoinLeafPredicateInfo
name|jlpi
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|equiLPIList
init|=
operator|new
name|ArrayList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|nonEquiLPIList
init|=
operator|new
name|ArrayList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|projsJoinKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsJoinKeysInput
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
name|projsJoinKeys
operator|.
name|add
argument_list|(
name|projsJoinKeysInput
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|projsJoinKeysInJoinSchema
init|=
operator|new
name|ArrayList
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsJoinKeysInJoinSchemaInput
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
name|projsJoinKeysInJoinSchema
operator|.
name|add
argument_list|(
name|projsJoinKeysInJoinSchemaInput
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
name|tmpMapOfProjIndxInJoinSchemaToLeafPInfo
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|ImmutableList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
name|mapOfProjIndxInJoinSchemaToLeafPInfo
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|ImmutableList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|tmpJLPILst
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|conjuctiveElements
decl_stmt|;
comment|// 1. Decompose Join condition to a number of leaf predicates
comment|// (conjuctive elements)
name|conjuctiveElements
operator|=
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|predicate
argument_list|)
expr_stmt|;
comment|// 2. Walk through leaf predicates building up JoinLeafPredicateInfo
for|for
control|(
name|RexNode
name|ce
range|:
name|conjuctiveElements
control|)
block|{
comment|// 2.1 Construct JoinLeafPredicateInfo
name|jlpi
operator|=
name|JoinLeafPredicateInfo
operator|.
name|constructJoinLeafPredicateInfo
argument_list|(
name|inputs
argument_list|,
name|systemFieldList
argument_list|,
name|ce
argument_list|)
expr_stmt|;
comment|// 2.2 Classify leaf predicate as Equi vs Non Equi
if|if
condition|(
name|jlpi
operator|.
name|comparisonType
operator|.
name|equals
argument_list|(
name|SqlKind
operator|.
name|EQUALS
argument_list|)
condition|)
block|{
name|equiLPIList
operator|.
name|add
argument_list|(
name|jlpi
argument_list|)
expr_stmt|;
comment|// 2.2.1 Maintain join keys (in child& Join Schema)
comment|// 2.2.2 Update Join Key to JoinLeafPredicateInfo map with keys
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|projsJoinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|addAll
argument_list|(
name|jlpi
operator|.
name|getProjsJoinKeysInChildSchema
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|projsJoinKeysInJoinSchema
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|addAll
argument_list|(
name|jlpi
operator|.
name|getProjsJoinKeysInJoinSchema
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Integer
name|projIndx
range|:
name|jlpi
operator|.
name|getProjsJoinKeysInJoinSchema
argument_list|(
name|i
argument_list|)
control|)
block|{
name|tmpJLPILst
operator|=
name|tmpMapOfProjIndxInJoinSchemaToLeafPInfo
operator|.
name|get
argument_list|(
name|projIndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpJLPILst
operator|==
literal|null
condition|)
block|{
name|tmpJLPILst
operator|=
operator|new
name|ArrayList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|tmpJLPILst
operator|.
name|add
argument_list|(
name|jlpi
argument_list|)
expr_stmt|;
name|tmpMapOfProjIndxInJoinSchemaToLeafPInfo
operator|.
name|put
argument_list|(
name|projIndx
argument_list|,
name|tmpJLPILst
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|nonEquiLPIList
operator|.
name|add
argument_list|(
name|jlpi
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 3. Update Update Join Key to List<JoinLeafPredicateInfo> to use
comment|// ImmutableList
for|for
control|(
name|Entry
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
name|e
range|:
name|tmpMapOfProjIndxInJoinSchemaToLeafPInfo
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|mapOfProjIndxInJoinSchemaToLeafPInfo
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 4. Construct JoinPredicateInfo
name|jpi
operator|=
operator|new
name|JoinPredicateInfo
argument_list|(
name|nonEquiLPIList
argument_list|,
name|equiLPIList
argument_list|,
name|projsJoinKeys
argument_list|,
name|projsJoinKeysInJoinSchema
argument_list|,
name|mapOfProjIndxInJoinSchemaToLeafPInfo
argument_list|)
expr_stmt|;
return|return
name|jpi
return|;
block|}
block|}
comment|/**    * JoinLeafPredicateInfo represents leaf predicate in Join condition    * (conjuctive lement).<br>    *<p>    * JoinLeafPredicateInfo:<br>    * 1. Stores list of expressions from left and right child which is part of    * equi join keys.<br>    * 2. Stores set of projection indexes from left and right child which is part    * of equi join keys; the indexes are both in child and Join node schema.<br>    */
specifier|public
specifier|static
class|class
name|JoinLeafPredicateInfo
block|{
specifier|private
specifier|final
name|SqlKind
name|comparisonType
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|joinKeyExprs
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|ImmutableSet
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|projsJoinKeysInChildSchema
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|ImmutableSet
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|projsJoinKeysInJoinSchema
decl_stmt|;
specifier|public
name|JoinLeafPredicateInfo
parameter_list|(
name|SqlKind
name|comparisonType
parameter_list|,
name|List
argument_list|<
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|joinKeyExprs
parameter_list|,
name|List
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|projsJoinKeysInChildSchema
parameter_list|,
name|List
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|projsJoinKeysInJoinSchema
parameter_list|)
block|{
name|this
operator|.
name|comparisonType
operator|=
name|comparisonType
expr_stmt|;
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|joinKeyExprsBuilder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|joinKeyExprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|joinKeyExprsBuilder
operator|.
name|add
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|joinKeyExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|joinKeyExprs
operator|=
name|joinKeyExprsBuilder
operator|.
name|build
argument_list|()
expr_stmt|;
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableSet
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|projsJoinKeysInChildSchemaBuilder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|projsJoinKeysInChildSchema
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|projsJoinKeysInChildSchemaBuilder
operator|.
name|add
argument_list|(
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|projsJoinKeysInChildSchema
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|projsJoinKeysInChildSchema
operator|=
name|projsJoinKeysInChildSchemaBuilder
operator|.
name|build
argument_list|()
expr_stmt|;
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableSet
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|projsJoinKeysInJoinSchemaBuilder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|projsJoinKeysInJoinSchema
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|projsJoinKeysInJoinSchemaBuilder
operator|.
name|add
argument_list|(
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|projsJoinKeysInJoinSchema
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|projsJoinKeysInJoinSchema
operator|=
name|projsJoinKeysInJoinSchemaBuilder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|RexNode
argument_list|>
name|getJoinExprs
parameter_list|(
name|int
name|input
parameter_list|)
block|{
return|return
name|this
operator|.
name|joinKeyExprs
operator|.
name|get
argument_list|(
name|input
argument_list|)
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromLeftPartOfJoinKeysInChildSchema
parameter_list|()
block|{
assert|assert
name|projsJoinKeysInChildSchema
operator|.
name|size
argument_list|()
operator|==
literal|2
assert|;
return|return
name|this
operator|.
name|projsJoinKeysInChildSchema
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromRightPartOfJoinKeysInChildSchema
parameter_list|()
block|{
assert|assert
name|projsJoinKeysInChildSchema
operator|.
name|size
argument_list|()
operator|==
literal|2
assert|;
return|return
name|this
operator|.
name|projsJoinKeysInChildSchema
operator|.
name|get
argument_list|(
literal|1
argument_list|)
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsJoinKeysInChildSchema
parameter_list|(
name|int
name|input
parameter_list|)
block|{
return|return
name|this
operator|.
name|projsJoinKeysInChildSchema
operator|.
name|get
argument_list|(
name|input
argument_list|)
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromLeftPartOfJoinKeysInJoinSchema
parameter_list|()
block|{
assert|assert
name|projsJoinKeysInJoinSchema
operator|.
name|size
argument_list|()
operator|==
literal|2
assert|;
return|return
name|this
operator|.
name|projsJoinKeysInJoinSchema
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromRightPartOfJoinKeysInJoinSchema
parameter_list|()
block|{
assert|assert
name|projsJoinKeysInJoinSchema
operator|.
name|size
argument_list|()
operator|==
literal|2
assert|;
return|return
name|this
operator|.
name|projsJoinKeysInJoinSchema
operator|.
name|get
argument_list|(
literal|1
argument_list|)
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsJoinKeysInJoinSchema
parameter_list|(
name|int
name|input
parameter_list|)
block|{
return|return
name|this
operator|.
name|projsJoinKeysInJoinSchema
operator|.
name|get
argument_list|(
name|input
argument_list|)
return|;
block|}
comment|// We create the join predicate info object. The object contains the join condition,
comment|// split accordingly. If the join condition is not part of the equi-join predicate,
comment|// the returned object will be typed as SQLKind.OTHER.
specifier|private
specifier|static
name|JoinLeafPredicateInfo
name|constructJoinLeafPredicateInfo
parameter_list|(
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|systemFieldList
parameter_list|,
name|RexNode
name|pe
parameter_list|)
throws|throws
name|CalciteSemanticException
block|{
name|JoinLeafPredicateInfo
name|jlpi
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|filterNulls
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|joinExprs
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|joinExprs
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// 1. Split leaf join predicate to expressions from left, right
name|RexNode
name|otherConditions
init|=
name|HiveRelOptUtil
operator|.
name|splitHiveJoinCondition
argument_list|(
name|systemFieldList
argument_list|,
name|inputs
argument_list|,
name|pe
argument_list|,
name|joinExprs
argument_list|,
name|filterNulls
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|otherConditions
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
comment|// 2. Collect child projection indexes used
name|List
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|projsJoinKeysInChildSchema
init|=
operator|new
name|ArrayList
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ImmutableSet
operator|.
name|Builder
argument_list|<
name|Integer
argument_list|>
name|projsFromInputJoinKeysInChildSchema
init|=
name|ImmutableSet
operator|.
name|builder
argument_list|()
decl_stmt|;
name|InputReferencedVisitor
name|irvLeft
init|=
operator|new
name|InputReferencedVisitor
argument_list|()
decl_stmt|;
name|irvLeft
operator|.
name|apply
argument_list|(
name|joinExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|projsFromInputJoinKeysInChildSchema
operator|.
name|addAll
argument_list|(
name|irvLeft
operator|.
name|inputPosReferenced
argument_list|)
expr_stmt|;
name|projsJoinKeysInChildSchema
operator|.
name|add
argument_list|(
name|projsFromInputJoinKeysInChildSchema
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// 3. Translate projection indexes to join schema, by adding offset.
name|List
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|projsJoinKeysInJoinSchema
init|=
operator|new
name|ArrayList
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// The offset of the first input does not need to change.
name|projsJoinKeysInJoinSchema
operator|.
name|add
argument_list|(
name|projsJoinKeysInChildSchema
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|inputs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|offSet
init|=
name|inputs
operator|.
name|get
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|ImmutableSet
operator|.
name|Builder
argument_list|<
name|Integer
argument_list|>
name|projsFromInputJoinKeysInJoinSchema
init|=
name|ImmutableSet
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|indx
range|:
name|projsJoinKeysInChildSchema
operator|.
name|get
argument_list|(
name|i
argument_list|)
control|)
block|{
name|projsFromInputJoinKeysInJoinSchema
operator|.
name|add
argument_list|(
name|indx
operator|+
name|offSet
argument_list|)
expr_stmt|;
block|}
name|projsJoinKeysInJoinSchema
operator|.
name|add
argument_list|(
name|projsFromInputJoinKeysInJoinSchema
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// 4. Construct JoinLeafPredicateInfo
name|jlpi
operator|=
operator|new
name|JoinLeafPredicateInfo
argument_list|(
name|pe
operator|.
name|getKind
argument_list|()
argument_list|,
name|joinExprs
argument_list|,
name|projsJoinKeysInChildSchema
argument_list|,
name|projsJoinKeysInJoinSchema
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// 2. Construct JoinLeafPredicateInfo
name|ImmutableBitSet
name|refCols
init|=
name|InputFinder
operator|.
name|bits
argument_list|(
name|pe
argument_list|)
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|length
init|=
name|inputs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|ImmutableBitSet
name|inputRange
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|count
argument_list|,
name|count
operator|+
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|inputRange
operator|.
name|contains
argument_list|(
name|refCols
argument_list|)
condition|)
block|{
name|joinExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|add
argument_list|(
name|pe
argument_list|)
expr_stmt|;
block|}
name|count
operator|+=
name|length
expr_stmt|;
block|}
name|jlpi
operator|=
operator|new
name|JoinLeafPredicateInfo
argument_list|(
name|SqlKind
operator|.
name|OTHER
argument_list|,
name|joinExprs
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|jlpi
return|;
block|}
block|}
specifier|public
specifier|static
name|boolean
name|limitRelNode
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
if|if
condition|(
operator|(
name|rel
operator|instanceof
name|Sort
operator|)
operator|&&
operator|(
operator|(
name|Sort
operator|)
name|rel
operator|)
operator|.
name|getCollation
argument_list|()
operator|.
name|getFieldCollations
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
specifier|public
specifier|static
name|boolean
name|orderRelNode
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
if|if
condition|(
operator|(
name|rel
operator|instanceof
name|Sort
operator|)
operator|&&
operator|!
operator|(
operator|(
name|Sort
operator|)
name|rel
operator|)
operator|.
name|getCollation
argument_list|()
operator|.
name|getFieldCollations
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
comment|/**    * Get top level select starting from root. Assumption here is root can only    * be Sort& Project. Also the top project should be at most 2 levels below    * Sort; i.e Sort(Limit)-Sort(OB)-Select    *    * @param rootRel    * @return    */
specifier|public
specifier|static
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|>
name|getTopLevelSelect
parameter_list|(
specifier|final
name|RelNode
name|rootRel
parameter_list|)
block|{
name|RelNode
name|tmpRel
init|=
name|rootRel
decl_stmt|;
name|RelNode
name|parentOforiginalProjRel
init|=
name|rootRel
decl_stmt|;
name|HiveProject
name|originalProjRel
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|tmpRel
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|tmpRel
operator|instanceof
name|HiveProject
condition|)
block|{
name|originalProjRel
operator|=
operator|(
name|HiveProject
operator|)
name|tmpRel
expr_stmt|;
break|break;
block|}
name|parentOforiginalProjRel
operator|=
name|tmpRel
expr_stmt|;
name|tmpRel
operator|=
name|tmpRel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|new
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|>
argument_list|(
name|parentOforiginalProjRel
argument_list|,
name|originalProjRel
argument_list|)
operator|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isDeterministic
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
name|boolean
name|deterministic
init|=
literal|true
decl_stmt|;
name|RexVisitor
argument_list|<
name|Void
argument_list|>
name|visitor
init|=
operator|new
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
argument_list|(
literal|true
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|visitCall
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
name|call
parameter_list|)
block|{
if|if
condition|(
operator|!
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|isDeterministic
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|Util
operator|.
name|FoundOne
argument_list|(
name|call
argument_list|)
throw|;
block|}
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
decl_stmt|;
try|try
block|{
name|expr
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
name|deterministic
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|deterministic
return|;
block|}
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|ImmutableMap
argument_list|<
name|Integer
argument_list|,
name|T
argument_list|>
name|getColInfoMap
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|hiveCols
parameter_list|,
name|int
name|startIndx
parameter_list|)
block|{
name|Builder
argument_list|<
name|Integer
argument_list|,
name|T
argument_list|>
name|bldr
init|=
name|ImmutableMap
operator|.
expr|<
name|Integer
decl_stmt|,
name|T
decl|>
name|builder
argument_list|()
decl_stmt|;
name|int
name|indx
init|=
name|startIndx
decl_stmt|;
for|for
control|(
name|T
name|ci
range|:
name|hiveCols
control|)
block|{
name|bldr
operator|.
name|put
argument_list|(
name|indx
argument_list|,
name|ci
argument_list|)
expr_stmt|;
name|indx
operator|++
expr_stmt|;
block|}
return|return
name|bldr
operator|.
name|build
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|ImmutableSet
argument_list|<
name|Integer
argument_list|>
name|shiftVColsSet
parameter_list|(
name|Set
argument_list|<
name|Integer
argument_list|>
name|hiveVCols
parameter_list|,
name|int
name|shift
parameter_list|)
block|{
name|ImmutableSet
operator|.
name|Builder
argument_list|<
name|Integer
argument_list|>
name|bldr
init|=
name|ImmutableSet
operator|.
expr|<
name|Integer
operator|>
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|pos
range|:
name|hiveVCols
control|)
block|{
name|bldr
operator|.
name|add
argument_list|(
name|shift
operator|+
name|pos
argument_list|)
expr_stmt|;
block|}
return|return
name|bldr
operator|.
name|build
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|ImmutableMap
argument_list|<
name|Integer
argument_list|,
name|VirtualColumn
argument_list|>
name|getVColsMap
parameter_list|(
name|List
argument_list|<
name|VirtualColumn
argument_list|>
name|hiveVCols
parameter_list|,
name|int
name|startIndx
parameter_list|)
block|{
name|Builder
argument_list|<
name|Integer
argument_list|,
name|VirtualColumn
argument_list|>
name|bldr
init|=
name|ImmutableMap
operator|.
expr|<
name|Integer
decl_stmt|,
name|VirtualColumn
decl|>
name|builder
argument_list|()
decl_stmt|;
name|int
name|indx
init|=
name|startIndx
decl_stmt|;
for|for
control|(
name|VirtualColumn
name|vc
range|:
name|hiveVCols
control|)
block|{
name|bldr
operator|.
name|put
argument_list|(
name|indx
argument_list|,
name|vc
argument_list|)
expr_stmt|;
name|indx
operator|++
expr_stmt|;
block|}
return|return
name|bldr
operator|.
name|build
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|getColNameIndxMap
parameter_list|(
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|tableFields
parameter_list|)
block|{
name|Builder
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|bldr
init|=
name|ImmutableMap
operator|.
expr|<
name|String
decl_stmt|,
name|Integer
decl|>
name|builder
argument_list|()
decl_stmt|;
name|int
name|indx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FieldSchema
name|fs
range|:
name|tableFields
control|)
block|{
name|bldr
operator|.
name|put
argument_list|(
name|fs
operator|.
name|getName
argument_list|()
argument_list|,
name|indx
argument_list|)
expr_stmt|;
name|indx
operator|++
expr_stmt|;
block|}
return|return
name|bldr
operator|.
name|build
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|getRowColNameIndxMap
parameter_list|(
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rowFields
parameter_list|)
block|{
name|Builder
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|bldr
init|=
name|ImmutableMap
operator|.
expr|<
name|String
decl_stmt|,
name|Integer
decl|>
name|builder
argument_list|()
decl_stmt|;
name|int
name|indx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|rdt
range|:
name|rowFields
control|)
block|{
name|bldr
operator|.
name|put
argument_list|(
name|rdt
operator|.
name|getName
argument_list|()
argument_list|,
name|indx
argument_list|)
expr_stmt|;
name|indx
operator|++
expr_stmt|;
block|}
return|return
name|bldr
operator|.
name|build
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|getInputRef
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|inputRefs
parameter_list|,
name|RelNode
name|inputRel
parameter_list|)
block|{
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|bldr
init|=
name|ImmutableList
operator|.
expr|<
name|RexNode
operator|>
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
range|:
name|inputRefs
control|)
block|{
name|bldr
operator|.
name|add
argument_list|(
operator|new
name|RexInputRef
argument_list|(
name|i
argument_list|,
name|inputRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|bldr
operator|.
name|build
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|ExprNodeDesc
name|getExprNode
parameter_list|(
name|Integer
name|inputRefIndx
parameter_list|,
name|RelNode
name|inputRel
parameter_list|,
name|ExprNodeConverter
name|exprConv
parameter_list|)
block|{
name|ExprNodeDesc
name|exprNode
init|=
literal|null
decl_stmt|;
name|RexNode
name|rexInputRef
init|=
operator|new
name|RexInputRef
argument_list|(
name|inputRefIndx
argument_list|,
name|inputRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|inputRefIndx
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|exprNode
operator|=
name|rexInputRef
operator|.
name|accept
argument_list|(
name|exprConv
argument_list|)
expr_stmt|;
return|return
name|exprNode
return|;
block|}
specifier|public
specifier|static
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|getExprNodes
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|inputRefs
parameter_list|,
name|RelNode
name|inputRel
parameter_list|,
name|String
name|inputTabAlias
parameter_list|)
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|exprNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|rexInputRefs
init|=
name|getInputRef
argument_list|(
name|inputRefs
argument_list|,
name|inputRel
argument_list|)
decl_stmt|;
comment|// TODO: Change ExprNodeConverter to be independent of Partition Expr
name|ExprNodeConverter
name|exprConv
init|=
operator|new
name|ExprNodeConverter
argument_list|(
name|inputTabAlias
argument_list|,
name|inputRel
operator|.
name|getRowType
argument_list|()
argument_list|,
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
argument_list|,
name|inputRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|iRef
range|:
name|rexInputRefs
control|)
block|{
name|exprNodes
operator|.
name|add
argument_list|(
name|iRef
operator|.
name|accept
argument_list|(
name|exprConv
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|exprNodes
return|;
block|}
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|getFieldNames
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|inputRefs
parameter_list|,
name|RelNode
name|inputRel
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|schemaNames
init|=
name|inputRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|iRef
range|:
name|inputRefs
control|)
block|{
name|fieldNames
operator|.
name|add
argument_list|(
name|schemaNames
operator|.
name|get
argument_list|(
name|iRef
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|fieldNames
return|;
block|}
comment|/**    * Walks over an expression and determines whether it is constant.    */
specifier|public
specifier|static
class|class
name|ConstantFinder
implements|implements
name|RexVisitor
argument_list|<
name|Boolean
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|visitLiteral
parameter_list|(
name|RexLiteral
name|literal
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|localRef
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Not expected to be called."
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visitOver
parameter_list|(
name|RexOver
name|over
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visitCorrelVariable
parameter_list|(
name|RexCorrelVariable
name|correlVariable
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visitDynamicParam
parameter_list|(
name|RexDynamicParam
name|dynamicParam
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
comment|// Constant if operator is deterministic and all operands are
comment|// constant.
return|return
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|isDeterministic
argument_list|()
operator|&&
name|RexVisitorImpl
operator|.
name|visitArrayAnd
argument_list|(
name|this
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visitRangeRef
parameter_list|(
name|RexRangeRef
name|rangeRef
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
comment|// "<expr>.FIELD" is constant iff "<expr>" is constant.
return|return
name|fieldAccess
operator|.
name|getReferenceExpr
argument_list|()
operator|.
name|accept
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
name|Set
argument_list|<
name|Integer
argument_list|>
name|getInputRefs
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
name|InputRefsCollector
name|irefColl
init|=
operator|new
name|InputRefsCollector
argument_list|(
literal|true
argument_list|)
decl_stmt|;
return|return
name|irefColl
operator|.
name|getInputRefSet
argument_list|()
return|;
block|}
specifier|private
specifier|static
class|class
name|InputRefsCollector
extends|extends
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
block|{
specifier|private
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|inputRefSet
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|InputRefsCollector
parameter_list|(
name|boolean
name|deep
parameter_list|)
block|{
name|super
argument_list|(
name|deep
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|inputRefSet
operator|.
name|add
argument_list|(
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getInputRefSet
parameter_list|()
block|{
return|return
name|inputRefSet
return|;
block|}
block|}
block|}
end_class

end_unit

