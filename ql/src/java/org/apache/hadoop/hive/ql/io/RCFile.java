begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|rmi
operator|.
name|server
operator|.
name|UID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|MessageDigest
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ChecksumException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|ColumnProjectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|columnar
operator|.
name|BytesRefArrayWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|columnar
operator|.
name|BytesRefWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|columnar
operator|.
name|LazyDecompressionCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|shims
operator|.
name|ShimLoader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
operator|.
name|Metadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|VersionMismatchException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableComparable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|CompressionCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|CompressionInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|CompressionOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|Compressor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|Decompressor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Progressable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  *<code>RCFile</code>s, short of Record Columnar File, are flat files  * consisting of binary key/value pairs, which shares much similarity with  *<code>SequenceFile</code>.  *  * RCFile stores columns of a table in a record columnar way. It first  * partitions rows horizontally into row splits. and then it vertically  * partitions each row split in a columnar way. RCFile first stores the meta  * data of a row split, as the key part of a record, and all the data of a row  * split as the value part. When writing, RCFile.Writer first holds records'  * value bytes in memory, and determines a row split if the raw bytes size of  * buffered records overflow a given parameter<tt>Writer.columnsBufferSize</tt>,  * which can be set like:<code>conf.setInt(COLUMNS_BUFFER_SIZE_CONF_STR,           4 * 1024 * 1024)</code> .  *<p>  *<code>RCFile</code> provides {@link Writer}, {@link Reader} and classes for  * writing, reading respectively.  *</p>  *  *<p>  * RCFile stores columns of a table in a record columnar way. It first  * partitions rows horizontally into row splits. and then it vertically  * partitions each row split in a columnar way. RCFile first stores the meta  * data of a row split, as the key part of a record, and all the data of a row  * split as the value part.  *</p>  *  *<p>  * RCFile compresses values in a more fine-grained manner then record level  * compression. However, It currently does not support compress the key part  * yet. The actual compression algorithm used to compress key and/or values can  * be specified by using the appropriate {@link CompressionCodec}.  *</p>  *  *<p>  * The {@link Reader} is used to read and explain the bytes of RCFile.  *</p>  *  *<h4 id="Formats">RCFile Formats</h4>  *  *  *<h5 id="Header">RC Header</h5>  *<ul>  *<li>version - 3 bytes of magic header<b>RCF</b>, followed by 1 byte of  * actual version number (e.g. RCF1)</li>  *<li>compression - A boolean which specifies if compression is turned on for  * keys/values in this file.</li>  *<li>compression codec -<code>CompressionCodec</code> class which is used  * for compression of keys and/or values (if compression is enabled).</li>  *<li>metadata - {@link Metadata} for this file.</li>  *<li>sync - A sync marker to denote end of the header.</li>  *</ul>  *  *<h5>RCFile Format</h5>  *<ul>  *<li><a href="#Header">Header</a></li>  *<li>Record  *<li>Key part  *<ul>  *<li>Record length in bytes</li>  *<li>Key length in bytes</li>  *<li>Number_of_rows_in_this_record(vint)</li>  *<li>Column_1_ondisk_length(vint)</li>  *<li>Column_1_row_1_value_plain_length</li>  *<li>Column_1_row_2_value_plain_length</li>  *<li>...</li>  *<li>Column_2_ondisk_length(vint)</li>  *<li>Column_2_row_1_value_plain_length</li>  *<li>Column_2_row_2_value_plain_length</li>  *<li>...</li>  *</ul>  *</li>  *</li>  *<li>Value part  *<ul>  *<li>Compressed or plain data of [column_1_row_1_value,  * column_1_row_2_value,....]</li>  *<li>Compressed or plain data of [column_2_row_1_value,  * column_2_row_2_value,....]</li>  *</ul>  *</li>  *</ul>  *<p>  *<pre>  * {@code  * The following is a pseudo-BNF grammar for RCFile. Comments are prefixed  * with dashes:  *  * rcfile ::=  *<file-header>  *<rcfile-rowgroup>+  *  * file-header ::=  *<file-version-header>  *<file-key-class-name>              (only exists if version is seq6)  *<file-value-class-name>            (only exists if version is seq6)  *<file-is-compressed>  *<file-is-block-compressed>         (only exists if version is seq6)  *   [<file-compression-codec-class>]  *<file-header-metadata>  *<file-sync-field>  *  * -- The normative RCFile implementation included with Hive is actually  * -- based on a modified version of Hadoop's SequenceFile code. Some  * -- things which should have been modified were not, including the code  * -- that writes out the file version header. Consequently, RCFile and  * -- SequenceFile originally shared the same version header.  A newer  * -- release has created a unique version string.  *  * file-version-header ::= Byte[4] {'S', 'E', 'Q', 6}  *                     |   Byte[4] {'R', 'C', 'F', 1}  *  * -- The name of the Java class responsible for reading the key buffer  * -- component of the rowgroup.  *  * file-key-class-name ::=  *   Text {"org.apache.hadoop.hive.ql.io.RCFile$KeyBuffer"}  *  * -- The name of the Java class responsible for reading the value buffer  * -- component of the rowgroup.  *  * file-value-class-name ::=  *   Text {"org.apache.hadoop.hive.ql.io.RCFile$ValueBuffer"}  *  * -- Boolean variable indicating whether or not the file uses compression  * -- for the key and column buffer sections.  *  * file-is-compressed ::= Byte[1]  *  * -- A boolean field indicating whether or not the file is block compressed.  * -- This field is *always* false. According to comments in the original  * -- RCFile implementation this field was retained for backwards  * -- compatability with the SequenceFile format.  *  * file-is-block-compressed ::= Byte[1] {false}  *  * -- The Java class name of the compression codec iff<file-is-compressed>  * -- is true. The named class must implement  * -- org.apache.hadoop.io.compress.CompressionCodec.  * -- The expected value is org.apache.hadoop.io.compress.GzipCodec.  *  * file-compression-codec-class ::= Text  *  * -- A collection of key-value pairs defining metadata values for the  * -- file. The Map is serialized using standard JDK serialization, i.e.  * -- an Int corresponding to the number of key-value pairs, followed by  * -- Text key and value pairs. The following metadata properties are  * -- mandatory for all RCFiles:  * --  * -- hive.io.rcfile.column.number: the number of columns in the RCFile  *  * file-header-metadata ::= Map<Text, Text>  *  * -- A 16 byte marker that is generated by the writer. This marker appears  * -- at regular intervals at the beginning of rowgroup-headers, and is  * -- intended to enable readers to skip over corrupted rowgroups.  *  * file-sync-hash ::= Byte[16]  *  * -- Each row group is split into three sections: a header, a set of  * -- key buffers, and a set of column buffers. The header section includes  * -- an optional sync hash, information about the size of the row group, and  * -- the total number of rows in the row group. Each key buffer  * -- consists of run-length encoding data which is used to decode  * -- the length and offsets of individual fields in the corresponding column  * -- buffer.  *  * rcfile-rowgroup ::=  *<rowgroup-header>  *<rowgroup-key-data>  *<rowgroup-column-buffers>  *  * rowgroup-header ::=  *   [<rowgroup-sync-marker>,<rowgroup-sync-hash>]  *<rowgroup-record-length>  *<rowgroup-key-length>  *<rowgroup-compressed-key-length>  *  * -- rowgroup-key-data is compressed if the column data is compressed.  * rowgroup-key-data ::=  *<rowgroup-num-rows>  *<rowgroup-key-buffers>  *  * -- An integer (always -1) signaling the beginning of a sync-hash  * -- field.  *  * rowgroup-sync-marker ::= Int  *  * -- A 16 byte sync field. This must match the<file-sync-hash> value read  * -- in the file header.  *  * rowgroup-sync-hash ::= Byte[16]  *  * -- The record-length is the sum of the number of bytes used to store  * -- the key and column parts, i.e. it is the total length of the current  * -- rowgroup.  *  * rowgroup-record-length ::= Int  *  * -- Total length in bytes of the rowgroup's key sections.  *  * rowgroup-key-length ::= Int  *  * -- Total compressed length in bytes of the rowgroup's key sections.  *  * rowgroup-compressed-key-length ::= Int  *  * -- Number of rows in the current rowgroup.  *  * rowgroup-num-rows ::= VInt  *  * -- One or more column key buffers corresponding to each column  * -- in the RCFile.  *  * rowgroup-key-buffers ::=<rowgroup-key-buffer>+  *  * -- Data in each column buffer is stored using a run-length  * -- encoding scheme that is intended to reduce the cost of  * -- repeated column field values. This mechanism is described  * -- in more detail in the following entries.  *  * rowgroup-key-buffer ::=  *<column-buffer-length>  *<column-buffer-uncompressed-length>  *<column-key-buffer-length>  *<column-key-buffer>  *  * -- The serialized length on disk of the corresponding column buffer.  *  * column-buffer-length ::= VInt  *  * -- The uncompressed length of the corresponding column buffer. This  * -- is equivalent to column-buffer-length if the RCFile is not compressed.  *  * column-buffer-uncompressed-length ::= VInt  *  * -- The length in bytes of the current column key buffer  *  * column-key-buffer-length ::= VInt  *  * -- The column-key-buffer contains a sequence of serialized VInt values  * -- corresponding to the byte lengths of the serialized column fields  * -- in the corresponding rowgroup-column-buffer. For example, consider  * -- an integer column that contains the consecutive values 1, 2, 3, 44.  * -- The RCFile format stores these values as strings in the column buffer,  * -- e.g. "12344". The length of each column field is recorded in  * -- the column-key-buffer as a sequence of VInts: 1,1,1,2. However,  * -- if the same length occurs repeatedly, then we replace repeated  * -- run lengths with the complement (i.e. negative) of the number of  * -- repetitions, so 1,1,1,2 becomes 1,~2,2.  *  * column-key-buffer ::= Byte[column-key-buffer-length]  *  * rowgroup-column-buffers ::=<rowgroup-value-buffer>+  *  * -- RCFile stores all column data as strings regardless of the  * -- underlying column type. The strings are neither length-prefixed or  * -- null-terminated, and decoding them into individual fields requires  * -- the use of the run-length information contained in the corresponding  * -- column-key-buffer.  *  * rowgroup-column-buffer ::= Byte[column-buffer-length]  *  * Byte ::= An eight-bit byte  *  * VInt ::= Variable length integer. The high-order bit of each byte  * indicates whether more bytes remain to be read. The low-order seven  * bits are appended as increasingly more significant bits in the  * resulting integer value.  *  * Int ::= A four-byte integer in big-endian format.  *  * Text ::= VInt, Chars (Length prefixed UTF-8 characters)  * }  *</pre>  *</p>  */
end_comment

begin_class
specifier|public
class|class
name|RCFile
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|RCFile
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// internal variable
specifier|public
specifier|static
specifier|final
name|String
name|COLUMN_NUMBER_METADATA_STR
init|=
literal|"hive.io.rcfile.column.number"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|RECORD_INTERVAL_CONF_STR
init|=
name|HIVE_RCFILE_RECORD_INTERVAL
operator|.
name|varname
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|COLUMN_NUMBER_CONF_STR
init|=
name|HIVE_RCFILE_COLUMN_NUMBER_CONF
operator|.
name|varname
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|TOLERATE_CORRUPTIONS_CONF_STR
init|=
name|HIVE_RCFILE_TOLERATE_CORRUPTIONS
operator|.
name|varname
decl_stmt|;
comment|// HACK: We actually need BlockMissingException, but that is not available
comment|// in all hadoop versions.
specifier|public
specifier|static
specifier|final
name|String
name|BLOCK_MISSING_MESSAGE
init|=
literal|"Could not obtain block"
decl_stmt|;
comment|// All of the versions should be place in this list.
specifier|private
specifier|static
specifier|final
name|int
name|ORIGINAL_VERSION
init|=
literal|0
decl_stmt|;
comment|// version with SEQ
specifier|private
specifier|static
specifier|final
name|int
name|NEW_MAGIC_VERSION
init|=
literal|1
decl_stmt|;
comment|// version with RCF
specifier|private
specifier|static
specifier|final
name|int
name|CURRENT_VERSION
init|=
name|NEW_MAGIC_VERSION
decl_stmt|;
comment|// The first version of RCFile used the sequence file header.
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|ORIGINAL_MAGIC
init|=
operator|new
name|byte
index|[]
block|{
operator|(
name|byte
operator|)
literal|'S'
block|,
operator|(
name|byte
operator|)
literal|'E'
block|,
operator|(
name|byte
operator|)
literal|'Q'
block|}
decl_stmt|;
comment|// the version that was included with the original magic, which is mapped
comment|// into ORIGINAL_VERSION
specifier|private
specifier|static
specifier|final
name|byte
name|ORIGINAL_MAGIC_VERSION_WITH_METADATA
init|=
literal|6
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|ORIGINAL_MAGIC_VERSION
init|=
operator|new
name|byte
index|[]
block|{
operator|(
name|byte
operator|)
literal|'S'
block|,
operator|(
name|byte
operator|)
literal|'E'
block|,
operator|(
name|byte
operator|)
literal|'Q'
block|,
name|ORIGINAL_MAGIC_VERSION_WITH_METADATA
block|}
decl_stmt|;
comment|// The 'magic' bytes at the beginning of the RCFile
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|MAGIC
init|=
operator|new
name|byte
index|[]
block|{
operator|(
name|byte
operator|)
literal|'R'
block|,
operator|(
name|byte
operator|)
literal|'C'
block|,
operator|(
name|byte
operator|)
literal|'F'
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|SYNC_ESCAPE
init|=
operator|-
literal|1
decl_stmt|;
comment|// "length" of sync entries
specifier|private
specifier|static
specifier|final
name|int
name|SYNC_HASH_SIZE
init|=
literal|16
decl_stmt|;
comment|// number of bytes in hash
specifier|private
specifier|static
specifier|final
name|int
name|SYNC_SIZE
init|=
literal|4
operator|+
name|SYNC_HASH_SIZE
decl_stmt|;
comment|// escape + hash
comment|/** The number of bytes between sync points. */
specifier|public
specifier|static
specifier|final
name|int
name|SYNC_INTERVAL
init|=
literal|100
operator|*
name|SYNC_SIZE
decl_stmt|;
comment|/**    * KeyBuffer is the key of each record in RCFile. Its on-disk layout is as    * below:    *    *<ul>    *<li>record length in bytes,it is the sum of bytes used to store the key    * part and the value part.</li>    *<li>Key length in bytes, it is how many bytes used by the key part.</li>    *<li>number_of_rows_in_this_record(vint),</li>    *<li>column_1_ondisk_length(vint),</li>    *<li>column_1_row_1_value_plain_length,</li>    *<li>column_1_row_2_value_plain_length,</li>    *<li>....</li>    *<li>column_2_ondisk_length(vint),</li>    *<li>column_2_row_1_value_plain_length,</li>    *<li>column_2_row_2_value_plain_length,</li>    *<li>.... .</li>    *<li>{the end of the key part}</li>    *</ul>    */
specifier|public
specifier|static
class|class
name|KeyBuffer
implements|implements
name|WritableComparable
block|{
comment|// each column's length in the value
specifier|private
name|int
index|[]
name|eachColumnValueLen
init|=
literal|null
decl_stmt|;
specifier|private
name|int
index|[]
name|eachColumnUncompressedValueLen
init|=
literal|null
decl_stmt|;
comment|// stores each cell's length of a column in one DataOutputBuffer element
specifier|private
name|NonSyncDataOutputBuffer
index|[]
name|allCellValLenBuffer
init|=
literal|null
decl_stmt|;
comment|// how many rows in this split
specifier|private
name|int
name|numberRows
init|=
literal|0
decl_stmt|;
comment|// how many columns
specifier|private
name|int
name|columnNumber
init|=
literal|0
decl_stmt|;
comment|// return the number of columns recorded in this file's header
specifier|public
name|int
name|getColumnNumber
parameter_list|()
block|{
return|return
name|columnNumber
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
annotation|@
name|Deprecated
specifier|public
name|KeyBuffer
parameter_list|()
block|{     }
name|KeyBuffer
parameter_list|(
name|int
name|columnNum
parameter_list|)
block|{
name|columnNumber
operator|=
name|columnNum
expr_stmt|;
name|eachColumnValueLen
operator|=
operator|new
name|int
index|[
name|columnNumber
index|]
expr_stmt|;
name|eachColumnUncompressedValueLen
operator|=
operator|new
name|int
index|[
name|columnNumber
index|]
expr_stmt|;
name|allCellValLenBuffer
operator|=
operator|new
name|NonSyncDataOutputBuffer
index|[
name|columnNumber
index|]
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
annotation|@
name|Deprecated
name|KeyBuffer
parameter_list|(
name|int
name|numberRows
parameter_list|,
name|int
name|columnNum
parameter_list|)
block|{
name|this
argument_list|(
name|columnNum
argument_list|)
expr_stmt|;
name|this
operator|.
name|numberRows
operator|=
name|numberRows
expr_stmt|;
block|}
specifier|public
name|void
name|nullColumn
parameter_list|(
name|int
name|columnIndex
parameter_list|)
block|{
name|eachColumnValueLen
index|[
name|columnIndex
index|]
operator|=
literal|0
expr_stmt|;
name|eachColumnUncompressedValueLen
index|[
name|columnIndex
index|]
operator|=
literal|0
expr_stmt|;
name|allCellValLenBuffer
index|[
name|columnIndex
index|]
operator|=
operator|new
name|NonSyncDataOutputBuffer
argument_list|()
expr_stmt|;
block|}
comment|/**      * add in a new column's meta data.      *      * @param columnValueLen      *          this total bytes number of this column's values in this split      * @param colValLenBuffer      *          each cell's length of this column's in this split      */
name|void
name|setColumnLenInfo
parameter_list|(
name|int
name|columnValueLen
parameter_list|,
name|NonSyncDataOutputBuffer
name|colValLenBuffer
parameter_list|,
name|int
name|columnUncompressedValueLen
parameter_list|,
name|int
name|columnIndex
parameter_list|)
block|{
name|eachColumnValueLen
index|[
name|columnIndex
index|]
operator|=
name|columnValueLen
expr_stmt|;
name|eachColumnUncompressedValueLen
index|[
name|columnIndex
index|]
operator|=
name|columnUncompressedValueLen
expr_stmt|;
name|allCellValLenBuffer
index|[
name|columnIndex
index|]
operator|=
name|colValLenBuffer
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|eachColumnValueLen
operator|=
operator|new
name|int
index|[
name|columnNumber
index|]
expr_stmt|;
name|eachColumnUncompressedValueLen
operator|=
operator|new
name|int
index|[
name|columnNumber
index|]
expr_stmt|;
name|allCellValLenBuffer
operator|=
operator|new
name|NonSyncDataOutputBuffer
index|[
name|columnNumber
index|]
expr_stmt|;
name|numberRows
operator|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columnNumber
condition|;
name|i
operator|++
control|)
block|{
name|eachColumnValueLen
index|[
name|i
index|]
operator|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|eachColumnUncompressedValueLen
index|[
name|i
index|]
operator|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|int
name|bufLen
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
name|allCellValLenBuffer
index|[
name|i
index|]
operator|==
literal|null
condition|)
block|{
name|allCellValLenBuffer
index|[
name|i
index|]
operator|=
operator|new
name|NonSyncDataOutputBuffer
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|allCellValLenBuffer
index|[
name|i
index|]
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
name|allCellValLenBuffer
index|[
name|i
index|]
operator|.
name|write
argument_list|(
name|in
argument_list|,
name|bufLen
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
comment|// out.writeInt(numberRows);
name|WritableUtils
operator|.
name|writeVLong
argument_list|(
name|out
argument_list|,
name|numberRows
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|eachColumnValueLen
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|WritableUtils
operator|.
name|writeVLong
argument_list|(
name|out
argument_list|,
name|eachColumnValueLen
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|WritableUtils
operator|.
name|writeVLong
argument_list|(
name|out
argument_list|,
name|eachColumnUncompressedValueLen
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|NonSyncDataOutputBuffer
name|colRowsLenBuf
init|=
name|allCellValLenBuffer
index|[
name|i
index|]
decl_stmt|;
name|int
name|bufLen
init|=
name|colRowsLenBuf
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|WritableUtils
operator|.
name|writeVLong
argument_list|(
name|out
argument_list|,
name|bufLen
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|colRowsLenBuf
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|bufLen
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * get number of bytes to store the keyBuffer.      *      * @return number of bytes used to store this KeyBuffer on disk      * @throws IOException      */
specifier|public
name|int
name|getSize
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|ret
operator|+=
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|numberRows
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|eachColumnValueLen
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|+=
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|eachColumnValueLen
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|eachColumnUncompressedValueLen
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|allCellValLenBuffer
index|[
name|i
index|]
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|allCellValLenBuffer
index|[
name|i
index|]
operator|.
name|getLength
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
name|Object
name|arg0
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"compareTo not supported in class "
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
specifier|public
name|int
index|[]
name|getEachColumnUncompressedValueLen
parameter_list|()
block|{
return|return
name|eachColumnUncompressedValueLen
return|;
block|}
specifier|public
name|int
index|[]
name|getEachColumnValueLen
parameter_list|()
block|{
return|return
name|eachColumnValueLen
return|;
block|}
comment|/**      * @return the numberRows      */
specifier|public
name|int
name|getNumberRows
parameter_list|()
block|{
return|return
name|numberRows
return|;
block|}
block|}
comment|/**    * ValueBuffer is the value of each record in RCFile. Its on-disk layout is as    * below:    *<ul>    *<li>Compressed or plain data of [column_1_row_1_value,    * column_1_row_2_value,....]</li>    *<li>Compressed or plain data of [column_2_row_1_value,    * column_2_row_2_value,....]</li>    *</ul>    */
specifier|public
specifier|static
class|class
name|ValueBuffer
implements|implements
name|WritableComparable
block|{
class|class
name|LazyDecompressionCallbackImpl
implements|implements
name|LazyDecompressionCallback
block|{
name|int
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|colIndex
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
name|LazyDecompressionCallbackImpl
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|colIndex
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
name|this
operator|.
name|colIndex
operator|=
name|colIndex
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|decompress
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|decompressedFlag
index|[
name|index
index|]
operator|||
name|codec
operator|==
literal|null
condition|)
block|{
return|return
name|loadedColumnsValueBuffer
index|[
name|index
index|]
operator|.
name|getData
argument_list|()
return|;
block|}
name|NonSyncDataOutputBuffer
name|compressedData
init|=
name|compressedColumnsValueBuffer
index|[
name|index
index|]
decl_stmt|;
name|decompressBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
name|DataInputStream
name|valueIn
init|=
operator|new
name|DataInputStream
argument_list|(
name|deflatFilter
argument_list|)
decl_stmt|;
name|deflatFilter
operator|.
name|resetState
argument_list|()
expr_stmt|;
if|if
condition|(
name|deflatFilter
operator|instanceof
name|SchemaAwareCompressionInputStream
condition|)
block|{
operator|(
operator|(
name|SchemaAwareCompressionInputStream
operator|)
name|deflatFilter
operator|)
operator|.
name|setColumnIndex
argument_list|(
name|colIndex
argument_list|)
expr_stmt|;
block|}
name|decompressBuffer
operator|.
name|reset
argument_list|(
name|compressedData
operator|.
name|getData
argument_list|()
argument_list|,
name|keyBuffer
operator|.
name|eachColumnValueLen
index|[
name|colIndex
index|]
argument_list|)
expr_stmt|;
name|NonSyncDataOutputBuffer
name|decompressedColBuf
init|=
name|loadedColumnsValueBuffer
index|[
name|index
index|]
decl_stmt|;
name|decompressedColBuf
operator|.
name|reset
argument_list|()
expr_stmt|;
name|decompressedColBuf
operator|.
name|write
argument_list|(
name|valueIn
argument_list|,
name|keyBuffer
operator|.
name|eachColumnUncompressedValueLen
index|[
name|colIndex
index|]
argument_list|)
expr_stmt|;
name|decompressedFlag
index|[
name|index
index|]
operator|=
literal|true
expr_stmt|;
name|numCompressed
operator|--
expr_stmt|;
return|return
name|decompressedColBuf
operator|.
name|getData
argument_list|()
return|;
block|}
block|}
comment|// used to load columns' value into memory
specifier|private
name|NonSyncDataOutputBuffer
index|[]
name|loadedColumnsValueBuffer
init|=
literal|null
decl_stmt|;
specifier|private
name|NonSyncDataOutputBuffer
index|[]
name|compressedColumnsValueBuffer
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
index|[]
name|decompressedFlag
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|numCompressed
decl_stmt|;
specifier|private
name|LazyDecompressionCallbackImpl
index|[]
name|lazyDecompressCallbackObjs
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|lazyDecompress
init|=
literal|true
decl_stmt|;
name|boolean
name|inited
init|=
literal|false
decl_stmt|;
comment|// used for readFields
name|KeyBuffer
name|keyBuffer
decl_stmt|;
specifier|private
name|int
name|columnNumber
init|=
literal|0
decl_stmt|;
comment|// set true for columns that needed to skip loading into memory.
name|boolean
index|[]
name|skippedColIDs
init|=
literal|null
decl_stmt|;
name|CompressionCodec
name|codec
decl_stmt|;
name|Decompressor
name|valDecompressor
init|=
literal|null
decl_stmt|;
name|NonSyncDataInputBuffer
name|decompressBuffer
init|=
operator|new
name|NonSyncDataInputBuffer
argument_list|()
decl_stmt|;
name|CompressionInputStream
name|deflatFilter
init|=
literal|null
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
annotation|@
name|Deprecated
specifier|public
name|ValueBuffer
parameter_list|()
throws|throws
name|IOException
block|{     }
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
annotation|@
name|Deprecated
specifier|public
name|ValueBuffer
parameter_list|(
name|KeyBuffer
name|keyBuffer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|keyBuffer
argument_list|,
name|keyBuffer
operator|.
name|columnNumber
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
annotation|@
name|Deprecated
specifier|public
name|ValueBuffer
parameter_list|(
name|KeyBuffer
name|keyBuffer
parameter_list|,
name|boolean
index|[]
name|skippedColIDs
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|keyBuffer
argument_list|,
name|keyBuffer
operator|.
name|columnNumber
argument_list|,
name|skippedColIDs
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
annotation|@
name|Deprecated
specifier|public
name|ValueBuffer
parameter_list|(
name|KeyBuffer
name|currentKey
parameter_list|,
name|int
name|columnNumber
parameter_list|,
name|boolean
index|[]
name|skippedCols
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|currentKey
argument_list|,
name|columnNumber
argument_list|,
name|skippedCols
argument_list|,
name|codec
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ValueBuffer
parameter_list|(
name|KeyBuffer
name|currentKey
parameter_list|,
name|int
name|columnNumber
parameter_list|,
name|boolean
index|[]
name|skippedCols
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|boolean
name|lazyDecompress
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|lazyDecompress
operator|=
name|lazyDecompress
expr_stmt|;
name|keyBuffer
operator|=
name|currentKey
expr_stmt|;
name|this
operator|.
name|columnNumber
operator|=
name|columnNumber
expr_stmt|;
if|if
condition|(
name|skippedCols
operator|!=
literal|null
operator|&&
name|skippedCols
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|skippedColIDs
operator|=
name|skippedCols
expr_stmt|;
block|}
else|else
block|{
name|skippedColIDs
operator|=
operator|new
name|boolean
index|[
name|columnNumber
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|skippedColIDs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|skippedColIDs
index|[
name|i
index|]
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|int
name|skipped
init|=
literal|0
decl_stmt|;
for|for
control|(
name|boolean
name|currentSkip
range|:
name|skippedColIDs
control|)
block|{
if|if
condition|(
name|currentSkip
condition|)
block|{
name|skipped
operator|++
expr_stmt|;
block|}
block|}
name|loadedColumnsValueBuffer
operator|=
operator|new
name|NonSyncDataOutputBuffer
index|[
name|columnNumber
operator|-
name|skipped
index|]
expr_stmt|;
name|decompressedFlag
operator|=
operator|new
name|boolean
index|[
name|columnNumber
operator|-
name|skipped
index|]
expr_stmt|;
name|lazyDecompressCallbackObjs
operator|=
operator|new
name|LazyDecompressionCallbackImpl
index|[
name|columnNumber
operator|-
name|skipped
index|]
expr_stmt|;
name|compressedColumnsValueBuffer
operator|=
operator|new
name|NonSyncDataOutputBuffer
index|[
name|columnNumber
operator|-
name|skipped
index|]
expr_stmt|;
name|this
operator|.
name|codec
operator|=
name|codec
expr_stmt|;
if|if
condition|(
name|codec
operator|!=
literal|null
condition|)
block|{
name|valDecompressor
operator|=
name|CodecPool
operator|.
name|getDecompressor
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|deflatFilter
operator|=
name|codec
operator|.
name|createInputStream
argument_list|(
name|decompressBuffer
argument_list|,
name|valDecompressor
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|codec
operator|!=
literal|null
condition|)
block|{
name|numCompressed
operator|=
name|decompressedFlag
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|numCompressed
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|int
name|k
init|=
literal|0
init|,
name|readIndex
init|=
literal|0
init|;
name|k
operator|<
name|columnNumber
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|skippedColIDs
index|[
name|k
index|]
condition|)
block|{
continue|continue;
block|}
name|loadedColumnsValueBuffer
index|[
name|readIndex
index|]
operator|=
operator|new
name|NonSyncDataOutputBuffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|codec
operator|!=
literal|null
condition|)
block|{
name|decompressedFlag
index|[
name|readIndex
index|]
operator|=
literal|false
expr_stmt|;
name|lazyDecompressCallbackObjs
index|[
name|readIndex
index|]
operator|=
operator|new
name|LazyDecompressionCallbackImpl
argument_list|(
name|readIndex
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|compressedColumnsValueBuffer
index|[
name|readIndex
index|]
operator|=
operator|new
name|NonSyncDataOutputBuffer
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|decompressedFlag
index|[
name|readIndex
index|]
operator|=
literal|true
expr_stmt|;
block|}
name|readIndex
operator|++
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
annotation|@
name|Deprecated
specifier|public
name|void
name|setColumnValueBuffer
parameter_list|(
name|NonSyncDataOutputBuffer
name|valBuffer
parameter_list|,
name|int
name|addIndex
parameter_list|)
block|{
name|loadedColumnsValueBuffer
index|[
name|addIndex
index|]
operator|=
name|valBuffer
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|addIndex
init|=
literal|0
decl_stmt|;
name|int
name|skipTotal
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columnNumber
condition|;
name|i
operator|++
control|)
block|{
name|int
name|vaRowsLen
init|=
name|keyBuffer
operator|.
name|eachColumnValueLen
index|[
name|i
index|]
decl_stmt|;
comment|// skip this column
if|if
condition|(
name|skippedColIDs
index|[
name|i
index|]
condition|)
block|{
name|skipTotal
operator|+=
name|vaRowsLen
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|skipTotal
operator|!=
literal|0
condition|)
block|{
name|in
operator|.
name|skipBytes
argument_list|(
name|skipTotal
argument_list|)
expr_stmt|;
name|skipTotal
operator|=
literal|0
expr_stmt|;
block|}
name|NonSyncDataOutputBuffer
name|valBuf
decl_stmt|;
if|if
condition|(
name|codec
operator|!=
literal|null
condition|)
block|{
comment|// load into compressed buf first
name|valBuf
operator|=
name|compressedColumnsValueBuffer
index|[
name|addIndex
index|]
expr_stmt|;
block|}
else|else
block|{
name|valBuf
operator|=
name|loadedColumnsValueBuffer
index|[
name|addIndex
index|]
expr_stmt|;
block|}
name|valBuf
operator|.
name|reset
argument_list|()
expr_stmt|;
name|valBuf
operator|.
name|write
argument_list|(
name|in
argument_list|,
name|vaRowsLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
operator|!=
literal|null
condition|)
block|{
name|decompressedFlag
index|[
name|addIndex
index|]
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|lazyDecompress
condition|)
block|{
name|lazyDecompressCallbackObjs
index|[
name|addIndex
index|]
operator|.
name|decompress
argument_list|()
expr_stmt|;
name|decompressedFlag
index|[
name|addIndex
index|]
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|addIndex
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|codec
operator|!=
literal|null
condition|)
block|{
name|numCompressed
operator|=
name|decompressedFlag
operator|.
name|length
expr_stmt|;
block|}
if|if
condition|(
name|skipTotal
operator|!=
literal|0
condition|)
block|{
name|in
operator|.
name|skipBytes
argument_list|(
name|skipTotal
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|codec
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|NonSyncDataOutputBuffer
name|currentBuf
range|:
name|compressedColumnsValueBuffer
control|)
block|{
name|out
operator|.
name|write
argument_list|(
name|currentBuf
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|currentBuf
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|NonSyncDataOutputBuffer
name|currentBuf
range|:
name|loadedColumnsValueBuffer
control|)
block|{
name|out
operator|.
name|write
argument_list|(
name|currentBuf
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|currentBuf
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|nullColumn
parameter_list|(
name|int
name|columnIndex
parameter_list|)
block|{
if|if
condition|(
name|codec
operator|!=
literal|null
condition|)
block|{
name|compressedColumnsValueBuffer
index|[
name|columnIndex
index|]
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|loadedColumnsValueBuffer
index|[
name|columnIndex
index|]
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|clearColumnBuffer
parameter_list|()
throws|throws
name|IOException
block|{
name|decompressBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
for|for
control|(
name|NonSyncDataOutputBuffer
name|element
range|:
name|loadedColumnsValueBuffer
control|)
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|codec
operator|!=
literal|null
condition|)
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|decompressBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|valDecompressor
operator|!=
literal|null
condition|)
block|{
comment|// Make sure we only return valDecompressor once.
name|CodecPool
operator|.
name|returnDecompressor
argument_list|(
name|valDecompressor
argument_list|)
expr_stmt|;
name|valDecompressor
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
name|Object
name|arg0
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"compareTo not supported in class "
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Create a metadata object with alternating key-value pairs.    * Eg. metadata(key1, value1, key2, value2)    */
specifier|public
specifier|static
name|Metadata
name|createMetadata
parameter_list|(
name|Text
modifier|...
name|values
parameter_list|)
block|{
if|if
condition|(
name|values
operator|.
name|length
operator|%
literal|2
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Must have a matched set of "
operator|+
literal|"key-value pairs. "
operator|+
name|values
operator|.
name|length
operator|+
literal|" strings supplied."
argument_list|)
throw|;
block|}
name|Metadata
name|result
init|=
operator|new
name|Metadata
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|result
operator|.
name|set
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|values
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Write KeyBuffer/ValueBuffer pairs to a RCFile. RCFile's format is    * compatible with SequenceFile's.    *    */
specifier|public
specifier|static
class|class
name|Writer
block|{
name|Configuration
name|conf
decl_stmt|;
name|FSDataOutputStream
name|out
decl_stmt|;
name|CompressionCodec
name|codec
init|=
literal|null
decl_stmt|;
name|Metadata
name|metadata
init|=
literal|null
decl_stmt|;
comment|// Insert a globally unique 16-byte value every few entries, so that one
comment|// can seek into the middle of a file and then synchronize with record
comment|// starts and ends by scanning for this value.
name|long
name|lastSyncPos
decl_stmt|;
comment|// position of last sync
name|byte
index|[]
name|sync
decl_stmt|;
comment|// 16 random bytes
block|{
try|try
block|{
name|MessageDigest
name|digester
init|=
name|MessageDigest
operator|.
name|getInstance
argument_list|(
literal|"MD5"
argument_list|)
decl_stmt|;
name|long
name|time
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|digester
operator|.
name|update
argument_list|(
operator|(
operator|new
name|UID
argument_list|()
operator|+
literal|"@"
operator|+
name|time
operator|)
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
name|sync
operator|=
name|digester
operator|.
name|digest
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|// how many records the writer buffers before it writes to disk
specifier|private
name|int
name|RECORD_INTERVAL
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
comment|// the max size of memory for buffering records before writes them out
specifier|private
name|int
name|columnsBufferSize
init|=
literal|4
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
comment|// 4M
comment|// the conf string for COLUMNS_BUFFER_SIZE
specifier|public
specifier|static
name|String
name|COLUMNS_BUFFER_SIZE_CONF_STR
init|=
literal|"hive.io.rcfile.record.buffer.size"
decl_stmt|;
comment|// how many records already buffered
specifier|private
name|int
name|bufferedRecords
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|ColumnBuffer
index|[]
name|columnBuffers
decl_stmt|;
specifier|private
name|int
name|columnNumber
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|int
index|[]
name|columnValuePlainLength
decl_stmt|;
name|KeyBuffer
name|key
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|int
index|[]
name|plainTotalColumnLength
decl_stmt|;
specifier|private
specifier|final
name|int
index|[]
name|comprTotalColumnLength
decl_stmt|;
name|boolean
name|useNewMagic
init|=
literal|true
decl_stmt|;
comment|/*      * used for buffering appends before flush them out      */
class|class
name|ColumnBuffer
block|{
comment|// used for buffer a column's values
name|NonSyncDataOutputBuffer
name|columnValBuffer
decl_stmt|;
comment|// used to store each value's length
name|NonSyncDataOutputBuffer
name|valLenBuffer
decl_stmt|;
comment|/*        * use a run-length encoding. We only record run length if a same        * 'prevValueLen' occurs more than one time. And we negative the run        * length to distinguish a runLength and a normal value length. For        * example, if the values' lengths are 1,1,1,2, we record 1, ~2,2. And for        * value lengths 1,2,3 we record 1,2,3.        */
name|int
name|runLength
init|=
literal|0
decl_stmt|;
name|int
name|prevValueLength
init|=
operator|-
literal|1
decl_stmt|;
name|ColumnBuffer
parameter_list|()
throws|throws
name|IOException
block|{
name|columnValBuffer
operator|=
operator|new
name|NonSyncDataOutputBuffer
argument_list|()
expr_stmt|;
name|valLenBuffer
operator|=
operator|new
name|NonSyncDataOutputBuffer
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|append
parameter_list|(
name|BytesRefWritable
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|writeDataTo
argument_list|(
name|columnValBuffer
argument_list|)
expr_stmt|;
name|int
name|currentLen
init|=
name|data
operator|.
name|getLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|prevValueLength
operator|<
literal|0
condition|)
block|{
name|startNewGroup
argument_list|(
name|currentLen
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|currentLen
operator|!=
name|prevValueLength
condition|)
block|{
name|flushGroup
argument_list|()
expr_stmt|;
name|startNewGroup
argument_list|(
name|currentLen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|runLength
operator|++
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|startNewGroup
parameter_list|(
name|int
name|currentLen
parameter_list|)
block|{
name|prevValueLength
operator|=
name|currentLen
expr_stmt|;
name|runLength
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|void
name|clear
parameter_list|()
throws|throws
name|IOException
block|{
name|valLenBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
name|columnValBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
name|prevValueLength
operator|=
operator|-
literal|1
expr_stmt|;
name|runLength
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|void
name|flushGroup
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|prevValueLength
operator|>=
literal|0
condition|)
block|{
name|WritableUtils
operator|.
name|writeVLong
argument_list|(
name|valLenBuffer
argument_list|,
name|prevValueLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|runLength
operator|>
literal|0
condition|)
block|{
name|WritableUtils
operator|.
name|writeVLong
argument_list|(
name|valLenBuffer
argument_list|,
operator|~
name|runLength
argument_list|)
expr_stmt|;
block|}
name|runLength
operator|=
operator|-
literal|1
expr_stmt|;
name|prevValueLength
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|long
name|getLength
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|out
operator|.
name|getPos
argument_list|()
return|;
block|}
comment|/** Constructs a RCFile Writer. */
specifier|public
name|Writer
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
literal|null
argument_list|,
operator|new
name|Metadata
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs a RCFile Writer.      *      * @param fs      *          the file system used      * @param conf      *          the configuration file      * @param name      *          the file name      * @throws IOException      */
specifier|public
name|Writer
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
name|progress
argument_list|,
operator|new
name|Metadata
argument_list|()
argument_list|,
name|codec
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs a RCFile Writer.      *      * @param fs      *          the file system used      * @param conf      *          the configuration file      * @param name      *          the file name      * @param progress a progress meter to update as the file is written      * @param metadata a string to string map in the file header      * @throws IOException      */
specifier|public
name|Writer
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|Metadata
name|metadata
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
name|fs
operator|.
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"io.file.buffer.size"
argument_list|,
literal|4096
argument_list|)
argument_list|,
name|ShimLoader
operator|.
name|getHadoopShims
argument_list|()
operator|.
name|getDefaultReplication
argument_list|(
name|fs
argument_list|,
name|name
argument_list|)
argument_list|,
name|ShimLoader
operator|.
name|getHadoopShims
argument_list|()
operator|.
name|getDefaultBlockSize
argument_list|(
name|fs
argument_list|,
name|name
argument_list|)
argument_list|,
name|progress
argument_list|,
name|metadata
argument_list|,
name|codec
argument_list|)
expr_stmt|;
block|}
comment|/**      *      * Constructs a RCFile Writer.      *      * @param fs      *          the file system used      * @param conf      *          the configuration file      * @param name      *          the file name      * @param bufferSize the size of the file buffer      * @param replication the number of replicas for the file      * @param blockSize the block size of the file      * @param progress the progress meter for writing the file      * @param metadata a string to string map in the file header      * @throws IOException      */
specifier|public
name|Writer
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|Metadata
name|metadata
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|)
throws|throws
name|IOException
block|{
name|RECORD_INTERVAL
operator|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|HIVE_RCFILE_RECORD_INTERVAL
argument_list|)
expr_stmt|;
name|columnNumber
operator|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|HIVE_RCFILE_COLUMN_NUMBER_CONF
argument_list|)
expr_stmt|;
if|if
condition|(
name|metadata
operator|==
literal|null
condition|)
block|{
name|metadata
operator|=
operator|new
name|Metadata
argument_list|()
expr_stmt|;
block|}
name|metadata
operator|.
name|set
argument_list|(
operator|new
name|Text
argument_list|(
name|COLUMN_NUMBER_METADATA_STR
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
literal|""
operator|+
name|columnNumber
argument_list|)
argument_list|)
expr_stmt|;
name|columnsBufferSize
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|COLUMNS_BUFFER_SIZE_CONF_STR
argument_list|,
literal|4
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|columnValuePlainLength
operator|=
operator|new
name|int
index|[
name|columnNumber
index|]
expr_stmt|;
name|columnBuffers
operator|=
operator|new
name|ColumnBuffer
index|[
name|columnNumber
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columnNumber
condition|;
name|i
operator|++
control|)
block|{
name|columnBuffers
index|[
name|i
index|]
operator|=
operator|new
name|ColumnBuffer
argument_list|()
expr_stmt|;
block|}
name|init
argument_list|(
name|conf
argument_list|,
name|fs
operator|.
name|create
argument_list|(
name|name
argument_list|,
literal|true
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|)
argument_list|,
name|codec
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
name|initializeFileHeader
argument_list|()
expr_stmt|;
name|writeFileHeader
argument_list|()
expr_stmt|;
name|finalizeFileHeader
argument_list|()
expr_stmt|;
name|key
operator|=
operator|new
name|KeyBuffer
argument_list|(
name|columnNumber
argument_list|)
expr_stmt|;
name|plainTotalColumnLength
operator|=
operator|new
name|int
index|[
name|columnNumber
index|]
expr_stmt|;
name|comprTotalColumnLength
operator|=
operator|new
name|int
index|[
name|columnNumber
index|]
expr_stmt|;
block|}
comment|/** Write the initial part of file header. */
name|void
name|initializeFileHeader
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|useNewMagic
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|MAGIC
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|CURRENT_VERSION
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|write
argument_list|(
name|ORIGINAL_MAGIC_VERSION
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Write the final part of file header. */
name|void
name|finalizeFileHeader
parameter_list|()
throws|throws
name|IOException
block|{
name|out
operator|.
name|write
argument_list|(
name|sync
argument_list|)
expr_stmt|;
comment|// write the sync bytes
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
comment|// flush header
block|}
name|boolean
name|isCompressed
parameter_list|()
block|{
return|return
name|codec
operator|!=
literal|null
return|;
block|}
comment|/** Write and flush the file header. */
name|void
name|writeFileHeader
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|useNewMagic
condition|)
block|{
name|out
operator|.
name|writeBoolean
argument_list|(
name|isCompressed
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|KeyBuffer
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|ValueBuffer
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBoolean
argument_list|(
name|isCompressed
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBoolean
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isCompressed
argument_list|()
condition|)
block|{
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
operator|(
name|codec
operator|.
name|getClass
argument_list|()
operator|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|metadata
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
name|void
name|init
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FSDataOutputStream
name|out
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|out
operator|=
name|out
expr_stmt|;
name|this
operator|.
name|codec
operator|=
name|codec
expr_stmt|;
name|this
operator|.
name|metadata
operator|=
name|metadata
expr_stmt|;
name|this
operator|.
name|useNewMagic
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|HIVEUSEEXPLICITRCFILEHEADER
operator|.
name|varname
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** Returns the compression codec of data in this file. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
annotation|@
name|Deprecated
specifier|public
name|CompressionCodec
name|getCompressionCodec
parameter_list|()
block|{
return|return
name|codec
return|;
block|}
comment|/** create a sync point. */
specifier|public
name|void
name|sync
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|sync
operator|!=
literal|null
operator|&&
name|lastSyncPos
operator|!=
name|out
operator|.
name|getPos
argument_list|()
condition|)
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|SYNC_ESCAPE
argument_list|)
expr_stmt|;
comment|// mark the start of the sync
name|out
operator|.
name|write
argument_list|(
name|sync
argument_list|)
expr_stmt|;
comment|// write sync
name|lastSyncPos
operator|=
name|out
operator|.
name|getPos
argument_list|()
expr_stmt|;
comment|// update lastSyncPos
block|}
block|}
comment|/** Returns the configuration of this file. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
annotation|@
name|Deprecated
name|Configuration
name|getConf
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
specifier|private
name|void
name|checkAndWriteSync
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|sync
operator|!=
literal|null
operator|&&
name|out
operator|.
name|getPos
argument_list|()
operator|>=
name|lastSyncPos
operator|+
name|SYNC_INTERVAL
condition|)
block|{
name|sync
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|int
name|columnBufferSize
init|=
literal|0
decl_stmt|;
comment|/**      * Append a row of values. Currently it only can accept<      * {@link BytesRefArrayWritable}. If its<code>size()</code> is less than the      * column number in the file, zero bytes are appended for the empty columns.      * If its size() is greater then the column number in the file, the exceeded      * columns' bytes are ignored.      *      * @param val a BytesRefArrayWritable with the list of serialized columns      * @throws IOException      */
specifier|public
name|void
name|append
parameter_list|(
name|Writable
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
operator|(
name|val
operator|instanceof
name|BytesRefArrayWritable
operator|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Currently the writer can only accept BytesRefArrayWritable"
argument_list|)
throw|;
block|}
name|BytesRefArrayWritable
name|columns
init|=
operator|(
name|BytesRefArrayWritable
operator|)
name|val
decl_stmt|;
name|int
name|size
init|=
name|columns
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|BytesRefWritable
name|cu
init|=
name|columns
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|plainLen
init|=
name|cu
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|columnBufferSize
operator|+=
name|plainLen
expr_stmt|;
name|columnValuePlainLength
index|[
name|i
index|]
operator|+=
name|plainLen
expr_stmt|;
name|columnBuffers
index|[
name|i
index|]
operator|.
name|append
argument_list|(
name|cu
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|<
name|columnNumber
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|columns
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|columnNumber
condition|;
name|i
operator|++
control|)
block|{
name|columnBuffers
index|[
name|i
index|]
operator|.
name|append
argument_list|(
name|BytesRefWritable
operator|.
name|ZeroBytesRefWritable
argument_list|)
expr_stmt|;
block|}
block|}
name|bufferedRecords
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|columnBufferSize
operator|>
name|columnsBufferSize
operator|)
operator|||
operator|(
name|bufferedRecords
operator|>=
name|RECORD_INTERVAL
operator|)
condition|)
block|{
name|flushRecords
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|flushRecords
parameter_list|()
throws|throws
name|IOException
block|{
name|key
operator|.
name|numberRows
operator|=
name|bufferedRecords
expr_stmt|;
name|Compressor
name|compressor
init|=
literal|null
decl_stmt|;
name|NonSyncDataOutputBuffer
name|valueBuffer
init|=
literal|null
decl_stmt|;
name|CompressionOutputStream
name|deflateFilter
init|=
literal|null
decl_stmt|;
name|DataOutputStream
name|deflateOut
init|=
literal|null
decl_stmt|;
name|boolean
name|isCompressed
init|=
name|isCompressed
argument_list|()
decl_stmt|;
name|int
name|valueLength
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isCompressed
condition|)
block|{
name|ReflectionUtils
operator|.
name|setConf
argument_list|(
name|codec
argument_list|,
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|compressor
operator|=
name|CodecPool
operator|.
name|getCompressor
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|valueBuffer
operator|=
operator|new
name|NonSyncDataOutputBuffer
argument_list|()
expr_stmt|;
name|deflateFilter
operator|=
name|codec
operator|.
name|createOutputStream
argument_list|(
name|valueBuffer
argument_list|,
name|compressor
argument_list|)
expr_stmt|;
name|deflateOut
operator|=
operator|new
name|DataOutputStream
argument_list|(
name|deflateFilter
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|columnIndex
init|=
literal|0
init|;
name|columnIndex
operator|<
name|columnNumber
condition|;
name|columnIndex
operator|++
control|)
block|{
name|ColumnBuffer
name|currentBuf
init|=
name|columnBuffers
index|[
name|columnIndex
index|]
decl_stmt|;
name|currentBuf
operator|.
name|flushGroup
argument_list|()
expr_stmt|;
name|NonSyncDataOutputBuffer
name|columnValue
init|=
name|currentBuf
operator|.
name|columnValBuffer
decl_stmt|;
name|int
name|colLen
decl_stmt|;
name|int
name|plainLen
init|=
name|columnValuePlainLength
index|[
name|columnIndex
index|]
decl_stmt|;
if|if
condition|(
name|isCompressed
condition|)
block|{
if|if
condition|(
name|deflateFilter
operator|instanceof
name|SchemaAwareCompressionOutputStream
condition|)
block|{
operator|(
operator|(
name|SchemaAwareCompressionOutputStream
operator|)
name|deflateFilter
operator|)
operator|.
name|setColumnIndex
argument_list|(
name|columnIndex
argument_list|)
expr_stmt|;
block|}
name|deflateFilter
operator|.
name|resetState
argument_list|()
expr_stmt|;
name|deflateOut
operator|.
name|write
argument_list|(
name|columnValue
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|columnValue
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|deflateOut
operator|.
name|flush
argument_list|()
expr_stmt|;
name|deflateFilter
operator|.
name|finish
argument_list|()
expr_stmt|;
comment|// find how much compressed data was added for this column
name|colLen
operator|=
name|valueBuffer
operator|.
name|getLength
argument_list|()
operator|-
name|valueLength
expr_stmt|;
block|}
else|else
block|{
name|colLen
operator|=
name|columnValuePlainLength
index|[
name|columnIndex
index|]
expr_stmt|;
block|}
name|valueLength
operator|+=
name|colLen
expr_stmt|;
name|key
operator|.
name|setColumnLenInfo
argument_list|(
name|colLen
argument_list|,
name|currentBuf
operator|.
name|valLenBuffer
argument_list|,
name|plainLen
argument_list|,
name|columnIndex
argument_list|)
expr_stmt|;
name|plainTotalColumnLength
index|[
name|columnIndex
index|]
operator|+=
name|plainLen
expr_stmt|;
name|comprTotalColumnLength
index|[
name|columnIndex
index|]
operator|+=
name|colLen
expr_stmt|;
name|columnValuePlainLength
index|[
name|columnIndex
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|keyLength
init|=
name|key
operator|.
name|getSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"negative length keys not allowed: "
operator|+
name|key
argument_list|)
throw|;
block|}
if|if
condition|(
name|compressor
operator|!=
literal|null
condition|)
block|{
name|CodecPool
operator|.
name|returnCompressor
argument_list|(
name|compressor
argument_list|)
expr_stmt|;
block|}
comment|// Write the key out
name|writeKey
argument_list|(
name|key
argument_list|,
name|keyLength
operator|+
name|valueLength
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
comment|// write the value out
if|if
condition|(
name|isCompressed
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|valueBuffer
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|valueBuffer
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|columnIndex
init|=
literal|0
init|;
name|columnIndex
operator|<
name|columnNumber
condition|;
operator|++
name|columnIndex
control|)
block|{
name|NonSyncDataOutputBuffer
name|buf
init|=
name|columnBuffers
index|[
name|columnIndex
index|]
operator|.
name|columnValBuffer
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
name|buf
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// clear the columnBuffers
name|clearColumnBuffers
argument_list|()
expr_stmt|;
name|bufferedRecords
operator|=
literal|0
expr_stmt|;
name|columnBufferSize
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * flush a block out without doing anything except compressing the key part.      */
specifier|public
name|void
name|flushBlock
parameter_list|(
name|KeyBuffer
name|keyBuffer
parameter_list|,
name|ValueBuffer
name|valueBuffer
parameter_list|,
name|int
name|recordLen
parameter_list|,
name|int
name|keyLength
parameter_list|,
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
name|int
name|compressedKeyLen
parameter_list|)
throws|throws
name|IOException
block|{
name|writeKey
argument_list|(
name|keyBuffer
argument_list|,
name|recordLen
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
name|valueBuffer
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|writeKey
parameter_list|(
name|KeyBuffer
name|keyBuffer
parameter_list|,
name|int
name|recordLen
parameter_list|,
name|int
name|keyLength
parameter_list|)
throws|throws
name|IOException
block|{
name|checkAndWriteSync
argument_list|()
expr_stmt|;
comment|// sync
name|out
operator|.
name|writeInt
argument_list|(
name|recordLen
argument_list|)
expr_stmt|;
comment|// total record length
name|out
operator|.
name|writeInt
argument_list|(
name|keyLength
argument_list|)
expr_stmt|;
comment|// key portion length
if|if
condition|(
name|this
operator|.
name|isCompressed
argument_list|()
condition|)
block|{
name|Compressor
name|compressor
init|=
name|CodecPool
operator|.
name|getCompressor
argument_list|(
name|codec
argument_list|)
decl_stmt|;
name|NonSyncDataOutputBuffer
name|compressionBuffer
init|=
operator|new
name|NonSyncDataOutputBuffer
argument_list|()
decl_stmt|;
name|CompressionOutputStream
name|deflateFilter
init|=
name|codec
operator|.
name|createOutputStream
argument_list|(
name|compressionBuffer
argument_list|,
name|compressor
argument_list|)
decl_stmt|;
name|DataOutputStream
name|deflateOut
init|=
operator|new
name|DataOutputStream
argument_list|(
name|deflateFilter
argument_list|)
decl_stmt|;
comment|//compress key and write key out
name|compressionBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
name|deflateFilter
operator|.
name|resetState
argument_list|()
expr_stmt|;
name|keyBuffer
operator|.
name|write
argument_list|(
name|deflateOut
argument_list|)
expr_stmt|;
name|deflateOut
operator|.
name|flush
argument_list|()
expr_stmt|;
name|deflateFilter
operator|.
name|finish
argument_list|()
expr_stmt|;
name|int
name|compressedKeyLen
init|=
name|compressionBuffer
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|compressedKeyLen
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|compressionBuffer
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|compressedKeyLen
argument_list|)
expr_stmt|;
name|CodecPool
operator|.
name|returnCompressor
argument_list|(
name|compressor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|keyLength
argument_list|)
expr_stmt|;
name|keyBuffer
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|clearColumnBuffers
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columnNumber
condition|;
name|i
operator|++
control|)
block|{
name|columnBuffers
index|[
name|i
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|bufferedRecords
operator|>
literal|0
condition|)
block|{
name|flushRecords
argument_list|()
expr_stmt|;
block|}
name|clearColumnBuffers
argument_list|()
expr_stmt|;
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
comment|// Close the underlying stream if we own it...
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|out
operator|=
literal|null
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columnNumber
condition|;
name|i
operator|++
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Column#"
operator|+
name|i
operator|+
literal|" : Plain Total Column Value Length: "
operator|+
name|plainTotalColumnLength
index|[
name|i
index|]
operator|+
literal|",  Compr Total Column Value Length: "
operator|+
name|comprTotalColumnLength
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Read KeyBuffer/ValueBuffer pairs from a RCFile.    *    */
specifier|public
specifier|static
class|class
name|Reader
block|{
specifier|private
specifier|static
class|class
name|SelectedColumn
block|{
specifier|public
name|int
name|colIndex
decl_stmt|;
specifier|public
name|int
name|rowReadIndex
decl_stmt|;
specifier|public
name|int
name|runLength
decl_stmt|;
specifier|public
name|int
name|prvLength
decl_stmt|;
specifier|public
name|boolean
name|isNulled
decl_stmt|;
block|}
specifier|private
specifier|final
name|Path
name|file
decl_stmt|;
specifier|private
specifier|final
name|FSDataInputStream
name|in
decl_stmt|;
specifier|private
name|byte
name|version
decl_stmt|;
specifier|private
name|CompressionCodec
name|codec
init|=
literal|null
decl_stmt|;
specifier|private
name|Metadata
name|metadata
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|sync
init|=
operator|new
name|byte
index|[
name|SYNC_HASH_SIZE
index|]
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|syncCheck
init|=
operator|new
name|byte
index|[
name|SYNC_HASH_SIZE
index|]
decl_stmt|;
specifier|private
name|boolean
name|syncSeen
decl_stmt|;
specifier|private
name|long
name|lastSeenSyncPos
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|headerEnd
decl_stmt|;
specifier|private
specifier|final
name|long
name|end
decl_stmt|;
specifier|private
name|int
name|currentKeyLength
decl_stmt|;
specifier|private
name|int
name|currentRecordLength
decl_stmt|;
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
specifier|private
specifier|final
name|ValueBuffer
name|currentValue
decl_stmt|;
specifier|private
name|int
name|readRowsIndexInBuffer
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|recordsNumInValBuffer
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|columnNumber
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|loadColumnNum
decl_stmt|;
specifier|private
name|int
name|passedRowsNum
init|=
literal|0
decl_stmt|;
comment|// Should we try to tolerate corruption? Default is No.
specifier|private
name|boolean
name|tolerateCorruptions
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|decompress
init|=
literal|false
decl_stmt|;
specifier|private
name|Decompressor
name|keyDecompressor
decl_stmt|;
name|NonSyncDataOutputBuffer
name|keyDecompressedData
init|=
operator|new
name|NonSyncDataOutputBuffer
argument_list|()
decl_stmt|;
comment|//Current state of each selected column - e.g. current run length, etc.
comment|// The size of the array is equal to the number of selected columns
specifier|private
specifier|final
name|SelectedColumn
index|[]
name|selectedColumns
decl_stmt|;
comment|// map of original column id -> index among selected columns
specifier|private
specifier|final
name|int
index|[]
name|revPrjColIDs
decl_stmt|;
comment|// column value lengths for each of the selected columns
specifier|private
specifier|final
name|NonSyncDataInputBuffer
index|[]
name|colValLenBufferReadIn
decl_stmt|;
comment|/** Create a new RCFile reader. */
specifier|public
name|Reader
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|file
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|file
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"io.file.buffer.size"
argument_list|,
literal|4096
argument_list|)
argument_list|,
name|conf
argument_list|,
literal|0
argument_list|,
name|fs
operator|.
name|getFileStatus
argument_list|(
name|file
argument_list|)
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Create a new RCFile reader. */
specifier|public
name|Reader
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|file
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|tolerateCorruptions
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HIVE_RCFILE_TOLERATE_CORRUPTIONS
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
literal|"io.file.buffer.size"
argument_list|,
name|bufferSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|in
operator|=
name|openFile
argument_list|(
name|fs
argument_list|,
name|file
argument_list|,
name|bufferSize
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|length
expr_stmt|;
name|boolean
name|succeed
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|start
operator|>
literal|0
condition|)
block|{
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
name|seek
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|init
argument_list|()
expr_stmt|;
block|}
name|succeed
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|succeed
condition|)
block|{
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|!=
literal|null
operator|&&
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception in closing "
operator|+
name|in
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|columnNumber
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|metadata
operator|.
name|get
argument_list|(
operator|new
name|Text
argument_list|(
name|COLUMN_NUMBER_METADATA_STR
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|notSkipIDs
init|=
name|ColumnProjectionUtils
operator|.
name|getReadColumnIDs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|boolean
index|[]
name|skippedColIDs
init|=
operator|new
name|boolean
index|[
name|columnNumber
index|]
decl_stmt|;
if|if
condition|(
name|ColumnProjectionUtils
operator|.
name|isReadAllColumns
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|Arrays
operator|.
name|fill
argument_list|(
name|skippedColIDs
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|notSkipIDs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Arrays
operator|.
name|fill
argument_list|(
name|skippedColIDs
argument_list|,
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|read
range|:
name|notSkipIDs
control|)
block|{
if|if
condition|(
name|read
operator|<
name|columnNumber
condition|)
block|{
name|skippedColIDs
index|[
name|read
index|]
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// select count(1)
name|Arrays
operator|.
name|fill
argument_list|(
name|skippedColIDs
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|loadColumnNum
operator|=
name|columnNumber
expr_stmt|;
if|if
condition|(
name|skippedColIDs
operator|.
name|length
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|boolean
name|skippedColID
range|:
name|skippedColIDs
control|)
block|{
if|if
condition|(
name|skippedColID
condition|)
block|{
name|loadColumnNum
operator|-=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|revPrjColIDs
operator|=
operator|new
name|int
index|[
name|columnNumber
index|]
expr_stmt|;
comment|// get list of selected column IDs
name|selectedColumns
operator|=
operator|new
name|SelectedColumn
index|[
name|loadColumnNum
index|]
expr_stmt|;
name|colValLenBufferReadIn
operator|=
operator|new
name|NonSyncDataInputBuffer
index|[
name|loadColumnNum
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|j
init|=
literal|0
init|;
name|i
operator|<
name|columnNumber
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|skippedColIDs
index|[
name|i
index|]
condition|)
block|{
name|SelectedColumn
name|col
init|=
operator|new
name|SelectedColumn
argument_list|()
decl_stmt|;
name|col
operator|.
name|colIndex
operator|=
name|i
expr_stmt|;
name|col
operator|.
name|runLength
operator|=
literal|0
expr_stmt|;
name|col
operator|.
name|prvLength
operator|=
operator|-
literal|1
expr_stmt|;
name|col
operator|.
name|rowReadIndex
operator|=
literal|0
expr_stmt|;
name|selectedColumns
index|[
name|j
index|]
operator|=
name|col
expr_stmt|;
name|colValLenBufferReadIn
index|[
name|j
index|]
operator|=
operator|new
name|NonSyncDataInputBuffer
argument_list|()
expr_stmt|;
name|revPrjColIDs
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
else|else
block|{
name|revPrjColIDs
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|currentKey
operator|=
name|createKeyBuffer
argument_list|()
expr_stmt|;
name|boolean
name|lazyDecompress
init|=
operator|!
name|tolerateCorruptions
decl_stmt|;
name|currentValue
operator|=
operator|new
name|ValueBuffer
argument_list|(
literal|null
argument_list|,
name|columnNumber
argument_list|,
name|skippedColIDs
argument_list|,
name|codec
argument_list|,
name|lazyDecompress
argument_list|)
expr_stmt|;
block|}
comment|/**      * Return the metadata (Text to Text map) that was written into the      * file.      */
specifier|public
name|Metadata
name|getMetadata
parameter_list|()
block|{
return|return
name|metadata
return|;
block|}
comment|/**      * Return the metadata value associated with the given key.      * @param key the metadata key to retrieve      */
specifier|public
name|Text
name|getMetadataValueOf
parameter_list|(
name|Text
name|key
parameter_list|)
block|{
return|return
name|metadata
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/**      * Override this method to specialize the type of      * {@link FSDataInputStream} returned.      */
specifier|protected
name|FSDataInputStream
name|openFile
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|file
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|long
name|length
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|open
argument_list|(
name|file
argument_list|,
name|bufferSize
argument_list|)
return|;
block|}
specifier|private
name|void
name|init
parameter_list|()
throws|throws
name|IOException
block|{
name|byte
index|[]
name|magic
init|=
operator|new
name|byte
index|[
name|MAGIC
operator|.
name|length
index|]
decl_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|magic
argument_list|)
expr_stmt|;
if|if
condition|(
name|Arrays
operator|.
name|equals
argument_list|(
name|magic
argument_list|,
name|ORIGINAL_MAGIC
argument_list|)
condition|)
block|{
name|byte
name|vers
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
if|if
condition|(
name|vers
operator|!=
name|ORIGINAL_MAGIC_VERSION_WITH_METADATA
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|file
operator|+
literal|" is a version "
operator|+
name|vers
operator|+
literal|" SequenceFile instead of an RCFile."
argument_list|)
throw|;
block|}
name|version
operator|=
name|ORIGINAL_VERSION
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|magic
argument_list|,
name|MAGIC
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|file
operator|+
literal|" not a RCFile and has magic of "
operator|+
operator|new
name|String
argument_list|(
name|magic
argument_list|)
argument_list|)
throw|;
block|}
comment|// Set 'version'
name|version
operator|=
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
if|if
condition|(
name|version
operator|>
name|CURRENT_VERSION
condition|)
block|{
throw|throw
operator|new
name|VersionMismatchException
argument_list|(
operator|(
name|byte
operator|)
name|CURRENT_VERSION
argument_list|,
name|version
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|version
operator|==
name|ORIGINAL_VERSION
condition|)
block|{
try|try
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|keyCls
init|=
name|conf
operator|.
name|getClassByName
argument_list|(
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|)
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|valCls
init|=
name|conf
operator|.
name|getClassByName
argument_list|(
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|keyCls
operator|.
name|equals
argument_list|(
name|KeyBuffer
operator|.
name|class
argument_list|)
operator|||
operator|!
name|valCls
operator|.
name|equals
argument_list|(
name|ValueBuffer
operator|.
name|class
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|file
operator|+
literal|" not a RCFile"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|file
operator|+
literal|" not a RCFile"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|decompress
operator|=
name|in
operator|.
name|readBoolean
argument_list|()
expr_stmt|;
comment|// is compressed?
if|if
condition|(
name|version
operator|==
name|ORIGINAL_VERSION
condition|)
block|{
comment|// is block-compressed? it should be always false.
name|boolean
name|blkCompressed
init|=
name|in
operator|.
name|readBoolean
argument_list|()
decl_stmt|;
if|if
condition|(
name|blkCompressed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|file
operator|+
literal|" not a RCFile."
argument_list|)
throw|;
block|}
block|}
comment|// setup the compression codec
if|if
condition|(
name|decompress
condition|)
block|{
name|String
name|codecClassname
init|=
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|)
decl_stmt|;
try|try
block|{
name|Class
argument_list|<
name|?
extends|extends
name|CompressionCodec
argument_list|>
name|codecClass
init|=
name|conf
operator|.
name|getClassByName
argument_list|(
name|codecClassname
argument_list|)
operator|.
name|asSubclass
argument_list|(
name|CompressionCodec
operator|.
name|class
argument_list|)
decl_stmt|;
name|codec
operator|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|codecClass
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|cnfe
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown codec: "
operator|+
name|codecClassname
argument_list|,
name|cnfe
argument_list|)
throw|;
block|}
name|keyDecompressor
operator|=
name|CodecPool
operator|.
name|getDecompressor
argument_list|(
name|codec
argument_list|)
expr_stmt|;
block|}
name|metadata
operator|=
operator|new
name|Metadata
argument_list|()
expr_stmt|;
name|metadata
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|sync
argument_list|)
expr_stmt|;
comment|// read sync bytes
name|headerEnd
operator|=
name|in
operator|.
name|getPos
argument_list|()
expr_stmt|;
block|}
comment|/** Return the current byte position in the input file. */
specifier|public
specifier|synchronized
name|long
name|getPosition
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|in
operator|.
name|getPos
argument_list|()
return|;
block|}
comment|/**      * Set the current byte position in the input file.      *      *<p>      * The position passed must be a position returned by      * {@link RCFile.Writer#getLength()} when writing this file. To seek to an      * arbitrary position, use {@link RCFile.Reader#sync(long)}. In another      * words, the current seek can only seek to the end of the file. For other      * positions, use {@link RCFile.Reader#sync(long)}.      */
specifier|public
specifier|synchronized
name|void
name|seek
parameter_list|(
name|long
name|position
parameter_list|)
throws|throws
name|IOException
block|{
name|in
operator|.
name|seek
argument_list|(
name|position
argument_list|)
expr_stmt|;
block|}
comment|/**      * Resets the values which determine if there are more rows in the buffer      *      * This can be used after one calls seek or sync, if one called next before that.      * Otherwise, the seek or sync will have no effect, it will continue to get rows from the      * buffer built up from the call to next.      */
specifier|public
specifier|synchronized
name|void
name|resetBuffer
parameter_list|()
block|{
name|readRowsIndexInBuffer
operator|=
literal|0
expr_stmt|;
name|recordsNumInValBuffer
operator|=
literal|0
expr_stmt|;
block|}
comment|/** Seek to the next sync mark past a given position. */
specifier|public
specifier|synchronized
name|void
name|sync
parameter_list|(
name|long
name|position
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|position
operator|+
name|SYNC_SIZE
operator|>=
name|end
condition|)
block|{
name|seek
argument_list|(
name|end
argument_list|)
expr_stmt|;
return|return;
block|}
comment|//this is to handle syn(pos) where pos< headerEnd.
if|if
condition|(
name|position
operator|<
name|headerEnd
condition|)
block|{
comment|// seek directly to first record
name|in
operator|.
name|seek
argument_list|(
name|headerEnd
argument_list|)
expr_stmt|;
comment|// note the sync marker "seen" in the header
name|syncSeen
operator|=
literal|true
expr_stmt|;
return|return;
block|}
try|try
block|{
name|seek
argument_list|(
name|position
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|// skip escape
name|int
name|prefix
init|=
name|sync
operator|.
name|length
decl_stmt|;
name|int
name|n
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"io.bytes.per.checksum"
argument_list|,
literal|512
argument_list|)
decl_stmt|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
name|prefix
operator|+
name|n
index|]
decl_stmt|;
name|n
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|n
argument_list|,
name|end
operator|-
name|in
operator|.
name|getPos
argument_list|()
argument_list|)
expr_stmt|;
comment|/* fill array with a pattern that will never match sync */
name|Arrays
operator|.
name|fill
argument_list|(
name|buffer
argument_list|,
call|(
name|byte
call|)
argument_list|(
operator|~
name|sync
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
operator|&&
operator|(
name|in
operator|.
name|getPos
argument_list|()
operator|+
name|n
operator|)
operator|<=
name|end
condition|)
block|{
name|position
operator|=
name|in
operator|.
name|getPos
argument_list|()
expr_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|buffer
argument_list|,
name|prefix
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* the buffer has n+sync bytes */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sync
operator|.
name|length
operator|&&
name|sync
index|[
name|j
index|]
operator|==
name|buffer
index|[
name|i
operator|+
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
comment|/* nothing */
block|}
if|if
condition|(
name|j
operator|==
name|sync
operator|.
name|length
condition|)
block|{
comment|/* simplified from (position + (i - prefix) + sync.length) - SYNC_SIZE */
name|in
operator|.
name|seek
argument_list|(
name|position
operator|+
name|i
operator|-
name|SYNC_SIZE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* move the last 16 bytes to the prefix area */
name|System
operator|.
name|arraycopy
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|.
name|length
operator|-
name|prefix
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|n
argument_list|,
name|end
operator|-
name|in
operator|.
name|getPos
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ChecksumException
name|e
parameter_list|)
block|{
comment|// checksum failure
name|handleChecksumException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|handleChecksumException
parameter_list|(
name|ChecksumException
name|e
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"io.skip.checksum.errors"
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Bad checksum at "
operator|+
name|getPosition
argument_list|()
operator|+
literal|". Skipping entries."
argument_list|)
expr_stmt|;
name|sync
argument_list|(
name|getPosition
argument_list|()
operator|+
name|conf
operator|.
name|getInt
argument_list|(
literal|"io.bytes.per.checksum"
argument_list|,
literal|512
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
specifier|private
name|KeyBuffer
name|createKeyBuffer
parameter_list|()
block|{
return|return
operator|new
name|KeyBuffer
argument_list|(
name|columnNumber
argument_list|)
return|;
block|}
comment|/**      * Read and return the next record length, potentially skipping over a sync      * block.      *      * @return the length of the next record or -1 if there is no next record      * @throws IOException      */
specifier|private
specifier|synchronized
name|int
name|readRecordLength
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|in
operator|.
name|getPos
argument_list|()
operator|>=
name|end
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|int
name|length
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|sync
operator|!=
literal|null
operator|&&
name|length
operator|==
name|SYNC_ESCAPE
condition|)
block|{
comment|// process
comment|// a
comment|// sync entry
name|lastSeenSyncPos
operator|=
name|in
operator|.
name|getPos
argument_list|()
operator|-
literal|4
expr_stmt|;
comment|// minus SYNC_ESCAPE's length
name|in
operator|.
name|readFully
argument_list|(
name|syncCheck
argument_list|)
expr_stmt|;
comment|// read syncCheck
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|sync
argument_list|,
name|syncCheck
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"File is corrupt!"
argument_list|)
throw|;
block|}
name|syncSeen
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|getPos
argument_list|()
operator|>=
name|end
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|length
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
comment|// re-read length
block|}
else|else
block|{
name|syncSeen
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|length
return|;
block|}
specifier|private
name|void
name|seekToNextKeyBuffer
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|keyInit
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|currentValue
operator|.
name|inited
condition|)
block|{
name|in
operator|.
name|skip
argument_list|(
name|currentRecordLength
operator|-
name|currentKeyLength
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|int
name|compressedKeyLen
init|=
literal|0
decl_stmt|;
name|NonSyncDataInputBuffer
name|keyDataIn
init|=
operator|new
name|NonSyncDataInputBuffer
argument_list|()
decl_stmt|;
name|NonSyncDataInputBuffer
name|keyDecompressBuffer
init|=
operator|new
name|NonSyncDataInputBuffer
argument_list|()
decl_stmt|;
name|NonSyncDataOutputBuffer
name|keyTempBuffer
init|=
operator|new
name|NonSyncDataOutputBuffer
argument_list|()
decl_stmt|;
name|KeyBuffer
name|currentKey
init|=
literal|null
decl_stmt|;
name|boolean
name|keyInit
init|=
literal|false
decl_stmt|;
specifier|protected
name|int
name|nextKeyBuffer
parameter_list|()
throws|throws
name|IOException
block|{
name|seekToNextKeyBuffer
argument_list|()
expr_stmt|;
name|currentRecordLength
operator|=
name|readRecordLength
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentRecordLength
operator|==
operator|-
literal|1
condition|)
block|{
name|keyInit
operator|=
literal|false
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|currentKeyLength
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|compressedKeyLen
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|decompress
condition|)
block|{
name|keyTempBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
name|keyTempBuffer
operator|.
name|write
argument_list|(
name|in
argument_list|,
name|compressedKeyLen
argument_list|)
expr_stmt|;
name|keyDecompressBuffer
operator|.
name|reset
argument_list|(
name|keyTempBuffer
operator|.
name|getData
argument_list|()
argument_list|,
name|compressedKeyLen
argument_list|)
expr_stmt|;
name|CompressionInputStream
name|deflatFilter
init|=
name|codec
operator|.
name|createInputStream
argument_list|(
name|keyDecompressBuffer
argument_list|,
name|keyDecompressor
argument_list|)
decl_stmt|;
name|DataInputStream
name|compressedIn
init|=
operator|new
name|DataInputStream
argument_list|(
name|deflatFilter
argument_list|)
decl_stmt|;
name|deflatFilter
operator|.
name|resetState
argument_list|()
expr_stmt|;
name|keyDecompressedData
operator|.
name|reset
argument_list|()
expr_stmt|;
name|keyDecompressedData
operator|.
name|write
argument_list|(
name|compressedIn
argument_list|,
name|currentKeyLength
argument_list|)
expr_stmt|;
name|keyDataIn
operator|.
name|reset
argument_list|(
name|keyDecompressedData
operator|.
name|getData
argument_list|()
argument_list|,
name|currentKeyLength
argument_list|)
expr_stmt|;
name|currentKey
operator|.
name|readFields
argument_list|(
name|keyDataIn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|currentKey
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
name|keyInit
operator|=
literal|true
expr_stmt|;
name|currentValue
operator|.
name|inited
operator|=
literal|false
expr_stmt|;
name|readRowsIndexInBuffer
operator|=
literal|0
expr_stmt|;
name|recordsNumInValBuffer
operator|=
name|currentKey
operator|.
name|numberRows
expr_stmt|;
for|for
control|(
name|int
name|selIx
init|=
literal|0
init|;
name|selIx
operator|<
name|selectedColumns
operator|.
name|length
condition|;
name|selIx
operator|++
control|)
block|{
name|SelectedColumn
name|col
init|=
name|selectedColumns
index|[
name|selIx
index|]
decl_stmt|;
name|int
name|colIx
init|=
name|col
operator|.
name|colIndex
decl_stmt|;
name|NonSyncDataOutputBuffer
name|buf
init|=
name|currentKey
operator|.
name|allCellValLenBuffer
index|[
name|colIx
index|]
decl_stmt|;
name|colValLenBufferReadIn
index|[
name|selIx
index|]
operator|.
name|reset
argument_list|(
name|buf
operator|.
name|getData
argument_list|()
argument_list|,
name|buf
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|col
operator|.
name|rowReadIndex
operator|=
literal|0
expr_stmt|;
name|col
operator|.
name|runLength
operator|=
literal|0
expr_stmt|;
name|col
operator|.
name|prvLength
operator|=
operator|-
literal|1
expr_stmt|;
name|col
operator|.
name|isNulled
operator|=
name|colValLenBufferReadIn
index|[
name|selIx
index|]
operator|.
name|getLength
argument_list|()
operator|==
literal|0
expr_stmt|;
block|}
return|return
name|currentKeyLength
return|;
block|}
specifier|protected
name|void
name|currentValueBuffer
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|keyInit
condition|)
block|{
name|nextKeyBuffer
argument_list|()
expr_stmt|;
block|}
name|currentValue
operator|.
name|keyBuffer
operator|=
name|currentKey
expr_stmt|;
name|currentValue
operator|.
name|clearColumnBuffer
argument_list|()
expr_stmt|;
name|currentValue
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|currentValue
operator|.
name|inited
operator|=
literal|true
expr_stmt|;
block|}
specifier|public
name|boolean
name|nextBlock
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|keyLength
init|=
name|nextKeyBuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|keyLength
operator|>
literal|0
condition|)
block|{
name|currentValueBuffer
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|rowFetched
init|=
literal|false
decl_stmt|;
comment|// use this buffer to hold column's cells value length for usages in
comment|// getColumn(), instead of using colValLenBufferReadIn directly.
specifier|private
specifier|final
name|NonSyncDataInputBuffer
name|fetchColumnTempBuf
init|=
operator|new
name|NonSyncDataInputBuffer
argument_list|()
decl_stmt|;
comment|/**      * Fetch all data in the buffer for a given column. This is useful for      * columnar operators, which perform operations on an array data of one      * column. It should be used together with {@link #nextColumnsBatch()}.      * Calling getColumn() with not change the result of      * {@link #next(LongWritable)} and      * {@link #getCurrentRow(BytesRefArrayWritable)}.      *      * @param columnID the number of the column to get 0 to N-1      * @throws IOException      */
specifier|public
name|BytesRefArrayWritable
name|getColumn
parameter_list|(
name|int
name|columnID
parameter_list|,
name|BytesRefArrayWritable
name|rest
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|selColIdx
init|=
name|revPrjColIDs
index|[
name|columnID
index|]
decl_stmt|;
if|if
condition|(
name|selColIdx
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|rest
operator|==
literal|null
condition|)
block|{
name|rest
operator|=
operator|new
name|BytesRefArrayWritable
argument_list|()
expr_stmt|;
block|}
name|rest
operator|.
name|resetValid
argument_list|(
name|recordsNumInValBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|currentValue
operator|.
name|inited
condition|)
block|{
name|currentValueBuffer
argument_list|()
expr_stmt|;
block|}
name|int
name|columnNextRowStart
init|=
literal|0
decl_stmt|;
name|fetchColumnTempBuf
operator|.
name|reset
argument_list|(
name|currentKey
operator|.
name|allCellValLenBuffer
index|[
name|columnID
index|]
operator|.
name|getData
argument_list|()
argument_list|,
name|currentKey
operator|.
name|allCellValLenBuffer
index|[
name|columnID
index|]
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|SelectedColumn
name|selCol
init|=
name|selectedColumns
index|[
name|selColIdx
index|]
decl_stmt|;
name|byte
index|[]
name|uncompData
init|=
literal|null
decl_stmt|;
name|ValueBuffer
operator|.
name|LazyDecompressionCallbackImpl
name|decompCallBack
init|=
literal|null
decl_stmt|;
name|boolean
name|decompressed
init|=
name|currentValue
operator|.
name|decompressedFlag
index|[
name|selColIdx
index|]
decl_stmt|;
if|if
condition|(
name|decompressed
condition|)
block|{
name|uncompData
operator|=
name|currentValue
operator|.
name|loadedColumnsValueBuffer
index|[
name|selColIdx
index|]
operator|.
name|getData
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|decompCallBack
operator|=
name|currentValue
operator|.
name|lazyDecompressCallbackObjs
index|[
name|selColIdx
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|recordsNumInValBuffer
condition|;
name|i
operator|++
control|)
block|{
name|colAdvanceRow
argument_list|(
name|selColIdx
argument_list|,
name|selCol
argument_list|)
expr_stmt|;
name|int
name|length
init|=
name|selCol
operator|.
name|prvLength
decl_stmt|;
name|BytesRefWritable
name|currentCell
init|=
name|rest
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|decompressed
condition|)
block|{
name|currentCell
operator|.
name|set
argument_list|(
name|uncompData
argument_list|,
name|columnNextRowStart
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|currentCell
operator|.
name|set
argument_list|(
name|decompCallBack
argument_list|,
name|columnNextRowStart
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|columnNextRowStart
operator|=
name|columnNextRowStart
operator|+
name|length
expr_stmt|;
block|}
return|return
name|rest
return|;
block|}
comment|/**      * Read in next key buffer and throw any data in current key buffer and      * current value buffer. It will influence the result of      * {@link #next(LongWritable)} and      * {@link #getCurrentRow(BytesRefArrayWritable)}      *      * @return whether there still has records or not      * @throws IOException      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
annotation|@
name|Deprecated
specifier|public
specifier|synchronized
name|boolean
name|nextColumnsBatch
parameter_list|()
throws|throws
name|IOException
block|{
name|passedRowsNum
operator|+=
operator|(
name|recordsNumInValBuffer
operator|-
name|readRowsIndexInBuffer
operator|)
expr_stmt|;
return|return
name|nextKeyBuffer
argument_list|()
operator|>
literal|0
return|;
block|}
comment|/**      * Returns how many rows we fetched with next(). It only means how many rows      * are read by next(). The returned result may be smaller than actual number      * of rows passed by, because {@link #seek(long)},      * {@link #nextColumnsBatch()} can change the underlying key buffer and      * value buffer.      *      * @return next row number      * @throws IOException      */
specifier|public
specifier|synchronized
name|boolean
name|next
parameter_list|(
name|LongWritable
name|readRows
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|hasRecordsInBuffer
argument_list|()
condition|)
block|{
name|readRows
operator|.
name|set
argument_list|(
name|passedRowsNum
argument_list|)
expr_stmt|;
name|readRowsIndexInBuffer
operator|++
expr_stmt|;
name|passedRowsNum
operator|++
expr_stmt|;
name|rowFetched
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|keyInit
operator|=
literal|false
expr_stmt|;
block|}
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|tolerateCorruptions
condition|)
block|{
name|ret
operator|=
name|nextKeyValueTolerateCorruptions
argument_list|()
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|ret
operator|=
name|nextKeyBuffer
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|eof
parameter_list|)
block|{
name|eof
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|>
literal|0
operator|)
operator|&&
name|next
argument_list|(
name|readRows
argument_list|)
return|;
block|}
specifier|private
name|int
name|nextKeyValueTolerateCorruptions
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|currentOffset
init|=
name|in
operator|.
name|getPos
argument_list|()
decl_stmt|;
name|int
name|ret
decl_stmt|;
try|try
block|{
name|ret
operator|=
name|nextKeyBuffer
argument_list|()
expr_stmt|;
name|this
operator|.
name|currentValueBuffer
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// A BlockMissingException indicates a temporary error,
comment|// not a corruption. Re-throw this exception.
name|String
name|msg
init|=
name|ioe
operator|.
name|getMessage
argument_list|()
decl_stmt|;
if|if
condition|(
name|msg
operator|!=
literal|null
operator|&&
name|msg
operator|.
name|startsWith
argument_list|(
name|BLOCK_MISSING_MESSAGE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Re-throwing block-missing exception"
operator|+
name|ioe
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
comment|// We have an IOException other than a BlockMissingException.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Ignoring IOException in file "
operator|+
name|file
operator|+
literal|" after offset "
operator|+
name|currentOffset
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// We got an exception that is not IOException
comment|// (typically OOM, IndexOutOfBounds, InternalError).
comment|// This is most likely a corruption.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Ignoring unknown error in "
operator|+
name|file
operator|+
literal|" after offset "
operator|+
name|currentOffset
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
specifier|public
name|boolean
name|hasRecordsInBuffer
parameter_list|()
block|{
return|return
name|readRowsIndexInBuffer
operator|<
name|recordsNumInValBuffer
return|;
block|}
comment|/**      * get the current row used,make sure called {@link #next(LongWritable)}      * first.      *      * @throws IOException      */
specifier|public
specifier|synchronized
name|void
name|getCurrentRow
parameter_list|(
name|BytesRefArrayWritable
name|ret
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|keyInit
operator|||
name|rowFetched
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|tolerateCorruptions
condition|)
block|{
if|if
condition|(
operator|!
name|currentValue
operator|.
name|inited
condition|)
block|{
name|currentValueBuffer
argument_list|()
expr_stmt|;
block|}
name|ret
operator|.
name|resetValid
argument_list|(
name|columnNumber
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|currentValue
operator|.
name|inited
condition|)
block|{
name|currentValueBuffer
argument_list|()
expr_stmt|;
comment|// do this only when not initialized, but we may need to find a way to
comment|// tell the caller how to initialize the valid size
name|ret
operator|.
name|resetValid
argument_list|(
name|columnNumber
argument_list|)
expr_stmt|;
block|}
block|}
comment|// we do not use BytesWritable here to avoid the byte-copy from
comment|// DataOutputStream to BytesWritable
if|if
condition|(
name|currentValue
operator|.
name|numCompressed
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|selectedColumns
operator|.
name|length
condition|;
operator|++
name|j
control|)
block|{
name|SelectedColumn
name|col
init|=
name|selectedColumns
index|[
name|j
index|]
decl_stmt|;
name|int
name|i
init|=
name|col
operator|.
name|colIndex
decl_stmt|;
if|if
condition|(
name|col
operator|.
name|isNulled
condition|)
block|{
name|ret
operator|.
name|set
argument_list|(
name|i
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BytesRefWritable
name|ref
init|=
name|ret
operator|.
name|unCheckedGet
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|colAdvanceRow
argument_list|(
name|j
argument_list|,
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentValue
operator|.
name|decompressedFlag
index|[
name|j
index|]
condition|)
block|{
name|ref
operator|.
name|set
argument_list|(
name|currentValue
operator|.
name|loadedColumnsValueBuffer
index|[
name|j
index|]
operator|.
name|getData
argument_list|()
argument_list|,
name|col
operator|.
name|rowReadIndex
argument_list|,
name|col
operator|.
name|prvLength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ref
operator|.
name|set
argument_list|(
name|currentValue
operator|.
name|lazyDecompressCallbackObjs
index|[
name|j
index|]
argument_list|,
name|col
operator|.
name|rowReadIndex
argument_list|,
name|col
operator|.
name|prvLength
argument_list|)
expr_stmt|;
block|}
name|col
operator|.
name|rowReadIndex
operator|+=
name|col
operator|.
name|prvLength
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// This version of the loop eliminates a condition check and branch
comment|// and is measurably faster (20% or so)
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|selectedColumns
operator|.
name|length
condition|;
operator|++
name|j
control|)
block|{
name|SelectedColumn
name|col
init|=
name|selectedColumns
index|[
name|j
index|]
decl_stmt|;
name|int
name|i
init|=
name|col
operator|.
name|colIndex
decl_stmt|;
if|if
condition|(
name|col
operator|.
name|isNulled
condition|)
block|{
name|ret
operator|.
name|set
argument_list|(
name|i
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BytesRefWritable
name|ref
init|=
name|ret
operator|.
name|unCheckedGet
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|colAdvanceRow
argument_list|(
name|j
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|ref
operator|.
name|set
argument_list|(
name|currentValue
operator|.
name|loadedColumnsValueBuffer
index|[
name|j
index|]
operator|.
name|getData
argument_list|()
argument_list|,
name|col
operator|.
name|rowReadIndex
argument_list|,
name|col
operator|.
name|prvLength
argument_list|)
expr_stmt|;
name|col
operator|.
name|rowReadIndex
operator|+=
name|col
operator|.
name|prvLength
expr_stmt|;
block|}
block|}
block|}
name|rowFetched
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * Advance column state to the next now: update offsets, run lengths etc      * @param selCol - index among selectedColumns      * @param col - column object to update the state of.  prvLength will be      *        set to the new read position      * @throws IOException      */
specifier|private
name|void
name|colAdvanceRow
parameter_list|(
name|int
name|selCol
parameter_list|,
name|SelectedColumn
name|col
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|col
operator|.
name|runLength
operator|>
literal|0
condition|)
block|{
operator|--
name|col
operator|.
name|runLength
expr_stmt|;
block|}
else|else
block|{
name|int
name|length
init|=
operator|(
name|int
operator|)
name|WritableUtils
operator|.
name|readVLong
argument_list|(
name|colValLenBufferReadIn
index|[
name|selCol
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
comment|// we reach a runlength here, use the previous length and reset
comment|// runlength
name|col
operator|.
name|runLength
operator|=
operator|(
operator|~
name|length
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|col
operator|.
name|prvLength
operator|=
name|length
expr_stmt|;
name|col
operator|.
name|runLength
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/** Returns true iff the previous call to next passed a sync mark. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|public
name|boolean
name|syncSeen
parameter_list|()
block|{
return|return
name|syncSeen
return|;
block|}
comment|/** Returns the last seen sync position. */
specifier|public
name|long
name|lastSeenSyncPos
parameter_list|()
block|{
return|return
name|lastSeenSyncPos
return|;
block|}
comment|/** Returns the name of the file. */
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|file
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|public
name|boolean
name|isCompressedRCFile
parameter_list|()
block|{
return|return
name|this
operator|.
name|decompress
return|;
block|}
comment|/** Close the reader. */
specifier|public
name|void
name|close
parameter_list|()
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|currentValue
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|decompress
condition|)
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|keyDecompressedData
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyDecompressor
operator|!=
literal|null
condition|)
block|{
comment|// Make sure we only return keyDecompressor once.
name|CodecPool
operator|.
name|returnDecompressor
argument_list|(
name|keyDecompressor
argument_list|)
expr_stmt|;
name|keyDecompressor
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
comment|/**      * return the KeyBuffer object used in the reader. Internally in each      * reader, there is only one KeyBuffer object, which gets reused for every      * block.      */
specifier|public
name|KeyBuffer
name|getCurrentKeyBufferObj
parameter_list|()
block|{
return|return
name|this
operator|.
name|currentKey
return|;
block|}
comment|/**      * return the ValueBuffer object used in the reader. Internally in each      * reader, there is only one ValueBuffer object, which gets reused for every      * block.      */
specifier|public
name|ValueBuffer
name|getCurrentValueBufferObj
parameter_list|()
block|{
return|return
name|this
operator|.
name|currentValue
return|;
block|}
comment|//return the current block's length
specifier|public
name|int
name|getCurrentBlockLength
parameter_list|()
block|{
return|return
name|this
operator|.
name|currentRecordLength
return|;
block|}
comment|//return the current block's key length
specifier|public
name|int
name|getCurrentKeyLength
parameter_list|()
block|{
return|return
name|this
operator|.
name|currentKeyLength
return|;
block|}
comment|//return the current block's compressed key length
specifier|public
name|int
name|getCurrentCompressedKeyLen
parameter_list|()
block|{
return|return
name|this
operator|.
name|compressedKeyLen
return|;
block|}
comment|//return the CompressionCodec used for this file
specifier|public
name|CompressionCodec
name|getCompressionCodec
parameter_list|()
block|{
return|return
name|this
operator|.
name|codec
return|;
block|}
block|}
block|}
end_class

end_unit

