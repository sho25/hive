begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|rmi
operator|.
name|server
operator|.
name|UID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|MessageDigest
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ChecksumException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|CodecPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|columnar
operator|.
name|BytesRefArrayWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|columnar
operator|.
name|BytesRefWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|VersionMismatchException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
operator|.
name|Metadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|CompressionCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|CompressionInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|CompressionOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|Compressor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|Decompressor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Progressable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_comment
comment|/**  *<code>RCFile</code>s, short of Record Columnar File, are flat files  * consisting of binary key/value pairs, which shares much similarity with  *<code>SequenceFile</code>.  *   * RCFile stores columns of a table in a record columnar way. It first  * partitions rows horizontally into row splits. and then it vertically  * partitions each row split in a columnar way. RCFile first stores the meta  * data of a row split, as the key part of a record, and all the data of a row  * split as the value part. When writing, RCFile.Writer first holds records'  * value bytes in memory, and determines a row split if the raw bytes size of  * buffered records overflow a given parameter<tt>Writer.columnsBufferSize</tt>,  * which can be set like:<code>conf.setInt(COLUMNS_BUFFER_SIZE_CONF_STR,           4 * 1024 * 1024)</code> .  *<p>  *<code>RCFile</code> provides {@link Writer}, {@link Reader} and classes for  * writing, reading respectively.  *</p>  *   *<p>  * RCFile stores columns of a table in a record columnar way. It first  * partitions rows horizontally into row splits. and then it vertically  * partitions each row split in a columnar way. RCFile first stores the meta  * data of a row split, as the key part of a record, and all the data of a row  * split as the value part.  *</p>  *   *<p>  * RCFile compresses values in a more fine-grained manner then record level  * compression. However, It currently does not support compress the key part  * yet. The actual compression algorithm used to compress key and/or values can  * be specified by using the appropriate {@link CompressionCodec}.  *</p>  *   *<p>  * The {@link Reader} is used to read and explain the bytes of RCFile.  *</p>  *   *<h4 id="Formats">RCFile Formats</h4>  *   *   *<h5 id="Header">RC Header</h5>  *<ul>  *<li>version - 3 bytes of magic header<b>SEQ</b>, followed by 1 byte of  * actual version number (e.g. SEQ4 or SEQ6)</li>  *<li>keyClassName -KeyBuffer's class name</li>  *<li>valueClassName - ValueBuffer's class name</li>  *<li>compression - A boolean which specifies if compression is turned on for  * keys/values in this file.</li>  *<li>blockCompression - always false. this field is kept for compatible with  * SequeceFile's format</li>  *<li>compression codec -<code>CompressionCodec</code> class which is used for  * compression of keys and/or values (if compression is enabled).</li>  *<li>metadata - {@link Metadata} for this file.</li>  *<li>sync - A sync marker to denote end of the header.</li>  *</ul>  *   *<h5>RCFile Format</h5>  *<ul>  *<li><a href="#Header">Header</a></li>  *<li>Record  *<li>Key part  *<ul>  *<li>Record length in bytes</li>  *<li>Key length in bytes</li>  *<li>Number_of_rows_in_this_record(vint)</li>  *<li>Column_1_ondisk_length(vint)</li>  *<li>Column_1_row_1_value_plain_length</li>  *<li>Column_1_row_2_value_plain_length</li>  *<li>...</li>  *<li>Column_2_ondisk_length(vint)</li>  *<li>Column_2_row_1_value_plain_length</li>  *<li>Column_2_row_2_value_plain_length</li>  *<li>...</li>  *</ul>  *</li>  *</li>  *<li>Value part  *<ul>  *<li>Compressed or plain data of [column_1_row_1_value,  * column_1_row_2_value,....]</li>  *<li>Compressed or plain data of [column_2_row_1_value,  * column_2_row_2_value,....]</li>  *</ul>  *</li>  *</ul>  *   */
end_comment

begin_class
specifier|public
class|class
name|RCFile
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|RCFile
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
name|String
name|RECORD_INTERVAL_CONF_STR
init|=
literal|"hive.io.rcfile.record.interval"
decl_stmt|;
specifier|public
specifier|static
name|String
name|COLUMN_NUMBER_METADATA_STR
init|=
literal|"hive.io.rcfile.column.number"
decl_stmt|;
specifier|public
specifier|static
name|String
name|COLUMN_NUMBER_CONF_STR
init|=
literal|"hive.io.rcfile.column.number.conf"
decl_stmt|;
comment|/*    * these header and Sync are kept from SequenceFile, for compatible of    * SequenceFile's format.    */
specifier|private
specifier|static
specifier|final
name|byte
name|VERSION_WITH_METADATA
init|=
operator|(
name|byte
operator|)
literal|6
decl_stmt|;
specifier|private
specifier|static
name|byte
index|[]
name|VERSION
init|=
operator|new
name|byte
index|[]
block|{
operator|(
name|byte
operator|)
literal|'S'
block|,
operator|(
name|byte
operator|)
literal|'E'
block|,
operator|(
name|byte
operator|)
literal|'Q'
block|,
name|VERSION_WITH_METADATA
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|SYNC_ESCAPE
init|=
operator|-
literal|1
decl_stmt|;
comment|// "length" of sync entries
specifier|private
specifier|static
specifier|final
name|int
name|SYNC_HASH_SIZE
init|=
literal|16
decl_stmt|;
comment|// number of bytes in hash
specifier|private
specifier|static
specifier|final
name|int
name|SYNC_SIZE
init|=
literal|4
operator|+
name|SYNC_HASH_SIZE
decl_stmt|;
comment|// escape + hash
comment|/** The number of bytes between sync points. */
specifier|public
specifier|static
specifier|final
name|int
name|SYNC_INTERVAL
init|=
literal|100
operator|*
name|SYNC_SIZE
decl_stmt|;
comment|/**    * KeyBuffer is the key of each record in RCFile. Its on-disk layout is as    * below:    *     *<ul>    *<li>record length in bytes,it is the sum of bytes used to store the key    * part and the value part.</li>    *<li>Key length in bytes, it is how many bytes used by the key part.</li>    *<li>number_of_rows_in_this_record(vint),</li>    *<li>column_1_ondisk_length(vint),</li>    *<li>column_1_row_1_value_plain_length,</li>    *<li>column_1_row_2_value_plain_length,</li>    *<li>....</li>    *<li>column_2_ondisk_length(vint),</li>    *<li>column_2_row_1_value_plain_length,</li>    *<li>column_2_row_2_value_plain_length,</li>    *<li>.... .</li>    *<li>{the end of the key part}</li>    *</ul>    */
specifier|static
class|class
name|KeyBuffer
implements|implements
name|Writable
block|{
comment|// each column's value length in a split
specifier|private
name|int
index|[]
name|eachColumnValueLen
init|=
literal|null
decl_stmt|;
specifier|private
name|int
index|[]
name|eachColumnUncompressedValueLen
init|=
literal|null
decl_stmt|;
comment|// stores each cell's length of a column in one DataOutputBuffer element
specifier|private
name|NonSyncDataOutputBuffer
index|[]
name|allCellValLenBuffer
init|=
literal|null
decl_stmt|;
comment|// how many rows in this split
specifier|private
name|int
name|numberRows
init|=
literal|0
decl_stmt|;
comment|// how many columns
specifier|private
name|int
name|columnNumber
init|=
literal|0
decl_stmt|;
name|KeyBuffer
parameter_list|(
name|int
name|columnNumber
parameter_list|)
block|{
name|this
argument_list|(
literal|0
argument_list|,
name|columnNumber
argument_list|)
expr_stmt|;
block|}
name|KeyBuffer
parameter_list|(
name|int
name|numberRows
parameter_list|,
name|int
name|columnNum
parameter_list|)
block|{
name|columnNumber
operator|=
name|columnNum
expr_stmt|;
name|eachColumnValueLen
operator|=
operator|new
name|int
index|[
name|columnNumber
index|]
expr_stmt|;
name|eachColumnUncompressedValueLen
operator|=
operator|new
name|int
index|[
name|columnNumber
index|]
expr_stmt|;
name|allCellValLenBuffer
operator|=
operator|new
name|NonSyncDataOutputBuffer
index|[
name|columnNumber
index|]
expr_stmt|;
name|this
operator|.
name|numberRows
operator|=
name|numberRows
expr_stmt|;
block|}
comment|/**      * add in a new column's meta data.      *       * @param columnValueLen      *          this total bytes number of this column's values in this split      * @param colValLenBuffer      *          each cell's length of this column's in this split      */
name|void
name|setColumnLenInfo
parameter_list|(
name|int
name|columnValueLen
parameter_list|,
name|NonSyncDataOutputBuffer
name|colValLenBuffer
parameter_list|,
name|int
name|columnUncompressedValueLen
parameter_list|,
name|int
name|columnIndex
parameter_list|)
block|{
name|eachColumnValueLen
index|[
name|columnIndex
index|]
operator|=
name|columnValueLen
expr_stmt|;
name|eachColumnUncompressedValueLen
index|[
name|columnIndex
index|]
operator|=
name|columnUncompressedValueLen
expr_stmt|;
name|allCellValLenBuffer
index|[
name|columnIndex
index|]
operator|=
name|colValLenBuffer
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|eachColumnValueLen
operator|=
operator|new
name|int
index|[
name|columnNumber
index|]
expr_stmt|;
name|eachColumnUncompressedValueLen
operator|=
operator|new
name|int
index|[
name|columnNumber
index|]
expr_stmt|;
name|allCellValLenBuffer
operator|=
operator|new
name|NonSyncDataOutputBuffer
index|[
name|columnNumber
index|]
expr_stmt|;
name|numberRows
operator|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columnNumber
condition|;
name|i
operator|++
control|)
block|{
name|eachColumnValueLen
index|[
name|i
index|]
operator|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|eachColumnUncompressedValueLen
index|[
name|i
index|]
operator|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|int
name|bufLen
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
name|allCellValLenBuffer
index|[
name|i
index|]
operator|==
literal|null
condition|)
name|allCellValLenBuffer
index|[
name|i
index|]
operator|=
operator|new
name|NonSyncDataOutputBuffer
argument_list|()
expr_stmt|;
else|else
name|allCellValLenBuffer
index|[
name|i
index|]
operator|.
name|reset
argument_list|()
expr_stmt|;
name|allCellValLenBuffer
index|[
name|i
index|]
operator|.
name|write
argument_list|(
name|in
argument_list|,
name|bufLen
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
comment|// out.writeInt(numberRows);
name|WritableUtils
operator|.
name|writeVLong
argument_list|(
name|out
argument_list|,
name|numberRows
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|eachColumnValueLen
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|WritableUtils
operator|.
name|writeVLong
argument_list|(
name|out
argument_list|,
name|eachColumnValueLen
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|WritableUtils
operator|.
name|writeVLong
argument_list|(
name|out
argument_list|,
name|eachColumnUncompressedValueLen
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|NonSyncDataOutputBuffer
name|colRowsLenBuf
init|=
name|allCellValLenBuffer
index|[
name|i
index|]
decl_stmt|;
name|int
name|bufLen
init|=
name|colRowsLenBuf
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|WritableUtils
operator|.
name|writeVLong
argument_list|(
name|out
argument_list|,
name|bufLen
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|colRowsLenBuf
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|bufLen
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * get number of bytes to store the keyBuffer      *       * @return number of bytes used to store this KeyBuffer on disk      * @throws IOException      */
specifier|public
name|int
name|getSize
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|ret
operator|+=
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|numberRows
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|eachColumnValueLen
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|+=
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|eachColumnValueLen
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|eachColumnUncompressedValueLen
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|allCellValLenBuffer
index|[
name|i
index|]
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|allCellValLenBuffer
index|[
name|i
index|]
operator|.
name|getLength
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
block|}
comment|/**    * ValueBuffer is the value of each record in RCFile. Its on-disk layout is as    * below:    *<ul>    *<li>Compressed or plain data of [column_1_row_1_value,    * column_1_row_2_value,....]</li>    *<li>Compressed or plain data of [column_2_row_1_value,    * column_2_row_2_value,....]</li>    *</ul>    */
specifier|static
class|class
name|ValueBuffer
implements|implements
name|Writable
block|{
comment|// used to load columns' value into memory
specifier|private
name|NonSyncDataOutputBuffer
index|[]
name|loadedColumnsValueBuffer
init|=
literal|null
decl_stmt|;
name|boolean
name|inited
init|=
literal|false
decl_stmt|;
comment|// used for readFields
name|KeyBuffer
name|keyBuffer
decl_stmt|;
specifier|private
name|int
name|columnNumber
init|=
literal|0
decl_stmt|;
comment|// set true for columns that needed to skip loading into memory.
name|boolean
index|[]
name|skippedColIDs
init|=
literal|null
decl_stmt|;
name|CompressionCodec
name|codec
decl_stmt|;
name|Decompressor
name|valDecompressor
init|=
literal|null
decl_stmt|;
name|NonSyncDataInputBuffer
name|decompressBuffer
init|=
operator|new
name|NonSyncDataInputBuffer
argument_list|()
decl_stmt|;
name|CompressionInputStream
name|deflatFilter
init|=
literal|null
decl_stmt|;
specifier|public
name|ValueBuffer
parameter_list|(
name|KeyBuffer
name|keyBuffer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|keyBuffer
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ValueBuffer
parameter_list|(
name|KeyBuffer
name|keyBuffer
parameter_list|,
name|boolean
index|[]
name|skippedColIDs
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|keyBuffer
argument_list|,
name|keyBuffer
operator|.
name|columnNumber
argument_list|,
name|skippedColIDs
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ValueBuffer
parameter_list|(
name|KeyBuffer
name|currentKey
parameter_list|,
name|int
name|columnNumber
parameter_list|,
name|boolean
index|[]
name|skippedCols
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|)
throws|throws
name|IOException
block|{
name|keyBuffer
operator|=
name|currentKey
expr_stmt|;
name|this
operator|.
name|columnNumber
operator|=
name|columnNumber
expr_stmt|;
if|if
condition|(
name|skippedCols
operator|!=
literal|null
operator|&&
name|skippedCols
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|skippedColIDs
operator|=
name|skippedCols
expr_stmt|;
block|}
else|else
block|{
name|skippedColIDs
operator|=
operator|new
name|boolean
index|[
name|columnNumber
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|skippedColIDs
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|skippedColIDs
index|[
name|i
index|]
operator|=
literal|false
expr_stmt|;
block|}
name|int
name|skipped
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|skippedColIDs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|boolean
name|currentSkip
range|:
name|skippedColIDs
control|)
if|if
condition|(
name|currentSkip
condition|)
name|skipped
operator|++
expr_stmt|;
block|}
name|loadedColumnsValueBuffer
operator|=
operator|new
name|NonSyncDataOutputBuffer
index|[
name|columnNumber
operator|-
name|skipped
index|]
expr_stmt|;
name|this
operator|.
name|codec
operator|=
name|codec
expr_stmt|;
if|if
condition|(
name|codec
operator|!=
literal|null
condition|)
block|{
name|valDecompressor
operator|=
name|CodecPool
operator|.
name|getDecompressor
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|deflatFilter
operator|=
name|codec
operator|.
name|createInputStream
argument_list|(
name|decompressBuffer
argument_list|,
name|valDecompressor
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|k
init|=
literal|0
init|,
name|readIndex
init|=
literal|0
init|;
name|k
operator|<
name|columnNumber
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|skippedColIDs
index|[
name|k
index|]
condition|)
continue|continue;
name|loadedColumnsValueBuffer
index|[
name|readIndex
index|]
operator|=
operator|new
name|NonSyncDataOutputBuffer
argument_list|()
expr_stmt|;
name|readIndex
operator|++
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|setColumnValueBuffer
parameter_list|(
name|NonSyncDataOutputBuffer
name|valBuffer
parameter_list|,
name|int
name|addIndex
parameter_list|)
block|{
name|loadedColumnsValueBuffer
index|[
name|addIndex
index|]
operator|=
name|valBuffer
expr_stmt|;
block|}
name|NonSyncDataOutputBuffer
name|compressedData
init|=
operator|new
name|NonSyncDataOutputBuffer
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|addIndex
init|=
literal|0
decl_stmt|;
name|int
name|skipTotal
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columnNumber
condition|;
name|i
operator|++
control|)
block|{
name|int
name|vaRowsLen
init|=
name|keyBuffer
operator|.
name|eachColumnValueLen
index|[
name|i
index|]
decl_stmt|;
comment|// skip this column
if|if
condition|(
name|skippedColIDs
index|[
name|i
index|]
condition|)
block|{
name|skipTotal
operator|+=
name|vaRowsLen
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|skipTotal
operator|!=
literal|0
condition|)
block|{
name|in
operator|.
name|skipBytes
argument_list|(
name|skipTotal
argument_list|)
expr_stmt|;
name|skipTotal
operator|=
literal|0
expr_stmt|;
block|}
name|NonSyncDataOutputBuffer
name|valBuf
init|=
name|loadedColumnsValueBuffer
index|[
name|addIndex
index|]
decl_stmt|;
name|valBuf
operator|.
name|reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|codec
operator|!=
literal|null
condition|)
block|{
name|decompressBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
name|DataInputStream
name|valueIn
init|=
operator|new
name|DataInputStream
argument_list|(
name|deflatFilter
argument_list|)
decl_stmt|;
name|deflatFilter
operator|.
name|resetState
argument_list|()
expr_stmt|;
name|compressedData
operator|.
name|reset
argument_list|()
expr_stmt|;
name|compressedData
operator|.
name|write
argument_list|(
name|in
argument_list|,
name|vaRowsLen
argument_list|)
expr_stmt|;
name|decompressBuffer
operator|.
name|reset
argument_list|(
name|compressedData
operator|.
name|getData
argument_list|()
argument_list|,
name|vaRowsLen
argument_list|)
expr_stmt|;
name|valBuf
operator|.
name|write
argument_list|(
name|valueIn
argument_list|,
name|keyBuffer
operator|.
name|eachColumnUncompressedValueLen
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|valBuf
operator|.
name|write
argument_list|(
name|in
argument_list|,
name|vaRowsLen
argument_list|)
expr_stmt|;
block|}
name|addIndex
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|skipTotal
operator|!=
literal|0
condition|)
block|{
name|in
operator|.
name|skipBytes
argument_list|(
name|skipTotal
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|loadedColumnsValueBuffer
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|NonSyncDataOutputBuffer
name|currentBuf
init|=
name|loadedColumnsValueBuffer
index|[
name|i
index|]
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
name|currentBuf
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|currentBuf
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|clearColumnBuffer
parameter_list|()
throws|throws
name|IOException
block|{
name|decompressBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|loadedColumnsValueBuffer
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|loadedColumnsValueBuffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|codec
operator|!=
literal|null
condition|)
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|decompressBuffer
argument_list|)
expr_stmt|;
name|CodecPool
operator|.
name|returnDecompressor
argument_list|(
name|valDecompressor
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Write KeyBuffer/ValueBuffer pairs to a RCFile. RCFile's format is    * compatible with SequenceFile's.    *     */
specifier|public
specifier|static
class|class
name|Writer
block|{
name|Configuration
name|conf
decl_stmt|;
name|FSDataOutputStream
name|out
decl_stmt|;
name|CompressionCodec
name|codec
init|=
literal|null
decl_stmt|;
name|Metadata
name|metadata
init|=
literal|null
decl_stmt|;
name|Compressor
name|compressor
init|=
literal|null
decl_stmt|;
comment|// Insert a globally unique 16-byte value every few entries, so that one
comment|// can seek into the middle of a file and then synchronize with record
comment|// starts and ends by scanning for this value.
name|long
name|lastSyncPos
decl_stmt|;
comment|// position of last sync
name|byte
index|[]
name|sync
decl_stmt|;
comment|// 16 random bytes
block|{
try|try
block|{
name|MessageDigest
name|digester
init|=
name|MessageDigest
operator|.
name|getInstance
argument_list|(
literal|"MD5"
argument_list|)
decl_stmt|;
name|long
name|time
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|digester
operator|.
name|update
argument_list|(
operator|(
operator|new
name|UID
argument_list|()
operator|+
literal|"@"
operator|+
name|time
operator|)
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
name|sync
operator|=
name|digester
operator|.
name|digest
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|// how many records the writer buffers before it writes to disk
specifier|private
name|int
name|RECORD_INTERVAL
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
comment|// the max size of memory for buffering records before writes them out
specifier|private
name|int
name|columnsBufferSize
init|=
literal|4
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
comment|// 4M
comment|// the conf string for COLUMNS_BUFFER_SIZE
specifier|public
specifier|static
name|String
name|COLUMNS_BUFFER_SIZE_CONF_STR
init|=
literal|"hive.io.rcfile.record.buffer.size"
decl_stmt|;
comment|// how many records already buffered
specifier|private
name|int
name|bufferedRecords
init|=
literal|0
decl_stmt|;
name|NonSyncDataOutputBuffer
index|[]
name|compressionBuffer
decl_stmt|;
name|CompressionOutputStream
index|[]
name|deflateFilter
init|=
literal|null
decl_stmt|;
name|DataOutputStream
index|[]
name|deflateOut
init|=
literal|null
decl_stmt|;
specifier|private
name|ColumnBuffer
index|[]
name|columnBuffers
decl_stmt|;
name|NonSyncDataOutputBuffer
name|keyCompressionBuffer
decl_stmt|;
name|CompressionOutputStream
name|keyDeflateFilter
decl_stmt|;
name|DataOutputStream
name|keyDeflateOut
decl_stmt|;
name|Compressor
name|keyCompressor
decl_stmt|;
specifier|private
name|int
name|columnNumber
init|=
literal|0
decl_stmt|;
specifier|private
name|int
index|[]
name|columnValuePlainLength
decl_stmt|;
name|KeyBuffer
name|key
init|=
literal|null
decl_stmt|;
name|ValueBuffer
name|value
init|=
literal|null
decl_stmt|;
comment|/*      * used for buffering appends before flush them out      */
class|class
name|ColumnBuffer
block|{
comment|// used for buffer a column's values
name|NonSyncDataOutputBuffer
name|columnValBuffer
decl_stmt|;
comment|// used to store each value's length
name|NonSyncDataOutputBuffer
name|valLenBuffer
decl_stmt|;
name|ColumnBuffer
parameter_list|()
throws|throws
name|IOException
block|{
name|columnValBuffer
operator|=
operator|new
name|NonSyncDataOutputBuffer
argument_list|()
expr_stmt|;
name|valLenBuffer
operator|=
operator|new
name|NonSyncDataOutputBuffer
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|append
parameter_list|(
name|BytesRefWritable
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|writeDataTo
argument_list|(
name|columnValBuffer
argument_list|)
expr_stmt|;
name|WritableUtils
operator|.
name|writeVLong
argument_list|(
name|valLenBuffer
argument_list|,
name|data
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|clear
parameter_list|()
throws|throws
name|IOException
block|{
name|valLenBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
name|columnValBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|long
name|getLength
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|out
operator|.
name|getPos
argument_list|()
return|;
block|}
comment|/** Constructs a RCFile Writer. */
specifier|public
name|Writer
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
literal|null
argument_list|,
operator|new
name|Metadata
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs a RCFile Writer.      *       * @param fs      *          the file system used      * @param conf      *          the configuration file      * @param name      *          the file name      * @throws IOException      */
specifier|public
name|Writer
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
literal|null
argument_list|,
operator|new
name|Metadata
argument_list|()
argument_list|,
name|codec
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs a RCFile Writer.      *       * @param fs      *          the file system used      * @param conf      *          the configuration file      * @param name      *          the file name      * @param progress      * @param metadata      * @throws IOException      */
specifier|public
name|Writer
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|Metadata
name|metadata
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
name|fs
operator|.
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"io.file.buffer.size"
argument_list|,
literal|4096
argument_list|)
argument_list|,
name|fs
operator|.
name|getDefaultReplication
argument_list|()
argument_list|,
name|fs
operator|.
name|getDefaultBlockSize
argument_list|()
argument_list|,
name|progress
argument_list|,
name|metadata
argument_list|,
name|codec
argument_list|)
expr_stmt|;
block|}
comment|/**      *       * Constructs a RCFile Writer.      *       * @param fs      *          the file system used      * @param conf      *          the configuration file      * @param name      *          the file name      * @param bufferSize      * @param replication      * @param blockSize      * @param progress      * @param metadata      * @throws IOException      */
specifier|public
name|Writer
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|Metadata
name|metadata
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|)
throws|throws
name|IOException
block|{
name|RECORD_INTERVAL
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|RECORD_INTERVAL_CONF_STR
argument_list|,
name|RECORD_INTERVAL
argument_list|)
expr_stmt|;
name|columnNumber
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|COLUMN_NUMBER_CONF_STR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|metadata
operator|==
literal|null
condition|)
name|metadata
operator|=
operator|new
name|Metadata
argument_list|()
expr_stmt|;
name|metadata
operator|.
name|set
argument_list|(
operator|new
name|Text
argument_list|(
name|COLUMN_NUMBER_METADATA_STR
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
literal|""
operator|+
name|columnNumber
argument_list|)
argument_list|)
expr_stmt|;
name|columnsBufferSize
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|COLUMNS_BUFFER_SIZE_CONF_STR
argument_list|,
literal|4
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|columnValuePlainLength
operator|=
operator|new
name|int
index|[
name|columnNumber
index|]
expr_stmt|;
name|columnBuffers
operator|=
operator|new
name|ColumnBuffer
index|[
name|columnNumber
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columnNumber
condition|;
name|i
operator|++
control|)
block|{
name|columnBuffers
index|[
name|i
index|]
operator|=
operator|new
name|ColumnBuffer
argument_list|()
expr_stmt|;
block|}
name|init
argument_list|(
name|name
argument_list|,
name|conf
argument_list|,
name|fs
operator|.
name|create
argument_list|(
name|name
argument_list|,
literal|true
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|)
argument_list|,
name|codec
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
name|initializeFileHeader
argument_list|()
expr_stmt|;
name|writeFileHeader
argument_list|()
expr_stmt|;
name|finalizeFileHeader
argument_list|()
expr_stmt|;
name|key
operator|=
operator|new
name|KeyBuffer
argument_list|(
name|columnNumber
argument_list|)
expr_stmt|;
name|value
operator|=
operator|new
name|ValueBuffer
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
comment|/** Write the initial part of file header. */
name|void
name|initializeFileHeader
parameter_list|()
throws|throws
name|IOException
block|{
name|out
operator|.
name|write
argument_list|(
name|VERSION
argument_list|)
expr_stmt|;
block|}
comment|/** Write the final part of file header. */
name|void
name|finalizeFileHeader
parameter_list|()
throws|throws
name|IOException
block|{
name|out
operator|.
name|write
argument_list|(
name|sync
argument_list|)
expr_stmt|;
comment|// write the sync bytes
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
comment|// flush header
block|}
name|boolean
name|isCompressed
parameter_list|()
block|{
return|return
name|codec
operator|!=
literal|null
return|;
block|}
comment|/** Write and flush the file header. */
name|void
name|writeFileHeader
parameter_list|()
throws|throws
name|IOException
block|{
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|KeyBuffer
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|ValueBuffer
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBoolean
argument_list|(
name|isCompressed
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBoolean
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|isCompressed
argument_list|()
condition|)
block|{
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
operator|(
name|codec
operator|.
name|getClass
argument_list|()
operator|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|metadata
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
name|void
name|init
parameter_list|(
name|Path
name|name
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|FSDataOutputStream
name|out
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|out
operator|=
name|out
expr_stmt|;
name|this
operator|.
name|codec
operator|=
name|codec
expr_stmt|;
name|this
operator|.
name|metadata
operator|=
name|metadata
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|codec
operator|!=
literal|null
condition|)
block|{
name|ReflectionUtils
operator|.
name|setConf
argument_list|(
name|codec
argument_list|,
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|compressor
operator|=
name|CodecPool
operator|.
name|getCompressor
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|compressionBuffer
operator|=
operator|new
name|NonSyncDataOutputBuffer
index|[
name|columnNumber
index|]
expr_stmt|;
name|deflateFilter
operator|=
operator|new
name|CompressionOutputStream
index|[
name|columnNumber
index|]
expr_stmt|;
name|deflateOut
operator|=
operator|new
name|DataOutputStream
index|[
name|columnNumber
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columnNumber
condition|;
name|i
operator|++
control|)
block|{
name|compressionBuffer
index|[
name|i
index|]
operator|=
operator|new
name|NonSyncDataOutputBuffer
argument_list|()
expr_stmt|;
name|deflateFilter
index|[
name|i
index|]
operator|=
name|codec
operator|.
name|createOutputStream
argument_list|(
name|compressionBuffer
index|[
name|i
index|]
argument_list|,
name|compressor
argument_list|)
expr_stmt|;
name|deflateOut
index|[
name|i
index|]
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|deflateFilter
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|keyCompressor
operator|=
name|CodecPool
operator|.
name|getCompressor
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|keyCompressionBuffer
operator|=
operator|new
name|NonSyncDataOutputBuffer
argument_list|()
expr_stmt|;
name|keyDeflateFilter
operator|=
name|codec
operator|.
name|createOutputStream
argument_list|(
name|keyCompressionBuffer
argument_list|,
name|keyCompressor
argument_list|)
expr_stmt|;
name|keyDeflateOut
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|keyDeflateFilter
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Returns the compression codec of data in this file. */
specifier|public
name|CompressionCodec
name|getCompressionCodec
parameter_list|()
block|{
return|return
name|codec
return|;
block|}
comment|/** create a sync point */
specifier|public
name|void
name|sync
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|sync
operator|!=
literal|null
operator|&&
name|lastSyncPos
operator|!=
name|out
operator|.
name|getPos
argument_list|()
condition|)
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|SYNC_ESCAPE
argument_list|)
expr_stmt|;
comment|// mark the start of the sync
name|out
operator|.
name|write
argument_list|(
name|sync
argument_list|)
expr_stmt|;
comment|// write sync
name|lastSyncPos
operator|=
name|out
operator|.
name|getPos
argument_list|()
expr_stmt|;
comment|// update lastSyncPos
block|}
block|}
comment|/** Returns the configuration of this file. */
name|Configuration
name|getConf
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
specifier|private
name|void
name|checkAndWriteSync
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|sync
operator|!=
literal|null
operator|&&
name|out
operator|.
name|getPos
argument_list|()
operator|>=
name|lastSyncPos
operator|+
name|SYNC_INTERVAL
condition|)
block|{
name|sync
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|int
name|columnBufferSize
init|=
literal|0
decl_stmt|;
comment|/**      * append a row of values. Currently it only can accept<      * {@link BytesRefArrayWritable}. If its<code>size()</code> is less than the      * column number in the file, zero bytes are appended for the empty columns.      * If its size() is greater then the column number in the file, the exceeded      * columns' bytes are ignored.      *       * @param val      * @throws IOException      */
specifier|public
name|void
name|append
parameter_list|(
name|Writable
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
operator|(
name|val
operator|instanceof
name|BytesRefArrayWritable
operator|)
condition|)
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Currently the writer can only accept BytesRefArrayWritable"
argument_list|)
throw|;
name|BytesRefArrayWritable
name|columns
init|=
operator|(
name|BytesRefArrayWritable
operator|)
name|val
decl_stmt|;
name|int
name|size
init|=
name|columns
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|BytesRefWritable
name|cu
init|=
name|columns
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|plainLen
init|=
name|cu
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|columnBufferSize
operator|+=
name|plainLen
expr_stmt|;
name|columnValuePlainLength
index|[
name|i
index|]
operator|+=
name|plainLen
expr_stmt|;
name|columnBuffers
index|[
name|i
index|]
operator|.
name|append
argument_list|(
name|cu
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|<
name|columnNumber
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|columns
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|columnNumber
condition|;
name|i
operator|++
control|)
block|{
name|columnBuffers
index|[
name|i
index|]
operator|.
name|append
argument_list|(
name|BytesRefWritable
operator|.
name|ZeroBytesRefWritable
argument_list|)
expr_stmt|;
block|}
block|}
name|bufferedRecords
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|columnBufferSize
operator|>
name|columnsBufferSize
operator|)
operator|||
operator|(
name|bufferedRecords
operator|>=
name|RECORD_INTERVAL
operator|)
condition|)
block|{
name|flushRecords
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|flushRecords
parameter_list|()
throws|throws
name|IOException
block|{
name|key
operator|.
name|numberRows
operator|=
name|bufferedRecords
expr_stmt|;
name|value
operator|.
name|keyBuffer
operator|=
name|key
expr_stmt|;
name|int
name|valueLength
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|columnIndex
init|=
literal|0
init|;
name|columnIndex
operator|<
name|columnNumber
condition|;
name|columnIndex
operator|++
control|)
block|{
name|ColumnBuffer
name|currentBuf
init|=
name|columnBuffers
index|[
name|columnIndex
index|]
decl_stmt|;
name|NonSyncDataOutputBuffer
name|columnValue
init|=
name|currentBuf
operator|.
name|columnValBuffer
decl_stmt|;
if|if
condition|(
name|isCompressed
argument_list|()
condition|)
block|{
name|compressionBuffer
index|[
name|columnIndex
index|]
operator|.
name|reset
argument_list|()
expr_stmt|;
name|deflateFilter
index|[
name|columnIndex
index|]
operator|.
name|resetState
argument_list|()
expr_stmt|;
name|deflateOut
index|[
name|columnIndex
index|]
operator|.
name|write
argument_list|(
name|columnValue
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|columnValue
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|deflateOut
index|[
name|columnIndex
index|]
operator|.
name|flush
argument_list|()
expr_stmt|;
name|deflateFilter
index|[
name|columnIndex
index|]
operator|.
name|finish
argument_list|()
expr_stmt|;
name|int
name|colLen
init|=
name|compressionBuffer
index|[
name|columnIndex
index|]
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|key
operator|.
name|setColumnLenInfo
argument_list|(
name|colLen
argument_list|,
name|currentBuf
operator|.
name|valLenBuffer
argument_list|,
name|columnValuePlainLength
index|[
name|columnIndex
index|]
argument_list|,
name|columnIndex
argument_list|)
expr_stmt|;
name|value
operator|.
name|setColumnValueBuffer
argument_list|(
name|compressionBuffer
index|[
name|columnIndex
index|]
argument_list|,
name|columnIndex
argument_list|)
expr_stmt|;
name|valueLength
operator|+=
name|colLen
expr_stmt|;
block|}
else|else
block|{
name|int
name|colLen
init|=
name|columnValuePlainLength
index|[
name|columnIndex
index|]
decl_stmt|;
name|key
operator|.
name|setColumnLenInfo
argument_list|(
name|colLen
argument_list|,
name|currentBuf
operator|.
name|valLenBuffer
argument_list|,
name|colLen
argument_list|,
name|columnIndex
argument_list|)
expr_stmt|;
name|value
operator|.
name|setColumnValueBuffer
argument_list|(
name|columnValue
argument_list|,
name|columnIndex
argument_list|)
expr_stmt|;
name|valueLength
operator|+=
name|colLen
expr_stmt|;
block|}
name|columnValuePlainLength
index|[
name|columnIndex
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|keyLength
init|=
name|key
operator|.
name|getSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"negative length keys not allowed: "
operator|+
name|key
argument_list|)
throw|;
comment|// Write the record out
name|checkAndWriteSync
argument_list|()
expr_stmt|;
comment|// sync
name|out
operator|.
name|writeInt
argument_list|(
name|keyLength
operator|+
name|valueLength
argument_list|)
expr_stmt|;
comment|// total record length
name|out
operator|.
name|writeInt
argument_list|(
name|keyLength
argument_list|)
expr_stmt|;
comment|// key portion length
if|if
condition|(
operator|!
name|isCompressed
argument_list|()
condition|)
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|keyLength
argument_list|)
expr_stmt|;
name|key
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|// key
block|}
else|else
block|{
name|keyCompressionBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
name|keyDeflateFilter
operator|.
name|resetState
argument_list|()
expr_stmt|;
name|key
operator|.
name|write
argument_list|(
name|keyDeflateOut
argument_list|)
expr_stmt|;
name|keyDeflateOut
operator|.
name|flush
argument_list|()
expr_stmt|;
name|keyDeflateFilter
operator|.
name|finish
argument_list|()
expr_stmt|;
name|int
name|compressedKeyLen
init|=
name|keyCompressionBuffer
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|compressedKeyLen
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|keyCompressionBuffer
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|compressedKeyLen
argument_list|)
expr_stmt|;
block|}
name|value
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|// value
comment|// clear the columnBuffers
name|clearColumnBuffers
argument_list|()
expr_stmt|;
name|bufferedRecords
operator|=
literal|0
expr_stmt|;
name|columnBufferSize
operator|=
literal|0
expr_stmt|;
block|}
specifier|private
name|void
name|clearColumnBuffers
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columnNumber
condition|;
name|i
operator|++
control|)
block|{
name|columnBuffers
index|[
name|i
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|bufferedRecords
operator|>
literal|0
condition|)
name|flushRecords
argument_list|()
expr_stmt|;
name|clearColumnBuffers
argument_list|()
expr_stmt|;
if|if
condition|(
name|isCompressed
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columnNumber
condition|;
name|i
operator|++
control|)
block|{
name|deflateFilter
index|[
name|i
index|]
operator|.
name|close
argument_list|()
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|deflateOut
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|keyDeflateFilter
operator|.
name|close
argument_list|()
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|keyDeflateOut
argument_list|)
expr_stmt|;
name|CodecPool
operator|.
name|returnCompressor
argument_list|(
name|keyCompressor
argument_list|)
expr_stmt|;
name|keyCompressor
operator|=
literal|null
expr_stmt|;
name|CodecPool
operator|.
name|returnCompressor
argument_list|(
name|compressor
argument_list|)
expr_stmt|;
name|compressor
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
comment|// Close the underlying stream if we own it...
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|out
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Read KeyBuffer/ValueBuffer pairs from a RCFile.    *     */
specifier|public
specifier|static
class|class
name|Reader
block|{
specifier|private
name|Path
name|file
decl_stmt|;
specifier|private
name|FSDataInputStream
name|in
decl_stmt|;
specifier|private
name|byte
name|version
decl_stmt|;
specifier|private
name|CompressionCodec
name|codec
init|=
literal|null
decl_stmt|;
specifier|private
name|Metadata
name|metadata
init|=
literal|null
decl_stmt|;
specifier|private
name|byte
index|[]
name|sync
init|=
operator|new
name|byte
index|[
name|SYNC_HASH_SIZE
index|]
decl_stmt|;
specifier|private
name|byte
index|[]
name|syncCheck
init|=
operator|new
name|byte
index|[
name|SYNC_HASH_SIZE
index|]
decl_stmt|;
specifier|private
name|boolean
name|syncSeen
decl_stmt|;
specifier|private
name|long
name|end
decl_stmt|;
specifier|private
name|int
name|currentKeyLength
decl_stmt|;
specifier|private
name|int
name|currentRecordLength
decl_stmt|;
specifier|private
name|Configuration
name|conf
decl_stmt|;
specifier|private
name|ValueBuffer
name|currentValue
decl_stmt|;
specifier|private
name|boolean
index|[]
name|skippedColIDs
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|readRowsIndexInBuffer
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|recordsNumInValBuffer
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|columnNumber
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|loadColumnNum
decl_stmt|;
specifier|private
name|int
name|passedRowsNum
init|=
literal|0
decl_stmt|;
specifier|private
name|int
index|[]
name|columnRowReadIndex
init|=
literal|null
decl_stmt|;
specifier|private
name|NonSyncDataInputBuffer
index|[]
name|colValLenBufferReadIn
decl_stmt|;
specifier|private
name|boolean
name|decompress
init|=
literal|false
decl_stmt|;
specifier|private
name|Decompressor
name|keyDecompressor
decl_stmt|;
name|NonSyncDataOutputBuffer
name|keyDecompressedData
init|=
operator|new
name|NonSyncDataOutputBuffer
argument_list|()
decl_stmt|;
name|int
index|[]
name|prjColIDs
init|=
literal|null
decl_stmt|;
comment|// selected column IDs
comment|/** Create a new RCFile reader. */
specifier|public
name|Reader
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|file
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|file
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"io.file.buffer.size"
argument_list|,
literal|4096
argument_list|)
argument_list|,
name|conf
argument_list|,
literal|0
argument_list|,
name|fs
operator|.
name|getFileStatus
argument_list|(
name|file
argument_list|)
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Create a new RCFile reader. */
specifier|public
name|Reader
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|file
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|conf
operator|.
name|setInt
argument_list|(
literal|"io.file.buffer.size"
argument_list|,
name|bufferSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|in
operator|=
name|fs
operator|.
name|open
argument_list|(
name|file
argument_list|,
name|bufferSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|length
expr_stmt|;
if|if
condition|(
name|start
operator|>
literal|0
condition|)
block|{
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
name|seek
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|init
argument_list|()
expr_stmt|;
block|}
name|columnNumber
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|metadata
operator|.
name|get
argument_list|(
operator|new
name|Text
argument_list|(
name|COLUMN_NUMBER_METADATA_STR
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|java
operator|.
name|util
operator|.
name|ArrayList
argument_list|<
name|Integer
argument_list|>
name|notSkipIDs
init|=
name|HiveFileFormatUtils
operator|.
name|getReadColumnIDs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|skippedColIDs
operator|=
operator|new
name|boolean
index|[
name|columnNumber
index|]
expr_stmt|;
if|if
condition|(
name|notSkipIDs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|skippedColIDs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|skippedColIDs
index|[
name|i
index|]
operator|=
literal|true
expr_stmt|;
block|}
for|for
control|(
name|int
name|read
range|:
name|notSkipIDs
control|)
block|{
if|if
condition|(
name|read
operator|<
name|columnNumber
condition|)
name|skippedColIDs
index|[
name|read
index|]
operator|=
literal|false
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// TODO: if no column name is specified e.g, in select count(1) from tt;
comment|// skip all columns, this should be distinguished from the case:
comment|// select * from tt;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|skippedColIDs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|skippedColIDs
index|[
name|i
index|]
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|loadColumnNum
operator|=
name|columnNumber
expr_stmt|;
if|if
condition|(
name|skippedColIDs
operator|!=
literal|null
operator|&&
name|skippedColIDs
operator|.
name|length
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|skippedColIDs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|skippedColIDs
index|[
name|i
index|]
condition|)
name|loadColumnNum
operator|-=
literal|1
expr_stmt|;
block|}
block|}
comment|// get list of selected column IDs
name|prjColIDs
operator|=
operator|new
name|int
index|[
name|loadColumnNum
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|j
init|=
literal|0
init|;
name|i
operator|<
name|columnNumber
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|skippedColIDs
index|[
name|i
index|]
condition|)
block|{
name|prjColIDs
index|[
name|j
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
name|colValLenBufferReadIn
operator|=
operator|new
name|NonSyncDataInputBuffer
index|[
name|columnNumber
index|]
expr_stmt|;
name|columnRowReadIndex
operator|=
operator|new
name|int
index|[
name|columnNumber
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columnNumber
condition|;
name|i
operator|++
control|)
block|{
name|columnRowReadIndex
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|skippedColIDs
index|[
name|i
index|]
condition|)
name|colValLenBufferReadIn
index|[
name|i
index|]
operator|=
operator|new
name|NonSyncDataInputBuffer
argument_list|()
expr_stmt|;
block|}
name|currentKey
operator|=
name|createKeyBuffer
argument_list|()
expr_stmt|;
name|currentValue
operator|=
operator|new
name|ValueBuffer
argument_list|(
literal|null
argument_list|,
name|columnNumber
argument_list|,
name|skippedColIDs
argument_list|,
name|codec
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|init
parameter_list|()
throws|throws
name|IOException
block|{
name|byte
index|[]
name|versionBlock
init|=
operator|new
name|byte
index|[
name|VERSION
operator|.
name|length
index|]
decl_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|versionBlock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|versionBlock
index|[
literal|0
index|]
operator|!=
name|VERSION
index|[
literal|0
index|]
operator|)
operator|||
operator|(
name|versionBlock
index|[
literal|1
index|]
operator|!=
name|VERSION
index|[
literal|1
index|]
operator|)
operator|||
operator|(
name|versionBlock
index|[
literal|2
index|]
operator|!=
name|VERSION
index|[
literal|2
index|]
operator|)
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
name|file
operator|+
literal|" not a RCFile"
argument_list|)
throw|;
comment|// Set 'version'
name|version
operator|=
name|versionBlock
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|version
operator|>
name|VERSION
index|[
literal|3
index|]
condition|)
throw|throw
operator|new
name|VersionMismatchException
argument_list|(
name|VERSION
index|[
literal|3
index|]
argument_list|,
name|version
argument_list|)
throw|;
try|try
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|keyCls
init|=
name|conf
operator|.
name|getClassByName
argument_list|(
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|)
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|valCls
init|=
name|conf
operator|.
name|getClassByName
argument_list|(
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|keyCls
operator|.
name|equals
argument_list|(
name|KeyBuffer
operator|.
name|class
argument_list|)
operator|||
operator|!
name|valCls
operator|.
name|equals
argument_list|(
name|ValueBuffer
operator|.
name|class
argument_list|)
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
name|file
operator|+
literal|" not a RCFile"
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|file
operator|+
literal|" not a RCFile"
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|version
operator|>
literal|2
condition|)
block|{
comment|// if version> 2
name|decompress
operator|=
name|in
operator|.
name|readBoolean
argument_list|()
expr_stmt|;
comment|// is compressed?
block|}
else|else
block|{
name|decompress
operator|=
literal|false
expr_stmt|;
block|}
comment|// is block-compressed? it should be always false.
name|boolean
name|blkCompressed
init|=
name|in
operator|.
name|readBoolean
argument_list|()
decl_stmt|;
if|if
condition|(
name|blkCompressed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|file
operator|+
literal|" not a RCFile."
argument_list|)
throw|;
block|}
comment|// setup the compression codec
if|if
condition|(
name|decompress
condition|)
block|{
name|String
name|codecClassname
init|=
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|)
decl_stmt|;
try|try
block|{
name|Class
argument_list|<
name|?
extends|extends
name|CompressionCodec
argument_list|>
name|codecClass
init|=
name|conf
operator|.
name|getClassByName
argument_list|(
name|codecClassname
argument_list|)
operator|.
name|asSubclass
argument_list|(
name|CompressionCodec
operator|.
name|class
argument_list|)
decl_stmt|;
name|codec
operator|=
operator|(
name|CompressionCodec
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|codecClass
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|cnfe
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown codec: "
operator|+
name|codecClassname
argument_list|,
name|cnfe
argument_list|)
throw|;
block|}
name|keyDecompressor
operator|=
name|CodecPool
operator|.
name|getDecompressor
argument_list|(
name|codec
argument_list|)
expr_stmt|;
block|}
name|metadata
operator|=
operator|new
name|Metadata
argument_list|()
expr_stmt|;
if|if
condition|(
name|version
operator|>=
name|VERSION_WITH_METADATA
condition|)
block|{
comment|// if version>= 6
name|metadata
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|version
operator|>
literal|1
condition|)
block|{
comment|// if version> 1
name|in
operator|.
name|readFully
argument_list|(
name|sync
argument_list|)
expr_stmt|;
comment|// read sync bytes
block|}
block|}
comment|/** Return the current byte position in the input file. */
specifier|public
specifier|synchronized
name|long
name|getPosition
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|in
operator|.
name|getPos
argument_list|()
return|;
block|}
comment|/**      * Set the current byte position in the input file.      *       *<p>      * The position passed must be a position returned by      * {@link RCFile.Writer#getLength()} when writing this file. To seek to an      * arbitrary position, use {@link RCFile.Reader#sync(long)}. In another      * words, the current seek can only seek to the end of the file. For other      * positions, use {@link RCFile.Reader#sync(long)}.      */
specifier|public
specifier|synchronized
name|void
name|seek
parameter_list|(
name|long
name|position
parameter_list|)
throws|throws
name|IOException
block|{
name|in
operator|.
name|seek
argument_list|(
name|position
argument_list|)
expr_stmt|;
block|}
comment|/** Seek to the next sync mark past a given position. */
specifier|public
specifier|synchronized
name|void
name|sync
parameter_list|(
name|long
name|position
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|position
operator|+
name|SYNC_SIZE
operator|>=
name|end
condition|)
block|{
name|seek
argument_list|(
name|end
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
name|seek
argument_list|(
name|position
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|// skip escape
name|in
operator|.
name|readFully
argument_list|(
name|syncCheck
argument_list|)
expr_stmt|;
name|int
name|syncLen
init|=
name|sync
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|in
operator|.
name|getPos
argument_list|()
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|j
operator|<
name|syncLen
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|sync
index|[
name|j
index|]
operator|!=
name|syncCheck
index|[
operator|(
name|i
operator|+
name|j
operator|)
operator|%
name|syncLen
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|syncLen
condition|)
block|{
name|in
operator|.
name|seek
argument_list|(
name|in
operator|.
name|getPos
argument_list|()
operator|-
name|SYNC_SIZE
argument_list|)
expr_stmt|;
comment|// position before
comment|// sync
return|return;
block|}
name|syncCheck
index|[
name|i
operator|%
name|syncLen
index|]
operator|=
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ChecksumException
name|e
parameter_list|)
block|{
comment|// checksum failure
name|handleChecksumException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|handleChecksumException
parameter_list|(
name|ChecksumException
name|e
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"io.skip.checksum.errors"
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Bad checksum at "
operator|+
name|getPosition
argument_list|()
operator|+
literal|". Skipping entries."
argument_list|)
expr_stmt|;
name|sync
argument_list|(
name|getPosition
argument_list|()
operator|+
name|conf
operator|.
name|getInt
argument_list|(
literal|"io.bytes.per.checksum"
argument_list|,
literal|512
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
specifier|private
name|KeyBuffer
name|createKeyBuffer
parameter_list|()
block|{
return|return
operator|new
name|KeyBuffer
argument_list|(
name|columnNumber
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|private
name|ValueBuffer
name|createValueBuffer
parameter_list|(
name|KeyBuffer
name|key
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|ValueBuffer
argument_list|(
name|key
argument_list|,
name|skippedColIDs
argument_list|)
return|;
block|}
comment|/**      * Read and return the next record length, potentially skipping over a sync      * block.      *       * @return the length of the next record or -1 if there is no next record      * @throws IOException      */
specifier|private
specifier|synchronized
name|int
name|readRecordLength
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|in
operator|.
name|getPos
argument_list|()
operator|>=
name|end
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|int
name|length
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|version
operator|>
literal|1
operator|&&
name|sync
operator|!=
literal|null
operator|&&
name|length
operator|==
name|SYNC_ESCAPE
condition|)
block|{
comment|// process
comment|// a
comment|// sync entry
name|in
operator|.
name|readFully
argument_list|(
name|syncCheck
argument_list|)
expr_stmt|;
comment|// read syncCheck
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|sync
argument_list|,
name|syncCheck
argument_list|)
condition|)
comment|// check it
throw|throw
operator|new
name|IOException
argument_list|(
literal|"File is corrupt!"
argument_list|)
throw|;
name|syncSeen
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|getPos
argument_list|()
operator|>=
name|end
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|length
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
comment|// re-read length
block|}
else|else
block|{
name|syncSeen
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|length
return|;
block|}
specifier|private
name|void
name|seekToNextKeyBuffer
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|keyInit
condition|)
return|return;
if|if
condition|(
operator|!
name|currentValue
operator|.
name|inited
condition|)
block|{
name|in
operator|.
name|skip
argument_list|(
name|currentRecordLength
operator|-
name|currentKeyLength
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|int
name|compressedKeyLen
init|=
literal|0
decl_stmt|;
name|NonSyncDataInputBuffer
name|keyDataIn
init|=
operator|new
name|NonSyncDataInputBuffer
argument_list|()
decl_stmt|;
name|NonSyncDataInputBuffer
name|keyDecompressBuffer
init|=
operator|new
name|NonSyncDataInputBuffer
argument_list|()
decl_stmt|;
name|NonSyncDataOutputBuffer
name|keyTempBuffer
init|=
operator|new
name|NonSyncDataOutputBuffer
argument_list|()
decl_stmt|;
name|KeyBuffer
name|currentKey
init|=
literal|null
decl_stmt|;
name|boolean
name|keyInit
init|=
literal|false
decl_stmt|;
specifier|protected
name|int
name|nextKeyBuffer
parameter_list|()
throws|throws
name|IOException
block|{
name|seekToNextKeyBuffer
argument_list|()
expr_stmt|;
name|currentRecordLength
operator|=
name|readRecordLength
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentRecordLength
operator|==
operator|-
literal|1
condition|)
block|{
name|keyInit
operator|=
literal|false
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|currentKeyLength
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|compressedKeyLen
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|decompress
condition|)
block|{
name|keyTempBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
name|keyTempBuffer
operator|.
name|write
argument_list|(
name|in
argument_list|,
name|compressedKeyLen
argument_list|)
expr_stmt|;
name|keyDecompressBuffer
operator|.
name|reset
argument_list|(
name|keyTempBuffer
operator|.
name|getData
argument_list|()
argument_list|,
name|compressedKeyLen
argument_list|)
expr_stmt|;
name|CompressionInputStream
name|deflatFilter
init|=
name|codec
operator|.
name|createInputStream
argument_list|(
name|keyDecompressBuffer
argument_list|,
name|keyDecompressor
argument_list|)
decl_stmt|;
name|DataInputStream
name|compressedIn
init|=
operator|new
name|DataInputStream
argument_list|(
name|deflatFilter
argument_list|)
decl_stmt|;
name|deflatFilter
operator|.
name|resetState
argument_list|()
expr_stmt|;
name|keyDecompressedData
operator|.
name|reset
argument_list|()
expr_stmt|;
name|keyDecompressedData
operator|.
name|write
argument_list|(
name|compressedIn
argument_list|,
name|currentKeyLength
argument_list|)
expr_stmt|;
name|keyDataIn
operator|.
name|reset
argument_list|(
name|keyDecompressedData
operator|.
name|getData
argument_list|()
argument_list|,
name|currentKeyLength
argument_list|)
expr_stmt|;
name|currentKey
operator|.
name|readFields
argument_list|(
name|keyDataIn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|currentKey
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
name|keyInit
operator|=
literal|true
expr_stmt|;
name|currentValue
operator|.
name|inited
operator|=
literal|false
expr_stmt|;
name|readRowsIndexInBuffer
operator|=
literal|0
expr_stmt|;
name|recordsNumInValBuffer
operator|=
name|currentKey
operator|.
name|numberRows
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|prjColIDs
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|int
name|i
init|=
name|prjColIDs
index|[
name|j
index|]
decl_stmt|;
name|colValLenBufferReadIn
index|[
name|i
index|]
operator|.
name|reset
argument_list|(
name|currentKey
operator|.
name|allCellValLenBuffer
index|[
name|i
index|]
operator|.
name|getData
argument_list|()
argument_list|,
name|currentKey
operator|.
name|allCellValLenBuffer
index|[
name|i
index|]
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|columnRowReadIndex
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|currentKeyLength
return|;
block|}
specifier|protected
name|void
name|currentValueBuffer
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|keyInit
condition|)
name|nextKeyBuffer
argument_list|()
expr_stmt|;
name|currentValue
operator|.
name|keyBuffer
operator|=
name|currentKey
expr_stmt|;
name|currentValue
operator|.
name|clearColumnBuffer
argument_list|()
expr_stmt|;
name|currentValue
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|currentValue
operator|.
name|inited
operator|=
literal|true
expr_stmt|;
block|}
specifier|private
name|boolean
name|rowFetched
init|=
literal|false
decl_stmt|;
comment|// use this buffer to hold column's cells value length for usages in
comment|// getColumn(), instead of using colValLenBufferReadIn directly.
specifier|private
name|NonSyncDataInputBuffer
name|fetchColumnTempBuf
init|=
operator|new
name|NonSyncDataInputBuffer
argument_list|()
decl_stmt|;
comment|/**      * Fetch all data in the buffer for a given column. This is useful for      * columnar operators, which perform operations on an array data of one      * column. It should be used together with {@link #nextColumnsBatch()}.      * Calling getColumn() with not change the result of      * {@link #next(LongWritable)} and      * {@link #getCurrentRow(BytesRefArrayWritable)}.      *       * @param columnID      * @throws IOException      */
specifier|public
name|BytesRefArrayWritable
name|getColumn
parameter_list|(
name|int
name|columnID
parameter_list|,
name|BytesRefArrayWritable
name|rest
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|skippedColIDs
index|[
name|columnID
index|]
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|rest
operator|==
literal|null
condition|)
block|{
name|rest
operator|=
operator|new
name|BytesRefArrayWritable
argument_list|()
expr_stmt|;
block|}
name|rest
operator|.
name|resetValid
argument_list|(
name|recordsNumInValBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|currentValue
operator|.
name|inited
condition|)
name|currentValueBuffer
argument_list|()
expr_stmt|;
name|int
name|columnNextRowStart
init|=
literal|0
decl_stmt|;
name|fetchColumnTempBuf
operator|.
name|reset
argument_list|(
name|currentKey
operator|.
name|allCellValLenBuffer
index|[
name|columnID
index|]
operator|.
name|getData
argument_list|()
argument_list|,
name|currentKey
operator|.
name|allCellValLenBuffer
index|[
name|columnID
index|]
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|recordsNumInValBuffer
condition|;
name|i
operator|++
control|)
block|{
name|int
name|length
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|fetchColumnTempBuf
argument_list|)
decl_stmt|;
name|BytesRefWritable
name|currentCell
init|=
name|rest
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|currentCell
operator|.
name|set
argument_list|(
name|currentValue
operator|.
name|loadedColumnsValueBuffer
index|[
name|columnID
index|]
operator|.
name|getData
argument_list|()
argument_list|,
name|columnNextRowStart
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|columnNextRowStart
operator|=
name|columnNextRowStart
operator|+
name|length
expr_stmt|;
block|}
return|return
name|rest
return|;
block|}
comment|/**      * Read in next key buffer and throw any data in current key buffer and      * current value buffer. It will influence the result of {@link      * #next(LongWritable)} and {@link #getCurrentRow(BytesRefArrayWritable)}      *       * @return whether there still has records or not      * @throws IOException      */
specifier|public
specifier|synchronized
name|boolean
name|nextColumnsBatch
parameter_list|()
throws|throws
name|IOException
block|{
name|passedRowsNum
operator|+=
operator|(
name|recordsNumInValBuffer
operator|-
name|readRowsIndexInBuffer
operator|)
expr_stmt|;
return|return
name|nextKeyBuffer
argument_list|()
operator|>
literal|0
return|;
block|}
comment|/**      * Returns how many rows we fetched with next(). It only means how many rows      * are read by next(). The returned result may be smaller than actual number      * of rows passed by, because {@link #seek(long)},      * {@link #nextColumnsBatch()} can change the underlying key buffer and      * value buffer.      *       * @return next row number      * @throws IOException      */
specifier|public
specifier|synchronized
name|boolean
name|next
parameter_list|(
name|LongWritable
name|readRows
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|hasRecordsInBuffer
argument_list|()
condition|)
block|{
name|readRows
operator|.
name|set
argument_list|(
name|passedRowsNum
argument_list|)
expr_stmt|;
name|readRowsIndexInBuffer
operator|++
expr_stmt|;
name|passedRowsNum
operator|++
expr_stmt|;
name|rowFetched
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|keyInit
operator|=
literal|false
expr_stmt|;
block|}
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
try|try
block|{
name|ret
operator|=
name|nextKeyBuffer
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|eof
parameter_list|)
block|{
name|eof
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
return|return
name|next
argument_list|(
name|readRows
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|boolean
name|hasRecordsInBuffer
parameter_list|()
block|{
return|return
name|readRowsIndexInBuffer
operator|<
name|recordsNumInValBuffer
return|;
block|}
comment|/**      * get the current row used,make sure called {@link #next(LongWritable)}      * first.      *       * @throws IOException      */
specifier|public
specifier|synchronized
name|void
name|getCurrentRow
parameter_list|(
name|BytesRefArrayWritable
name|ret
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|keyInit
operator|||
name|rowFetched
condition|)
return|return;
if|if
condition|(
operator|!
name|currentValue
operator|.
name|inited
condition|)
block|{
name|currentValueBuffer
argument_list|()
expr_stmt|;
name|ret
operator|.
name|resetValid
argument_list|(
name|columnNumber
argument_list|)
expr_stmt|;
comment|// do this only when not intialized
block|}
comment|// we do not use BytesWritable here to avoid the byte-copy from
comment|// DataOutputStream to BytesWritable
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|prjColIDs
operator|.
name|length
condition|;
operator|++
name|j
control|)
block|{
name|int
name|i
init|=
name|prjColIDs
index|[
name|j
index|]
decl_stmt|;
name|BytesRefWritable
name|ref
init|=
name|ret
operator|.
name|unCheckedGet
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|columnCurrentRowStart
init|=
operator|(
name|int
operator|)
name|columnRowReadIndex
index|[
name|i
index|]
decl_stmt|;
name|int
name|length
init|=
operator|(
name|int
operator|)
name|WritableUtils
operator|.
name|readVLong
argument_list|(
name|colValLenBufferReadIn
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|columnRowReadIndex
index|[
name|i
index|]
operator|=
name|columnCurrentRowStart
operator|+
name|length
expr_stmt|;
name|ref
operator|.
name|set
argument_list|(
name|currentValue
operator|.
name|loadedColumnsValueBuffer
index|[
name|j
index|]
operator|.
name|getData
argument_list|()
argument_list|,
name|columnCurrentRowStart
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|rowFetched
operator|=
literal|true
expr_stmt|;
block|}
comment|/** Returns true iff the previous call to next passed a sync mark. */
specifier|public
name|boolean
name|syncSeen
parameter_list|()
block|{
return|return
name|syncSeen
return|;
block|}
comment|/** Returns the name of the file. */
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|file
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Close the reader. */
specifier|public
name|void
name|close
parameter_list|()
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|currentValue
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|decompress
condition|)
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|keyDecompressedData
argument_list|)
expr_stmt|;
name|CodecPool
operator|.
name|returnDecompressor
argument_list|(
name|keyDecompressor
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

