begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|type
package|;
end_package

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|ZoneId
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|UDFArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|CalciteSubquerySemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ASTNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|SubqueryType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|PrimitiveTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|common
operator|.
name|util
operator|.
name|DateUtils
import|;
end_import

begin_comment
comment|/**  * Generic expressions factory. Currently, the only implementation produces  * Hive {@link ExprNodeDesc}.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|ExprFactory
parameter_list|<
name|T
parameter_list|>
block|{
specifier|static
specifier|final
name|BigDecimal
name|NANOS_PER_SEC_BD
init|=
operator|new
name|BigDecimal
argument_list|(
name|DateUtils
operator|.
name|NANOS_PER_SEC
argument_list|)
decl_stmt|;
comment|/**    * Returns whether the input is an instance of the expression class.    */
specifier|protected
specifier|abstract
name|boolean
name|isExprInstance
parameter_list|(
name|Object
name|o
parameter_list|)
function_decl|;
comment|/**    * Generates an expression from the input column. This may not necessarily    * be a column expression, e.g., if the column is a constant.    */
specifier|protected
specifier|abstract
name|T
name|toExpr
parameter_list|(
name|ColumnInfo
name|colInfo
parameter_list|)
function_decl|;
comment|/* FIELD REFERENCES */
comment|/**    * Returns whether the input object is a column reference expression.    */
specifier|protected
specifier|abstract
name|boolean
name|isColumnRefExpr
parameter_list|(
name|Object
name|o
parameter_list|)
function_decl|;
comment|/**    * Creates column expression.    */
specifier|protected
specifier|abstract
name|T
name|createColumnRefExpr
parameter_list|(
name|ColumnInfo
name|colInfo
parameter_list|)
function_decl|;
comment|/**    * Returns column name referenced by a column expression.    */
specifier|protected
specifier|abstract
name|String
name|getColumnName
parameter_list|(
name|T
name|expr
parameter_list|)
function_decl|;
comment|/* CONSTANT EXPRESSIONS */
comment|/**    * Returns whether the input expression is a constant expression.    */
specifier|protected
specifier|abstract
name|boolean
name|isConstantExpr
parameter_list|(
name|Object
name|o
parameter_list|)
function_decl|;
comment|/**    * Returns whether all input expressions are constant expressions.    */
specifier|protected
name|boolean
name|isAllConstants
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|exprs
parameter_list|)
block|{
for|for
control|(
name|T
name|expr
range|:
name|exprs
control|)
block|{
if|if
condition|(
operator|!
name|isConstantExpr
argument_list|(
name|expr
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns whether the input expression is a struct of    * constant expressions (all of them).    */
specifier|protected
specifier|abstract
name|boolean
name|isConstantStruct
parameter_list|(
name|T
name|expr
parameter_list|)
function_decl|;
comment|/**    * Creates a null constant expression with void type.    */
specifier|protected
specifier|abstract
name|T
name|createNullConstantExpr
parameter_list|()
function_decl|;
comment|/**    * Creates a boolean constant expression from input value.    */
specifier|protected
specifier|abstract
name|T
name|createBooleanConstantExpr
parameter_list|(
name|String
name|value
parameter_list|)
function_decl|;
comment|/**    * Creates a bigint constant expression from input value.    */
specifier|protected
specifier|abstract
name|T
name|createBigintConstantExpr
parameter_list|(
name|String
name|value
parameter_list|)
function_decl|;
comment|/**    * Creates a int constant expression from input value.    */
specifier|protected
specifier|abstract
name|T
name|createIntConstantExpr
parameter_list|(
name|String
name|value
parameter_list|)
function_decl|;
comment|/**    * Creates a smallint constant expression from input value.    */
specifier|protected
specifier|abstract
name|T
name|createSmallintConstantExpr
parameter_list|(
name|String
name|value
parameter_list|)
function_decl|;
comment|/**    * Creates a tinyint constant expression from input value.    */
specifier|protected
specifier|abstract
name|T
name|createTinyintConstantExpr
parameter_list|(
name|String
name|value
parameter_list|)
function_decl|;
comment|/**    * Creates a float constant expression from input value.    */
specifier|protected
specifier|abstract
name|T
name|createFloatConstantExpr
parameter_list|(
name|String
name|value
parameter_list|)
function_decl|;
comment|/**    * Creates a double constant expression from input value.    */
specifier|protected
specifier|abstract
name|T
name|createDoubleConstantExpr
parameter_list|(
name|String
name|value
parameter_list|)
function_decl|;
comment|/**    * Creates a decimal constant expression from input value.    * If the constant created from the input value is null, we return:    * 1) a constant expression containing null value if allowNullValueConstantExpr is true, or    * 2) null if allowNullValueConstantExpr is false.    */
specifier|protected
specifier|abstract
name|T
name|createDecimalConstantExpr
parameter_list|(
name|String
name|value
parameter_list|,
name|boolean
name|allowNullValueConstantExpr
parameter_list|)
function_decl|;
comment|/**    * Creates a string constant expression from input value.    */
specifier|protected
specifier|abstract
name|T
name|createStringConstantExpr
parameter_list|(
name|String
name|value
parameter_list|)
function_decl|;
comment|/**    * Creates a date constant expression from input value.    */
specifier|protected
specifier|abstract
name|T
name|createDateConstantExpr
parameter_list|(
name|String
name|value
parameter_list|)
function_decl|;
comment|/**    * Creates a timestamp constant expression from input value.    */
specifier|protected
specifier|abstract
name|T
name|createTimestampConstantExpr
parameter_list|(
name|String
name|value
parameter_list|)
function_decl|;
comment|/**    * Creates a timestamp with local time zone constant expression from input value.    * ZoneId is the local time zone.    */
specifier|protected
specifier|abstract
name|T
name|createTimestampLocalTimeZoneConstantExpr
parameter_list|(
name|String
name|value
parameter_list|,
name|ZoneId
name|zoneId
parameter_list|)
function_decl|;
comment|/**    * Creates a interval year-month constant expression from input value.    */
specifier|protected
specifier|abstract
name|T
name|createIntervalYearMonthConstantExpr
parameter_list|(
name|String
name|value
parameter_list|)
function_decl|;
comment|/**    * Creates a interval day-time constant expression from input value.    */
specifier|protected
specifier|abstract
name|T
name|createIntervalDayTimeConstantExpr
parameter_list|(
name|String
name|value
parameter_list|)
function_decl|;
comment|/**    * Creates a interval year constant expression from input value.    */
specifier|protected
specifier|abstract
name|T
name|createIntervalYearConstantExpr
parameter_list|(
name|String
name|value
parameter_list|)
function_decl|;
comment|/**    * Creates a interval month constant expression from input value.    */
specifier|protected
specifier|abstract
name|T
name|createIntervalMonthConstantExpr
parameter_list|(
name|String
name|value
parameter_list|)
function_decl|;
comment|/**    * Creates a interval day constant expression from input value.    */
specifier|protected
specifier|abstract
name|T
name|createIntervalDayConstantExpr
parameter_list|(
name|String
name|value
parameter_list|)
function_decl|;
comment|/**    * Creates a interval hour constant expression from input value.    */
specifier|protected
specifier|abstract
name|T
name|createIntervalHourConstantExpr
parameter_list|(
name|String
name|value
parameter_list|)
function_decl|;
comment|/**    * Creates a interval minute constant expression from input value.    */
specifier|protected
specifier|abstract
name|T
name|createIntervalMinuteConstantExpr
parameter_list|(
name|String
name|value
parameter_list|)
function_decl|;
comment|/**    * Creates a interval second constant expression from input value.    */
specifier|protected
specifier|abstract
name|T
name|createIntervalSecondConstantExpr
parameter_list|(
name|String
name|value
parameter_list|)
function_decl|;
comment|/**    * Default generator for constant expression when type cannot be inferred    * from input query.    */
specifier|protected
name|T
name|createConstantExpr
parameter_list|(
name|String
name|value
parameter_list|)
block|{
comment|// The expression can be any one of Double, Long and Integer. We
comment|// try to parse the expression in that order to ensure that the
comment|// most specific type is used for conversion.
name|T
name|result
init|=
literal|null
decl_stmt|;
name|T
name|result2
init|=
literal|null
decl_stmt|;
try|try
block|{
name|result
operator|=
name|createDoubleConstantExpr
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
operator|!
name|value
operator|.
name|toLowerCase
argument_list|()
operator|.
name|contains
argument_list|(
literal|"e"
argument_list|)
condition|)
block|{
name|result2
operator|=
name|createDecimalConstantExpr
argument_list|(
name|value
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|result2
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
literal|null
expr_stmt|;
comment|// We will use decimal if all else fails.
block|}
block|}
name|result
operator|=
name|createBigintConstantExpr
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|result
operator|=
name|createIntConstantExpr
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
comment|// do nothing here, we will throw an exception in the following block
block|}
return|return
name|result
operator|!=
literal|null
condition|?
name|result
else|:
name|result2
return|;
block|}
comment|/**    * Creates a constant expression from input value with given type.    */
specifier|protected
specifier|abstract
name|T
name|createConstantExpr
parameter_list|(
name|TypeInfo
name|typeInfo
parameter_list|,
name|Object
name|constantValue
parameter_list|)
function_decl|;
comment|/**    * Adjust type of constant value based on input type, e.g., adjust precision and scale    * of decimal value based on type information.    */
specifier|protected
specifier|abstract
name|TypeInfo
name|adjustConstantType
parameter_list|(
name|PrimitiveTypeInfo
name|targetType
parameter_list|,
name|Object
name|constantValue
parameter_list|)
function_decl|;
comment|/**    * Interpret the input constant value of source type as target type.    */
specifier|protected
specifier|abstract
name|Object
name|interpretConstantAsPrimitive
parameter_list|(
name|PrimitiveTypeInfo
name|targetType
parameter_list|,
name|Object
name|constantValue
parameter_list|,
name|PrimitiveTypeInfo
name|sourceType
parameter_list|)
function_decl|;
comment|/**    * Returns value stored in a constant expression.    */
specifier|protected
specifier|abstract
name|Object
name|getConstantValue
parameter_list|(
name|T
name|expr
parameter_list|)
function_decl|;
comment|/* METHODS FOR NESTED FIELD REFERENCES CREATION */
comment|/**    * Creates a reference to a nested field.    */
specifier|protected
specifier|abstract
name|T
name|createNestedColumnRefExpr
parameter_list|(
name|TypeInfo
name|typeInfo
parameter_list|,
name|T
name|expr
parameter_list|,
name|String
name|fieldName
parameter_list|,
name|Boolean
name|isList
parameter_list|)
function_decl|;
comment|/* FUNCTIONS */
comment|/**    * Returns whether the input expression is a function call.    */
specifier|protected
specifier|abstract
name|boolean
name|isFuncCallExpr
parameter_list|(
name|Object
name|o
parameter_list|)
function_decl|;
comment|/**    * Creates function call expression.    */
specifier|protected
specifier|abstract
name|T
name|createFuncCallExpr
parameter_list|(
name|TypeInfo
name|typeInfo
parameter_list|,
name|GenericUDF
name|genericUDF
parameter_list|,
name|List
argument_list|<
name|T
argument_list|>
name|inputs
parameter_list|)
function_decl|;
comment|/**    * Creates function call expression.    */
specifier|protected
specifier|abstract
name|T
name|createFuncCallExpr
parameter_list|(
name|GenericUDF
name|genericUDF
parameter_list|,
name|String
name|funcText
parameter_list|,
name|List
argument_list|<
name|T
argument_list|>
name|inputs
parameter_list|)
throws|throws
name|UDFArgumentException
function_decl|;
comment|/**    * Returns whether the input expression is an OR function call.    */
specifier|protected
specifier|abstract
name|boolean
name|isORFuncCallExpr
parameter_list|(
name|T
name|expr
parameter_list|)
function_decl|;
comment|/**    * Returns whether the input expression is an AND function call.    */
specifier|protected
specifier|abstract
name|boolean
name|isANDFuncCallExpr
parameter_list|(
name|T
name|expr
parameter_list|)
function_decl|;
comment|/**    * Returns whether the input expression is a POSITIVE function call.    */
specifier|protected
specifier|abstract
name|boolean
name|isPOSITIVEFuncCallExpr
parameter_list|(
name|T
name|expr
parameter_list|)
function_decl|;
comment|/**    * Returns whether the input expression is a STRUCT function call.    */
specifier|protected
specifier|abstract
name|boolean
name|isSTRUCTFuncCallExpr
parameter_list|(
name|T
name|expr
parameter_list|)
function_decl|;
comment|/**    * The method tries to rewrite an IN function call into an OR/AND function call.    * Returns null if the transformation fails.    */
specifier|protected
specifier|abstract
name|List
argument_list|<
name|T
argument_list|>
name|rewriteINIntoORFuncCallExpr
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|inOperands
parameter_list|)
throws|throws
name|SemanticException
function_decl|;
comment|/**    * Returns true if a CASE expression can be converted into a COALESCE function call.    */
specifier|protected
specifier|abstract
name|boolean
name|canConvertCASEIntoCOALESCEFuncCallExpr
parameter_list|(
name|GenericUDF
name|genericUDF
parameter_list|,
name|List
argument_list|<
name|T
argument_list|>
name|inputs
parameter_list|)
function_decl|;
comment|/* SUBQUERIES */
comment|/**    * Creates subquery expression.    */
specifier|protected
specifier|abstract
name|T
name|createSubqueryExpr
parameter_list|(
name|TypeCheckCtx
name|ctx
parameter_list|,
name|ASTNode
name|subqueryOp
parameter_list|,
name|SubqueryType
name|subqueryType
parameter_list|,
name|Object
index|[]
name|inputs
parameter_list|)
throws|throws
name|CalciteSubquerySemanticException
function_decl|;
comment|/* LIST OF EXPRESSIONS */
comment|/**    * Returns whether the input expression is a list of expressions.    */
specifier|protected
specifier|abstract
name|boolean
name|isExprsListExpr
parameter_list|(
name|Object
name|o
parameter_list|)
function_decl|;
comment|/**    * Creates list of expressions.    */
specifier|protected
specifier|abstract
name|T
name|createExprsListExpr
parameter_list|()
function_decl|;
comment|/**    * Adds expression to list of expressions and returns resulting    * list.    * If column list is mutable, it will not create a copy    * of the input list.    */
specifier|protected
specifier|abstract
name|T
name|addExprToExprsList
parameter_list|(
name|T
name|columnList
parameter_list|,
name|T
name|expr
parameter_list|)
function_decl|;
comment|/* TYPE SYSTEM */
comment|/**    * Returns the type for the input expression.    */
specifier|protected
specifier|abstract
name|TypeInfo
name|getTypeInfo
parameter_list|(
name|T
name|expr
parameter_list|)
function_decl|;
comment|/**    * Changes the type of the input expression to the input type and    * returns resulting expression.    * If the input expression is mutable, it will not create a copy    * of the expression.    */
specifier|protected
specifier|abstract
name|T
name|setTypeInfo
parameter_list|(
name|T
name|expr
parameter_list|,
name|TypeInfo
name|type
parameter_list|)
function_decl|;
comment|/* MISC */
comment|/**    * Folds the input expression and returns resulting expression.    * If the input expression is mutable, it will not create a copy    * of the expression.    */
specifier|protected
specifier|abstract
name|T
name|foldExpr
parameter_list|(
name|T
name|expr
parameter_list|)
function_decl|;
comment|/**    * Returns the children from the input expression (if any).    */
specifier|protected
specifier|abstract
name|List
argument_list|<
name|T
argument_list|>
name|getExprChildren
parameter_list|(
name|T
name|expr
parameter_list|)
function_decl|;
block|}
end_class

end_unit

