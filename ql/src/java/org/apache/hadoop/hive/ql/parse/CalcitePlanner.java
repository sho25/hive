begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ArrayListMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
operator|.
name|Builder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|ClassicToken
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|CommonToken
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|Tree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|TreeVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|TreeVisitorAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|druid
operator|.
name|DruidQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|druid
operator|.
name|DruidSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|druid
operator|.
name|DruidTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|java
operator|.
name|JavaTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|jdbc
operator|.
name|JdbcConvention
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|jdbc
operator|.
name|JdbcImplementor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|jdbc
operator|.
name|JdbcSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|jdbc
operator|.
name|JdbcTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteConnectionConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteConnectionConfigImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteConnectionProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|NullCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|interpreter
operator|.
name|BindableConvention
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptMaterialization
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTraitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepMatchOrder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgramBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollationImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|SetOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|CachingRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|ChainedRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|DefaultRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|JaninoRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinToMultiJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|LoptOptimizeJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectRemoveRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexWindowBound
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|SchemaPlus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDialect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDialectFactoryImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlExplainLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlWindow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|dialect
operator|.
name|HiveSqlDialect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|ArraySqlType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|Frameworks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|CompositeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableIntList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ObjectPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|StrictChecks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|Warehouse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ErrorMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|QueryProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|QueryState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Description
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RowSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|log
operator|.
name|PerfLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Hive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|NotNullConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|PrimaryKeyInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|VirtualColumn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|CalciteSemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|CalciteSemanticException
operator|.
name|UnsupportedFeature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|CalciteSubquerySemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|CalciteViewSemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|HiveCalciteUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|HiveConfPlannerContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|HiveDefaultRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|HivePlannerContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|HiveRelFactories
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|HiveRelOpMaterializationValidator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|HiveRexExecutorImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|HiveTypeSystemImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|RelOptHiveTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|TraitsUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|cost
operator|.
name|HiveAlgorithmsConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|cost
operator|.
name|HiveVolcanoPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveAggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveExcept
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveGroupingID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveIntersect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveRelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveSemiJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveSortLimit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveTableFunctionScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveTableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveUnion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|jdbc
operator|.
name|HiveJdbcConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|jdbc
operator|.
name|JdbcHiveTableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveAggregateJoinTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveAggregateProjectMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveAggregatePullUpConstantsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveAggregateReduceFunctionsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveAggregateReduceRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveDruidRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveExceptRewriteRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveExpandDistinctAggregatesRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveFilterAggregateTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveFilterJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveFilterProjectTSTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveFilterProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveFilterSetOpTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveFilterSortTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveInsertExchange4JoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveIntersectMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveIntersectRewriteRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveJoinAddNotNullRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveJoinCommuteRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveJoinConstraintsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveJoinProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveJoinPushTransitivePredicatesRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveJoinToMultiJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HivePartitionPruneRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HivePointLookupOptimizerRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HivePreFilteringRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveProjectFilterPullUpConstantsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveProjectJoinTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveProjectMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveProjectOverIntersectRemoveRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveProjectSortTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveReduceExpressionsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveReduceExpressionsWithStatsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveRelDecorrelator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveRelFieldTrimmer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveRemoveGBYSemiJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveRemoveSqCountCheck
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveRulesRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveSemiJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveSortJoinReduceRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveSortLimitPullUpConstantsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveSortMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveSortProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveSortRemoveRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveSortUnionReduceRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveSubQueryRemoveRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveUnionMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveUnionPullUpConstantsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveWindowingFixRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|jdbc
operator|.
name|JDBCAbstractSplitFilterRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|jdbc
operator|.
name|JDBCAggregationPushDownRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|jdbc
operator|.
name|JDBCExtractJoinFilterRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|jdbc
operator|.
name|JDBCFilterJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|jdbc
operator|.
name|JDBCFilterPushDownRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|jdbc
operator|.
name|JDBCJoinPushDownRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|jdbc
operator|.
name|JDBCProjectPushDownRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|jdbc
operator|.
name|JDBCSortPushDownRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|jdbc
operator|.
name|JDBCUnionPushDownRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|views
operator|.
name|HiveAggregateIncrementalRewritingRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|views
operator|.
name|HiveMaterializedViewRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|views
operator|.
name|HiveNoAggregateIncrementalRewritingRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|views
operator|.
name|MaterializedViewRewritingRelVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
operator|.
name|ASTBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
operator|.
name|ASTConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
operator|.
name|HiveOpConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
operator|.
name|JoinCondTypeCheckProcFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
operator|.
name|JoinTypeCheckCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
operator|.
name|PlanModifierForReturnPath
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
operator|.
name|RexNodeConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
operator|.
name|SqlFunctionConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
operator|.
name|TypeConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|OrderExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|OrderSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|PartitionExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|PartitionSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|QBExpr
operator|.
name|Opcode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
operator|.
name|BoundarySpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
operator|.
name|WindowExpressionSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
operator|.
name|WindowFunctionSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
operator|.
name|WindowSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
operator|.
name|WindowType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDescUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|GroupByDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|HiveOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|SelectDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFEvaluator
operator|.
name|Mode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDTF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDTFInline
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|serdeConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StandardStructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|ListTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|StructTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|joda
operator|.
name|time
operator|.
name|Interval
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|UndeclaredThrowableException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
operator|.
name|SimpleEntry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|sql
operator|.
name|DataSource
import|;
end_import

begin_class
specifier|public
class|class
name|CalcitePlanner
extends|extends
name|SemanticAnalyzer
block|{
specifier|private
specifier|final
name|AtomicInteger
name|noColsMissingStats
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
name|SemanticException
name|semanticException
decl_stmt|;
specifier|private
name|boolean
name|runCBO
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|disableSemJoinReordering
init|=
literal|true
decl_stmt|;
specifier|private
name|EnumSet
argument_list|<
name|ExtendedCBOProfile
argument_list|>
name|profilesCBO
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CommonToken
name|FROM_TOKEN
init|=
operator|new
name|ImmutableCommonToken
argument_list|(
name|HiveParser
operator|.
name|TOK_FROM
argument_list|,
literal|"TOK_FROM"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CommonToken
name|DEST_TOKEN
init|=
operator|new
name|ImmutableCommonToken
argument_list|(
name|HiveParser
operator|.
name|TOK_DESTINATION
argument_list|,
literal|"TOK_DESTINATION"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CommonToken
name|DIR_TOKEN
init|=
operator|new
name|ImmutableCommonToken
argument_list|(
name|HiveParser
operator|.
name|TOK_DIR
argument_list|,
literal|"TOK_DIR"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CommonToken
name|TMPFILE_TOKEN
init|=
operator|new
name|ImmutableCommonToken
argument_list|(
name|HiveParser
operator|.
name|TOK_TMP_FILE
argument_list|,
literal|"TOK_TMP_FILE"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CommonToken
name|SELECT_TOKEN
init|=
operator|new
name|ImmutableCommonToken
argument_list|(
name|HiveParser
operator|.
name|TOK_SELECT
argument_list|,
literal|"TOK_SELECT"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CommonToken
name|SELEXPR_TOKEN
init|=
operator|new
name|ImmutableCommonToken
argument_list|(
name|HiveParser
operator|.
name|TOK_SELEXPR
argument_list|,
literal|"TOK_SELEXPR"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CommonToken
name|TABLEORCOL_TOKEN
init|=
operator|new
name|ImmutableCommonToken
argument_list|(
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
argument_list|,
literal|"TOK_TABLE_OR_COL"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CommonToken
name|INSERT_TOKEN
init|=
operator|new
name|ImmutableCommonToken
argument_list|(
name|HiveParser
operator|.
name|TOK_INSERT
argument_list|,
literal|"TOK_INSERT"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CommonToken
name|QUERY_TOKEN
init|=
operator|new
name|ImmutableCommonToken
argument_list|(
name|HiveParser
operator|.
name|TOK_QUERY
argument_list|,
literal|"TOK_QUERY"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CommonToken
name|SUBQUERY_TOKEN
init|=
operator|new
name|ImmutableCommonToken
argument_list|(
name|HiveParser
operator|.
name|TOK_SUBQUERY
argument_list|,
literal|"TOK_SUBQUERY"
argument_list|)
decl_stmt|;
specifier|public
name|CalcitePlanner
parameter_list|(
name|QueryState
name|queryState
parameter_list|)
throws|throws
name|SemanticException
block|{
name|super
argument_list|(
name|queryState
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_CBO_ENABLED
argument_list|)
condition|)
block|{
name|runCBO
operator|=
literal|false
expr_stmt|;
name|disableSemJoinReordering
operator|=
literal|false
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|resetCalciteConfiguration
parameter_list|()
block|{
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_CBO_ENABLED
argument_list|)
condition|)
block|{
name|runCBO
operator|=
literal|true
expr_stmt|;
name|disableSemJoinReordering
operator|=
literal|true
expr_stmt|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
name|void
name|analyzeInternal
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|runCBO
condition|)
block|{
name|super
operator|.
name|analyzeInternal
argument_list|(
name|ast
argument_list|,
operator|new
name|PlannerContextFactory
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|PlannerContext
name|create
parameter_list|()
block|{
return|return
operator|new
name|PreCboCtx
argument_list|()
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|super
operator|.
name|analyzeInternal
argument_list|(
name|ast
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This method is useful if we want to obtain the logical plan after being parsed and    * optimized by Calcite.    *    * @return the Calcite plan for the query, null if it could not be generated    */
specifier|public
name|RelNode
name|genLogicalPlan
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting generating logical plan"
argument_list|)
expr_stmt|;
name|PreCboCtx
name|cboCtx
init|=
operator|new
name|PreCboCtx
argument_list|()
decl_stmt|;
comment|//change the location of position alias process here
name|processPositionAlias
argument_list|(
name|ast
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|genResolvedParseTree
argument_list|(
name|ast
argument_list|,
name|cboCtx
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ASTNode
name|queryForCbo
init|=
name|ast
decl_stmt|;
if|if
condition|(
name|cboCtx
operator|.
name|type
operator|==
name|PreCboCtx
operator|.
name|Type
operator|.
name|CTAS
operator|||
name|cboCtx
operator|.
name|type
operator|==
name|PreCboCtx
operator|.
name|Type
operator|.
name|VIEW
condition|)
block|{
name|queryForCbo
operator|=
name|cboCtx
operator|.
name|nodeOfInterest
expr_stmt|;
comment|// nodeOfInterest is the query
block|}
name|runCBO
operator|=
name|canCBOHandleAst
argument_list|(
name|queryForCbo
argument_list|,
name|getQB
argument_list|()
argument_list|,
name|cboCtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|runCBO
condition|)
block|{
return|return
literal|null
return|;
block|}
name|profilesCBO
operator|=
name|obtainCBOProfiles
argument_list|(
name|queryProperties
argument_list|)
expr_stmt|;
name|disableJoinMerge
operator|=
literal|true
expr_stmt|;
specifier|final
name|RelNode
name|resPlan
init|=
name|logicalPlan
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Finished generating logical plan"
argument_list|)
expr_stmt|;
return|return
name|resPlan
return|;
block|}
specifier|public
specifier|static
name|RelOptPlanner
name|createPlanner
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
block|{
return|return
name|createPlanner
argument_list|(
name|conf
argument_list|,
operator|new
name|HashSet
argument_list|<
name|RelNode
argument_list|>
argument_list|()
argument_list|,
operator|new
name|HashSet
argument_list|<
name|RelNode
argument_list|>
argument_list|()
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|RelOptPlanner
name|createPlanner
parameter_list|(
name|HiveConf
name|conf
parameter_list|,
name|Set
argument_list|<
name|RelNode
argument_list|>
name|corrScalarRexSQWithAgg
parameter_list|,
name|Set
argument_list|<
name|RelNode
argument_list|>
name|scalarAggNoGbyNoWin
parameter_list|)
block|{
specifier|final
name|Double
name|maxSplitSize
init|=
operator|(
name|double
operator|)
name|HiveConf
operator|.
name|getLongVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|MAPREDMAXSPLITSIZE
argument_list|)
decl_stmt|;
specifier|final
name|Double
name|maxMemory
init|=
operator|(
name|double
operator|)
name|HiveConf
operator|.
name|getLongVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVECONVERTJOINNOCONDITIONALTASKTHRESHOLD
argument_list|)
decl_stmt|;
name|HiveAlgorithmsConf
name|algorithmsConf
init|=
operator|new
name|HiveAlgorithmsConf
argument_list|(
name|maxSplitSize
argument_list|,
name|maxMemory
argument_list|)
decl_stmt|;
name|HiveRulesRegistry
name|registry
init|=
operator|new
name|HiveRulesRegistry
argument_list|()
decl_stmt|;
name|Properties
name|calciteConfigProperties
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|calciteConfigProperties
operator|.
name|setProperty
argument_list|(
name|CalciteConnectionProperty
operator|.
name|TIME_ZONE
operator|.
name|camelName
argument_list|()
argument_list|,
name|conf
operator|.
name|getLocalTimeZone
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|calciteConfigProperties
operator|.
name|setProperty
argument_list|(
name|CalciteConnectionProperty
operator|.
name|MATERIALIZATIONS_ENABLED
operator|.
name|camelName
argument_list|()
argument_list|,
name|Boolean
operator|.
name|FALSE
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|CalciteConnectionConfig
name|calciteConfig
init|=
operator|new
name|CalciteConnectionConfigImpl
argument_list|(
name|calciteConfigProperties
argument_list|)
decl_stmt|;
name|boolean
name|isCorrelatedColumns
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_CBO_STATS_CORRELATED_MULTI_KEY_JOINS
argument_list|)
decl_stmt|;
name|boolean
name|heuristicMaterializationStrategy
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_MATERIALIZED_VIEW_REWRITING_SELECTION_STRATEGY
argument_list|)
operator|.
name|equals
argument_list|(
literal|"heuristic"
argument_list|)
decl_stmt|;
name|HivePlannerContext
name|confContext
init|=
operator|new
name|HivePlannerContext
argument_list|(
name|algorithmsConf
argument_list|,
name|registry
argument_list|,
name|calciteConfig
argument_list|,
name|corrScalarRexSQWithAgg
argument_list|,
name|scalarAggNoGbyNoWin
argument_list|,
operator|new
name|HiveConfPlannerContext
argument_list|(
name|isCorrelatedColumns
argument_list|,
name|heuristicMaterializationStrategy
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|HiveVolcanoPlanner
operator|.
name|createPlanner
argument_list|(
name|confContext
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
name|Operator
name|genOPTree
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|PlannerContext
name|plannerCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
name|sinkOp
init|=
literal|null
decl_stmt|;
name|boolean
name|skipCalcitePlan
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|runCBO
condition|)
block|{
name|skipCalcitePlan
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|PreCboCtx
name|cboCtx
init|=
operator|(
name|PreCboCtx
operator|)
name|plannerCtx
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|oldHints
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Cache the hints before CBO runs and removes them.
comment|// Use the hints later in top level QB.
name|getHintsFromQB
argument_list|(
name|getQB
argument_list|()
argument_list|,
name|oldHints
argument_list|)
expr_stmt|;
comment|// Note: for now, we don't actually pass the queryForCbo to CBO, because
comment|// it accepts qb, not AST, and can also access all the private stuff in
comment|// SA. We rely on the fact that CBO ignores the unknown tokens (create
comment|// table, destination), so if the query is otherwise ok, it is as if we
comment|// did remove those and gave CBO the proper AST. That is kinda hacky.
name|ASTNode
name|queryForCbo
init|=
name|ast
decl_stmt|;
if|if
condition|(
name|cboCtx
operator|.
name|type
operator|==
name|PreCboCtx
operator|.
name|Type
operator|.
name|CTAS
operator|||
name|cboCtx
operator|.
name|type
operator|==
name|PreCboCtx
operator|.
name|Type
operator|.
name|VIEW
condition|)
block|{
name|queryForCbo
operator|=
name|cboCtx
operator|.
name|nodeOfInterest
expr_stmt|;
comment|// nodeOfInterest is the query
block|}
name|runCBO
operator|=
name|canCBOHandleAst
argument_list|(
name|queryForCbo
argument_list|,
name|getQB
argument_list|()
argument_list|,
name|cboCtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|queryProperties
operator|.
name|hasMultiDestQuery
argument_list|()
condition|)
block|{
name|handleMultiDestQuery
argument_list|(
name|ast
argument_list|,
name|cboCtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|runCBO
condition|)
block|{
name|profilesCBO
operator|=
name|obtainCBOProfiles
argument_list|(
name|queryProperties
argument_list|)
expr_stmt|;
name|disableJoinMerge
operator|=
literal|true
expr_stmt|;
name|boolean
name|reAnalyzeAST
init|=
literal|false
decl_stmt|;
specifier|final
name|boolean
name|materializedView
init|=
name|getQB
argument_list|()
operator|.
name|isMaterializedView
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|this
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_CBO_RETPATH_HIVEOP
argument_list|)
condition|)
block|{
if|if
condition|(
name|cboCtx
operator|.
name|type
operator|==
name|PreCboCtx
operator|.
name|Type
operator|.
name|VIEW
operator|&&
operator|!
name|materializedView
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Create view is not supported in cbo return path."
argument_list|)
throw|;
block|}
name|sinkOp
operator|=
name|getOptimizedHiveOPDag
argument_list|()
expr_stmt|;
if|if
condition|(
name|oldHints
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Propagating hints to QB: "
operator|+
name|oldHints
argument_list|)
expr_stmt|;
name|getQB
argument_list|()
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setHintList
argument_list|(
name|oldHints
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"CBO Succeeded; optimized logical plan."
argument_list|)
expr_stmt|;
name|this
operator|.
name|ctx
operator|.
name|setCboInfo
argument_list|(
literal|"Plan optimized by CBO."
argument_list|)
expr_stmt|;
name|this
operator|.
name|ctx
operator|.
name|setCboSucceeded
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// 0. Gen Optimized Plan
specifier|final
name|RelNode
name|newPlan
init|=
name|logicalPlan
argument_list|()
decl_stmt|;
comment|// 1. Convert Plan to AST
name|ASTNode
name|newAST
init|=
name|getOptimizedAST
argument_list|(
name|newPlan
argument_list|)
decl_stmt|;
comment|// 1.1. Fix up the query for insert/ctas/materialized views
name|newAST
operator|=
name|fixUpAfterCbo
argument_list|(
name|ast
argument_list|,
name|newAST
argument_list|,
name|cboCtx
argument_list|)
expr_stmt|;
comment|// 1.2. Fix up the query for materialization rebuild
if|if
condition|(
name|mvRebuildMode
operator|==
name|MaterializationRebuildMode
operator|.
name|AGGREGATE_REBUILD
condition|)
block|{
name|fixUpASTAggregateIncrementalRebuild
argument_list|(
name|newAST
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mvRebuildMode
operator|==
name|MaterializationRebuildMode
operator|.
name|NO_AGGREGATE_REBUILD
condition|)
block|{
name|fixUpASTNoAggregateIncrementalRebuild
argument_list|(
name|newAST
argument_list|)
expr_stmt|;
block|}
comment|// 2. Regen OP plan from optimized AST
if|if
condition|(
name|cboCtx
operator|.
name|type
operator|==
name|PreCboCtx
operator|.
name|Type
operator|.
name|VIEW
condition|)
block|{
try|try
block|{
name|viewSelect
operator|=
name|handleCreateViewDDL
argument_list|(
name|newAST
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CalciteViewSemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|cboCtx
operator|.
name|type
operator|==
name|PreCboCtx
operator|.
name|Type
operator|.
name|CTAS
condition|)
block|{
comment|// CTAS
name|init
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|setAST
argument_list|(
name|newAST
argument_list|)
expr_stmt|;
name|newAST
operator|=
name|reAnalyzeCTASAfterCbo
argument_list|(
name|newAST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// All others
name|init
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldHints
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|getQB
argument_list|()
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getHints
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Hints are not null in the optimized tree; "
operator|+
literal|"after CBO "
operator|+
name|getQB
argument_list|()
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getHints
argument_list|()
operator|.
name|dump
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Propagating hints to QB: "
operator|+
name|oldHints
argument_list|)
expr_stmt|;
name|getQB
argument_list|()
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setHintList
argument_list|(
name|oldHints
argument_list|)
expr_stmt|;
block|}
block|}
name|Phase1Ctx
name|ctx_1
init|=
name|initPhase1Ctx
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|doPhase1
argument_list|(
name|newAST
argument_list|,
name|getQB
argument_list|()
argument_list|,
name|ctx_1
argument_list|,
literal|null
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Couldn't do phase1 on CBO optimized query plan"
argument_list|)
throw|;
block|}
comment|// unfortunately making prunedPartitions immutable is not possible
comment|// here with SemiJoins not all tables are costed in CBO, so their
comment|// PartitionList is not evaluated until the run phase.
name|getMetaData
argument_list|(
name|getQB
argument_list|()
argument_list|)
expr_stmt|;
name|disableJoinMerge
operator|=
name|defaultJoinMerge
expr_stmt|;
name|sinkOp
operator|=
name|genPlan
argument_list|(
name|getQB
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"CBO Succeeded; optimized logical plan."
argument_list|)
expr_stmt|;
name|this
operator|.
name|ctx
operator|.
name|setCboInfo
argument_list|(
literal|"Plan optimized by CBO."
argument_list|)
expr_stmt|;
name|this
operator|.
name|ctx
operator|.
name|setCboSucceeded
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|ctx
operator|.
name|isExplainPlan
argument_list|()
condition|)
block|{
name|ExplainConfiguration
name|explainConfig
init|=
name|this
operator|.
name|ctx
operator|.
name|getExplainConfig
argument_list|()
decl_stmt|;
if|if
condition|(
name|explainConfig
operator|.
name|isCbo
argument_list|()
condition|)
block|{
if|if
condition|(
name|explainConfig
operator|.
name|isCboExtended
argument_list|()
condition|)
block|{
comment|// Include join cost
name|this
operator|.
name|ctx
operator|.
name|setCalcitePlan
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|newPlan
argument_list|,
name|SqlExplainLevel
operator|.
name|ALL_ATTRIBUTES
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Do not include join cost
name|this
operator|.
name|ctx
operator|.
name|setCalcitePlan
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|newPlan
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|explainConfig
operator|.
name|isExtended
argument_list|()
operator|||
name|explainConfig
operator|.
name|isFormatted
argument_list|()
condition|)
block|{
name|this
operator|.
name|ctx
operator|.
name|setOptimizedSql
argument_list|(
name|getOptimizedSql
argument_list|(
name|newPlan
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|getOptimizedSql
argument_list|(
name|newPlan
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
name|newAST
operator|.
name|dump
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|boolean
name|isMissingStats
init|=
name|noColsMissingStats
operator|.
name|get
argument_list|()
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|isMissingStats
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"CBO failed due to missing column stats (see previous errors), skipping CBO"
argument_list|)
expr_stmt|;
name|this
operator|.
name|ctx
operator|.
name|setCboInfo
argument_list|(
literal|"Plan not optimized by CBO due to missing statistics. Please check log for more details."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"CBO failed, skipping CBO. "
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|CalciteSemanticException
condition|)
block|{
name|CalciteSemanticException
name|calciteSemanticException
init|=
operator|(
name|CalciteSemanticException
operator|)
name|e
decl_stmt|;
name|UnsupportedFeature
name|unsupportedFeature
init|=
name|calciteSemanticException
operator|.
name|getUnsupportedFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|unsupportedFeature
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|ctx
operator|.
name|setCboInfo
argument_list|(
literal|"Plan not optimized by CBO due to missing feature ["
operator|+
name|unsupportedFeature
operator|+
literal|"]."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|ctx
operator|.
name|setCboInfo
argument_list|(
literal|"Plan not optimized by CBO."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|this
operator|.
name|ctx
operator|.
name|setCboInfo
argument_list|(
literal|"Plan not optimized by CBO."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|instanceof
name|CalciteSubquerySemanticException
condition|)
block|{
comment|// non-cbo path retries to execute subqueries and throws completely different exception/error
comment|// to eclipse the original error message
comment|// so avoid executing subqueries on non-cbo
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|CalciteViewSemanticException
condition|)
block|{
comment|// non-cbo path retries to execute create view and
comment|// we believe it will throw the same error message
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_IN_TEST
argument_list|)
operator|||
name|isMissingStats
operator|||
name|e
operator|instanceof
name|CalciteSemanticException
condition|)
block|{
name|reAnalyzeAST
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|SemanticException
operator|&&
operator|!
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_IN_TEST
argument_list|)
condition|)
block|{
comment|// although, its likely to be a valid exception, we will retry
comment|// with cbo off anyway.
comment|// for tests we would like to avoid retrying to catch cbo failures
name|reAnalyzeAST
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|RuntimeException
condition|)
block|{
throw|throw
operator|(
name|RuntimeException
operator|)
name|e
throw|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|SemanticException
condition|)
block|{
throw|throw
name|e
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|runCBO
operator|=
literal|false
expr_stmt|;
name|disableJoinMerge
operator|=
name|defaultJoinMerge
expr_stmt|;
name|disableSemJoinReordering
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|reAnalyzeAST
condition|)
block|{
name|init
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|prunedPartitions
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Assumption: At this point Parse Tree gen& resolution will always
comment|// be true (since we started out that way).
name|super
operator|.
name|genResolvedParseTree
argument_list|(
name|ast
argument_list|,
operator|new
name|PlannerContext
argument_list|()
argument_list|)
expr_stmt|;
name|skipCalcitePlan
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|this
operator|.
name|ctx
operator|.
name|setCboInfo
argument_list|(
literal|"Plan not optimized by CBO."
argument_list|)
expr_stmt|;
name|skipCalcitePlan
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|skipCalcitePlan
condition|)
block|{
name|sinkOp
operator|=
name|super
operator|.
name|genOPTree
argument_list|(
name|ast
argument_list|,
name|plannerCtx
argument_list|)
expr_stmt|;
block|}
return|return
name|sinkOp
return|;
block|}
specifier|private
name|ASTNode
name|handleCreateViewDDL
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|saveViewDefinition
argument_list|()
expr_stmt|;
name|String
name|originalText
init|=
name|createVwDesc
operator|.
name|getViewOriginalText
argument_list|()
decl_stmt|;
name|String
name|expandedText
init|=
name|createVwDesc
operator|.
name|getViewExpandedText
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|schema
init|=
name|createVwDesc
operator|.
name|getSchema
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|partitionColumns
init|=
name|createVwDesc
operator|.
name|getPartCols
argument_list|()
decl_stmt|;
name|init
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|setAST
argument_list|(
name|ast
argument_list|)
expr_stmt|;
name|ASTNode
name|newAST
init|=
name|reAnalyzeViewAfterCbo
argument_list|(
name|ast
argument_list|)
decl_stmt|;
name|createVwDesc
operator|.
name|setViewOriginalText
argument_list|(
name|originalText
argument_list|)
expr_stmt|;
name|createVwDesc
operator|.
name|setViewExpandedText
argument_list|(
name|expandedText
argument_list|)
expr_stmt|;
name|createVwDesc
operator|.
name|setSchema
argument_list|(
name|schema
argument_list|)
expr_stmt|;
name|createVwDesc
operator|.
name|setPartCols
argument_list|(
name|partitionColumns
argument_list|)
expr_stmt|;
return|return
name|newAST
return|;
block|}
comment|/*    * Tries to optimize FROM clause of multi-insert. No attempt to optimize insert clauses of the query.    * Returns true if rewriting is successful, false otherwise.    */
specifier|private
name|void
name|handleMultiDestQuery
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|PreCboCtx
name|cboCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Not supported by CBO
if|if
condition|(
operator|!
name|runCBO
condition|)
block|{
return|return;
block|}
comment|// Currently, we only optimized the query the content of the FROM clause
comment|// for multi-insert queries. Thus, nodeOfInterest is the FROM clause
if|if
condition|(
name|isJoinToken
argument_list|(
name|cboCtx
operator|.
name|nodeOfInterest
argument_list|)
condition|)
block|{
comment|// Join clause: rewriting is needed
name|ASTNode
name|subq
init|=
name|rewriteASTForMultiInsert
argument_list|(
name|ast
argument_list|,
name|cboCtx
operator|.
name|nodeOfInterest
argument_list|)
decl_stmt|;
if|if
condition|(
name|subq
operator|!=
literal|null
condition|)
block|{
comment|// We could rewrite into a subquery
name|cboCtx
operator|.
name|nodeOfInterest
operator|=
operator|(
name|ASTNode
operator|)
name|subq
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QB
name|newQB
init|=
operator|new
name|QB
argument_list|(
literal|null
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|Phase1Ctx
name|ctx_1
init|=
name|initPhase1Ctx
argument_list|()
decl_stmt|;
name|doPhase1
argument_list|(
name|cboCtx
operator|.
name|nodeOfInterest
argument_list|,
name|newQB
argument_list|,
name|ctx_1
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|setQB
argument_list|(
name|newQB
argument_list|)
expr_stmt|;
name|getMetaData
argument_list|(
name|getQB
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|runCBO
operator|=
literal|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cboCtx
operator|.
name|nodeOfInterest
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY
condition|)
block|{
comment|// Subquery: no rewriting needed
name|ASTNode
name|subq
init|=
name|cboCtx
operator|.
name|nodeOfInterest
decl_stmt|;
comment|// First child is subquery, second child is alias
comment|// We set the node of interest and QB to the subquery
comment|// We do not need to generate the QB again, but rather we use it directly
name|cboCtx
operator|.
name|nodeOfInterest
operator|=
operator|(
name|ASTNode
operator|)
name|subq
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|String
name|subQAlias
init|=
name|unescapeIdentifier
argument_list|(
name|subq
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|QB
name|newQB
init|=
name|getQB
argument_list|()
operator|.
name|getSubqForAlias
argument_list|(
name|subQAlias
argument_list|)
operator|.
name|getQB
argument_list|()
decl_stmt|;
name|newQB
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setAlias
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|newQB
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setIsSubQ
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|setQB
argument_list|(
name|newQB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// No need to run CBO (table ref or virtual table) or not supported
name|runCBO
operator|=
literal|false
expr_stmt|;
block|}
block|}
specifier|private
name|ASTNode
name|rewriteASTForMultiInsert
parameter_list|(
name|ASTNode
name|query
parameter_list|,
name|ASTNode
name|nodeOfInterest
parameter_list|)
block|{
comment|// 1. gather references from original query
comment|// This is a map from aliases to references.
comment|// We keep all references as we will need to modify them after creating
comment|// the subquery
specifier|final
name|Multimap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|aliasNodes
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
comment|// To know if we need to bail out
specifier|final
name|AtomicBoolean
name|notSupported
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|TreeVisitorAction
name|action
init|=
operator|new
name|TreeVisitorAction
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|pre
parameter_list|(
name|Object
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|notSupported
operator|.
name|get
argument_list|()
condition|)
block|{
if|if
condition|(
name|ParseDriver
operator|.
name|adaptor
operator|.
name|getType
argument_list|(
name|t
argument_list|)
operator|==
name|HiveParser
operator|.
name|TOK_ALLCOLREF
condition|)
block|{
comment|// TODO: this is a limitation of the AST rewriting approach that we will
comment|// not be able to overcome till proper integration of full multi-insert
comment|// queries with Calcite is implemented.
comment|// The current rewriting gather references from insert clauses and then
comment|// updates them with the new subquery references. However, if insert
comment|// clauses use * or tab.*, we cannot resolve the columns that we are
comment|// referring to. Thus, we just bail out and those queries will not be
comment|// currently optimized by Calcite.
comment|// An example of such query is:
comment|// FROM T_A a LEFT JOIN T_B b ON a.id = b.id
comment|// INSERT OVERWRITE TABLE join_result_1
comment|// SELECT a.*, b.*
comment|// INSERT OVERWRITE TABLE join_result_3
comment|// SELECT a.*, b.*;
name|notSupported
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ParseDriver
operator|.
name|adaptor
operator|.
name|getType
argument_list|(
name|t
argument_list|)
operator|==
name|HiveParser
operator|.
name|DOT
condition|)
block|{
name|Object
name|c
init|=
name|ParseDriver
operator|.
name|adaptor
operator|.
name|getChild
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
operator|&&
name|ParseDriver
operator|.
name|adaptor
operator|.
name|getType
argument_list|(
name|c
argument_list|)
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
condition|)
block|{
name|aliasNodes
operator|.
name|put
argument_list|(
operator|(
operator|(
name|ASTNode
operator|)
name|t
operator|)
operator|.
name|toStringTree
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ParseDriver
operator|.
name|adaptor
operator|.
name|getType
argument_list|(
name|t
argument_list|)
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
condition|)
block|{
name|Object
name|p
init|=
name|ParseDriver
operator|.
name|adaptor
operator|.
name|getParent
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|null
operator|||
name|ParseDriver
operator|.
name|adaptor
operator|.
name|getType
argument_list|(
name|p
argument_list|)
operator|!=
name|HiveParser
operator|.
name|DOT
condition|)
block|{
name|aliasNodes
operator|.
name|put
argument_list|(
operator|(
operator|(
name|ASTNode
operator|)
name|t
operator|)
operator|.
name|toStringTree
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|t
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|post
parameter_list|(
name|Object
name|t
parameter_list|)
block|{
return|return
name|t
return|;
block|}
block|}
decl_stmt|;
name|TreeVisitor
name|tv
init|=
operator|new
name|TreeVisitor
argument_list|(
name|ParseDriver
operator|.
name|adaptor
argument_list|)
decl_stmt|;
comment|// We will iterate through the children: if it is an INSERT, we will traverse
comment|// the subtree to gather the references
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|query
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|query
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|ParseDriver
operator|.
name|adaptor
operator|.
name|getType
argument_list|(
name|child
argument_list|)
operator|!=
name|HiveParser
operator|.
name|TOK_INSERT
condition|)
block|{
comment|// If it is not an INSERT, we do not need to anything
continue|continue;
block|}
name|tv
operator|.
name|visit
argument_list|(
name|child
argument_list|,
name|action
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|notSupported
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// Bail out
return|return
literal|null
return|;
block|}
comment|// 2. rewrite into query
comment|//  TOK_QUERY
comment|//     TOK_FROM
comment|//        join
comment|//     TOK_INSERT
comment|//        TOK_DESTINATION
comment|//           TOK_DIR
comment|//              TOK_TMP_FILE
comment|//        TOK_SELECT
comment|//           refs
name|ASTNode
name|from
init|=
operator|new
name|ASTNode
argument_list|(
name|FROM_TOKEN
argument_list|)
decl_stmt|;
name|from
operator|.
name|addChild
argument_list|(
operator|(
name|ASTNode
operator|)
name|ParseDriver
operator|.
name|adaptor
operator|.
name|dupTree
argument_list|(
name|nodeOfInterest
argument_list|)
argument_list|)
expr_stmt|;
name|ASTNode
name|destination
init|=
operator|new
name|ASTNode
argument_list|(
name|DEST_TOKEN
argument_list|)
decl_stmt|;
name|ASTNode
name|dir
init|=
operator|new
name|ASTNode
argument_list|(
name|DIR_TOKEN
argument_list|)
decl_stmt|;
name|ASTNode
name|tmpFile
init|=
operator|new
name|ASTNode
argument_list|(
name|TMPFILE_TOKEN
argument_list|)
decl_stmt|;
name|dir
operator|.
name|addChild
argument_list|(
name|tmpFile
argument_list|)
expr_stmt|;
name|destination
operator|.
name|addChild
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|ASTNode
name|select
init|=
operator|new
name|ASTNode
argument_list|(
name|SELECT_TOKEN
argument_list|)
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Collection
argument_list|<
name|Object
argument_list|>
name|selectIdentifier
range|:
name|aliasNodes
operator|.
name|asMap
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|Iterator
argument_list|<
name|Object
argument_list|>
name|it
init|=
name|selectIdentifier
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|ASTNode
name|node
init|=
operator|(
name|ASTNode
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// Add select expression
name|ASTNode
name|selectExpr
init|=
operator|new
name|ASTNode
argument_list|(
name|SELEXPR_TOKEN
argument_list|)
decl_stmt|;
name|selectExpr
operator|.
name|addChild
argument_list|(
operator|(
name|ASTNode
operator|)
name|ParseDriver
operator|.
name|adaptor
operator|.
name|dupTree
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
comment|// Identifier
name|String
name|colAlias
init|=
literal|"col"
operator|+
name|num
decl_stmt|;
name|selectExpr
operator|.
name|addChild
argument_list|(
operator|new
name|ASTNode
argument_list|(
operator|new
name|CommonToken
argument_list|(
name|HiveParser
operator|.
name|Identifier
argument_list|,
name|colAlias
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Alias
name|select
operator|.
name|addChild
argument_list|(
name|selectExpr
argument_list|)
expr_stmt|;
comment|// Rewrite all INSERT references (all the node values for this key)
name|ASTNode
name|colExpr
init|=
operator|new
name|ASTNode
argument_list|(
name|TABLEORCOL_TOKEN
argument_list|)
decl_stmt|;
name|colExpr
operator|.
name|addChild
argument_list|(
operator|new
name|ASTNode
argument_list|(
operator|new
name|CommonToken
argument_list|(
name|HiveParser
operator|.
name|Identifier
argument_list|,
name|colAlias
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|replaceASTChild
argument_list|(
name|node
argument_list|,
name|colExpr
argument_list|)
expr_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// Loop to rewrite rest of INSERT references
name|node
operator|=
operator|(
name|ASTNode
operator|)
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|colExpr
operator|=
operator|new
name|ASTNode
argument_list|(
name|TABLEORCOL_TOKEN
argument_list|)
expr_stmt|;
name|colExpr
operator|.
name|addChild
argument_list|(
operator|new
name|ASTNode
argument_list|(
operator|new
name|CommonToken
argument_list|(
name|HiveParser
operator|.
name|Identifier
argument_list|,
name|colAlias
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|replaceASTChild
argument_list|(
name|node
argument_list|,
name|colExpr
argument_list|)
expr_stmt|;
block|}
name|num
operator|++
expr_stmt|;
block|}
name|ASTNode
name|insert
init|=
operator|new
name|ASTNode
argument_list|(
name|INSERT_TOKEN
argument_list|)
decl_stmt|;
name|insert
operator|.
name|addChild
argument_list|(
name|destination
argument_list|)
expr_stmt|;
name|insert
operator|.
name|addChild
argument_list|(
name|select
argument_list|)
expr_stmt|;
name|ASTNode
name|newQuery
init|=
operator|new
name|ASTNode
argument_list|(
name|QUERY_TOKEN
argument_list|)
decl_stmt|;
name|newQuery
operator|.
name|addChild
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|newQuery
operator|.
name|addChild
argument_list|(
name|insert
argument_list|)
expr_stmt|;
comment|// 3. create subquery
name|ASTNode
name|subq
init|=
operator|new
name|ASTNode
argument_list|(
name|SUBQUERY_TOKEN
argument_list|)
decl_stmt|;
name|subq
operator|.
name|addChild
argument_list|(
name|newQuery
argument_list|)
expr_stmt|;
name|subq
operator|.
name|addChild
argument_list|(
operator|new
name|ASTNode
argument_list|(
operator|new
name|CommonToken
argument_list|(
name|HiveParser
operator|.
name|Identifier
argument_list|,
literal|"subq"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|replaceASTChild
argument_list|(
name|nodeOfInterest
argument_list|,
name|subq
argument_list|)
expr_stmt|;
comment|// 4. return subquery
return|return
name|subq
return|;
block|}
comment|/**    * Can CBO handle the given AST?    *    * @param ast    *          Top level AST    * @param qb    *          top level QB corresponding to the AST    * @param cboCtx    * @return boolean    *    *         Assumption:<br>    *         If top level QB is query then everything below it must also be    *         Query.    */
name|boolean
name|canCBOHandleAst
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|QB
name|qb
parameter_list|,
name|PreCboCtx
name|cboCtx
parameter_list|)
block|{
name|int
name|root
init|=
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
decl_stmt|;
name|boolean
name|needToLogMessage
init|=
name|STATIC_LOG
operator|.
name|isInfoEnabled
argument_list|()
decl_stmt|;
name|boolean
name|isSupportedRoot
init|=
name|root
operator|==
name|HiveParser
operator|.
name|TOK_QUERY
operator|||
name|root
operator|==
name|HiveParser
operator|.
name|TOK_EXPLAIN
operator|||
name|qb
operator|.
name|isCTAS
argument_list|()
operator|||
name|qb
operator|.
name|isMaterializedView
argument_list|()
decl_stmt|;
comment|// Queries without a source table currently are not supported by CBO
name|boolean
name|isSupportedType
init|=
operator|(
name|qb
operator|.
name|getIsQuery
argument_list|()
operator|)
operator|||
name|qb
operator|.
name|isCTAS
argument_list|()
operator|||
name|qb
operator|.
name|isMaterializedView
argument_list|()
operator|||
name|cboCtx
operator|.
name|type
operator|==
name|PreCboCtx
operator|.
name|Type
operator|.
name|INSERT
operator|||
name|cboCtx
operator|.
name|type
operator|==
name|PreCboCtx
operator|.
name|Type
operator|.
name|MULTI_INSERT
decl_stmt|;
name|boolean
name|noBadTokens
init|=
name|HiveCalciteUtil
operator|.
name|validateASTForUnsupportedTokens
argument_list|(
name|ast
argument_list|)
decl_stmt|;
name|boolean
name|result
init|=
name|isSupportedRoot
operator|&&
name|isSupportedType
operator|&&
name|noBadTokens
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
if|if
condition|(
name|needToLogMessage
condition|)
block|{
name|String
name|msg
init|=
literal|""
decl_stmt|;
if|if
condition|(
operator|!
name|isSupportedRoot
condition|)
block|{
name|msg
operator|+=
literal|"doesn't have QUERY or EXPLAIN as root and not a CTAS; "
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isSupportedType
condition|)
block|{
name|msg
operator|+=
literal|"is not a query with at least one source table "
operator|+
literal|" or there is a subquery without a source table, or CTAS, or insert; "
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|noBadTokens
condition|)
block|{
name|msg
operator|+=
literal|"has unsupported tokens; "
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|msg
operator|+=
literal|"has some unspecified limitations; "
expr_stmt|;
block|}
name|STATIC_LOG
operator|.
name|info
argument_list|(
literal|"Not invoking CBO because the statement "
operator|+
name|msg
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|msg
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|// Now check QB in more detail. canHandleQbForCbo returns null if query can
comment|// be handled.
name|String
name|msg
init|=
name|CalcitePlanner
operator|.
name|canHandleQbForCbo
argument_list|(
name|queryProperties
argument_list|,
name|conf
argument_list|,
literal|true
argument_list|,
name|needToLogMessage
argument_list|,
name|qb
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|needToLogMessage
condition|)
block|{
name|STATIC_LOG
operator|.
name|info
argument_list|(
literal|"Not invoking CBO because the statement "
operator|+
name|msg
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|msg
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Checks whether Calcite can handle the query.    *    * @param queryProperties    * @param conf    * @param topLevelQB    *          Does QB corresponds to top most query block?    * @param verbose    *          Whether return value should be verbose in case of failure.    * @return null if the query can be handled; non-null reason string if it    *         cannot be.    *    *         Assumption:<br>    *         1. If top level QB is query then everything below it must also be    *         Query<br>    *         2. Nested Subquery will return false for qbToChk.getIsQuery()    */
specifier|static
name|String
name|canHandleQbForCbo
parameter_list|(
name|QueryProperties
name|queryProperties
parameter_list|,
name|HiveConf
name|conf
parameter_list|,
name|boolean
name|topLevelQB
parameter_list|,
name|boolean
name|verbose
parameter_list|,
name|QB
name|qb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|queryProperties
operator|.
name|hasClusterBy
argument_list|()
operator|&&
operator|!
name|queryProperties
operator|.
name|hasDistributeBy
argument_list|()
operator|&&
operator|!
name|queryProperties
operator|.
name|hasSortBy
argument_list|()
operator|&&
operator|!
name|queryProperties
operator|.
name|hasPTF
argument_list|()
operator|&&
operator|!
name|queryProperties
operator|.
name|usesScript
argument_list|()
operator|&&
name|queryProperties
operator|.
name|isCBOSupportedLateralViews
argument_list|()
condition|)
block|{
comment|// Ok to run CBO.
return|return
literal|null
return|;
block|}
comment|// Not ok to run CBO, build error message.
name|String
name|msg
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|queryProperties
operator|.
name|hasClusterBy
argument_list|()
condition|)
name|msg
operator|+=
literal|"has cluster by; "
expr_stmt|;
if|if
condition|(
name|queryProperties
operator|.
name|hasDistributeBy
argument_list|()
condition|)
name|msg
operator|+=
literal|"has distribute by; "
expr_stmt|;
if|if
condition|(
name|queryProperties
operator|.
name|hasSortBy
argument_list|()
condition|)
name|msg
operator|+=
literal|"has sort by; "
expr_stmt|;
if|if
condition|(
name|queryProperties
operator|.
name|hasPTF
argument_list|()
condition|)
name|msg
operator|+=
literal|"has PTF; "
expr_stmt|;
if|if
condition|(
name|queryProperties
operator|.
name|usesScript
argument_list|()
condition|)
name|msg
operator|+=
literal|"uses scripts; "
expr_stmt|;
if|if
condition|(
name|queryProperties
operator|.
name|hasLateralViews
argument_list|()
condition|)
name|msg
operator|+=
literal|"has lateral views; "
expr_stmt|;
if|if
condition|(
name|msg
operator|.
name|isEmpty
argument_list|()
condition|)
name|msg
operator|+=
literal|"has some unspecified limitations; "
expr_stmt|;
block|}
return|return
name|msg
return|;
block|}
comment|/* This method inserts the right profiles into profiles CBO depending    * on the query characteristics. */
specifier|private
specifier|static
name|EnumSet
argument_list|<
name|ExtendedCBOProfile
argument_list|>
name|obtainCBOProfiles
parameter_list|(
name|QueryProperties
name|queryProperties
parameter_list|)
block|{
name|EnumSet
argument_list|<
name|ExtendedCBOProfile
argument_list|>
name|profilesCBO
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|ExtendedCBOProfile
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// If the query contains more than one join
if|if
condition|(
name|queryProperties
operator|.
name|getJoinCount
argument_list|()
operator|>
literal|1
condition|)
block|{
name|profilesCBO
operator|.
name|add
argument_list|(
name|ExtendedCBOProfile
operator|.
name|JOIN_REORDERING
argument_list|)
expr_stmt|;
block|}
comment|// If the query contains windowing processing
if|if
condition|(
name|queryProperties
operator|.
name|hasWindowing
argument_list|()
condition|)
block|{
name|profilesCBO
operator|.
name|add
argument_list|(
name|ExtendedCBOProfile
operator|.
name|WINDOWING_POSTPROCESSING
argument_list|)
expr_stmt|;
block|}
return|return
name|profilesCBO
return|;
block|}
annotation|@
name|Override
name|boolean
name|isCBOExecuted
parameter_list|()
block|{
return|return
name|runCBO
return|;
block|}
annotation|@
name|Override
name|boolean
name|isCBOSupportedLateralView
parameter_list|(
name|ASTNode
name|lateralView
parameter_list|)
block|{
comment|// Lateral view AST has the following shape:
comment|// ^(TOK_LATERAL_VIEW
comment|//   ^(TOK_SELECT ^(TOK_SELEXPR ^(TOK_FUNCTION Identifier params) identifier* tableAlias)))
if|if
condition|(
name|lateralView
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_LATERAL_VIEW_OUTER
condition|)
block|{
comment|// LATERAL VIEW OUTER not supported in CBO
return|return
literal|false
return|;
block|}
comment|// Only INLINE followed by ARRAY supported in CBO
name|ASTNode
name|lvFunc
init|=
operator|(
name|ASTNode
operator|)
name|lateralView
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|lvFuncName
init|=
name|lvFunc
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
if|if
condition|(
name|lvFuncName
operator|.
name|compareToIgnoreCase
argument_list|(
name|GenericUDTFInline
operator|.
name|class
operator|.
name|getAnnotation
argument_list|(
name|Description
operator|.
name|class
argument_list|)
operator|.
name|name
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|lvFunc
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|2
condition|)
block|{
return|return
literal|false
return|;
block|}
name|ASTNode
name|innerFunc
init|=
operator|(
name|ASTNode
operator|)
name|lvFunc
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|innerFunc
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_FUNCTION
operator|||
name|innerFunc
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|compareToIgnoreCase
argument_list|(
name|GenericUDFArray
operator|.
name|class
operator|.
name|getAnnotation
argument_list|(
name|Description
operator|.
name|class
argument_list|)
operator|.
name|name
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
name|boolean
name|continueJoinMerge
parameter_list|()
block|{
return|return
operator|!
operator|(
name|runCBO
operator|&&
name|disableSemJoinReordering
operator|)
return|;
block|}
annotation|@
name|Override
name|Table
name|materializeCTE
parameter_list|(
name|String
name|cteName
parameter_list|,
name|CTEClause
name|cte
parameter_list|)
throws|throws
name|HiveException
block|{
name|ASTNode
name|createTable
init|=
operator|new
name|ASTNode
argument_list|(
operator|new
name|ClassicToken
argument_list|(
name|HiveParser
operator|.
name|TOK_CREATETABLE
argument_list|)
argument_list|)
decl_stmt|;
name|ASTNode
name|tableName
init|=
operator|new
name|ASTNode
argument_list|(
operator|new
name|ClassicToken
argument_list|(
name|HiveParser
operator|.
name|TOK_TABNAME
argument_list|)
argument_list|)
decl_stmt|;
name|tableName
operator|.
name|addChild
argument_list|(
operator|new
name|ASTNode
argument_list|(
operator|new
name|ClassicToken
argument_list|(
name|HiveParser
operator|.
name|Identifier
argument_list|,
name|cteName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASTNode
name|temporary
init|=
operator|new
name|ASTNode
argument_list|(
operator|new
name|ClassicToken
argument_list|(
name|HiveParser
operator|.
name|KW_TEMPORARY
argument_list|,
name|MATERIALIZATION_MARKER
argument_list|)
argument_list|)
decl_stmt|;
name|createTable
operator|.
name|addChild
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|createTable
operator|.
name|addChild
argument_list|(
name|temporary
argument_list|)
expr_stmt|;
name|createTable
operator|.
name|addChild
argument_list|(
name|cte
operator|.
name|cteNode
argument_list|)
expr_stmt|;
name|CalcitePlanner
name|analyzer
init|=
operator|new
name|CalcitePlanner
argument_list|(
name|queryState
argument_list|)
decl_stmt|;
name|analyzer
operator|.
name|initCtx
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|init
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// should share cte contexts
name|analyzer
operator|.
name|aliasToCTEs
operator|.
name|putAll
argument_list|(
name|aliasToCTEs
argument_list|)
expr_stmt|;
name|HiveOperation
name|operation
init|=
name|queryState
operator|.
name|getHiveOperation
argument_list|()
decl_stmt|;
try|try
block|{
name|analyzer
operator|.
name|analyzeInternal
argument_list|(
name|createTable
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|queryState
operator|.
name|setCommandType
argument_list|(
name|operation
argument_list|)
expr_stmt|;
block|}
name|Table
name|table
init|=
name|analyzer
operator|.
name|tableDesc
operator|.
name|toTable
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Path
name|location
init|=
name|table
operator|.
name|getDataLocation
argument_list|()
decl_stmt|;
try|try
block|{
name|location
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
operator|.
name|mkdirs
argument_list|(
name|location
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|table
operator|.
name|setMaterializedTable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|cteName
operator|+
literal|" will be materialized into "
operator|+
name|location
argument_list|)
expr_stmt|;
name|cte
operator|.
name|source
operator|=
name|analyzer
expr_stmt|;
name|ctx
operator|.
name|addMaterializedTable
argument_list|(
name|cteName
argument_list|,
name|table
argument_list|)
expr_stmt|;
comment|// For CalcitePlanner, store qualified name too
name|ctx
operator|.
name|addMaterializedTable
argument_list|(
name|table
operator|.
name|getFullyQualifiedName
argument_list|()
argument_list|,
name|table
argument_list|)
expr_stmt|;
return|return
name|table
return|;
block|}
specifier|private
name|void
name|fixUpASTAggregateIncrementalRebuild
parameter_list|(
name|ASTNode
name|newAST
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Replace INSERT OVERWRITE by MERGE equivalent rewriting.
comment|// Here we need to do this complex AST rewriting that generates the same plan
comment|// that a MERGE clause would generate because CBO does not support MERGE yet.
comment|// TODO: Support MERGE as first class member in CBO to simplify this logic.
comment|// 1) Replace INSERT OVERWRITE by INSERT
name|ASTNode
name|updateNode
init|=
operator|new
name|ASTSearcher
argument_list|()
operator|.
name|simpleBreadthFirstSearch
argument_list|(
name|newAST
argument_list|,
name|HiveParser
operator|.
name|TOK_QUERY
argument_list|,
name|HiveParser
operator|.
name|TOK_INSERT
argument_list|)
decl_stmt|;
name|ASTNode
name|destinationNode
init|=
operator|(
name|ASTNode
operator|)
name|updateNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ASTNode
name|newInsertInto
init|=
operator|(
name|ASTNode
operator|)
name|ParseDriver
operator|.
name|adaptor
operator|.
name|create
argument_list|(
name|HiveParser
operator|.
name|TOK_INSERT_INTO
argument_list|,
literal|"TOK_INSERT_INTO"
argument_list|)
decl_stmt|;
name|newInsertInto
operator|.
name|addChildren
argument_list|(
name|destinationNode
operator|.
name|getChildren
argument_list|()
argument_list|)
expr_stmt|;
name|ASTNode
name|destinationParentNode
init|=
operator|(
name|ASTNode
operator|)
name|destinationNode
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|int
name|childIndex
init|=
name|destinationNode
operator|.
name|childIndex
decl_stmt|;
name|destinationParentNode
operator|.
name|deleteChild
argument_list|(
name|childIndex
argument_list|)
expr_stmt|;
name|destinationParentNode
operator|.
name|insertChild
argument_list|(
name|childIndex
argument_list|,
name|newInsertInto
argument_list|)
expr_stmt|;
comment|// 1.1) Extract name as we will need it afterwards:
comment|// TOK_DESTINATION TOK_TAB TOK_TABNAME<materialization_name>
name|ASTNode
name|materializationNode
init|=
operator|new
name|ASTSearcher
argument_list|()
operator|.
name|simpleBreadthFirstSearch
argument_list|(
name|newInsertInto
argument_list|,
name|HiveParser
operator|.
name|TOK_INSERT_INTO
argument_list|,
name|HiveParser
operator|.
name|TOK_TAB
argument_list|,
name|HiveParser
operator|.
name|TOK_TABNAME
argument_list|)
decl_stmt|;
comment|// 2) Copy INSERT branch and duplicate it, the first branch will be the UPDATE
comment|// for the MERGE statement while the new branch will be the INSERT for the
comment|// MERGE statement
name|ASTNode
name|updateParent
init|=
operator|(
name|ASTNode
operator|)
name|updateNode
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|ASTNode
name|insertNode
init|=
operator|(
name|ASTNode
operator|)
name|ParseDriver
operator|.
name|adaptor
operator|.
name|dupTree
argument_list|(
name|updateNode
argument_list|)
decl_stmt|;
name|insertNode
operator|.
name|setParent
argument_list|(
name|updateParent
argument_list|)
expr_stmt|;
name|updateParent
operator|.
name|addChild
argument_list|(
name|insertNode
argument_list|)
expr_stmt|;
comment|// 3) Create ROW_ID column in select clause from left input for the RIGHT OUTER JOIN.
comment|// This is needed for the UPDATE clause. Hence, we find the following node:
comment|// TOK_QUERY
comment|//   TOK_FROM
comment|//      TOK_RIGHTOUTERJOIN
comment|//         TOK_SUBQUERY
comment|//            TOK_QUERY
comment|//               ...
comment|//               TOK_INSERT
comment|//                  ...
comment|//                  TOK_SELECT
comment|// And then we create the following child node:
comment|// TOK_SELEXPR
comment|//    .
comment|//       TOK_TABLE_OR_COL
comment|//          cmv_mat_view
comment|//       ROW__ID
name|ASTNode
name|subqueryNodeInputROJ
init|=
operator|new
name|ASTSearcher
argument_list|()
operator|.
name|simpleBreadthFirstSearch
argument_list|(
name|newAST
argument_list|,
name|HiveParser
operator|.
name|TOK_QUERY
argument_list|,
name|HiveParser
operator|.
name|TOK_FROM
argument_list|,
name|HiveParser
operator|.
name|TOK_RIGHTOUTERJOIN
argument_list|,
name|HiveParser
operator|.
name|TOK_SUBQUERY
argument_list|)
decl_stmt|;
name|ASTNode
name|selectNodeInputROJ
init|=
operator|new
name|ASTSearcher
argument_list|()
operator|.
name|simpleBreadthFirstSearch
argument_list|(
name|subqueryNodeInputROJ
argument_list|,
name|HiveParser
operator|.
name|TOK_SUBQUERY
argument_list|,
name|HiveParser
operator|.
name|TOK_QUERY
argument_list|,
name|HiveParser
operator|.
name|TOK_INSERT
argument_list|,
name|HiveParser
operator|.
name|TOK_SELECT
argument_list|)
decl_stmt|;
name|ASTNode
name|selectExprNodeInputROJ
init|=
operator|(
name|ASTNode
operator|)
name|ParseDriver
operator|.
name|adaptor
operator|.
name|create
argument_list|(
name|HiveParser
operator|.
name|TOK_SELEXPR
argument_list|,
literal|"TOK_SELEXPR"
argument_list|)
decl_stmt|;
name|ASTNode
name|dotNodeInputROJ
init|=
operator|(
name|ASTNode
operator|)
name|ParseDriver
operator|.
name|adaptor
operator|.
name|create
argument_list|(
name|HiveParser
operator|.
name|DOT
argument_list|,
literal|"."
argument_list|)
decl_stmt|;
name|ASTNode
name|columnTokNodeInputROJ
init|=
operator|(
name|ASTNode
operator|)
name|ParseDriver
operator|.
name|adaptor
operator|.
name|create
argument_list|(
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
argument_list|,
literal|"TOK_TABLE_OR_COL"
argument_list|)
decl_stmt|;
name|ASTNode
name|tableNameNodeInputROJ
init|=
operator|(
name|ASTNode
operator|)
name|ParseDriver
operator|.
name|adaptor
operator|.
name|create
argument_list|(
name|HiveParser
operator|.
name|Identifier
argument_list|,
name|Warehouse
operator|.
name|getQualifiedName
argument_list|(
name|materializationNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|,
name|materializationNode
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|ASTNode
name|rowIdNodeInputROJ
init|=
operator|(
name|ASTNode
operator|)
name|ParseDriver
operator|.
name|adaptor
operator|.
name|create
argument_list|(
name|HiveParser
operator|.
name|Identifier
argument_list|,
name|VirtualColumn
operator|.
name|ROWID
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|ParseDriver
operator|.
name|adaptor
operator|.
name|addChild
argument_list|(
name|selectNodeInputROJ
argument_list|,
name|selectExprNodeInputROJ
argument_list|)
expr_stmt|;
name|ParseDriver
operator|.
name|adaptor
operator|.
name|addChild
argument_list|(
name|selectExprNodeInputROJ
argument_list|,
name|dotNodeInputROJ
argument_list|)
expr_stmt|;
name|ParseDriver
operator|.
name|adaptor
operator|.
name|addChild
argument_list|(
name|dotNodeInputROJ
argument_list|,
name|columnTokNodeInputROJ
argument_list|)
expr_stmt|;
name|ParseDriver
operator|.
name|adaptor
operator|.
name|addChild
argument_list|(
name|dotNodeInputROJ
argument_list|,
name|rowIdNodeInputROJ
argument_list|)
expr_stmt|;
name|ParseDriver
operator|.
name|adaptor
operator|.
name|addChild
argument_list|(
name|columnTokNodeInputROJ
argument_list|,
name|tableNameNodeInputROJ
argument_list|)
expr_stmt|;
comment|// 4) Transform first INSERT branch into an UPDATE
comment|// 4.1) Adding ROW__ID field
name|ASTNode
name|selectNodeInUpdate
init|=
operator|(
name|ASTNode
operator|)
name|updateNode
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectNodeInUpdate
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_SELECT
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"TOK_SELECT expected in incremental rewriting"
argument_list|)
throw|;
block|}
name|ASTNode
name|selectExprNodeInUpdate
init|=
operator|(
name|ASTNode
operator|)
name|ParseDriver
operator|.
name|adaptor
operator|.
name|dupNode
argument_list|(
name|selectExprNodeInputROJ
argument_list|)
decl_stmt|;
name|ASTNode
name|dotNodeInUpdate
init|=
operator|(
name|ASTNode
operator|)
name|ParseDriver
operator|.
name|adaptor
operator|.
name|dupNode
argument_list|(
name|dotNodeInputROJ
argument_list|)
decl_stmt|;
name|ASTNode
name|columnTokNodeInUpdate
init|=
operator|(
name|ASTNode
operator|)
name|ParseDriver
operator|.
name|adaptor
operator|.
name|dupNode
argument_list|(
name|columnTokNodeInputROJ
argument_list|)
decl_stmt|;
name|ASTNode
name|tableNameNodeInUpdate
init|=
operator|(
name|ASTNode
operator|)
name|ParseDriver
operator|.
name|adaptor
operator|.
name|dupNode
argument_list|(
name|subqueryNodeInputROJ
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|ASTNode
name|rowIdNodeInUpdate
init|=
operator|(
name|ASTNode
operator|)
name|ParseDriver
operator|.
name|adaptor
operator|.
name|dupNode
argument_list|(
name|rowIdNodeInputROJ
argument_list|)
decl_stmt|;
name|ParseDriver
operator|.
name|adaptor
operator|.
name|addChild
argument_list|(
name|selectExprNodeInUpdate
argument_list|,
name|dotNodeInUpdate
argument_list|)
expr_stmt|;
name|ParseDriver
operator|.
name|adaptor
operator|.
name|addChild
argument_list|(
name|dotNodeInUpdate
argument_list|,
name|columnTokNodeInUpdate
argument_list|)
expr_stmt|;
name|ParseDriver
operator|.
name|adaptor
operator|.
name|addChild
argument_list|(
name|dotNodeInUpdate
argument_list|,
name|rowIdNodeInUpdate
argument_list|)
expr_stmt|;
name|ParseDriver
operator|.
name|adaptor
operator|.
name|addChild
argument_list|(
name|columnTokNodeInUpdate
argument_list|,
name|tableNameNodeInUpdate
argument_list|)
expr_stmt|;
name|selectNodeInUpdate
operator|.
name|insertChild
argument_list|(
literal|0
argument_list|,
name|ParseDriver
operator|.
name|adaptor
operator|.
name|dupTree
argument_list|(
name|selectExprNodeInUpdate
argument_list|)
argument_list|)
expr_stmt|;
comment|// 4.2) Modifying filter condition. The incremental rewriting rule generated an OR
comment|// clause where first disjunct contains the condition for the UPDATE branch.
comment|// TOK_WHERE
comment|//   or
comment|//      and<- DISJUNCT FOR<UPDATE>
comment|//         =
comment|//            .
comment|//               TOK_TABLE_OR_COL
comment|//                  $hdt$_0
comment|//               a
comment|//            .
comment|//               TOK_TABLE_OR_COL
comment|//                  $hdt$_1
comment|//               a
comment|//         =
comment|//            .
comment|//               TOK_TABLE_OR_COL
comment|//                  $hdt$_0
comment|//               c
comment|//            .
comment|//               TOK_TABLE_OR_COL
comment|//                  $hdt$_1
comment|//               c
comment|//      and<- DISJUNCT FOR<INSERT>
comment|//         TOK_FUNCTION
comment|//            isnull
comment|//            .
comment|//               TOK_TABLE_OR_COL
comment|//                  $hdt$_0
comment|//               a
comment|//         TOK_FUNCTION
comment|//            isnull
comment|//            .
comment|//               TOK_TABLE_OR_COL
comment|//                  $hdt$_0
comment|//               c
name|ASTNode
name|whereClauseInUpdate
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|updateNode
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|updateNode
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_WHERE
condition|)
block|{
name|whereClauseInUpdate
operator|=
operator|(
name|ASTNode
operator|)
name|updateNode
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|whereClauseInUpdate
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"TOK_WHERE expected in incremental rewriting"
argument_list|)
throw|;
block|}
if|if
condition|(
name|whereClauseInUpdate
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|KW_OR
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"OR clause expected below TOK_WHERE in incremental rewriting"
argument_list|)
throw|;
block|}
comment|// We bypass the OR clause and select the first disjunct
name|ASTNode
name|newCondInUpdate
init|=
operator|(
name|ASTNode
operator|)
name|whereClauseInUpdate
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ParseDriver
operator|.
name|adaptor
operator|.
name|setChild
argument_list|(
name|whereClauseInUpdate
argument_list|,
literal|0
argument_list|,
name|newCondInUpdate
argument_list|)
expr_stmt|;
comment|// 4.3) Finally, we add SORT clause, this is needed for the UPDATE.
comment|//       TOK_SORTBY
comment|//         TOK_TABSORTCOLNAMEASC
comment|//            TOK_NULLS_FIRST
comment|//               .
comment|//                  TOK_TABLE_OR_COL
comment|//                     cmv_basetable_2
comment|//                  ROW__ID
name|ASTNode
name|sortExprNode
init|=
operator|(
name|ASTNode
operator|)
name|ParseDriver
operator|.
name|adaptor
operator|.
name|create
argument_list|(
name|HiveParser
operator|.
name|TOK_SORTBY
argument_list|,
literal|"TOK_SORTBY"
argument_list|)
decl_stmt|;
name|ASTNode
name|orderExprNode
init|=
operator|(
name|ASTNode
operator|)
name|ParseDriver
operator|.
name|adaptor
operator|.
name|create
argument_list|(
name|HiveParser
operator|.
name|TOK_TABSORTCOLNAMEASC
argument_list|,
literal|"TOK_TABSORTCOLNAMEASC"
argument_list|)
decl_stmt|;
name|ASTNode
name|nullsOrderExprNode
init|=
operator|(
name|ASTNode
operator|)
name|ParseDriver
operator|.
name|adaptor
operator|.
name|create
argument_list|(
name|HiveParser
operator|.
name|TOK_NULLS_FIRST
argument_list|,
literal|"TOK_NULLS_FIRST"
argument_list|)
decl_stmt|;
name|ASTNode
name|dotNodeInSort
init|=
operator|(
name|ASTNode
operator|)
name|ParseDriver
operator|.
name|adaptor
operator|.
name|dupTree
argument_list|(
name|dotNodeInUpdate
argument_list|)
decl_stmt|;
name|ParseDriver
operator|.
name|adaptor
operator|.
name|addChild
argument_list|(
name|updateNode
argument_list|,
name|sortExprNode
argument_list|)
expr_stmt|;
name|ParseDriver
operator|.
name|adaptor
operator|.
name|addChild
argument_list|(
name|sortExprNode
argument_list|,
name|orderExprNode
argument_list|)
expr_stmt|;
name|ParseDriver
operator|.
name|adaptor
operator|.
name|addChild
argument_list|(
name|orderExprNode
argument_list|,
name|nullsOrderExprNode
argument_list|)
expr_stmt|;
name|ParseDriver
operator|.
name|adaptor
operator|.
name|addChild
argument_list|(
name|nullsOrderExprNode
argument_list|,
name|dotNodeInSort
argument_list|)
expr_stmt|;
comment|// 5) Modify INSERT branch condition. In particular, we need to modify the
comment|// WHERE clause and pick up the second disjunct from the OR operation.
name|ASTNode
name|whereClauseInInsert
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|insertNode
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|insertNode
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_WHERE
condition|)
block|{
name|whereClauseInInsert
operator|=
operator|(
name|ASTNode
operator|)
name|insertNode
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|whereClauseInInsert
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"TOK_WHERE expected in incremental rewriting"
argument_list|)
throw|;
block|}
if|if
condition|(
name|whereClauseInInsert
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|KW_OR
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"OR clause expected below TOK_WHERE in incremental rewriting"
argument_list|)
throw|;
block|}
comment|// We bypass the OR clause and select the second disjunct
name|ASTNode
name|newCondInInsert
init|=
operator|(
name|ASTNode
operator|)
name|whereClauseInInsert
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|ParseDriver
operator|.
name|adaptor
operator|.
name|setChild
argument_list|(
name|whereClauseInInsert
argument_list|,
literal|0
argument_list|,
name|newCondInInsert
argument_list|)
expr_stmt|;
comment|// 6) Now we set some tree properties related to multi-insert
comment|// operation with INSERT/UPDATE
name|ctx
operator|.
name|setOperation
argument_list|(
name|Context
operator|.
name|Operation
operator|.
name|MERGE
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|addDestNamePrefix
argument_list|(
literal|1
argument_list|,
name|Context
operator|.
name|DestClausePrefix
operator|.
name|UPDATE
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|addDestNamePrefix
argument_list|(
literal|2
argument_list|,
name|Context
operator|.
name|DestClausePrefix
operator|.
name|INSERT
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|fixUpASTNoAggregateIncrementalRebuild
parameter_list|(
name|ASTNode
name|newAST
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Replace INSERT OVERWRITE by INSERT INTO
comment|// AST tree will have this shape:
comment|// TOK_QUERY
comment|//   TOK_FROM
comment|//      ...
comment|//   TOK_INSERT
comment|//      TOK_DESTINATION<- THIS TOKEN IS REPLACED BY 'TOK_INSERT_INTO'
comment|//         TOK_TAB
comment|//            TOK_TABNAME
comment|//               default.cmv_mat_view
comment|//      TOK_SELECT
comment|//         ...
name|ASTNode
name|dest
init|=
operator|new
name|ASTSearcher
argument_list|()
operator|.
name|simpleBreadthFirstSearch
argument_list|(
name|newAST
argument_list|,
name|HiveParser
operator|.
name|TOK_QUERY
argument_list|,
name|HiveParser
operator|.
name|TOK_INSERT
argument_list|,
name|HiveParser
operator|.
name|TOK_DESTINATION
argument_list|)
decl_stmt|;
name|ASTNode
name|newChild
init|=
operator|(
name|ASTNode
operator|)
name|ParseDriver
operator|.
name|adaptor
operator|.
name|create
argument_list|(
name|HiveParser
operator|.
name|TOK_INSERT_INTO
argument_list|,
literal|"TOK_INSERT_INTO"
argument_list|)
decl_stmt|;
name|newChild
operator|.
name|addChildren
argument_list|(
name|dest
operator|.
name|getChildren
argument_list|()
argument_list|)
expr_stmt|;
name|ASTNode
name|destParent
init|=
operator|(
name|ASTNode
operator|)
name|dest
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|int
name|childIndex
init|=
name|dest
operator|.
name|childIndex
decl_stmt|;
name|destParent
operator|.
name|deleteChild
argument_list|(
name|childIndex
argument_list|)
expr_stmt|;
name|destParent
operator|.
name|insertChild
argument_list|(
name|childIndex
argument_list|,
name|newChild
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|fixCtasColumnName
parameter_list|(
name|String
name|colName
parameter_list|)
block|{
if|if
condition|(
name|runCBO
condition|)
block|{
name|int
name|lastDot
init|=
name|colName
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastDot
operator|<
literal|0
condition|)
return|return
name|colName
return|;
comment|// alias is not fully qualified
name|String
name|nqColumnName
init|=
name|colName
operator|.
name|substring
argument_list|(
name|lastDot
operator|+
literal|1
argument_list|)
decl_stmt|;
name|STATIC_LOG
operator|.
name|debug
argument_list|(
literal|"Replacing "
operator|+
name|colName
operator|+
literal|" (produced by CBO) by "
operator|+
name|nqColumnName
argument_list|)
expr_stmt|;
return|return
name|nqColumnName
return|;
block|}
return|return
name|super
operator|.
name|fixCtasColumnName
argument_list|(
name|colName
argument_list|)
return|;
block|}
comment|/**    * The context that doPhase1 uses to populate information pertaining to CBO    * (currently, this is used for CTAS and insert-as-select).    */
specifier|static
class|class
name|PreCboCtx
extends|extends
name|PlannerContext
block|{
enum|enum
name|Type
block|{
name|NONE
block|,
name|INSERT
block|,
name|MULTI_INSERT
block|,
name|CTAS
block|,
name|VIEW
block|,
name|UNEXPECTED
block|}
specifier|private
name|ASTNode
name|nodeOfInterest
decl_stmt|;
specifier|private
name|Type
name|type
init|=
name|Type
operator|.
name|NONE
decl_stmt|;
specifier|private
name|void
name|set
parameter_list|(
name|Type
name|type
parameter_list|,
name|ASTNode
name|ast
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|type
operator|!=
name|Type
operator|.
name|NONE
condition|)
block|{
name|STATIC_LOG
operator|.
name|warn
argument_list|(
literal|"Setting "
operator|+
name|type
operator|+
literal|" when already "
operator|+
name|this
operator|.
name|type
operator|+
literal|"; node "
operator|+
name|ast
operator|.
name|dump
argument_list|()
operator|+
literal|" vs old node "
operator|+
name|nodeOfInterest
operator|.
name|dump
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|Type
operator|.
name|UNEXPECTED
expr_stmt|;
return|return;
block|}
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|this
operator|.
name|nodeOfInterest
operator|=
name|ast
expr_stmt|;
block|}
annotation|@
name|Override
name|void
name|setCTASToken
parameter_list|(
name|ASTNode
name|child
parameter_list|)
block|{
name|set
argument_list|(
name|PreCboCtx
operator|.
name|Type
operator|.
name|CTAS
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|void
name|setViewToken
parameter_list|(
name|ASTNode
name|child
parameter_list|)
block|{
name|set
argument_list|(
name|PreCboCtx
operator|.
name|Type
operator|.
name|VIEW
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|void
name|setInsertToken
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|boolean
name|isTmpFileDest
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isTmpFileDest
condition|)
block|{
name|set
argument_list|(
name|PreCboCtx
operator|.
name|Type
operator|.
name|INSERT
argument_list|,
name|ast
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
name|void
name|setMultiInsertToken
parameter_list|(
name|ASTNode
name|child
parameter_list|)
block|{
name|set
argument_list|(
name|PreCboCtx
operator|.
name|Type
operator|.
name|MULTI_INSERT
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|void
name|resetToken
parameter_list|()
block|{
name|this
operator|.
name|type
operator|=
name|Type
operator|.
name|NONE
expr_stmt|;
name|this
operator|.
name|nodeOfInterest
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|ASTNode
name|fixUpAfterCbo
parameter_list|(
name|ASTNode
name|originalAst
parameter_list|,
name|ASTNode
name|newAst
parameter_list|,
name|PreCboCtx
name|cboCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
switch|switch
condition|(
name|cboCtx
operator|.
name|type
condition|)
block|{
case|case
name|NONE
case|:
comment|// nothing to do
return|return
name|newAst
return|;
case|case
name|CTAS
case|:
case|case
name|VIEW
case|:
block|{
comment|// Patch the optimized query back into original CTAS AST, replacing the
comment|// original query.
name|replaceASTChild
argument_list|(
name|cboCtx
operator|.
name|nodeOfInterest
argument_list|,
name|newAst
argument_list|)
expr_stmt|;
return|return
name|originalAst
return|;
block|}
case|case
name|INSERT
case|:
block|{
comment|// We need to patch the dest back to original into new query.
comment|// This makes assumptions about the structure of the AST.
name|ASTNode
name|newDest
init|=
operator|new
name|ASTSearcher
argument_list|()
operator|.
name|simpleBreadthFirstSearch
argument_list|(
name|newAst
argument_list|,
name|HiveParser
operator|.
name|TOK_QUERY
argument_list|,
name|HiveParser
operator|.
name|TOK_INSERT
argument_list|,
name|HiveParser
operator|.
name|TOK_DESTINATION
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDest
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot find destination after CBO; new ast is "
operator|+
name|newAst
operator|.
name|dump
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Cannot find destination after CBO"
argument_list|)
throw|;
block|}
name|replaceASTChild
argument_list|(
name|newDest
argument_list|,
name|cboCtx
operator|.
name|nodeOfInterest
argument_list|)
expr_stmt|;
return|return
name|newAst
return|;
block|}
case|case
name|MULTI_INSERT
case|:
block|{
comment|// Patch the optimized query back into original FROM clause.
name|replaceASTChild
argument_list|(
name|cboCtx
operator|.
name|nodeOfInterest
argument_list|,
name|newAst
argument_list|)
expr_stmt|;
return|return
name|originalAst
return|;
block|}
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unexpected type "
operator|+
name|cboCtx
operator|.
name|type
argument_list|)
throw|;
block|}
block|}
name|ASTNode
name|reAnalyzeCTASAfterCbo
parameter_list|(
name|ASTNode
name|newAst
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// analyzeCreateTable uses this.ast, but doPhase1 doesn't, so only reset it
comment|// here.
name|newAst
operator|=
name|analyzeCreateTable
argument_list|(
name|newAst
argument_list|,
name|getQB
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|newAst
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"analyzeCreateTable failed to initialize CTAS after CBO;"
operator|+
literal|" new ast is "
operator|+
name|getAST
argument_list|()
operator|.
name|dump
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"analyzeCreateTable failed to initialize CTAS after CBO"
argument_list|)
throw|;
block|}
return|return
name|newAst
return|;
block|}
name|ASTNode
name|reAnalyzeViewAfterCbo
parameter_list|(
name|ASTNode
name|newAst
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// analyzeCreateView uses this.ast, but doPhase1 doesn't, so only reset it
comment|// here.
name|newAst
operator|=
name|analyzeCreateView
argument_list|(
name|newAst
argument_list|,
name|getQB
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|newAst
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"analyzeCreateTable failed to initialize materialized view after CBO;"
operator|+
literal|" new ast is "
operator|+
name|getAST
argument_list|()
operator|.
name|dump
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"analyzeCreateTable failed to initialize materialized view after CBO"
argument_list|)
throw|;
block|}
return|return
name|newAst
return|;
block|}
specifier|public
specifier|static
class|class
name|ASTSearcher
block|{
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|ASTNode
argument_list|>
name|searchQueue
init|=
operator|new
name|LinkedList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Performs breadth-first search of the AST for a nested set of tokens. Tokens      * don't have to be each others' direct children, they can be separated by      * layers of other tokens. For each token in the list, the first one found is      * matched and there's no backtracking; thus, if AST has multiple instances of      * some token, of which only one matches, it is not guaranteed to be found. We      * use this for simple things. Not thread-safe - reuses searchQueue.      */
specifier|public
name|ASTNode
name|simpleBreadthFirstSearch
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|int
modifier|...
name|tokens
parameter_list|)
block|{
name|searchQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
name|searchQueue
operator|.
name|add
argument_list|(
name|ast
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tokens
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|boolean
name|found
init|=
literal|false
decl_stmt|;
name|int
name|token
init|=
name|tokens
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
operator|!
name|searchQueue
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|found
condition|)
block|{
name|ASTNode
name|next
init|=
name|searchQueue
operator|.
name|poll
argument_list|()
decl_stmt|;
name|found
operator|=
name|next
operator|.
name|getType
argument_list|()
operator|==
name|token
expr_stmt|;
if|if
condition|(
name|found
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|tokens
operator|.
name|length
operator|-
literal|1
condition|)
return|return
name|next
return|;
name|searchQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|next
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|searchQueue
operator|.
name|add
argument_list|(
operator|(
name|ASTNode
operator|)
name|next
operator|.
name|getChild
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
return|return
literal|null
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|ASTNode
name|depthFirstSearch
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|int
name|token
parameter_list|)
block|{
name|searchQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
name|searchQueue
operator|.
name|add
argument_list|(
name|ast
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|searchQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ASTNode
name|next
init|=
name|searchQueue
operator|.
name|poll
argument_list|()
decl_stmt|;
if|if
condition|(
name|next
operator|.
name|getType
argument_list|()
operator|==
name|token
condition|)
return|return
name|next
return|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|next
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|searchQueue
operator|.
name|add
argument_list|(
operator|(
name|ASTNode
operator|)
name|next
operator|.
name|getChild
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|ASTNode
name|simpleBreadthFirstSearchAny
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|int
modifier|...
name|tokens
parameter_list|)
block|{
name|searchQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
name|searchQueue
operator|.
name|add
argument_list|(
name|ast
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|searchQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ASTNode
name|next
init|=
name|searchQueue
operator|.
name|poll
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tokens
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|next
operator|.
name|getType
argument_list|()
operator|==
name|tokens
index|[
name|i
index|]
condition|)
return|return
name|next
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|next
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|searchQueue
operator|.
name|add
argument_list|(
operator|(
name|ASTNode
operator|)
name|next
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|searchQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|replaceASTChild
parameter_list|(
name|ASTNode
name|child
parameter_list|,
name|ASTNode
name|newChild
parameter_list|)
block|{
name|ASTNode
name|parent
init|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|parent
decl_stmt|;
name|int
name|childIndex
init|=
name|child
operator|.
name|childIndex
decl_stmt|;
name|parent
operator|.
name|deleteChild
argument_list|(
name|childIndex
argument_list|)
expr_stmt|;
name|parent
operator|.
name|insertChild
argument_list|(
name|childIndex
argument_list|,
name|newChild
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get optimized logical plan for the given QB tree in the semAnalyzer.    *    * @return    * @throws SemanticException    */
name|RelNode
name|logicalPlan
parameter_list|()
throws|throws
name|SemanticException
block|{
name|RelNode
name|optimizedOptiqPlan
init|=
literal|null
decl_stmt|;
name|CalcitePlannerAction
name|calcitePlannerAction
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|columnAccessInfo
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|columnAccessInfo
operator|=
operator|new
name|ColumnAccessInfo
argument_list|()
expr_stmt|;
block|}
name|calcitePlannerAction
operator|=
operator|new
name|CalcitePlannerAction
argument_list|(
name|prunedPartitions
argument_list|,
name|ctx
operator|.
name|getOpContext
argument_list|()
operator|.
name|getColStatsCache
argument_list|()
argument_list|,
name|this
operator|.
name|columnAccessInfo
argument_list|)
expr_stmt|;
try|try
block|{
name|optimizedOptiqPlan
operator|=
name|Frameworks
operator|.
name|withPlanner
argument_list|(
name|calcitePlannerAction
argument_list|,
name|Frameworks
operator|.
name|newConfigBuilder
argument_list|()
operator|.
name|typeSystem
argument_list|(
operator|new
name|HiveTypeSystemImpl
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|rethrowCalciteException
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"rethrowCalciteException didn't throw for "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|optimizedOptiqPlan
return|;
block|}
comment|/**    * Get SQL rewrite for a Calcite logical plan    *    * @return Optimized SQL text (or null, if failed)    */
specifier|public
name|String
name|getOptimizedSql
parameter_list|(
name|RelNode
name|optimizedOptiqPlan
parameter_list|)
block|{
name|boolean
name|nullsLast
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_DEFAULT_NULLS_LAST
argument_list|)
decl_stmt|;
name|NullCollation
name|nullCollation
init|=
name|nullsLast
condition|?
name|NullCollation
operator|.
name|LAST
else|:
name|NullCollation
operator|.
name|LOW
decl_stmt|;
name|SqlDialect
name|dialect
init|=
operator|new
name|HiveSqlDialect
argument_list|(
name|SqlDialect
operator|.
name|EMPTY_CONTEXT
operator|.
name|withDatabaseProduct
argument_list|(
name|SqlDialect
operator|.
name|DatabaseProduct
operator|.
name|HIVE
argument_list|)
operator|.
name|withDatabaseMajorVersion
argument_list|(
literal|4
argument_list|)
comment|// TODO: should not be hardcoded
operator|.
name|withDatabaseMinorVersion
argument_list|(
literal|0
argument_list|)
operator|.
name|withIdentifierQuoteString
argument_list|(
literal|"`"
argument_list|)
operator|.
name|withNullCollation
argument_list|(
name|nullCollation
argument_list|)
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|boolean
name|allowsAs
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|supportsCharSet
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
decl_stmt|;
try|try
block|{
specifier|final
name|JdbcImplementor
name|jdbcImplementor
init|=
operator|new
name|JdbcImplementor
argument_list|(
name|dialect
argument_list|,
operator|(
name|JavaTypeFactory
operator|)
name|optimizedOptiqPlan
operator|.
name|getCluster
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|JdbcImplementor
operator|.
name|Result
name|result
init|=
name|jdbcImplementor
operator|.
name|visitChild
argument_list|(
literal|0
argument_list|,
name|optimizedOptiqPlan
argument_list|)
decl_stmt|;
name|String
name|sql
init|=
name|result
operator|.
name|asStatement
argument_list|()
operator|.
name|toSqlString
argument_list|(
name|dialect
argument_list|)
operator|.
name|getSql
argument_list|()
decl_stmt|;
return|return
name|sql
operator|.
name|replaceAll
argument_list|(
literal|"VARCHAR\\(2147483647\\)"
argument_list|,
literal|"STRING"
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Rel2SQL Rewrite threw error"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Get Optimized AST for the given QB tree in the semAnalyzer.    *    * @return Optimized operator tree translated in to Hive AST    * @throws SemanticException    */
name|ASTNode
name|getOptimizedAST
parameter_list|()
throws|throws
name|SemanticException
block|{
return|return
name|getOptimizedAST
argument_list|(
name|logicalPlan
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get Optimized AST for the given QB tree in the semAnalyzer.    *    * @return Optimized operator tree translated in to Hive AST    * @throws SemanticException    */
name|ASTNode
name|getOptimizedAST
parameter_list|(
name|RelNode
name|optimizedOptiqPlan
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|optiqOptimizedAST
init|=
name|ASTConverter
operator|.
name|convert
argument_list|(
name|optimizedOptiqPlan
argument_list|,
name|resultSchema
argument_list|,
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_COLUMN_ALIGNMENT
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|optiqOptimizedAST
return|;
block|}
comment|/**    * Get Optimized Hive Operator DAG for the given QB tree in the semAnalyzer.    *    * @return Optimized Hive operator tree    * @throws SemanticException    */
name|Operator
name|getOptimizedHiveOPDag
parameter_list|()
throws|throws
name|SemanticException
block|{
name|RelNode
name|optimizedOptiqPlan
init|=
literal|null
decl_stmt|;
name|CalcitePlannerAction
name|calcitePlannerAction
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|columnAccessInfo
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|columnAccessInfo
operator|=
operator|new
name|ColumnAccessInfo
argument_list|()
expr_stmt|;
block|}
name|calcitePlannerAction
operator|=
operator|new
name|CalcitePlannerAction
argument_list|(
name|prunedPartitions
argument_list|,
name|ctx
operator|.
name|getOpContext
argument_list|()
operator|.
name|getColStatsCache
argument_list|()
argument_list|,
name|this
operator|.
name|columnAccessInfo
argument_list|)
expr_stmt|;
try|try
block|{
name|optimizedOptiqPlan
operator|=
name|Frameworks
operator|.
name|withPlanner
argument_list|(
name|calcitePlannerAction
argument_list|,
name|Frameworks
operator|.
name|newConfigBuilder
argument_list|()
operator|.
name|typeSystem
argument_list|(
operator|new
name|HiveTypeSystemImpl
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|rethrowCalciteException
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"rethrowCalciteException didn't throw for "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
name|RelNode
name|modifiedOptimizedOptiqPlan
init|=
name|PlanModifierForReturnPath
operator|.
name|convertOpTree
argument_list|(
name|optimizedOptiqPlan
argument_list|,
name|resultSchema
argument_list|,
name|this
operator|.
name|getQB
argument_list|()
operator|.
name|getTableDesc
argument_list|()
operator|!=
literal|null
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Translating the following plan:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|modifiedOptimizedOptiqPlan
argument_list|)
argument_list|)
expr_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|hiveRoot
init|=
operator|new
name|HiveOpConverter
argument_list|(
name|this
argument_list|,
name|conf
argument_list|,
name|unparseTranslator
argument_list|,
name|topOps
argument_list|)
operator|.
name|convert
argument_list|(
name|modifiedOptimizedOptiqPlan
argument_list|)
decl_stmt|;
name|RowResolver
name|hiveRootRR
init|=
name|genRowResolver
argument_list|(
name|hiveRoot
argument_list|,
name|getQB
argument_list|()
argument_list|)
decl_stmt|;
name|opParseCtx
operator|.
name|put
argument_list|(
name|hiveRoot
argument_list|,
operator|new
name|OpParseContext
argument_list|(
name|hiveRootRR
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|dest
init|=
name|getQB
argument_list|()
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getClauseNames
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|getQB
argument_list|()
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestSchemaForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
operator|&&
name|this
operator|.
name|getQB
argument_list|()
operator|.
name|getTableDesc
argument_list|()
operator|==
literal|null
condition|)
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|selOp
init|=
name|handleInsertStatement
argument_list|(
name|dest
argument_list|,
name|hiveRoot
argument_list|,
name|hiveRootRR
argument_list|,
name|getQB
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|genFileSinkPlan
argument_list|(
name|dest
argument_list|,
name|getQB
argument_list|()
argument_list|,
name|selOp
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|genFileSinkPlan
argument_list|(
name|dest
argument_list|,
name|getQB
argument_list|()
argument_list|,
name|hiveRoot
argument_list|)
return|;
block|}
block|}
comment|// This function serves as the wrapper of handleInsertStatementSpec in
comment|// SemanticAnalyzer
name|Operator
argument_list|<
name|?
argument_list|>
name|handleInsertStatement
parameter_list|(
name|String
name|dest
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|input
parameter_list|,
name|RowResolver
name|inputRR
parameter_list|,
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|colList
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|columns
init|=
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columns
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ColumnInfo
name|col
init|=
name|columns
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|colList
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|col
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ASTNode
name|selExprList
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSelForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|RowResolver
name|out_rwsch
init|=
name|handleInsertStatementSpec
argument_list|(
name|colList
argument_list|,
name|dest
argument_list|,
name|inputRR
argument_list|,
name|qb
argument_list|,
name|selExprList
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|columnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|colList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|outputCol
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|outputCol
argument_list|,
name|colList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|columnNames
operator|.
name|add
argument_list|(
name|outputCol
argument_list|)
expr_stmt|;
block|}
name|Operator
argument_list|<
name|?
argument_list|>
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|SelectDesc
argument_list|(
name|colList
argument_list|,
name|columnNames
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|out_rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|out_rwsch
argument_list|)
decl_stmt|;
name|output
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
comment|/***    * Unwraps Calcite Invocation exceptions coming meta data provider chain and    * obtains the real cause.    *    * @param e    */
specifier|private
name|void
name|rethrowCalciteException
parameter_list|(
name|Exception
name|e
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Throwable
name|first
init|=
operator|(
name|semanticException
operator|!=
literal|null
operator|)
condition|?
name|semanticException
else|:
name|e
decl_stmt|,
name|current
init|=
name|first
decl_stmt|,
name|cause
init|=
name|current
operator|.
name|getCause
argument_list|()
decl_stmt|;
while|while
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
name|Throwable
name|causeOfCause
init|=
name|cause
operator|.
name|getCause
argument_list|()
decl_stmt|;
if|if
condition|(
name|current
operator|==
name|first
operator|&&
name|causeOfCause
operator|==
literal|null
operator|&&
name|isUselessCause
argument_list|(
name|first
argument_list|)
condition|)
block|{
comment|// "cause" is a root cause, and "e"/"first" is a useless
comment|// exception it's wrapped in.
name|first
operator|=
name|cause
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|causeOfCause
operator|!=
literal|null
operator|&&
name|isUselessCause
argument_list|(
name|cause
argument_list|)
operator|&&
name|ExceptionHelper
operator|.
name|resetCause
argument_list|(
name|current
argument_list|,
name|causeOfCause
argument_list|)
condition|)
block|{
comment|// "cause" was a useless intermediate cause and was replace it
comment|// with its own cause.
name|cause
operator|=
name|causeOfCause
expr_stmt|;
continue|continue;
comment|// do loop once again with the new cause of "current"
block|}
name|current
operator|=
name|cause
expr_stmt|;
name|cause
operator|=
name|current
operator|.
name|getCause
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|first
operator|instanceof
name|RuntimeException
condition|)
block|{
throw|throw
operator|(
name|RuntimeException
operator|)
name|first
throw|;
block|}
elseif|else
if|if
condition|(
name|first
operator|instanceof
name|SemanticException
condition|)
block|{
throw|throw
operator|(
name|SemanticException
operator|)
name|first
throw|;
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|first
argument_list|)
throw|;
block|}
specifier|private
specifier|static
class|class
name|ExceptionHelper
block|{
specifier|private
specifier|static
specifier|final
name|Field
name|CAUSE_FIELD
init|=
name|getField
argument_list|(
name|Throwable
operator|.
name|class
argument_list|,
literal|"cause"
argument_list|)
decl_stmt|,
name|TARGET_FIELD
init|=
name|getField
argument_list|(
name|InvocationTargetException
operator|.
name|class
argument_list|,
literal|"target"
argument_list|)
decl_stmt|,
name|MESSAGE_FIELD
init|=
name|getField
argument_list|(
name|Throwable
operator|.
name|class
argument_list|,
literal|"detailMessage"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|Field
name|getField
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|,
name|String
name|name
parameter_list|)
block|{
try|try
block|{
name|Field
name|f
init|=
name|clazz
operator|.
name|getDeclaredField
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|public
specifier|static
name|boolean
name|resetCause
parameter_list|(
name|Throwable
name|target
parameter_list|,
name|Throwable
name|newCause
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|MESSAGE_FIELD
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|Field
name|field
init|=
operator|(
name|target
operator|instanceof
name|InvocationTargetException
operator|)
condition|?
name|TARGET_FIELD
else|:
name|CAUSE_FIELD
decl_stmt|;
if|if
condition|(
name|field
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|Throwable
name|oldCause
init|=
name|target
operator|.
name|getCause
argument_list|()
decl_stmt|;
name|String
name|oldMsg
init|=
name|target
operator|.
name|getMessage
argument_list|()
decl_stmt|;
name|field
operator|.
name|set
argument_list|(
name|target
argument_list|,
name|newCause
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldMsg
operator|!=
literal|null
operator|&&
name|oldMsg
operator|.
name|equals
argument_list|(
name|oldCause
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|MESSAGE_FIELD
operator|.
name|set
argument_list|(
name|target
argument_list|,
name|newCause
operator|==
literal|null
condition|?
literal|null
else|:
name|newCause
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|se
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
specifier|private
name|boolean
name|isUselessCause
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
return|return
name|t
operator|instanceof
name|RuntimeException
operator|||
name|t
operator|instanceof
name|InvocationTargetException
operator|||
name|t
operator|instanceof
name|UndeclaredThrowableException
return|;
block|}
specifier|private
name|RowResolver
name|genRowResolver
parameter_list|(
name|Operator
name|op
parameter_list|,
name|QB
name|qb
parameter_list|)
block|{
name|RowResolver
name|rr
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|String
name|subqAlias
init|=
operator|(
name|qb
operator|.
name|getAliases
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|qb
operator|.
name|getSubqAliases
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
condition|?
name|qb
operator|.
name|getAliases
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
else|:
literal|null
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|ci
range|:
name|op
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
control|)
block|{
try|try
block|{
name|rr
operator|.
name|putWithCheck
argument_list|(
operator|(
name|subqAlias
operator|!=
literal|null
operator|)
condition|?
name|subqAlias
else|:
name|ci
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|ci
operator|.
name|getAlias
argument_list|()
operator|!=
literal|null
condition|?
name|ci
operator|.
name|getAlias
argument_list|()
else|:
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|ci
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|rr
return|;
block|}
specifier|private
enum|enum
name|ExtendedCBOProfile
block|{
name|JOIN_REORDERING
block|,
name|WINDOWING_POSTPROCESSING
block|,
name|REFERENTIAL_CONSTRAINTS
block|;   }
comment|/**    * Code responsible for Calcite plan generation and optimization.    */
specifier|private
class|class
name|CalcitePlannerAction
implements|implements
name|Frameworks
operator|.
name|PlannerAction
argument_list|<
name|RelNode
argument_list|>
block|{
specifier|private
name|RelOptCluster
name|cluster
decl_stmt|;
specifier|private
name|RelOptSchema
name|relOptSchema
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|PrunedPartitionList
argument_list|>
name|partitionCache
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|ColumnStatsList
argument_list|>
name|colStatsCache
decl_stmt|;
specifier|private
specifier|final
name|ColumnAccessInfo
name|columnAccessInfo
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|HiveProject
argument_list|,
name|Table
argument_list|>
name|viewProjectToTableSchema
decl_stmt|;
comment|//correlated vars across subqueries within same query needs to have different ID
comment|// this will be used in RexNodeConverter to create cor var
specifier|private
name|int
name|subqueryId
decl_stmt|;
comment|// this is to keep track if a subquery is correlated and contains aggregate
comment|// since this is special cased when it is rewritten in SubqueryRemoveRule
name|Set
argument_list|<
name|RelNode
argument_list|>
name|corrScalarRexSQWithAgg
init|=
operator|new
name|HashSet
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|RelNode
argument_list|>
name|scalarAggNoGbyNoWin
init|=
operator|new
name|HashSet
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
comment|// TODO: Do we need to keep track of RR, ColNameToPosMap for every op or
comment|// just last one.
name|LinkedHashMap
argument_list|<
name|RelNode
argument_list|,
name|RowResolver
argument_list|>
name|relToHiveRR
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|RelNode
argument_list|,
name|RowResolver
argument_list|>
argument_list|()
decl_stmt|;
name|LinkedHashMap
argument_list|<
name|RelNode
argument_list|,
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|relToHiveColNameCalcitePosMap
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|RelNode
argument_list|,
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|CalcitePlannerAction
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|PrunedPartitionList
argument_list|>
name|partitionCache
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ColumnStatsList
argument_list|>
name|colStatsCache
parameter_list|,
name|ColumnAccessInfo
name|columnAccessInfo
parameter_list|)
block|{
name|this
operator|.
name|partitionCache
operator|=
name|partitionCache
expr_stmt|;
name|this
operator|.
name|colStatsCache
operator|=
name|colStatsCache
expr_stmt|;
name|this
operator|.
name|columnAccessInfo
operator|=
name|columnAccessInfo
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RelNode
name|apply
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptSchema
name|relOptSchema
parameter_list|,
name|SchemaPlus
name|rootSchema
parameter_list|)
block|{
name|RelNode
name|calciteGenPlan
init|=
literal|null
decl_stmt|;
name|RelNode
name|calcitePreCboPlan
init|=
literal|null
decl_stmt|;
name|RelNode
name|calciteOptimizedPlan
init|=
literal|null
decl_stmt|;
name|subqueryId
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*        * recreate cluster, so that it picks up the additional traitDef        */
name|RelOptPlanner
name|planner
init|=
name|createPlanner
argument_list|(
name|conf
argument_list|,
name|corrScalarRexSQWithAgg
argument_list|,
name|scalarAggNoGbyNoWin
argument_list|)
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RelOptCluster
name|optCluster
init|=
name|RelOptCluster
operator|.
name|create
argument_list|(
name|planner
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
name|this
operator|.
name|cluster
operator|=
name|optCluster
expr_stmt|;
name|this
operator|.
name|relOptSchema
operator|=
name|relOptSchema
expr_stmt|;
name|PerfLogger
name|perfLogger
init|=
name|SessionState
operator|.
name|getPerfLogger
argument_list|()
decl_stmt|;
comment|// 1. Gen Calcite Plan
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|)
expr_stmt|;
try|try
block|{
name|calciteGenPlan
operator|=
name|genLogicalPlan
argument_list|(
name|getQB
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// if it is to create view, we do not use table alias
name|resultSchema
operator|=
name|SemanticAnalyzer
operator|.
name|convertRowSchemaToResultSetSchema
argument_list|(
name|relToHiveRR
operator|.
name|get
argument_list|(
name|calciteGenPlan
argument_list|)
argument_list|,
name|getQB
argument_list|()
operator|.
name|isView
argument_list|()
operator|||
name|getQB
argument_list|()
operator|.
name|isMaterializedView
argument_list|()
condition|?
literal|false
else|:
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_RESULTSET_USE_UNIQUE_COLUMN_NAMES
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|e
parameter_list|)
block|{
name|semanticException
operator|=
name|e
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|,
literal|"Calcite: Plan generation"
argument_list|)
expr_stmt|;
comment|// Validate query materialization (materialized views, query results caching.
comment|// This check needs to occur before constant folding, which may remove some
comment|// function calls from the query plan.
name|HiveRelOpMaterializationValidator
name|matValidator
init|=
operator|new
name|HiveRelOpMaterializationValidator
argument_list|()
decl_stmt|;
name|matValidator
operator|.
name|validateQueryMaterialization
argument_list|(
name|calciteGenPlan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|matValidator
operator|.
name|isValidMaterialization
argument_list|()
condition|)
block|{
name|String
name|reason
init|=
name|matValidator
operator|.
name|getInvalidMaterializationReason
argument_list|()
decl_stmt|;
name|setInvalidQueryMaterializationReason
argument_list|(
name|reason
argument_list|)
expr_stmt|;
block|}
comment|// Create executor
name|RexExecutor
name|executorProvider
init|=
operator|new
name|HiveRexExecutorImpl
argument_list|(
name|optCluster
argument_list|)
decl_stmt|;
name|calciteGenPlan
operator|.
name|getCluster
argument_list|()
operator|.
name|getPlanner
argument_list|()
operator|.
name|setExecutor
argument_list|(
name|executorProvider
argument_list|)
expr_stmt|;
comment|// We need to get the ColumnAccessInfo and viewToTableSchema for views.
name|HiveRelFieldTrimmer
name|fieldTrimmer
init|=
operator|new
name|HiveRelFieldTrimmer
argument_list|(
literal|null
argument_list|,
name|HiveRelFactories
operator|.
name|HIVE_BUILDER
operator|.
name|create
argument_list|(
name|optCluster
argument_list|,
literal|null
argument_list|)
argument_list|,
name|this
operator|.
name|columnAccessInfo
argument_list|,
name|this
operator|.
name|viewProjectToTableSchema
argument_list|)
decl_stmt|;
name|fieldTrimmer
operator|.
name|trim
argument_list|(
name|calciteGenPlan
argument_list|)
expr_stmt|;
comment|// Create and set MD provider
name|HiveDefaultRelMetadataProvider
name|mdProvider
init|=
operator|new
name|HiveDefaultRelMetadataProvider
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|RelMetadataQuery
operator|.
name|THREAD_PROVIDERS
operator|.
name|set
argument_list|(
name|JaninoRelMetadataProvider
operator|.
name|of
argument_list|(
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//Remove subquery
name|LOG
operator|.
name|debug
argument_list|(
literal|"Plan before removing subquery:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|calciteGenPlan
argument_list|)
argument_list|)
expr_stmt|;
name|calciteGenPlan
operator|=
name|hepPlan
argument_list|(
name|calciteGenPlan
argument_list|,
literal|false
argument_list|,
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
literal|null
argument_list|,
operator|new
name|HiveSubQueryRemoveRule
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Plan just after removing subquery:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|calciteGenPlan
argument_list|)
argument_list|)
expr_stmt|;
name|calciteGenPlan
operator|=
name|HiveRelDecorrelator
operator|.
name|decorrelateQuery
argument_list|(
name|calciteGenPlan
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Plan after decorrelation:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|calciteGenPlan
argument_list|)
argument_list|)
expr_stmt|;
comment|// 2. Apply pre-join order optimizations
name|calcitePreCboPlan
operator|=
name|applyPreJoinOrderingTransforms
argument_list|(
name|calciteGenPlan
argument_list|,
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
name|executorProvider
argument_list|)
expr_stmt|;
comment|// 3. Materialized view based rewriting
comment|// We disable it for CTAS and MV creation queries (trying to avoid any problem
comment|// due to data freshness)
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_MATERIALIZED_VIEW_ENABLE_AUTO_REWRITING
argument_list|)
operator|&&
operator|!
name|getQB
argument_list|()
operator|.
name|isMaterializedView
argument_list|()
operator|&&
operator|!
name|ctx
operator|.
name|isLoadingMaterializedView
argument_list|()
operator|&&
operator|!
name|getQB
argument_list|()
operator|.
name|isCTAS
argument_list|()
condition|)
block|{
name|calcitePreCboPlan
operator|=
name|applyMaterializedViewRewriting
argument_list|(
name|planner
argument_list|,
name|calcitePreCboPlan
argument_list|,
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
name|executorProvider
argument_list|)
expr_stmt|;
block|}
comment|// Get rid of sq_count_check if group by key is constant
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_REMOVE_SQ_COUNT_CHECK
argument_list|)
condition|)
block|{
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|)
expr_stmt|;
name|calcitePreCboPlan
operator|=
name|hepPlan
argument_list|(
name|calcitePreCboPlan
argument_list|,
literal|false
argument_list|,
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
literal|null
argument_list|,
name|HiveRemoveSqCountCheck
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|,
literal|"Calcite: Removing sq_count_check UDF "
argument_list|)
expr_stmt|;
block|}
comment|// 4. Apply join order optimizations: reordering MST algorithm
comment|//    If join optimizations failed because of missing stats, we continue with
comment|//    the rest of optimizations
if|if
condition|(
name|profilesCBO
operator|.
name|contains
argument_list|(
name|ExtendedCBOProfile
operator|.
name|JOIN_REORDERING
argument_list|)
condition|)
block|{
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|)
expr_stmt|;
comment|//  Remove Projects between Joins so that JoinToMultiJoinRule can merge them to MultiJoin
name|calcitePreCboPlan
operator|=
name|hepPlan
argument_list|(
name|calcitePreCboPlan
argument_list|,
literal|true
argument_list|,
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
name|executorProvider
argument_list|,
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|,
name|HiveJoinProjectTransposeRule
operator|.
name|LEFT_PROJECT_BTW_JOIN
argument_list|,
name|HiveJoinProjectTransposeRule
operator|.
name|RIGHT_PROJECT_BTW_JOIN
argument_list|,
name|HiveProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
try|try
block|{
name|List
argument_list|<
name|RelMetadataProvider
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|)
expr_stmt|;
name|RelTraitSet
name|desiredTraits
init|=
name|optCluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRelNode
operator|.
name|CONVENTION
argument_list|,
name|RelCollations
operator|.
name|EMPTY
argument_list|)
decl_stmt|;
name|HepProgramBuilder
name|hepPgmBldr
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addMatchOrder
argument_list|(
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|)
decl_stmt|;
name|hepPgmBldr
operator|.
name|addRuleInstance
argument_list|(
operator|new
name|JoinToMultiJoinRule
argument_list|(
name|HiveJoin
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|hepPgmBldr
operator|.
name|addRuleInstance
argument_list|(
operator|new
name|LoptOptimizeJoinRule
argument_list|(
name|HiveRelFactories
operator|.
name|HIVE_BUILDER
argument_list|)
argument_list|)
expr_stmt|;
name|HepProgram
name|hepPgm
init|=
name|hepPgmBldr
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|hepPgm
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|registerMetadataProviders
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|RelMetadataProvider
name|chainedProvider
init|=
name|ChainedRelMetadataProvider
operator|.
name|of
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|optCluster
operator|.
name|setMetadataProvider
argument_list|(
operator|new
name|CachingRelMetadataProvider
argument_list|(
name|chainedProvider
argument_list|,
name|hepPlanner
argument_list|)
argument_list|)
expr_stmt|;
name|RelNode
name|rootRel
init|=
name|calcitePreCboPlan
decl_stmt|;
name|hepPlanner
operator|.
name|setRoot
argument_list|(
name|rootRel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|calcitePreCboPlan
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equals
argument_list|(
name|desiredTraits
argument_list|)
condition|)
block|{
name|rootRel
operator|=
name|hepPlanner
operator|.
name|changeTraits
argument_list|(
name|calcitePreCboPlan
argument_list|,
name|desiredTraits
argument_list|)
expr_stmt|;
block|}
name|hepPlanner
operator|.
name|setRoot
argument_list|(
name|rootRel
argument_list|)
expr_stmt|;
name|calciteOptimizedPlan
operator|=
name|hepPlanner
operator|.
name|findBestExp
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|boolean
name|isMissingStats
init|=
name|noColsMissingStats
operator|.
name|get
argument_list|()
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|isMissingStats
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Missing column stats (see previous messages), skipping join reordering in CBO"
argument_list|)
expr_stmt|;
name|noColsMissingStats
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|calciteOptimizedPlan
operator|=
name|calcitePreCboPlan
expr_stmt|;
name|disableSemJoinReordering
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|,
literal|"Calcite: Join Reordering"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|calciteOptimizedPlan
operator|=
name|calcitePreCboPlan
expr_stmt|;
name|disableSemJoinReordering
operator|=
literal|false
expr_stmt|;
block|}
comment|// 5. Run other optimizations that do not need stats
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|)
expr_stmt|;
name|calciteOptimizedPlan
operator|=
name|hepPlan
argument_list|(
name|calciteOptimizedPlan
argument_list|,
literal|false
argument_list|,
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
literal|null
argument_list|,
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|,
name|ProjectRemoveRule
operator|.
name|INSTANCE
argument_list|,
name|HiveUnionMergeRule
operator|.
name|INSTANCE
argument_list|,
name|HiveAggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|,
name|HiveProjectMergeRule
operator|.
name|INSTANCE_NO_FORCE
argument_list|,
name|HiveJoinCommuteRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|,
literal|"Calcite: Optimizations without stats 1"
argument_list|)
expr_stmt|;
comment|// 6. Run aggregate-join transpose (cost based)
comment|//    If it failed because of missing stats, we continue with
comment|//    the rest of optimizations
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|AGGR_JOIN_TRANSPOSE
argument_list|)
condition|)
block|{
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|)
expr_stmt|;
try|try
block|{
name|calciteOptimizedPlan
operator|=
name|hepPlan
argument_list|(
name|calciteOptimizedPlan
argument_list|,
literal|false
argument_list|,
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
literal|null
argument_list|,
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|,
name|HiveAggregateJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|boolean
name|isMissingStats
init|=
name|noColsMissingStats
operator|.
name|get
argument_list|()
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|isMissingStats
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Missing column stats (see previous messages), skipping aggregate-join transpose in CBO"
argument_list|)
expr_stmt|;
name|noColsMissingStats
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|,
literal|"Calcite: Aggregate join transpose"
argument_list|)
expr_stmt|;
block|}
comment|// 7.convert Join + GBy to semijoin
comment|// run this rule at later stages, since many calcite rules cant deal with semijoin
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|SEMIJOIN_CONVERSION
argument_list|)
condition|)
block|{
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|)
expr_stmt|;
name|calciteOptimizedPlan
operator|=
name|hepPlan
argument_list|(
name|calciteOptimizedPlan
argument_list|,
literal|false
argument_list|,
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
literal|null
argument_list|,
name|HiveSemiJoinRule
operator|.
name|INSTANCE_PROJECT
argument_list|,
name|HiveSemiJoinRule
operator|.
name|INSTANCE_PROJECT_SWAPPED
argument_list|,
name|HiveSemiJoinRule
operator|.
name|INSTANCE_AGGREGATE
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|,
literal|"Calcite: Semijoin conversion"
argument_list|)
expr_stmt|;
block|}
comment|// 8. convert SemiJoin + GBy to SemiJoin
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|)
expr_stmt|;
name|calciteOptimizedPlan
operator|=
name|hepPlan
argument_list|(
name|calciteOptimizedPlan
argument_list|,
literal|false
argument_list|,
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
literal|null
argument_list|,
name|HiveRemoveGBYSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|,
literal|"Calcite: Removal of gby from semijoin"
argument_list|)
expr_stmt|;
comment|// 9. Run rule to fix windowing issue when it is done over
comment|// aggregation columns (HIVE-10627)
if|if
condition|(
name|profilesCBO
operator|.
name|contains
argument_list|(
name|ExtendedCBOProfile
operator|.
name|WINDOWING_POSTPROCESSING
argument_list|)
condition|)
block|{
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|)
expr_stmt|;
name|calciteOptimizedPlan
operator|=
name|hepPlan
argument_list|(
name|calciteOptimizedPlan
argument_list|,
literal|false
argument_list|,
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
literal|null
argument_list|,
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|,
name|HiveWindowingFixRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|,
literal|"Calcite: Window fixing rule"
argument_list|)
expr_stmt|;
block|}
comment|// 10. Apply Druid transformation rules
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|)
expr_stmt|;
name|calciteOptimizedPlan
operator|=
name|hepPlan
argument_list|(
name|calciteOptimizedPlan
argument_list|,
literal|false
argument_list|,
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
literal|null
argument_list|,
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|,
name|HiveDruidRules
operator|.
name|FILTER_DATE_RANGE_RULE
argument_list|,
name|HiveDruidRules
operator|.
name|FILTER
argument_list|,
name|HiveDruidRules
operator|.
name|PROJECT_FILTER_TRANSPOSE
argument_list|,
name|HiveDruidRules
operator|.
name|AGGREGATE_FILTER_TRANSPOSE
argument_list|,
name|HiveDruidRules
operator|.
name|AGGREGATE_PROJECT
argument_list|,
name|HiveDruidRules
operator|.
name|PROJECT
argument_list|,
name|HiveDruidRules
operator|.
name|EXPAND_SINGLE_DISTINCT_AGGREGATES_DRUID_RULE
argument_list|,
name|HiveDruidRules
operator|.
name|AGGREGATE
argument_list|,
name|HiveDruidRules
operator|.
name|POST_AGGREGATION_PROJECT
argument_list|,
name|HiveDruidRules
operator|.
name|FILTER_AGGREGATE_TRANSPOSE
argument_list|,
name|HiveDruidRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|,
name|HiveDruidRules
operator|.
name|HAVING_FILTER_RULE
argument_list|,
name|HiveDruidRules
operator|.
name|SORT_PROJECT_TRANSPOSE
argument_list|,
name|HiveDruidRules
operator|.
name|SORT
argument_list|,
name|HiveDruidRules
operator|.
name|PROJECT_SORT_TRANSPOSE
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|,
literal|"Calcite: Druid transformation rules"
argument_list|)
expr_stmt|;
name|calciteOptimizedPlan
operator|=
name|hepPlan
argument_list|(
name|calciteOptimizedPlan
argument_list|,
literal|true
argument_list|,
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
literal|null
argument_list|,
name|HepMatchOrder
operator|.
name|TOP_DOWN
argument_list|,
name|JDBCExtractJoinFilterRule
operator|.
name|INSTANCE
argument_list|,
name|JDBCAbstractSplitFilterRule
operator|.
name|SPLIT_FILTER_ABOVE_JOIN
argument_list|,
name|JDBCAbstractSplitFilterRule
operator|.
name|SPLIT_FILTER_ABOVE_CONVERTER
argument_list|,
name|JDBCFilterJoinRule
operator|.
name|INSTANCE
argument_list|,
name|JDBCJoinPushDownRule
operator|.
name|INSTANCE
argument_list|,
name|JDBCUnionPushDownRule
operator|.
name|INSTANCE
argument_list|,
name|JDBCFilterPushDownRule
operator|.
name|INSTANCE
argument_list|,
name|JDBCProjectPushDownRule
operator|.
name|INSTANCE
argument_list|,
name|JDBCAggregationPushDownRule
operator|.
name|INSTANCE
argument_list|,
name|JDBCSortPushDownRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
comment|// 11. Run rules to aid in translation from Calcite tree to Hive tree
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_CBO_RETPATH_HIVEOP
argument_list|)
condition|)
block|{
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|)
expr_stmt|;
comment|// 12.1. Merge join into multijoin operators (if possible)
name|calciteOptimizedPlan
operator|=
name|hepPlan
argument_list|(
name|calciteOptimizedPlan
argument_list|,
literal|true
argument_list|,
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
literal|null
argument_list|,
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|,
name|HiveJoinProjectTransposeRule
operator|.
name|BOTH_PROJECT_INCLUDE_OUTER
argument_list|,
name|HiveJoinProjectTransposeRule
operator|.
name|LEFT_PROJECT_INCLUDE_OUTER
argument_list|,
name|HiveJoinProjectTransposeRule
operator|.
name|RIGHT_PROJECT_INCLUDE_OUTER
argument_list|,
name|HiveJoinToMultiJoinRule
operator|.
name|INSTANCE
argument_list|,
name|HiveProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
comment|// The previous rules can pull up projections through join operators,
comment|// thus we run the field trimmer again to push them back down
name|fieldTrimmer
operator|=
operator|new
name|HiveRelFieldTrimmer
argument_list|(
literal|null
argument_list|,
name|HiveRelFactories
operator|.
name|HIVE_BUILDER
operator|.
name|create
argument_list|(
name|optCluster
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|calciteOptimizedPlan
operator|=
name|fieldTrimmer
operator|.
name|trim
argument_list|(
name|calciteOptimizedPlan
argument_list|)
expr_stmt|;
name|calciteOptimizedPlan
operator|=
name|hepPlan
argument_list|(
name|calciteOptimizedPlan
argument_list|,
literal|false
argument_list|,
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
literal|null
argument_list|,
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|,
name|ProjectRemoveRule
operator|.
name|INSTANCE
argument_list|,
operator|new
name|ProjectMergeRule
argument_list|(
literal|false
argument_list|,
name|HiveRelFactories
operator|.
name|HIVE_BUILDER
argument_list|)
argument_list|)
expr_stmt|;
name|calciteOptimizedPlan
operator|=
name|hepPlan
argument_list|(
name|calciteOptimizedPlan
argument_list|,
literal|true
argument_list|,
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
literal|null
argument_list|,
name|HiveFilterProjectTSTransposeRule
operator|.
name|INSTANCE
argument_list|,
name|HiveFilterProjectTSTransposeRule
operator|.
name|INSTANCE_DRUID
argument_list|,
name|HiveProjectFilterPullUpConstantsRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
comment|// 11.2.  Introduce exchange operators below join/multijoin operators
name|calciteOptimizedPlan
operator|=
name|hepPlan
argument_list|(
name|calciteOptimizedPlan
argument_list|,
literal|false
argument_list|,
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
literal|null
argument_list|,
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|,
name|HiveInsertExchange4JoinRule
operator|.
name|EXCHANGE_BELOW_JOIN
argument_list|,
name|HiveInsertExchange4JoinRule
operator|.
name|EXCHANGE_BELOW_MULTIJOIN
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|,
literal|"Calcite: Translation from Calcite tree to Hive tree"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_IN_TEST
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"CBO Planning details:\n"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Original Plan:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|calciteGenPlan
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Plan After PPD, PartPruning, ColumnPruning:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|calcitePreCboPlan
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Plan After Join Reordering:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|calciteOptimizedPlan
argument_list|,
name|SqlExplainLevel
operator|.
name|ALL_ATTRIBUTES
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|calciteOptimizedPlan
return|;
block|}
comment|/**      * Perform all optimizations before Join Ordering.      *      * @param basePlan      *          original plan      * @param mdProvider      *          meta data provider      * @param executorProvider      *          executor      * @return      */
specifier|private
name|RelNode
name|applyPreJoinOrderingTransforms
parameter_list|(
name|RelNode
name|basePlan
parameter_list|,
name|RelMetadataProvider
name|mdProvider
parameter_list|,
name|RexExecutor
name|executorProvider
parameter_list|)
block|{
comment|// TODO: Decorelation of subquery should be done before attempting
comment|// Partition Pruning; otherwise Expression evaluation may try to execute
comment|// corelated sub query.
name|PerfLogger
name|perfLogger
init|=
name|SessionState
operator|.
name|getPerfLogger
argument_list|()
decl_stmt|;
specifier|final
name|int
name|maxCNFNodeCount
init|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_CBO_CNF_NODES_LIMIT
argument_list|)
decl_stmt|;
specifier|final
name|int
name|minNumORClauses
init|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPOINTLOOKUPOPTIMIZERMIN
argument_list|)
decl_stmt|;
comment|//0. SetOp rewrite
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|)
expr_stmt|;
name|basePlan
operator|=
name|hepPlan
argument_list|(
name|basePlan
argument_list|,
literal|true
argument_list|,
name|mdProvider
argument_list|,
literal|null
argument_list|,
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|,
name|HiveProjectOverIntersectRemoveRule
operator|.
name|INSTANCE
argument_list|,
name|HiveIntersectMergeRule
operator|.
name|INSTANCE
argument_list|,
name|HiveUnionMergeRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|,
literal|"Calcite: HiveProjectOverIntersectRemoveRule, HiveIntersectMerge and HiveUnionMergeRule rules"
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|)
expr_stmt|;
name|basePlan
operator|=
name|hepPlan
argument_list|(
name|basePlan
argument_list|,
literal|false
argument_list|,
name|mdProvider
argument_list|,
name|executorProvider
argument_list|,
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|,
name|HiveIntersectRewriteRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|,
literal|"Calcite: HiveIntersectRewrite rule"
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|)
expr_stmt|;
name|basePlan
operator|=
name|hepPlan
argument_list|(
name|basePlan
argument_list|,
literal|false
argument_list|,
name|mdProvider
argument_list|,
name|executorProvider
argument_list|,
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|,
name|HiveExceptRewriteRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|,
literal|"Calcite: HiveExceptRewrite rule"
argument_list|)
expr_stmt|;
comment|//1. Distinct aggregate rewrite
comment|// Run this optimization early, since it is expanding the operator pipeline.
if|if
condition|(
operator|!
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_EXECUTION_ENGINE
argument_list|)
operator|.
name|equals
argument_list|(
literal|"mr"
argument_list|)
operator|&&
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTIMIZEDISTINCTREWRITE
argument_list|)
condition|)
block|{
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|)
expr_stmt|;
comment|// Its not clear, if this rewrite is always performant on MR, since extra map phase
comment|// introduced for 2nd MR job may offset gains of this multi-stage aggregation.
comment|// We need a cost model for MR to enable this on MR.
name|basePlan
operator|=
name|hepPlan
argument_list|(
name|basePlan
argument_list|,
literal|true
argument_list|,
name|mdProvider
argument_list|,
name|executorProvider
argument_list|,
name|HiveExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|,
literal|"Calcite: Prejoin ordering transformation, Distinct aggregate rewrite"
argument_list|)
expr_stmt|;
block|}
comment|// 2. Try factoring out common filter elements& separating deterministic
comment|// vs non-deterministic UDF. This needs to run before PPD so that PPD can
comment|// add on-clauses for old style Join Syntax
comment|// Ex: select * from R1 join R2 where ((R1.x=R2.x) and R1.y<10) or
comment|// ((R1.x=R2.x) and R1.z=10)) and rand(1)< 0.1
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|)
expr_stmt|;
name|basePlan
operator|=
name|hepPlan
argument_list|(
name|basePlan
argument_list|,
literal|false
argument_list|,
name|mdProvider
argument_list|,
name|executorProvider
argument_list|,
name|HepMatchOrder
operator|.
name|ARBITRARY
argument_list|,
operator|new
name|HivePreFilteringRule
argument_list|(
name|maxCNFNodeCount
argument_list|)
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|,
literal|"Calcite: Prejoin ordering transformation, factor out common filter elements and separating deterministic vs non-deterministic UDF"
argument_list|)
expr_stmt|;
comment|// 3. Run exhaustive PPD, add not null filters, transitive inference,
comment|// constant propagation, constant folding
name|List
argument_list|<
name|RelOptRule
argument_list|>
name|rules
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTPPD_WINDOWING
argument_list|)
condition|)
block|{
name|rules
operator|.
name|add
argument_list|(
name|HiveFilterProjectTransposeRule
operator|.
name|INSTANCE_DETERMINISTIC_WINDOWING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rules
operator|.
name|add
argument_list|(
name|HiveFilterProjectTransposeRule
operator|.
name|INSTANCE_DETERMINISTIC
argument_list|)
expr_stmt|;
block|}
name|rules
operator|.
name|add
argument_list|(
name|HiveFilterSetOpTransposeRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|rules
operator|.
name|add
argument_list|(
name|HiveFilterSortTransposeRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|rules
operator|.
name|add
argument_list|(
name|HiveFilterJoinRule
operator|.
name|JOIN
argument_list|)
expr_stmt|;
name|rules
operator|.
name|add
argument_list|(
name|HiveFilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
expr_stmt|;
name|rules
operator|.
name|add
argument_list|(
operator|new
name|HiveFilterAggregateTransposeRule
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|HiveRelFactories
operator|.
name|HIVE_BUILDER
argument_list|,
name|Aggregate
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|rules
operator|.
name|add
argument_list|(
operator|new
name|FilterMergeRule
argument_list|(
name|HiveRelFactories
operator|.
name|HIVE_BUILDER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_OPTIMIZE_REDUCE_WITH_STATS
argument_list|)
condition|)
block|{
name|rules
operator|.
name|add
argument_list|(
name|HiveReduceExpressionsWithStatsRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
name|rules
operator|.
name|add
argument_list|(
name|HiveProjectFilterPullUpConstantsRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|rules
operator|.
name|add
argument_list|(
name|HiveReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
expr_stmt|;
name|rules
operator|.
name|add
argument_list|(
name|HiveReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
expr_stmt|;
name|rules
operator|.
name|add
argument_list|(
name|HiveReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
expr_stmt|;
name|rules
operator|.
name|add
argument_list|(
name|HiveAggregateReduceFunctionsRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|rules
operator|.
name|add
argument_list|(
name|HiveAggregateReduceRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPOINTLOOKUPOPTIMIZER
argument_list|)
condition|)
block|{
name|rules
operator|.
name|add
argument_list|(
operator|new
name|HivePointLookupOptimizerRule
operator|.
name|FilterCondition
argument_list|(
name|minNumORClauses
argument_list|)
argument_list|)
expr_stmt|;
name|rules
operator|.
name|add
argument_list|(
operator|new
name|HivePointLookupOptimizerRule
operator|.
name|JoinCondition
argument_list|(
name|minNumORClauses
argument_list|)
argument_list|)
expr_stmt|;
name|rules
operator|.
name|add
argument_list|(
operator|new
name|HivePointLookupOptimizerRule
operator|.
name|ProjectionExpressions
argument_list|(
name|minNumORClauses
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rules
operator|.
name|add
argument_list|(
name|HiveProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_OPTIMIZE_CONSTRAINTS_JOIN
argument_list|)
operator|&&
name|profilesCBO
operator|.
name|contains
argument_list|(
name|ExtendedCBOProfile
operator|.
name|REFERENTIAL_CONSTRAINTS
argument_list|)
condition|)
block|{
name|rules
operator|.
name|add
argument_list|(
name|HiveJoinConstraintsRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
name|rules
operator|.
name|add
argument_list|(
name|HiveJoinAddNotNullRule
operator|.
name|INSTANCE_JOIN
argument_list|)
expr_stmt|;
name|rules
operator|.
name|add
argument_list|(
name|HiveJoinAddNotNullRule
operator|.
name|INSTANCE_SEMIJOIN
argument_list|)
expr_stmt|;
name|rules
operator|.
name|add
argument_list|(
name|HiveJoinPushTransitivePredicatesRule
operator|.
name|INSTANCE_JOIN
argument_list|)
expr_stmt|;
name|rules
operator|.
name|add
argument_list|(
name|HiveJoinPushTransitivePredicatesRule
operator|.
name|INSTANCE_SEMIJOIN
argument_list|)
expr_stmt|;
name|rules
operator|.
name|add
argument_list|(
name|HiveSortMergeRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|rules
operator|.
name|add
argument_list|(
name|HiveSortLimitPullUpConstantsRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|rules
operator|.
name|add
argument_list|(
name|HiveUnionPullUpConstantsRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|rules
operator|.
name|add
argument_list|(
name|HiveAggregatePullUpConstantsRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|)
expr_stmt|;
name|basePlan
operator|=
name|hepPlan
argument_list|(
name|basePlan
argument_list|,
literal|true
argument_list|,
name|mdProvider
argument_list|,
name|executorProvider
argument_list|,
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|,
name|rules
operator|.
name|toArray
argument_list|(
operator|new
name|RelOptRule
index|[
name|rules
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|,
literal|"Calcite: Prejoin ordering transformation, PPD, not null predicates, transitive inference, constant folding"
argument_list|)
expr_stmt|;
comment|// 4. Push down limit through outer join
comment|// NOTE: We run this after PPD to support old style join syntax.
comment|// Ex: select * from R1 left outer join R2 where ((R1.x=R2.x) and R1.y<10) or
comment|// ((R1.x=R2.x) and R1.z=10)) and rand(1)< 0.1 order by R1.x limit 10
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_OPTIMIZE_LIMIT_TRANSPOSE
argument_list|)
condition|)
block|{
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|)
expr_stmt|;
comment|// This should be a cost based decision, but till we enable the extended cost
comment|// model, we will use the given value for the variable
specifier|final
name|float
name|reductionProportion
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_OPTIMIZE_LIMIT_TRANSPOSE_REDUCTION_PERCENTAGE
argument_list|)
decl_stmt|;
specifier|final
name|long
name|reductionTuples
init|=
name|HiveConf
operator|.
name|getLongVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_OPTIMIZE_LIMIT_TRANSPOSE_REDUCTION_TUPLES
argument_list|)
decl_stmt|;
name|basePlan
operator|=
name|hepPlan
argument_list|(
name|basePlan
argument_list|,
literal|true
argument_list|,
name|mdProvider
argument_list|,
name|executorProvider
argument_list|,
name|HiveSortMergeRule
operator|.
name|INSTANCE
argument_list|,
name|HiveSortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|,
name|HiveSortJoinReduceRule
operator|.
name|INSTANCE
argument_list|,
name|HiveSortUnionReduceRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|basePlan
operator|=
name|hepPlan
argument_list|(
name|basePlan
argument_list|,
literal|true
argument_list|,
name|mdProvider
argument_list|,
name|executorProvider
argument_list|,
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|,
operator|new
name|HiveSortRemoveRule
argument_list|(
name|reductionProportion
argument_list|,
name|reductionTuples
argument_list|)
argument_list|,
name|HiveProjectSortTransposeRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|,
literal|"Calcite: Prejoin ordering transformation, Push down limit through outer join"
argument_list|)
expr_stmt|;
block|}
comment|// 5. Push Down Semi Joins
comment|//TODO: Enable this later
comment|/*perfLogger.PerfLogBegin(this.getClass().getName(), PerfLogger.OPTIMIZER);       basePlan = hepPlan(basePlan, true, mdProvider, executorProvider, SemiJoinJoinTransposeRule.INSTANCE,           SemiJoinFilterTransposeRule.INSTANCE, SemiJoinProjectTransposeRule.INSTANCE);       perfLogger.PerfLogEnd(this.getClass().getName(), PerfLogger.OPTIMIZER,         "Calcite: Prejoin ordering transformation, Push Down Semi Joins"); */
comment|// 6. Apply Partition Pruning
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|)
expr_stmt|;
name|basePlan
operator|=
name|hepPlan
argument_list|(
name|basePlan
argument_list|,
literal|false
argument_list|,
name|mdProvider
argument_list|,
name|executorProvider
argument_list|,
operator|new
name|HivePartitionPruneRule
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|,
literal|"Calcite: Prejoin ordering transformation, Partition Pruning"
argument_list|)
expr_stmt|;
comment|// 7. Projection Pruning (this introduces select above TS& hence needs to be run last due to PP)
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|)
expr_stmt|;
name|HiveRelFieldTrimmer
name|fieldTrimmer
init|=
operator|new
name|HiveRelFieldTrimmer
argument_list|(
literal|null
argument_list|,
name|HiveRelFactories
operator|.
name|HIVE_BUILDER
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
literal|null
argument_list|)
argument_list|,
name|profilesCBO
operator|.
name|contains
argument_list|(
name|ExtendedCBOProfile
operator|.
name|JOIN_REORDERING
argument_list|)
argument_list|)
decl_stmt|;
name|basePlan
operator|=
name|fieldTrimmer
operator|.
name|trim
argument_list|(
name|basePlan
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|,
literal|"Calcite: Prejoin ordering transformation, Projection Pruning"
argument_list|)
expr_stmt|;
comment|// 8. Rerun PPD through Project as column pruning would have introduced
comment|// DT above scans; By pushing filter just above TS, Hive can push it into
comment|// storage (incase there are filters on non partition cols). This only
comment|// matches FIL-PROJ-TS
comment|// Also merge, remove and reduce Project if possible
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|)
expr_stmt|;
name|basePlan
operator|=
name|hepPlan
argument_list|(
name|basePlan
argument_list|,
literal|true
argument_list|,
name|mdProvider
argument_list|,
name|executorProvider
argument_list|,
name|HiveFilterProjectTSTransposeRule
operator|.
name|INSTANCE
argument_list|,
name|HiveFilterProjectTSTransposeRule
operator|.
name|INSTANCE_DRUID
argument_list|,
name|HiveProjectFilterPullUpConstantsRule
operator|.
name|INSTANCE
argument_list|,
name|HiveProjectMergeRule
operator|.
name|INSTANCE
argument_list|,
name|ProjectRemoveRule
operator|.
name|INSTANCE
argument_list|,
name|HiveSortMergeRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|,
literal|"Calcite: Prejoin ordering transformation, Rerun PPD"
argument_list|)
expr_stmt|;
return|return
name|basePlan
return|;
block|}
specifier|private
name|RelNode
name|applyMaterializedViewRewriting
parameter_list|(
name|RelOptPlanner
name|planner
parameter_list|,
name|RelNode
name|basePlan
parameter_list|,
name|RelMetadataProvider
name|mdProvider
parameter_list|,
name|RexExecutor
name|executorProvider
parameter_list|)
block|{
specifier|final
name|RelOptCluster
name|optCluster
init|=
name|basePlan
operator|.
name|getCluster
argument_list|()
decl_stmt|;
specifier|final
name|PerfLogger
name|perfLogger
init|=
name|SessionState
operator|.
name|getPerfLogger
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|calcitePreMVRewritingPlan
init|=
name|basePlan
decl_stmt|;
comment|// Add views to planner
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
name|materializations
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|mvRebuildMode
operator|!=
name|MaterializationRebuildMode
operator|.
name|NONE
condition|)
block|{
comment|// We only retrieve the materialization corresponding to the rebuild. In turn,
comment|// we pass 'true' for the forceMVContentsUpToDate parameter, as we cannot allow the
comment|// materialization contents to be stale for a rebuild if we want to use it.
name|materializations
operator|=
name|db
operator|.
name|getValidMaterializedView
argument_list|(
name|mvRebuildDbName
argument_list|,
name|mvRebuildName
argument_list|,
name|getTablesUsed
argument_list|(
name|basePlan
argument_list|)
argument_list|,
literal|true
argument_list|,
name|getTxnMgr
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// This is not a rebuild, we retrieve all the materializations. In turn, we do not need
comment|// to force the materialization contents to be up-to-date, as this is not a rebuild, and
comment|// we apply the user parameters (HIVE_MATERIALIZED_VIEW_REWRITING_TIME_WINDOW) instead.
name|materializations
operator|=
name|db
operator|.
name|getAllValidMaterializedViews
argument_list|(
name|getTablesUsed
argument_list|(
name|basePlan
argument_list|)
argument_list|,
literal|false
argument_list|,
name|getTxnMgr
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// We need to use the current cluster for the scan operator on views,
comment|// otherwise the planner will throw an Exception (different planners)
name|materializations
operator|=
name|Lists
operator|.
name|transform
argument_list|(
name|materializations
argument_list|,
operator|new
name|Function
argument_list|<
name|RelOptMaterialization
argument_list|,
name|RelOptMaterialization
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RelOptMaterialization
name|apply
parameter_list|(
name|RelOptMaterialization
name|materialization
parameter_list|)
block|{
specifier|final
name|RelNode
name|viewScan
init|=
name|materialization
operator|.
name|tableRel
decl_stmt|;
specifier|final
name|RelNode
name|newViewScan
decl_stmt|;
if|if
condition|(
name|viewScan
operator|instanceof
name|Project
condition|)
block|{
comment|// There is a Project on top (due to nullability)
specifier|final
name|Project
name|pq
init|=
operator|(
name|Project
operator|)
name|viewScan
decl_stmt|;
name|newViewScan
operator|=
name|HiveProject
operator|.
name|create
argument_list|(
name|optCluster
argument_list|,
name|copyNodeScan
argument_list|(
name|pq
operator|.
name|getInput
argument_list|()
argument_list|)
argument_list|,
name|pq
operator|.
name|getChildExps
argument_list|()
argument_list|,
name|pq
operator|.
name|getRowType
argument_list|()
argument_list|,
name|Collections
operator|.
expr|<
name|RelCollation
operator|>
name|emptyList
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newViewScan
operator|=
name|copyNodeScan
argument_list|(
name|viewScan
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|RelOptMaterialization
argument_list|(
name|newViewScan
argument_list|,
name|materialization
operator|.
name|queryRel
argument_list|,
literal|null
argument_list|,
name|materialization
operator|.
name|qualifiedTableName
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|copyNodeScan
parameter_list|(
name|RelNode
name|scan
parameter_list|)
block|{
specifier|final
name|RelNode
name|newScan
decl_stmt|;
if|if
condition|(
name|scan
operator|instanceof
name|DruidQuery
condition|)
block|{
specifier|final
name|DruidQuery
name|dq
init|=
operator|(
name|DruidQuery
operator|)
name|scan
decl_stmt|;
comment|// Ideally we should use HiveRelNode convention. However, since Volcano planner
comment|// throws in that case because DruidQuery does not implement the interface,
comment|// we set it as Bindable. Currently, we do not use convention in Hive, hence that
comment|// should be fine.
comment|// TODO: If we want to make use of convention (e.g., while directly generating operator
comment|// tree instead of AST), this should be changed.
name|newScan
operator|=
name|DruidQuery
operator|.
name|create
argument_list|(
name|optCluster
argument_list|,
name|optCluster
operator|.
name|traitSetOf
argument_list|(
name|BindableConvention
operator|.
name|INSTANCE
argument_list|)
argument_list|,
name|scan
operator|.
name|getTable
argument_list|()
argument_list|,
name|dq
operator|.
name|getDruidTable
argument_list|()
argument_list|,
name|ImmutableList
operator|.
expr|<
name|RelNode
operator|>
name|of
argument_list|(
name|dq
operator|.
name|getTableScan
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newScan
operator|=
operator|new
name|HiveTableScan
argument_list|(
name|optCluster
argument_list|,
name|optCluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRelNode
operator|.
name|CONVENTION
argument_list|)
argument_list|,
operator|(
name|RelOptHiveTable
operator|)
name|scan
operator|.
name|getTable
argument_list|()
argument_list|,
operator|(
operator|(
name|RelOptHiveTable
operator|)
name|scan
operator|.
name|getTable
argument_list|()
operator|)
operator|.
name|getName
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
name|newScan
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception loading materialized views"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|materializations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|)
expr_stmt|;
comment|// Use Calcite cost model for view rewriting
name|optCluster
operator|.
name|invalidateMetadataQuery
argument_list|()
expr_stmt|;
name|RelMetadataQuery
operator|.
name|THREAD_PROVIDERS
operator|.
name|set
argument_list|(
name|JaninoRelMetadataProvider
operator|.
name|of
argument_list|(
name|DefaultRelMetadataProvider
operator|.
name|INSTANCE
argument_list|)
argument_list|)
expr_stmt|;
comment|// Add materializations to planner
for|for
control|(
name|RelOptMaterialization
name|materialization
range|:
name|materializations
control|)
block|{
name|planner
operator|.
name|addMaterialization
argument_list|(
name|materialization
argument_list|)
expr_stmt|;
block|}
comment|// Add view-based rewriting rules to planner
name|planner
operator|.
name|addRule
argument_list|(
name|HiveMaterializedViewRule
operator|.
name|INSTANCE_PROJECT_FILTER
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|HiveMaterializedViewRule
operator|.
name|INSTANCE_FILTER
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|HiveMaterializedViewRule
operator|.
name|INSTANCE_PROJECT_JOIN
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|HiveMaterializedViewRule
operator|.
name|INSTANCE_JOIN
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|HiveMaterializedViewRule
operator|.
name|INSTANCE_PROJECT_AGGREGATE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|HiveMaterializedViewRule
operator|.
name|INSTANCE_AGGREGATE
argument_list|)
expr_stmt|;
comment|// Partition pruner rule
name|planner
operator|.
name|addRule
argument_list|(
name|HiveFilterProjectTSTransposeRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
operator|new
name|HivePartitionPruneRule
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
comment|// Optimize plan
name|planner
operator|.
name|setRoot
argument_list|(
name|basePlan
argument_list|)
expr_stmt|;
name|basePlan
operator|=
name|planner
operator|.
name|findBestExp
argument_list|()
expr_stmt|;
comment|// Remove view-based rewriting rules from planner
name|planner
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Restore default cost model
name|optCluster
operator|.
name|invalidateMetadataQuery
argument_list|()
expr_stmt|;
name|RelMetadataQuery
operator|.
name|THREAD_PROVIDERS
operator|.
name|set
argument_list|(
name|JaninoRelMetadataProvider
operator|.
name|of
argument_list|(
name|mdProvider
argument_list|)
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|PerfLogger
operator|.
name|OPTIMIZER
argument_list|,
literal|"Calcite: View-based rewriting"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|calcitePreMVRewritingPlan
argument_list|)
operator|.
name|equals
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|basePlan
argument_list|)
argument_list|)
condition|)
block|{
comment|// A rewriting was produced, we will check whether it was part of an incremental rebuild
comment|// to try to replace INSERT OVERWRITE by INSERT
if|if
condition|(
name|mvRebuildMode
operator|==
name|MaterializationRebuildMode
operator|.
name|INSERT_OVERWRITE_REBUILD
operator|&&
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_MATERIALIZED_VIEW_REBUILD_INCREMENTAL
argument_list|)
condition|)
block|{
comment|// First we need to check if it is valid to convert to MERGE/INSERT INTO.
comment|// If we succeed, we modify the plan and afterwards the AST.
comment|// MV should be an acid table.
name|MaterializedViewRewritingRelVisitor
name|visitor
init|=
operator|new
name|MaterializedViewRewritingRelVisitor
argument_list|()
decl_stmt|;
name|visitor
operator|.
name|go
argument_list|(
name|basePlan
argument_list|)
expr_stmt|;
if|if
condition|(
name|visitor
operator|.
name|isRewritingAllowed
argument_list|()
condition|)
block|{
comment|// Trigger rewriting to remove UNION branch with MV
if|if
condition|(
name|visitor
operator|.
name|isContainsAggregate
argument_list|()
condition|)
block|{
name|basePlan
operator|=
name|hepPlan
argument_list|(
name|basePlan
argument_list|,
literal|false
argument_list|,
name|mdProvider
argument_list|,
literal|null
argument_list|,
name|HepMatchOrder
operator|.
name|TOP_DOWN
argument_list|,
name|HiveAggregateIncrementalRewritingRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|mvRebuildMode
operator|=
name|MaterializationRebuildMode
operator|.
name|AGGREGATE_REBUILD
expr_stmt|;
block|}
else|else
block|{
name|basePlan
operator|=
name|hepPlan
argument_list|(
name|basePlan
argument_list|,
literal|false
argument_list|,
name|mdProvider
argument_list|,
literal|null
argument_list|,
name|HepMatchOrder
operator|.
name|TOP_DOWN
argument_list|,
name|HiveNoAggregateIncrementalRewritingRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|mvRebuildMode
operator|=
name|MaterializationRebuildMode
operator|.
name|NO_AGGREGATE_REBUILD
expr_stmt|;
block|}
block|}
block|}
comment|// Now we trigger some needed optimization rules again
name|basePlan
operator|=
name|applyPreJoinOrderingTransforms
argument_list|(
name|basePlan
argument_list|,
name|mdProvider
argument_list|,
name|executorProvider
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|basePlan
return|;
block|}
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getTablesUsed
parameter_list|(
name|RelNode
name|plan
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|tablesUsed
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
operator|new
name|RelVisitor
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|node
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|TableScan
condition|)
block|{
name|TableScan
name|ts
init|=
operator|(
name|TableScan
operator|)
name|node
decl_stmt|;
name|tablesUsed
operator|.
name|add
argument_list|(
operator|(
operator|(
name|RelOptHiveTable
operator|)
name|ts
operator|.
name|getTable
argument_list|()
operator|)
operator|.
name|getHiveTableMD
argument_list|()
operator|.
name|getFullyQualifiedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|super
operator|.
name|visit
argument_list|(
name|node
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
operator|.
name|go
argument_list|(
name|plan
argument_list|)
expr_stmt|;
return|return
name|tablesUsed
return|;
block|}
comment|/**      * Run the HEP Planner with the given rule set.      *      * @param basePlan      * @param followPlanChanges      * @param mdProvider      * @param executorProvider      * @param rules      * @return optimized RelNode      */
specifier|private
name|RelNode
name|hepPlan
parameter_list|(
name|RelNode
name|basePlan
parameter_list|,
name|boolean
name|followPlanChanges
parameter_list|,
name|RelMetadataProvider
name|mdProvider
parameter_list|,
name|RexExecutor
name|executorProvider
parameter_list|,
name|RelOptRule
modifier|...
name|rules
parameter_list|)
block|{
return|return
name|hepPlan
argument_list|(
name|basePlan
argument_list|,
name|followPlanChanges
argument_list|,
name|mdProvider
argument_list|,
name|executorProvider
argument_list|,
name|HepMatchOrder
operator|.
name|TOP_DOWN
argument_list|,
name|rules
argument_list|)
return|;
block|}
comment|/**      * Run the HEP Planner with the given rule set.      *      * @param basePlan      * @param followPlanChanges      * @param mdProvider      * @param executorProvider      * @param order      * @param rules      * @return optimized RelNode      */
specifier|private
name|RelNode
name|hepPlan
parameter_list|(
name|RelNode
name|basePlan
parameter_list|,
name|boolean
name|followPlanChanges
parameter_list|,
name|RelMetadataProvider
name|mdProvider
parameter_list|,
name|RexExecutor
name|executorProvider
parameter_list|,
name|HepMatchOrder
name|order
parameter_list|,
name|RelOptRule
modifier|...
name|rules
parameter_list|)
block|{
name|RelNode
name|optimizedRelNode
init|=
name|basePlan
decl_stmt|;
name|HepProgramBuilder
name|programBuilder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|followPlanChanges
condition|)
block|{
name|programBuilder
operator|.
name|addMatchOrder
argument_list|(
name|order
argument_list|)
expr_stmt|;
name|programBuilder
operator|=
name|programBuilder
operator|.
name|addRuleCollection
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|rules
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// TODO: Should this be also TOP_DOWN?
for|for
control|(
name|RelOptRule
name|r
range|:
name|rules
control|)
name|programBuilder
operator|.
name|addRuleInstance
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
comment|// Create planner and copy context
name|HepPlanner
name|planner
init|=
operator|new
name|HepPlanner
argument_list|(
name|programBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|basePlan
operator|.
name|getCluster
argument_list|()
operator|.
name|getPlanner
argument_list|()
operator|.
name|getContext
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RelMetadataProvider
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|mdProvider
argument_list|)
expr_stmt|;
name|planner
operator|.
name|registerMetadataProviders
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|RelMetadataProvider
name|chainedProvider
init|=
name|ChainedRelMetadataProvider
operator|.
name|of
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|basePlan
operator|.
name|getCluster
argument_list|()
operator|.
name|setMetadataProvider
argument_list|(
operator|new
name|CachingRelMetadataProvider
argument_list|(
name|chainedProvider
argument_list|,
name|planner
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|executorProvider
operator|!=
literal|null
condition|)
block|{
comment|// basePlan.getCluster.getPlanner is the VolcanoPlanner from apply()
comment|// both planners need to use the correct executor
name|basePlan
operator|.
name|getCluster
argument_list|()
operator|.
name|getPlanner
argument_list|()
operator|.
name|setExecutor
argument_list|(
name|executorProvider
argument_list|)
expr_stmt|;
name|planner
operator|.
name|setExecutor
argument_list|(
name|executorProvider
argument_list|)
expr_stmt|;
block|}
name|planner
operator|.
name|setRoot
argument_list|(
name|basePlan
argument_list|)
expr_stmt|;
name|optimizedRelNode
operator|=
name|planner
operator|.
name|findBestExp
argument_list|()
expr_stmt|;
return|return
name|optimizedRelNode
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|RelNode
name|genSetOpLogicalPlan
parameter_list|(
name|Opcode
name|opcode
parameter_list|,
name|String
name|alias
parameter_list|,
name|String
name|leftalias
parameter_list|,
name|RelNode
name|leftRel
parameter_list|,
name|String
name|rightalias
parameter_list|,
name|RelNode
name|rightRel
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// 1. Get Row Resolvers, Column map for original left and right input of
comment|// SetOp Rel
name|RowResolver
name|leftRR
init|=
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|leftRel
argument_list|)
decl_stmt|;
name|RowResolver
name|rightRR
init|=
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|rightRel
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|leftmap
init|=
name|leftRR
operator|.
name|getFieldMap
argument_list|(
name|leftalias
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|rightmap
init|=
name|rightRR
operator|.
name|getFieldMap
argument_list|(
name|rightalias
argument_list|)
decl_stmt|;
comment|// 2. Validate that SetOp is feasible according to Hive (by using type
comment|// info from RR)
if|if
condition|(
name|leftmap
operator|.
name|size
argument_list|()
operator|!=
name|rightmap
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Schema of both sides of union should match."
argument_list|)
throw|;
block|}
name|ASTNode
name|tabref
init|=
name|getQB
argument_list|()
operator|.
name|getAliases
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|getQB
argument_list|()
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|getQB
argument_list|()
operator|.
name|getAliases
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|// 3. construct SetOp Output RR using original left& right Input
name|RowResolver
name|setOpOutRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
argument_list|>
name|lIter
init|=
name|leftmap
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
argument_list|>
name|rIter
init|=
name|rightmap
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|lIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|lEntry
init|=
name|lIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|rEntry
init|=
name|rIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|ColumnInfo
name|lInfo
init|=
name|lEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ColumnInfo
name|rInfo
init|=
name|rEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|field
init|=
name|lEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
comment|// try widening conversion, otherwise fail union
name|TypeInfo
name|commonTypeInfo
init|=
name|FunctionRegistry
operator|.
name|getCommonClassForUnionAll
argument_list|(
name|lInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|rInfo
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|commonTypeInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|tabref
argument_list|,
literal|"Schema of both sides of setop should match: Column "
operator|+
name|field
operator|+
literal|" is of type "
operator|+
name|lInfo
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
operator|+
literal|" on first table and type "
operator|+
name|rInfo
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
operator|+
literal|" on second table"
argument_list|)
argument_list|)
throw|;
block|}
name|ColumnInfo
name|setOpColInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|lInfo
argument_list|)
decl_stmt|;
name|setOpColInfo
operator|.
name|setType
argument_list|(
name|commonTypeInfo
argument_list|)
expr_stmt|;
name|setOpOutRR
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|field
argument_list|,
name|setOpColInfo
argument_list|)
expr_stmt|;
block|}
comment|// 4. Determine which columns requires cast on left/right input (Calcite
comment|// requires exact types on both sides of SetOp)
name|boolean
name|leftNeedsTypeCast
init|=
literal|false
decl_stmt|;
name|boolean
name|rightNeedsTypeCast
init|=
literal|false
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftProjs
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightProjs
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|leftRowDT
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightRowDT
init|=
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|RelDataType
name|leftFieldDT
decl_stmt|;
name|RelDataType
name|rightFieldDT
decl_stmt|;
name|RelDataType
name|unionFieldDT
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftRowDT
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|leftFieldDT
operator|=
name|leftRowDT
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
name|rightFieldDT
operator|=
name|rightRowDT
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|leftFieldDT
operator|.
name|equals
argument_list|(
name|rightFieldDT
argument_list|)
condition|)
block|{
name|unionFieldDT
operator|=
name|TypeConverter
operator|.
name|convert
argument_list|(
name|setOpOutRR
operator|.
name|getColumnInfos
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|cluster
operator|.
name|getTypeFactory
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unionFieldDT
operator|.
name|equals
argument_list|(
name|leftFieldDT
argument_list|)
condition|)
block|{
name|leftNeedsTypeCast
operator|=
literal|true
expr_stmt|;
block|}
name|leftProjs
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|ensureType
argument_list|(
name|unionFieldDT
argument_list|,
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|leftFieldDT
argument_list|,
name|i
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unionFieldDT
operator|.
name|equals
argument_list|(
name|rightFieldDT
argument_list|)
condition|)
block|{
name|rightNeedsTypeCast
operator|=
literal|true
expr_stmt|;
block|}
name|rightProjs
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|ensureType
argument_list|(
name|unionFieldDT
argument_list|,
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|rightFieldDT
argument_list|,
name|i
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|leftProjs
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|ensureType
argument_list|(
name|leftFieldDT
argument_list|,
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|leftFieldDT
argument_list|,
name|i
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|rightProjs
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|ensureType
argument_list|(
name|rightFieldDT
argument_list|,
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|rightFieldDT
argument_list|,
name|i
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 5. Introduce Project Rel above original left/right inputs if cast is
comment|// needed for type parity
name|RelNode
name|setOpLeftInput
init|=
name|leftRel
decl_stmt|;
name|RelNode
name|setOpRightInput
init|=
name|rightRel
decl_stmt|;
if|if
condition|(
name|leftNeedsTypeCast
condition|)
block|{
name|setOpLeftInput
operator|=
name|HiveProject
operator|.
name|create
argument_list|(
name|leftRel
argument_list|,
name|leftProjs
argument_list|,
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rightNeedsTypeCast
condition|)
block|{
name|setOpRightInput
operator|=
name|HiveProject
operator|.
name|create
argument_list|(
name|rightRel
argument_list|,
name|rightProjs
argument_list|,
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// 6. Construct SetOp Rel
name|Builder
argument_list|<
name|RelNode
argument_list|>
name|bldr
init|=
operator|new
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
name|bldr
operator|.
name|add
argument_list|(
name|setOpLeftInput
argument_list|)
expr_stmt|;
name|bldr
operator|.
name|add
argument_list|(
name|setOpRightInput
argument_list|)
expr_stmt|;
name|SetOp
name|setOpRel
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|UNION
case|:
name|setOpRel
operator|=
operator|new
name|HiveUnion
argument_list|(
name|cluster
argument_list|,
name|TraitsUtil
operator|.
name|getDefaultTraitSet
argument_list|(
name|cluster
argument_list|)
argument_list|,
name|bldr
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTERSECT
case|:
name|setOpRel
operator|=
operator|new
name|HiveIntersect
argument_list|(
name|cluster
argument_list|,
name|TraitsUtil
operator|.
name|getDefaultTraitSet
argument_list|(
name|cluster
argument_list|)
argument_list|,
name|bldr
operator|.
name|build
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTERSECTALL
case|:
name|setOpRel
operator|=
operator|new
name|HiveIntersect
argument_list|(
name|cluster
argument_list|,
name|TraitsUtil
operator|.
name|getDefaultTraitSet
argument_list|(
name|cluster
argument_list|)
argument_list|,
name|bldr
operator|.
name|build
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXCEPT
case|:
name|setOpRel
operator|=
operator|new
name|HiveExcept
argument_list|(
name|cluster
argument_list|,
name|TraitsUtil
operator|.
name|getDefaultTraitSet
argument_list|(
name|cluster
argument_list|)
argument_list|,
name|bldr
operator|.
name|build
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXCEPTALL
case|:
name|setOpRel
operator|=
operator|new
name|HiveExcept
argument_list|(
name|cluster
argument_list|,
name|TraitsUtil
operator|.
name|getDefaultTraitSet
argument_list|(
name|cluster
argument_list|)
argument_list|,
name|bldr
operator|.
name|build
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UNSUPPORTED_SET_OPERATOR
operator|.
name|getMsg
argument_list|(
name|opcode
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|relToHiveRR
operator|.
name|put
argument_list|(
name|setOpRel
argument_list|,
name|setOpOutRR
argument_list|)
expr_stmt|;
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|setOpRel
argument_list|,
name|this
operator|.
name|buildHiveToCalciteColumnMap
argument_list|(
name|setOpOutRR
argument_list|,
name|setOpRel
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|setOpRel
return|;
block|}
specifier|private
name|RelNode
name|genJoinRelNode
parameter_list|(
name|RelNode
name|leftRel
parameter_list|,
name|String
name|leftTableAlias
parameter_list|,
name|RelNode
name|rightRel
parameter_list|,
name|String
name|rightTableAlias
parameter_list|,
name|JoinType
name|hiveJoinType
parameter_list|,
name|ASTNode
name|joinCond
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|leftRR
init|=
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|leftRel
argument_list|)
decl_stmt|;
name|RowResolver
name|rightRR
init|=
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|rightRel
argument_list|)
decl_stmt|;
comment|// 1. Construct ExpressionNodeDesc representing Join Condition
name|RexNode
name|calciteJoinCond
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|namedColumns
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|joinCond
operator|!=
literal|null
condition|)
block|{
name|JoinTypeCheckCtx
name|jCtx
init|=
operator|new
name|JoinTypeCheckCtx
argument_list|(
name|leftRR
argument_list|,
name|rightRR
argument_list|,
name|hiveJoinType
argument_list|)
decl_stmt|;
name|RowResolver
name|input
init|=
name|RowResolver
operator|.
name|getCombinedRR
argument_list|(
name|leftRR
argument_list|,
name|rightRR
argument_list|)
decl_stmt|;
comment|// named columns join
comment|// TODO: we can also do the same for semi join but it seems that other
comment|// DBMS does not support it yet.
if|if
condition|(
name|joinCond
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABCOLNAME
operator|&&
operator|!
name|hiveJoinType
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|LEFTSEMI
argument_list|)
condition|)
block|{
name|namedColumns
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
comment|// We will transform using clause and make it look like an on-clause.
comment|// So, lets generate a valid on-clause AST from using.
name|ASTNode
name|and
init|=
operator|(
name|ASTNode
operator|)
name|ParseDriver
operator|.
name|adaptor
operator|.
name|create
argument_list|(
name|HiveParser
operator|.
name|KW_AND
argument_list|,
literal|"and"
argument_list|)
decl_stmt|;
name|ASTNode
name|equal
init|=
literal|null
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
name|child
range|:
name|joinCond
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|String
name|columnName
init|=
operator|(
operator|(
name|ASTNode
operator|)
name|child
operator|)
operator|.
name|getText
argument_list|()
decl_stmt|;
comment|// dealing with views
if|if
condition|(
name|unparseTranslator
operator|!=
literal|null
operator|&&
name|unparseTranslator
operator|.
name|isEnabled
argument_list|()
condition|)
block|{
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
argument_list|)
expr_stmt|;
block|}
name|namedColumns
operator|.
name|add
argument_list|(
name|columnName
argument_list|)
expr_stmt|;
name|ASTNode
name|left
init|=
name|ASTBuilder
operator|.
name|qualifiedName
argument_list|(
name|leftTableAlias
argument_list|,
name|columnName
argument_list|)
decl_stmt|;
name|ASTNode
name|right
init|=
name|ASTBuilder
operator|.
name|qualifiedName
argument_list|(
name|rightTableAlias
argument_list|,
name|columnName
argument_list|)
decl_stmt|;
name|equal
operator|=
operator|(
name|ASTNode
operator|)
name|ParseDriver
operator|.
name|adaptor
operator|.
name|create
argument_list|(
name|HiveParser
operator|.
name|EQUAL
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
name|ParseDriver
operator|.
name|adaptor
operator|.
name|addChild
argument_list|(
name|equal
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|ParseDriver
operator|.
name|adaptor
operator|.
name|addChild
argument_list|(
name|equal
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|ParseDriver
operator|.
name|adaptor
operator|.
name|addChild
argument_list|(
name|and
argument_list|,
name|equal
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|joinCond
operator|=
name|count
operator|>
literal|1
condition|?
name|and
else|:
name|equal
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unparseTranslator
operator|!=
literal|null
operator|&&
name|unparseTranslator
operator|.
name|isEnabled
argument_list|()
condition|)
block|{
name|genAllExprNodeDesc
argument_list|(
name|joinCond
argument_list|,
name|input
argument_list|,
name|jCtx
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
name|exprNodes
init|=
name|JoinCondTypeCheckProcFactory
operator|.
name|genExprNode
argument_list|(
name|joinCond
argument_list|,
name|jCtx
argument_list|)
decl_stmt|;
if|if
condition|(
name|jCtx
operator|.
name|getError
argument_list|()
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|SemanticAnalyzer
operator|.
name|generateErrorMessage
argument_list|(
name|jCtx
operator|.
name|getErrorSrcNode
argument_list|()
argument_list|,
name|jCtx
operator|.
name|getError
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|ExprNodeDesc
name|joinCondnExprNode
init|=
name|exprNodes
operator|.
name|get
argument_list|(
name|joinCond
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputRels
init|=
operator|new
name|ArrayList
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
name|inputRels
operator|.
name|add
argument_list|(
name|leftRel
argument_list|)
expr_stmt|;
name|inputRels
operator|.
name|add
argument_list|(
name|rightRel
argument_list|)
expr_stmt|;
name|calciteJoinCond
operator|=
name|RexNodeConverter
operator|.
name|convert
argument_list|(
name|cluster
argument_list|,
name|joinCondnExprNode
argument_list|,
name|inputRels
argument_list|,
name|relToHiveRR
argument_list|,
name|relToHiveColNameCalcitePosMap
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|calciteJoinCond
operator|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// 2. Validate that join condition is legal (i.e no function refering to
comment|// both sides of join, only equi join)
comment|// TODO: Join filter handling (only supported for OJ by runtime or is it
comment|// supported for IJ as well)
comment|// 3. Construct Join Rel Node and RowResolver for the new Join Node
name|boolean
name|leftSemiJoin
init|=
literal|false
decl_stmt|;
name|JoinRelType
name|calciteJoinType
decl_stmt|;
switch|switch
condition|(
name|hiveJoinType
condition|)
block|{
case|case
name|LEFTOUTER
case|:
name|calciteJoinType
operator|=
name|JoinRelType
operator|.
name|LEFT
expr_stmt|;
break|break;
case|case
name|RIGHTOUTER
case|:
name|calciteJoinType
operator|=
name|JoinRelType
operator|.
name|RIGHT
expr_stmt|;
break|break;
case|case
name|FULLOUTER
case|:
name|calciteJoinType
operator|=
name|JoinRelType
operator|.
name|FULL
expr_stmt|;
break|break;
case|case
name|LEFTSEMI
case|:
name|calciteJoinType
operator|=
name|JoinRelType
operator|.
name|INNER
expr_stmt|;
name|leftSemiJoin
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|INNER
case|:
default|default:
name|calciteJoinType
operator|=
name|JoinRelType
operator|.
name|INNER
expr_stmt|;
break|break;
block|}
name|RelNode
name|topRel
init|=
literal|null
decl_stmt|;
name|RowResolver
name|topRR
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|leftSemiJoin
condition|)
block|{
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|sysFieldList
init|=
operator|new
name|ArrayList
argument_list|<
name|RelDataTypeField
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftJoinKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightJoinKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|RexNode
name|nonEquiConds
init|=
name|RelOptUtil
operator|.
name|splitJoinCondition
argument_list|(
name|sysFieldList
argument_list|,
name|leftRel
argument_list|,
name|rightRel
argument_list|,
name|calciteJoinCond
argument_list|,
name|leftJoinKeys
argument_list|,
name|rightJoinKeys
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|RelNode
index|[]
name|inputRels
init|=
operator|new
name|RelNode
index|[]
block|{
name|leftRel
block|,
name|rightRel
block|}
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|RexNode
name|remainingEquiCond
init|=
name|HiveCalciteUtil
operator|.
name|projectNonColumnEquiConditions
argument_list|(
name|HiveRelFactories
operator|.
name|HIVE_PROJECT_FACTORY
argument_list|,
name|inputRels
argument_list|,
name|leftJoinKeys
argument_list|,
name|rightJoinKeys
argument_list|,
literal|0
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|)
decl_stmt|;
comment|// Adjust right input fields in nonEquiConds if previous call modified the input
if|if
condition|(
name|inputRels
index|[
literal|0
index|]
operator|!=
name|leftRel
condition|)
block|{
name|nonEquiConds
operator|=
name|RexUtil
operator|.
name|shift
argument_list|(
name|nonEquiConds
argument_list|,
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|inputRels
index|[
literal|0
index|]
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|-
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|calciteJoinCond
operator|=
name|remainingEquiCond
operator|!=
literal|null
condition|?
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|remainingEquiCond
argument_list|,
name|nonEquiConds
argument_list|)
argument_list|,
literal|false
argument_list|)
else|:
name|nonEquiConds
expr_stmt|;
name|topRel
operator|=
name|HiveSemiJoin
operator|.
name|getSemiJoin
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRelNode
operator|.
name|CONVENTION
argument_list|)
argument_list|,
name|inputRels
index|[
literal|0
index|]
argument_list|,
name|inputRels
index|[
literal|1
index|]
argument_list|,
name|calciteJoinCond
argument_list|,
name|ImmutableIntList
operator|.
name|copyOf
argument_list|(
name|leftKeys
argument_list|)
argument_list|,
name|ImmutableIntList
operator|.
name|copyOf
argument_list|(
name|rightKeys
argument_list|)
argument_list|)
expr_stmt|;
comment|// Create join RR: we need to check whether we need to update left RR in case
comment|// previous call to projectNonColumnEquiConditions updated it
if|if
condition|(
name|inputRels
index|[
literal|0
index|]
operator|!=
name|leftRel
condition|)
block|{
name|RowResolver
name|newLeftRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|RowResolver
operator|.
name|add
argument_list|(
name|newLeftRR
argument_list|,
name|leftRR
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Duplicates detected when adding columns to RR: see previous message"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
init|;
name|i
operator|<
name|inputRels
index|[
literal|0
index|]
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ColumnInfo
name|oColInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
argument_list|,
name|TypeConverter
operator|.
name|convert
argument_list|(
name|inputRels
index|[
literal|0
index|]
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|newLeftRR
operator|.
name|put
argument_list|(
name|oColInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|oColInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|oColInfo
argument_list|)
expr_stmt|;
block|}
name|RowResolver
name|joinRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|RowResolver
operator|.
name|add
argument_list|(
name|joinRR
argument_list|,
name|newLeftRR
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Duplicates detected when adding columns to RR: see previous message"
argument_list|)
expr_stmt|;
block|}
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|topRel
argument_list|,
name|this
operator|.
name|buildHiveToCalciteColumnMap
argument_list|(
name|joinRR
argument_list|,
name|topRel
argument_list|)
argument_list|)
expr_stmt|;
name|relToHiveRR
operator|.
name|put
argument_list|(
name|topRel
argument_list|,
name|joinRR
argument_list|)
expr_stmt|;
comment|// Introduce top project operator to remove additional column(s) that have
comment|// been introduced
name|List
argument_list|<
name|RexNode
argument_list|>
name|topFields
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|topFieldNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|topFields
operator|.
name|add
argument_list|(
name|leftRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|topFieldNames
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|topRel
operator|=
name|HiveRelFactories
operator|.
name|HIVE_PROJECT_FACTORY
operator|.
name|createProject
argument_list|(
name|topRel
argument_list|,
name|topFields
argument_list|,
name|topFieldNames
argument_list|)
expr_stmt|;
block|}
name|topRR
operator|=
operator|new
name|RowResolver
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|RowResolver
operator|.
name|add
argument_list|(
name|topRR
argument_list|,
name|leftRR
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Duplicates detected when adding columns to RR: see previous message"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|topRel
operator|=
name|HiveJoin
operator|.
name|getJoin
argument_list|(
name|cluster
argument_list|,
name|leftRel
argument_list|,
name|rightRel
argument_list|,
name|calciteJoinCond
argument_list|,
name|calciteJoinType
argument_list|)
expr_stmt|;
name|topRR
operator|=
name|RowResolver
operator|.
name|getCombinedRR
argument_list|(
name|leftRR
argument_list|,
name|rightRR
argument_list|)
expr_stmt|;
if|if
condition|(
name|namedColumns
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|tableAliases
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|tableAliases
operator|.
name|add
argument_list|(
name|leftTableAlias
argument_list|)
expr_stmt|;
name|tableAliases
operator|.
name|add
argument_list|(
name|rightTableAlias
argument_list|)
expr_stmt|;
name|topRR
operator|.
name|setNamedJoinInfo
argument_list|(
operator|new
name|NamedJoinInfo
argument_list|(
name|tableAliases
argument_list|,
name|namedColumns
argument_list|,
name|hiveJoinType
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 4. Add new rel& its RR to the maps
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|topRel
argument_list|,
name|this
operator|.
name|buildHiveToCalciteColumnMap
argument_list|(
name|topRR
argument_list|,
name|topRel
argument_list|)
argument_list|)
expr_stmt|;
name|relToHiveRR
operator|.
name|put
argument_list|(
name|topRel
argument_list|,
name|topRR
argument_list|)
expr_stmt|;
return|return
name|topRel
return|;
block|}
comment|/**      * Generate Join Logical Plan Relnode by walking through the join AST.      *      * @param aliasToRel      *          Alias(Table/Relation alias) to RelNode; only read and not      *          written in to by this method      * @return      * @throws SemanticException      */
specifier|private
name|RelNode
name|genJoinLogicalPlan
parameter_list|(
name|ASTNode
name|joinParseTree
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RelNode
argument_list|>
name|aliasToRel
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RelNode
name|leftRel
init|=
literal|null
decl_stmt|;
name|RelNode
name|rightRel
init|=
literal|null
decl_stmt|;
name|JoinType
name|hiveJoinType
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|joinParseTree
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_UNIQUEJOIN
condition|)
block|{
name|String
name|msg
init|=
name|String
operator|.
name|format
argument_list|(
literal|"UNIQUE JOIN is currently not supported in CBO,"
operator|+
literal|" turn off cbo to use UNIQUE JOIN."
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
name|msg
argument_list|,
name|UnsupportedFeature
operator|.
name|Unique_join
argument_list|)
throw|;
block|}
comment|// 1. Determine Join Type
comment|// TODO: What about TOK_CROSSJOIN, TOK_MAPJOIN
switch|switch
condition|(
name|joinParseTree
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_LEFTOUTERJOIN
case|:
name|hiveJoinType
operator|=
name|JoinType
operator|.
name|LEFTOUTER
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_RIGHTOUTERJOIN
case|:
name|hiveJoinType
operator|=
name|JoinType
operator|.
name|RIGHTOUTER
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_FULLOUTERJOIN
case|:
name|hiveJoinType
operator|=
name|JoinType
operator|.
name|FULLOUTER
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_LEFTSEMIJOIN
case|:
name|hiveJoinType
operator|=
name|JoinType
operator|.
name|LEFTSEMI
expr_stmt|;
break|break;
default|default:
name|hiveJoinType
operator|=
name|JoinType
operator|.
name|INNER
expr_stmt|;
break|break;
block|}
comment|// 2. Get Left Table Alias
name|ASTNode
name|left
init|=
operator|(
name|ASTNode
operator|)
name|joinParseTree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|leftTableAlias
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|(
name|left
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABREF
operator|)
operator|||
operator|(
name|left
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY
operator|)
operator|||
operator|(
name|left
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PTBLFUNCTION
operator|)
condition|)
block|{
name|String
name|tableName
init|=
name|SemanticAnalyzer
operator|.
name|getUnescapedUnqualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|left
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|leftTableAlias
operator|=
name|left
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|?
name|tableName
else|:
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|left
operator|.
name|getChild
argument_list|(
name|left
operator|.
name|getChildCount
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
comment|// ptf node form is: ^(TOK_PTBLFUNCTION $name $alias?
comment|// partitionTableFunctionSource partitioningSpec? expression*)
comment|// guranteed to have an lias here: check done in processJoin
name|leftTableAlias
operator|=
operator|(
name|left
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PTBLFUNCTION
operator|)
condition|?
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|left
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
else|:
name|leftTableAlias
expr_stmt|;
name|leftRel
operator|=
name|aliasToRel
operator|.
name|get
argument_list|(
name|leftTableAlias
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SemanticAnalyzer
operator|.
name|isJoinToken
argument_list|(
name|left
argument_list|)
condition|)
block|{
name|leftRel
operator|=
name|genJoinLogicalPlan
argument_list|(
name|left
argument_list|,
name|aliasToRel
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|left
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_LATERAL_VIEW
condition|)
block|{
name|leftRel
operator|=
name|genLateralViewPlans
argument_list|(
name|left
argument_list|,
name|aliasToRel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
operator|(
literal|false
operator|)
assert|;
block|}
comment|// 3. Get Right Table Alias
name|ASTNode
name|right
init|=
operator|(
name|ASTNode
operator|)
name|joinParseTree
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|String
name|rightTableAlias
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|(
name|right
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABREF
operator|)
operator|||
operator|(
name|right
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY
operator|)
operator|||
operator|(
name|right
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PTBLFUNCTION
operator|)
condition|)
block|{
name|String
name|tableName
init|=
name|SemanticAnalyzer
operator|.
name|getUnescapedUnqualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|right
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|rightTableAlias
operator|=
name|right
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|?
name|tableName
else|:
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|right
operator|.
name|getChild
argument_list|(
name|right
operator|.
name|getChildCount
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
comment|// ptf node form is: ^(TOK_PTBLFUNCTION $name $alias?
comment|// partitionTableFunctionSource partitioningSpec? expression*)
comment|// guranteed to have an lias here: check done in processJoin
name|rightTableAlias
operator|=
operator|(
name|right
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PTBLFUNCTION
operator|)
condition|?
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|right
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
else|:
name|rightTableAlias
expr_stmt|;
name|rightRel
operator|=
name|aliasToRel
operator|.
name|get
argument_list|(
name|rightTableAlias
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|right
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_LATERAL_VIEW
condition|)
block|{
name|rightRel
operator|=
name|genLateralViewPlans
argument_list|(
name|right
argument_list|,
name|aliasToRel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
operator|(
literal|false
operator|)
assert|;
block|}
comment|// 4. Get Join Condn
name|ASTNode
name|joinCond
init|=
operator|(
name|ASTNode
operator|)
name|joinParseTree
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
decl_stmt|;
comment|// 5. Create Join rel
return|return
name|genJoinRelNode
argument_list|(
name|leftRel
argument_list|,
name|leftTableAlias
argument_list|,
name|rightRel
argument_list|,
name|rightTableAlias
argument_list|,
name|hiveJoinType
argument_list|,
name|joinCond
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|genTableLogicalPlan
parameter_list|(
name|String
name|tableAlias
parameter_list|,
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|rr
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|RelNode
name|tableRel
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// 1. If the table has a Sample specified, bail from Calcite path.
comment|// 2. if returnpath is on and hivetestmode is on bail
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getTabSample
argument_list|(
name|tableAlias
argument_list|)
operator|!=
literal|null
operator|||
name|getNameToSplitSampleMap
argument_list|()
operator|.
name|containsKey
argument_list|(
name|tableAlias
argument_list|)
operator|||
operator|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_CBO_RETPATH_HIVEOP
argument_list|)
operator|)
operator|&&
operator|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODE
argument_list|)
operator|)
condition|)
block|{
name|String
name|msg
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Table Sample specified for %s."
operator|+
literal|" Currently we don't support Table Sample clauses in CBO,"
operator|+
literal|" turn off cbo for queries on tableSamples."
argument_list|,
name|tableAlias
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
name|msg
argument_list|,
name|UnsupportedFeature
operator|.
name|Table_sample_clauses
argument_list|)
throw|;
block|}
comment|// 2. Get Table Metadata
name|Table
name|tabMetaData
init|=
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|tableAlias
argument_list|)
decl_stmt|;
comment|// 3. Get Table Logical Schema (Row Type)
comment|// NOTE: Table logical schema = Non Partition Cols + Partition Cols +
comment|// Virtual Cols
comment|// 3.1 Add Column info for non partion cols (Object Inspector fields)
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
name|StructObjectInspector
name|rowObjectInspector
init|=
operator|(
name|StructObjectInspector
operator|)
name|tabMetaData
operator|.
name|getDeserializer
argument_list|()
operator|.
name|getObjectInspector
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|fields
init|=
name|rowObjectInspector
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
name|ColumnInfo
name|colInfo
decl_stmt|;
name|String
name|colName
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|cInfoLst
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|colName
operator|=
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldName
argument_list|()
expr_stmt|;
name|colInfo
operator|=
operator|new
name|ColumnInfo
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldName
argument_list|()
argument_list|,
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
argument_list|,
name|tableAlias
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|colInfo
operator|.
name|setSkewedCol
argument_list|(
operator|(
name|SemanticAnalyzer
operator|.
name|isSkewedCol
argument_list|(
name|tableAlias
argument_list|,
name|qb
argument_list|,
name|colName
argument_list|)
operator|)
condition|?
literal|true
else|:
literal|false
argument_list|)
expr_stmt|;
name|rr
operator|.
name|put
argument_list|(
name|tableAlias
argument_list|,
name|colName
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|cInfoLst
operator|.
name|add
argument_list|(
name|colInfo
argument_list|)
expr_stmt|;
block|}
comment|// TODO: Fix this
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|nonPartitionColumns
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|(
name|cInfoLst
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|partitionColumns
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
comment|// 3.2 Add column info corresponding to partition columns
for|for
control|(
name|FieldSchema
name|part_col
range|:
name|tabMetaData
operator|.
name|getPartCols
argument_list|()
control|)
block|{
name|colName
operator|=
name|part_col
operator|.
name|getName
argument_list|()
expr_stmt|;
name|colInfo
operator|=
operator|new
name|ColumnInfo
argument_list|(
name|colName
argument_list|,
name|TypeInfoFactory
operator|.
name|getPrimitiveTypeInfo
argument_list|(
name|part_col
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|,
name|tableAlias
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|rr
operator|.
name|put
argument_list|(
name|tableAlias
argument_list|,
name|colName
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|cInfoLst
operator|.
name|add
argument_list|(
name|colInfo
argument_list|)
expr_stmt|;
name|partitionColumns
operator|.
name|add
argument_list|(
name|colInfo
argument_list|)
expr_stmt|;
block|}
specifier|final
name|TableType
name|tableType
init|=
name|obtainTableType
argument_list|(
name|tabMetaData
argument_list|)
decl_stmt|;
comment|// 3.3 Add column info corresponding to virtual columns
name|List
argument_list|<
name|VirtualColumn
argument_list|>
name|virtualCols
init|=
operator|new
name|ArrayList
argument_list|<
name|VirtualColumn
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|tableType
operator|==
name|TableType
operator|.
name|NATIVE
condition|)
block|{
name|Iterator
argument_list|<
name|VirtualColumn
argument_list|>
name|vcs
init|=
name|VirtualColumn
operator|.
name|getRegistry
argument_list|(
name|conf
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|vcs
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|VirtualColumn
name|vc
init|=
name|vcs
operator|.
name|next
argument_list|()
decl_stmt|;
name|colInfo
operator|=
operator|new
name|ColumnInfo
argument_list|(
name|vc
operator|.
name|getName
argument_list|()
argument_list|,
name|vc
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|tableAlias
argument_list|,
literal|true
argument_list|,
name|vc
operator|.
name|getIsHidden
argument_list|()
argument_list|)
expr_stmt|;
name|rr
operator|.
name|put
argument_list|(
name|tableAlias
argument_list|,
name|vc
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|cInfoLst
operator|.
name|add
argument_list|(
name|colInfo
argument_list|)
expr_stmt|;
name|virtualCols
operator|.
name|add
argument_list|(
name|vc
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 4. Build operator
name|RelOptHiveTable
name|optTable
decl_stmt|;
if|if
condition|(
name|tableType
operator|==
name|TableType
operator|.
name|DRUID
operator|||
operator|(
name|tableType
operator|==
name|TableType
operator|.
name|JDBC
operator|&&
name|tabMetaData
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|JDBC_TABLE
argument_list|)
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// Create case sensitive columns list
name|List
argument_list|<
name|String
argument_list|>
name|originalColumnNames
init|=
operator|(
operator|(
name|StandardStructObjectInspector
operator|)
name|rowObjectInspector
operator|)
operator|.
name|getOriginalColumnNames
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ColumnInfo
argument_list|>
name|cIList
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|(
name|originalColumnNames
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rr
operator|.
name|getColumnInfos
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|cIList
operator|.
name|add
argument_list|(
operator|new
name|ColumnInfo
argument_list|(
name|originalColumnNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|rr
operator|.
name|getColumnInfos
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|tableAlias
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Build row type from field<type, name>
name|RelDataType
name|rowType
init|=
name|TypeConverter
operator|.
name|getType
argument_list|(
name|cluster
argument_list|,
name|cIList
argument_list|)
decl_stmt|;
comment|// Build RelOptAbstractTable
name|List
argument_list|<
name|String
argument_list|>
name|fullyQualifiedTabName
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|tabMetaData
operator|.
name|getDbName
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|tabMetaData
operator|.
name|getDbName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fullyQualifiedTabName
operator|.
name|add
argument_list|(
name|tabMetaData
operator|.
name|getDbName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fullyQualifiedTabName
operator|.
name|add
argument_list|(
name|tabMetaData
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|tableType
operator|==
name|TableType
operator|.
name|DRUID
condition|)
block|{
comment|// Build Druid query
name|String
name|address
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_DRUID_BROKER_DEFAULT_ADDRESS
argument_list|)
decl_stmt|;
name|String
name|dataSource
init|=
name|tabMetaData
operator|.
name|getParameters
argument_list|()
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|DRUID_DATA_SOURCE
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|metrics
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RelDataTypeFactory
name|dtFactory
init|=
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataType
argument_list|>
name|druidColTypes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|druidColNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|//@TODO FIX this, we actually do not need this anymore,
comment|// in addition to that Druid allow numeric dimensions now so this check is not accurate
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|rowType
operator|.
name|getFieldList
argument_list|()
control|)
block|{
if|if
condition|(
name|DruidTable
operator|.
name|DEFAULT_TIMESTAMP_COLUMN
operator|.
name|equals
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
comment|// Druid's time column is always not null.
name|druidColTypes
operator|.
name|add
argument_list|(
name|dtFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|druidColTypes
operator|.
name|add
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|druidColNames
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|DruidTable
operator|.
name|DEFAULT_TIMESTAMP_COLUMN
argument_list|)
condition|)
block|{
comment|// timestamp
continue|continue;
block|}
if|if
condition|(
name|field
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|VARCHAR
condition|)
block|{
comment|// dimension
continue|continue;
block|}
name|metrics
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Interval
argument_list|>
name|intervals
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|DruidTable
operator|.
name|DEFAULT_INTERVAL
argument_list|)
decl_stmt|;
name|rowType
operator|=
name|dtFactory
operator|.
name|createStructType
argument_list|(
name|druidColTypes
argument_list|,
name|druidColNames
argument_list|)
expr_stmt|;
name|DruidTable
name|druidTable
init|=
operator|new
name|DruidTable
argument_list|(
operator|new
name|DruidSchema
argument_list|(
name|address
argument_list|,
name|address
argument_list|,
literal|false
argument_list|)
argument_list|,
name|dataSource
argument_list|,
name|RelDataTypeImpl
operator|.
name|proto
argument_list|(
name|rowType
argument_list|)
argument_list|,
name|metrics
argument_list|,
name|DruidTable
operator|.
name|DEFAULT_TIMESTAMP_COLUMN
argument_list|,
name|intervals
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|optTable
operator|=
operator|new
name|RelOptHiveTable
argument_list|(
name|relOptSchema
argument_list|,
name|relOptSchema
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
name|fullyQualifiedTabName
argument_list|,
name|rowType
argument_list|,
name|tabMetaData
argument_list|,
name|nonPartitionColumns
argument_list|,
name|partitionColumns
argument_list|,
name|virtualCols
argument_list|,
name|conf
argument_list|,
name|partitionCache
argument_list|,
name|colStatsCache
argument_list|,
name|noColsMissingStats
argument_list|)
expr_stmt|;
specifier|final
name|TableScan
name|scan
init|=
operator|new
name|HiveTableScan
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRelNode
operator|.
name|CONVENTION
argument_list|)
argument_list|,
name|optTable
argument_list|,
literal|null
operator|==
name|tableAlias
condition|?
name|tabMetaData
operator|.
name|getTableName
argument_list|()
else|:
name|tableAlias
argument_list|,
name|getAliasId
argument_list|(
name|tableAlias
argument_list|,
name|qb
argument_list|)
argument_list|,
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_CBO_RETPATH_HIVEOP
argument_list|)
argument_list|,
name|qb
operator|.
name|isInsideView
argument_list|()
operator|||
name|qb
operator|.
name|getAliasInsideView
argument_list|()
operator|.
name|contains
argument_list|(
name|tableAlias
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|tableRel
operator|=
name|DruidQuery
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|BindableConvention
operator|.
name|INSTANCE
argument_list|)
argument_list|,
name|optTable
argument_list|,
name|druidTable
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|scan
argument_list|)
argument_list|,
name|DruidSqlOperatorConverter
operator|.
name|getDefaultMap
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|optTable
operator|=
operator|new
name|RelOptHiveTable
argument_list|(
name|relOptSchema
argument_list|,
name|relOptSchema
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
name|fullyQualifiedTabName
argument_list|,
name|rowType
argument_list|,
name|tabMetaData
argument_list|,
name|nonPartitionColumns
argument_list|,
name|partitionColumns
argument_list|,
name|virtualCols
argument_list|,
name|conf
argument_list|,
name|partitionCache
argument_list|,
name|colStatsCache
argument_list|,
name|noColsMissingStats
argument_list|)
expr_stmt|;
specifier|final
name|HiveTableScan
name|hts
init|=
operator|new
name|HiveTableScan
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRelNode
operator|.
name|CONVENTION
argument_list|)
argument_list|,
name|optTable
argument_list|,
literal|null
operator|==
name|tableAlias
condition|?
name|tabMetaData
operator|.
name|getTableName
argument_list|()
else|:
name|tableAlias
argument_list|,
name|getAliasId
argument_list|(
name|tableAlias
argument_list|,
name|qb
argument_list|)
argument_list|,
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_CBO_RETPATH_HIVEOP
argument_list|)
argument_list|,
name|qb
operator|.
name|isInsideView
argument_list|()
operator|||
name|qb
operator|.
name|getAliasInsideView
argument_list|()
operator|.
name|contains
argument_list|(
name|tableAlias
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|String
name|dataBaseType
init|=
name|tabMetaData
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|JDBC_DATABASE_TYPE
argument_list|)
decl_stmt|;
specifier|final
name|String
name|url
init|=
name|tabMetaData
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|JDBC_URL
argument_list|)
decl_stmt|;
specifier|final
name|String
name|driver
init|=
name|tabMetaData
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|JDBC_DRIVER
argument_list|)
decl_stmt|;
specifier|final
name|String
name|user
init|=
name|tabMetaData
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|JDBC_USERNAME
argument_list|)
decl_stmt|;
comment|//final String query = tabMetaData.getProperty("hive.sql.query");
name|String
name|pswd
init|=
name|tabMetaData
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|JDBC_PASSWORD
argument_list|)
decl_stmt|;
if|if
condition|(
name|pswd
operator|==
literal|null
condition|)
block|{
name|String
name|keystore
init|=
name|tabMetaData
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|JDBC_KEYSTORE
argument_list|)
decl_stmt|;
name|String
name|key
init|=
name|tabMetaData
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|JDBC_KEY
argument_list|)
decl_stmt|;
name|pswd
operator|=
name|Utilities
operator|.
name|getPasswdFromKeystore
argument_list|(
name|keystore
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
specifier|final
name|String
name|tableName
init|=
name|tabMetaData
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|JDBC_TABLE
argument_list|)
decl_stmt|;
name|DataSource
name|ds
init|=
name|JdbcSchema
operator|.
name|dataSource
argument_list|(
name|url
argument_list|,
name|driver
argument_list|,
name|user
argument_list|,
name|pswd
argument_list|)
decl_stmt|;
name|SqlDialect
name|jdbcDialect
init|=
name|JdbcSchema
operator|.
name|createDialect
argument_list|(
name|SqlDialectFactoryImpl
operator|.
name|INSTANCE
argument_list|,
name|ds
argument_list|)
decl_stmt|;
name|JdbcConvention
name|jc
init|=
name|JdbcConvention
operator|.
name|of
argument_list|(
name|jdbcDialect
argument_list|,
literal|null
argument_list|,
name|dataBaseType
argument_list|)
decl_stmt|;
name|JdbcSchema
name|schema
init|=
operator|new
name|JdbcSchema
argument_list|(
name|ds
argument_list|,
name|jc
operator|.
name|dialect
argument_list|,
name|jc
argument_list|,
literal|null
comment|/*catalog */
argument_list|,
literal|null
comment|/*schema */
argument_list|)
decl_stmt|;
name|JdbcTable
name|jt
init|=
operator|(
name|JdbcTable
operator|)
name|schema
operator|.
name|getTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|jt
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Table "
operator|+
name|tableName
operator|+
literal|" was not found in the database"
argument_list|)
throw|;
block|}
name|JdbcHiveTableScan
name|jdbcTableRel
init|=
operator|new
name|JdbcHiveTableScan
argument_list|(
name|cluster
argument_list|,
name|optTable
argument_list|,
name|jt
argument_list|,
name|jc
argument_list|,
name|hts
argument_list|)
decl_stmt|;
name|tableRel
operator|=
operator|new
name|HiveJdbcConverter
argument_list|(
name|cluster
argument_list|,
name|jdbcTableRel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|HiveRelNode
operator|.
name|CONVENTION
argument_list|)
argument_list|,
name|jdbcTableRel
argument_list|,
name|jc
argument_list|,
name|url
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Build row type from field<type, name>
name|RelDataType
name|rowType
init|=
name|inferNotNullableColumns
argument_list|(
name|tabMetaData
argument_list|,
name|TypeConverter
operator|.
name|getType
argument_list|(
name|cluster
argument_list|,
name|rr
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
comment|// Build RelOptAbstractTable
name|List
argument_list|<
name|String
argument_list|>
name|fullyQualifiedTabName
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|tabMetaData
operator|.
name|getDbName
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|tabMetaData
operator|.
name|getDbName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fullyQualifiedTabName
operator|.
name|add
argument_list|(
name|tabMetaData
operator|.
name|getDbName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fullyQualifiedTabName
operator|.
name|add
argument_list|(
name|tabMetaData
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
name|optTable
operator|=
operator|new
name|RelOptHiveTable
argument_list|(
name|relOptSchema
argument_list|,
name|relOptSchema
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
name|fullyQualifiedTabName
argument_list|,
name|rowType
argument_list|,
name|tabMetaData
argument_list|,
name|nonPartitionColumns
argument_list|,
name|partitionColumns
argument_list|,
name|virtualCols
argument_list|,
name|conf
argument_list|,
name|partitionCache
argument_list|,
name|colStatsCache
argument_list|,
name|noColsMissingStats
argument_list|)
expr_stmt|;
comment|// Build Hive Table Scan Rel
name|tableRel
operator|=
operator|new
name|HiveTableScan
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRelNode
operator|.
name|CONVENTION
argument_list|)
argument_list|,
name|optTable
argument_list|,
literal|null
operator|==
name|tableAlias
condition|?
name|tabMetaData
operator|.
name|getTableName
argument_list|()
else|:
name|tableAlias
argument_list|,
name|getAliasId
argument_list|(
name|tableAlias
argument_list|,
name|qb
argument_list|)
argument_list|,
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_CBO_RETPATH_HIVEOP
argument_list|)
argument_list|,
name|qb
operator|.
name|isInsideView
argument_list|()
operator|||
name|qb
operator|.
name|getAliasInsideView
argument_list|()
operator|.
name|contains
argument_list|(
name|tableAlias
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|optTable
operator|.
name|getReferentialConstraints
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|profilesCBO
operator|.
name|add
argument_list|(
name|ExtendedCBOProfile
operator|.
name|REFERENTIAL_CONSTRAINTS
argument_list|)
expr_stmt|;
block|}
comment|// 6. Add Schema(RR) to RelNode-Schema map
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|hiveToCalciteColMap
init|=
name|buildHiveToCalciteColumnMap
argument_list|(
name|rr
argument_list|,
name|tableRel
argument_list|)
decl_stmt|;
name|relToHiveRR
operator|.
name|put
argument_list|(
name|tableRel
argument_list|,
name|rr
argument_list|)
expr_stmt|;
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|tableRel
argument_list|,
name|hiveToCalciteColMap
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|SemanticException
condition|)
block|{
throw|throw
operator|(
name|SemanticException
operator|)
name|e
throw|;
block|}
else|else
block|{
throw|throw
operator|(
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
operator|)
throw|;
block|}
block|}
return|return
name|tableRel
return|;
block|}
specifier|private
name|RelDataType
name|inferNotNullableColumns
parameter_list|(
name|Table
name|tabMetaData
parameter_list|,
name|RelDataType
name|rowType
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// Retrieve not null constraints
specifier|final
name|NotNullConstraint
name|nnc
init|=
name|Hive
operator|.
name|get
argument_list|()
operator|.
name|getReliableNotNullConstraints
argument_list|(
name|tabMetaData
operator|.
name|getDbName
argument_list|()
argument_list|,
name|tabMetaData
operator|.
name|getTableName
argument_list|()
argument_list|)
decl_stmt|;
comment|// Retrieve primary key constraints (cannot be null)
specifier|final
name|PrimaryKeyInfo
name|pkc
init|=
name|Hive
operator|.
name|get
argument_list|()
operator|.
name|getReliablePrimaryKeys
argument_list|(
name|tabMetaData
operator|.
name|getDbName
argument_list|()
argument_list|,
name|tabMetaData
operator|.
name|getTableName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|nnc
operator|.
name|getNotNullConstraints
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|pkc
operator|.
name|getColNames
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|rowType
return|;
block|}
comment|// Build the bitset with not null columns
name|ImmutableBitSet
operator|.
name|Builder
name|builder
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|nnCol
range|:
name|nnc
operator|.
name|getNotNullConstraints
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|int
name|nnPos
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rowType
operator|.
name|getFieldNames
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rowType
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|equals
argument_list|(
name|nnCol
argument_list|)
condition|)
block|{
name|nnPos
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|nnPos
operator|==
operator|-
literal|1
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Column for not null constraint definition "
operator|+
name|nnCol
operator|+
literal|" not found"
argument_list|)
expr_stmt|;
return|return
name|rowType
return|;
block|}
name|builder
operator|.
name|set
argument_list|(
name|nnPos
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|pkCol
range|:
name|pkc
operator|.
name|getColNames
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|int
name|pkPos
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rowType
operator|.
name|getFieldNames
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rowType
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|equals
argument_list|(
name|pkCol
argument_list|)
condition|)
block|{
name|pkPos
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pkPos
operator|==
operator|-
literal|1
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Column for not null constraint definition "
operator|+
name|pkCol
operator|+
literal|" not found"
argument_list|)
expr_stmt|;
return|return
name|rowType
return|;
block|}
name|builder
operator|.
name|set
argument_list|(
name|pkPos
argument_list|)
expr_stmt|;
block|}
name|ImmutableBitSet
name|bitSet
init|=
name|builder
operator|.
name|build
argument_list|()
decl_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RelDataTypeFactory
name|dtFactory
init|=
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataType
argument_list|>
name|fieldTypes
init|=
operator|new
name|LinkedList
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
operator|new
name|LinkedList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|rdtf
range|:
name|rowType
operator|.
name|getFieldList
argument_list|()
control|)
block|{
if|if
condition|(
name|bitSet
operator|.
name|indexOf
argument_list|(
name|rdtf
operator|.
name|getIndex
argument_list|()
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|fieldTypes
operator|.
name|add
argument_list|(
name|dtFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|rdtf
operator|.
name|getType
argument_list|()
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fieldTypes
operator|.
name|add
argument_list|(
name|rdtf
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fieldNames
operator|.
name|add
argument_list|(
name|rdtf
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|dtFactory
operator|.
name|createStructType
argument_list|(
name|fieldTypes
argument_list|,
name|fieldNames
argument_list|)
return|;
block|}
specifier|private
name|TableType
name|obtainTableType
parameter_list|(
name|Table
name|tabMetaData
parameter_list|)
block|{
if|if
condition|(
name|tabMetaData
operator|.
name|getStorageHandler
argument_list|()
operator|!=
literal|null
condition|)
block|{
specifier|final
name|String
name|storageHandlerStr
init|=
name|tabMetaData
operator|.
name|getStorageHandler
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|storageHandlerStr
operator|.
name|equals
argument_list|(
name|Constants
operator|.
name|DRUID_HIVE_STORAGE_HANDLER_ID
argument_list|)
condition|)
block|{
return|return
name|TableType
operator|.
name|DRUID
return|;
block|}
if|if
condition|(
name|storageHandlerStr
operator|.
name|equals
argument_list|(
name|Constants
operator|.
name|JDBC_HIVE_STORAGE_HANDLER_ID
argument_list|)
condition|)
block|{
return|return
name|TableType
operator|.
name|JDBC
return|;
block|}
block|}
return|return
name|TableType
operator|.
name|NATIVE
return|;
block|}
specifier|private
name|RelNode
name|genFilterRelNode
parameter_list|(
name|ASTNode
name|filterExpr
parameter_list|,
name|RelNode
name|srcRel
parameter_list|,
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|outerNameToPosMap
parameter_list|,
name|RowResolver
name|outerRR
parameter_list|,
name|boolean
name|useCaching
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ExprNodeDesc
name|filterCondn
init|=
name|genExprNodeDesc
argument_list|(
name|filterExpr
argument_list|,
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
argument_list|,
name|outerRR
argument_list|,
literal|null
argument_list|,
name|useCaching
argument_list|)
decl_stmt|;
if|if
condition|(
name|filterCondn
operator|instanceof
name|ExprNodeConstantDesc
operator|&&
operator|!
name|filterCondn
operator|.
name|getTypeString
argument_list|()
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|BOOLEAN_TYPE_NAME
argument_list|)
condition|)
block|{
comment|// queries like select * from t1 where 'foo';
comment|// Calcite's rule PushFilterThroughProject chokes on it. Arguably, we
comment|// can insert a cast to
comment|// boolean in such cases, but since Postgres, Oracle and MS SQL server
comment|// fail on compile time
comment|// for such queries, its an arcane corner case, not worth of adding that
comment|// complexity.
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
literal|"Filter expression with non-boolean return type."
argument_list|,
name|UnsupportedFeature
operator|.
name|Filter_expression_with_non_boolean_return_type
argument_list|)
throw|;
block|}
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|hiveColNameCalcitePosMap
init|=
name|this
operator|.
name|relToHiveColNameCalcitePosMap
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
name|RexNode
name|convertedFilterExpr
init|=
operator|new
name|RexNodeConverter
argument_list|(
name|cluster
argument_list|,
name|srcRel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|outerNameToPosMap
argument_list|,
name|hiveColNameCalcitePosMap
argument_list|,
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
argument_list|,
name|outerRR
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
name|subqueryId
argument_list|)
operator|.
name|convert
argument_list|(
name|filterCondn
argument_list|)
decl_stmt|;
name|RexNode
name|factoredFilterExpr
init|=
name|RexUtil
operator|.
name|pullFactors
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|convertedFilterExpr
argument_list|)
decl_stmt|;
name|RelNode
name|filterRel
init|=
operator|new
name|HiveFilter
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRelNode
operator|.
name|CONVENTION
argument_list|)
argument_list|,
name|srcRel
argument_list|,
name|factoredFilterExpr
argument_list|)
decl_stmt|;
name|this
operator|.
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|filterRel
argument_list|,
name|hiveColNameCalcitePosMap
argument_list|)
expr_stmt|;
name|relToHiveRR
operator|.
name|put
argument_list|(
name|filterRel
argument_list|,
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
argument_list|)
expr_stmt|;
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|filterRel
argument_list|,
name|hiveColNameCalcitePosMap
argument_list|)
expr_stmt|;
return|return
name|filterRel
return|;
block|}
specifier|private
name|void
name|subqueryRestrictionCheck
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|searchCond
parameter_list|,
name|RelNode
name|srcRel
parameter_list|,
name|boolean
name|forHavingClause
parameter_list|,
name|Set
argument_list|<
name|ASTNode
argument_list|>
name|corrScalarQueries
parameter_list|,
name|Set
argument_list|<
name|ASTNode
argument_list|>
name|scalarQueriesWithAggNoWinNoGby
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|ASTNode
argument_list|>
name|subQueriesInOriginalTree
init|=
name|SubQueryUtils
operator|.
name|findSubQueries
argument_list|(
name|searchCond
argument_list|)
decl_stmt|;
name|ASTNode
name|clonedSearchCond
init|=
operator|(
name|ASTNode
operator|)
name|SubQueryUtils
operator|.
name|adaptor
operator|.
name|dupTree
argument_list|(
name|searchCond
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|subQueries
init|=
name|SubQueryUtils
operator|.
name|findSubQueries
argument_list|(
name|clonedSearchCond
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subQueriesInOriginalTree
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|//we do not care about the transformation or rewriting of AST
comment|// which following statement does
comment|// we only care about the restriction checks they perform.
comment|// We plan to get rid of these restrictions later
name|int
name|sqIdx
init|=
name|qb
operator|.
name|incrNumSubQueryPredicates
argument_list|()
decl_stmt|;
name|ASTNode
name|originalSubQueryAST
init|=
name|subQueriesInOriginalTree
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ASTNode
name|subQueryAST
init|=
name|subQueries
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|//SubQueryUtils.rewriteParentQueryWhere(clonedSearchCond, subQueryAST);
name|Boolean
name|orInSubquery
init|=
operator|new
name|Boolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|Integer
name|subqueryCount
init|=
operator|new
name|Integer
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ObjectPair
argument_list|<
name|Boolean
argument_list|,
name|Integer
argument_list|>
name|subqInfo
init|=
operator|new
name|ObjectPair
argument_list|<
name|Boolean
argument_list|,
name|Integer
argument_list|>
argument_list|(
literal|false
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ASTNode
name|outerQueryExpr
init|=
operator|(
name|ASTNode
operator|)
name|subQueryAST
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|outerQueryExpr
operator|!=
literal|null
operator|&&
name|outerQueryExpr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY_EXPR
condition|)
block|{
throw|throw
operator|new
name|CalciteSubquerySemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UNSUPPORTED_SUBQUERY_EXPRESSION
operator|.
name|getMsg
argument_list|(
name|outerQueryExpr
argument_list|,
literal|"IN/NOT IN subqueries are not allowed in LHS"
argument_list|)
argument_list|)
throw|;
block|}
name|QBSubQuery
name|subQuery
init|=
name|SubQueryUtils
operator|.
name|buildSubQuery
argument_list|(
name|qb
operator|.
name|getId
argument_list|()
argument_list|,
name|sqIdx
argument_list|,
name|subQueryAST
argument_list|,
name|originalSubQueryAST
argument_list|,
name|ctx
argument_list|)
decl_stmt|;
name|RowResolver
name|inputRR
init|=
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
name|String
name|havingInputAlias
init|=
literal|null
decl_stmt|;
name|boolean
index|[]
name|subqueryConfig
init|=
block|{
literal|false
block|,
literal|false
block|}
decl_stmt|;
name|subQuery
operator|.
name|subqueryRestrictionsCheck
argument_list|(
name|inputRR
argument_list|,
name|forHavingClause
argument_list|,
name|havingInputAlias
argument_list|,
name|subqueryConfig
argument_list|)
expr_stmt|;
if|if
condition|(
name|subqueryConfig
index|[
literal|0
index|]
condition|)
block|{
name|corrScalarQueries
operator|.
name|add
argument_list|(
name|originalSubQueryAST
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|subqueryConfig
index|[
literal|1
index|]
condition|)
block|{
name|scalarQueriesWithAggNoWinNoGby
operator|.
name|add
argument_list|(
name|originalSubQueryAST
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|RelNode
name|genLateralViewPlans
parameter_list|(
name|ASTNode
name|lateralView
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RelNode
argument_list|>
name|aliasToRel
parameter_list|)
throws|throws
name|SemanticException
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|this
operator|.
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeFactory
name|dtFactory
init|=
name|this
operator|.
name|cluster
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|String
name|inlineFunctionName
init|=
name|GenericUDTFInline
operator|.
name|class
operator|.
name|getAnnotation
argument_list|(
name|Description
operator|.
name|class
argument_list|)
operator|.
name|name
argument_list|()
decl_stmt|;
name|int
name|numChildren
init|=
name|lateralView
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|numChildren
operator|==
literal|2
operator|)
assert|;
comment|// 1) Obtain input and all related data structures
name|ASTNode
name|next
init|=
operator|(
name|ASTNode
operator|)
name|lateralView
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|RelNode
name|inputRel
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|next
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABREF
case|:
case|case
name|HiveParser
operator|.
name|TOK_SUBQUERY
case|:
case|case
name|HiveParser
operator|.
name|TOK_PTBLFUNCTION
case|:
name|String
name|inputTableName
init|=
name|SemanticAnalyzer
operator|.
name|getUnescapedUnqualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|next
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|String
name|inputTableAlias
decl_stmt|;
if|if
condition|(
name|next
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PTBLFUNCTION
condition|)
block|{
comment|// ptf node form is: ^(TOK_PTBLFUNCTION $name $alias?
comment|// partitionTableFunctionSource partitioningSpec? expression*)
comment|// ptf node guaranteed to have an alias here
name|inputTableAlias
operator|=
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|next
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inputTableAlias
operator|=
name|next
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|?
name|inputTableName
else|:
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|next
operator|.
name|getChild
argument_list|(
name|next
operator|.
name|getChildCount
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|inputRel
operator|=
name|aliasToRel
operator|.
name|get
argument_list|(
name|inputTableAlias
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_LATERAL_VIEW
case|:
name|inputRel
operator|=
name|genLateralViewPlans
argument_list|(
name|next
argument_list|,
name|aliasToRel
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|LATERAL_VIEW_INVALID_CHILD
operator|.
name|getMsg
argument_list|(
name|lateralView
argument_list|)
argument_list|)
throw|;
block|}
comment|// Input row resolver
name|RowResolver
name|inputRR
init|=
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|inputRel
argument_list|)
decl_stmt|;
comment|// Extract input refs. They will serve as input for the function invocation
name|List
argument_list|<
name|RexNode
argument_list|>
name|inputRefs
init|=
name|Lists
operator|.
name|transform
argument_list|(
name|inputRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|input
lambda|->
operator|new
name|RexInputRef
argument_list|(
name|input
operator|.
name|getIndex
argument_list|()
argument_list|,
name|input
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// Extract type for the arguments
name|List
argument_list|<
name|RelDataType
argument_list|>
name|inputRefsTypes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputRefs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|inputRefsTypes
operator|.
name|add
argument_list|(
name|inputRefs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Input name to position map
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|inputPosMap
init|=
name|this
operator|.
name|relToHiveColNameCalcitePosMap
operator|.
name|get
argument_list|(
name|inputRel
argument_list|)
decl_stmt|;
comment|// 2) Generate HiveTableFunctionScan RelNode for lateral view
comment|// TODO: Support different functions (not only INLINE) with LATERAL VIEW JOIN
comment|// ^(TOK_LATERAL_VIEW ^(TOK_SELECT ^(TOK_SELEXPR ^(TOK_FUNCTION Identifier["inline"] valuesClause) identifier* tableAlias)))
specifier|final
name|ASTNode
name|selExprClause
init|=
operator|(
name|ASTNode
operator|)
name|lateralView
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|ASTNode
name|functionCall
init|=
operator|(
name|ASTNode
operator|)
name|selExprClause
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|functionCall
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|compareToIgnoreCase
argument_list|(
name|inlineFunctionName
argument_list|)
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"CBO only supports inline LVJ"
argument_list|)
throw|;
block|}
specifier|final
name|ASTNode
name|valuesClause
init|=
operator|(
name|ASTNode
operator|)
name|functionCall
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// Output types. They will be the concatenation of the input refs types and
comment|// the types of the expressions for the lateral view generated rows
name|List
argument_list|<
name|RelDataType
argument_list|>
name|outputFieldTypes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|inputRefsTypes
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|outputFieldNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|inputRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
argument_list|)
decl_stmt|;
comment|// Generate all expressions from lateral view
name|ExprNodeDesc
name|valuesExpr
init|=
name|genExprNodeDesc
argument_list|(
name|valuesClause
argument_list|,
name|inputRR
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|RexCall
name|convertedOriginalValuesExpr
init|=
operator|(
name|RexCall
operator|)
operator|new
name|RexNodeConverter
argument_list|(
name|this
operator|.
name|cluster
argument_list|,
name|inputRel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|inputPosMap
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
operator|.
name|convert
argument_list|(
name|valuesExpr
argument_list|)
decl_stmt|;
name|RelDataType
name|valuesRowType
init|=
operator|(
operator|(
name|ArraySqlType
operator|)
name|convertedOriginalValuesExpr
operator|.
name|getType
argument_list|()
operator|)
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|newStructExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|structExpr
range|:
name|convertedOriginalValuesExpr
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|RexCall
name|structCall
init|=
operator|(
name|RexCall
operator|)
name|structExpr
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|inputRefs
argument_list|)
decl_stmt|;
name|exprs
operator|.
name|addAll
argument_list|(
name|structCall
operator|.
name|getOperands
argument_list|()
argument_list|)
expr_stmt|;
name|newStructExprs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|structCall
operator|.
name|op
argument_list|,
name|exprs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RexNode
name|convertedFinalValuesExpr
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|convertedOriginalValuesExpr
operator|.
name|op
argument_list|,
name|newStructExprs
argument_list|)
decl_stmt|;
comment|// The return type will be the concatenation of input type and original values type
name|RelDataType
name|retType
init|=
name|SqlValidatorUtil
operator|.
name|deriveJoinRowType
argument_list|(
name|inputRel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|valuesRowType
argument_list|,
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|dtFactory
argument_list|,
literal|null
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
decl_stmt|;
comment|// Create inline SQL operator
name|FunctionInfo
name|inlineFunctionInfo
init|=
name|FunctionRegistry
operator|.
name|getFunctionInfo
argument_list|(
name|inlineFunctionName
argument_list|)
decl_stmt|;
name|SqlOperator
name|calciteOp
init|=
name|SqlFunctionConverter
operator|.
name|getCalciteOperator
argument_list|(
name|inlineFunctionName
argument_list|,
name|inlineFunctionInfo
operator|.
name|getGenericUDTF
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|inputRefsTypes
argument_list|)
argument_list|,
name|retType
argument_list|)
decl_stmt|;
name|RelNode
name|htfsRel
init|=
name|HiveTableFunctionScan
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|TraitsUtil
operator|.
name|getDefaultTraitSet
argument_list|(
name|cluster
argument_list|)
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|inputRel
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|calciteOp
argument_list|,
name|convertedFinalValuesExpr
argument_list|)
argument_list|,
literal|null
argument_list|,
name|retType
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// 3) Keep track of colname-to-posmap&& RR for new op
name|RowResolver
name|outputRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
comment|// Add all input columns
if|if
condition|(
operator|!
name|RowResolver
operator|.
name|add
argument_list|(
name|outputRR
argument_list|,
name|inputRR
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Duplicates detected when adding columns to RR: see previous message"
argument_list|)
expr_stmt|;
block|}
comment|// Add all columns from lateral view
comment|// First we extract the information that the query provides
name|String
name|tableAlias
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|columnAliases
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|uniqueNames
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|selExprClause
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|selExprClause
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABALIAS
case|:
name|tableAlias
operator|=
name|unescapeIdentifier
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|String
name|colAlias
init|=
name|unescapeIdentifier
argument_list|(
name|child
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|uniqueNames
operator|.
name|contains
argument_list|(
name|colAlias
argument_list|)
condition|)
block|{
comment|// Column aliases defined by query for lateral view output are duplicated
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|COLUMN_ALIAS_ALREADY_EXISTS
operator|.
name|getMsg
argument_list|(
name|colAlias
argument_list|)
argument_list|)
throw|;
block|}
name|columnAliases
operator|.
name|add
argument_list|(
name|colAlias
argument_list|)
expr_stmt|;
name|uniqueNames
operator|.
name|add
argument_list|(
name|colAlias
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tableAlias
operator|==
literal|null
condition|)
block|{
comment|// Parser enforces that table alias is added, but check again
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Alias should be specified LVJ"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|columnAliases
operator|.
name|isEmpty
argument_list|()
operator|&&
name|columnAliases
operator|.
name|size
argument_list|()
operator|!=
name|valuesRowType
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
comment|// Number of columns in the aliases does not match with number of columns
comment|// generated by the lateral view
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UDTF_ALIAS_MISMATCH
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|columnAliases
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Auto-generate column aliases
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|valuesRowType
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|columnAliases
operator|.
name|add
argument_list|(
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|numInputExprs
init|=
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|ListTypeInfo
name|listTypeInfo
init|=
operator|(
name|ListTypeInfo
operator|)
name|valuesExpr
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
comment|// Array should have ListTypeInfo
name|StructTypeInfo
name|typeInfos
init|=
operator|(
name|StructTypeInfo
operator|)
name|listTypeInfo
operator|.
name|getListElementTypeInfo
argument_list|()
decl_stmt|;
comment|// Within the list, we extract types
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|j
init|=
literal|0
init|;
name|i
operator|<
name|columnAliases
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|internalColName
decl_stmt|;
do|do
block|{
name|internalColName
operator|=
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|j
operator|++
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|inputRR
operator|.
name|getPosition
argument_list|(
name|internalColName
argument_list|)
operator|!=
operator|-
literal|1
condition|)
do|;
name|outputRR
operator|.
name|put
argument_list|(
name|tableAlias
argument_list|,
name|columnAliases
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|internalColName
argument_list|,
name|typeInfos
operator|.
name|getAllStructFieldTypeInfos
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|tableAlias
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|htfsRel
argument_list|,
name|buildHiveToCalciteColumnMap
argument_list|(
name|outputRR
argument_list|,
name|htfsRel
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|relToHiveRR
operator|.
name|put
argument_list|(
name|htfsRel
argument_list|,
name|outputRR
argument_list|)
expr_stmt|;
comment|// 4) Return new operator
return|return
name|htfsRel
return|;
block|}
specifier|private
name|boolean
name|genSubQueryRelNode
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|node
parameter_list|,
name|RelNode
name|srcRel
parameter_list|,
name|boolean
name|forHavingClause
parameter_list|,
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|RelNode
argument_list|>
name|subQueryToRelNode
parameter_list|)
throws|throws
name|CalciteSubquerySemanticException
block|{
name|Set
argument_list|<
name|ASTNode
argument_list|>
name|corrScalarQueriesWithAgg
init|=
operator|new
name|HashSet
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|ASTNode
argument_list|>
name|scalarQueriesWithAggNoWinNoGby
init|=
operator|new
name|HashSet
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|isSubQuery
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|//disallow subqueries which HIVE doesn't currently support
name|subqueryRestrictionCheck
argument_list|(
name|qb
argument_list|,
name|node
argument_list|,
name|srcRel
argument_list|,
name|forHavingClause
argument_list|,
name|corrScalarQueriesWithAgg
argument_list|,
name|scalarQueriesWithAggNoWinNoGby
argument_list|)
expr_stmt|;
name|Deque
argument_list|<
name|ASTNode
argument_list|>
name|stack
init|=
operator|new
name|ArrayDeque
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|node
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ASTNode
name|next
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|next
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_SUBQUERY_EXPR
case|:
comment|/*                * Restriction 2.h Subquery isnot allowed in LHS                */
if|if
condition|(
name|next
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|3
operator|&&
name|next
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY_EXPR
condition|)
block|{
throw|throw
operator|new
name|CalciteSubquerySemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UNSUPPORTED_SUBQUERY_EXPRESSION
operator|.
name|getMsg
argument_list|(
name|next
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
argument_list|,
literal|"SubQuery in LHS expressions are not supported."
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|sbQueryAlias
init|=
literal|"sq_"
operator|+
name|qb
operator|.
name|incrNumSubQueryPredicates
argument_list|()
decl_stmt|;
name|QB
name|qbSQ
init|=
operator|new
name|QB
argument_list|(
name|qb
operator|.
name|getId
argument_list|()
argument_list|,
name|sbQueryAlias
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|Phase1Ctx
name|ctx1
init|=
name|initPhase1Ctx
argument_list|()
decl_stmt|;
name|doPhase1
argument_list|(
operator|(
name|ASTNode
operator|)
name|next
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|,
name|qbSQ
argument_list|,
name|ctx1
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|getMetaData
argument_list|(
name|qbSQ
argument_list|)
expr_stmt|;
name|this
operator|.
name|subqueryId
operator|++
expr_stmt|;
name|RelNode
name|subQueryRelNode
init|=
name|genLogicalPlan
argument_list|(
name|qbSQ
argument_list|,
literal|false
argument_list|,
name|relToHiveColNameCalcitePosMap
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
argument_list|,
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
argument_list|)
decl_stmt|;
name|subQueryToRelNode
operator|.
name|put
argument_list|(
name|next
argument_list|,
name|subQueryRelNode
argument_list|)
expr_stmt|;
comment|//keep track of subqueries which are scalar, correlated and contains aggregate
comment|// subquery expression. This will later be special cased in Subquery remove rule
comment|// for correlated scalar queries with aggregate we have take care of the case where
comment|// inner aggregate happens on empty result
if|if
condition|(
name|corrScalarQueriesWithAgg
operator|.
name|contains
argument_list|(
name|next
argument_list|)
condition|)
block|{
name|corrScalarRexSQWithAgg
operator|.
name|add
argument_list|(
name|subQueryRelNode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scalarQueriesWithAggNoWinNoGby
operator|.
name|contains
argument_list|(
name|next
argument_list|)
condition|)
block|{
name|scalarAggNoGbyNoWin
operator|.
name|add
argument_list|(
name|subQueryRelNode
argument_list|)
expr_stmt|;
block|}
name|isSubQuery
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
name|int
name|childCount
init|=
name|next
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|childCount
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|stack
operator|.
name|push
argument_list|(
operator|(
name|ASTNode
operator|)
name|next
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|SemanticException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CalciteSubquerySemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|isSubQuery
condition|)
block|{
comment|// since subqueries will later be rewritten into JOINs we want join reordering logic to trigger
name|profilesCBO
operator|.
name|add
argument_list|(
name|ExtendedCBOProfile
operator|.
name|JOIN_REORDERING
argument_list|)
expr_stmt|;
block|}
return|return
name|isSubQuery
return|;
block|}
specifier|private
name|RelNode
name|genFilterRelNode
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|searchCond
parameter_list|,
name|RelNode
name|srcRel
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RelNode
argument_list|>
name|aliasToRel
parameter_list|,
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|outerNameToPosMap
parameter_list|,
name|RowResolver
name|outerRR
parameter_list|,
name|boolean
name|forHavingClause
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|RelNode
argument_list|>
name|subQueryToRelNode
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|boolean
name|isSubQuery
init|=
name|genSubQueryRelNode
argument_list|(
name|qb
argument_list|,
name|searchCond
argument_list|,
name|srcRel
argument_list|,
name|forHavingClause
argument_list|,
name|subQueryToRelNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|isSubQuery
condition|)
block|{
name|ExprNodeDesc
name|subQueryExpr
init|=
name|genExprNodeDesc
argument_list|(
name|searchCond
argument_list|,
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
argument_list|,
name|outerRR
argument_list|,
name|subQueryToRelNode
argument_list|,
name|forHavingClause
argument_list|)
decl_stmt|;
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|hiveColNameCalcitePosMap
init|=
name|this
operator|.
name|relToHiveColNameCalcitePosMap
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
name|RexNode
name|convertedFilterLHS
init|=
operator|new
name|RexNodeConverter
argument_list|(
name|cluster
argument_list|,
name|srcRel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|outerNameToPosMap
argument_list|,
name|hiveColNameCalcitePosMap
argument_list|,
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
argument_list|,
name|outerRR
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
name|subqueryId
argument_list|)
operator|.
name|convert
argument_list|(
name|subQueryExpr
argument_list|)
decl_stmt|;
name|RelNode
name|filterRel
init|=
operator|new
name|HiveFilter
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRelNode
operator|.
name|CONVENTION
argument_list|)
argument_list|,
name|srcRel
argument_list|,
name|convertedFilterLHS
argument_list|)
decl_stmt|;
name|this
operator|.
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|filterRel
argument_list|,
name|this
operator|.
name|relToHiveColNameCalcitePosMap
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
argument_list|)
expr_stmt|;
name|relToHiveRR
operator|.
name|put
argument_list|(
name|filterRel
argument_list|,
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|filterRel
return|;
block|}
else|else
block|{
return|return
name|genFilterRelNode
argument_list|(
name|searchCond
argument_list|,
name|srcRel
argument_list|,
name|outerNameToPosMap
argument_list|,
name|outerRR
argument_list|,
name|forHavingClause
argument_list|)
return|;
block|}
block|}
specifier|private
name|RelNode
name|projectLeftOuterSide
parameter_list|(
name|RelNode
name|srcRel
parameter_list|,
name|int
name|numColumns
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|iRR
init|=
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
name|RowResolver
name|oRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|RowResolver
operator|.
name|add
argument_list|(
name|oRR
argument_list|,
name|iRR
argument_list|,
name|numColumns
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|calciteColLst
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|oFieldNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|RelDataType
name|iType
init|=
name|srcRel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iType
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RelDataTypeField
name|fType
init|=
name|iType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|fName
init|=
name|iType
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|calciteColLst
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|fType
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|oFieldNames
operator|.
name|add
argument_list|(
name|fName
argument_list|)
expr_stmt|;
block|}
name|HiveRelNode
name|selRel
init|=
name|HiveProject
operator|.
name|create
argument_list|(
name|srcRel
argument_list|,
name|calciteColLst
argument_list|,
name|oFieldNames
argument_list|)
decl_stmt|;
name|this
operator|.
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|selRel
argument_list|,
name|buildHiveToCalciteColumnMap
argument_list|(
name|oRR
argument_list|,
name|selRel
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|relToHiveRR
operator|.
name|put
argument_list|(
name|selRel
argument_list|,
name|oRR
argument_list|)
expr_stmt|;
return|return
name|selRel
return|;
block|}
specifier|private
name|RelNode
name|genFilterLogicalPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|RelNode
name|srcRel
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RelNode
argument_list|>
name|aliasToRel
parameter_list|,
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|outerNameToPosMap
parameter_list|,
name|RowResolver
name|outerRR
parameter_list|,
name|boolean
name|forHavingClause
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RelNode
name|filterRel
init|=
literal|null
decl_stmt|;
name|Iterator
argument_list|<
name|ASTNode
argument_list|>
name|whereClauseIterator
init|=
name|getQBParseInfo
argument_list|(
name|qb
argument_list|)
operator|.
name|getDestToWhereExpr
argument_list|()
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|whereClauseIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|filterRel
operator|=
name|genFilterRelNode
argument_list|(
name|qb
argument_list|,
operator|(
name|ASTNode
operator|)
name|whereClauseIterator
operator|.
name|next
argument_list|()
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|srcRel
argument_list|,
name|aliasToRel
argument_list|,
name|outerNameToPosMap
argument_list|,
name|outerRR
argument_list|,
name|forHavingClause
argument_list|)
expr_stmt|;
block|}
return|return
name|filterRel
return|;
block|}
comment|/**      * Class to store GenericUDAF related information.      */
specifier|private
class|class
name|AggInfo
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|m_aggParams
decl_stmt|;
specifier|private
specifier|final
name|TypeInfo
name|m_returnType
decl_stmt|;
specifier|private
specifier|final
name|String
name|m_udfName
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|m_distinct
decl_stmt|;
specifier|private
name|AggInfo
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|aggParams
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|,
name|String
name|udfName
parameter_list|,
name|boolean
name|isDistinct
parameter_list|)
block|{
name|m_aggParams
operator|=
name|aggParams
expr_stmt|;
name|m_returnType
operator|=
name|returnType
expr_stmt|;
name|m_udfName
operator|=
name|udfName
expr_stmt|;
name|m_distinct
operator|=
name|isDistinct
expr_stmt|;
block|}
block|}
specifier|private
name|AggregateCall
name|convertGBAgg
parameter_list|(
name|AggInfo
name|agg
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|gbChildProjLst
parameter_list|,
name|RexNodeConverter
name|converter
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|rexNodeToPosMap
parameter_list|,
name|Integer
name|childProjLstIndx
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// 1. Get agg fn ret type in Calcite
name|RelDataType
name|aggFnRetType
init|=
name|TypeConverter
operator|.
name|convert
argument_list|(
name|agg
operator|.
name|m_returnType
argument_list|,
name|this
operator|.
name|cluster
operator|.
name|getTypeFactory
argument_list|()
argument_list|)
decl_stmt|;
comment|// 2. Convert Agg Fn args and type of args to Calcite
comment|// TODO: Does HQL allows expressions as aggregate args or can it only be
comment|// projections from child?
name|Integer
name|inputIndx
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|argList
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|RexNode
name|rexNd
init|=
literal|null
decl_stmt|;
name|RelDataTypeFactory
name|dtFactory
init|=
name|this
operator|.
name|cluster
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RelDataType
argument_list|>
name|aggArgRelDTBldr
init|=
operator|new
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|expr
range|:
name|agg
operator|.
name|m_aggParams
control|)
block|{
name|rexNd
operator|=
name|converter
operator|.
name|convert
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|inputIndx
operator|=
name|rexNodeToPosMap
operator|.
name|get
argument_list|(
name|rexNd
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputIndx
operator|==
literal|null
condition|)
block|{
name|gbChildProjLst
operator|.
name|add
argument_list|(
name|rexNd
argument_list|)
expr_stmt|;
name|rexNodeToPosMap
operator|.
name|put
argument_list|(
name|rexNd
operator|.
name|toString
argument_list|()
argument_list|,
name|childProjLstIndx
argument_list|)
expr_stmt|;
name|inputIndx
operator|=
name|childProjLstIndx
expr_stmt|;
name|childProjLstIndx
operator|++
expr_stmt|;
block|}
name|argList
operator|.
name|add
argument_list|(
name|inputIndx
argument_list|)
expr_stmt|;
comment|// TODO: does arg need type cast?
name|aggArgRelDTBldr
operator|.
name|add
argument_list|(
name|TypeConverter
operator|.
name|convert
argument_list|(
name|expr
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|dtFactory
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 3. Get Aggregation FN from Calcite given name, ret type and input arg
comment|// type
specifier|final
name|SqlAggFunction
name|aggregation
init|=
name|SqlFunctionConverter
operator|.
name|getCalciteAggFn
argument_list|(
name|agg
operator|.
name|m_udfName
argument_list|,
name|agg
operator|.
name|m_distinct
argument_list|,
name|aggArgRelDTBldr
operator|.
name|build
argument_list|()
argument_list|,
name|aggFnRetType
argument_list|)
decl_stmt|;
return|return
operator|new
name|AggregateCall
argument_list|(
name|aggregation
argument_list|,
name|agg
operator|.
name|m_distinct
argument_list|,
name|argList
argument_list|,
name|aggFnRetType
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|genGBRelNode
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|gbExprs
parameter_list|,
name|List
argument_list|<
name|AggInfo
argument_list|>
name|aggInfoLst
parameter_list|,
name|List
argument_list|<
name|Long
argument_list|>
name|groupSets
parameter_list|,
name|RelNode
name|srcRel
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|posMap
init|=
name|this
operator|.
name|relToHiveColNameCalcitePosMap
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
name|RexNodeConverter
name|converter
init|=
operator|new
name|RexNodeConverter
argument_list|(
name|this
operator|.
name|cluster
argument_list|,
name|srcRel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|posMap
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|hasGroupSets
init|=
name|groupSets
operator|!=
literal|null
operator|&&
operator|!
name|groupSets
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|gbChildProjLst
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|rexNodeToPosMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|groupSetPositions
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|Integer
name|gbIndx
init|=
literal|0
decl_stmt|;
name|RexNode
name|rnd
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|key
range|:
name|gbExprs
control|)
block|{
name|rnd
operator|=
name|converter
operator|.
name|convert
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|gbChildProjLst
operator|.
name|add
argument_list|(
name|rnd
argument_list|)
expr_stmt|;
name|groupSetPositions
operator|.
name|add
argument_list|(
name|gbIndx
argument_list|)
expr_stmt|;
name|rexNodeToPosMap
operator|.
name|put
argument_list|(
name|rnd
operator|.
name|toString
argument_list|()
argument_list|,
name|gbIndx
argument_list|)
expr_stmt|;
name|gbIndx
operator|++
expr_stmt|;
block|}
specifier|final
name|ImmutableBitSet
name|groupSet
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|groupSetPositions
argument_list|)
decl_stmt|;
comment|// Grouping sets: we need to transform them into ImmutableBitSet
comment|// objects for Calcite
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
name|transformedGroupSets
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|hasGroupSets
condition|)
block|{
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
name|setTransformedGroupSets
init|=
operator|new
name|HashSet
argument_list|<
name|ImmutableBitSet
argument_list|>
argument_list|(
name|groupSets
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|long
name|val
range|:
name|groupSets
control|)
block|{
name|setTransformedGroupSets
operator|.
name|add
argument_list|(
name|convert
argument_list|(
name|val
argument_list|,
name|groupSet
operator|.
name|cardinality
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Calcite expects the grouping sets sorted and without duplicates
name|transformedGroupSets
operator|=
operator|new
name|ArrayList
argument_list|<
name|ImmutableBitSet
argument_list|>
argument_list|(
name|setTransformedGroupSets
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|transformedGroupSets
argument_list|,
name|ImmutableBitSet
operator|.
name|COMPARATOR
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggregateCalls
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|AggInfo
name|agg
range|:
name|aggInfoLst
control|)
block|{
name|aggregateCalls
operator|.
name|add
argument_list|(
name|convertGBAgg
argument_list|(
name|agg
argument_list|,
name|srcRel
argument_list|,
name|gbChildProjLst
argument_list|,
name|converter
argument_list|,
name|rexNodeToPosMap
argument_list|,
name|gbChildProjLst
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasGroupSets
condition|)
block|{
comment|// Create GroupingID column
name|AggregateCall
name|aggCall
init|=
name|AggregateCall
operator|.
name|create
argument_list|(
name|HiveGroupingID
operator|.
name|INSTANCE
argument_list|,
literal|false
argument_list|,
operator|new
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Integer
argument_list|>
argument_list|()
operator|.
name|build
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
name|this
operator|.
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
argument_list|,
name|HiveGroupingID
operator|.
name|INSTANCE
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|aggregateCalls
operator|.
name|add
argument_list|(
name|aggCall
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gbChildProjLst
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// This will happen for count(*), in such cases we arbitarily pick
comment|// first element from srcRel
name|gbChildProjLst
operator|.
name|add
argument_list|(
name|this
operator|.
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|srcRel
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RelNode
name|gbInputRel
init|=
name|HiveProject
operator|.
name|create
argument_list|(
name|srcRel
argument_list|,
name|gbChildProjLst
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|HiveRelNode
name|aggregateRel
init|=
operator|new
name|HiveAggregate
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRelNode
operator|.
name|CONVENTION
argument_list|)
argument_list|,
name|gbInputRel
argument_list|,
name|groupSet
argument_list|,
name|transformedGroupSets
argument_list|,
name|aggregateCalls
argument_list|)
decl_stmt|;
return|return
name|aggregateRel
return|;
block|}
comment|/* This method returns the flip big-endian representation of value */
specifier|private
name|ImmutableBitSet
name|convert
parameter_list|(
name|long
name|value
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|BitSet
name|bits
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|index
init|=
name|length
operator|-
literal|1
init|;
name|index
operator|>=
literal|0
condition|;
name|index
operator|--
control|)
block|{
if|if
condition|(
name|value
operator|%
literal|2
operator|!=
literal|0
condition|)
block|{
name|bits
operator|.
name|set
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|value
operator|>>>
literal|1
expr_stmt|;
block|}
comment|// We flip the bits because Calcite considers that '1'
comment|// means that the column participates in the GroupBy
comment|// and '0' does not, as opposed to grouping_id.
name|bits
operator|.
name|flip
argument_list|(
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|ImmutableBitSet
operator|.
name|FROM_BIT_SET
operator|.
name|apply
argument_list|(
name|bits
argument_list|)
return|;
block|}
specifier|private
name|void
name|addAlternateGByKeyMappings
parameter_list|(
name|ASTNode
name|gByExpr
parameter_list|,
name|ColumnInfo
name|colInfo
parameter_list|,
name|RowResolver
name|gByInputRR
parameter_list|,
name|RowResolver
name|gByRR
parameter_list|)
block|{
if|if
condition|(
name|gByExpr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|DOT
operator|&&
name|gByExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
condition|)
block|{
name|String
name|tab_alias
init|=
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|gByExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|col_alias
init|=
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|gByExpr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
name|gByRR
operator|.
name|put
argument_list|(
name|tab_alias
argument_list|,
name|col_alias
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gByExpr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
condition|)
block|{
name|String
name|col_alias
init|=
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|gByExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|tab_alias
init|=
literal|null
decl_stmt|;
comment|/*          * If the input to the GBy has a tab alias for the column, then add an          * entry based on that tab_alias. For e.g. this query: select b.x,          * count(*) from t1 b group by x needs (tab_alias=b, col_alias=x) in the          * GBy RR. tab_alias=b comes from looking at the RowResolver that is the          * ancestor before any GBy/ReduceSinks added for the GBY operation.          */
try|try
block|{
name|ColumnInfo
name|pColInfo
init|=
name|gByInputRR
operator|.
name|get
argument_list|(
name|tab_alias
argument_list|,
name|col_alias
argument_list|)
decl_stmt|;
name|tab_alias
operator|=
name|pColInfo
operator|==
literal|null
condition|?
literal|null
else|:
name|pColInfo
operator|.
name|getTabAlias
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|se
parameter_list|)
block|{         }
name|gByRR
operator|.
name|put
argument_list|(
name|tab_alias
argument_list|,
name|col_alias
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|addToGBExpr
parameter_list|(
name|RowResolver
name|groupByOutputRowResolver
parameter_list|,
name|RowResolver
name|groupByInputRowResolver
parameter_list|,
name|ASTNode
name|grpbyExpr
parameter_list|,
name|ExprNodeDesc
name|grpbyExprNDesc
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|gbExprNDescLst
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|outputColumnNames
parameter_list|)
block|{
comment|// TODO: Should we use grpbyExprNDesc.getTypeInfo()? what if expr is
comment|// UDF
name|int
name|i
init|=
name|gbExprNDescLst
operator|.
name|size
argument_list|()
decl_stmt|;
name|String
name|field
init|=
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|gbExprNDescLst
operator|.
name|add
argument_list|(
name|grpbyExprNDesc
argument_list|)
expr_stmt|;
name|ColumnInfo
name|oColInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|grpbyExprNDesc
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|groupByOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|grpbyExpr
argument_list|,
name|oColInfo
argument_list|)
expr_stmt|;
name|addAlternateGByKeyMappings
argument_list|(
name|grpbyExpr
argument_list|,
name|oColInfo
argument_list|,
name|groupByInputRowResolver
argument_list|,
name|groupByOutputRowResolver
argument_list|)
expr_stmt|;
block|}
specifier|private
name|AggInfo
name|getHiveAggInfo
parameter_list|(
name|ASTNode
name|aggAst
parameter_list|,
name|int
name|aggFnLstArgIndx
parameter_list|,
name|RowResolver
name|inputRR
parameter_list|)
throws|throws
name|SemanticException
block|{
name|AggInfo
name|aInfo
init|=
literal|null
decl_stmt|;
comment|// 1 Convert UDAF Params to ExprNodeDesc
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|aggParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|aggFnLstArgIndx
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|paraExpr
init|=
operator|(
name|ASTNode
operator|)
name|aggAst
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|paraExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|paraExpr
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|aggParameters
operator|.
name|add
argument_list|(
name|paraExprNode
argument_list|)
expr_stmt|;
block|}
comment|// 2. Is this distinct UDAF
name|boolean
name|isDistinct
init|=
name|aggAst
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
decl_stmt|;
comment|// 3. Determine type of UDAF
name|TypeInfo
name|udafRetType
init|=
literal|null
decl_stmt|;
comment|// 3.1 Obtain UDAF name
name|String
name|aggName
init|=
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|aggAst
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
comment|// 3.2 Rank functions type is 'int'/'double'
if|if
condition|(
name|FunctionRegistry
operator|.
name|isRankingFunction
argument_list|(
name|aggName
argument_list|)
condition|)
block|{
if|if
condition|(
name|aggName
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"percent_rank"
argument_list|)
condition|)
name|udafRetType
operator|=
name|TypeInfoFactory
operator|.
name|doubleTypeInfo
expr_stmt|;
else|else
name|udafRetType
operator|=
name|TypeInfoFactory
operator|.
name|intTypeInfo
expr_stmt|;
block|}
else|else
block|{
comment|// 3.3 Try obtaining UDAF evaluators to determine the ret type
try|try
block|{
name|boolean
name|isAllColumns
init|=
name|aggAst
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONSTAR
decl_stmt|;
comment|// 3.3.1 Get UDAF Evaluator
name|Mode
name|amode
init|=
name|SemanticAnalyzer
operator|.
name|groupByDescModeToUDAFMode
argument_list|(
name|GroupByDesc
operator|.
name|Mode
operator|.
name|COMPLETE
argument_list|,
name|isDistinct
argument_list|)
decl_stmt|;
name|GenericUDAFEvaluator
name|genericUDAFEvaluator
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|aggName
operator|.
name|toLowerCase
argument_list|()
operator|.
name|equals
argument_list|(
name|FunctionRegistry
operator|.
name|LEAD_FUNC_NAME
argument_list|)
operator|||
name|aggName
operator|.
name|toLowerCase
argument_list|()
operator|.
name|equals
argument_list|(
name|FunctionRegistry
operator|.
name|LAG_FUNC_NAME
argument_list|)
condition|)
block|{
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
name|originalParameterTypeInfos
init|=
name|SemanticAnalyzer
operator|.
name|getWritableObjectInspector
argument_list|(
name|aggParameters
argument_list|)
decl_stmt|;
name|genericUDAFEvaluator
operator|=
name|FunctionRegistry
operator|.
name|getGenericWindowingEvaluator
argument_list|(
name|aggName
argument_list|,
name|originalParameterTypeInfos
argument_list|,
name|isDistinct
argument_list|,
name|isAllColumns
argument_list|)
expr_stmt|;
name|GenericUDAFInfo
name|udaf
init|=
name|SemanticAnalyzer
operator|.
name|getGenericUDAFInfo
argument_list|(
name|genericUDAFEvaluator
argument_list|,
name|amode
argument_list|,
name|aggParameters
argument_list|)
decl_stmt|;
name|udafRetType
operator|=
operator|(
operator|(
name|ListTypeInfo
operator|)
name|udaf
operator|.
name|returnType
operator|)
operator|.
name|getListElementTypeInfo
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|genericUDAFEvaluator
operator|=
name|SemanticAnalyzer
operator|.
name|getGenericUDAFEvaluator
argument_list|(
name|aggName
argument_list|,
name|aggParameters
argument_list|,
name|aggAst
argument_list|,
name|isDistinct
argument_list|,
name|isAllColumns
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|genericUDAFEvaluator
operator|!=
literal|null
operator|)
assert|;
comment|// 3.3.2 Get UDAF Info using UDAF Evaluator
name|GenericUDAFInfo
name|udaf
init|=
name|SemanticAnalyzer
operator|.
name|getGenericUDAFInfo
argument_list|(
name|genericUDAFEvaluator
argument_list|,
name|amode
argument_list|,
name|aggParameters
argument_list|)
decl_stmt|;
if|if
condition|(
name|FunctionRegistry
operator|.
name|pivotResult
argument_list|(
name|aggName
argument_list|)
condition|)
block|{
name|udafRetType
operator|=
operator|(
operator|(
name|ListTypeInfo
operator|)
name|udaf
operator|.
name|returnType
operator|)
operator|.
name|getListElementTypeInfo
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|udafRetType
operator|=
name|udaf
operator|.
name|returnType
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"CBO: Couldn't Obtain UDAF evaluators for "
operator|+
name|aggName
operator|+
literal|", trying to translate to GenericUDF"
argument_list|)
expr_stmt|;
block|}
comment|// 3.4 Try GenericUDF translation
if|if
condition|(
name|udafRetType
operator|==
literal|null
condition|)
block|{
name|TypeCheckCtx
name|tcCtx
init|=
operator|new
name|TypeCheckCtx
argument_list|(
name|inputRR
argument_list|)
decl_stmt|;
comment|// We allow stateful functions in the SELECT list (but nowhere else)
name|tcCtx
operator|.
name|setAllowStatefulFunctions
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|tcCtx
operator|.
name|setAllowDistinctFunctions
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|exp
init|=
name|genExprNodeDesc
argument_list|(
operator|(
name|ASTNode
operator|)
name|aggAst
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|inputRR
argument_list|,
name|tcCtx
argument_list|)
decl_stmt|;
name|udafRetType
operator|=
name|exp
operator|.
name|getTypeInfo
argument_list|()
expr_stmt|;
block|}
block|}
comment|// 4. Construct AggInfo
name|aInfo
operator|=
operator|new
name|AggInfo
argument_list|(
name|aggParameters
argument_list|,
name|udafRetType
argument_list|,
name|aggName
argument_list|,
name|isDistinct
argument_list|)
expr_stmt|;
return|return
name|aInfo
return|;
block|}
comment|/**      * Generate GB plan.      *      * @param qb      * @param srcRel      * @return TODO: 1. Grouping Sets (roll up..)      * @throws SemanticException      */
specifier|private
name|RelNode
name|genGBLogicalPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|RelNode
name|srcRel
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RelNode
name|gbRel
init|=
literal|null
decl_stmt|;
name|QBParseInfo
name|qbp
init|=
name|getQBParseInfo
argument_list|(
name|qb
argument_list|)
decl_stmt|;
comment|// 1. Gather GB Expressions (AST) (GB + Aggregations)
comment|// NOTE: Multi Insert is not supported
name|String
name|detsClauseName
init|=
name|qbp
operator|.
name|getClauseNames
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// Check and transform group by *. This will only happen for select distinct *.
comment|// Here the "genSelectPlan" is being leveraged.
comment|// The main benefits are (1) remove virtual columns that should
comment|// not be included in the group by; (2) add the fully qualified column names to unParseTranslator
comment|// so that view is supported. The drawback is that an additional SEL op is added. If it is
comment|// not necessary, it will be removed by NonBlockingOpDeDupProc Optimizer because it will match
comment|// SEL%SEL% rule.
name|ASTNode
name|selExprList
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSelForClause
argument_list|(
name|detsClauseName
argument_list|)
decl_stmt|;
name|SubQueryUtils
operator|.
name|checkForTopLevelSubqueries
argument_list|(
name|selExprList
argument_list|)
expr_stmt|;
if|if
condition|(
name|selExprList
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SELECTDI
operator|&&
name|selExprList
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
operator|&&
name|selExprList
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|ASTNode
name|node
init|=
operator|(
name|ASTNode
operator|)
name|selExprList
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALLCOLREF
condition|)
block|{
comment|// As we said before, here we use genSelectLogicalPlan to rewrite AllColRef
name|srcRel
operator|=
name|genSelectLogicalPlan
argument_list|(
name|qb
argument_list|,
name|srcRel
argument_list|,
name|srcRel
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
operator|.
name|getKey
argument_list|()
expr_stmt|;
name|RowResolver
name|rr
init|=
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
name|qbp
operator|.
name|setSelExprForClause
argument_list|(
name|detsClauseName
argument_list|,
name|SemanticAnalyzer
operator|.
name|genSelectDIAST
argument_list|(
name|rr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Select DISTINCT + windowing; GBy handled by genSelectForWindowing
if|if
condition|(
name|selExprList
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SELECTDI
operator|&&
operator|!
name|qb
operator|.
name|getAllWindowingSpecs
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByAstExprs
init|=
name|getGroupByForClause
argument_list|(
name|qbp
argument_list|,
name|detsClauseName
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|qbp
operator|.
name|getAggregationExprsForClause
argument_list|(
name|detsClauseName
argument_list|)
decl_stmt|;
name|boolean
name|hasGrpByAstExprs
init|=
operator|(
name|grpByAstExprs
operator|!=
literal|null
operator|&&
operator|!
name|grpByAstExprs
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
literal|true
else|:
literal|false
decl_stmt|;
name|boolean
name|hasAggregationTrees
init|=
operator|(
name|aggregationTrees
operator|!=
literal|null
operator|&&
operator|!
name|aggregationTrees
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
literal|true
else|:
literal|false
decl_stmt|;
specifier|final
name|boolean
name|cubeRollupGrpSetPresent
init|=
operator|(
operator|!
name|qbp
operator|.
name|getDestRollups
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|qbp
operator|.
name|getDestGroupingSets
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|qbp
operator|.
name|getDestCubes
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
decl_stmt|;
comment|// 2. Sanity check
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEGROUPBYSKEW
argument_list|)
operator|&&
name|qbp
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|detsClauseName
argument_list|)
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UNSUPPORTED_MULTIPLE_DISTINCTS
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|cubeRollupGrpSetPresent
condition|)
block|{
if|if
condition|(
operator|!
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPSIDEAGGREGATE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|HIVE_GROUPING_SETS_AGGR_NOMAPAGGR
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEGROUPBYSKEW
argument_list|)
condition|)
block|{
name|checkExpressionsForGroupingSet
argument_list|(
name|grpByAstExprs
argument_list|,
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|detsClauseName
argument_list|)
argument_list|,
name|aggregationTrees
argument_list|,
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qbp
operator|.
name|getDestGroupingSets
argument_list|()
operator|.
name|size
argument_list|()
operator|>
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_NEW_JOB_GROUPING_SET_CARDINALITY
argument_list|)
condition|)
block|{
name|String
name|errorMsg
init|=
literal|"The number of rows per input row due to grouping sets is "
operator|+
name|qbp
operator|.
name|getDestGroupingSets
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|HIVE_GROUPING_SETS_THRESHOLD_NOT_ALLOWED_WITH_SKEW
operator|.
name|getMsg
argument_list|(
name|errorMsg
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|hasGrpByAstExprs
operator|||
name|hasAggregationTrees
condition|)
block|{
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|gbExprNDescLst
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// 3. Input, Output Row Resolvers
name|RowResolver
name|groupByInputRowResolver
init|=
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
name|RowResolver
name|groupByOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|groupByOutputRowResolver
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasGrpByAstExprs
condition|)
block|{
comment|// 4. Construct GB Keys (ExprNode)
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByAstExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByAstExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
name|astToExprNDescMap
init|=
name|genAllExprNodeDesc
argument_list|(
name|grpbyExpr
argument_list|,
name|groupByInputRowResolver
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|grpbyExprNDesc
init|=
name|astToExprNDescMap
operator|.
name|get
argument_list|(
name|grpbyExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|grpbyExprNDesc
operator|==
literal|null
condition|)
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
literal|"Invalid Column Reference: "
operator|+
name|grpbyExpr
operator|.
name|dump
argument_list|()
argument_list|,
name|UnsupportedFeature
operator|.
name|Invalid_column_reference
argument_list|)
throw|;
name|addToGBExpr
argument_list|(
name|groupByOutputRowResolver
argument_list|,
name|groupByInputRowResolver
argument_list|,
name|grpbyExpr
argument_list|,
name|grpbyExprNDesc
argument_list|,
name|gbExprNDescLst
argument_list|,
name|outputColumnNames
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 5. GroupingSets, Cube, Rollup
name|int
name|groupingColsSize
init|=
name|gbExprNDescLst
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|groupingSets
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|cubeRollupGrpSetPresent
condition|)
block|{
name|groupingSets
operator|=
name|getGroupByGroupingSetsForClause
argument_list|(
name|qbp
argument_list|,
name|detsClauseName
argument_list|)
operator|.
name|getSecond
argument_list|()
expr_stmt|;
block|}
comment|// 6. Construct aggregation function Info
name|ArrayList
argument_list|<
name|AggInfo
argument_list|>
name|aggregations
init|=
operator|new
name|ArrayList
argument_list|<
name|AggInfo
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasAggregationTrees
condition|)
block|{
assert|assert
operator|(
name|aggregationTrees
operator|!=
literal|null
operator|)
assert|;
for|for
control|(
name|ASTNode
name|value
range|:
name|aggregationTrees
operator|.
name|values
argument_list|()
control|)
block|{
comment|// 6.1 Determine type of UDAF
comment|// This is the GenericUDAF name
name|String
name|aggName
init|=
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|value
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|isDistinct
init|=
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
decl_stmt|;
name|boolean
name|isAllColumns
init|=
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONSTAR
decl_stmt|;
comment|// 6.2 Convert UDAF Params to ExprNodeDesc
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|aggParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|paraExpr
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|paraExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|paraExpr
argument_list|,
name|groupByInputRowResolver
argument_list|)
decl_stmt|;
name|aggParameters
operator|.
name|add
argument_list|(
name|paraExprNode
argument_list|)
expr_stmt|;
block|}
name|Mode
name|amode
init|=
name|SemanticAnalyzer
operator|.
name|groupByDescModeToUDAFMode
argument_list|(
name|GroupByDesc
operator|.
name|Mode
operator|.
name|COMPLETE
argument_list|,
name|isDistinct
argument_list|)
decl_stmt|;
name|GenericUDAFEvaluator
name|genericUDAFEvaluator
init|=
name|SemanticAnalyzer
operator|.
name|getGenericUDAFEvaluator
argument_list|(
name|aggName
argument_list|,
name|aggParameters
argument_list|,
name|value
argument_list|,
name|isDistinct
argument_list|,
name|isAllColumns
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|genericUDAFEvaluator
operator|!=
literal|null
operator|)
assert|;
name|GenericUDAFInfo
name|udaf
init|=
name|SemanticAnalyzer
operator|.
name|getGenericUDAFInfo
argument_list|(
name|genericUDAFEvaluator
argument_list|,
name|amode
argument_list|,
name|aggParameters
argument_list|)
decl_stmt|;
name|AggInfo
name|aInfo
init|=
operator|new
name|AggInfo
argument_list|(
name|aggParameters
argument_list|,
name|udaf
operator|.
name|returnType
argument_list|,
name|aggName
argument_list|,
name|isDistinct
argument_list|)
decl_stmt|;
name|aggregations
operator|.
name|add
argument_list|(
name|aInfo
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|groupingColsSize
operator|+
name|aggregations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|value
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|aInfo
operator|.
name|m_returnType
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 7. If GroupingSets, Cube, Rollup were used, we account grouping__id
if|if
condition|(
name|groupingSets
operator|!=
literal|null
operator|&&
operator|!
name|groupingSets
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|groupingColsSize
operator|+
name|aggregations
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|put
argument_list|(
literal|null
argument_list|,
name|VirtualColumn
operator|.
name|GROUPINGID
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|VirtualColumn
operator|.
name|GROUPINGID
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 8. We create the group_by operator
name|gbRel
operator|=
name|genGBRelNode
argument_list|(
name|gbExprNDescLst
argument_list|,
name|aggregations
argument_list|,
name|groupingSets
argument_list|,
name|srcRel
argument_list|)
expr_stmt|;
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|gbRel
argument_list|,
name|buildHiveToCalciteColumnMap
argument_list|(
name|groupByOutputRowResolver
argument_list|,
name|gbRel
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|relToHiveRR
operator|.
name|put
argument_list|(
name|gbRel
argument_list|,
name|groupByOutputRowResolver
argument_list|)
expr_stmt|;
block|}
return|return
name|gbRel
return|;
block|}
comment|/**      * Generate OB RelNode and input Select RelNode that should be used to      * introduce top constraining Project. If Input select RelNode is not      * present then don't introduce top constraining select.      *      * @param qb      * @param selPair      * @param outermostOB      * @return RelNode OB RelNode      * @throws SemanticException      */
specifier|private
name|RelNode
name|genOBLogicalPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|RowResolver
argument_list|>
name|selPair
parameter_list|,
name|boolean
name|outermostOB
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// selPair.getKey() is the operator right before OB
comment|// selPair.getValue() is RR which only contains columns needed in result
comment|// set. Extra columns needed by order by will be absent from it.
name|RelNode
name|srcRel
init|=
name|selPair
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|RowResolver
name|selectOutputRR
init|=
name|selPair
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|RelNode
name|sortRel
init|=
literal|null
decl_stmt|;
name|RelNode
name|returnRel
init|=
literal|null
decl_stmt|;
name|QBParseInfo
name|qbp
init|=
name|getQBParseInfo
argument_list|(
name|qb
argument_list|)
decl_stmt|;
name|String
name|dest
init|=
name|qbp
operator|.
name|getClauseNames
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|ASTNode
name|obAST
init|=
name|qbp
operator|.
name|getOrderByForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|obAST
operator|!=
literal|null
condition|)
block|{
comment|// 1. OB Expr sanity test
comment|// in strict mode, in the presence of order by, limit must be
comment|// specified
name|Integer
name|limit
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestLimit
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|limit
operator|==
literal|null
condition|)
block|{
name|String
name|error
init|=
name|StrictChecks
operator|.
name|checkNoLimit
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|SemanticAnalyzer
operator|.
name|generateErrorMessage
argument_list|(
name|obAST
argument_list|,
name|error
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// 2. Walk through OB exprs and extract field collations and additional
comment|// virtual columns needed
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|newVCLst
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|fieldCollations
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|int
name|fieldIndex
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|obASTExprLst
init|=
name|obAST
operator|.
name|getChildren
argument_list|()
decl_stmt|;
name|ASTNode
name|obASTExpr
decl_stmt|;
name|ASTNode
name|nullObASTExpr
decl_stmt|;
name|List
argument_list|<
name|Pair
argument_list|<
name|ASTNode
argument_list|,
name|TypeInfo
argument_list|>
argument_list|>
name|vcASTTypePairs
init|=
operator|new
name|ArrayList
argument_list|<
name|Pair
argument_list|<
name|ASTNode
argument_list|,
name|TypeInfo
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|RowResolver
name|inputRR
init|=
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
name|RowResolver
name|outputRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|RexNode
name|rnd
decl_stmt|;
name|RexNodeConverter
name|converter
init|=
operator|new
name|RexNodeConverter
argument_list|(
name|cluster
argument_list|,
name|srcRel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|relToHiveColNameCalcitePosMap
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|srcRelRecordSz
init|=
name|srcRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|obASTExprLst
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// 2.1 Convert AST Expr to ExprNode
name|obASTExpr
operator|=
operator|(
name|ASTNode
operator|)
name|obASTExprLst
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|nullObASTExpr
operator|=
operator|(
name|ASTNode
operator|)
name|obASTExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ASTNode
name|ref
init|=
operator|(
name|ASTNode
operator|)
name|nullObASTExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
name|astToExprNDescMap
init|=
literal|null
decl_stmt|;
name|ExprNodeDesc
name|obExprNDesc
init|=
literal|null
decl_stmt|;
name|boolean
name|isBothByPos
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_GROUPBY_ORDERBY_POSITION_ALIAS
argument_list|)
decl_stmt|;
name|boolean
name|isObyByPos
init|=
name|isBothByPos
operator|||
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_ORDERBY_POSITION_ALIAS
argument_list|)
decl_stmt|;
comment|// replace each of the position alias in ORDERBY with the actual column
if|if
condition|(
name|ref
operator|!=
literal|null
operator|&&
name|ref
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|Number
condition|)
block|{
if|if
condition|(
name|isObyByPos
condition|)
block|{
name|int
name|pos
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|ref
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|>
literal|0
operator|&&
name|pos
operator|<=
name|selectOutputRR
operator|.
name|getColumnInfos
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// fieldIndex becomes so simple
comment|// Note that pos starts from 1 while fieldIndex starts from 0;
name|fieldIndex
operator|=
name|pos
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_POSITION_ALIAS_IN_ORDERBY
operator|.
name|getMsg
argument_list|(
literal|"Position alias: "
operator|+
name|pos
operator|+
literal|" does not exist\n"
operator|+
literal|"The Select List is indexed from 1 to "
operator|+
name|selectOutputRR
operator|.
name|getColumnInfos
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// if not using position alias and it is a number.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Using constant number "
operator|+
name|ref
operator|.
name|getText
argument_list|()
operator|+
literal|" in order by. If you try to use position alias when hive.orderby.position.alias is false, the position alias will be ignored."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// first try to get it from select
comment|// in case of udtf, selectOutputRR may be null.
if|if
condition|(
name|selectOutputRR
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|astToExprNDescMap
operator|=
name|genAllExprNodeDesc
argument_list|(
name|ref
argument_list|,
name|selectOutputRR
argument_list|)
expr_stmt|;
name|obExprNDesc
operator|=
name|astToExprNDescMap
operator|.
name|get
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|ex
parameter_list|)
block|{
comment|// we can tolerate this as this is the previous behavior
name|LOG
operator|.
name|debug
argument_list|(
literal|"Can not find column in "
operator|+
name|ref
operator|.
name|getText
argument_list|()
operator|+
literal|". The error msg is "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// then try to get it from all
if|if
condition|(
name|obExprNDesc
operator|==
literal|null
condition|)
block|{
name|astToExprNDescMap
operator|=
name|genAllExprNodeDesc
argument_list|(
name|ref
argument_list|,
name|inputRR
argument_list|)
expr_stmt|;
name|obExprNDesc
operator|=
name|astToExprNDescMap
operator|.
name|get
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|obExprNDesc
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Invalid order by expression: "
operator|+
name|obASTExpr
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
comment|// 2.2 Convert ExprNode to RexNode
name|rnd
operator|=
name|converter
operator|.
name|convert
argument_list|(
name|obExprNDesc
argument_list|)
expr_stmt|;
comment|// 2.3 Determine the index of ob expr in child schema
comment|// NOTE: Calcite can not take compound exprs in OB without it being
comment|// present in the child (& hence we add a child Project Rel)
if|if
condition|(
name|rnd
operator|instanceof
name|RexInputRef
condition|)
block|{
name|fieldIndex
operator|=
operator|(
operator|(
name|RexInputRef
operator|)
name|rnd
operator|)
operator|.
name|getIndex
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|fieldIndex
operator|=
name|srcRelRecordSz
operator|+
name|newVCLst
operator|.
name|size
argument_list|()
expr_stmt|;
name|newVCLst
operator|.
name|add
argument_list|(
name|rnd
argument_list|)
expr_stmt|;
name|vcASTTypePairs
operator|.
name|add
argument_list|(
operator|new
name|Pair
argument_list|<
name|ASTNode
argument_list|,
name|TypeInfo
argument_list|>
argument_list|(
name|ref
argument_list|,
name|obExprNDesc
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 2.4 Determine the Direction of order by
name|RelFieldCollation
operator|.
name|Direction
name|order
init|=
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|DESCENDING
decl_stmt|;
if|if
condition|(
name|obASTExpr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABSORTCOLNAMEASC
condition|)
block|{
name|order
operator|=
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|ASCENDING
expr_stmt|;
block|}
name|RelFieldCollation
operator|.
name|NullDirection
name|nullOrder
decl_stmt|;
if|if
condition|(
name|nullObASTExpr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_NULLS_FIRST
condition|)
block|{
name|nullOrder
operator|=
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|FIRST
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nullObASTExpr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_NULLS_LAST
condition|)
block|{
name|nullOrder
operator|=
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|LAST
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unexpected null ordering option: "
operator|+
name|nullObASTExpr
operator|.
name|getType
argument_list|()
argument_list|)
throw|;
block|}
comment|// 2.5 Add to field collations
name|fieldCollations
operator|.
name|add
argument_list|(
operator|new
name|RelFieldCollation
argument_list|(
name|fieldIndex
argument_list|,
name|order
argument_list|,
name|nullOrder
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 3. Add Child Project Rel if needed, Generate Output RR, input Sel Rel
comment|// for top constraining Sel
name|RelNode
name|obInputRel
init|=
name|srcRel
decl_stmt|;
if|if
condition|(
operator|!
name|newVCLst
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|originalInputRefs
init|=
name|Lists
operator|.
name|transform
argument_list|(
name|srcRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|,
operator|new
name|Function
argument_list|<
name|RelDataTypeField
argument_list|,
name|RexNode
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|apply
parameter_list|(
name|RelDataTypeField
name|input
parameter_list|)
block|{
return|return
operator|new
name|RexInputRef
argument_list|(
name|input
operator|.
name|getIndex
argument_list|()
argument_list|,
name|input
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|RowResolver
name|obSyntheticProjectRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|RowResolver
operator|.
name|add
argument_list|(
name|obSyntheticProjectRR
argument_list|,
name|inputRR
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
literal|"Duplicates detected when adding columns to RR: see previous message"
argument_list|,
name|UnsupportedFeature
operator|.
name|Duplicates_in_RR
argument_list|)
throw|;
block|}
name|int
name|vcolPos
init|=
name|inputRR
operator|.
name|getRowSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|ASTNode
argument_list|,
name|TypeInfo
argument_list|>
name|astTypePair
range|:
name|vcASTTypePairs
control|)
block|{
name|obSyntheticProjectRR
operator|.
name|putExpression
argument_list|(
name|astTypePair
operator|.
name|getKey
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|vcolPos
argument_list|)
argument_list|,
name|astTypePair
operator|.
name|getValue
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|vcolPos
operator|++
expr_stmt|;
block|}
name|obInputRel
operator|=
name|genSelectRelNode
argument_list|(
name|CompositeList
operator|.
name|of
argument_list|(
name|originalInputRefs
argument_list|,
name|newVCLst
argument_list|)
argument_list|,
name|obSyntheticProjectRR
argument_list|,
name|srcRel
argument_list|)
expr_stmt|;
if|if
condition|(
name|outermostOB
condition|)
block|{
if|if
condition|(
operator|!
name|RowResolver
operator|.
name|add
argument_list|(
name|outputRR
argument_list|,
name|inputRR
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
literal|"Duplicates detected when adding columns to RR: see previous message"
argument_list|,
name|UnsupportedFeature
operator|.
name|Duplicates_in_RR
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|RowResolver
operator|.
name|add
argument_list|(
name|outputRR
argument_list|,
name|obSyntheticProjectRR
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
literal|"Duplicates detected when adding columns to RR: see previous message"
argument_list|,
name|UnsupportedFeature
operator|.
name|Duplicates_in_RR
argument_list|)
throw|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|RowResolver
operator|.
name|add
argument_list|(
name|outputRR
argument_list|,
name|inputRR
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
literal|"Duplicates detected when adding columns to RR: see previous message"
argument_list|,
name|UnsupportedFeature
operator|.
name|Duplicates_in_RR
argument_list|)
throw|;
block|}
block|}
comment|// 4. Construct SortRel
name|RelTraitSet
name|traitSet
init|=
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRelNode
operator|.
name|CONVENTION
argument_list|)
decl_stmt|;
name|RelCollation
name|canonizedCollation
init|=
name|traitSet
operator|.
name|canonize
argument_list|(
name|RelCollationImpl
operator|.
name|of
argument_list|(
name|fieldCollations
argument_list|)
argument_list|)
decl_stmt|;
name|sortRel
operator|=
operator|new
name|HiveSortLimit
argument_list|(
name|cluster
argument_list|,
name|traitSet
argument_list|,
name|obInputRel
argument_list|,
name|canonizedCollation
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// 5. Update the maps
comment|// NOTE: Output RR for SortRel is considered same as its input; we may
comment|// end up not using VC that is present in sort rel. Also note that
comment|// rowtype of sortrel is the type of it child; if child happens to be
comment|// synthetic project that we introduced then that projectrel would
comment|// contain the vc.
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|hiveColNameCalcitePosMap
init|=
name|buildHiveToCalciteColumnMap
argument_list|(
name|outputRR
argument_list|,
name|sortRel
argument_list|)
decl_stmt|;
name|relToHiveRR
operator|.
name|put
argument_list|(
name|sortRel
argument_list|,
name|outputRR
argument_list|)
expr_stmt|;
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|sortRel
argument_list|,
name|hiveColNameCalcitePosMap
argument_list|)
expr_stmt|;
if|if
condition|(
name|selectOutputRR
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|originalInputRefs
init|=
name|Lists
operator|.
name|transform
argument_list|(
name|srcRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|,
operator|new
name|Function
argument_list|<
name|RelDataTypeField
argument_list|,
name|RexNode
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|apply
parameter_list|(
name|RelDataTypeField
name|input
parameter_list|)
block|{
return|return
operator|new
name|RexInputRef
argument_list|(
name|input
operator|.
name|getIndex
argument_list|()
argument_list|,
name|input
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|selectedRefs
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|selectOutputRR
operator|.
name|getColumnInfos
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|index
operator|++
control|)
block|{
name|selectedRefs
operator|.
name|add
argument_list|(
name|originalInputRefs
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// We need to add select since order by schema may have more columns than result schema.
name|returnRel
operator|=
name|genSelectRelNode
argument_list|(
name|selectedRefs
argument_list|,
name|selectOutputRR
argument_list|,
name|sortRel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|returnRel
operator|=
name|sortRel
expr_stmt|;
block|}
block|}
return|return
name|returnRel
return|;
block|}
specifier|private
name|RelNode
name|genLimitLogicalPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|RelNode
name|srcRel
parameter_list|)
throws|throws
name|SemanticException
block|{
name|HiveRelNode
name|sortRel
init|=
literal|null
decl_stmt|;
name|QBParseInfo
name|qbp
init|=
name|getQBParseInfo
argument_list|(
name|qb
argument_list|)
decl_stmt|;
name|SimpleEntry
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|entry
init|=
name|qbp
operator|.
name|getDestToLimit
argument_list|()
operator|.
name|get
argument_list|(
name|qbp
operator|.
name|getClauseNames
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
name|Integer
name|offset
init|=
operator|(
name|entry
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Integer
name|fetch
init|=
operator|(
name|entry
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|fetch
operator|!=
literal|null
condition|)
block|{
name|RexNode
name|offsetRN
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|offset
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|fetchRN
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|fetch
argument_list|)
argument_list|)
decl_stmt|;
name|RelTraitSet
name|traitSet
init|=
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRelNode
operator|.
name|CONVENTION
argument_list|)
decl_stmt|;
name|RelCollation
name|canonizedCollation
init|=
name|traitSet
operator|.
name|canonize
argument_list|(
name|RelCollations
operator|.
name|EMPTY
argument_list|)
decl_stmt|;
name|sortRel
operator|=
operator|new
name|HiveSortLimit
argument_list|(
name|cluster
argument_list|,
name|traitSet
argument_list|,
name|srcRel
argument_list|,
name|canonizedCollation
argument_list|,
name|offsetRN
argument_list|,
name|fetchRN
argument_list|)
expr_stmt|;
name|RowResolver
name|inputRR
init|=
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
name|RowResolver
name|outputRR
init|=
name|inputRR
operator|.
name|duplicate
argument_list|()
decl_stmt|;
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|hiveColNameCalcitePosMap
init|=
name|buildHiveToCalciteColumnMap
argument_list|(
name|outputRR
argument_list|,
name|sortRel
argument_list|)
decl_stmt|;
name|relToHiveRR
operator|.
name|put
argument_list|(
name|sortRel
argument_list|,
name|outputRR
argument_list|)
expr_stmt|;
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|sortRel
argument_list|,
name|hiveColNameCalcitePosMap
argument_list|)
expr_stmt|;
block|}
return|return
name|sortRel
return|;
block|}
specifier|private
name|List
argument_list|<
name|RexNode
argument_list|>
name|getPartitionKeys
parameter_list|(
name|PartitionSpec
name|ps
parameter_list|,
name|RexNodeConverter
name|converter
parameter_list|,
name|RowResolver
name|inputRR
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|pKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|ps
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|PartitionExpression
argument_list|>
name|pExprs
init|=
name|ps
operator|.
name|getExpressions
argument_list|()
decl_stmt|;
for|for
control|(
name|PartitionExpression
name|pExpr
range|:
name|pExprs
control|)
block|{
name|TypeCheckCtx
name|tcCtx
init|=
operator|new
name|TypeCheckCtx
argument_list|(
name|inputRR
argument_list|)
decl_stmt|;
name|tcCtx
operator|.
name|setAllowStatefulFunctions
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|exp
init|=
name|genExprNodeDesc
argument_list|(
name|pExpr
operator|.
name|getExpression
argument_list|()
argument_list|,
name|inputRR
argument_list|,
name|tcCtx
argument_list|)
decl_stmt|;
name|pKeys
operator|.
name|add
argument_list|(
name|converter
operator|.
name|convert
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|pKeys
return|;
block|}
specifier|private
name|List
argument_list|<
name|RexFieldCollation
argument_list|>
name|getOrderKeys
parameter_list|(
name|OrderSpec
name|os
parameter_list|,
name|RexNodeConverter
name|converter
parameter_list|,
name|RowResolver
name|inputRR
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|RexFieldCollation
argument_list|>
name|oKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|RexFieldCollation
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|os
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|OrderExpression
argument_list|>
name|oExprs
init|=
name|os
operator|.
name|getExpressions
argument_list|()
decl_stmt|;
for|for
control|(
name|OrderExpression
name|oExpr
range|:
name|oExprs
control|)
block|{
name|TypeCheckCtx
name|tcCtx
init|=
operator|new
name|TypeCheckCtx
argument_list|(
name|inputRR
argument_list|)
decl_stmt|;
name|tcCtx
operator|.
name|setAllowStatefulFunctions
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|exp
init|=
name|genExprNodeDesc
argument_list|(
name|oExpr
operator|.
name|getExpression
argument_list|()
argument_list|,
name|inputRR
argument_list|,
name|tcCtx
argument_list|)
decl_stmt|;
name|RexNode
name|ordExp
init|=
name|converter
operator|.
name|convert
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|SqlKind
argument_list|>
name|flags
init|=
operator|new
name|HashSet
argument_list|<
name|SqlKind
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|oExpr
operator|.
name|getOrder
argument_list|()
operator|==
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|Order
operator|.
name|DESC
condition|)
block|{
name|flags
operator|.
name|add
argument_list|(
name|SqlKind
operator|.
name|DESCENDING
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oExpr
operator|.
name|getNullOrder
argument_list|()
operator|==
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|NullOrder
operator|.
name|NULLS_FIRST
condition|)
block|{
name|flags
operator|.
name|add
argument_list|(
name|SqlKind
operator|.
name|NULLS_FIRST
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oExpr
operator|.
name|getNullOrder
argument_list|()
operator|==
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|NullOrder
operator|.
name|NULLS_LAST
condition|)
block|{
name|flags
operator|.
name|add
argument_list|(
name|SqlKind
operator|.
name|NULLS_LAST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unexpected null ordering option: "
operator|+
name|oExpr
operator|.
name|getNullOrder
argument_list|()
argument_list|)
throw|;
block|}
name|oKeys
operator|.
name|add
argument_list|(
operator|new
name|RexFieldCollation
argument_list|(
name|ordExp
argument_list|,
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|oKeys
return|;
block|}
specifier|private
name|RexWindowBound
name|getBound
parameter_list|(
name|BoundarySpec
name|bs
parameter_list|,
name|RexNodeConverter
name|converter
parameter_list|)
block|{
name|RexWindowBound
name|rwb
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|bs
operator|!=
literal|null
condition|)
block|{
name|SqlParserPos
name|pos
init|=
operator|new
name|SqlParserPos
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|SqlNode
name|amt
init|=
name|bs
operator|.
name|getAmt
argument_list|()
operator|==
literal|0
condition|?
literal|null
else|:
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|bs
operator|.
name|getAmt
argument_list|()
argument_list|)
argument_list|,
operator|new
name|SqlParserPos
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|amtLiteral
init|=
literal|null
decl_stmt|;
name|SqlCall
name|sc
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|amt
operator|!=
literal|null
condition|)
name|amtLiteral
operator|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeLiteral
argument_list|(
operator|new
name|Integer
argument_list|(
name|bs
operator|.
name|getAmt
argument_list|()
argument_list|)
argument_list|,
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bs
operator|.
name|getDirection
argument_list|()
condition|)
block|{
case|case
name|PRECEDING
case|:
if|if
condition|(
name|amt
operator|==
literal|null
condition|)
block|{
name|rwb
operator|=
name|RexWindowBound
operator|.
name|create
argument_list|(
name|SqlWindow
operator|.
name|createUnboundedPreceding
argument_list|(
name|pos
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|=
operator|(
name|SqlCall
operator|)
name|SqlWindow
operator|.
name|createPreceding
argument_list|(
name|amt
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|rwb
operator|=
name|RexWindowBound
operator|.
name|create
argument_list|(
name|sc
argument_list|,
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|sc
operator|.
name|getOperator
argument_list|()
argument_list|,
name|amtLiteral
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CURRENT
case|:
name|rwb
operator|=
name|RexWindowBound
operator|.
name|create
argument_list|(
name|SqlWindow
operator|.
name|createCurrentRow
argument_list|(
operator|new
name|SqlParserPos
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
break|break;
case|case
name|FOLLOWING
case|:
if|if
condition|(
name|amt
operator|==
literal|null
condition|)
block|{
name|rwb
operator|=
name|RexWindowBound
operator|.
name|create
argument_list|(
name|SqlWindow
operator|.
name|createUnboundedFollowing
argument_list|(
operator|new
name|SqlParserPos
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|=
operator|(
name|SqlCall
operator|)
name|SqlWindow
operator|.
name|createFollowing
argument_list|(
name|amt
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|rwb
operator|=
name|RexWindowBound
operator|.
name|create
argument_list|(
name|sc
argument_list|,
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|sc
operator|.
name|getOperator
argument_list|()
argument_list|,
name|amtLiteral
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|rwb
return|;
block|}
specifier|private
name|int
name|getWindowSpecIndx
parameter_list|(
name|ASTNode
name|wndAST
parameter_list|)
block|{
name|int
name|wi
init|=
name|wndAST
operator|.
name|getChildCount
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|wi
operator|<=
literal|0
operator|||
operator|(
name|wndAST
operator|.
name|getChild
argument_list|(
name|wi
argument_list|)
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_WINDOWSPEC
operator|)
condition|)
block|{
name|wi
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|wi
return|;
block|}
specifier|private
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|TypeInfo
argument_list|>
name|genWindowingProj
parameter_list|(
name|QB
name|qb
parameter_list|,
name|WindowExpressionSpec
name|wExpSpec
parameter_list|,
name|RelNode
name|srcRel
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RexNode
name|w
init|=
literal|null
decl_stmt|;
name|TypeInfo
name|wHiveRetType
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|wExpSpec
operator|instanceof
name|WindowFunctionSpec
condition|)
block|{
name|WindowFunctionSpec
name|wFnSpec
init|=
operator|(
name|WindowFunctionSpec
operator|)
name|wExpSpec
decl_stmt|;
name|ASTNode
name|windowProjAst
init|=
name|wFnSpec
operator|.
name|getExpression
argument_list|()
decl_stmt|;
comment|// TODO: do we need to get to child?
name|int
name|wndSpecASTIndx
init|=
name|getWindowSpecIndx
argument_list|(
name|windowProjAst
argument_list|)
decl_stmt|;
comment|// 2. Get Hive Aggregate Info
name|AggInfo
name|hiveAggInfo
init|=
name|getHiveAggInfo
argument_list|(
name|windowProjAst
argument_list|,
name|wndSpecASTIndx
operator|-
literal|1
argument_list|,
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
argument_list|)
decl_stmt|;
comment|// 3. Get Calcite Return type for Agg Fn
name|wHiveRetType
operator|=
name|hiveAggInfo
operator|.
name|m_returnType
expr_stmt|;
name|RelDataType
name|calciteAggFnRetType
init|=
name|TypeConverter
operator|.
name|convert
argument_list|(
name|hiveAggInfo
operator|.
name|m_returnType
argument_list|,
name|this
operator|.
name|cluster
operator|.
name|getTypeFactory
argument_list|()
argument_list|)
decl_stmt|;
comment|// 4. Convert Agg Fn args to Calcite
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|posMap
init|=
name|this
operator|.
name|relToHiveColNameCalcitePosMap
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
name|RexNodeConverter
name|converter
init|=
operator|new
name|RexNodeConverter
argument_list|(
name|this
operator|.
name|cluster
argument_list|,
name|srcRel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|posMap
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|calciteAggFnArgsBldr
init|=
name|ImmutableList
operator|.
expr|<
name|RexNode
operator|>
name|builder
argument_list|()
decl_stmt|;
name|Builder
argument_list|<
name|RelDataType
argument_list|>
name|calciteAggFnArgsTypeBldr
init|=
name|ImmutableList
operator|.
expr|<
name|RelDataType
operator|>
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hiveAggInfo
operator|.
name|m_aggParams
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|calciteAggFnArgsBldr
operator|.
name|add
argument_list|(
name|converter
operator|.
name|convert
argument_list|(
name|hiveAggInfo
operator|.
name|m_aggParams
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|calciteAggFnArgsTypeBldr
operator|.
name|add
argument_list|(
name|TypeConverter
operator|.
name|convert
argument_list|(
name|hiveAggInfo
operator|.
name|m_aggParams
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|this
operator|.
name|cluster
operator|.
name|getTypeFactory
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|calciteAggFnArgs
init|=
name|calciteAggFnArgsBldr
operator|.
name|build
argument_list|()
decl_stmt|;
name|ImmutableList
argument_list|<
name|RelDataType
argument_list|>
name|calciteAggFnArgsType
init|=
name|calciteAggFnArgsTypeBldr
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// 5. Get Calcite Agg Fn
specifier|final
name|SqlAggFunction
name|calciteAggFn
init|=
name|SqlFunctionConverter
operator|.
name|getCalciteAggFn
argument_list|(
name|hiveAggInfo
operator|.
name|m_udfName
argument_list|,
name|hiveAggInfo
operator|.
name|m_distinct
argument_list|,
name|calciteAggFnArgsType
argument_list|,
name|calciteAggFnRetType
argument_list|)
decl_stmt|;
comment|// 6. Translate Window spec
name|RowResolver
name|inputRR
init|=
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
name|WindowSpec
name|wndSpec
init|=
operator|(
operator|(
name|WindowFunctionSpec
operator|)
name|wExpSpec
operator|)
operator|.
name|getWindowSpec
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|partitionKeys
init|=
name|getPartitionKeys
argument_list|(
name|wndSpec
operator|.
name|getPartition
argument_list|()
argument_list|,
name|converter
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RexFieldCollation
argument_list|>
name|orderKeys
init|=
name|getOrderKeys
argument_list|(
name|wndSpec
operator|.
name|getOrder
argument_list|()
argument_list|,
name|converter
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|RexWindowBound
name|upperBound
init|=
name|getBound
argument_list|(
name|wndSpec
operator|.
name|getWindowFrame
argument_list|()
operator|.
name|getStart
argument_list|()
argument_list|,
name|converter
argument_list|)
decl_stmt|;
name|RexWindowBound
name|lowerBound
init|=
name|getBound
argument_list|(
name|wndSpec
operator|.
name|getWindowFrame
argument_list|()
operator|.
name|getEnd
argument_list|()
argument_list|,
name|converter
argument_list|)
decl_stmt|;
name|boolean
name|isRows
init|=
name|wndSpec
operator|.
name|getWindowFrame
argument_list|()
operator|.
name|getWindowType
argument_list|()
operator|==
name|WindowType
operator|.
name|ROWS
decl_stmt|;
name|w
operator|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeOver
argument_list|(
name|calciteAggFnRetType
argument_list|,
name|calciteAggFn
argument_list|,
name|calciteAggFnArgs
argument_list|,
name|partitionKeys
argument_list|,
name|ImmutableList
operator|.
expr|<
name|RexFieldCollation
operator|>
name|copyOf
argument_list|(
name|orderKeys
argument_list|)
argument_list|,
name|lowerBound
argument_list|,
name|upperBound
argument_list|,
name|isRows
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
name|hiveAggInfo
operator|.
name|m_distinct
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// TODO: Convert to Semantic Exception
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unsupported window Spec"
argument_list|)
throw|;
block|}
return|return
operator|new
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|TypeInfo
argument_list|>
argument_list|(
name|w
argument_list|,
name|wHiveRetType
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|genSelectForWindowing
parameter_list|(
name|QB
name|qb
parameter_list|,
name|RelNode
name|srcRel
parameter_list|,
name|HashSet
argument_list|<
name|ColumnInfo
argument_list|>
name|newColumns
parameter_list|)
throws|throws
name|SemanticException
block|{
name|getQBParseInfo
argument_list|(
name|qb
argument_list|)
expr_stmt|;
name|WindowingSpec
name|wSpec
init|=
operator|(
operator|!
name|qb
operator|.
name|getAllWindowingSpecs
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
name|qb
operator|.
name|getAllWindowingSpecs
argument_list|()
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|wSpec
operator|==
literal|null
condition|)
return|return
literal|null
return|;
comment|// 1. Get valid Window Function Spec
name|wSpec
operator|.
name|validateAndMakeEffective
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|WindowExpressionSpec
argument_list|>
name|windowExpressions
init|=
name|wSpec
operator|.
name|getWindowExpressions
argument_list|()
decl_stmt|;
if|if
condition|(
name|windowExpressions
operator|==
literal|null
operator|||
name|windowExpressions
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|null
return|;
name|RowResolver
name|inputRR
init|=
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
comment|// 2. Get RexNodes for original Projections from below
name|List
argument_list|<
name|RexNode
argument_list|>
name|projsForWindowSelOp
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|(
name|HiveCalciteUtil
operator|.
name|getProjsFromBelowAsInputRef
argument_list|(
name|srcRel
argument_list|)
argument_list|)
decl_stmt|;
comment|// 3. Construct new Row Resolver with everything from below.
name|RowResolver
name|out_rwsch
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|RowResolver
operator|.
name|add
argument_list|(
name|out_rwsch
argument_list|,
name|inputRR
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Duplicates detected when adding columns to RR: see previous message"
argument_list|)
expr_stmt|;
block|}
comment|// 4. Walk through Window Expressions& Construct RexNodes for those,
comment|// Update out_rwsch
specifier|final
name|QBParseInfo
name|qbp
init|=
name|getQBParseInfo
argument_list|(
name|qb
argument_list|)
decl_stmt|;
specifier|final
name|String
name|selClauseName
init|=
name|qbp
operator|.
name|getClauseNames
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|cubeRollupGrpSetPresent
init|=
operator|(
operator|!
name|qbp
operator|.
name|getDestRollups
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|qbp
operator|.
name|getDestGroupingSets
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|qbp
operator|.
name|getDestCubes
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
decl_stmt|;
for|for
control|(
name|WindowExpressionSpec
name|wExprSpec
range|:
name|windowExpressions
control|)
block|{
if|if
condition|(
operator|!
name|qbp
operator|.
name|getDestToGroupBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Special handling of grouping function
name|wExprSpec
operator|.
name|setExpression
argument_list|(
name|rewriteGroupingFunctionAST
argument_list|(
name|getGroupByForClause
argument_list|(
name|qbp
argument_list|,
name|selClauseName
argument_list|)
argument_list|,
name|wExprSpec
operator|.
name|getExpression
argument_list|()
argument_list|,
operator|!
name|cubeRollupGrpSetPresent
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|out_rwsch
operator|.
name|getExpression
argument_list|(
name|wExprSpec
operator|.
name|getExpression
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|TypeInfo
argument_list|>
name|wtp
init|=
name|genWindowingProj
argument_list|(
name|qb
argument_list|,
name|wExprSpec
argument_list|,
name|srcRel
argument_list|)
decl_stmt|;
name|projsForWindowSelOp
operator|.
name|add
argument_list|(
name|wtp
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
comment|// 6.2.2 Update Output Row Schema
name|ColumnInfo
name|oColInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|projsForWindowSelOp
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|wtp
operator|.
name|getValue
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|out_rwsch
operator|.
name|putExpression
argument_list|(
name|wExprSpec
operator|.
name|getExpression
argument_list|()
argument_list|,
name|oColInfo
argument_list|)
expr_stmt|;
name|newColumns
operator|.
name|add
argument_list|(
name|oColInfo
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|genSelectRelNode
argument_list|(
name|projsForWindowSelOp
argument_list|,
name|out_rwsch
argument_list|,
name|srcRel
argument_list|,
name|windowExpressions
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|genSelectRelNode
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|calciteColLst
parameter_list|,
name|RowResolver
name|out_rwsch
parameter_list|,
name|RelNode
name|srcRel
parameter_list|)
throws|throws
name|CalciteSemanticException
block|{
return|return
name|genSelectRelNode
argument_list|(
name|calciteColLst
argument_list|,
name|out_rwsch
argument_list|,
name|srcRel
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|genSelectRelNode
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|calciteColLst
parameter_list|,
name|RowResolver
name|out_rwsch
parameter_list|,
name|RelNode
name|srcRel
parameter_list|,
name|List
argument_list|<
name|WindowExpressionSpec
argument_list|>
name|windowExpressions
parameter_list|)
throws|throws
name|CalciteSemanticException
block|{
comment|// 1. Build Column Names
name|Set
argument_list|<
name|String
argument_list|>
name|colNamesSet
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ColumnInfo
argument_list|>
name|cInfoLst
init|=
name|out_rwsch
operator|.
name|getRowSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|columnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|windowToAlias
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|windowExpressions
operator|!=
literal|null
condition|)
block|{
name|windowToAlias
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|WindowExpressionSpec
name|wes
range|:
name|windowExpressions
control|)
block|{
name|windowToAlias
operator|.
name|put
argument_list|(
name|wes
operator|.
name|getExpression
argument_list|()
operator|.
name|toStringTree
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|wes
operator|.
name|getAlias
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|String
index|[]
name|qualifiedColNames
decl_stmt|;
name|String
name|tmpColAlias
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|calciteColLst
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ColumnInfo
name|cInfo
init|=
name|cInfoLst
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|qualifiedColNames
operator|=
name|out_rwsch
operator|.
name|reverseLookup
argument_list|(
name|cInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
comment|/*          * if (qualifiedColNames[0] != null&& !qualifiedColNames[0].isEmpty())          * tmpColAlias = qualifiedColNames[0] + "." + qualifiedColNames[1]; else          */
name|tmpColAlias
operator|=
name|qualifiedColNames
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|tmpColAlias
operator|.
name|contains
argument_list|(
literal|"."
argument_list|)
operator|||
name|tmpColAlias
operator|.
name|contains
argument_list|(
literal|":"
argument_list|)
condition|)
block|{
name|tmpColAlias
operator|=
name|cInfo
operator|.
name|getInternalName
argument_list|()
expr_stmt|;
block|}
comment|// Prepend column names with '_o_' if it starts with '_c'
comment|/*          * Hive treats names that start with '_c' as internalNames; so change          * the names so we don't run into this issue when converting back to          * Hive AST.          */
if|if
condition|(
name|tmpColAlias
operator|.
name|startsWith
argument_list|(
literal|"_c"
argument_list|)
condition|)
block|{
name|tmpColAlias
operator|=
literal|"_o_"
operator|+
name|tmpColAlias
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|windowToAlias
operator|!=
literal|null
operator|&&
name|windowToAlias
operator|.
name|containsKey
argument_list|(
name|tmpColAlias
argument_list|)
condition|)
block|{
name|tmpColAlias
operator|=
name|windowToAlias
operator|.
name|get
argument_list|(
name|tmpColAlias
argument_list|)
expr_stmt|;
block|}
name|int
name|suffix
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|colNamesSet
operator|.
name|contains
argument_list|(
name|tmpColAlias
argument_list|)
condition|)
block|{
name|tmpColAlias
operator|=
name|qualifiedColNames
index|[
literal|1
index|]
operator|+
name|suffix
expr_stmt|;
name|suffix
operator|++
expr_stmt|;
block|}
name|colNamesSet
operator|.
name|add
argument_list|(
name|tmpColAlias
argument_list|)
expr_stmt|;
name|columnNames
operator|.
name|add
argument_list|(
name|tmpColAlias
argument_list|)
expr_stmt|;
block|}
comment|// 3 Build Calcite Rel Node for project using converted projections& col
comment|// names
name|HiveRelNode
name|selRel
init|=
name|HiveProject
operator|.
name|create
argument_list|(
name|srcRel
argument_list|,
name|calciteColLst
argument_list|,
name|columnNames
argument_list|)
decl_stmt|;
comment|// 4. Keep track of colname-to-posmap&& RR for new select
name|this
operator|.
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|selRel
argument_list|,
name|buildHiveToCalciteColumnMap
argument_list|(
name|out_rwsch
argument_list|,
name|selRel
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|relToHiveRR
operator|.
name|put
argument_list|(
name|selRel
argument_list|,
name|out_rwsch
argument_list|)
expr_stmt|;
return|return
name|selRel
return|;
block|}
specifier|private
name|void
name|setQueryHints
parameter_list|(
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|qbp
init|=
name|getQBParseInfo
argument_list|(
name|qb
argument_list|)
decl_stmt|;
name|String
name|selClauseName
init|=
name|qbp
operator|.
name|getClauseNames
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|Tree
name|selExpr0
init|=
name|qbp
operator|.
name|getSelForClause
argument_list|(
name|selClauseName
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|selExpr0
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|QUERY_HINT
condition|)
return|return;
name|String
name|hint
init|=
name|ctx
operator|.
name|getTokenRewriteStream
argument_list|()
operator|.
name|toString
argument_list|(
name|selExpr0
operator|.
name|getTokenStartIndex
argument_list|()
argument_list|,
name|selExpr0
operator|.
name|getTokenStopIndex
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Handling query hints: "
operator|+
name|hint
argument_list|)
expr_stmt|;
name|ParseDriver
name|pd
init|=
operator|new
name|ParseDriver
argument_list|()
decl_stmt|;
try|try
block|{
name|ASTNode
name|hintNode
init|=
name|pd
operator|.
name|parseHint
argument_list|(
name|hint
argument_list|)
decl_stmt|;
name|qbp
operator|.
name|setHints
argument_list|(
name|hintNode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"failed to parse query hint: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * NOTE: there can only be one select caluse since we don't handle multi      * destination insert.      *      * @throws SemanticException      */
comment|/**      * @param qb      * @param srcRel      * @param starSrcRel      * @param outerNameToPosMap      * @param outerRR      * @param isAllColRefRewrite      *          when it is true, it means that it is called from group by *, where we use      *          genSelectLogicalPlan to rewrite *      * @return RelNode: the select relnode RowResolver: i.e., originalRR, the RR after select when there is an order by.      * @throws SemanticException      */
specifier|private
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|RowResolver
argument_list|>
name|genSelectLogicalPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|RelNode
name|srcRel
parameter_list|,
name|RelNode
name|starSrcRel
parameter_list|,
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|outerNameToPosMap
parameter_list|,
name|RowResolver
name|outerRR
parameter_list|,
name|boolean
name|isAllColRefRewrite
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// 0. Generate a Select Node for Windowing
comment|// Exclude the newly-generated select columns from */etc. resolution.
name|HashSet
argument_list|<
name|ColumnInfo
argument_list|>
name|excludedColumns
init|=
operator|new
name|HashSet
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
name|RelNode
name|selForWindow
init|=
name|genSelectForWindowing
argument_list|(
name|qb
argument_list|,
name|srcRel
argument_list|,
name|excludedColumns
argument_list|)
decl_stmt|;
name|srcRel
operator|=
operator|(
name|selForWindow
operator|==
literal|null
operator|)
condition|?
name|srcRel
else|:
name|selForWindow
expr_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|col_list
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// 1. Get Select Expression List
name|QBParseInfo
name|qbp
init|=
name|getQBParseInfo
argument_list|(
name|qb
argument_list|)
decl_stmt|;
name|String
name|selClauseName
init|=
name|qbp
operator|.
name|getClauseNames
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|ASTNode
name|selExprList
init|=
name|qbp
operator|.
name|getSelForClause
argument_list|(
name|selClauseName
argument_list|)
decl_stmt|;
comment|// make sure if there is subquery it is top level expression
name|SubQueryUtils
operator|.
name|checkForTopLevelSubqueries
argument_list|(
name|selExprList
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|cubeRollupGrpSetPresent
init|=
operator|(
operator|!
name|qbp
operator|.
name|getDestRollups
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|qbp
operator|.
name|getDestGroupingSets
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|qbp
operator|.
name|getDestCubes
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
decl_stmt|;
comment|// 2.Row resolvers for input, output
name|RowResolver
name|out_rwsch
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|Integer
name|pos
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// TODO: will this also fix windowing? try
name|RowResolver
name|inputRR
init|=
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|,
name|starRR
init|=
name|inputRR
decl_stmt|;
name|inputRR
operator|.
name|setCheckForAmbiguity
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|starSrcRel
operator|!=
literal|null
condition|)
block|{
name|starRR
operator|=
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|starSrcRel
argument_list|)
expr_stmt|;
block|}
comment|// 3. Query Hints
comment|// TODO: Handle Query Hints; currently we ignore them
name|boolean
name|selectStar
init|=
literal|false
decl_stmt|;
name|int
name|posn
init|=
literal|0
decl_stmt|;
name|boolean
name|hintPresent
init|=
operator|(
name|selExprList
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|QUERY_HINT
operator|)
decl_stmt|;
if|if
condition|(
name|hintPresent
condition|)
block|{
name|posn
operator|++
expr_stmt|;
block|}
comment|// 4. Bailout if select involves Transform
name|boolean
name|isInTransform
init|=
operator|(
name|selExprList
operator|.
name|getChild
argument_list|(
name|posn
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TRANSFORM
operator|)
decl_stmt|;
if|if
condition|(
name|isInTransform
condition|)
block|{
name|String
name|msg
init|=
name|String
operator|.
name|format
argument_list|(
literal|"SELECT TRANSFORM is currently not supported in CBO,"
operator|+
literal|" turn off cbo to use TRANSFORM."
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
name|msg
argument_list|,
name|UnsupportedFeature
operator|.
name|Select_transform
argument_list|)
throw|;
block|}
comment|// 5. Check if select involves UDTF
name|String
name|udtfTableAlias
init|=
literal|null
decl_stmt|;
name|GenericUDTF
name|genericUDTF
init|=
literal|null
decl_stmt|;
name|String
name|genericUDTFName
init|=
literal|null
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|udtfColAliases
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ASTNode
name|expr
init|=
operator|(
name|ASTNode
operator|)
name|selExprList
operator|.
name|getChild
argument_list|(
name|posn
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|exprType
init|=
name|expr
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|exprType
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTION
operator|||
name|exprType
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONSTAR
condition|)
block|{
name|String
name|funcName
init|=
name|TypeCheckProcFactory
operator|.
name|DefaultExprProcessor
operator|.
name|getFunctionText
argument_list|(
name|expr
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|FunctionInfo
name|fi
init|=
name|FunctionRegistry
operator|.
name|getFunctionInfo
argument_list|(
name|funcName
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|!=
literal|null
operator|&&
name|fi
operator|.
name|getGenericUDTF
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Find UDTF "
operator|+
name|funcName
argument_list|)
expr_stmt|;
name|genericUDTF
operator|=
name|fi
operator|.
name|getGenericUDTF
argument_list|()
expr_stmt|;
name|genericUDTFName
operator|=
name|funcName
expr_stmt|;
if|if
condition|(
operator|!
name|fi
operator|.
name|isNative
argument_list|()
condition|)
block|{
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
operator|(
name|ASTNode
operator|)
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|genericUDTF
operator|!=
literal|null
operator|&&
operator|(
name|selectStar
operator|=
name|exprType
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONSTAR
operator|)
condition|)
block|{
name|genColListRegex
argument_list|(
literal|".*"
argument_list|,
literal|null
argument_list|,
operator|(
name|ASTNode
operator|)
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|col_list
argument_list|,
literal|null
argument_list|,
name|inputRR
argument_list|,
name|starRR
argument_list|,
name|pos
argument_list|,
name|out_rwsch
argument_list|,
name|qb
operator|.
name|getAliases
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|genericUDTF
operator|!=
literal|null
condition|)
block|{
comment|// Only support a single expression when it's a UDTF
if|if
condition|(
name|selExprList
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
operator|(
name|ASTNode
operator|)
name|selExprList
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|,
name|ErrorMsg
operator|.
name|UDTF_MULTIPLE_EXPR
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|ASTNode
name|selExpr
init|=
operator|(
name|ASTNode
operator|)
name|selExprList
operator|.
name|getChild
argument_list|(
name|posn
argument_list|)
decl_stmt|;
comment|// Get the column / table aliases from the expression. Start from 1 as
comment|// 0 is the TOK_FUNCTION
comment|// column names also can be inferred from result of UDTF
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|selExpr
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|selExprChild
init|=
operator|(
name|ASTNode
operator|)
name|selExpr
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|selExprChild
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|Identifier
case|:
name|udtfColAliases
operator|.
name|add
argument_list|(
name|unescapeIdentifier
argument_list|(
name|selExprChild
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
name|selExprChild
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABALIAS
case|:
assert|assert
operator|(
name|selExprChild
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
operator|)
assert|;
name|udtfTableAlias
operator|=
name|unescapeIdentifier
argument_list|(
name|selExprChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|qb
operator|.
name|addAlias
argument_list|(
name|udtfTableAlias
argument_list|)
expr_stmt|;
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
operator|(
name|ASTNode
operator|)
name|selExprChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Find invalid token type "
operator|+
name|selExprChild
operator|.
name|getType
argument_list|()
operator|+
literal|" in UDTF."
argument_list|)
throw|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"UDTF table alias is "
operator|+
name|udtfTableAlias
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"UDTF col aliases are "
operator|+
name|udtfColAliases
argument_list|)
expr_stmt|;
block|}
comment|// 6. Iterate over all expression (after SELECT)
name|ASTNode
name|exprList
decl_stmt|;
if|if
condition|(
name|genericUDTF
operator|!=
literal|null
condition|)
block|{
name|exprList
operator|=
name|expr
expr_stmt|;
block|}
else|else
block|{
name|exprList
operator|=
name|selExprList
expr_stmt|;
block|}
comment|// For UDTF's, skip the function name to get the expressions
name|int
name|startPosn
init|=
name|genericUDTF
operator|!=
literal|null
condition|?
name|posn
operator|+
literal|1
else|:
name|posn
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|startPosn
init|;
name|i
operator|<
name|exprList
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|// 6.1 child can be EXPR AS ALIAS, or EXPR.
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|exprList
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|boolean
name|hasAsClause
init|=
operator|(
operator|!
name|isInTransform
operator|)
operator|&&
operator|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
operator|)
decl_stmt|;
comment|// 6.2 EXPR AS (ALIAS,...) parses, but is only allowed for UDTF's
comment|// This check is not needed and invalid when there is a transform b/c
comment|// the
comment|// AST's are slightly different.
if|if
condition|(
name|genericUDTF
operator|==
literal|null
operator|&&
name|child
operator|.
name|getChildCount
argument_list|()
operator|>
literal|2
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|SemanticAnalyzer
operator|.
name|generateErrorMessage
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
argument_list|,
name|ErrorMsg
operator|.
name|INVALID_AS
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|tabAlias
decl_stmt|;
name|String
name|colAlias
decl_stmt|;
if|if
condition|(
name|genericUDTF
operator|!=
literal|null
condition|)
block|{
name|tabAlias
operator|=
literal|null
expr_stmt|;
name|colAlias
operator|=
name|getAutogenColAliasPrfxLbl
argument_list|()
operator|+
name|i
expr_stmt|;
name|expr
operator|=
name|child
expr_stmt|;
block|}
else|else
block|{
comment|// 6.3 Get rid of TOK_SELEXPR
name|expr
operator|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|String
index|[]
name|colRef
init|=
name|SemanticAnalyzer
operator|.
name|getColAlias
argument_list|(
name|child
argument_list|,
name|getAutogenColAliasPrfxLbl
argument_list|()
argument_list|,
name|inputRR
argument_list|,
name|autogenColAliasPrfxIncludeFuncName
argument_list|()
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tabAlias
operator|=
name|colRef
index|[
literal|0
index|]
expr_stmt|;
name|colAlias
operator|=
name|colRef
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hasAsClause
condition|)
block|{
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|RelNode
argument_list|>
name|subQueryToRelNode
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|boolean
name|isSubQuery
init|=
name|genSubQueryRelNode
argument_list|(
name|qb
argument_list|,
name|expr
argument_list|,
name|srcRel
argument_list|,
literal|false
argument_list|,
name|subQueryToRelNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|isSubQuery
condition|)
block|{
name|ExprNodeDesc
name|subQueryExpr
init|=
name|genExprNodeDesc
argument_list|(
name|expr
argument_list|,
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
argument_list|,
name|outerRR
argument_list|,
name|subQueryToRelNode
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|col_list
operator|.
name|add
argument_list|(
name|subQueryExpr
argument_list|)
expr_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|pos
argument_list|)
argument_list|,
name|subQueryExpr
operator|.
name|getWritableObjectInspector
argument_list|()
argument_list|,
name|tabAlias
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|out_rwsch
operator|.
name|putWithCheck
argument_list|(
name|tabAlias
argument_list|,
name|colAlias
argument_list|,
literal|null
argument_list|,
name|colInfo
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
literal|"Cannot add column to RR: "
operator|+
name|tabAlias
operator|+
literal|"."
operator|+
name|colAlias
operator|+
literal|" => "
operator|+
name|colInfo
operator|+
literal|" due to duplication, see previous warnings"
argument_list|,
name|UnsupportedFeature
operator|.
name|Duplicates_in_RR
argument_list|)
throw|;
block|}
name|pos
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|pos
operator|.
name|intValue
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// 6.4 Build ExprNode corresponding to colums
if|if
condition|(
name|expr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALLCOLREF
condition|)
block|{
name|pos
operator|=
name|genColListRegex
argument_list|(
literal|".*"
argument_list|,
name|expr
operator|.
name|getChildCount
argument_list|()
operator|==
literal|0
condition|?
literal|null
else|:
name|SemanticAnalyzer
operator|.
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|expr
argument_list|,
name|col_list
argument_list|,
name|excludedColumns
argument_list|,
name|inputRR
argument_list|,
name|starRR
argument_list|,
name|pos
argument_list|,
name|out_rwsch
argument_list|,
name|qb
operator|.
name|getAliases
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|selectStar
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
operator|&&
operator|!
name|hasAsClause
operator|&&
operator|!
name|inputRR
operator|.
name|getIsExprResolver
argument_list|()
operator|&&
name|SemanticAnalyzer
operator|.
name|isRegex
argument_list|(
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
name|conf
argument_list|)
condition|)
block|{
comment|// In case the expression is a regex COL.
comment|// This can only happen without AS clause
comment|// We don't allow this for ExprResolver - the Group By case
name|pos
operator|=
name|genColListRegex
argument_list|(
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|,
name|expr
argument_list|,
name|col_list
argument_list|,
name|excludedColumns
argument_list|,
name|inputRR
argument_list|,
name|starRR
argument_list|,
name|pos
argument_list|,
name|out_rwsch
argument_list|,
name|qb
operator|.
name|getAliases
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|DOT
operator|&&
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
operator|&&
name|inputRR
operator|.
name|hasTableAlias
argument_list|(
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|)
operator|&&
operator|!
name|hasAsClause
operator|&&
operator|!
name|inputRR
operator|.
name|getIsExprResolver
argument_list|()
operator|&&
name|SemanticAnalyzer
operator|.
name|isRegex
argument_list|(
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
name|conf
argument_list|)
condition|)
block|{
comment|// In case the expression is TABLE.COL (col can be regex).
comment|// This can only happen without AS clause
comment|// We don't allow this for ExprResolver - the Group By case
name|pos
operator|=
name|genColListRegex
argument_list|(
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|expr
argument_list|,
name|col_list
argument_list|,
name|excludedColumns
argument_list|,
name|inputRR
argument_list|,
name|starRR
argument_list|,
name|pos
argument_list|,
name|out_rwsch
argument_list|,
name|qb
operator|.
name|getAliases
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ParseUtils
operator|.
name|containsTokenOfType
argument_list|(
name|expr
argument_list|,
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
argument_list|)
operator|&&
operator|!
operator|(
name|srcRel
operator|instanceof
name|HiveAggregate
operator|)
condition|)
block|{
comment|// Likely a malformed query eg, select hash(distinct c1) from t1;
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
literal|"Distinct without an aggregation."
argument_list|,
name|UnsupportedFeature
operator|.
name|Distinct_without_an_aggreggation
argument_list|)
throw|;
block|}
else|else
block|{
comment|// Case when this is an expression
name|TypeCheckCtx
name|tcCtx
init|=
operator|new
name|TypeCheckCtx
argument_list|(
name|inputRR
argument_list|)
decl_stmt|;
comment|// We allow stateful functions in the SELECT list (but nowhere else)
name|tcCtx
operator|.
name|setAllowStatefulFunctions
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qbp
operator|.
name|getDestToGroupBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Special handling of grouping function
name|expr
operator|=
name|rewriteGroupingFunctionAST
argument_list|(
name|getGroupByForClause
argument_list|(
name|qbp
argument_list|,
name|selClauseName
argument_list|)
argument_list|,
name|expr
argument_list|,
operator|!
name|cubeRollupGrpSetPresent
argument_list|)
expr_stmt|;
block|}
name|ExprNodeDesc
name|exp
init|=
name|genExprNodeDesc
argument_list|(
name|expr
argument_list|,
name|inputRR
argument_list|,
name|tcCtx
argument_list|)
decl_stmt|;
name|String
name|recommended
init|=
name|recommendName
argument_list|(
name|exp
argument_list|,
name|colAlias
argument_list|)
decl_stmt|;
if|if
condition|(
name|recommended
operator|!=
literal|null
operator|&&
name|out_rwsch
operator|.
name|get
argument_list|(
literal|null
argument_list|,
name|recommended
argument_list|)
operator|==
literal|null
condition|)
block|{
name|colAlias
operator|=
name|recommended
expr_stmt|;
block|}
name|col_list
operator|.
name|add
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|pos
argument_list|)
argument_list|,
name|exp
operator|.
name|getWritableObjectInspector
argument_list|()
argument_list|,
name|tabAlias
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|colInfo
operator|.
name|setSkewedCol
argument_list|(
operator|(
name|exp
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|?
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|exp
operator|)
operator|.
name|isSkewedCol
argument_list|()
else|:
literal|false
argument_list|)
expr_stmt|;
name|out_rwsch
operator|.
name|put
argument_list|(
name|tabAlias
argument_list|,
name|colAlias
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|pos
operator|.
name|intValue
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|selectStar
operator|=
name|selectStar
operator|&&
name|exprList
operator|.
name|getChildCount
argument_list|()
operator|==
name|posn
operator|+
literal|1
expr_stmt|;
comment|// 7. Convert Hive projections to Calcite
name|List
argument_list|<
name|RexNode
argument_list|>
name|calciteColLst
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|RexNodeConverter
name|rexNodeConv
init|=
operator|new
name|RexNodeConverter
argument_list|(
name|cluster
argument_list|,
name|srcRel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|outerNameToPosMap
argument_list|,
name|buildHiveColNameToInputPosMap
argument_list|(
name|col_list
argument_list|,
name|inputRR
argument_list|)
argument_list|,
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
argument_list|,
name|outerRR
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|,
name|subqueryId
argument_list|)
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|colExpr
range|:
name|col_list
control|)
block|{
name|calciteColLst
operator|.
name|add
argument_list|(
name|rexNodeConv
operator|.
name|convert
argument_list|(
name|colExpr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 8. Build Calcite Rel
name|RelNode
name|outputRel
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|genericUDTF
operator|!=
literal|null
condition|)
block|{
comment|// The basic idea for CBO support of UDTF is to treat UDTF as a special
comment|// project.
comment|// In AST return path, as we just need to generate a SEL_EXPR, we just
comment|// need to remember the expressions and the alias.
comment|// In OP return path, we need to generate a SEL and then a UDTF
comment|// following old semantic analyzer.
name|outputRel
operator|=
name|genUDTFPlan
argument_list|(
name|genericUDTF
argument_list|,
name|genericUDTFName
argument_list|,
name|udtfTableAlias
argument_list|,
name|udtfColAliases
argument_list|,
name|qb
argument_list|,
name|calciteColLst
argument_list|,
name|out_rwsch
argument_list|,
name|srcRel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|dest
init|=
name|qbp
operator|.
name|getClauseNames
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|ASTNode
name|obAST
init|=
name|qbp
operator|.
name|getOrderByForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|RowResolver
name|originalRR
init|=
literal|null
decl_stmt|;
comment|// We only support limited unselected column following by order by.
comment|// TODO: support unselected columns in genericUDTF and windowing functions.
comment|// We examine the order by in this query block and adds in column needed
comment|// by order by in select list.
if|if
condition|(
name|obAST
operator|!=
literal|null
operator|&&
operator|!
operator|(
name|selForWindow
operator|!=
literal|null
operator|&&
name|selExprList
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SELECTDI
operator|)
operator|&&
operator|!
name|isAllColRefRewrite
condition|)
block|{
comment|// 1. OB Expr sanity test
comment|// in strict mode, in the presence of order by, limit must be
comment|// specified
name|Integer
name|limit
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestLimit
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|limit
operator|==
literal|null
condition|)
block|{
name|String
name|error
init|=
name|StrictChecks
operator|.
name|checkNoLimit
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|SemanticAnalyzer
operator|.
name|generateErrorMessage
argument_list|(
name|obAST
argument_list|,
name|error
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|List
argument_list|<
name|RexNode
argument_list|>
name|originalInputRefs
init|=
name|Lists
operator|.
name|transform
argument_list|(
name|srcRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|,
operator|new
name|Function
argument_list|<
name|RelDataTypeField
argument_list|,
name|RexNode
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|apply
parameter_list|(
name|RelDataTypeField
name|input
parameter_list|)
block|{
return|return
operator|new
name|RexInputRef
argument_list|(
name|input
operator|.
name|getIndex
argument_list|()
argument_list|,
name|input
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|originalRR
operator|=
name|out_rwsch
operator|.
name|duplicate
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|internalName
init|=
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|out_rwsch
operator|.
name|getColumnInfos
argument_list|()
operator|.
name|size
argument_list|()
operator|+
name|i
argument_list|)
decl_stmt|;
name|colInfo
operator|.
name|setInternalName
argument_list|(
name|internalName
argument_list|)
expr_stmt|;
comment|// if there is any confict, then we do not generate it in the new select
comment|// otherwise, we add it into the calciteColLst and generate the new select
if|if
condition|(
operator|!
name|out_rwsch
operator|.
name|putWithCheck
argument_list|(
name|colInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getAlias
argument_list|()
argument_list|,
name|internalName
argument_list|,
name|colInfo
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Column already present in RR. skipping."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|calciteColLst
operator|.
name|add
argument_list|(
name|originalInputRefs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|outputRel
operator|=
name|genSelectRelNode
argument_list|(
name|calciteColLst
argument_list|,
name|out_rwsch
argument_list|,
name|srcRel
argument_list|)
expr_stmt|;
comment|// outputRel is the generated augmented select with extra unselected
comment|// columns, and originalRR is the original generated select
return|return
operator|new
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|RowResolver
argument_list|>
argument_list|(
name|outputRel
argument_list|,
name|originalRR
argument_list|)
return|;
block|}
else|else
block|{
name|outputRel
operator|=
name|genSelectRelNode
argument_list|(
name|calciteColLst
argument_list|,
name|out_rwsch
argument_list|,
name|srcRel
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 9. Handle select distinct as GBY if there exist windowing functions
if|if
condition|(
name|selForWindow
operator|!=
literal|null
operator|&&
name|selExprList
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SELECTDI
condition|)
block|{
name|ImmutableBitSet
name|groupSet
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|outputRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|outputRel
operator|=
operator|new
name|HiveAggregate
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRelNode
operator|.
name|CONVENTION
argument_list|)
argument_list|,
name|outputRel
argument_list|,
name|groupSet
argument_list|,
literal|null
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|AggregateCall
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|RowResolver
name|groupByOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|out_rwsch
operator|.
name|getColumnInfos
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ColumnInfo
name|colInfo
init|=
name|out_rwsch
operator|.
name|getColumnInfos
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ColumnInfo
name|newColInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
decl_stmt|;
name|groupByOutputRowResolver
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getAlias
argument_list|()
argument_list|,
name|newColInfo
argument_list|)
expr_stmt|;
block|}
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|outputRel
argument_list|,
name|buildHiveToCalciteColumnMap
argument_list|(
name|groupByOutputRowResolver
argument_list|,
name|outputRel
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|relToHiveRR
operator|.
name|put
argument_list|(
name|outputRel
argument_list|,
name|groupByOutputRowResolver
argument_list|)
expr_stmt|;
block|}
name|inputRR
operator|.
name|setCheckForAmbiguity
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
operator|new
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|RowResolver
argument_list|>
argument_list|(
name|outputRel
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|genUDTFPlan
parameter_list|(
name|GenericUDTF
name|genericUDTF
parameter_list|,
name|String
name|genericUDTFName
parameter_list|,
name|String
name|outputTableAlias
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|colAliases
parameter_list|,
name|QB
name|qb
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|selectColLst
parameter_list|,
name|RowResolver
name|selectRR
parameter_list|,
name|RelNode
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// No GROUP BY / DISTRIBUTE BY / SORT BY / CLUSTER BY
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|qbp
operator|.
name|getDestToGroupBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UDTF_NO_GROUP_BY
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|qbp
operator|.
name|getDestToDistributeBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UDTF_NO_DISTRIBUTE_BY
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|qbp
operator|.
name|getDestToSortBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UDTF_NO_SORT_BY
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|qbp
operator|.
name|getDestToClusterBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UDTF_NO_CLUSTER_BY
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|qbp
operator|.
name|getAliasToLateralViews
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UDTF_LATERAL_VIEW
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Table alias: "
operator|+
name|outputTableAlias
operator|+
literal|" Col aliases: "
operator|+
name|colAliases
argument_list|)
expr_stmt|;
comment|// Use the RowResolver from the input operator to generate a input
comment|// ObjectInspector that can be used to initialize the UDTF. Then, the
comment|// resulting output object inspector can be used to make the RowResolver
comment|// for the UDTF operator
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|inputCols
init|=
name|selectRR
operator|.
name|getColumnInfos
argument_list|()
decl_stmt|;
comment|// Create the object inspector for the input columns and initialize the
comment|// UDTF
name|ArrayList
argument_list|<
name|String
argument_list|>
name|colNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ObjectInspector
index|[]
name|colOIs
init|=
operator|new
name|ObjectInspector
index|[
name|inputCols
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputCols
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|colNames
operator|.
name|add
argument_list|(
name|inputCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
name|colOIs
index|[
name|i
index|]
operator|=
name|inputCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getObjectInspector
argument_list|()
expr_stmt|;
block|}
name|StandardStructObjectInspector
name|rowOI
init|=
name|ObjectInspectorFactory
operator|.
name|getStandardStructObjectInspector
argument_list|(
name|colNames
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|colOIs
argument_list|)
argument_list|)
decl_stmt|;
name|StructObjectInspector
name|outputOI
init|=
name|genericUDTF
operator|.
name|initialize
argument_list|(
name|rowOI
argument_list|)
decl_stmt|;
name|int
name|numUdtfCols
init|=
name|outputOI
operator|.
name|getAllStructFieldRefs
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|colAliases
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// user did not specfied alias names, infer names from outputOI
for|for
control|(
name|StructField
name|field
range|:
name|outputOI
operator|.
name|getAllStructFieldRefs
argument_list|()
control|)
block|{
name|colAliases
operator|.
name|add
argument_list|(
name|field
operator|.
name|getFieldName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Make sure that the number of column aliases in the AS clause matches
comment|// the number of columns output by the UDTF
name|int
name|numSuppliedAliases
init|=
name|colAliases
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|numUdtfCols
operator|!=
name|numSuppliedAliases
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UDTF_ALIAS_MISMATCH
operator|.
name|getMsg
argument_list|(
literal|"expected "
operator|+
name|numUdtfCols
operator|+
literal|" aliases "
operator|+
literal|"but got "
operator|+
name|numSuppliedAliases
argument_list|)
argument_list|)
throw|;
block|}
comment|// Generate the output column info's / row resolver using internal names.
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|udtfCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|colAliasesIter
init|=
name|colAliases
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|StructField
name|sf
range|:
name|outputOI
operator|.
name|getAllStructFieldRefs
argument_list|()
control|)
block|{
name|String
name|colAlias
init|=
name|colAliasesIter
operator|.
name|next
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|colAlias
operator|!=
literal|null
operator|)
assert|;
comment|// Since the UDTF operator feeds into a LVJ operator that will rename
comment|// all the internal names, we can just use field name from the UDTF's OI
comment|// as the internal name
name|ColumnInfo
name|col
init|=
operator|new
name|ColumnInfo
argument_list|(
name|sf
operator|.
name|getFieldName
argument_list|()
argument_list|,
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|sf
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
argument_list|,
name|outputTableAlias
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|udtfCols
operator|.
name|add
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
comment|// Create the row resolver for this operator from the output columns
name|RowResolver
name|out_rwsch
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|udtfCols
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|out_rwsch
operator|.
name|put
argument_list|(
name|outputTableAlias
argument_list|,
name|colAliases
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|udtfCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Add the UDTFOperator to the operator DAG
name|RelTraitSet
name|traitSet
init|=
name|TraitsUtil
operator|.
name|getDefaultTraitSet
argument_list|(
name|cluster
argument_list|)
decl_stmt|;
comment|// Build row type from field<type, name>
name|RelDataType
name|retType
init|=
name|TypeConverter
operator|.
name|getType
argument_list|(
name|cluster
argument_list|,
name|out_rwsch
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Builder
argument_list|<
name|RelDataType
argument_list|>
name|argTypeBldr
init|=
name|ImmutableList
operator|.
expr|<
name|RelDataType
operator|>
name|builder
argument_list|()
decl_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RelDataTypeFactory
name|dtFactory
init|=
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|RowSchema
name|rs
init|=
name|selectRR
operator|.
name|getRowSchema
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|ci
range|:
name|rs
operator|.
name|getSignature
argument_list|()
control|)
block|{
name|argTypeBldr
operator|.
name|add
argument_list|(
name|TypeConverter
operator|.
name|convert
argument_list|(
name|ci
operator|.
name|getType
argument_list|()
argument_list|,
name|dtFactory
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SqlOperator
name|calciteOp
init|=
name|SqlFunctionConverter
operator|.
name|getCalciteOperator
argument_list|(
name|genericUDTFName
argument_list|,
name|genericUDTF
argument_list|,
name|argTypeBldr
operator|.
name|build
argument_list|()
argument_list|,
name|retType
argument_list|)
decl_stmt|;
comment|// Hive UDTF only has a single input
name|List
argument_list|<
name|RelNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|RexNode
name|rexNode
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|calciteOp
argument_list|,
name|selectColLst
argument_list|)
decl_stmt|;
name|RelNode
name|udtf
init|=
name|HiveTableFunctionScan
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|traitSet
argument_list|,
name|list
argument_list|,
name|rexNode
argument_list|,
literal|null
argument_list|,
name|retType
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// Add new rel& its RR to the maps
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|udtf
argument_list|,
name|this
operator|.
name|buildHiveToCalciteColumnMap
argument_list|(
name|out_rwsch
argument_list|,
name|udtf
argument_list|)
argument_list|)
expr_stmt|;
name|relToHiveRR
operator|.
name|put
argument_list|(
name|udtf
argument_list|,
name|out_rwsch
argument_list|)
expr_stmt|;
return|return
name|udtf
return|;
block|}
specifier|private
name|RelNode
name|genLogicalPlan
parameter_list|(
name|QBExpr
name|qbexpr
parameter_list|)
throws|throws
name|SemanticException
block|{
switch|switch
condition|(
name|qbexpr
operator|.
name|getOpcode
argument_list|()
condition|)
block|{
case|case
name|NULLOP
case|:
return|return
name|genLogicalPlan
argument_list|(
name|qbexpr
operator|.
name|getQB
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
case|case
name|UNION
case|:
case|case
name|INTERSECT
case|:
case|case
name|INTERSECTALL
case|:
case|case
name|EXCEPT
case|:
case|case
name|EXCEPTALL
case|:
name|RelNode
name|qbexpr1Ops
init|=
name|genLogicalPlan
argument_list|(
name|qbexpr
operator|.
name|getQBExpr1
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|qbexpr2Ops
init|=
name|genLogicalPlan
argument_list|(
name|qbexpr
operator|.
name|getQBExpr2
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|genSetOpLogicalPlan
argument_list|(
name|qbexpr
operator|.
name|getOpcode
argument_list|()
argument_list|,
name|qbexpr
operator|.
name|getAlias
argument_list|()
argument_list|,
name|qbexpr
operator|.
name|getQBExpr1
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|qbexpr1Ops
argument_list|,
name|qbexpr
operator|.
name|getQBExpr2
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|qbexpr2Ops
argument_list|)
return|;
default|default:
return|return
literal|null
return|;
block|}
block|}
specifier|private
name|RelNode
name|genLogicalPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|boolean
name|outerMostQB
parameter_list|,
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|outerNameToPosMap
parameter_list|,
name|RowResolver
name|outerRR
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RelNode
name|srcRel
init|=
literal|null
decl_stmt|;
name|RelNode
name|filterRel
init|=
literal|null
decl_stmt|;
name|RelNode
name|gbRel
init|=
literal|null
decl_stmt|;
name|RelNode
name|gbHavingRel
init|=
literal|null
decl_stmt|;
name|RelNode
name|selectRel
init|=
literal|null
decl_stmt|;
name|RelNode
name|obRel
init|=
literal|null
decl_stmt|;
name|RelNode
name|limitRel
init|=
literal|null
decl_stmt|;
comment|// First generate all the opInfos for the elements in the from clause
name|Map
argument_list|<
name|String
argument_list|,
name|RelNode
argument_list|>
name|aliasToRel
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
comment|// 0. Check if we can handle the SubQuery;
comment|// canHandleQbForCbo returns null if the query can be handled.
name|String
name|reason
init|=
name|canHandleQbForCbo
argument_list|(
name|queryProperties
argument_list|,
name|conf
argument_list|,
literal|false
argument_list|,
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
argument_list|,
name|qb
argument_list|)
decl_stmt|;
if|if
condition|(
name|reason
operator|!=
literal|null
condition|)
block|{
name|String
name|msg
init|=
literal|"CBO can not handle Sub Query"
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|msg
operator|+
literal|" because it: "
operator|+
name|reason
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
name|msg
argument_list|,
name|UnsupportedFeature
operator|.
name|Subquery
argument_list|)
throw|;
block|}
comment|// 1. Build Rel For Src (SubQuery, TS, Join)
comment|// 1.1. Recurse over the subqueries to fill the subquery part of the plan
for|for
control|(
name|String
name|subqAlias
range|:
name|qb
operator|.
name|getSubqAliases
argument_list|()
control|)
block|{
name|QBExpr
name|qbexpr
init|=
name|qb
operator|.
name|getSubqForAlias
argument_list|(
name|subqAlias
argument_list|)
decl_stmt|;
name|RelNode
name|relNode
init|=
name|genLogicalPlan
argument_list|(
name|qbexpr
argument_list|)
decl_stmt|;
name|aliasToRel
operator|.
name|put
argument_list|(
name|subqAlias
argument_list|,
name|relNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|qb
operator|.
name|getViewToTabSchema
argument_list|()
operator|.
name|containsKey
argument_list|(
name|subqAlias
argument_list|)
condition|)
block|{
if|if
condition|(
name|relNode
operator|instanceof
name|HiveProject
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|viewProjectToTableSchema
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|viewProjectToTableSchema
operator|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|viewProjectToTableSchema
operator|.
name|put
argument_list|(
operator|(
name|HiveProject
operator|)
name|relNode
argument_list|,
name|qb
operator|.
name|getViewToTabSchema
argument_list|()
operator|.
name|get
argument_list|(
name|subqAlias
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"View "
operator|+
name|subqAlias
operator|+
literal|" is corresponding to "
operator|+
name|relNode
operator|.
name|toString
argument_list|()
operator|+
literal|", rather than a HiveProject."
argument_list|)
throw|;
block|}
block|}
block|}
comment|// 1.2 Recurse over all the source tables
for|for
control|(
name|String
name|tableAlias
range|:
name|qb
operator|.
name|getTabAliases
argument_list|()
control|)
block|{
name|RelNode
name|op
init|=
name|genTableLogicalPlan
argument_list|(
name|tableAlias
argument_list|,
name|qb
argument_list|)
decl_stmt|;
name|aliasToRel
operator|.
name|put
argument_list|(
name|tableAlias
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aliasToRel
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// // This may happen for queries like select 1; (no source table)
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|setSrcForAlias
argument_list|(
name|DUMMY_TABLE
argument_list|,
name|getDummyTable
argument_list|()
argument_list|)
expr_stmt|;
name|qb
operator|.
name|addAlias
argument_list|(
name|DUMMY_TABLE
argument_list|)
expr_stmt|;
name|qb
operator|.
name|setTabAlias
argument_list|(
name|DUMMY_TABLE
argument_list|,
name|DUMMY_TABLE
argument_list|)
expr_stmt|;
name|RelNode
name|op
init|=
name|genTableLogicalPlan
argument_list|(
name|DUMMY_TABLE
argument_list|,
name|qb
argument_list|)
decl_stmt|;
name|aliasToRel
operator|.
name|put
argument_list|(
name|DUMMY_TABLE
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
comment|// 1.3 process join
comment|// 1.3.1 process hints
name|setQueryHints
argument_list|(
name|qb
argument_list|)
expr_stmt|;
comment|// 1.3.2 process the actual join
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getJoinExpr
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|srcRel
operator|=
name|genJoinLogicalPlan
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getJoinExpr
argument_list|()
argument_list|,
name|aliasToRel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If no join then there should only be either 1 TS or 1 SubQuery
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelNode
argument_list|>
name|uniqueAliasToRel
init|=
name|aliasToRel
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|srcRel
operator|=
name|uniqueAliasToRel
operator|.
name|getValue
argument_list|()
expr_stmt|;
comment|// If it contains a LV
name|List
argument_list|<
name|ASTNode
argument_list|>
name|lateralViews
init|=
name|getQBParseInfo
argument_list|(
name|qb
argument_list|)
operator|.
name|getAliasToLateralViews
argument_list|()
operator|.
name|get
argument_list|(
name|uniqueAliasToRel
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lateralViews
operator|!=
literal|null
condition|)
block|{
name|srcRel
operator|=
name|genLateralViewPlans
argument_list|(
name|Iterables
operator|.
name|getLast
argument_list|(
name|lateralViews
argument_list|)
argument_list|,
name|aliasToRel
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 2. Build Rel for where Clause
name|filterRel
operator|=
name|genFilterLogicalPlan
argument_list|(
name|qb
argument_list|,
name|srcRel
argument_list|,
name|aliasToRel
argument_list|,
name|outerNameToPosMap
argument_list|,
name|outerRR
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|srcRel
operator|=
operator|(
name|filterRel
operator|==
literal|null
operator|)
condition|?
name|srcRel
else|:
name|filterRel
expr_stmt|;
name|RelNode
name|starSrcRel
init|=
name|srcRel
decl_stmt|;
comment|// 3. Build Rel for GB Clause
name|gbRel
operator|=
name|genGBLogicalPlan
argument_list|(
name|qb
argument_list|,
name|srcRel
argument_list|)
expr_stmt|;
name|srcRel
operator|=
operator|(
name|gbRel
operator|==
literal|null
operator|)
condition|?
name|srcRel
else|:
name|gbRel
expr_stmt|;
comment|// 4. Build Rel for GB Having Clause
name|gbHavingRel
operator|=
name|genGBHavingLogicalPlan
argument_list|(
name|qb
argument_list|,
name|srcRel
argument_list|,
name|aliasToRel
argument_list|)
expr_stmt|;
name|srcRel
operator|=
operator|(
name|gbHavingRel
operator|==
literal|null
operator|)
condition|?
name|srcRel
else|:
name|gbHavingRel
expr_stmt|;
comment|// 5. Build Rel for Select Clause
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|RowResolver
argument_list|>
name|selPair
init|=
name|genSelectLogicalPlan
argument_list|(
name|qb
argument_list|,
name|srcRel
argument_list|,
name|starSrcRel
argument_list|,
name|outerNameToPosMap
argument_list|,
name|outerRR
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|selectRel
operator|=
name|selPair
operator|.
name|getKey
argument_list|()
expr_stmt|;
name|srcRel
operator|=
operator|(
name|selectRel
operator|==
literal|null
operator|)
condition|?
name|srcRel
else|:
name|selectRel
expr_stmt|;
comment|// 6. Build Rel for OB Clause
name|obRel
operator|=
name|genOBLogicalPlan
argument_list|(
name|qb
argument_list|,
name|selPair
argument_list|,
name|outerMostQB
argument_list|)
expr_stmt|;
name|srcRel
operator|=
operator|(
name|obRel
operator|==
literal|null
operator|)
condition|?
name|srcRel
else|:
name|obRel
expr_stmt|;
comment|// 7. Build Rel for Limit Clause
name|limitRel
operator|=
name|genLimitLogicalPlan
argument_list|(
name|qb
argument_list|,
name|srcRel
argument_list|)
expr_stmt|;
name|srcRel
operator|=
operator|(
name|limitRel
operator|==
literal|null
operator|)
condition|?
name|srcRel
else|:
name|limitRel
expr_stmt|;
comment|// 8. Incase this QB corresponds to subquery then modify its RR to point
comment|// to subquery alias.
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|RowResolver
name|rr
init|=
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
name|RowResolver
name|newRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|String
name|alias
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|rr
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|colInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|String
index|[]
name|tmp
init|=
name|rr
operator|.
name|reverseLookup
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
literal|""
operator|.
name|equals
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|)
operator|||
name|tmp
index|[
literal|1
index|]
operator|==
literal|null
condition|)
block|{
comment|// ast expression is not a valid column name for table
name|tmp
index|[
literal|1
index|]
operator|=
name|colInfo
operator|.
name|getInternalName
argument_list|()
expr_stmt|;
block|}
name|ColumnInfo
name|newCi
init|=
operator|new
name|ColumnInfo
argument_list|(
name|colInfo
argument_list|)
decl_stmt|;
name|newCi
operator|.
name|setTabAlias
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|newRR
operator|.
name|putWithCheck
argument_list|(
name|alias
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|,
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|newCi
argument_list|)
expr_stmt|;
block|}
name|relToHiveRR
operator|.
name|put
argument_list|(
name|srcRel
argument_list|,
name|newRR
argument_list|)
expr_stmt|;
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|srcRel
argument_list|,
name|buildHiveToCalciteColumnMap
argument_list|(
name|newRR
argument_list|,
name|srcRel
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Plan for Query Block "
operator|+
name|qb
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|setQB
argument_list|(
name|qb
argument_list|)
expr_stmt|;
return|return
name|srcRel
return|;
block|}
specifier|private
name|RelNode
name|genGBHavingLogicalPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|RelNode
name|srcRel
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RelNode
argument_list|>
name|aliasToRel
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RelNode
name|gbFilter
init|=
literal|null
decl_stmt|;
name|QBParseInfo
name|qbp
init|=
name|getQBParseInfo
argument_list|(
name|qb
argument_list|)
decl_stmt|;
name|String
name|destClauseName
init|=
name|qbp
operator|.
name|getClauseNames
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|ASTNode
name|havingClause
init|=
name|qbp
operator|.
name|getHavingForClause
argument_list|(
name|qbp
operator|.
name|getClauseNames
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|havingClause
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|srcRel
operator|instanceof
name|HiveAggregate
operator|)
condition|)
block|{
comment|// ill-formed query like select * from t1 having c1> 0;
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
literal|"Having clause without any group-by."
argument_list|,
name|UnsupportedFeature
operator|.
name|Having_clause_without_any_groupby
argument_list|)
throw|;
block|}
name|ASTNode
name|targetNode
init|=
operator|(
name|ASTNode
operator|)
name|havingClause
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|validateNoHavingReferenceToAlias
argument_list|(
name|qb
argument_list|,
name|targetNode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qbp
operator|.
name|getDestToGroupBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|boolean
name|cubeRollupGrpSetPresent
init|=
operator|(
operator|!
name|qbp
operator|.
name|getDestRollups
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|qbp
operator|.
name|getDestGroupingSets
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|qbp
operator|.
name|getDestCubes
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
decl_stmt|;
comment|// Special handling of grouping function
name|targetNode
operator|=
name|rewriteGroupingFunctionAST
argument_list|(
name|getGroupByForClause
argument_list|(
name|qbp
argument_list|,
name|destClauseName
argument_list|)
argument_list|,
name|targetNode
argument_list|,
operator|!
name|cubeRollupGrpSetPresent
argument_list|)
expr_stmt|;
block|}
name|gbFilter
operator|=
name|genFilterRelNode
argument_list|(
name|qb
argument_list|,
name|targetNode
argument_list|,
name|srcRel
argument_list|,
name|aliasToRel
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|gbFilter
return|;
block|}
comment|/*      * Bail if having clause uses Select Expression aliases for Aggregation      * expressions. We could do what Hive does. But this is non standard      * behavior. Making sure this doesn't cause issues when translating through      * Calcite is not worth it.      */
specifier|private
name|void
name|validateNoHavingReferenceToAlias
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|havingExpr
parameter_list|)
throws|throws
name|CalciteSemanticException
block|{
name|QBParseInfo
name|qbPI
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|String
argument_list|>
name|exprToAlias
init|=
name|qbPI
operator|.
name|getAllExprToColumnAlias
argument_list|()
decl_stmt|;
comment|/*        * a mouthful, but safe: - a QB is guaranteed to have atleast 1        * destination - we don't support multi insert, so picking the first dest.        */
name|Set
argument_list|<
name|String
argument_list|>
name|aggExprs
init|=
name|qbPI
operator|.
name|getDestToAggregationExprs
argument_list|()
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|keySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ASTNode
argument_list|,
name|String
argument_list|>
name|selExpr
range|:
name|exprToAlias
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|selAST
init|=
name|selExpr
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|aggExprs
operator|.
name|contains
argument_list|(
name|selAST
operator|.
name|toStringTree
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
specifier|final
name|String
name|aliasToCheck
init|=
name|selExpr
operator|.
name|getValue
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Object
argument_list|>
name|aliasReferences
init|=
operator|new
name|HashSet
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|TreeVisitorAction
name|action
init|=
operator|new
name|TreeVisitorAction
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|pre
parameter_list|(
name|Object
name|t
parameter_list|)
block|{
if|if
condition|(
name|ParseDriver
operator|.
name|adaptor
operator|.
name|getType
argument_list|(
name|t
argument_list|)
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
condition|)
block|{
name|Object
name|c
init|=
name|ParseDriver
operator|.
name|adaptor
operator|.
name|getChild
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
operator|&&
name|ParseDriver
operator|.
name|adaptor
operator|.
name|getType
argument_list|(
name|c
argument_list|)
operator|==
name|HiveParser
operator|.
name|Identifier
operator|&&
name|ParseDriver
operator|.
name|adaptor
operator|.
name|getText
argument_list|(
name|c
argument_list|)
operator|.
name|equals
argument_list|(
name|aliasToCheck
argument_list|)
condition|)
block|{
name|aliasReferences
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|t
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|post
parameter_list|(
name|Object
name|t
parameter_list|)
block|{
return|return
name|t
return|;
block|}
block|}
decl_stmt|;
operator|new
name|TreeVisitor
argument_list|(
name|ParseDriver
operator|.
name|adaptor
argument_list|)
operator|.
name|visit
argument_list|(
name|havingExpr
argument_list|,
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliasReferences
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|String
name|havingClause
init|=
name|ctx
operator|.
name|getTokenRewriteStream
argument_list|()
operator|.
name|toString
argument_list|(
name|havingExpr
operator|.
name|getTokenStartIndex
argument_list|()
argument_list|,
name|havingExpr
operator|.
name|getTokenStopIndex
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|msg
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Encountered Select alias '%s' in having clause '%s'"
operator|+
literal|" This non standard behavior is not supported with cbo on."
operator|+
literal|" Turn off cbo for these queries."
argument_list|,
name|aliasToCheck
argument_list|,
name|havingClause
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
name|msg
argument_list|,
name|UnsupportedFeature
operator|.
name|Select_alias_in_having_clause
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|buildHiveToCalciteColumnMap
parameter_list|(
name|RowResolver
name|rr
parameter_list|,
name|RelNode
name|rNode
parameter_list|)
block|{
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|b
init|=
operator|new
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|ci
range|:
name|rr
operator|.
name|getRowSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
control|)
block|{
name|b
operator|.
name|put
argument_list|(
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|rr
operator|.
name|getPosition
argument_list|(
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|b
operator|.
name|build
argument_list|()
return|;
block|}
specifier|private
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|buildHiveColNameToInputPosMap
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|col_list
parameter_list|,
name|RowResolver
name|inputRR
parameter_list|)
block|{
comment|// Build a map of Hive column Names (ExprNodeColumnDesc Name)
comment|// to the positions of those projections in the input
name|Map
argument_list|<
name|Integer
argument_list|,
name|ExprNodeDesc
argument_list|>
name|hashCodeTocolumnDescMap
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ExprNodeDescUtils
operator|.
name|getExprNodeColumnDesc
argument_list|(
name|col_list
argument_list|,
name|hashCodeTocolumnDescMap
argument_list|)
expr_stmt|;
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|hiveColNameToInputPosMapBuilder
init|=
operator|new
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|exprNodecolName
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|exprDesc
range|:
name|hashCodeTocolumnDescMap
operator|.
name|values
argument_list|()
control|)
block|{
name|exprNodecolName
operator|=
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|exprDesc
operator|)
operator|.
name|getColumn
argument_list|()
expr_stmt|;
name|hiveColNameToInputPosMapBuilder
operator|.
name|put
argument_list|(
name|exprNodecolName
argument_list|,
name|inputRR
operator|.
name|getPosition
argument_list|(
name|exprNodecolName
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|hiveColNameToInputPosMapBuilder
operator|.
name|build
argument_list|()
return|;
block|}
specifier|private
name|QBParseInfo
name|getQBParseInfo
parameter_list|(
name|QB
name|qb
parameter_list|)
throws|throws
name|CalciteSemanticException
block|{
return|return
name|qb
operator|.
name|getParseInfo
argument_list|()
return|;
block|}
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getTabAliases
parameter_list|(
name|RowResolver
name|inputRR
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|tabAliases
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// TODO: this should be
comment|// unique
for|for
control|(
name|ColumnInfo
name|ci
range|:
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|tabAliases
operator|.
name|add
argument_list|(
name|ci
operator|.
name|getTabAlias
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|tabAliases
return|;
block|}
block|}
specifier|private
enum|enum
name|TableType
block|{
name|DRUID
block|,
name|NATIVE
block|,
name|JDBC
block|}
block|}
end_class

end_unit

