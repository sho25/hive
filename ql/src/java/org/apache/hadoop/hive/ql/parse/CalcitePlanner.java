begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|UndeclaredThrowableException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|TreeVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|TreeVisitorAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTraitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepMatchOrder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgramBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|InvalidRelException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollationImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|CachingRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|ChainedRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterAggregateTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinToMultiJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|LoptOptimizeJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectRemoveRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ReduceExpressionsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SemiJoinFilterTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SemiJoinJoinTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SemiJoinProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|UnionMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexExecutorImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexWindowBound
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|SchemaPlus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|Schemas
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlExplainLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlWindow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|Frameworks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|CompositeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableIntList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ErrorMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|QueryProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RowSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|VirtualColumn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|CalciteSemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|CalciteSemanticException
operator|.
name|UnsupportedFeature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|HiveCalciteUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|HiveDefaultRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|HiveHepPlannerContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|HiveTypeSystemImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|HiveVolcanoPlannerContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|RelOptHiveTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|TraitsUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|cost
operator|.
name|HiveAlgorithmsConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|cost
operator|.
name|HiveVolcanoPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveAggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveGroupingID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveRelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveSemiJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveSortLimit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveTableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveUnion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveAggregateJoinTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveAggregateProjectMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveExpandDistinctAggregatesRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveFilterJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveFilterProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveFilterSetOpTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveInsertExchange4JoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveJoinAddNotNullRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveJoinCommuteRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveJoinProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveJoinPushTransitivePredicatesRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveJoinToMultiJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HivePartitionPruneRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HivePreFilteringRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveProjectMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveProjectSortTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveRelFieldTrimmer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveRulesRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveSortJoinReduceRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveSortMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveSortProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveSortRemoveRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
operator|.
name|HiveWindowingFixRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
operator|.
name|ASTConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
operator|.
name|HiveOpConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
operator|.
name|JoinCondTypeCheckProcFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
operator|.
name|JoinTypeCheckCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
operator|.
name|PlanModifierForReturnPath
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
operator|.
name|RexNodeConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
operator|.
name|SqlFunctionConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
operator|.
name|TypeConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|OrderExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|OrderSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|PartitionExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|PartitionSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|QBSubQuery
operator|.
name|SubQueryType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
operator|.
name|BoundarySpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
operator|.
name|RangeBoundarySpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
operator|.
name|WindowExpressionSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
operator|.
name|WindowFunctionSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
operator|.
name|WindowSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDescUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|GroupByDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|SelectDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFEvaluator
operator|.
name|Mode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|serdeConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|ListTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
operator|.
name|Builder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_class
specifier|public
class|class
name|CalcitePlanner
extends|extends
name|SemanticAnalyzer
block|{
specifier|private
specifier|final
name|AtomicInteger
name|noColsMissingStats
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
name|SemanticException
name|semanticException
decl_stmt|;
specifier|private
name|boolean
name|runCBO
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|disableSemJoinReordering
init|=
literal|true
decl_stmt|;
specifier|private
name|EnumSet
argument_list|<
name|ExtendedCBOProfile
argument_list|>
name|profilesCBO
decl_stmt|;
specifier|public
name|CalcitePlanner
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|SemanticException
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_CBO_ENABLED
argument_list|)
condition|)
block|{
name|runCBO
operator|=
literal|false
expr_stmt|;
name|disableSemJoinReordering
operator|=
literal|false
expr_stmt|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
name|void
name|analyzeInternal
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|runCBO
condition|)
block|{
name|PreCboCtx
name|cboCtx
init|=
operator|new
name|PreCboCtx
argument_list|()
decl_stmt|;
name|super
operator|.
name|analyzeInternal
argument_list|(
name|ast
argument_list|,
name|cboCtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|super
operator|.
name|analyzeInternal
argument_list|(
name|ast
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
name|Operator
name|genOPTree
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|PlannerContext
name|plannerCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
name|sinkOp
init|=
literal|null
decl_stmt|;
name|boolean
name|skipCalcitePlan
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|runCBO
condition|)
block|{
name|skipCalcitePlan
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|PreCboCtx
name|cboCtx
init|=
operator|(
name|PreCboCtx
operator|)
name|plannerCtx
decl_stmt|;
comment|// Note: for now, we don't actually pass the queryForCbo to CBO, because
comment|// it accepts qb, not AST, and can also access all the private stuff in
comment|// SA. We rely on the fact that CBO ignores the unknown tokens (create
comment|// table, destination), so if the query is otherwise ok, it is as if we
comment|// did remove those and gave CBO the proper AST. That is kinda hacky.
name|ASTNode
name|queryForCbo
init|=
name|ast
decl_stmt|;
if|if
condition|(
name|cboCtx
operator|.
name|type
operator|==
name|PreCboCtx
operator|.
name|Type
operator|.
name|CTAS
condition|)
block|{
name|queryForCbo
operator|=
name|cboCtx
operator|.
name|nodeOfInterest
expr_stmt|;
comment|// nodeOfInterest is the query
block|}
name|runCBO
operator|=
name|canCBOHandleAst
argument_list|(
name|queryForCbo
argument_list|,
name|getQB
argument_list|()
argument_list|,
name|cboCtx
argument_list|)
expr_stmt|;
name|profilesCBO
operator|=
name|obtainCBOProfiles
argument_list|(
name|queryProperties
argument_list|)
expr_stmt|;
if|if
condition|(
name|runCBO
condition|)
block|{
name|disableJoinMerge
operator|=
literal|true
expr_stmt|;
name|boolean
name|reAnalyzeAST
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|this
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_CBO_RETPATH_HIVEOP
argument_list|)
condition|)
block|{
name|sinkOp
operator|=
name|getOptimizedHiveOPDag
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"CBO Succeeded; optimized logical plan."
argument_list|)
expr_stmt|;
name|this
operator|.
name|ctx
operator|.
name|setCboInfo
argument_list|(
literal|"Plan optimized by CBO."
argument_list|)
expr_stmt|;
name|this
operator|.
name|ctx
operator|.
name|setCboSucceeded
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// 1. Gen Optimized AST
name|ASTNode
name|newAST
init|=
name|getOptimizedAST
argument_list|()
decl_stmt|;
comment|// 1.1. Fix up the query for insert/ctas
name|newAST
operator|=
name|fixUpCtasAndInsertAfterCbo
argument_list|(
name|ast
argument_list|,
name|newAST
argument_list|,
name|cboCtx
argument_list|)
expr_stmt|;
comment|// 2. Regen OP plan from optimized AST
name|init
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|cboCtx
operator|.
name|type
operator|==
name|PreCboCtx
operator|.
name|Type
operator|.
name|CTAS
condition|)
block|{
comment|// Redo create-table analysis, because it's not part of doPhase1.
name|setAST
argument_list|(
name|newAST
argument_list|)
expr_stmt|;
name|newAST
operator|=
name|reAnalyzeCtasAfterCbo
argument_list|(
name|newAST
argument_list|)
expr_stmt|;
block|}
name|Phase1Ctx
name|ctx_1
init|=
name|initPhase1Ctx
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|doPhase1
argument_list|(
name|newAST
argument_list|,
name|getQB
argument_list|()
argument_list|,
name|ctx_1
argument_list|,
literal|null
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Couldn't do phase1 on CBO optimized query plan"
argument_list|)
throw|;
block|}
comment|// unfortunately making prunedPartitions immutable is not possible
comment|// here with SemiJoins not all tables are costed in CBO, so their
comment|// PartitionList is not evaluated until the run phase.
name|getMetaData
argument_list|(
name|getQB
argument_list|()
argument_list|)
expr_stmt|;
name|disableJoinMerge
operator|=
literal|false
expr_stmt|;
name|sinkOp
operator|=
name|genPlan
argument_list|(
name|getQB
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"CBO Succeeded; optimized logical plan."
argument_list|)
expr_stmt|;
name|this
operator|.
name|ctx
operator|.
name|setCboInfo
argument_list|(
literal|"Plan optimized by CBO."
argument_list|)
expr_stmt|;
name|this
operator|.
name|ctx
operator|.
name|setCboSucceeded
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|newAST
operator|.
name|dump
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|boolean
name|isMissingStats
init|=
name|noColsMissingStats
operator|.
name|get
argument_list|()
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|isMissingStats
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"CBO failed due to missing column stats (see previous errors), skipping CBO"
argument_list|)
expr_stmt|;
name|this
operator|.
name|ctx
operator|.
name|setCboInfo
argument_list|(
literal|"Plan not optimized by CBO due to missing statistics. Please check log for more details."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"CBO failed, skipping CBO. "
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|CalciteSemanticException
condition|)
block|{
name|CalciteSemanticException
name|calciteSemanticException
init|=
operator|(
name|CalciteSemanticException
operator|)
name|e
decl_stmt|;
name|UnsupportedFeature
name|unsupportedFeature
init|=
name|calciteSemanticException
operator|.
name|getUnsupportedFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|unsupportedFeature
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|ctx
operator|.
name|setCboInfo
argument_list|(
literal|"Plan not optimized by CBO due to missing feature ["
operator|+
name|unsupportedFeature
operator|+
literal|"]."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|ctx
operator|.
name|setCboInfo
argument_list|(
literal|"Plan not optimized by CBO."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|this
operator|.
name|ctx
operator|.
name|setCboInfo
argument_list|(
literal|"Plan not optimized by CBO."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_IN_TEST
argument_list|)
operator|||
name|isMissingStats
operator|||
name|e
operator|instanceof
name|CalciteSemanticException
condition|)
block|{
name|reAnalyzeAST
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|SemanticException
condition|)
block|{
throw|throw
operator|(
name|SemanticException
operator|)
name|e
throw|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|RuntimeException
condition|)
block|{
throw|throw
operator|(
name|RuntimeException
operator|)
name|e
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|runCBO
operator|=
literal|false
expr_stmt|;
name|disableJoinMerge
operator|=
literal|false
expr_stmt|;
name|disableSemJoinReordering
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|reAnalyzeAST
condition|)
block|{
name|init
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|prunedPartitions
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Assumption: At this point Parse Tree gen& resolution will always
comment|// be true (since we started out that way).
name|super
operator|.
name|genResolvedParseTree
argument_list|(
name|ast
argument_list|,
operator|new
name|PlannerContext
argument_list|()
argument_list|)
expr_stmt|;
name|skipCalcitePlan
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|this
operator|.
name|ctx
operator|.
name|setCboInfo
argument_list|(
literal|"Plan not optimized by CBO."
argument_list|)
expr_stmt|;
name|skipCalcitePlan
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|skipCalcitePlan
condition|)
block|{
name|sinkOp
operator|=
name|super
operator|.
name|genOPTree
argument_list|(
name|ast
argument_list|,
name|plannerCtx
argument_list|)
expr_stmt|;
block|}
return|return
name|sinkOp
return|;
block|}
comment|/**    * Can CBO handle the given AST?    *    * @param ast    *          Top level AST    * @param qb    *          top level QB corresponding to the AST    * @param cboCtx    * @param semAnalyzer    * @return boolean    *    *         Assumption:<br>    *         If top level QB is query then everything below it must also be    *         Query.    */
name|boolean
name|canCBOHandleAst
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|QB
name|qb
parameter_list|,
name|PreCboCtx
name|cboCtx
parameter_list|)
block|{
name|int
name|root
init|=
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
decl_stmt|;
name|boolean
name|needToLogMessage
init|=
name|STATIC_LOG
operator|.
name|isInfoEnabled
argument_list|()
decl_stmt|;
name|boolean
name|isSupportedRoot
init|=
name|root
operator|==
name|HiveParser
operator|.
name|TOK_QUERY
operator|||
name|root
operator|==
name|HiveParser
operator|.
name|TOK_EXPLAIN
operator|||
name|qb
operator|.
name|isCTAS
argument_list|()
decl_stmt|;
name|boolean
name|isSupportedType
init|=
name|qb
operator|.
name|getIsQuery
argument_list|()
operator|||
name|qb
operator|.
name|isCTAS
argument_list|()
operator|||
name|cboCtx
operator|.
name|type
operator|==
name|PreCboCtx
operator|.
name|Type
operator|.
name|INSERT
decl_stmt|;
name|boolean
name|noBadTokens
init|=
name|HiveCalciteUtil
operator|.
name|validateASTForUnsupportedTokens
argument_list|(
name|ast
argument_list|)
decl_stmt|;
name|boolean
name|result
init|=
name|isSupportedRoot
operator|&&
name|isSupportedType
operator|&&
name|getCreateViewDesc
argument_list|()
operator|==
literal|null
operator|&&
name|noBadTokens
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
if|if
condition|(
name|needToLogMessage
condition|)
block|{
name|String
name|msg
init|=
literal|""
decl_stmt|;
if|if
condition|(
operator|!
name|isSupportedRoot
condition|)
block|{
name|msg
operator|+=
literal|"doesn't have QUERY or EXPLAIN as root and not a CTAS; "
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isSupportedType
condition|)
block|{
name|msg
operator|+=
literal|"is not a query, CTAS, or insert; "
expr_stmt|;
block|}
if|if
condition|(
name|getCreateViewDesc
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|msg
operator|+=
literal|"has create view; "
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|noBadTokens
condition|)
block|{
name|msg
operator|+=
literal|"has unsupported tokens; "
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|msg
operator|+=
literal|"has some unspecified limitations; "
expr_stmt|;
block|}
name|STATIC_LOG
operator|.
name|info
argument_list|(
literal|"Not invoking CBO because the statement "
operator|+
name|msg
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|msg
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|// Now check QB in more detail. canHandleQbForCbo returns null if query can
comment|// be handled.
name|String
name|msg
init|=
name|CalcitePlanner
operator|.
name|canHandleQbForCbo
argument_list|(
name|queryProperties
argument_list|,
name|conf
argument_list|,
literal|true
argument_list|,
name|needToLogMessage
argument_list|,
name|qb
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|needToLogMessage
condition|)
block|{
name|STATIC_LOG
operator|.
name|info
argument_list|(
literal|"Not invoking CBO because the statement "
operator|+
name|msg
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|msg
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Checks whether Calcite can handle the query.    *    * @param queryProperties    * @param conf    * @param topLevelQB    *          Does QB corresponds to top most query block?    * @param verbose    *          Whether return value should be verbose in case of failure.    * @return null if the query can be handled; non-null reason string if it    *         cannot be.    *    *         Assumption:<br>    *         1. If top level QB is query then everything below it must also be    *         Query<br>    *         2. Nested Subquery will return false for qbToChk.getIsQuery()    */
specifier|static
name|String
name|canHandleQbForCbo
parameter_list|(
name|QueryProperties
name|queryProperties
parameter_list|,
name|HiveConf
name|conf
parameter_list|,
name|boolean
name|topLevelQB
parameter_list|,
name|boolean
name|verbose
parameter_list|,
name|QB
name|qb
parameter_list|)
block|{
name|boolean
name|isInTest
init|=
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_IN_TEST
argument_list|)
decl_stmt|;
name|boolean
name|isStrictTest
init|=
name|isInTest
operator|&&
operator|!
name|conf
operator|.
name|getVar
argument_list|(
name|ConfVars
operator|.
name|HIVEMAPREDMODE
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"nonstrict"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isStrictTest
operator|&&
operator|!
name|queryProperties
operator|.
name|hasClusterBy
argument_list|()
operator|&&
operator|!
name|queryProperties
operator|.
name|hasDistributeBy
argument_list|()
operator|&&
operator|!
name|queryProperties
operator|.
name|hasSortBy
argument_list|()
operator|&&
operator|!
name|queryProperties
operator|.
name|hasPTF
argument_list|()
operator|&&
operator|!
name|queryProperties
operator|.
name|usesScript
argument_list|()
operator|&&
operator|!
name|queryProperties
operator|.
name|hasMultiDestQuery
argument_list|()
operator|&&
operator|!
name|queryProperties
operator|.
name|hasLateralViews
argument_list|()
condition|)
block|{
comment|// Ok to run CBO.
return|return
literal|null
return|;
block|}
comment|// Not ok to run CBO, build error message.
name|String
name|msg
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|isStrictTest
condition|)
name|msg
operator|+=
literal|"is in test running in mode other than nonstrict; "
expr_stmt|;
if|if
condition|(
name|queryProperties
operator|.
name|hasClusterBy
argument_list|()
condition|)
name|msg
operator|+=
literal|"has cluster by; "
expr_stmt|;
if|if
condition|(
name|queryProperties
operator|.
name|hasDistributeBy
argument_list|()
condition|)
name|msg
operator|+=
literal|"has distribute by; "
expr_stmt|;
if|if
condition|(
name|queryProperties
operator|.
name|hasSortBy
argument_list|()
condition|)
name|msg
operator|+=
literal|"has sort by; "
expr_stmt|;
if|if
condition|(
name|queryProperties
operator|.
name|hasPTF
argument_list|()
condition|)
name|msg
operator|+=
literal|"has PTF; "
expr_stmt|;
if|if
condition|(
name|queryProperties
operator|.
name|usesScript
argument_list|()
condition|)
name|msg
operator|+=
literal|"uses scripts; "
expr_stmt|;
if|if
condition|(
name|queryProperties
operator|.
name|hasMultiDestQuery
argument_list|()
condition|)
name|msg
operator|+=
literal|"is a multi-destination query; "
expr_stmt|;
if|if
condition|(
name|queryProperties
operator|.
name|hasLateralViews
argument_list|()
condition|)
name|msg
operator|+=
literal|"has lateral views; "
expr_stmt|;
if|if
condition|(
name|msg
operator|.
name|isEmpty
argument_list|()
condition|)
name|msg
operator|+=
literal|"has some unspecified limitations; "
expr_stmt|;
block|}
return|return
name|msg
return|;
block|}
comment|/* This method inserts the right profiles into profiles CBO depending    * on the query characteristics. */
specifier|private
specifier|static
name|EnumSet
argument_list|<
name|ExtendedCBOProfile
argument_list|>
name|obtainCBOProfiles
parameter_list|(
name|QueryProperties
name|queryProperties
parameter_list|)
block|{
name|EnumSet
argument_list|<
name|ExtendedCBOProfile
argument_list|>
name|profilesCBO
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|ExtendedCBOProfile
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// If the query contains more than one join
if|if
condition|(
name|queryProperties
operator|.
name|getJoinCount
argument_list|()
operator|>
literal|1
condition|)
block|{
name|profilesCBO
operator|.
name|add
argument_list|(
name|ExtendedCBOProfile
operator|.
name|JOIN_REORDERING
argument_list|)
expr_stmt|;
block|}
comment|// If the query contains windowing processing
if|if
condition|(
name|queryProperties
operator|.
name|hasWindowing
argument_list|()
condition|)
block|{
name|profilesCBO
operator|.
name|add
argument_list|(
name|ExtendedCBOProfile
operator|.
name|WINDOWING_POSTPROCESSING
argument_list|)
expr_stmt|;
block|}
return|return
name|profilesCBO
return|;
block|}
annotation|@
name|Override
name|boolean
name|continueJoinMerge
parameter_list|()
block|{
return|return
operator|!
operator|(
name|runCBO
operator|&&
name|disableSemJoinReordering
operator|)
return|;
block|}
annotation|@
name|Override
name|String
name|fixCtasColumnName
parameter_list|(
name|String
name|colName
parameter_list|)
block|{
if|if
condition|(
name|runCBO
condition|)
block|{
name|int
name|lastDot
init|=
name|colName
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastDot
operator|<
literal|0
condition|)
return|return
name|colName
return|;
comment|// alias is not fully qualified
name|String
name|nqColumnName
init|=
name|colName
operator|.
name|substring
argument_list|(
name|lastDot
operator|+
literal|1
argument_list|)
decl_stmt|;
name|STATIC_LOG
operator|.
name|debug
argument_list|(
literal|"Replacing "
operator|+
name|colName
operator|+
literal|" (produced by CBO) by "
operator|+
name|nqColumnName
argument_list|)
expr_stmt|;
return|return
name|nqColumnName
return|;
block|}
return|return
name|super
operator|.
name|fixCtasColumnName
argument_list|(
name|colName
argument_list|)
return|;
block|}
comment|/**    * The context that doPhase1 uses to populate information pertaining to CBO    * (currently, this is used for CTAS and insert-as-select).    */
specifier|static
class|class
name|PreCboCtx
extends|extends
name|PlannerContext
block|{
enum|enum
name|Type
block|{
name|NONE
block|,
name|INSERT
block|,
name|CTAS
block|,
name|UNEXPECTED
block|}
specifier|private
name|ASTNode
name|nodeOfInterest
decl_stmt|;
specifier|private
name|Type
name|type
init|=
name|Type
operator|.
name|NONE
decl_stmt|;
specifier|private
name|void
name|set
parameter_list|(
name|Type
name|type
parameter_list|,
name|ASTNode
name|ast
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|type
operator|!=
name|Type
operator|.
name|NONE
condition|)
block|{
name|STATIC_LOG
operator|.
name|warn
argument_list|(
literal|"Setting "
operator|+
name|type
operator|+
literal|" when already "
operator|+
name|this
operator|.
name|type
operator|+
literal|"; node "
operator|+
name|ast
operator|.
name|dump
argument_list|()
operator|+
literal|" vs old node "
operator|+
name|nodeOfInterest
operator|.
name|dump
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|Type
operator|.
name|UNEXPECTED
expr_stmt|;
return|return;
block|}
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|this
operator|.
name|nodeOfInterest
operator|=
name|ast
expr_stmt|;
block|}
annotation|@
name|Override
name|void
name|setCTASToken
parameter_list|(
name|ASTNode
name|child
parameter_list|)
block|{
name|set
argument_list|(
name|PreCboCtx
operator|.
name|Type
operator|.
name|CTAS
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|void
name|setInsertToken
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|boolean
name|isTmpFileDest
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isTmpFileDest
condition|)
block|{
name|set
argument_list|(
name|PreCboCtx
operator|.
name|Type
operator|.
name|INSERT
argument_list|,
name|ast
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ASTNode
name|fixUpCtasAndInsertAfterCbo
parameter_list|(
name|ASTNode
name|originalAst
parameter_list|,
name|ASTNode
name|newAst
parameter_list|,
name|PreCboCtx
name|cboCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
switch|switch
condition|(
name|cboCtx
operator|.
name|type
condition|)
block|{
case|case
name|NONE
case|:
comment|// nothing to do
return|return
name|newAst
return|;
case|case
name|CTAS
case|:
block|{
comment|// Patch the optimized query back into original CTAS AST, replacing the
comment|// original query.
name|replaceASTChild
argument_list|(
name|cboCtx
operator|.
name|nodeOfInterest
argument_list|,
name|newAst
argument_list|)
expr_stmt|;
return|return
name|originalAst
return|;
block|}
case|case
name|INSERT
case|:
block|{
comment|// We need to patch the dest back to original into new query.
comment|// This makes assumptions about the structure of the AST.
name|ASTNode
name|newDest
init|=
operator|new
name|ASTSearcher
argument_list|()
operator|.
name|simpleBreadthFirstSearch
argument_list|(
name|newAst
argument_list|,
name|HiveParser
operator|.
name|TOK_QUERY
argument_list|,
name|HiveParser
operator|.
name|TOK_INSERT
argument_list|,
name|HiveParser
operator|.
name|TOK_DESTINATION
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDest
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot find destination after CBO; new ast is "
operator|+
name|newAst
operator|.
name|dump
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Cannot find destination after CBO"
argument_list|)
throw|;
block|}
name|replaceASTChild
argument_list|(
name|newDest
argument_list|,
name|cboCtx
operator|.
name|nodeOfInterest
argument_list|)
expr_stmt|;
return|return
name|newAst
return|;
block|}
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unexpected type "
operator|+
name|cboCtx
operator|.
name|type
argument_list|)
throw|;
block|}
block|}
name|ASTNode
name|reAnalyzeCtasAfterCbo
parameter_list|(
name|ASTNode
name|newAst
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// analyzeCreateTable uses this.ast, but doPhase1 doesn't, so only reset it
comment|// here.
name|newAst
operator|=
name|analyzeCreateTable
argument_list|(
name|newAst
argument_list|,
name|getQB
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|newAst
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"analyzeCreateTable failed to initialize CTAS after CBO;"
operator|+
literal|" new ast is "
operator|+
name|getAST
argument_list|()
operator|.
name|dump
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"analyzeCreateTable failed to initialize CTAS after CBO"
argument_list|)
throw|;
block|}
return|return
name|newAst
return|;
block|}
comment|/**    * Performs breadth-first search of the AST for a nested set of tokens. Tokens    * don't have to be each others' direct children, they can be separated by    * layers of other tokens. For each token in the list, the first one found is    * matched and there's no backtracking; thus, if AST has multiple instances of    * some token, of which only one matches, it is not guaranteed to be found. We    * use this for simple things. Not thread-safe - reuses searchQueue.    */
specifier|static
class|class
name|ASTSearcher
block|{
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|ASTNode
argument_list|>
name|searchQueue
init|=
operator|new
name|LinkedList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|ASTNode
name|simpleBreadthFirstSearch
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|int
modifier|...
name|tokens
parameter_list|)
block|{
name|searchQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
name|searchQueue
operator|.
name|add
argument_list|(
name|ast
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tokens
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|boolean
name|found
init|=
literal|false
decl_stmt|;
name|int
name|token
init|=
name|tokens
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
operator|!
name|searchQueue
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|found
condition|)
block|{
name|ASTNode
name|next
init|=
name|searchQueue
operator|.
name|poll
argument_list|()
decl_stmt|;
name|found
operator|=
name|next
operator|.
name|getType
argument_list|()
operator|==
name|token
expr_stmt|;
if|if
condition|(
name|found
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|tokens
operator|.
name|length
operator|-
literal|1
condition|)
return|return
name|next
return|;
name|searchQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|next
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|searchQueue
operator|.
name|add
argument_list|(
operator|(
name|ASTNode
operator|)
name|next
operator|.
name|getChild
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
return|return
literal|null
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
specifier|private
specifier|static
name|void
name|replaceASTChild
parameter_list|(
name|ASTNode
name|child
parameter_list|,
name|ASTNode
name|newChild
parameter_list|)
block|{
name|ASTNode
name|parent
init|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|parent
decl_stmt|;
name|int
name|childIndex
init|=
name|child
operator|.
name|childIndex
decl_stmt|;
name|parent
operator|.
name|deleteChild
argument_list|(
name|childIndex
argument_list|)
expr_stmt|;
name|parent
operator|.
name|insertChild
argument_list|(
name|childIndex
argument_list|,
name|newChild
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get Optimized AST for the given QB tree in the semAnalyzer.    *    * @return Optimized operator tree translated in to Hive AST    * @throws SemanticException    */
name|ASTNode
name|getOptimizedAST
parameter_list|()
throws|throws
name|SemanticException
block|{
name|ASTNode
name|optiqOptimizedAST
init|=
literal|null
decl_stmt|;
name|RelNode
name|optimizedOptiqPlan
init|=
literal|null
decl_stmt|;
name|CalcitePlannerAction
name|calcitePlannerAction
init|=
operator|new
name|CalcitePlannerAction
argument_list|(
name|prunedPartitions
argument_list|)
decl_stmt|;
try|try
block|{
name|optimizedOptiqPlan
operator|=
name|Frameworks
operator|.
name|withPlanner
argument_list|(
name|calcitePlannerAction
argument_list|,
name|Frameworks
operator|.
name|newConfigBuilder
argument_list|()
operator|.
name|typeSystem
argument_list|(
operator|new
name|HiveTypeSystemImpl
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|rethrowCalciteException
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"rethrowCalciteException didn't throw for "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
name|optiqOptimizedAST
operator|=
name|ASTConverter
operator|.
name|convert
argument_list|(
name|optimizedOptiqPlan
argument_list|,
name|resultSchema
argument_list|)
expr_stmt|;
return|return
name|optiqOptimizedAST
return|;
block|}
comment|/**    * Get Optimized Hive Operator DAG for the given QB tree in the semAnalyzer.    *    * @return Optimized Hive operator tree    * @throws SemanticException    */
name|Operator
name|getOptimizedHiveOPDag
parameter_list|()
throws|throws
name|SemanticException
block|{
name|RelNode
name|optimizedOptiqPlan
init|=
literal|null
decl_stmt|;
name|CalcitePlannerAction
name|calcitePlannerAction
init|=
operator|new
name|CalcitePlannerAction
argument_list|(
name|prunedPartitions
argument_list|)
decl_stmt|;
try|try
block|{
name|optimizedOptiqPlan
operator|=
name|Frameworks
operator|.
name|withPlanner
argument_list|(
name|calcitePlannerAction
argument_list|,
name|Frameworks
operator|.
name|newConfigBuilder
argument_list|()
operator|.
name|typeSystem
argument_list|(
operator|new
name|HiveTypeSystemImpl
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|rethrowCalciteException
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"rethrowCalciteException didn't throw for "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
name|RelNode
name|modifiedOptimizedOptiqPlan
init|=
name|PlanModifierForReturnPath
operator|.
name|convertOpTree
argument_list|(
name|optimizedOptiqPlan
argument_list|,
name|resultSchema
argument_list|,
name|this
operator|.
name|getQB
argument_list|()
operator|.
name|getTableDesc
argument_list|()
operator|!=
literal|null
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Translating the following plan:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|modifiedOptimizedOptiqPlan
argument_list|)
argument_list|)
expr_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|hiveRoot
init|=
operator|new
name|HiveOpConverter
argument_list|(
name|this
argument_list|,
name|conf
argument_list|,
name|unparseTranslator
argument_list|,
name|topOps
argument_list|,
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPREDMODE
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"strict"
argument_list|)
argument_list|)
operator|.
name|convert
argument_list|(
name|modifiedOptimizedOptiqPlan
argument_list|)
decl_stmt|;
name|RowResolver
name|hiveRootRR
init|=
name|genRowResolver
argument_list|(
name|hiveRoot
argument_list|,
name|getQB
argument_list|()
argument_list|)
decl_stmt|;
name|opParseCtx
operator|.
name|put
argument_list|(
name|hiveRoot
argument_list|,
operator|new
name|OpParseContext
argument_list|(
name|hiveRootRR
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|dest
init|=
name|getQB
argument_list|()
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getClauseNames
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|getQB
argument_list|()
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestSchemaForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
operator|&&
name|this
operator|.
name|getQB
argument_list|()
operator|.
name|getTableDesc
argument_list|()
operator|==
literal|null
condition|)
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|selOp
init|=
name|handleInsertStatement
argument_list|(
name|dest
argument_list|,
name|hiveRoot
argument_list|,
name|hiveRootRR
argument_list|,
name|getQB
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|genFileSinkPlan
argument_list|(
name|dest
argument_list|,
name|getQB
argument_list|()
argument_list|,
name|selOp
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|genFileSinkPlan
argument_list|(
name|dest
argument_list|,
name|getQB
argument_list|()
argument_list|,
name|hiveRoot
argument_list|)
return|;
block|}
block|}
comment|// This function serves as the wrapper of handleInsertStatementSpec in
comment|// SemanticAnalyzer
name|Operator
argument_list|<
name|?
argument_list|>
name|handleInsertStatement
parameter_list|(
name|String
name|dest
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|input
parameter_list|,
name|RowResolver
name|inputRR
parameter_list|,
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|colList
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|columns
init|=
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columns
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ColumnInfo
name|col
init|=
name|columns
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|colList
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|col
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ASTNode
name|selExprList
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSelForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|RowResolver
name|out_rwsch
init|=
name|handleInsertStatementSpec
argument_list|(
name|colList
argument_list|,
name|dest
argument_list|,
name|inputRR
argument_list|,
name|inputRR
argument_list|,
name|qb
argument_list|,
name|selExprList
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|columnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|colList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|outputCol
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|outputCol
argument_list|,
name|colList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|columnNames
operator|.
name|add
argument_list|(
name|outputCol
argument_list|)
expr_stmt|;
block|}
name|Operator
argument_list|<
name|?
argument_list|>
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|SelectDesc
argument_list|(
name|colList
argument_list|,
name|columnNames
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|out_rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|out_rwsch
argument_list|)
decl_stmt|;
name|output
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
comment|/***    * Unwraps Calcite Invocation exceptions coming meta data provider chain and    * obtains the real cause.    *    * @param Exception    */
specifier|private
name|void
name|rethrowCalciteException
parameter_list|(
name|Exception
name|e
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Throwable
name|first
init|=
operator|(
name|semanticException
operator|!=
literal|null
operator|)
condition|?
name|semanticException
else|:
name|e
decl_stmt|,
name|current
init|=
name|first
decl_stmt|,
name|cause
init|=
name|current
operator|.
name|getCause
argument_list|()
decl_stmt|;
while|while
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
name|Throwable
name|causeOfCause
init|=
name|cause
operator|.
name|getCause
argument_list|()
decl_stmt|;
if|if
condition|(
name|current
operator|==
name|first
operator|&&
name|causeOfCause
operator|==
literal|null
operator|&&
name|isUselessCause
argument_list|(
name|first
argument_list|)
condition|)
block|{
comment|// "cause" is a root cause, and "e"/"first" is a useless
comment|// exception it's wrapped in.
name|first
operator|=
name|cause
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|causeOfCause
operator|!=
literal|null
operator|&&
name|isUselessCause
argument_list|(
name|cause
argument_list|)
operator|&&
name|ExceptionHelper
operator|.
name|resetCause
argument_list|(
name|current
argument_list|,
name|causeOfCause
argument_list|)
condition|)
block|{
comment|// "cause" was a useless intermediate cause and was replace it
comment|// with its own cause.
name|cause
operator|=
name|causeOfCause
expr_stmt|;
continue|continue;
comment|// do loop once again with the new cause of "current"
block|}
name|current
operator|=
name|cause
expr_stmt|;
name|cause
operator|=
name|current
operator|.
name|getCause
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|first
operator|instanceof
name|RuntimeException
condition|)
block|{
throw|throw
operator|(
name|RuntimeException
operator|)
name|first
throw|;
block|}
elseif|else
if|if
condition|(
name|first
operator|instanceof
name|SemanticException
condition|)
block|{
throw|throw
operator|(
name|SemanticException
operator|)
name|first
throw|;
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|first
argument_list|)
throw|;
block|}
specifier|private
specifier|static
class|class
name|ExceptionHelper
block|{
specifier|private
specifier|static
specifier|final
name|Field
name|CAUSE_FIELD
init|=
name|getField
argument_list|(
name|Throwable
operator|.
name|class
argument_list|,
literal|"cause"
argument_list|)
decl_stmt|,
name|TARGET_FIELD
init|=
name|getField
argument_list|(
name|InvocationTargetException
operator|.
name|class
argument_list|,
literal|"target"
argument_list|)
decl_stmt|,
name|MESSAGE_FIELD
init|=
name|getField
argument_list|(
name|Throwable
operator|.
name|class
argument_list|,
literal|"detailMessage"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|Field
name|getField
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|,
name|String
name|name
parameter_list|)
block|{
try|try
block|{
name|Field
name|f
init|=
name|clazz
operator|.
name|getDeclaredField
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|public
specifier|static
name|boolean
name|resetCause
parameter_list|(
name|Throwable
name|target
parameter_list|,
name|Throwable
name|newCause
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|MESSAGE_FIELD
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|Field
name|field
init|=
operator|(
name|target
operator|instanceof
name|InvocationTargetException
operator|)
condition|?
name|TARGET_FIELD
else|:
name|CAUSE_FIELD
decl_stmt|;
if|if
condition|(
name|field
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|Throwable
name|oldCause
init|=
name|target
operator|.
name|getCause
argument_list|()
decl_stmt|;
name|String
name|oldMsg
init|=
name|target
operator|.
name|getMessage
argument_list|()
decl_stmt|;
name|field
operator|.
name|set
argument_list|(
name|target
argument_list|,
name|newCause
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldMsg
operator|!=
literal|null
operator|&&
name|oldMsg
operator|.
name|equals
argument_list|(
name|oldCause
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|MESSAGE_FIELD
operator|.
name|set
argument_list|(
name|target
argument_list|,
name|newCause
operator|==
literal|null
condition|?
literal|null
else|:
name|newCause
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|se
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
specifier|private
name|boolean
name|isUselessCause
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
return|return
name|t
operator|instanceof
name|RuntimeException
operator|||
name|t
operator|instanceof
name|InvocationTargetException
operator|||
name|t
operator|instanceof
name|UndeclaredThrowableException
return|;
block|}
specifier|private
name|RowResolver
name|genRowResolver
parameter_list|(
name|Operator
name|op
parameter_list|,
name|QB
name|qb
parameter_list|)
block|{
name|RowResolver
name|rr
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|String
name|subqAlias
init|=
operator|(
name|qb
operator|.
name|getAliases
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|qb
operator|.
name|getSubqAliases
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
condition|?
name|qb
operator|.
name|getAliases
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
else|:
literal|null
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|ci
range|:
name|op
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
control|)
block|{
try|try
block|{
name|rr
operator|.
name|putWithCheck
argument_list|(
operator|(
name|subqAlias
operator|!=
literal|null
operator|)
condition|?
name|subqAlias
else|:
name|ci
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|ci
operator|.
name|getAlias
argument_list|()
operator|!=
literal|null
condition|?
name|ci
operator|.
name|getAlias
argument_list|()
else|:
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|ci
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|rr
return|;
block|}
specifier|private
enum|enum
name|ExtendedCBOProfile
block|{
name|JOIN_REORDERING
block|,
name|WINDOWING_POSTPROCESSING
block|;   }
comment|/**    * Code responsible for Calcite plan generation and optimization.    */
specifier|private
class|class
name|CalcitePlannerAction
implements|implements
name|Frameworks
operator|.
name|PlannerAction
argument_list|<
name|RelNode
argument_list|>
block|{
specifier|private
name|RelOptCluster
name|cluster
decl_stmt|;
specifier|private
name|RelOptSchema
name|relOptSchema
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|PrunedPartitionList
argument_list|>
name|partitionCache
decl_stmt|;
comment|// TODO: Do we need to keep track of RR, ColNameToPosMap for every op or
comment|// just last one.
name|LinkedHashMap
argument_list|<
name|RelNode
argument_list|,
name|RowResolver
argument_list|>
name|relToHiveRR
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|RelNode
argument_list|,
name|RowResolver
argument_list|>
argument_list|()
decl_stmt|;
name|LinkedHashMap
argument_list|<
name|RelNode
argument_list|,
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|relToHiveColNameCalcitePosMap
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|RelNode
argument_list|,
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|CalcitePlannerAction
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|PrunedPartitionList
argument_list|>
name|partitionCache
parameter_list|)
block|{
name|this
operator|.
name|partitionCache
operator|=
name|partitionCache
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RelNode
name|apply
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptSchema
name|relOptSchema
parameter_list|,
name|SchemaPlus
name|rootSchema
parameter_list|)
block|{
name|RelNode
name|calciteGenPlan
init|=
literal|null
decl_stmt|;
name|RelNode
name|calcitePreCboPlan
init|=
literal|null
decl_stmt|;
name|RelNode
name|calciteOptimizedPlan
init|=
literal|null
decl_stmt|;
comment|/*        * recreate cluster, so that it picks up the additional traitDef        */
specifier|final
name|Double
name|maxSplitSize
init|=
operator|(
name|double
operator|)
name|HiveConf
operator|.
name|getLongVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|MAPREDMAXSPLITSIZE
argument_list|)
decl_stmt|;
specifier|final
name|Double
name|maxMemory
init|=
operator|(
name|double
operator|)
name|HiveConf
operator|.
name|getLongVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVECONVERTJOINNOCONDITIONALTASKTHRESHOLD
argument_list|)
decl_stmt|;
name|HiveAlgorithmsConf
name|algorithmsConf
init|=
operator|new
name|HiveAlgorithmsConf
argument_list|(
name|maxSplitSize
argument_list|,
name|maxMemory
argument_list|)
decl_stmt|;
name|HiveVolcanoPlannerContext
name|confContext
init|=
operator|new
name|HiveVolcanoPlannerContext
argument_list|(
name|algorithmsConf
argument_list|)
decl_stmt|;
name|RelOptPlanner
name|planner
init|=
name|HiveVolcanoPlanner
operator|.
name|createPlanner
argument_list|(
name|confContext
argument_list|)
decl_stmt|;
specifier|final
name|RelOptQuery
name|query
init|=
operator|new
name|RelOptQuery
argument_list|(
name|planner
argument_list|)
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|cluster
operator|=
name|query
operator|.
name|createCluster
argument_list|(
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
name|rexBuilder
argument_list|)
expr_stmt|;
name|this
operator|.
name|cluster
operator|=
name|cluster
expr_stmt|;
name|this
operator|.
name|relOptSchema
operator|=
name|relOptSchema
expr_stmt|;
comment|// 1. Gen Calcite Plan
try|try
block|{
name|calciteGenPlan
operator|=
name|genLogicalPlan
argument_list|(
name|getQB
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|resultSchema
operator|=
name|SemanticAnalyzer
operator|.
name|convertRowSchemaToResultSetSchema
argument_list|(
name|relToHiveRR
operator|.
name|get
argument_list|(
name|calciteGenPlan
argument_list|)
argument_list|,
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_RESULTSET_USE_UNIQUE_COLUMN_NAMES
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|e
parameter_list|)
block|{
name|semanticException
operator|=
name|e
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// Create MD provider
name|HiveDefaultRelMetadataProvider
name|mdProvider
init|=
operator|new
name|HiveDefaultRelMetadataProvider
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// 2. Apply pre-join order optimizations
name|calcitePreCboPlan
operator|=
name|applyPreJoinOrderingTransforms
argument_list|(
name|calciteGenPlan
argument_list|,
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|)
expr_stmt|;
comment|// 3. Apply join order optimizations: reordering MST algorithm
comment|//    If join optimizations failed because of missing stats, we continue with
comment|//    the rest of optimizations
if|if
condition|(
name|profilesCBO
operator|.
name|contains
argument_list|(
name|ExtendedCBOProfile
operator|.
name|JOIN_REORDERING
argument_list|)
condition|)
block|{
try|try
block|{
name|List
argument_list|<
name|RelMetadataProvider
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|)
expr_stmt|;
name|RelTraitSet
name|desiredTraits
init|=
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRelNode
operator|.
name|CONVENTION
argument_list|,
name|RelCollations
operator|.
name|EMPTY
argument_list|)
decl_stmt|;
name|HepProgramBuilder
name|hepPgmBldr
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addMatchOrder
argument_list|(
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|)
decl_stmt|;
name|hepPgmBldr
operator|.
name|addRuleInstance
argument_list|(
operator|new
name|JoinToMultiJoinRule
argument_list|(
name|HiveJoin
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|hepPgmBldr
operator|.
name|addRuleInstance
argument_list|(
operator|new
name|LoptOptimizeJoinRule
argument_list|(
name|HiveJoin
operator|.
name|HIVE_JOIN_FACTORY
argument_list|,
name|HiveProject
operator|.
name|DEFAULT_PROJECT_FACTORY
argument_list|,
name|HiveFilter
operator|.
name|DEFAULT_FILTER_FACTORY
argument_list|)
argument_list|)
expr_stmt|;
name|HepProgram
name|hepPgm
init|=
name|hepPgmBldr
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|hepPgm
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|registerMetadataProviders
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|RelMetadataProvider
name|chainedProvider
init|=
name|ChainedRelMetadataProvider
operator|.
name|of
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|cluster
operator|.
name|setMetadataProvider
argument_list|(
operator|new
name|CachingRelMetadataProvider
argument_list|(
name|chainedProvider
argument_list|,
name|hepPlanner
argument_list|)
argument_list|)
expr_stmt|;
name|RelNode
name|rootRel
init|=
name|calcitePreCboPlan
decl_stmt|;
name|hepPlanner
operator|.
name|setRoot
argument_list|(
name|rootRel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|calcitePreCboPlan
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equals
argument_list|(
name|desiredTraits
argument_list|)
condition|)
block|{
name|rootRel
operator|=
name|hepPlanner
operator|.
name|changeTraits
argument_list|(
name|calcitePreCboPlan
argument_list|,
name|desiredTraits
argument_list|)
expr_stmt|;
block|}
name|hepPlanner
operator|.
name|setRoot
argument_list|(
name|rootRel
argument_list|)
expr_stmt|;
name|calciteOptimizedPlan
operator|=
name|hepPlanner
operator|.
name|findBestExp
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|boolean
name|isMissingStats
init|=
name|noColsMissingStats
operator|.
name|get
argument_list|()
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|isMissingStats
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Missing column stats (see previous messages), skipping join reordering in CBO"
argument_list|)
expr_stmt|;
name|noColsMissingStats
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|calciteOptimizedPlan
operator|=
name|calcitePreCboPlan
expr_stmt|;
name|disableSemJoinReordering
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
block|}
else|else
block|{
name|calciteOptimizedPlan
operator|=
name|calcitePreCboPlan
expr_stmt|;
name|disableSemJoinReordering
operator|=
literal|false
expr_stmt|;
block|}
comment|// 4. Run other optimizations that do not need stats
name|calciteOptimizedPlan
operator|=
name|hepPlan
argument_list|(
name|calciteOptimizedPlan
argument_list|,
literal|false
argument_list|,
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|,
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|,
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|,
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|,
name|ProjectRemoveRule
operator|.
name|INSTANCE
argument_list|,
name|UnionMergeRule
operator|.
name|INSTANCE
argument_list|,
operator|new
name|ProjectMergeRule
argument_list|(
literal|false
argument_list|,
name|HiveProject
operator|.
name|DEFAULT_PROJECT_FACTORY
argument_list|)
argument_list|,
name|HiveAggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
comment|// 5. Run aggregate-join transpose (cost based)
comment|//    If it failed because of missing stats, we continue with
comment|//    the rest of optimizations
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|AGGR_JOIN_TRANSPOSE
argument_list|)
condition|)
block|{
try|try
block|{
name|HepProgramBuilder
name|hepPgmBldr
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addMatchOrder
argument_list|(
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|)
decl_stmt|;
name|hepPgmBldr
operator|.
name|addRuleInstance
argument_list|(
name|HiveAggregateJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|HepProgram
name|hepPgm
init|=
name|hepPgmBldr
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|hepPgm
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RelMetadataProvider
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|)
expr_stmt|;
name|hepPlanner
operator|.
name|registerMetadataProviders
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|RelMetadataProvider
name|chainedProvider
init|=
name|ChainedRelMetadataProvider
operator|.
name|of
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|cluster
operator|.
name|setMetadataProvider
argument_list|(
operator|new
name|CachingRelMetadataProvider
argument_list|(
name|chainedProvider
argument_list|,
name|hepPlanner
argument_list|)
argument_list|)
expr_stmt|;
name|hepPlanner
operator|.
name|setRoot
argument_list|(
name|calciteOptimizedPlan
argument_list|)
expr_stmt|;
name|calciteOptimizedPlan
operator|=
name|hepPlanner
operator|.
name|findBestExp
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|boolean
name|isMissingStats
init|=
name|noColsMissingStats
operator|.
name|get
argument_list|()
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|isMissingStats
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Missing column stats (see previous messages), skipping aggregate-join transpose in CBO"
argument_list|)
expr_stmt|;
name|noColsMissingStats
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
block|}
comment|// 6. Run rule to try to remove projects on top of join operators
name|calciteOptimizedPlan
operator|=
name|hepPlan
argument_list|(
name|calciteOptimizedPlan
argument_list|,
literal|false
argument_list|,
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|,
name|HiveJoinCommuteRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
comment|// 7. Run rule to fix windowing issue when it is done over
comment|// aggregation columns (HIVE-10627)
if|if
condition|(
name|profilesCBO
operator|.
name|contains
argument_list|(
name|ExtendedCBOProfile
operator|.
name|WINDOWING_POSTPROCESSING
argument_list|)
condition|)
block|{
name|calciteOptimizedPlan
operator|=
name|hepPlan
argument_list|(
name|calciteOptimizedPlan
argument_list|,
literal|false
argument_list|,
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|,
name|HiveWindowingFixRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
comment|// 8. Run rules to aid in translation from Calcite tree to Hive tree
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_CBO_RETPATH_HIVEOP
argument_list|)
condition|)
block|{
comment|// 8.1. Merge join into multijoin operators (if possible)
name|calciteOptimizedPlan
operator|=
name|hepPlan
argument_list|(
name|calciteOptimizedPlan
argument_list|,
literal|true
argument_list|,
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|,
name|HiveJoinProjectTransposeRule
operator|.
name|BOTH_PROJECT_INCLUDE_OUTER
argument_list|,
name|HiveJoinProjectTransposeRule
operator|.
name|LEFT_PROJECT_INCLUDE_OUTER
argument_list|,
name|HiveJoinProjectTransposeRule
operator|.
name|RIGHT_PROJECT_INCLUDE_OUTER
argument_list|,
name|HiveJoinToMultiJoinRule
operator|.
name|INSTANCE
argument_list|,
name|HiveProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
comment|// The previous rules can pull up projections through join operators,
comment|// thus we run the field trimmer again to push them back down
name|HiveRelFieldTrimmer
name|fieldTrimmer
init|=
operator|new
name|HiveRelFieldTrimmer
argument_list|(
literal|null
argument_list|,
name|cluster
argument_list|,
name|HiveProject
operator|.
name|DEFAULT_PROJECT_FACTORY
argument_list|,
name|HiveFilter
operator|.
name|DEFAULT_FILTER_FACTORY
argument_list|,
name|HiveJoin
operator|.
name|HIVE_JOIN_FACTORY
argument_list|,
name|HiveSemiJoin
operator|.
name|HIVE_SEMIJOIN_FACTORY
argument_list|,
name|HiveSortLimit
operator|.
name|HIVE_SORT_REL_FACTORY
argument_list|,
name|HiveAggregate
operator|.
name|HIVE_AGGR_REL_FACTORY
argument_list|,
name|HiveUnion
operator|.
name|UNION_REL_FACTORY
argument_list|)
decl_stmt|;
name|calciteOptimizedPlan
operator|=
name|fieldTrimmer
operator|.
name|trim
argument_list|(
name|calciteOptimizedPlan
argument_list|)
expr_stmt|;
name|calciteOptimizedPlan
operator|=
name|hepPlan
argument_list|(
name|calciteOptimizedPlan
argument_list|,
literal|false
argument_list|,
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|,
name|ProjectRemoveRule
operator|.
name|INSTANCE
argument_list|,
operator|new
name|ProjectMergeRule
argument_list|(
literal|false
argument_list|,
name|HiveProject
operator|.
name|DEFAULT_PROJECT_FACTORY
argument_list|)
argument_list|)
expr_stmt|;
comment|// 8.2.  Introduce exchange operators below join/multijoin operators
name|calciteOptimizedPlan
operator|=
name|hepPlan
argument_list|(
name|calciteOptimizedPlan
argument_list|,
literal|false
argument_list|,
name|mdProvider
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|,
name|HiveInsertExchange4JoinRule
operator|.
name|EXCHANGE_BELOW_JOIN
argument_list|,
name|HiveInsertExchange4JoinRule
operator|.
name|EXCHANGE_BELOW_MULTIJOIN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_IN_TEST
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"CBO Planning details:\n"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Original Plan:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|calciteGenPlan
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Plan After PPD, PartPruning, ColumnPruning:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|calcitePreCboPlan
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Plan After Join Reordering:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|calciteOptimizedPlan
argument_list|,
name|SqlExplainLevel
operator|.
name|ALL_ATTRIBUTES
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|calciteOptimizedPlan
return|;
block|}
comment|/**      * Perform all optimizations before Join Ordering.      *      * @param basePlan      *          original plan      * @param mdProvider      *          meta data provider      * @return      */
specifier|private
name|RelNode
name|applyPreJoinOrderingTransforms
parameter_list|(
name|RelNode
name|basePlan
parameter_list|,
name|RelMetadataProvider
name|mdProvider
parameter_list|)
block|{
comment|// TODO: Decorelation of subquery should be done before attempting
comment|// Partition Pruning; otherwise Expression evaluation may try to execute
comment|// corelated sub query.
comment|//0. Distinct aggregate rewrite
comment|// Run this optimization early, since it is expanding the operator pipeline.
if|if
condition|(
operator|!
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_EXECUTION_ENGINE
argument_list|)
operator|.
name|equals
argument_list|(
literal|"mr"
argument_list|)
operator|&&
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTIMIZEDISTINCTREWRITE
argument_list|)
condition|)
block|{
comment|// Its not clear, if this rewrite is always performant on MR, since extra map phase
comment|// introduced for 2nd MR job may offset gains of this multi-stage aggregation.
comment|// We need a cost model for MR to enable this on MR.
name|basePlan
operator|=
name|hepPlan
argument_list|(
name|basePlan
argument_list|,
literal|true
argument_list|,
name|mdProvider
argument_list|,
name|HiveExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
comment|// 1. Push down limit through outer join
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_OPTIMIZE_LIMIT_JOIN_TRANSPOSE
argument_list|)
condition|)
block|{
comment|// This should be a cost based decision, but till we enable the extended cost
comment|// model, we will use the given value for the variable
specifier|final
name|float
name|reductionProportion
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_OPTIMIZE_LIMIT_JOIN_TRANSPOSE_REDUCTION_PERCENTAGE
argument_list|)
decl_stmt|;
specifier|final
name|long
name|reductionTuples
init|=
name|HiveConf
operator|.
name|getLongVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_OPTIMIZE_LIMIT_JOIN_TRANSPOSE_REDUCTION_TUPLES
argument_list|)
decl_stmt|;
name|basePlan
operator|=
name|hepPlan
argument_list|(
name|basePlan
argument_list|,
literal|true
argument_list|,
name|mdProvider
argument_list|,
name|HiveSortMergeRule
operator|.
name|INSTANCE
argument_list|,
name|HiveSortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|,
name|HiveSortJoinReduceRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|basePlan
operator|=
name|hepPlan
argument_list|(
name|basePlan
argument_list|,
literal|true
argument_list|,
name|mdProvider
argument_list|,
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|,
operator|new
name|HiveSortRemoveRule
argument_list|(
name|reductionProportion
argument_list|,
name|reductionTuples
argument_list|)
argument_list|,
name|HiveProjectSortTransposeRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
comment|// 2. Push Down Semi Joins
name|basePlan
operator|=
name|hepPlan
argument_list|(
name|basePlan
argument_list|,
literal|true
argument_list|,
name|mdProvider
argument_list|,
name|SemiJoinJoinTransposeRule
operator|.
name|INSTANCE
argument_list|,
name|SemiJoinFilterTransposeRule
operator|.
name|INSTANCE
argument_list|,
name|SemiJoinProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
comment|// 3. Add not null filters
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_CBO_RETPATH_HIVEOP
argument_list|)
condition|)
block|{
name|basePlan
operator|=
name|hepPlan
argument_list|(
name|basePlan
argument_list|,
literal|true
argument_list|,
name|mdProvider
argument_list|,
name|HiveJoinAddNotNullRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
comment|// 4. Constant propagation, common filter extraction, and PPD
name|basePlan
operator|=
name|hepPlan
argument_list|(
name|basePlan
argument_list|,
literal|true
argument_list|,
name|mdProvider
argument_list|,
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|,
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|,
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|,
name|HivePreFilteringRule
operator|.
name|INSTANCE
argument_list|,
operator|new
name|HiveFilterProjectTransposeRule
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|HiveFilter
operator|.
name|DEFAULT_FILTER_FACTORY
argument_list|,
name|HiveProject
operator|.
name|class
argument_list|,
name|HiveProject
operator|.
name|DEFAULT_PROJECT_FACTORY
argument_list|)
argument_list|,
operator|new
name|HiveFilterSetOpTransposeRule
argument_list|(
name|HiveFilter
operator|.
name|DEFAULT_FILTER_FACTORY
argument_list|)
argument_list|,
name|HiveFilterJoinRule
operator|.
name|JOIN
argument_list|,
name|HiveFilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|,
operator|new
name|FilterAggregateTransposeRule
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|HiveFilter
operator|.
name|DEFAULT_FILTER_FACTORY
argument_list|,
name|Aggregate
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
comment|// 5. Transitive inference& Partition Pruning
name|basePlan
operator|=
name|hepPlan
argument_list|(
name|basePlan
argument_list|,
literal|false
argument_list|,
name|mdProvider
argument_list|,
operator|new
name|HiveJoinPushTransitivePredicatesRule
argument_list|(
name|Join
operator|.
name|class
argument_list|,
name|HiveFilter
operator|.
name|DEFAULT_FILTER_FACTORY
argument_list|)
argument_list|,
operator|new
name|HivePartitionPruneRule
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
comment|// 6. Projection Pruning
name|HiveRelFieldTrimmer
name|fieldTrimmer
init|=
operator|new
name|HiveRelFieldTrimmer
argument_list|(
literal|null
argument_list|,
name|cluster
argument_list|,
name|HiveProject
operator|.
name|DEFAULT_PROJECT_FACTORY
argument_list|,
name|HiveFilter
operator|.
name|DEFAULT_FILTER_FACTORY
argument_list|,
name|HiveJoin
operator|.
name|HIVE_JOIN_FACTORY
argument_list|,
name|HiveSemiJoin
operator|.
name|HIVE_SEMIJOIN_FACTORY
argument_list|,
name|HiveSortLimit
operator|.
name|HIVE_SORT_REL_FACTORY
argument_list|,
name|HiveAggregate
operator|.
name|HIVE_AGGR_REL_FACTORY
argument_list|,
name|HiveUnion
operator|.
name|UNION_REL_FACTORY
argument_list|)
decl_stmt|;
name|basePlan
operator|=
name|fieldTrimmer
operator|.
name|trim
argument_list|(
name|basePlan
argument_list|)
expr_stmt|;
comment|// 7. Rerun PPD through Project as column pruning would have introduced DT
comment|// above scans
name|basePlan
operator|=
name|hepPlan
argument_list|(
name|basePlan
argument_list|,
literal|true
argument_list|,
name|mdProvider
argument_list|,
operator|new
name|FilterProjectTransposeRule
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|HiveFilter
operator|.
name|DEFAULT_FILTER_FACTORY
argument_list|,
name|HiveProject
operator|.
name|class
argument_list|,
name|HiveProject
operator|.
name|DEFAULT_PROJECT_FACTORY
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|basePlan
return|;
block|}
comment|/**      * Run the HEP Planner with the given rule set.      *      * @param basePlan      * @param followPlanChanges      * @param mdProvider      * @param rules      * @return optimized RelNode      */
specifier|private
name|RelNode
name|hepPlan
parameter_list|(
name|RelNode
name|basePlan
parameter_list|,
name|boolean
name|followPlanChanges
parameter_list|,
name|RelMetadataProvider
name|mdProvider
parameter_list|,
name|RelOptRule
modifier|...
name|rules
parameter_list|)
block|{
return|return
name|hepPlan
argument_list|(
name|basePlan
argument_list|,
name|followPlanChanges
argument_list|,
name|mdProvider
argument_list|,
name|HepMatchOrder
operator|.
name|TOP_DOWN
argument_list|,
name|rules
argument_list|)
return|;
block|}
comment|/**      * Run the HEP Planner with the given rule set.      *      * @param basePlan      * @param followPlanChanges      * @param mdProvider      * @param order      * @param rules      * @return optimized RelNode      */
specifier|private
name|RelNode
name|hepPlan
parameter_list|(
name|RelNode
name|basePlan
parameter_list|,
name|boolean
name|followPlanChanges
parameter_list|,
name|RelMetadataProvider
name|mdProvider
parameter_list|,
name|HepMatchOrder
name|order
parameter_list|,
name|RelOptRule
modifier|...
name|rules
parameter_list|)
block|{
name|RelNode
name|optimizedRelNode
init|=
name|basePlan
decl_stmt|;
name|HepProgramBuilder
name|programBuilder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|followPlanChanges
condition|)
block|{
name|programBuilder
operator|.
name|addMatchOrder
argument_list|(
name|order
argument_list|)
expr_stmt|;
name|programBuilder
operator|=
name|programBuilder
operator|.
name|addRuleCollection
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|rules
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// TODO: Should this be also TOP_DOWN?
for|for
control|(
name|RelOptRule
name|r
range|:
name|rules
control|)
name|programBuilder
operator|.
name|addRuleInstance
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|HiveRulesRegistry
name|registry
init|=
operator|new
name|HiveRulesRegistry
argument_list|()
decl_stmt|;
name|HiveHepPlannerContext
name|context
init|=
operator|new
name|HiveHepPlannerContext
argument_list|(
name|registry
argument_list|)
decl_stmt|;
name|HepPlanner
name|planner
init|=
operator|new
name|HepPlanner
argument_list|(
name|programBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|context
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RelMetadataProvider
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|mdProvider
argument_list|)
expr_stmt|;
name|planner
operator|.
name|registerMetadataProviders
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|RelMetadataProvider
name|chainedProvider
init|=
name|ChainedRelMetadataProvider
operator|.
name|of
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|basePlan
operator|.
name|getCluster
argument_list|()
operator|.
name|setMetadataProvider
argument_list|(
operator|new
name|CachingRelMetadataProvider
argument_list|(
name|chainedProvider
argument_list|,
name|planner
argument_list|)
argument_list|)
expr_stmt|;
comment|// Executor is required for constant-reduction rules; see [CALCITE-566]
specifier|final
name|RexExecutorImpl
name|executor
init|=
operator|new
name|RexExecutorImpl
argument_list|(
name|Schemas
operator|.
name|createDataContext
argument_list|(
literal|null
argument_list|)
argument_list|)
decl_stmt|;
name|basePlan
operator|.
name|getCluster
argument_list|()
operator|.
name|getPlanner
argument_list|()
operator|.
name|setExecutor
argument_list|(
name|executor
argument_list|)
expr_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|basePlan
argument_list|)
expr_stmt|;
name|optimizedRelNode
operator|=
name|planner
operator|.
name|findBestExp
argument_list|()
expr_stmt|;
return|return
name|optimizedRelNode
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|RelNode
name|genUnionLogicalPlan
parameter_list|(
name|String
name|unionalias
parameter_list|,
name|String
name|leftalias
parameter_list|,
name|RelNode
name|leftRel
parameter_list|,
name|String
name|rightalias
parameter_list|,
name|RelNode
name|rightRel
parameter_list|)
throws|throws
name|SemanticException
block|{
name|HiveUnion
name|unionRel
init|=
literal|null
decl_stmt|;
comment|// 1. Get Row Resolvers, Column map for original left and right input of
comment|// Union Rel
name|RowResolver
name|leftRR
init|=
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|leftRel
argument_list|)
decl_stmt|;
name|RowResolver
name|rightRR
init|=
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|rightRel
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|leftmap
init|=
name|leftRR
operator|.
name|getFieldMap
argument_list|(
name|leftalias
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|rightmap
init|=
name|rightRR
operator|.
name|getFieldMap
argument_list|(
name|rightalias
argument_list|)
decl_stmt|;
comment|// 2. Validate that Union is feasible according to Hive (by using type
comment|// info from RR)
if|if
condition|(
name|leftmap
operator|.
name|size
argument_list|()
operator|!=
name|rightmap
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Schema of both sides of union should match."
argument_list|)
throw|;
block|}
name|ASTNode
name|tabref
init|=
name|getQB
argument_list|()
operator|.
name|getAliases
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|getQB
argument_list|()
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|getQB
argument_list|()
operator|.
name|getAliases
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|// 3. construct Union Output RR using original left& right Input
name|RowResolver
name|unionoutRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
argument_list|>
name|lIter
init|=
name|leftmap
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
argument_list|>
name|rIter
init|=
name|rightmap
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|lIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|lEntry
init|=
name|lIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|rEntry
init|=
name|rIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|ColumnInfo
name|lInfo
init|=
name|lEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ColumnInfo
name|rInfo
init|=
name|rEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|field
init|=
name|lEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
comment|// try widening conversion, otherwise fail union
name|TypeInfo
name|commonTypeInfo
init|=
name|FunctionRegistry
operator|.
name|getCommonClassForUnionAll
argument_list|(
name|lInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|rInfo
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|commonTypeInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|tabref
argument_list|,
literal|"Schema of both sides of union should match: Column "
operator|+
name|field
operator|+
literal|" is of type "
operator|+
name|lInfo
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
operator|+
literal|" on first table and type "
operator|+
name|rInfo
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
operator|+
literal|" on second table"
argument_list|)
argument_list|)
throw|;
block|}
name|ColumnInfo
name|unionColInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|lInfo
argument_list|)
decl_stmt|;
name|unionColInfo
operator|.
name|setType
argument_list|(
name|commonTypeInfo
argument_list|)
expr_stmt|;
name|unionoutRR
operator|.
name|put
argument_list|(
name|unionalias
argument_list|,
name|field
argument_list|,
name|unionColInfo
argument_list|)
expr_stmt|;
block|}
comment|// 4. Determine which columns requires cast on left/right input (Calcite
comment|// requires exact types on both sides of union)
name|boolean
name|leftNeedsTypeCast
init|=
literal|false
decl_stmt|;
name|boolean
name|rightNeedsTypeCast
init|=
literal|false
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftProjs
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightProjs
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|leftRowDT
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightRowDT
init|=
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|RelDataType
name|leftFieldDT
decl_stmt|;
name|RelDataType
name|rightFieldDT
decl_stmt|;
name|RelDataType
name|unionFieldDT
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftRowDT
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|leftFieldDT
operator|=
name|leftRowDT
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
name|rightFieldDT
operator|=
name|rightRowDT
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|leftFieldDT
operator|.
name|equals
argument_list|(
name|rightFieldDT
argument_list|)
condition|)
block|{
name|unionFieldDT
operator|=
name|TypeConverter
operator|.
name|convert
argument_list|(
name|unionoutRR
operator|.
name|getColumnInfos
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|cluster
operator|.
name|getTypeFactory
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unionFieldDT
operator|.
name|equals
argument_list|(
name|leftFieldDT
argument_list|)
condition|)
block|{
name|leftNeedsTypeCast
operator|=
literal|true
expr_stmt|;
block|}
name|leftProjs
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|ensureType
argument_list|(
name|unionFieldDT
argument_list|,
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|leftFieldDT
argument_list|,
name|i
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unionFieldDT
operator|.
name|equals
argument_list|(
name|rightFieldDT
argument_list|)
condition|)
block|{
name|rightNeedsTypeCast
operator|=
literal|true
expr_stmt|;
block|}
name|rightProjs
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|ensureType
argument_list|(
name|unionFieldDT
argument_list|,
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|rightFieldDT
argument_list|,
name|i
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|leftProjs
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|ensureType
argument_list|(
name|leftFieldDT
argument_list|,
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|leftFieldDT
argument_list|,
name|i
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|rightProjs
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|ensureType
argument_list|(
name|rightFieldDT
argument_list|,
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|rightFieldDT
argument_list|,
name|i
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 5. Introduce Project Rel above original left/right inputs if cast is
comment|// needed for type parity
name|RelNode
name|unionLeftInput
init|=
name|leftRel
decl_stmt|;
name|RelNode
name|unionRightInput
init|=
name|rightRel
decl_stmt|;
if|if
condition|(
name|leftNeedsTypeCast
condition|)
block|{
name|unionLeftInput
operator|=
name|HiveProject
operator|.
name|create
argument_list|(
name|leftRel
argument_list|,
name|leftProjs
argument_list|,
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rightNeedsTypeCast
condition|)
block|{
name|unionRightInput
operator|=
name|HiveProject
operator|.
name|create
argument_list|(
name|rightRel
argument_list|,
name|rightProjs
argument_list|,
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// 6. Construct Union Rel
name|Builder
argument_list|<
name|RelNode
argument_list|>
name|bldr
init|=
operator|new
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
name|bldr
operator|.
name|add
argument_list|(
name|unionLeftInput
argument_list|)
expr_stmt|;
name|bldr
operator|.
name|add
argument_list|(
name|unionRightInput
argument_list|)
expr_stmt|;
name|unionRel
operator|=
operator|new
name|HiveUnion
argument_list|(
name|cluster
argument_list|,
name|TraitsUtil
operator|.
name|getDefaultTraitSet
argument_list|(
name|cluster
argument_list|)
argument_list|,
name|bldr
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
name|relToHiveRR
operator|.
name|put
argument_list|(
name|unionRel
argument_list|,
name|unionoutRR
argument_list|)
expr_stmt|;
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|unionRel
argument_list|,
name|this
operator|.
name|buildHiveToCalciteColumnMap
argument_list|(
name|unionoutRR
argument_list|,
name|unionRel
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|unionRel
return|;
block|}
specifier|private
name|RelNode
name|genJoinRelNode
parameter_list|(
name|RelNode
name|leftRel
parameter_list|,
name|RelNode
name|rightRel
parameter_list|,
name|JoinType
name|hiveJoinType
parameter_list|,
name|ASTNode
name|joinCond
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RelNode
name|joinRel
init|=
literal|null
decl_stmt|;
comment|// 1. construct the RowResolver for the new Join Node by combining row
comment|// resolvers from left, right
name|RowResolver
name|leftRR
init|=
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|leftRel
argument_list|)
decl_stmt|;
name|RowResolver
name|rightRR
init|=
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|rightRel
argument_list|)
decl_stmt|;
name|RowResolver
name|joinRR
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|hiveJoinType
operator|!=
name|JoinType
operator|.
name|LEFTSEMI
condition|)
block|{
name|joinRR
operator|=
name|RowResolver
operator|.
name|getCombinedRR
argument_list|(
name|leftRR
argument_list|,
name|rightRR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|joinRR
operator|=
operator|new
name|RowResolver
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|RowResolver
operator|.
name|add
argument_list|(
name|joinRR
argument_list|,
name|leftRR
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Duplicates detected when adding columns to RR: see previous message"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 2. Construct ExpressionNodeDesc representing Join Condition
name|RexNode
name|calciteJoinCond
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|joinCond
operator|!=
literal|null
condition|)
block|{
name|JoinTypeCheckCtx
name|jCtx
init|=
operator|new
name|JoinTypeCheckCtx
argument_list|(
name|leftRR
argument_list|,
name|rightRR
argument_list|,
name|hiveJoinType
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
name|exprNodes
init|=
name|JoinCondTypeCheckProcFactory
operator|.
name|genExprNode
argument_list|(
name|joinCond
argument_list|,
name|jCtx
argument_list|)
decl_stmt|;
if|if
condition|(
name|jCtx
operator|.
name|getError
argument_list|()
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|SemanticException
argument_list|(
name|SemanticAnalyzer
operator|.
name|generateErrorMessage
argument_list|(
name|jCtx
operator|.
name|getErrorSrcNode
argument_list|()
argument_list|,
name|jCtx
operator|.
name|getError
argument_list|()
argument_list|)
argument_list|)
throw|;
name|ExprNodeDesc
name|joinCondnExprNode
init|=
name|exprNodes
operator|.
name|get
argument_list|(
name|joinCond
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputRels
init|=
operator|new
name|ArrayList
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
name|inputRels
operator|.
name|add
argument_list|(
name|leftRel
argument_list|)
expr_stmt|;
name|inputRels
operator|.
name|add
argument_list|(
name|rightRel
argument_list|)
expr_stmt|;
name|calciteJoinCond
operator|=
name|RexNodeConverter
operator|.
name|convert
argument_list|(
name|cluster
argument_list|,
name|joinCondnExprNode
argument_list|,
name|inputRels
argument_list|,
name|relToHiveRR
argument_list|,
name|relToHiveColNameCalcitePosMap
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|calciteJoinCond
operator|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// 3. Validate that join condition is legal (i.e no function refering to
comment|// both sides of join, only equi join)
comment|// TODO: Join filter handling (only supported for OJ by runtime or is it
comment|// supported for IJ as well)
comment|// 4. Construct Join Rel Node
name|boolean
name|leftSemiJoin
init|=
literal|false
decl_stmt|;
name|JoinRelType
name|calciteJoinType
decl_stmt|;
switch|switch
condition|(
name|hiveJoinType
condition|)
block|{
case|case
name|LEFTOUTER
case|:
name|calciteJoinType
operator|=
name|JoinRelType
operator|.
name|LEFT
expr_stmt|;
break|break;
case|case
name|RIGHTOUTER
case|:
name|calciteJoinType
operator|=
name|JoinRelType
operator|.
name|RIGHT
expr_stmt|;
break|break;
case|case
name|FULLOUTER
case|:
name|calciteJoinType
operator|=
name|JoinRelType
operator|.
name|FULL
expr_stmt|;
break|break;
case|case
name|LEFTSEMI
case|:
name|calciteJoinType
operator|=
name|JoinRelType
operator|.
name|INNER
expr_stmt|;
name|leftSemiJoin
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|INNER
case|:
default|default:
name|calciteJoinType
operator|=
name|JoinRelType
operator|.
name|INNER
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|leftSemiJoin
condition|)
block|{
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|sysFieldList
init|=
operator|new
name|ArrayList
argument_list|<
name|RelDataTypeField
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftJoinKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightJoinKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|RexNode
name|nonEquiConds
init|=
name|RelOptUtil
operator|.
name|splitJoinCondition
argument_list|(
name|sysFieldList
argument_list|,
name|leftRel
argument_list|,
name|rightRel
argument_list|,
name|calciteJoinCond
argument_list|,
name|leftJoinKeys
argument_list|,
name|rightJoinKeys
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|nonEquiConds
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Non equality condition not supported in Semi-Join"
operator|+
name|nonEquiConds
argument_list|)
throw|;
block|}
name|RelNode
index|[]
name|inputRels
init|=
operator|new
name|RelNode
index|[]
block|{
name|leftRel
block|,
name|rightRel
block|}
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|calciteJoinCond
operator|=
name|HiveCalciteUtil
operator|.
name|projectNonColumnEquiConditions
argument_list|(
name|HiveProject
operator|.
name|DEFAULT_PROJECT_FACTORY
argument_list|,
name|inputRels
argument_list|,
name|leftJoinKeys
argument_list|,
name|rightJoinKeys
argument_list|,
literal|0
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|)
expr_stmt|;
name|joinRel
operator|=
name|HiveSemiJoin
operator|.
name|getSemiJoin
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRelNode
operator|.
name|CONVENTION
argument_list|)
argument_list|,
name|inputRels
index|[
literal|0
index|]
argument_list|,
name|inputRels
index|[
literal|1
index|]
argument_list|,
name|calciteJoinCond
argument_list|,
name|ImmutableIntList
operator|.
name|copyOf
argument_list|(
name|leftKeys
argument_list|)
argument_list|,
name|ImmutableIntList
operator|.
name|copyOf
argument_list|(
name|rightKeys
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|joinRel
operator|=
name|HiveJoin
operator|.
name|getJoin
argument_list|(
name|cluster
argument_list|,
name|leftRel
argument_list|,
name|rightRel
argument_list|,
name|calciteJoinCond
argument_list|,
name|calciteJoinType
argument_list|,
name|leftSemiJoin
argument_list|)
expr_stmt|;
block|}
comment|// 5. Add new JoinRel& its RR to the maps
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|joinRel
argument_list|,
name|this
operator|.
name|buildHiveToCalciteColumnMap
argument_list|(
name|joinRR
argument_list|,
name|joinRel
argument_list|)
argument_list|)
expr_stmt|;
name|relToHiveRR
operator|.
name|put
argument_list|(
name|joinRel
argument_list|,
name|joinRR
argument_list|)
expr_stmt|;
return|return
name|joinRel
return|;
block|}
comment|/**      * Generate Join Logical Plan Relnode by walking through the join AST.      *      * @param qb      * @param aliasToRel      *          Alias(Table/Relation alias) to RelNode; only read and not      *          written in to by this method      * @return      * @throws SemanticException      */
specifier|private
name|RelNode
name|genJoinLogicalPlan
parameter_list|(
name|ASTNode
name|joinParseTree
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RelNode
argument_list|>
name|aliasToRel
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RelNode
name|leftRel
init|=
literal|null
decl_stmt|;
name|RelNode
name|rightRel
init|=
literal|null
decl_stmt|;
name|JoinType
name|hiveJoinType
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|joinParseTree
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_UNIQUEJOIN
condition|)
block|{
name|String
name|msg
init|=
name|String
operator|.
name|format
argument_list|(
literal|"UNIQUE JOIN is currently not supported in CBO,"
operator|+
literal|" turn off cbo to use UNIQUE JOIN."
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
name|msg
argument_list|,
name|UnsupportedFeature
operator|.
name|Unique_join
argument_list|)
throw|;
block|}
comment|// 1. Determine Join Type
comment|// TODO: What about TOK_CROSSJOIN, TOK_MAPJOIN
switch|switch
condition|(
name|joinParseTree
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_LEFTOUTERJOIN
case|:
name|hiveJoinType
operator|=
name|JoinType
operator|.
name|LEFTOUTER
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_RIGHTOUTERJOIN
case|:
name|hiveJoinType
operator|=
name|JoinType
operator|.
name|RIGHTOUTER
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_FULLOUTERJOIN
case|:
name|hiveJoinType
operator|=
name|JoinType
operator|.
name|FULLOUTER
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_LEFTSEMIJOIN
case|:
name|hiveJoinType
operator|=
name|JoinType
operator|.
name|LEFTSEMI
expr_stmt|;
break|break;
default|default:
name|hiveJoinType
operator|=
name|JoinType
operator|.
name|INNER
expr_stmt|;
break|break;
block|}
comment|// 2. Get Left Table Alias
name|ASTNode
name|left
init|=
operator|(
name|ASTNode
operator|)
name|joinParseTree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|left
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABREF
operator|)
operator|||
operator|(
name|left
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY
operator|)
operator|||
operator|(
name|left
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PTBLFUNCTION
operator|)
condition|)
block|{
name|String
name|tableName
init|=
name|SemanticAnalyzer
operator|.
name|getUnescapedUnqualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|left
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|String
name|leftTableAlias
init|=
name|left
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|?
name|tableName
else|:
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|left
operator|.
name|getChild
argument_list|(
name|left
operator|.
name|getChildCount
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
comment|// ptf node form is: ^(TOK_PTBLFUNCTION $name $alias?
comment|// partitionTableFunctionSource partitioningSpec? expression*)
comment|// guranteed to have an lias here: check done in processJoin
name|leftTableAlias
operator|=
operator|(
name|left
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PTBLFUNCTION
operator|)
condition|?
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|left
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
else|:
name|leftTableAlias
expr_stmt|;
name|leftRel
operator|=
name|aliasToRel
operator|.
name|get
argument_list|(
name|leftTableAlias
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SemanticAnalyzer
operator|.
name|isJoinToken
argument_list|(
name|left
argument_list|)
condition|)
block|{
name|leftRel
operator|=
name|genJoinLogicalPlan
argument_list|(
name|left
argument_list|,
name|aliasToRel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
operator|(
literal|false
operator|)
assert|;
block|}
comment|// 3. Get Right Table Alias
name|ASTNode
name|right
init|=
operator|(
name|ASTNode
operator|)
name|joinParseTree
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|right
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABREF
operator|)
operator|||
operator|(
name|right
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY
operator|)
operator|||
operator|(
name|right
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PTBLFUNCTION
operator|)
condition|)
block|{
name|String
name|tableName
init|=
name|SemanticAnalyzer
operator|.
name|getUnescapedUnqualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|right
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|String
name|rightTableAlias
init|=
name|right
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|?
name|tableName
else|:
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|right
operator|.
name|getChild
argument_list|(
name|right
operator|.
name|getChildCount
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
comment|// ptf node form is: ^(TOK_PTBLFUNCTION $name $alias?
comment|// partitionTableFunctionSource partitioningSpec? expression*)
comment|// guranteed to have an lias here: check done in processJoin
name|rightTableAlias
operator|=
operator|(
name|right
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PTBLFUNCTION
operator|)
condition|?
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|right
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
else|:
name|rightTableAlias
expr_stmt|;
name|rightRel
operator|=
name|aliasToRel
operator|.
name|get
argument_list|(
name|rightTableAlias
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
operator|(
literal|false
operator|)
assert|;
block|}
comment|// 4. Get Join Condn
name|ASTNode
name|joinCond
init|=
operator|(
name|ASTNode
operator|)
name|joinParseTree
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
decl_stmt|;
comment|// 5. Create Join rel
return|return
name|genJoinRelNode
argument_list|(
name|leftRel
argument_list|,
name|rightRel
argument_list|,
name|hiveJoinType
argument_list|,
name|joinCond
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|genTableLogicalPlan
parameter_list|(
name|String
name|tableAlias
parameter_list|,
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|rr
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|HiveTableScan
name|tableRel
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// 1. If the table has a Sample specified, bail from Calcite path.
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getTabSample
argument_list|(
name|tableAlias
argument_list|)
operator|!=
literal|null
operator|||
name|getNameToSplitSampleMap
argument_list|()
operator|.
name|containsKey
argument_list|(
name|tableAlias
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Table Sample specified for %s."
operator|+
literal|" Currently we don't support Table Sample clauses in CBO,"
operator|+
literal|" turn off cbo for queries on tableSamples."
argument_list|,
name|tableAlias
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
name|msg
argument_list|,
name|UnsupportedFeature
operator|.
name|Table_sample_clauses
argument_list|)
throw|;
block|}
comment|// 2. Get Table Metadata
name|Table
name|tabMetaData
init|=
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|tableAlias
argument_list|)
decl_stmt|;
comment|// 3. Get Table Logical Schema (Row Type)
comment|// NOTE: Table logical schema = Non Partition Cols + Partition Cols +
comment|// Virtual Cols
comment|// 3.1 Add Column info for non partion cols (Object Inspector fields)
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
name|StructObjectInspector
name|rowObjectInspector
init|=
operator|(
name|StructObjectInspector
operator|)
name|tabMetaData
operator|.
name|getDeserializer
argument_list|()
operator|.
name|getObjectInspector
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|fields
init|=
name|rowObjectInspector
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
name|ColumnInfo
name|colInfo
decl_stmt|;
name|String
name|colName
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|cInfoLst
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|colName
operator|=
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldName
argument_list|()
expr_stmt|;
name|colInfo
operator|=
operator|new
name|ColumnInfo
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldName
argument_list|()
argument_list|,
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
argument_list|,
name|tableAlias
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|colInfo
operator|.
name|setSkewedCol
argument_list|(
operator|(
name|SemanticAnalyzer
operator|.
name|isSkewedCol
argument_list|(
name|tableAlias
argument_list|,
name|qb
argument_list|,
name|colName
argument_list|)
operator|)
condition|?
literal|true
else|:
literal|false
argument_list|)
expr_stmt|;
name|rr
operator|.
name|put
argument_list|(
name|tableAlias
argument_list|,
name|colName
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|cInfoLst
operator|.
name|add
argument_list|(
name|colInfo
argument_list|)
expr_stmt|;
block|}
comment|// TODO: Fix this
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|nonPartitionColumns
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|(
name|cInfoLst
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|partitionColumns
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
comment|// 3.2 Add column info corresponding to partition columns
for|for
control|(
name|FieldSchema
name|part_col
range|:
name|tabMetaData
operator|.
name|getPartCols
argument_list|()
control|)
block|{
name|colName
operator|=
name|part_col
operator|.
name|getName
argument_list|()
expr_stmt|;
name|colInfo
operator|=
operator|new
name|ColumnInfo
argument_list|(
name|colName
argument_list|,
name|TypeInfoFactory
operator|.
name|getPrimitiveTypeInfo
argument_list|(
name|part_col
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|,
name|tableAlias
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|rr
operator|.
name|put
argument_list|(
name|tableAlias
argument_list|,
name|colName
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|cInfoLst
operator|.
name|add
argument_list|(
name|colInfo
argument_list|)
expr_stmt|;
name|partitionColumns
operator|.
name|add
argument_list|(
name|colInfo
argument_list|)
expr_stmt|;
block|}
comment|// 3.3 Add column info corresponding to virtual columns
name|List
argument_list|<
name|VirtualColumn
argument_list|>
name|virtualCols
init|=
operator|new
name|ArrayList
argument_list|<
name|VirtualColumn
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|VirtualColumn
argument_list|>
name|vcs
init|=
name|VirtualColumn
operator|.
name|getRegistry
argument_list|(
name|conf
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|vcs
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|VirtualColumn
name|vc
init|=
name|vcs
operator|.
name|next
argument_list|()
decl_stmt|;
name|colInfo
operator|=
operator|new
name|ColumnInfo
argument_list|(
name|vc
operator|.
name|getName
argument_list|()
argument_list|,
name|vc
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|tableAlias
argument_list|,
literal|true
argument_list|,
name|vc
operator|.
name|getIsHidden
argument_list|()
argument_list|)
expr_stmt|;
name|rr
operator|.
name|put
argument_list|(
name|tableAlias
argument_list|,
name|vc
operator|.
name|getName
argument_list|()
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|cInfoLst
operator|.
name|add
argument_list|(
name|colInfo
argument_list|)
expr_stmt|;
name|virtualCols
operator|.
name|add
argument_list|(
name|vc
argument_list|)
expr_stmt|;
block|}
comment|// 3.4 Build row type from field<type, name>
name|RelDataType
name|rowType
init|=
name|TypeConverter
operator|.
name|getType
argument_list|(
name|cluster
argument_list|,
name|rr
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// 4. Build RelOptAbstractTable
name|String
name|fullyQualifiedTabName
init|=
name|tabMetaData
operator|.
name|getDbName
argument_list|()
decl_stmt|;
if|if
condition|(
name|fullyQualifiedTabName
operator|!=
literal|null
operator|&&
operator|!
name|fullyQualifiedTabName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fullyQualifiedTabName
operator|=
name|fullyQualifiedTabName
operator|+
literal|"."
operator|+
name|tabMetaData
operator|.
name|getTableName
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|fullyQualifiedTabName
operator|=
name|tabMetaData
operator|.
name|getTableName
argument_list|()
expr_stmt|;
block|}
name|RelOptHiveTable
name|optTable
init|=
operator|new
name|RelOptHiveTable
argument_list|(
name|relOptSchema
argument_list|,
name|fullyQualifiedTabName
argument_list|,
name|rowType
argument_list|,
name|tabMetaData
argument_list|,
name|nonPartitionColumns
argument_list|,
name|partitionColumns
argument_list|,
name|virtualCols
argument_list|,
name|conf
argument_list|,
name|partitionCache
argument_list|,
name|noColsMissingStats
argument_list|)
decl_stmt|;
comment|// 5. Build Hive Table Scan Rel
name|tableRel
operator|=
operator|new
name|HiveTableScan
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRelNode
operator|.
name|CONVENTION
argument_list|)
argument_list|,
name|optTable
argument_list|,
literal|null
operator|==
name|tableAlias
condition|?
name|tabMetaData
operator|.
name|getTableName
argument_list|()
else|:
name|tableAlias
argument_list|,
name|getAliasId
argument_list|(
name|tableAlias
argument_list|,
name|qb
argument_list|)
argument_list|,
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_CBO_RETPATH_HIVEOP
argument_list|)
argument_list|)
expr_stmt|;
comment|// 6. Add Schema(RR) to RelNode-Schema map
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|hiveToCalciteColMap
init|=
name|buildHiveToCalciteColumnMap
argument_list|(
name|rr
argument_list|,
name|tableRel
argument_list|)
decl_stmt|;
name|relToHiveRR
operator|.
name|put
argument_list|(
name|tableRel
argument_list|,
name|rr
argument_list|)
expr_stmt|;
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|tableRel
argument_list|,
name|hiveToCalciteColMap
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|SemanticException
condition|)
block|{
throw|throw
operator|(
name|SemanticException
operator|)
name|e
throw|;
block|}
else|else
block|{
throw|throw
operator|(
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
operator|)
throw|;
block|}
block|}
return|return
name|tableRel
return|;
block|}
specifier|private
name|RelNode
name|genFilterRelNode
parameter_list|(
name|ASTNode
name|filterExpr
parameter_list|,
name|RelNode
name|srcRel
parameter_list|,
name|boolean
name|useCaching
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ExprNodeDesc
name|filterCondn
init|=
name|genExprNodeDesc
argument_list|(
name|filterExpr
argument_list|,
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
argument_list|,
name|useCaching
argument_list|)
decl_stmt|;
if|if
condition|(
name|filterCondn
operator|instanceof
name|ExprNodeConstantDesc
operator|&&
operator|!
name|filterCondn
operator|.
name|getTypeString
argument_list|()
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|BOOLEAN_TYPE_NAME
argument_list|)
condition|)
block|{
comment|// queries like select * from t1 where 'foo';
comment|// Calcite's rule PushFilterThroughProject chokes on it. Arguably, we
comment|// can insert a cast to
comment|// boolean in such cases, but since Postgres, Oracle and MS SQL server
comment|// fail on compile time
comment|// for such queries, its an arcane corner case, not worth of adding that
comment|// complexity.
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
literal|"Filter expression with non-boolean return type."
argument_list|,
name|UnsupportedFeature
operator|.
name|Filter_expression_with_non_boolean_return_type
argument_list|)
throw|;
block|}
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|hiveColNameCalcitePosMap
init|=
name|this
operator|.
name|relToHiveColNameCalcitePosMap
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
name|RexNode
name|convertedFilterExpr
init|=
operator|new
name|RexNodeConverter
argument_list|(
name|cluster
argument_list|,
name|srcRel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|hiveColNameCalcitePosMap
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
operator|.
name|convert
argument_list|(
name|filterCondn
argument_list|)
decl_stmt|;
name|RexNode
name|factoredFilterExpr
init|=
name|RexUtil
operator|.
name|pullFactors
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|convertedFilterExpr
argument_list|)
decl_stmt|;
name|RelNode
name|filterRel
init|=
operator|new
name|HiveFilter
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRelNode
operator|.
name|CONVENTION
argument_list|)
argument_list|,
name|srcRel
argument_list|,
name|factoredFilterExpr
argument_list|)
decl_stmt|;
name|this
operator|.
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|filterRel
argument_list|,
name|hiveColNameCalcitePosMap
argument_list|)
expr_stmt|;
name|relToHiveRR
operator|.
name|put
argument_list|(
name|filterRel
argument_list|,
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
argument_list|)
expr_stmt|;
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|filterRel
argument_list|,
name|hiveColNameCalcitePosMap
argument_list|)
expr_stmt|;
return|return
name|filterRel
return|;
block|}
specifier|private
name|RelNode
name|genFilterRelNode
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|searchCond
parameter_list|,
name|RelNode
name|srcRel
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RelNode
argument_list|>
name|aliasToRel
parameter_list|,
name|boolean
name|forHavingClause
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|/*        * Handle Subquery predicates.        *        * Notes (8/22/14 hb): Why is this a copy of the code from {@link        * #genFilterPlan} - for now we will support the same behavior as non CBO        * route. - but plan to allow nested SubQueries(Restriction.9.m) and        * multiple SubQuery expressions(Restriction.8.m). This requires use to        * utilize Calcite's Decorrelation mechanics, and for Calcite to fix/flush        * out Null semantics(CALCITE-373) - besides only the driving code has        * been copied. Most of the code which is SubQueryUtils and QBSubQuery is        * reused.        */
name|int
name|numSrcColumns
init|=
name|srcRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|subQueriesInOriginalTree
init|=
name|SubQueryUtils
operator|.
name|findSubQueries
argument_list|(
name|searchCond
argument_list|)
decl_stmt|;
if|if
condition|(
name|subQueriesInOriginalTree
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|/*          * Restriction.9.m :: disallow nested SubQuery expressions.          */
if|if
condition|(
name|qb
operator|.
name|getSubQueryPredicateDef
argument_list|()
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UNSUPPORTED_SUBQUERY_EXPRESSION
operator|.
name|getMsg
argument_list|(
name|subQueriesInOriginalTree
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|"Nested SubQuery expressions are not supported."
argument_list|)
argument_list|)
throw|;
block|}
comment|/*          * Restriction.8.m :: We allow only 1 SubQuery expression per Query.          */
if|if
condition|(
name|subQueriesInOriginalTree
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UNSUPPORTED_SUBQUERY_EXPRESSION
operator|.
name|getMsg
argument_list|(
name|subQueriesInOriginalTree
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"Only 1 SubQuery expression is supported."
argument_list|)
argument_list|)
throw|;
block|}
comment|/*          * Clone the Search AST; apply all rewrites on the clone.          */
name|ASTNode
name|clonedSearchCond
init|=
operator|(
name|ASTNode
operator|)
name|SubQueryUtils
operator|.
name|adaptor
operator|.
name|dupTree
argument_list|(
name|searchCond
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|subQueries
init|=
name|SubQueryUtils
operator|.
name|findSubQueries
argument_list|(
name|clonedSearchCond
argument_list|)
decl_stmt|;
name|RowResolver
name|inputRR
init|=
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
name|RowResolver
name|outerQBRR
init|=
name|inputRR
decl_stmt|;
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|outerQBPosMap
init|=
name|relToHiveColNameCalcitePosMap
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subQueries
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|subQueryAST
init|=
name|subQueries
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ASTNode
name|originalSubQueryAST
init|=
name|subQueriesInOriginalTree
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|sqIdx
init|=
name|qb
operator|.
name|incrNumSubQueryPredicates
argument_list|()
decl_stmt|;
name|clonedSearchCond
operator|=
name|SubQueryUtils
operator|.
name|rewriteParentQueryWhere
argument_list|(
name|clonedSearchCond
argument_list|,
name|subQueryAST
argument_list|)
expr_stmt|;
name|QBSubQuery
name|subQuery
init|=
name|SubQueryUtils
operator|.
name|buildSubQuery
argument_list|(
name|qb
operator|.
name|getId
argument_list|()
argument_list|,
name|sqIdx
argument_list|,
name|subQueryAST
argument_list|,
name|originalSubQueryAST
argument_list|,
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|forHavingClause
condition|)
block|{
name|qb
operator|.
name|setWhereClauseSubQueryPredicate
argument_list|(
name|subQuery
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qb
operator|.
name|setHavingClauseSubQueryPredicate
argument_list|(
name|subQuery
argument_list|)
expr_stmt|;
block|}
name|String
name|havingInputAlias
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|forHavingClause
condition|)
block|{
name|havingInputAlias
operator|=
literal|"gby_sq"
operator|+
name|sqIdx
expr_stmt|;
name|aliasToRel
operator|.
name|put
argument_list|(
name|havingInputAlias
argument_list|,
name|srcRel
argument_list|)
expr_stmt|;
block|}
name|subQuery
operator|.
name|validateAndRewriteAST
argument_list|(
name|inputRR
argument_list|,
name|forHavingClause
argument_list|,
name|havingInputAlias
argument_list|,
name|aliasToRel
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|QB
name|qbSQ
init|=
operator|new
name|QB
argument_list|(
name|subQuery
operator|.
name|getOuterQueryId
argument_list|()
argument_list|,
name|subQuery
operator|.
name|getAlias
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|qbSQ
operator|.
name|setSubQueryDef
argument_list|(
name|subQuery
operator|.
name|getSubQuery
argument_list|()
argument_list|)
expr_stmt|;
name|Phase1Ctx
name|ctx_1
init|=
name|initPhase1Ctx
argument_list|()
decl_stmt|;
name|doPhase1
argument_list|(
name|subQuery
operator|.
name|getSubQueryAST
argument_list|()
argument_list|,
name|qbSQ
argument_list|,
name|ctx_1
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|getMetaData
argument_list|(
name|qbSQ
argument_list|)
expr_stmt|;
name|RelNode
name|subQueryRelNode
init|=
name|genLogicalPlan
argument_list|(
name|qbSQ
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|aliasToRel
operator|.
name|put
argument_list|(
name|subQuery
operator|.
name|getAlias
argument_list|()
argument_list|,
name|subQueryRelNode
argument_list|)
expr_stmt|;
name|RowResolver
name|sqRR
init|=
name|relToHiveRR
operator|.
name|get
argument_list|(
name|subQueryRelNode
argument_list|)
decl_stmt|;
comment|/*            * Check.5.h :: For In and Not In the SubQuery must implicitly or            * explicitly only contain one select item.            */
if|if
condition|(
name|subQuery
operator|.
name|getOperator
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|SubQueryType
operator|.
name|EXISTS
operator|&&
name|subQuery
operator|.
name|getOperator
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|SubQueryType
operator|.
name|NOT_EXISTS
operator|&&
name|sqRR
operator|.
name|getColumnInfos
argument_list|()
operator|.
name|size
argument_list|()
operator|-
name|subQuery
operator|.
name|getNumOfCorrelationExprsAddedToSQSelect
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_SUBQUERY_EXPRESSION
operator|.
name|getMsg
argument_list|(
name|subQueryAST
argument_list|,
literal|"SubQuery can contain only 1 item in Select List."
argument_list|)
argument_list|)
throw|;
block|}
comment|/*            * If this is a Not In SubQuery Predicate then Join in the Null Check            * SubQuery. See QBSubQuery.NotInCheck for details on why and how this            * is constructed.            */
if|if
condition|(
name|subQuery
operator|.
name|getNotInCheck
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|QBSubQuery
operator|.
name|NotInCheck
name|notInCheck
init|=
name|subQuery
operator|.
name|getNotInCheck
argument_list|()
decl_stmt|;
name|notInCheck
operator|.
name|setSQRR
argument_list|(
name|sqRR
argument_list|)
expr_stmt|;
name|QB
name|qbSQ_nic
init|=
operator|new
name|QB
argument_list|(
name|subQuery
operator|.
name|getOuterQueryId
argument_list|()
argument_list|,
name|notInCheck
operator|.
name|getAlias
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|qbSQ_nic
operator|.
name|setSubQueryDef
argument_list|(
name|notInCheck
operator|.
name|getSubQuery
argument_list|()
argument_list|)
expr_stmt|;
name|ctx_1
operator|=
name|initPhase1Ctx
argument_list|()
expr_stmt|;
name|doPhase1
argument_list|(
name|notInCheck
operator|.
name|getSubQueryAST
argument_list|()
argument_list|,
name|qbSQ_nic
argument_list|,
name|ctx_1
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|getMetaData
argument_list|(
name|qbSQ_nic
argument_list|)
expr_stmt|;
name|RelNode
name|subQueryNICRelNode
init|=
name|genLogicalPlan
argument_list|(
name|qbSQ_nic
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|aliasToRel
operator|.
name|put
argument_list|(
name|notInCheck
operator|.
name|getAlias
argument_list|()
argument_list|,
name|subQueryNICRelNode
argument_list|)
expr_stmt|;
name|srcRel
operator|=
name|genJoinRelNode
argument_list|(
name|srcRel
argument_list|,
name|subQueryNICRelNode
argument_list|,
comment|// set explicitly to inner until we figure out SemiJoin use
comment|// notInCheck.getJoinType(),
name|JoinType
operator|.
name|INNER
argument_list|,
name|notInCheck
operator|.
name|getJoinConditionAST
argument_list|()
argument_list|)
expr_stmt|;
name|inputRR
operator|=
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
expr_stmt|;
if|if
condition|(
name|forHavingClause
condition|)
block|{
name|aliasToRel
operator|.
name|put
argument_list|(
name|havingInputAlias
argument_list|,
name|srcRel
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*            * Gen Join between outer Operator and SQ op            */
name|subQuery
operator|.
name|buildJoinCondition
argument_list|(
name|inputRR
argument_list|,
name|sqRR
argument_list|,
name|forHavingClause
argument_list|,
name|havingInputAlias
argument_list|)
expr_stmt|;
name|srcRel
operator|=
name|genJoinRelNode
argument_list|(
name|srcRel
argument_list|,
name|subQueryRelNode
argument_list|,
name|subQuery
operator|.
name|getJoinType
argument_list|()
argument_list|,
name|subQuery
operator|.
name|getJoinConditionAST
argument_list|()
argument_list|)
expr_stmt|;
name|searchCond
operator|=
name|subQuery
operator|.
name|updateOuterQueryFilter
argument_list|(
name|clonedSearchCond
argument_list|)
expr_stmt|;
name|srcRel
operator|=
name|genFilterRelNode
argument_list|(
name|searchCond
argument_list|,
name|srcRel
argument_list|,
name|forHavingClause
argument_list|)
expr_stmt|;
comment|/*            * For Not Exists and Not In, add a projection on top of the Left            * Outer Join.            */
if|if
condition|(
name|subQuery
operator|.
name|getOperator
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|SubQueryType
operator|.
name|NOT_EXISTS
operator|||
name|subQuery
operator|.
name|getOperator
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|SubQueryType
operator|.
name|NOT_IN
condition|)
block|{
name|srcRel
operator|=
name|projectLeftOuterSide
argument_list|(
name|srcRel
argument_list|,
name|numSrcColumns
argument_list|)
expr_stmt|;
block|}
block|}
name|relToHiveRR
operator|.
name|put
argument_list|(
name|srcRel
argument_list|,
name|outerQBRR
argument_list|)
expr_stmt|;
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|srcRel
argument_list|,
name|outerQBPosMap
argument_list|)
expr_stmt|;
return|return
name|srcRel
return|;
block|}
return|return
name|genFilterRelNode
argument_list|(
name|searchCond
argument_list|,
name|srcRel
argument_list|,
name|forHavingClause
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|projectLeftOuterSide
parameter_list|(
name|RelNode
name|srcRel
parameter_list|,
name|int
name|numColumns
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|iRR
init|=
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
name|RowResolver
name|oRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|RowResolver
operator|.
name|add
argument_list|(
name|oRR
argument_list|,
name|iRR
argument_list|,
name|numColumns
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|calciteColLst
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|oFieldNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|RelDataType
name|iType
init|=
name|srcRel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iType
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RelDataTypeField
name|fType
init|=
name|iType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|fName
init|=
name|iType
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|calciteColLst
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|fType
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|oFieldNames
operator|.
name|add
argument_list|(
name|fName
argument_list|)
expr_stmt|;
block|}
name|HiveRelNode
name|selRel
init|=
name|HiveProject
operator|.
name|create
argument_list|(
name|srcRel
argument_list|,
name|calciteColLst
argument_list|,
name|oFieldNames
argument_list|)
decl_stmt|;
name|this
operator|.
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|selRel
argument_list|,
name|buildHiveToCalciteColumnMap
argument_list|(
name|oRR
argument_list|,
name|selRel
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|relToHiveRR
operator|.
name|put
argument_list|(
name|selRel
argument_list|,
name|oRR
argument_list|)
expr_stmt|;
return|return
name|selRel
return|;
block|}
specifier|private
name|RelNode
name|genFilterLogicalPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|RelNode
name|srcRel
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RelNode
argument_list|>
name|aliasToRel
parameter_list|,
name|boolean
name|forHavingClause
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RelNode
name|filterRel
init|=
literal|null
decl_stmt|;
name|Iterator
argument_list|<
name|ASTNode
argument_list|>
name|whereClauseIterator
init|=
name|getQBParseInfo
argument_list|(
name|qb
argument_list|)
operator|.
name|getDestToWhereExpr
argument_list|()
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|whereClauseIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|filterRel
operator|=
name|genFilterRelNode
argument_list|(
name|qb
argument_list|,
operator|(
name|ASTNode
operator|)
name|whereClauseIterator
operator|.
name|next
argument_list|()
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|srcRel
argument_list|,
name|aliasToRel
argument_list|,
name|forHavingClause
argument_list|)
expr_stmt|;
block|}
return|return
name|filterRel
return|;
block|}
comment|/**      * Class to store GenericUDAF related information.      */
specifier|private
class|class
name|AggInfo
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|m_aggParams
decl_stmt|;
specifier|private
specifier|final
name|TypeInfo
name|m_returnType
decl_stmt|;
specifier|private
specifier|final
name|String
name|m_udfName
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|m_distinct
decl_stmt|;
specifier|private
name|AggInfo
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|aggParams
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|,
name|String
name|udfName
parameter_list|,
name|boolean
name|isDistinct
parameter_list|)
block|{
name|m_aggParams
operator|=
name|aggParams
expr_stmt|;
name|m_returnType
operator|=
name|returnType
expr_stmt|;
name|m_udfName
operator|=
name|udfName
expr_stmt|;
name|m_distinct
operator|=
name|isDistinct
expr_stmt|;
block|}
block|}
specifier|private
name|AggregateCall
name|convertGBAgg
parameter_list|(
name|AggInfo
name|agg
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|gbChildProjLst
parameter_list|,
name|RexNodeConverter
name|converter
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|rexNodeToPosMap
parameter_list|,
name|Integer
name|childProjLstIndx
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// 1. Get agg fn ret type in Calcite
name|RelDataType
name|aggFnRetType
init|=
name|TypeConverter
operator|.
name|convert
argument_list|(
name|agg
operator|.
name|m_returnType
argument_list|,
name|this
operator|.
name|cluster
operator|.
name|getTypeFactory
argument_list|()
argument_list|)
decl_stmt|;
comment|// 2. Convert Agg Fn args and type of args to Calcite
comment|// TODO: Does HQL allows expressions as aggregate args or can it only be
comment|// projections from child?
name|Integer
name|inputIndx
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|argList
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|RexNode
name|rexNd
init|=
literal|null
decl_stmt|;
name|RelDataTypeFactory
name|dtFactory
init|=
name|this
operator|.
name|cluster
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RelDataType
argument_list|>
name|aggArgRelDTBldr
init|=
operator|new
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|expr
range|:
name|agg
operator|.
name|m_aggParams
control|)
block|{
name|rexNd
operator|=
name|converter
operator|.
name|convert
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|inputIndx
operator|=
name|rexNodeToPosMap
operator|.
name|get
argument_list|(
name|rexNd
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputIndx
operator|==
literal|null
condition|)
block|{
name|gbChildProjLst
operator|.
name|add
argument_list|(
name|rexNd
argument_list|)
expr_stmt|;
name|rexNodeToPosMap
operator|.
name|put
argument_list|(
name|rexNd
operator|.
name|toString
argument_list|()
argument_list|,
name|childProjLstIndx
argument_list|)
expr_stmt|;
name|inputIndx
operator|=
name|childProjLstIndx
expr_stmt|;
name|childProjLstIndx
operator|++
expr_stmt|;
block|}
name|argList
operator|.
name|add
argument_list|(
name|inputIndx
argument_list|)
expr_stmt|;
comment|// TODO: does arg need type cast?
name|aggArgRelDTBldr
operator|.
name|add
argument_list|(
name|TypeConverter
operator|.
name|convert
argument_list|(
name|expr
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|dtFactory
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 3. Get Aggregation FN from Calcite given name, ret type and input arg
comment|// type
specifier|final
name|SqlAggFunction
name|aggregation
init|=
name|SqlFunctionConverter
operator|.
name|getCalciteAggFn
argument_list|(
name|agg
operator|.
name|m_udfName
argument_list|,
name|aggArgRelDTBldr
operator|.
name|build
argument_list|()
argument_list|,
name|aggFnRetType
argument_list|)
decl_stmt|;
return|return
operator|new
name|AggregateCall
argument_list|(
name|aggregation
argument_list|,
name|agg
operator|.
name|m_distinct
argument_list|,
name|argList
argument_list|,
name|aggFnRetType
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|genGBRelNode
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|gbExprs
parameter_list|,
name|List
argument_list|<
name|AggInfo
argument_list|>
name|aggInfoLst
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|groupSets
parameter_list|,
name|RelNode
name|srcRel
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|posMap
init|=
name|this
operator|.
name|relToHiveColNameCalcitePosMap
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
name|RexNodeConverter
name|converter
init|=
operator|new
name|RexNodeConverter
argument_list|(
name|this
operator|.
name|cluster
argument_list|,
name|srcRel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|posMap
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|hasGroupSets
init|=
name|groupSets
operator|!=
literal|null
operator|&&
operator|!
name|groupSets
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|gbChildProjLst
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|rexNodeToPosMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|groupSetPositions
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|Integer
name|gbIndx
init|=
literal|0
decl_stmt|;
name|RexNode
name|rnd
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|key
range|:
name|gbExprs
control|)
block|{
name|rnd
operator|=
name|converter
operator|.
name|convert
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|gbChildProjLst
operator|.
name|add
argument_list|(
name|rnd
argument_list|)
expr_stmt|;
name|groupSetPositions
operator|.
name|add
argument_list|(
name|gbIndx
argument_list|)
expr_stmt|;
name|rexNodeToPosMap
operator|.
name|put
argument_list|(
name|rnd
operator|.
name|toString
argument_list|()
argument_list|,
name|gbIndx
argument_list|)
expr_stmt|;
name|gbIndx
operator|++
expr_stmt|;
block|}
specifier|final
name|ImmutableBitSet
name|groupSet
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|groupSetPositions
argument_list|)
decl_stmt|;
comment|// Grouping sets: we need to transform them into ImmutableBitSet
comment|// objects for Calcite
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
name|transformedGroupSets
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|hasGroupSets
condition|)
block|{
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
name|setTransformedGroupSets
init|=
operator|new
name|HashSet
argument_list|<
name|ImmutableBitSet
argument_list|>
argument_list|(
name|groupSets
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|val
range|:
name|groupSets
control|)
block|{
name|setTransformedGroupSets
operator|.
name|add
argument_list|(
name|convert
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Calcite expects the grouping sets sorted and without duplicates
name|transformedGroupSets
operator|=
operator|new
name|ArrayList
argument_list|<
name|ImmutableBitSet
argument_list|>
argument_list|(
name|setTransformedGroupSets
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|transformedGroupSets
argument_list|,
name|ImmutableBitSet
operator|.
name|COMPARATOR
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggregateCalls
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|AggInfo
name|agg
range|:
name|aggInfoLst
control|)
block|{
name|aggregateCalls
operator|.
name|add
argument_list|(
name|convertGBAgg
argument_list|(
name|agg
argument_list|,
name|srcRel
argument_list|,
name|gbChildProjLst
argument_list|,
name|converter
argument_list|,
name|rexNodeToPosMap
argument_list|,
name|gbChildProjLst
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasGroupSets
condition|)
block|{
comment|// Create GroupingID column
name|AggregateCall
name|aggCall
init|=
operator|new
name|AggregateCall
argument_list|(
name|HiveGroupingID
operator|.
name|INSTANCE
argument_list|,
literal|false
argument_list|,
operator|new
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Integer
argument_list|>
argument_list|()
operator|.
name|build
argument_list|()
argument_list|,
name|this
operator|.
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
argument_list|,
name|HiveGroupingID
operator|.
name|INSTANCE
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|aggregateCalls
operator|.
name|add
argument_list|(
name|aggCall
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gbChildProjLst
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// This will happen for count(*), in such cases we arbitarily pick
comment|// first element from srcRel
name|gbChildProjLst
operator|.
name|add
argument_list|(
name|this
operator|.
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|srcRel
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RelNode
name|gbInputRel
init|=
name|HiveProject
operator|.
name|create
argument_list|(
name|srcRel
argument_list|,
name|gbChildProjLst
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|HiveRelNode
name|aggregateRel
init|=
literal|null
decl_stmt|;
try|try
block|{
name|aggregateRel
operator|=
operator|new
name|HiveAggregate
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRelNode
operator|.
name|CONVENTION
argument_list|)
argument_list|,
name|gbInputRel
argument_list|,
operator|(
name|transformedGroupSets
operator|!=
literal|null
condition|?
literal|true
else|:
literal|false
operator|)
argument_list|,
name|groupSet
argument_list|,
name|transformedGroupSets
argument_list|,
name|aggregateCalls
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidRelException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|aggregateRel
return|;
block|}
specifier|private
name|ImmutableBitSet
name|convert
parameter_list|(
name|int
name|value
parameter_list|)
block|{
name|BitSet
name|bits
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|value
operator|!=
literal|0L
condition|)
block|{
if|if
condition|(
name|value
operator|%
literal|2
operator|!=
literal|0
condition|)
block|{
name|bits
operator|.
name|set
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
operator|++
name|index
expr_stmt|;
name|value
operator|=
name|value
operator|>>>
literal|1
expr_stmt|;
block|}
return|return
name|ImmutableBitSet
operator|.
name|FROM_BIT_SET
operator|.
name|apply
argument_list|(
name|bits
argument_list|)
return|;
block|}
specifier|private
name|void
name|addAlternateGByKeyMappings
parameter_list|(
name|ASTNode
name|gByExpr
parameter_list|,
name|ColumnInfo
name|colInfo
parameter_list|,
name|RowResolver
name|gByInputRR
parameter_list|,
name|RowResolver
name|gByRR
parameter_list|)
block|{
if|if
condition|(
name|gByExpr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|DOT
operator|&&
name|gByExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
condition|)
block|{
name|String
name|tab_alias
init|=
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|gByExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|col_alias
init|=
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|gByExpr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|gByRR
operator|.
name|put
argument_list|(
name|tab_alias
argument_list|,
name|col_alias
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gByExpr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
condition|)
block|{
name|String
name|col_alias
init|=
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|gByExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|tab_alias
init|=
literal|null
decl_stmt|;
comment|/*          * If the input to the GBy has a tab alias for the column, then add an          * entry based on that tab_alias. For e.g. this query: select b.x,          * count(*) from t1 b group by x needs (tab_alias=b, col_alias=x) in the          * GBy RR. tab_alias=b comes from looking at the RowResolver that is the          * ancestor before any GBy/ReduceSinks added for the GBY operation.          */
try|try
block|{
name|ColumnInfo
name|pColInfo
init|=
name|gByInputRR
operator|.
name|get
argument_list|(
name|tab_alias
argument_list|,
name|col_alias
argument_list|)
decl_stmt|;
name|tab_alias
operator|=
name|pColInfo
operator|==
literal|null
condition|?
literal|null
else|:
name|pColInfo
operator|.
name|getTabAlias
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|se
parameter_list|)
block|{         }
name|gByRR
operator|.
name|put
argument_list|(
name|tab_alias
argument_list|,
name|col_alias
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|addToGBExpr
parameter_list|(
name|RowResolver
name|groupByOutputRowResolver
parameter_list|,
name|RowResolver
name|groupByInputRowResolver
parameter_list|,
name|ASTNode
name|grpbyExpr
parameter_list|,
name|ExprNodeDesc
name|grpbyExprNDesc
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|gbExprNDescLst
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|outputColumnNames
parameter_list|)
block|{
comment|// TODO: Should we use grpbyExprNDesc.getTypeInfo()? what if expr is
comment|// UDF
name|int
name|i
init|=
name|gbExprNDescLst
operator|.
name|size
argument_list|()
decl_stmt|;
name|String
name|field
init|=
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|gbExprNDescLst
operator|.
name|add
argument_list|(
name|grpbyExprNDesc
argument_list|)
expr_stmt|;
name|ColumnInfo
name|oColInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|grpbyExprNDesc
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|groupByOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|grpbyExpr
argument_list|,
name|oColInfo
argument_list|)
expr_stmt|;
name|addAlternateGByKeyMappings
argument_list|(
name|grpbyExpr
argument_list|,
name|oColInfo
argument_list|,
name|groupByInputRowResolver
argument_list|,
name|groupByOutputRowResolver
argument_list|)
expr_stmt|;
block|}
specifier|private
name|AggInfo
name|getHiveAggInfo
parameter_list|(
name|ASTNode
name|aggAst
parameter_list|,
name|int
name|aggFnLstArgIndx
parameter_list|,
name|RowResolver
name|inputRR
parameter_list|)
throws|throws
name|SemanticException
block|{
name|AggInfo
name|aInfo
init|=
literal|null
decl_stmt|;
comment|// 1 Convert UDAF Params to ExprNodeDesc
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|aggParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|aggFnLstArgIndx
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|paraExpr
init|=
operator|(
name|ASTNode
operator|)
name|aggAst
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|paraExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|paraExpr
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|aggParameters
operator|.
name|add
argument_list|(
name|paraExprNode
argument_list|)
expr_stmt|;
block|}
comment|// 2. Is this distinct UDAF
name|boolean
name|isDistinct
init|=
name|aggAst
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
decl_stmt|;
comment|// 3. Determine type of UDAF
name|TypeInfo
name|udafRetType
init|=
literal|null
decl_stmt|;
comment|// 3.1 Obtain UDAF name
name|String
name|aggName
init|=
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|aggAst
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
comment|// 3.2 Rank functions type is 'int'/'double'
if|if
condition|(
name|FunctionRegistry
operator|.
name|isRankingFunction
argument_list|(
name|aggName
argument_list|)
condition|)
block|{
if|if
condition|(
name|aggName
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"percent_rank"
argument_list|)
condition|)
name|udafRetType
operator|=
name|TypeInfoFactory
operator|.
name|doubleTypeInfo
expr_stmt|;
else|else
name|udafRetType
operator|=
name|TypeInfoFactory
operator|.
name|intTypeInfo
expr_stmt|;
block|}
else|else
block|{
comment|// 3.3 Try obtaining UDAF evaluators to determine the ret type
try|try
block|{
name|boolean
name|isAllColumns
init|=
name|aggAst
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONSTAR
decl_stmt|;
comment|// 3.3.1 Get UDAF Evaluator
name|Mode
name|amode
init|=
name|SemanticAnalyzer
operator|.
name|groupByDescModeToUDAFMode
argument_list|(
name|GroupByDesc
operator|.
name|Mode
operator|.
name|COMPLETE
argument_list|,
name|isDistinct
argument_list|)
decl_stmt|;
name|GenericUDAFEvaluator
name|genericUDAFEvaluator
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|aggName
operator|.
name|toLowerCase
argument_list|()
operator|.
name|equals
argument_list|(
name|FunctionRegistry
operator|.
name|LEAD_FUNC_NAME
argument_list|)
operator|||
name|aggName
operator|.
name|toLowerCase
argument_list|()
operator|.
name|equals
argument_list|(
name|FunctionRegistry
operator|.
name|LAG_FUNC_NAME
argument_list|)
condition|)
block|{
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
name|originalParameterTypeInfos
init|=
name|SemanticAnalyzer
operator|.
name|getWritableObjectInspector
argument_list|(
name|aggParameters
argument_list|)
decl_stmt|;
name|genericUDAFEvaluator
operator|=
name|FunctionRegistry
operator|.
name|getGenericWindowingEvaluator
argument_list|(
name|aggName
argument_list|,
name|originalParameterTypeInfos
argument_list|,
name|isDistinct
argument_list|,
name|isAllColumns
argument_list|)
expr_stmt|;
name|GenericUDAFInfo
name|udaf
init|=
name|SemanticAnalyzer
operator|.
name|getGenericUDAFInfo
argument_list|(
name|genericUDAFEvaluator
argument_list|,
name|amode
argument_list|,
name|aggParameters
argument_list|)
decl_stmt|;
name|udafRetType
operator|=
operator|(
operator|(
name|ListTypeInfo
operator|)
name|udaf
operator|.
name|returnType
operator|)
operator|.
name|getListElementTypeInfo
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|genericUDAFEvaluator
operator|=
name|SemanticAnalyzer
operator|.
name|getGenericUDAFEvaluator
argument_list|(
name|aggName
argument_list|,
name|aggParameters
argument_list|,
name|aggAst
argument_list|,
name|isDistinct
argument_list|,
name|isAllColumns
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|genericUDAFEvaluator
operator|!=
literal|null
operator|)
assert|;
comment|// 3.3.2 Get UDAF Info using UDAF Evaluator
name|GenericUDAFInfo
name|udaf
init|=
name|SemanticAnalyzer
operator|.
name|getGenericUDAFInfo
argument_list|(
name|genericUDAFEvaluator
argument_list|,
name|amode
argument_list|,
name|aggParameters
argument_list|)
decl_stmt|;
if|if
condition|(
name|FunctionRegistry
operator|.
name|pivotResult
argument_list|(
name|aggName
argument_list|)
condition|)
block|{
name|udafRetType
operator|=
operator|(
operator|(
name|ListTypeInfo
operator|)
name|udaf
operator|.
name|returnType
operator|)
operator|.
name|getListElementTypeInfo
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|udafRetType
operator|=
name|udaf
operator|.
name|returnType
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"CBO: Couldn't Obtain UDAF evaluators for "
operator|+
name|aggName
operator|+
literal|", trying to translate to GenericUDF"
argument_list|)
expr_stmt|;
block|}
comment|// 3.4 Try GenericUDF translation
if|if
condition|(
name|udafRetType
operator|==
literal|null
condition|)
block|{
name|TypeCheckCtx
name|tcCtx
init|=
operator|new
name|TypeCheckCtx
argument_list|(
name|inputRR
argument_list|)
decl_stmt|;
comment|// We allow stateful functions in the SELECT list (but nowhere else)
name|tcCtx
operator|.
name|setAllowStatefulFunctions
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|tcCtx
operator|.
name|setAllowDistinctFunctions
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|exp
init|=
name|genExprNodeDesc
argument_list|(
operator|(
name|ASTNode
operator|)
name|aggAst
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|inputRR
argument_list|,
name|tcCtx
argument_list|)
decl_stmt|;
name|udafRetType
operator|=
name|exp
operator|.
name|getTypeInfo
argument_list|()
expr_stmt|;
block|}
block|}
comment|// 4. Construct AggInfo
name|aInfo
operator|=
operator|new
name|AggInfo
argument_list|(
name|aggParameters
argument_list|,
name|udafRetType
argument_list|,
name|aggName
argument_list|,
name|isDistinct
argument_list|)
expr_stmt|;
return|return
name|aInfo
return|;
block|}
comment|/**      * Generate GB plan.      *      * @param qb      * @param srcRel      * @return TODO: 1. Grouping Sets (roll up..)      * @throws SemanticException      */
specifier|private
name|RelNode
name|genGBLogicalPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|RelNode
name|srcRel
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RelNode
name|gbRel
init|=
literal|null
decl_stmt|;
name|QBParseInfo
name|qbp
init|=
name|getQBParseInfo
argument_list|(
name|qb
argument_list|)
decl_stmt|;
comment|// 1. Gather GB Expressions (AST) (GB + Aggregations)
comment|// NOTE: Multi Insert is not supported
name|String
name|detsClauseName
init|=
name|qbp
operator|.
name|getClauseNames
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// Check and transform group by *. This will only happen for select distinct *.
comment|// Here the "genSelectPlan" is being leveraged.
comment|// The main benefits are (1) remove virtual columns that should
comment|// not be included in the group by; (2) add the fully qualified column names to unParseTranslator
comment|// so that view is supported. The drawback is that an additional SEL op is added. If it is
comment|// not necessary, it will be removed by NonBlockingOpDeDupProc Optimizer because it will match
comment|// SEL%SEL% rule.
name|ASTNode
name|selExprList
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSelForClause
argument_list|(
name|detsClauseName
argument_list|)
decl_stmt|;
if|if
condition|(
name|selExprList
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SELECTDI
operator|&&
name|selExprList
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
operator|&&
name|selExprList
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|ASTNode
name|node
init|=
operator|(
name|ASTNode
operator|)
name|selExprList
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALLCOLREF
condition|)
block|{
name|srcRel
operator|=
name|genSelectLogicalPlan
argument_list|(
name|qb
argument_list|,
name|srcRel
argument_list|,
name|srcRel
argument_list|)
expr_stmt|;
name|RowResolver
name|rr
init|=
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
name|qbp
operator|.
name|setSelExprForClause
argument_list|(
name|detsClauseName
argument_list|,
name|SemanticAnalyzer
operator|.
name|genSelectDIAST
argument_list|(
name|rr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByAstExprs
init|=
name|SemanticAnalyzer
operator|.
name|getGroupByForClause
argument_list|(
name|qbp
argument_list|,
name|detsClauseName
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|qbp
operator|.
name|getAggregationExprsForClause
argument_list|(
name|detsClauseName
argument_list|)
decl_stmt|;
name|boolean
name|hasGrpByAstExprs
init|=
operator|(
name|grpByAstExprs
operator|!=
literal|null
operator|&&
operator|!
name|grpByAstExprs
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
literal|true
else|:
literal|false
decl_stmt|;
name|boolean
name|hasAggregationTrees
init|=
operator|(
name|aggregationTrees
operator|!=
literal|null
operator|&&
operator|!
name|aggregationTrees
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
literal|true
else|:
literal|false
decl_stmt|;
specifier|final
name|boolean
name|cubeRollupGrpSetPresent
init|=
operator|(
operator|!
name|qbp
operator|.
name|getDestRollups
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|qbp
operator|.
name|getDestGroupingSets
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|qbp
operator|.
name|getDestCubes
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
decl_stmt|;
comment|// 2. Sanity check
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEGROUPBYSKEW
argument_list|)
operator|&&
name|qbp
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|detsClauseName
argument_list|)
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UNSUPPORTED_MULTIPLE_DISTINCTS
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|cubeRollupGrpSetPresent
condition|)
block|{
if|if
condition|(
operator|!
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPSIDEAGGREGATE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|HIVE_GROUPING_SETS_AGGR_NOMAPAGGR
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEGROUPBYSKEW
argument_list|)
condition|)
block|{
name|checkExpressionsForGroupingSet
argument_list|(
name|grpByAstExprs
argument_list|,
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|detsClauseName
argument_list|)
argument_list|,
name|aggregationTrees
argument_list|,
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qbp
operator|.
name|getDestGroupingSets
argument_list|()
operator|.
name|size
argument_list|()
operator|>
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_NEW_JOB_GROUPING_SET_CARDINALITY
argument_list|)
condition|)
block|{
name|String
name|errorMsg
init|=
literal|"The number of rows per input row due to grouping sets is "
operator|+
name|qbp
operator|.
name|getDestGroupingSets
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|HIVE_GROUPING_SETS_THRESHOLD_NOT_ALLOWED_WITH_SKEW
operator|.
name|getMsg
argument_list|(
name|errorMsg
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|hasGrpByAstExprs
operator|||
name|hasAggregationTrees
condition|)
block|{
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|gbExprNDescLst
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// 3. Input, Output Row Resolvers
name|RowResolver
name|groupByInputRowResolver
init|=
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
name|RowResolver
name|groupByOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|groupByOutputRowResolver
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasGrpByAstExprs
condition|)
block|{
comment|// 4. Construct GB Keys (ExprNode)
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByAstExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByAstExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
name|astToExprNDescMap
init|=
name|TypeCheckProcFactory
operator|.
name|genExprNode
argument_list|(
name|grpbyExpr
argument_list|,
operator|new
name|TypeCheckCtx
argument_list|(
name|groupByInputRowResolver
argument_list|)
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|grpbyExprNDesc
init|=
name|astToExprNDescMap
operator|.
name|get
argument_list|(
name|grpbyExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|grpbyExprNDesc
operator|==
literal|null
condition|)
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
literal|"Invalid Column Reference: "
operator|+
name|grpbyExpr
operator|.
name|dump
argument_list|()
argument_list|,
name|UnsupportedFeature
operator|.
name|Invalid_column_reference
argument_list|)
throw|;
name|addToGBExpr
argument_list|(
name|groupByOutputRowResolver
argument_list|,
name|groupByInputRowResolver
argument_list|,
name|grpbyExpr
argument_list|,
name|grpbyExprNDesc
argument_list|,
name|gbExprNDescLst
argument_list|,
name|outputColumnNames
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 5. GroupingSets, Cube, Rollup
name|int
name|groupingColsSize
init|=
name|gbExprNDescLst
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|groupingSets
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|cubeRollupGrpSetPresent
condition|)
block|{
if|if
condition|(
name|qbp
operator|.
name|getDestRollups
argument_list|()
operator|.
name|contains
argument_list|(
name|detsClauseName
argument_list|)
condition|)
block|{
name|groupingSets
operator|=
name|getGroupingSetsForRollup
argument_list|(
name|grpByAstExprs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qbp
operator|.
name|getDestCubes
argument_list|()
operator|.
name|contains
argument_list|(
name|detsClauseName
argument_list|)
condition|)
block|{
name|groupingSets
operator|=
name|getGroupingSetsForCube
argument_list|(
name|grpByAstExprs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qbp
operator|.
name|getDestGroupingSets
argument_list|()
operator|.
name|contains
argument_list|(
name|detsClauseName
argument_list|)
condition|)
block|{
name|groupingSets
operator|=
name|getGroupingSets
argument_list|(
name|grpByAstExprs
argument_list|,
name|qbp
argument_list|,
name|detsClauseName
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|limit
init|=
name|groupingColsSize
operator|*
literal|2
decl_stmt|;
while|while
condition|(
name|groupingColsSize
operator|<
name|limit
condition|)
block|{
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|groupingColsSize
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|put
argument_list|(
literal|null
argument_list|,
name|field
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|TypeInfoFactory
operator|.
name|booleanTypeInfo
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|groupingColsSize
operator|++
expr_stmt|;
block|}
block|}
comment|// 6. Construct aggregation function Info
name|ArrayList
argument_list|<
name|AggInfo
argument_list|>
name|aggregations
init|=
operator|new
name|ArrayList
argument_list|<
name|AggInfo
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasAggregationTrees
condition|)
block|{
assert|assert
operator|(
name|aggregationTrees
operator|!=
literal|null
operator|)
assert|;
for|for
control|(
name|ASTNode
name|value
range|:
name|aggregationTrees
operator|.
name|values
argument_list|()
control|)
block|{
comment|// 6.1 Determine type of UDAF
comment|// This is the GenericUDAF name
name|String
name|aggName
init|=
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|value
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|isDistinct
init|=
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
decl_stmt|;
name|boolean
name|isAllColumns
init|=
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONSTAR
decl_stmt|;
comment|// 6.2 Convert UDAF Params to ExprNodeDesc
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|aggParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|paraExpr
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|paraExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|paraExpr
argument_list|,
name|groupByInputRowResolver
argument_list|)
decl_stmt|;
name|aggParameters
operator|.
name|add
argument_list|(
name|paraExprNode
argument_list|)
expr_stmt|;
block|}
name|Mode
name|amode
init|=
name|SemanticAnalyzer
operator|.
name|groupByDescModeToUDAFMode
argument_list|(
name|GroupByDesc
operator|.
name|Mode
operator|.
name|COMPLETE
argument_list|,
name|isDistinct
argument_list|)
decl_stmt|;
name|GenericUDAFEvaluator
name|genericUDAFEvaluator
init|=
name|SemanticAnalyzer
operator|.
name|getGenericUDAFEvaluator
argument_list|(
name|aggName
argument_list|,
name|aggParameters
argument_list|,
name|value
argument_list|,
name|isDistinct
argument_list|,
name|isAllColumns
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|genericUDAFEvaluator
operator|!=
literal|null
operator|)
assert|;
name|GenericUDAFInfo
name|udaf
init|=
name|SemanticAnalyzer
operator|.
name|getGenericUDAFInfo
argument_list|(
name|genericUDAFEvaluator
argument_list|,
name|amode
argument_list|,
name|aggParameters
argument_list|)
decl_stmt|;
name|AggInfo
name|aInfo
init|=
operator|new
name|AggInfo
argument_list|(
name|aggParameters
argument_list|,
name|udaf
operator|.
name|returnType
argument_list|,
name|aggName
argument_list|,
name|isDistinct
argument_list|)
decl_stmt|;
name|aggregations
operator|.
name|add
argument_list|(
name|aInfo
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|groupingColsSize
operator|+
name|aggregations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|value
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|aInfo
operator|.
name|m_returnType
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 7. If GroupingSets, Cube, Rollup were used, we account grouping__id
if|if
condition|(
name|groupingSets
operator|!=
literal|null
operator|&&
operator|!
name|groupingSets
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|groupingColsSize
operator|+
name|aggregations
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|put
argument_list|(
literal|null
argument_list|,
name|VirtualColumn
operator|.
name|GROUPINGID
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|TypeInfoFactory
operator|.
name|intTypeInfo
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 8. We create the group_by operator
name|gbRel
operator|=
name|genGBRelNode
argument_list|(
name|gbExprNDescLst
argument_list|,
name|aggregations
argument_list|,
name|groupingSets
argument_list|,
name|srcRel
argument_list|)
expr_stmt|;
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|gbRel
argument_list|,
name|buildHiveToCalciteColumnMap
argument_list|(
name|groupByOutputRowResolver
argument_list|,
name|gbRel
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|relToHiveRR
operator|.
name|put
argument_list|(
name|gbRel
argument_list|,
name|groupByOutputRowResolver
argument_list|)
expr_stmt|;
block|}
return|return
name|gbRel
return|;
block|}
comment|/**      * Generate OB RelNode and input Select RelNode that should be used to      * introduce top constraining Project. If Input select RelNode is not      * present then don't introduce top constraining select.      *      * @param qb      * @param srcRel      * @param outermostOB      * @return Pair<RelNode, RelNode> Key- OB RelNode, Value - Input Select for      *         top constraining Select      * @throws SemanticException      */
specifier|private
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|>
name|genOBLogicalPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|RelNode
name|srcRel
parameter_list|,
name|boolean
name|outermostOB
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RelNode
name|sortRel
init|=
literal|null
decl_stmt|;
name|RelNode
name|originalOBChild
init|=
literal|null
decl_stmt|;
name|QBParseInfo
name|qbp
init|=
name|getQBParseInfo
argument_list|(
name|qb
argument_list|)
decl_stmt|;
name|String
name|dest
init|=
name|qbp
operator|.
name|getClauseNames
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|ASTNode
name|obAST
init|=
name|qbp
operator|.
name|getOrderByForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|obAST
operator|!=
literal|null
condition|)
block|{
comment|// 1. OB Expr sanity test
comment|// in strict mode, in the presence of order by, limit must be specified
name|Integer
name|limit
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestLimit
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPREDMODE
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"strict"
argument_list|)
operator|&&
name|limit
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|SemanticAnalyzer
operator|.
name|generateErrorMessage
argument_list|(
name|obAST
argument_list|,
name|ErrorMsg
operator|.
name|NO_LIMIT_WITH_ORDERBY
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|// 2. Walk through OB exprs and extract field collations and additional
comment|// virtual columns needed
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|newVCLst
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|fieldCollations
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|int
name|fieldIndex
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|obASTExprLst
init|=
name|obAST
operator|.
name|getChildren
argument_list|()
decl_stmt|;
name|ASTNode
name|obASTExpr
decl_stmt|;
name|List
argument_list|<
name|Pair
argument_list|<
name|ASTNode
argument_list|,
name|TypeInfo
argument_list|>
argument_list|>
name|vcASTTypePairs
init|=
operator|new
name|ArrayList
argument_list|<
name|Pair
argument_list|<
name|ASTNode
argument_list|,
name|TypeInfo
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|RowResolver
name|inputRR
init|=
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
name|RowResolver
name|outputRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|RexNode
name|rnd
decl_stmt|;
name|RexNodeConverter
name|converter
init|=
operator|new
name|RexNodeConverter
argument_list|(
name|cluster
argument_list|,
name|srcRel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|relToHiveColNameCalcitePosMap
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|srcRelRecordSz
init|=
name|srcRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|obASTExprLst
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// 2.1 Convert AST Expr to ExprNode
name|obASTExpr
operator|=
operator|(
name|ASTNode
operator|)
name|obASTExprLst
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
name|astToExprNDescMap
init|=
name|TypeCheckProcFactory
operator|.
name|genExprNode
argument_list|(
name|obASTExpr
argument_list|,
operator|new
name|TypeCheckCtx
argument_list|(
name|inputRR
argument_list|)
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|obExprNDesc
init|=
name|astToExprNDescMap
operator|.
name|get
argument_list|(
name|obASTExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|obExprNDesc
operator|==
literal|null
condition|)
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Invalid order by expression: "
operator|+
name|obASTExpr
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
comment|// 2.2 Convert ExprNode to RexNode
name|rnd
operator|=
name|converter
operator|.
name|convert
argument_list|(
name|obExprNDesc
argument_list|)
expr_stmt|;
comment|// 2.3 Determine the index of ob expr in child schema
comment|// NOTE: Calcite can not take compound exprs in OB without it being
comment|// present in the child (& hence we add a child Project Rel)
if|if
condition|(
name|rnd
operator|instanceof
name|RexInputRef
condition|)
block|{
name|fieldIndex
operator|=
operator|(
operator|(
name|RexInputRef
operator|)
name|rnd
operator|)
operator|.
name|getIndex
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|fieldIndex
operator|=
name|srcRelRecordSz
operator|+
name|newVCLst
operator|.
name|size
argument_list|()
expr_stmt|;
name|newVCLst
operator|.
name|add
argument_list|(
name|rnd
argument_list|)
expr_stmt|;
name|vcASTTypePairs
operator|.
name|add
argument_list|(
operator|new
name|Pair
argument_list|<
name|ASTNode
argument_list|,
name|TypeInfo
argument_list|>
argument_list|(
operator|(
name|ASTNode
operator|)
name|obASTExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|obExprNDesc
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 2.4 Determine the Direction of order by
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelFieldCollation
operator|.
name|Direction
name|order
init|=
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|DESCENDING
decl_stmt|;
if|if
condition|(
name|obASTExpr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABSORTCOLNAMEASC
condition|)
block|{
name|order
operator|=
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|ASCENDING
expr_stmt|;
block|}
comment|// 2.5 Add to field collations
name|fieldCollations
operator|.
name|add
argument_list|(
operator|new
name|RelFieldCollation
argument_list|(
name|fieldIndex
argument_list|,
name|order
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 3. Add Child Project Rel if needed, Generate Output RR, input Sel Rel
comment|// for top constraining Sel
name|RelNode
name|obInputRel
init|=
name|srcRel
decl_stmt|;
if|if
condition|(
operator|!
name|newVCLst
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|originalInputRefs
init|=
name|Lists
operator|.
name|transform
argument_list|(
name|srcRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|,
operator|new
name|Function
argument_list|<
name|RelDataTypeField
argument_list|,
name|RexNode
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|apply
parameter_list|(
name|RelDataTypeField
name|input
parameter_list|)
block|{
return|return
operator|new
name|RexInputRef
argument_list|(
name|input
operator|.
name|getIndex
argument_list|()
argument_list|,
name|input
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|RowResolver
name|obSyntheticProjectRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|RowResolver
operator|.
name|add
argument_list|(
name|obSyntheticProjectRR
argument_list|,
name|inputRR
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
literal|"Duplicates detected when adding columns to RR: see previous message"
argument_list|,
name|UnsupportedFeature
operator|.
name|Duplicates_in_RR
argument_list|)
throw|;
block|}
name|int
name|vcolPos
init|=
name|inputRR
operator|.
name|getRowSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|ASTNode
argument_list|,
name|TypeInfo
argument_list|>
name|astTypePair
range|:
name|vcASTTypePairs
control|)
block|{
name|obSyntheticProjectRR
operator|.
name|putExpression
argument_list|(
name|astTypePair
operator|.
name|getKey
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|vcolPos
argument_list|)
argument_list|,
name|astTypePair
operator|.
name|getValue
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|vcolPos
operator|++
expr_stmt|;
block|}
name|obInputRel
operator|=
name|genSelectRelNode
argument_list|(
name|CompositeList
operator|.
name|of
argument_list|(
name|originalInputRefs
argument_list|,
name|newVCLst
argument_list|)
argument_list|,
name|obSyntheticProjectRR
argument_list|,
name|srcRel
argument_list|)
expr_stmt|;
if|if
condition|(
name|outermostOB
condition|)
block|{
if|if
condition|(
operator|!
name|RowResolver
operator|.
name|add
argument_list|(
name|outputRR
argument_list|,
name|inputRR
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
literal|"Duplicates detected when adding columns to RR: see previous message"
argument_list|,
name|UnsupportedFeature
operator|.
name|Duplicates_in_RR
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|RowResolver
operator|.
name|add
argument_list|(
name|outputRR
argument_list|,
name|obSyntheticProjectRR
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
literal|"Duplicates detected when adding columns to RR: see previous message"
argument_list|,
name|UnsupportedFeature
operator|.
name|Duplicates_in_RR
argument_list|)
throw|;
block|}
name|originalOBChild
operator|=
name|srcRel
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|RowResolver
operator|.
name|add
argument_list|(
name|outputRR
argument_list|,
name|inputRR
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
literal|"Duplicates detected when adding columns to RR: see previous message"
argument_list|,
name|UnsupportedFeature
operator|.
name|Duplicates_in_RR
argument_list|)
throw|;
block|}
block|}
comment|// 4. Construct SortRel
name|RelTraitSet
name|traitSet
init|=
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRelNode
operator|.
name|CONVENTION
argument_list|)
decl_stmt|;
name|RelCollation
name|canonizedCollation
init|=
name|traitSet
operator|.
name|canonize
argument_list|(
name|RelCollationImpl
operator|.
name|of
argument_list|(
name|fieldCollations
argument_list|)
argument_list|)
decl_stmt|;
name|sortRel
operator|=
operator|new
name|HiveSortLimit
argument_list|(
name|cluster
argument_list|,
name|traitSet
argument_list|,
name|obInputRel
argument_list|,
name|canonizedCollation
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// 5. Update the maps
comment|// NOTE: Output RR for SortRel is considered same as its input; we may
comment|// end up not using VC that is present in sort rel. Also note that
comment|// rowtype of sortrel is the type of it child; if child happens to be
comment|// synthetic project that we introduced then that projectrel would
comment|// contain the vc.
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|hiveColNameCalcitePosMap
init|=
name|buildHiveToCalciteColumnMap
argument_list|(
name|outputRR
argument_list|,
name|sortRel
argument_list|)
decl_stmt|;
name|relToHiveRR
operator|.
name|put
argument_list|(
name|sortRel
argument_list|,
name|outputRR
argument_list|)
expr_stmt|;
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|sortRel
argument_list|,
name|hiveColNameCalcitePosMap
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|new
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|>
argument_list|(
name|sortRel
argument_list|,
name|originalOBChild
argument_list|)
operator|)
return|;
block|}
specifier|private
name|RelNode
name|genLimitLogicalPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|RelNode
name|srcRel
parameter_list|)
throws|throws
name|SemanticException
block|{
name|HiveRelNode
name|sortRel
init|=
literal|null
decl_stmt|;
name|QBParseInfo
name|qbp
init|=
name|getQBParseInfo
argument_list|(
name|qb
argument_list|)
decl_stmt|;
name|Integer
name|limit
init|=
name|qbp
operator|.
name|getDestToLimit
argument_list|()
operator|.
name|get
argument_list|(
name|qbp
operator|.
name|getClauseNames
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|limit
operator|!=
literal|null
condition|)
block|{
name|RexNode
name|fetch
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|limit
argument_list|)
argument_list|)
decl_stmt|;
name|RelTraitSet
name|traitSet
init|=
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRelNode
operator|.
name|CONVENTION
argument_list|)
decl_stmt|;
name|RelCollation
name|canonizedCollation
init|=
name|traitSet
operator|.
name|canonize
argument_list|(
name|RelCollations
operator|.
name|EMPTY
argument_list|)
decl_stmt|;
name|sortRel
operator|=
operator|new
name|HiveSortLimit
argument_list|(
name|cluster
argument_list|,
name|traitSet
argument_list|,
name|srcRel
argument_list|,
name|canonizedCollation
argument_list|,
literal|null
argument_list|,
name|fetch
argument_list|)
expr_stmt|;
name|RowResolver
name|outputRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|RowResolver
operator|.
name|add
argument_list|(
name|outputRR
argument_list|,
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
literal|"Duplicates detected when adding columns to RR: see previous message"
argument_list|,
name|UnsupportedFeature
operator|.
name|Duplicates_in_RR
argument_list|)
throw|;
block|}
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|hiveColNameCalcitePosMap
init|=
name|buildHiveToCalciteColumnMap
argument_list|(
name|outputRR
argument_list|,
name|sortRel
argument_list|)
decl_stmt|;
name|relToHiveRR
operator|.
name|put
argument_list|(
name|sortRel
argument_list|,
name|outputRR
argument_list|)
expr_stmt|;
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|sortRel
argument_list|,
name|hiveColNameCalcitePosMap
argument_list|)
expr_stmt|;
block|}
return|return
name|sortRel
return|;
block|}
specifier|private
name|List
argument_list|<
name|RexNode
argument_list|>
name|getPartitionKeys
parameter_list|(
name|PartitionSpec
name|ps
parameter_list|,
name|RexNodeConverter
name|converter
parameter_list|,
name|RowResolver
name|inputRR
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|pKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|ps
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|PartitionExpression
argument_list|>
name|pExprs
init|=
name|ps
operator|.
name|getExpressions
argument_list|()
decl_stmt|;
for|for
control|(
name|PartitionExpression
name|pExpr
range|:
name|pExprs
control|)
block|{
name|TypeCheckCtx
name|tcCtx
init|=
operator|new
name|TypeCheckCtx
argument_list|(
name|inputRR
argument_list|)
decl_stmt|;
name|tcCtx
operator|.
name|setAllowStatefulFunctions
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|exp
init|=
name|genExprNodeDesc
argument_list|(
name|pExpr
operator|.
name|getExpression
argument_list|()
argument_list|,
name|inputRR
argument_list|,
name|tcCtx
argument_list|)
decl_stmt|;
name|pKeys
operator|.
name|add
argument_list|(
name|converter
operator|.
name|convert
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|pKeys
return|;
block|}
specifier|private
name|List
argument_list|<
name|RexFieldCollation
argument_list|>
name|getOrderKeys
parameter_list|(
name|OrderSpec
name|os
parameter_list|,
name|RexNodeConverter
name|converter
parameter_list|,
name|RowResolver
name|inputRR
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|RexFieldCollation
argument_list|>
name|oKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|RexFieldCollation
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|os
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|OrderExpression
argument_list|>
name|oExprs
init|=
name|os
operator|.
name|getExpressions
argument_list|()
decl_stmt|;
for|for
control|(
name|OrderExpression
name|oExpr
range|:
name|oExprs
control|)
block|{
name|TypeCheckCtx
name|tcCtx
init|=
operator|new
name|TypeCheckCtx
argument_list|(
name|inputRR
argument_list|)
decl_stmt|;
name|tcCtx
operator|.
name|setAllowStatefulFunctions
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|exp
init|=
name|genExprNodeDesc
argument_list|(
name|oExpr
operator|.
name|getExpression
argument_list|()
argument_list|,
name|inputRR
argument_list|,
name|tcCtx
argument_list|)
decl_stmt|;
name|RexNode
name|ordExp
init|=
name|converter
operator|.
name|convert
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|SqlKind
argument_list|>
name|flags
init|=
operator|new
name|HashSet
argument_list|<
name|SqlKind
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|oExpr
operator|.
name|getOrder
argument_list|()
operator|==
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|Order
operator|.
name|DESC
condition|)
name|flags
operator|.
name|add
argument_list|(
name|SqlKind
operator|.
name|DESCENDING
argument_list|)
expr_stmt|;
name|oKeys
operator|.
name|add
argument_list|(
operator|new
name|RexFieldCollation
argument_list|(
name|ordExp
argument_list|,
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|oKeys
return|;
block|}
specifier|private
name|RexWindowBound
name|getBound
parameter_list|(
name|BoundarySpec
name|bs
parameter_list|,
name|RexNodeConverter
name|converter
parameter_list|)
block|{
name|RexWindowBound
name|rwb
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|bs
operator|!=
literal|null
condition|)
block|{
name|SqlParserPos
name|pos
init|=
operator|new
name|SqlParserPos
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|SqlNode
name|amt
init|=
name|bs
operator|.
name|getAmt
argument_list|()
operator|==
literal|0
condition|?
literal|null
else|:
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|bs
operator|.
name|getAmt
argument_list|()
argument_list|)
argument_list|,
operator|new
name|SqlParserPos
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|amtLiteral
init|=
literal|null
decl_stmt|;
name|SqlCall
name|sc
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|amt
operator|!=
literal|null
condition|)
name|amtLiteral
operator|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeLiteral
argument_list|(
operator|new
name|Integer
argument_list|(
name|bs
operator|.
name|getAmt
argument_list|()
argument_list|)
argument_list|,
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bs
operator|.
name|getDirection
argument_list|()
condition|)
block|{
case|case
name|PRECEDING
case|:
if|if
condition|(
name|amt
operator|==
literal|null
condition|)
block|{
name|rwb
operator|=
name|RexWindowBound
operator|.
name|create
argument_list|(
name|SqlWindow
operator|.
name|createUnboundedPreceding
argument_list|(
name|pos
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|=
operator|(
name|SqlCall
operator|)
name|SqlWindow
operator|.
name|createPreceding
argument_list|(
name|amt
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|rwb
operator|=
name|RexWindowBound
operator|.
name|create
argument_list|(
name|sc
argument_list|,
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|sc
operator|.
name|getOperator
argument_list|()
argument_list|,
name|amtLiteral
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CURRENT
case|:
name|rwb
operator|=
name|RexWindowBound
operator|.
name|create
argument_list|(
name|SqlWindow
operator|.
name|createCurrentRow
argument_list|(
operator|new
name|SqlParserPos
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
break|break;
case|case
name|FOLLOWING
case|:
if|if
condition|(
name|amt
operator|==
literal|null
condition|)
block|{
name|rwb
operator|=
name|RexWindowBound
operator|.
name|create
argument_list|(
name|SqlWindow
operator|.
name|createUnboundedFollowing
argument_list|(
operator|new
name|SqlParserPos
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|=
operator|(
name|SqlCall
operator|)
name|SqlWindow
operator|.
name|createFollowing
argument_list|(
name|amt
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|rwb
operator|=
name|RexWindowBound
operator|.
name|create
argument_list|(
name|sc
argument_list|,
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|sc
operator|.
name|getOperator
argument_list|()
argument_list|,
name|amtLiteral
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|rwb
return|;
block|}
specifier|private
name|int
name|getWindowSpecIndx
parameter_list|(
name|ASTNode
name|wndAST
parameter_list|)
block|{
name|int
name|wi
init|=
name|wndAST
operator|.
name|getChildCount
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|wi
operator|<=
literal|0
operator|||
operator|(
name|wndAST
operator|.
name|getChild
argument_list|(
name|wi
argument_list|)
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_WINDOWSPEC
operator|)
condition|)
block|{
name|wi
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|wi
return|;
block|}
specifier|private
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|TypeInfo
argument_list|>
name|genWindowingProj
parameter_list|(
name|QB
name|qb
parameter_list|,
name|WindowExpressionSpec
name|wExpSpec
parameter_list|,
name|RelNode
name|srcRel
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RexNode
name|w
init|=
literal|null
decl_stmt|;
name|TypeInfo
name|wHiveRetType
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|wExpSpec
operator|instanceof
name|WindowFunctionSpec
condition|)
block|{
name|WindowFunctionSpec
name|wFnSpec
init|=
operator|(
name|WindowFunctionSpec
operator|)
name|wExpSpec
decl_stmt|;
name|ASTNode
name|windowProjAst
init|=
name|wFnSpec
operator|.
name|getExpression
argument_list|()
decl_stmt|;
comment|// TODO: do we need to get to child?
name|int
name|wndSpecASTIndx
init|=
name|getWindowSpecIndx
argument_list|(
name|windowProjAst
argument_list|)
decl_stmt|;
comment|// 2. Get Hive Aggregate Info
name|AggInfo
name|hiveAggInfo
init|=
name|getHiveAggInfo
argument_list|(
name|windowProjAst
argument_list|,
name|wndSpecASTIndx
operator|-
literal|1
argument_list|,
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
argument_list|)
decl_stmt|;
comment|// 3. Get Calcite Return type for Agg Fn
name|wHiveRetType
operator|=
name|hiveAggInfo
operator|.
name|m_returnType
expr_stmt|;
name|RelDataType
name|calciteAggFnRetType
init|=
name|TypeConverter
operator|.
name|convert
argument_list|(
name|hiveAggInfo
operator|.
name|m_returnType
argument_list|,
name|this
operator|.
name|cluster
operator|.
name|getTypeFactory
argument_list|()
argument_list|)
decl_stmt|;
comment|// 4. Convert Agg Fn args to Calcite
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|posMap
init|=
name|this
operator|.
name|relToHiveColNameCalcitePosMap
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
name|RexNodeConverter
name|converter
init|=
operator|new
name|RexNodeConverter
argument_list|(
name|this
operator|.
name|cluster
argument_list|,
name|srcRel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|posMap
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|calciteAggFnArgsBldr
init|=
name|ImmutableList
operator|.
expr|<
name|RexNode
operator|>
name|builder
argument_list|()
decl_stmt|;
name|Builder
argument_list|<
name|RelDataType
argument_list|>
name|calciteAggFnArgsTypeBldr
init|=
name|ImmutableList
operator|.
expr|<
name|RelDataType
operator|>
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hiveAggInfo
operator|.
name|m_aggParams
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|calciteAggFnArgsBldr
operator|.
name|add
argument_list|(
name|converter
operator|.
name|convert
argument_list|(
name|hiveAggInfo
operator|.
name|m_aggParams
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|calciteAggFnArgsTypeBldr
operator|.
name|add
argument_list|(
name|TypeConverter
operator|.
name|convert
argument_list|(
name|hiveAggInfo
operator|.
name|m_aggParams
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|this
operator|.
name|cluster
operator|.
name|getTypeFactory
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|calciteAggFnArgs
init|=
name|calciteAggFnArgsBldr
operator|.
name|build
argument_list|()
decl_stmt|;
name|ImmutableList
argument_list|<
name|RelDataType
argument_list|>
name|calciteAggFnArgsType
init|=
name|calciteAggFnArgsTypeBldr
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// 5. Get Calcite Agg Fn
specifier|final
name|SqlAggFunction
name|calciteAggFn
init|=
name|SqlFunctionConverter
operator|.
name|getCalciteAggFn
argument_list|(
name|hiveAggInfo
operator|.
name|m_udfName
argument_list|,
name|calciteAggFnArgsType
argument_list|,
name|calciteAggFnRetType
argument_list|)
decl_stmt|;
comment|// 6. Translate Window spec
name|RowResolver
name|inputRR
init|=
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
name|WindowSpec
name|wndSpec
init|=
operator|(
operator|(
name|WindowFunctionSpec
operator|)
name|wExpSpec
operator|)
operator|.
name|getWindowSpec
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|partitionKeys
init|=
name|getPartitionKeys
argument_list|(
name|wndSpec
operator|.
name|getPartition
argument_list|()
argument_list|,
name|converter
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RexFieldCollation
argument_list|>
name|orderKeys
init|=
name|getOrderKeys
argument_list|(
name|wndSpec
operator|.
name|getOrder
argument_list|()
argument_list|,
name|converter
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|RexWindowBound
name|upperBound
init|=
name|getBound
argument_list|(
name|wndSpec
operator|.
name|getWindowFrame
argument_list|()
operator|.
name|start
argument_list|,
name|converter
argument_list|)
decl_stmt|;
name|RexWindowBound
name|lowerBound
init|=
name|getBound
argument_list|(
name|wndSpec
operator|.
name|getWindowFrame
argument_list|()
operator|.
name|end
argument_list|,
name|converter
argument_list|)
decl_stmt|;
name|boolean
name|isRows
init|=
operator|(
operator|(
name|wndSpec
operator|.
name|getWindowFrame
argument_list|()
operator|.
name|start
operator|instanceof
name|RangeBoundarySpec
operator|)
operator|||
operator|(
name|wndSpec
operator|.
name|getWindowFrame
argument_list|()
operator|.
name|end
operator|instanceof
name|RangeBoundarySpec
operator|)
operator|)
condition|?
literal|true
else|:
literal|false
decl_stmt|;
name|w
operator|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeOver
argument_list|(
name|calciteAggFnRetType
argument_list|,
name|calciteAggFn
argument_list|,
name|calciteAggFnArgs
argument_list|,
name|partitionKeys
argument_list|,
name|ImmutableList
operator|.
expr|<
name|RexFieldCollation
operator|>
name|copyOf
argument_list|(
name|orderKeys
argument_list|)
argument_list|,
name|lowerBound
argument_list|,
name|upperBound
argument_list|,
name|isRows
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// TODO: Convert to Semantic Exception
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unsupported window Spec"
argument_list|)
throw|;
block|}
return|return
operator|new
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|TypeInfo
argument_list|>
argument_list|(
name|w
argument_list|,
name|wHiveRetType
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|genSelectForWindowing
parameter_list|(
name|QB
name|qb
parameter_list|,
name|RelNode
name|srcRel
parameter_list|,
name|HashSet
argument_list|<
name|ColumnInfo
argument_list|>
name|newColumns
parameter_list|)
throws|throws
name|SemanticException
block|{
name|getQBParseInfo
argument_list|(
name|qb
argument_list|)
expr_stmt|;
name|WindowingSpec
name|wSpec
init|=
operator|(
operator|!
name|qb
operator|.
name|getAllWindowingSpecs
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
name|qb
operator|.
name|getAllWindowingSpecs
argument_list|()
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|wSpec
operator|==
literal|null
condition|)
return|return
literal|null
return|;
comment|// 1. Get valid Window Function Spec
name|wSpec
operator|.
name|validateAndMakeEffective
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|WindowExpressionSpec
argument_list|>
name|windowExpressions
init|=
name|wSpec
operator|.
name|getWindowExpressions
argument_list|()
decl_stmt|;
if|if
condition|(
name|windowExpressions
operator|==
literal|null
operator|||
name|windowExpressions
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|null
return|;
name|RowResolver
name|inputRR
init|=
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
comment|// 2. Get RexNodes for original Projections from below
name|List
argument_list|<
name|RexNode
argument_list|>
name|projsForWindowSelOp
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|(
name|HiveCalciteUtil
operator|.
name|getProjsFromBelowAsInputRef
argument_list|(
name|srcRel
argument_list|)
argument_list|)
decl_stmt|;
comment|// 3. Construct new Row Resolver with everything from below.
name|RowResolver
name|out_rwsch
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|RowResolver
operator|.
name|add
argument_list|(
name|out_rwsch
argument_list|,
name|inputRR
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Duplicates detected when adding columns to RR: see previous message"
argument_list|)
expr_stmt|;
block|}
comment|// 4. Walk through Window Expressions& Construct RexNodes for those,
comment|// Update out_rwsch
for|for
control|(
name|WindowExpressionSpec
name|wExprSpec
range|:
name|windowExpressions
control|)
block|{
if|if
condition|(
name|out_rwsch
operator|.
name|getExpression
argument_list|(
name|wExprSpec
operator|.
name|getExpression
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|TypeInfo
argument_list|>
name|wtp
init|=
name|genWindowingProj
argument_list|(
name|qb
argument_list|,
name|wExprSpec
argument_list|,
name|srcRel
argument_list|)
decl_stmt|;
name|projsForWindowSelOp
operator|.
name|add
argument_list|(
name|wtp
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
comment|// 6.2.2 Update Output Row Schema
name|ColumnInfo
name|oColInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|projsForWindowSelOp
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|wtp
operator|.
name|getValue
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|out_rwsch
operator|.
name|putExpression
argument_list|(
name|wExprSpec
operator|.
name|getExpression
argument_list|()
argument_list|,
name|oColInfo
argument_list|)
expr_stmt|;
name|newColumns
operator|.
name|add
argument_list|(
name|oColInfo
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|genSelectRelNode
argument_list|(
name|projsForWindowSelOp
argument_list|,
name|out_rwsch
argument_list|,
name|srcRel
argument_list|,
name|windowExpressions
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|genSelectRelNode
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|calciteColLst
parameter_list|,
name|RowResolver
name|out_rwsch
parameter_list|,
name|RelNode
name|srcRel
parameter_list|)
throws|throws
name|CalciteSemanticException
block|{
return|return
name|genSelectRelNode
argument_list|(
name|calciteColLst
argument_list|,
name|out_rwsch
argument_list|,
name|srcRel
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|genSelectRelNode
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|calciteColLst
parameter_list|,
name|RowResolver
name|out_rwsch
parameter_list|,
name|RelNode
name|srcRel
parameter_list|,
name|List
argument_list|<
name|WindowExpressionSpec
argument_list|>
name|windowExpressions
parameter_list|)
throws|throws
name|CalciteSemanticException
block|{
comment|// 1. Build Column Names
name|Set
argument_list|<
name|String
argument_list|>
name|colNamesSet
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ColumnInfo
argument_list|>
name|cInfoLst
init|=
name|out_rwsch
operator|.
name|getRowSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|columnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|windowToAlias
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|windowExpressions
operator|!=
literal|null
condition|)
block|{
name|windowToAlias
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|WindowExpressionSpec
name|wes
range|:
name|windowExpressions
control|)
block|{
name|windowToAlias
operator|.
name|put
argument_list|(
name|wes
operator|.
name|getExpression
argument_list|()
operator|.
name|toStringTree
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|wes
operator|.
name|getAlias
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|String
index|[]
name|qualifiedColNames
decl_stmt|;
name|String
name|tmpColAlias
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|calciteColLst
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ColumnInfo
name|cInfo
init|=
name|cInfoLst
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|qualifiedColNames
operator|=
name|out_rwsch
operator|.
name|reverseLookup
argument_list|(
name|cInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
comment|/*          * if (qualifiedColNames[0] != null&& !qualifiedColNames[0].isEmpty())          * tmpColAlias = qualifiedColNames[0] + "." + qualifiedColNames[1]; else          */
name|tmpColAlias
operator|=
name|qualifiedColNames
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|tmpColAlias
operator|.
name|contains
argument_list|(
literal|"."
argument_list|)
operator|||
name|tmpColAlias
operator|.
name|contains
argument_list|(
literal|":"
argument_list|)
condition|)
block|{
name|tmpColAlias
operator|=
name|cInfo
operator|.
name|getInternalName
argument_list|()
expr_stmt|;
block|}
comment|// Prepend column names with '_o_' if it starts with '_c'
comment|/*          * Hive treats names that start with '_c' as internalNames; so change          * the names so we don't run into this issue when converting back to          * Hive AST.          */
if|if
condition|(
name|tmpColAlias
operator|.
name|startsWith
argument_list|(
literal|"_c"
argument_list|)
condition|)
block|{
name|tmpColAlias
operator|=
literal|"_o_"
operator|+
name|tmpColAlias
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|windowToAlias
operator|!=
literal|null
operator|&&
name|windowToAlias
operator|.
name|containsKey
argument_list|(
name|tmpColAlias
argument_list|)
condition|)
block|{
name|tmpColAlias
operator|=
name|windowToAlias
operator|.
name|get
argument_list|(
name|tmpColAlias
argument_list|)
expr_stmt|;
block|}
name|int
name|suffix
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|colNamesSet
operator|.
name|contains
argument_list|(
name|tmpColAlias
argument_list|)
condition|)
block|{
name|tmpColAlias
operator|=
name|qualifiedColNames
index|[
literal|1
index|]
operator|+
name|suffix
expr_stmt|;
name|suffix
operator|++
expr_stmt|;
block|}
name|colNamesSet
operator|.
name|add
argument_list|(
name|tmpColAlias
argument_list|)
expr_stmt|;
name|columnNames
operator|.
name|add
argument_list|(
name|tmpColAlias
argument_list|)
expr_stmt|;
block|}
comment|// 3 Build Calcite Rel Node for project using converted projections& col
comment|// names
name|HiveRelNode
name|selRel
init|=
name|HiveProject
operator|.
name|create
argument_list|(
name|srcRel
argument_list|,
name|calciteColLst
argument_list|,
name|columnNames
argument_list|)
decl_stmt|;
comment|// 4. Keep track of colname-to-posmap&& RR for new select
name|this
operator|.
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|selRel
argument_list|,
name|buildHiveToCalciteColumnMap
argument_list|(
name|out_rwsch
argument_list|,
name|selRel
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|relToHiveRR
operator|.
name|put
argument_list|(
name|selRel
argument_list|,
name|out_rwsch
argument_list|)
expr_stmt|;
return|return
name|selRel
return|;
block|}
comment|/**      * NOTE: there can only be one select caluse since we don't handle multi      * destination insert.      *      * @throws SemanticException      */
specifier|private
name|RelNode
name|genSelectLogicalPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|RelNode
name|srcRel
parameter_list|,
name|RelNode
name|starSrcRel
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// 0. Generate a Select Node for Windowing
comment|// Exclude the newly-generated select columns from */etc. resolution.
name|HashSet
argument_list|<
name|ColumnInfo
argument_list|>
name|excludedColumns
init|=
operator|new
name|HashSet
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
name|RelNode
name|selForWindow
init|=
name|genSelectForWindowing
argument_list|(
name|qb
argument_list|,
name|srcRel
argument_list|,
name|excludedColumns
argument_list|)
decl_stmt|;
name|srcRel
operator|=
operator|(
name|selForWindow
operator|==
literal|null
operator|)
condition|?
name|srcRel
else|:
name|selForWindow
expr_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|col_list
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// 1. Get Select Expression List
name|QBParseInfo
name|qbp
init|=
name|getQBParseInfo
argument_list|(
name|qb
argument_list|)
decl_stmt|;
name|String
name|selClauseName
init|=
name|qbp
operator|.
name|getClauseNames
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|ASTNode
name|selExprList
init|=
name|qbp
operator|.
name|getSelForClause
argument_list|(
name|selClauseName
argument_list|)
decl_stmt|;
comment|// 2.Row resolvers for input, output
name|RowResolver
name|out_rwsch
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|Integer
name|pos
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// TODO: will this also fix windowing? try
name|RowResolver
name|inputRR
init|=
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|,
name|starRR
init|=
name|inputRR
decl_stmt|;
if|if
condition|(
name|starSrcRel
operator|!=
literal|null
condition|)
block|{
name|starRR
operator|=
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|starSrcRel
argument_list|)
expr_stmt|;
block|}
comment|// 3. Query Hints
comment|// TODO: Handle Query Hints; currently we ignore them
name|boolean
name|selectStar
init|=
literal|false
decl_stmt|;
name|int
name|posn
init|=
literal|0
decl_stmt|;
name|boolean
name|hintPresent
init|=
operator|(
name|selExprList
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_HINTLIST
operator|)
decl_stmt|;
if|if
condition|(
name|hintPresent
condition|)
block|{
name|String
name|hint
init|=
name|ctx
operator|.
name|getTokenRewriteStream
argument_list|()
operator|.
name|toString
argument_list|(
name|selExprList
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getTokenStartIndex
argument_list|()
argument_list|,
name|selExprList
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getTokenStopIndex
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|msg
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Hint specified for %s."
operator|+
literal|" Currently we don't support hints in CBO, turn off cbo to use hints."
argument_list|,
name|hint
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
name|msg
argument_list|,
name|UnsupportedFeature
operator|.
name|Hint
argument_list|)
throw|;
block|}
comment|// 4. Bailout if select involves Transform
name|boolean
name|isInTransform
init|=
operator|(
name|selExprList
operator|.
name|getChild
argument_list|(
name|posn
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TRANSFORM
operator|)
decl_stmt|;
if|if
condition|(
name|isInTransform
condition|)
block|{
name|String
name|msg
init|=
name|String
operator|.
name|format
argument_list|(
literal|"SELECT TRANSFORM is currently not supported in CBO,"
operator|+
literal|" turn off cbo to use TRANSFORM."
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
name|msg
argument_list|,
name|UnsupportedFeature
operator|.
name|Select_transform
argument_list|)
throw|;
block|}
comment|// 5. Bailout if select involves UDTF
name|ASTNode
name|expr
init|=
operator|(
name|ASTNode
operator|)
name|selExprList
operator|.
name|getChild
argument_list|(
name|posn
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|exprType
init|=
name|expr
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|exprType
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTION
operator|||
name|exprType
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONSTAR
condition|)
block|{
name|String
name|funcName
init|=
name|TypeCheckProcFactory
operator|.
name|DefaultExprProcessor
operator|.
name|getFunctionText
argument_list|(
name|expr
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|FunctionInfo
name|fi
init|=
name|FunctionRegistry
operator|.
name|getFunctionInfo
argument_list|(
name|funcName
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|!=
literal|null
operator|&&
name|fi
operator|.
name|getGenericUDTF
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|String
name|msg
init|=
name|String
operator|.
name|format
argument_list|(
literal|"UDTF "
operator|+
name|funcName
operator|+
literal|" is currently not supported in CBO,"
operator|+
literal|" turn off cbo to use UDTF "
operator|+
name|funcName
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
name|msg
argument_list|,
name|UnsupportedFeature
operator|.
name|UDTF
argument_list|)
throw|;
block|}
block|}
comment|// 6. Iterate over all expression (after SELECT)
name|ASTNode
name|exprList
init|=
name|selExprList
decl_stmt|;
name|int
name|startPosn
init|=
name|posn
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|tabAliasesForAllProjs
init|=
name|getTabAliases
argument_list|(
name|starRR
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|startPosn
init|;
name|i
operator|<
name|exprList
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|// 6.1 child can be EXPR AS ALIAS, or EXPR.
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|exprList
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|boolean
name|hasAsClause
init|=
operator|(
operator|!
name|isInTransform
operator|)
operator|&&
operator|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
operator|)
decl_stmt|;
comment|// 6.2 EXPR AS (ALIAS,...) parses, but is only allowed for UDTF's
comment|// This check is not needed and invalid when there is a transform b/c
comment|// the
comment|// AST's are slightly different.
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|>
literal|2
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|SemanticAnalyzer
operator|.
name|generateErrorMessage
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
argument_list|,
name|ErrorMsg
operator|.
name|INVALID_AS
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|tabAlias
decl_stmt|;
name|String
name|colAlias
decl_stmt|;
comment|// 6.3 Get rid of TOK_SELEXPR
name|expr
operator|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|String
index|[]
name|colRef
init|=
name|SemanticAnalyzer
operator|.
name|getColAlias
argument_list|(
name|child
argument_list|,
name|getAutogenColAliasPrfxLbl
argument_list|()
argument_list|,
name|inputRR
argument_list|,
name|autogenColAliasPrfxIncludeFuncName
argument_list|()
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tabAlias
operator|=
name|colRef
index|[
literal|0
index|]
expr_stmt|;
name|colAlias
operator|=
name|colRef
index|[
literal|1
index|]
expr_stmt|;
comment|// 6.4 Build ExprNode corresponding to colums
if|if
condition|(
name|expr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALLCOLREF
condition|)
block|{
name|pos
operator|=
name|genColListRegex
argument_list|(
literal|".*"
argument_list|,
name|expr
operator|.
name|getChildCount
argument_list|()
operator|==
literal|0
condition|?
literal|null
else|:
name|SemanticAnalyzer
operator|.
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|expr
argument_list|,
name|col_list
argument_list|,
name|excludedColumns
argument_list|,
name|inputRR
argument_list|,
name|starRR
argument_list|,
name|pos
argument_list|,
name|out_rwsch
argument_list|,
name|tabAliasesForAllProjs
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|selectStar
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
operator|&&
operator|!
name|hasAsClause
operator|&&
operator|!
name|inputRR
operator|.
name|getIsExprResolver
argument_list|()
operator|&&
name|SemanticAnalyzer
operator|.
name|isRegex
argument_list|(
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
name|conf
argument_list|)
condition|)
block|{
comment|// In case the expression is a regex COL.
comment|// This can only happen without AS clause
comment|// We don't allow this for ExprResolver - the Group By case
name|pos
operator|=
name|genColListRegex
argument_list|(
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|,
name|expr
argument_list|,
name|col_list
argument_list|,
name|excludedColumns
argument_list|,
name|inputRR
argument_list|,
name|starRR
argument_list|,
name|pos
argument_list|,
name|out_rwsch
argument_list|,
name|tabAliasesForAllProjs
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|DOT
operator|&&
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
operator|&&
name|inputRR
operator|.
name|hasTableAlias
argument_list|(
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|)
operator|&&
operator|!
name|hasAsClause
operator|&&
operator|!
name|inputRR
operator|.
name|getIsExprResolver
argument_list|()
operator|&&
name|SemanticAnalyzer
operator|.
name|isRegex
argument_list|(
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
name|conf
argument_list|)
condition|)
block|{
comment|// In case the expression is TABLE.COL (col can be regex).
comment|// This can only happen without AS clause
comment|// We don't allow this for ExprResolver - the Group By case
name|pos
operator|=
name|genColListRegex
argument_list|(
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
name|SemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|expr
argument_list|,
name|col_list
argument_list|,
name|excludedColumns
argument_list|,
name|inputRR
argument_list|,
name|starRR
argument_list|,
name|pos
argument_list|,
name|out_rwsch
argument_list|,
name|tabAliasesForAllProjs
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|.
name|toStringTree
argument_list|()
operator|.
name|contains
argument_list|(
literal|"TOK_FUNCTIONDI"
argument_list|)
operator|&&
operator|!
operator|(
name|srcRel
operator|instanceof
name|HiveAggregate
operator|)
condition|)
block|{
comment|// Likely a malformed query eg, select hash(distinct c1) from t1;
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
literal|"Distinct without an aggreggation."
argument_list|,
name|UnsupportedFeature
operator|.
name|Distinct_without_an_aggreggation
argument_list|)
throw|;
block|}
else|else
block|{
comment|// Case when this is an expression
name|TypeCheckCtx
name|tcCtx
init|=
operator|new
name|TypeCheckCtx
argument_list|(
name|inputRR
argument_list|)
decl_stmt|;
comment|// We allow stateful functions in the SELECT list (but nowhere else)
name|tcCtx
operator|.
name|setAllowStatefulFunctions
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|exp
init|=
name|genExprNodeDesc
argument_list|(
name|expr
argument_list|,
name|inputRR
argument_list|,
name|tcCtx
argument_list|)
decl_stmt|;
name|String
name|recommended
init|=
name|recommendName
argument_list|(
name|exp
argument_list|,
name|colAlias
argument_list|)
decl_stmt|;
if|if
condition|(
name|recommended
operator|!=
literal|null
operator|&&
name|out_rwsch
operator|.
name|get
argument_list|(
literal|null
argument_list|,
name|recommended
argument_list|)
operator|==
literal|null
condition|)
block|{
name|colAlias
operator|=
name|recommended
expr_stmt|;
block|}
name|col_list
operator|.
name|add
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|pos
argument_list|)
argument_list|,
name|exp
operator|.
name|getWritableObjectInspector
argument_list|()
argument_list|,
name|tabAlias
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|colInfo
operator|.
name|setSkewedCol
argument_list|(
operator|(
name|exp
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|?
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|exp
operator|)
operator|.
name|isSkewedCol
argument_list|()
else|:
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out_rwsch
operator|.
name|putWithCheck
argument_list|(
name|tabAlias
argument_list|,
name|colAlias
argument_list|,
literal|null
argument_list|,
name|colInfo
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
literal|"Cannot add column to RR: "
operator|+
name|tabAlias
operator|+
literal|"."
operator|+
name|colAlias
operator|+
literal|" => "
operator|+
name|colInfo
operator|+
literal|" due to duplication, see previous warnings"
argument_list|,
name|UnsupportedFeature
operator|.
name|Duplicates_in_RR
argument_list|)
throw|;
block|}
if|if
condition|(
name|exp
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colExp
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|exp
decl_stmt|;
name|String
index|[]
name|altMapping
init|=
name|inputRR
operator|.
name|getAlternateMappings
argument_list|(
name|colExp
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|altMapping
operator|!=
literal|null
condition|)
block|{
name|out_rwsch
operator|.
name|put
argument_list|(
name|altMapping
index|[
literal|0
index|]
argument_list|,
name|altMapping
index|[
literal|1
index|]
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
block|}
block|}
name|pos
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|pos
operator|.
name|intValue
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|selectStar
operator|=
name|selectStar
operator|&&
name|exprList
operator|.
name|getChildCount
argument_list|()
operator|==
name|posn
operator|+
literal|1
expr_stmt|;
comment|// 7. Convert Hive projections to Calcite
name|List
argument_list|<
name|RexNode
argument_list|>
name|calciteColLst
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|RexNodeConverter
name|rexNodeConv
init|=
operator|new
name|RexNodeConverter
argument_list|(
name|cluster
argument_list|,
name|srcRel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|buildHiveColNameToInputPosMap
argument_list|(
name|col_list
argument_list|,
name|inputRR
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|colExpr
range|:
name|col_list
control|)
block|{
name|calciteColLst
operator|.
name|add
argument_list|(
name|rexNodeConv
operator|.
name|convert
argument_list|(
name|colExpr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 8. Build Calcite Rel
name|RelNode
name|selRel
init|=
name|genSelectRelNode
argument_list|(
name|calciteColLst
argument_list|,
name|out_rwsch
argument_list|,
name|srcRel
argument_list|)
decl_stmt|;
return|return
name|selRel
return|;
block|}
specifier|private
name|RelNode
name|genLogicalPlan
parameter_list|(
name|QBExpr
name|qbexpr
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|qbexpr
operator|.
name|getOpcode
argument_list|()
operator|==
name|QBExpr
operator|.
name|Opcode
operator|.
name|NULLOP
condition|)
block|{
return|return
name|genLogicalPlan
argument_list|(
name|qbexpr
operator|.
name|getQB
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|qbexpr
operator|.
name|getOpcode
argument_list|()
operator|==
name|QBExpr
operator|.
name|Opcode
operator|.
name|UNION
condition|)
block|{
name|RelNode
name|qbexpr1Ops
init|=
name|genLogicalPlan
argument_list|(
name|qbexpr
operator|.
name|getQBExpr1
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|qbexpr2Ops
init|=
name|genLogicalPlan
argument_list|(
name|qbexpr
operator|.
name|getQBExpr2
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|genUnionLogicalPlan
argument_list|(
name|qbexpr
operator|.
name|getAlias
argument_list|()
argument_list|,
name|qbexpr
operator|.
name|getQBExpr1
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|qbexpr1Ops
argument_list|,
name|qbexpr
operator|.
name|getQBExpr2
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|qbexpr2Ops
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|RelNode
name|genLogicalPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|boolean
name|outerMostQB
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RelNode
name|srcRel
init|=
literal|null
decl_stmt|;
name|RelNode
name|filterRel
init|=
literal|null
decl_stmt|;
name|RelNode
name|gbRel
init|=
literal|null
decl_stmt|;
name|RelNode
name|gbHavingRel
init|=
literal|null
decl_stmt|;
name|RelNode
name|selectRel
init|=
literal|null
decl_stmt|;
name|RelNode
name|obRel
init|=
literal|null
decl_stmt|;
name|RelNode
name|limitRel
init|=
literal|null
decl_stmt|;
comment|// First generate all the opInfos for the elements in the from clause
name|Map
argument_list|<
name|String
argument_list|,
name|RelNode
argument_list|>
name|aliasToRel
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
comment|// 0. Check if we can handle the SubQuery;
comment|// canHandleQbForCbo returns null if the query can be handled.
name|String
name|reason
init|=
name|canHandleQbForCbo
argument_list|(
name|queryProperties
argument_list|,
name|conf
argument_list|,
literal|false
argument_list|,
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
argument_list|,
name|qb
argument_list|)
decl_stmt|;
if|if
condition|(
name|reason
operator|!=
literal|null
condition|)
block|{
name|String
name|msg
init|=
literal|"CBO can not handle Sub Query"
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|msg
operator|+
literal|" because it: "
operator|+
name|reason
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
name|msg
argument_list|,
name|UnsupportedFeature
operator|.
name|Subquery
argument_list|)
throw|;
block|}
comment|// 1. Build Rel For Src (SubQuery, TS, Join)
comment|// 1.1. Recurse over the subqueries to fill the subquery part of the plan
for|for
control|(
name|String
name|subqAlias
range|:
name|qb
operator|.
name|getSubqAliases
argument_list|()
control|)
block|{
name|QBExpr
name|qbexpr
init|=
name|qb
operator|.
name|getSubqForAlias
argument_list|(
name|subqAlias
argument_list|)
decl_stmt|;
name|aliasToRel
operator|.
name|put
argument_list|(
name|subqAlias
argument_list|,
name|genLogicalPlan
argument_list|(
name|qbexpr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 1.2 Recurse over all the source tables
for|for
control|(
name|String
name|tableAlias
range|:
name|qb
operator|.
name|getTabAliases
argument_list|()
control|)
block|{
name|RelNode
name|op
init|=
name|genTableLogicalPlan
argument_list|(
name|tableAlias
argument_list|,
name|qb
argument_list|)
decl_stmt|;
name|aliasToRel
operator|.
name|put
argument_list|(
name|tableAlias
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aliasToRel
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// // This may happen for queries like select 1; (no source table)
comment|// We can do following which is same, as what Hive does.
comment|// With this, we will be able to generate Calcite plan.
comment|// qb.getMetaData().setSrcForAlias(DUMMY_TABLE, getDummyTable());
comment|// RelNode op = genTableLogicalPlan(DUMMY_TABLE, qb);
comment|// qb.addAlias(DUMMY_TABLE);
comment|// qb.setTabAlias(DUMMY_TABLE, DUMMY_TABLE);
comment|// aliasToRel.put(DUMMY_TABLE, op);
comment|// However, Hive trips later while trying to get Metadata for this dummy
comment|// table
comment|// So, for now lets just disable this. Anyway there is nothing much to
comment|// optimize in such cases.
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
literal|"Unsupported"
argument_list|,
name|UnsupportedFeature
operator|.
name|Others
argument_list|)
throw|;
block|}
comment|// 1.3 process join
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getJoinExpr
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|srcRel
operator|=
name|genJoinLogicalPlan
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getJoinExpr
argument_list|()
argument_list|,
name|aliasToRel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If no join then there should only be either 1 TS or 1 SubQuery
name|srcRel
operator|=
name|aliasToRel
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
comment|// 2. Build Rel for where Clause
name|filterRel
operator|=
name|genFilterLogicalPlan
argument_list|(
name|qb
argument_list|,
name|srcRel
argument_list|,
name|aliasToRel
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|srcRel
operator|=
operator|(
name|filterRel
operator|==
literal|null
operator|)
condition|?
name|srcRel
else|:
name|filterRel
expr_stmt|;
name|RelNode
name|starSrcRel
init|=
name|srcRel
decl_stmt|;
comment|// 3. Build Rel for GB Clause
name|gbRel
operator|=
name|genGBLogicalPlan
argument_list|(
name|qb
argument_list|,
name|srcRel
argument_list|)
expr_stmt|;
name|srcRel
operator|=
operator|(
name|gbRel
operator|==
literal|null
operator|)
condition|?
name|srcRel
else|:
name|gbRel
expr_stmt|;
comment|// 4. Build Rel for GB Having Clause
name|gbHavingRel
operator|=
name|genGBHavingLogicalPlan
argument_list|(
name|qb
argument_list|,
name|srcRel
argument_list|,
name|aliasToRel
argument_list|)
expr_stmt|;
name|srcRel
operator|=
operator|(
name|gbHavingRel
operator|==
literal|null
operator|)
condition|?
name|srcRel
else|:
name|gbHavingRel
expr_stmt|;
comment|// 5. Build Rel for Select Clause
name|selectRel
operator|=
name|genSelectLogicalPlan
argument_list|(
name|qb
argument_list|,
name|srcRel
argument_list|,
name|starSrcRel
argument_list|)
expr_stmt|;
name|srcRel
operator|=
operator|(
name|selectRel
operator|==
literal|null
operator|)
condition|?
name|srcRel
else|:
name|selectRel
expr_stmt|;
comment|// 6. Build Rel for OB Clause
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|>
name|obTopProjPair
init|=
name|genOBLogicalPlan
argument_list|(
name|qb
argument_list|,
name|srcRel
argument_list|,
name|outerMostQB
argument_list|)
decl_stmt|;
name|obRel
operator|=
name|obTopProjPair
operator|.
name|getKey
argument_list|()
expr_stmt|;
name|RelNode
name|topConstrainingProjArgsRel
init|=
name|obTopProjPair
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|srcRel
operator|=
operator|(
name|obRel
operator|==
literal|null
operator|)
condition|?
name|srcRel
else|:
name|obRel
expr_stmt|;
comment|// 7. Build Rel for Limit Clause
name|limitRel
operator|=
name|genLimitLogicalPlan
argument_list|(
name|qb
argument_list|,
name|srcRel
argument_list|)
expr_stmt|;
name|srcRel
operator|=
operator|(
name|limitRel
operator|==
literal|null
operator|)
condition|?
name|srcRel
else|:
name|limitRel
expr_stmt|;
comment|// 8. Introduce top constraining select if needed.
comment|// NOTES:
comment|// 1. Calcite can not take an expr in OB; hence it needs to be added as VC
comment|// in the input select; In such cases we need to introduce a select on top
comment|// to ensure VC is not visible beyond Limit, OB.
comment|// 2. Hive can not preserve order across select. In subqueries OB is used
comment|// to get a deterministic set of tuples from following limit. Hence we
comment|// introduce the constraining select above Limit (if present) instead of
comment|// OB.
comment|// 3. The top level OB will not introduce constraining select due to Hive
comment|// limitation(#2) stated above. The RR for OB will not include VC. Thus
comment|// Result Schema will not include exprs used by top OB. During AST Conv,
comment|// in the PlanModifierForASTConv we would modify the top level OB to
comment|// migrate exprs from input sel to SortRel (Note that Calcite doesn't
comment|// support this; but since we are done with Calcite at this point its OK).
if|if
condition|(
name|topConstrainingProjArgsRel
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|originalInputRefs
init|=
name|Lists
operator|.
name|transform
argument_list|(
name|topConstrainingProjArgsRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|,
operator|new
name|Function
argument_list|<
name|RelDataTypeField
argument_list|,
name|RexNode
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|apply
parameter_list|(
name|RelDataTypeField
name|input
parameter_list|)
block|{
return|return
operator|new
name|RexInputRef
argument_list|(
name|input
operator|.
name|getIndex
argument_list|()
argument_list|,
name|input
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|RowResolver
name|topConstrainingProjRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|RowResolver
operator|.
name|add
argument_list|(
name|topConstrainingProjRR
argument_list|,
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|topConstrainingProjArgsRel
argument_list|)
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Duplicates detected when adding columns to RR: see previous message"
argument_list|)
expr_stmt|;
block|}
name|srcRel
operator|=
name|genSelectRelNode
argument_list|(
name|originalInputRefs
argument_list|,
name|topConstrainingProjRR
argument_list|,
name|srcRel
argument_list|)
expr_stmt|;
block|}
comment|// 9. Incase this QB corresponds to subquery then modify its RR to point
comment|// to subquery alias
comment|// TODO: cleanup this
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|RowResolver
name|rr
init|=
name|this
operator|.
name|relToHiveRR
operator|.
name|get
argument_list|(
name|srcRel
argument_list|)
decl_stmt|;
name|RowResolver
name|newRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|String
name|alias
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|rr
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|colInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|String
index|[]
name|tmp
init|=
name|rr
operator|.
name|reverseLookup
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
literal|""
operator|.
name|equals
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|)
operator|||
name|tmp
index|[
literal|1
index|]
operator|==
literal|null
condition|)
block|{
comment|// ast expression is not a valid column name for table
name|tmp
index|[
literal|1
index|]
operator|=
name|colInfo
operator|.
name|getInternalName
argument_list|()
expr_stmt|;
block|}
name|ColumnInfo
name|newCi
init|=
operator|new
name|ColumnInfo
argument_list|(
name|colInfo
argument_list|)
decl_stmt|;
name|newCi
operator|.
name|setTabAlias
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|newRR
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|,
name|newCi
argument_list|)
expr_stmt|;
block|}
name|relToHiveRR
operator|.
name|put
argument_list|(
name|srcRel
argument_list|,
name|newRR
argument_list|)
expr_stmt|;
name|relToHiveColNameCalcitePosMap
operator|.
name|put
argument_list|(
name|srcRel
argument_list|,
name|buildHiveToCalciteColumnMap
argument_list|(
name|newRR
argument_list|,
name|srcRel
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Plan for Query Block "
operator|+
name|qb
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|setQB
argument_list|(
name|qb
argument_list|)
expr_stmt|;
return|return
name|srcRel
return|;
block|}
specifier|private
name|RelNode
name|genGBHavingLogicalPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|RelNode
name|srcRel
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RelNode
argument_list|>
name|aliasToRel
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RelNode
name|gbFilter
init|=
literal|null
decl_stmt|;
name|QBParseInfo
name|qbp
init|=
name|getQBParseInfo
argument_list|(
name|qb
argument_list|)
decl_stmt|;
name|ASTNode
name|havingClause
init|=
name|qbp
operator|.
name|getHavingForClause
argument_list|(
name|qbp
operator|.
name|getClauseNames
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|havingClause
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|srcRel
operator|instanceof
name|HiveAggregate
operator|)
condition|)
block|{
comment|// ill-formed query like select * from t1 having c1> 0;
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
literal|"Having clause without any group-by."
argument_list|,
name|UnsupportedFeature
operator|.
name|Having_clause_without_any_groupby
argument_list|)
throw|;
block|}
name|validateNoHavingReferenceToAlias
argument_list|(
name|qb
argument_list|,
operator|(
name|ASTNode
operator|)
name|havingClause
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|gbFilter
operator|=
name|genFilterRelNode
argument_list|(
name|qb
argument_list|,
operator|(
name|ASTNode
operator|)
name|havingClause
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|srcRel
argument_list|,
name|aliasToRel
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|gbFilter
return|;
block|}
comment|/*      * Bail if having clause uses Select Expression aliases for Aggregation      * expressions. We could do what Hive does. But this is non standard      * behavior. Making sure this doesn't cause issues when translating through      * Calcite is not worth it.      */
specifier|private
name|void
name|validateNoHavingReferenceToAlias
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|havingExpr
parameter_list|)
throws|throws
name|CalciteSemanticException
block|{
name|QBParseInfo
name|qbPI
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|String
argument_list|>
name|exprToAlias
init|=
name|qbPI
operator|.
name|getAllExprToColumnAlias
argument_list|()
decl_stmt|;
comment|/*        * a mouthful, but safe: - a QB is guaranteed to have atleast 1        * destination - we don't support multi insert, so picking the first dest.        */
name|Set
argument_list|<
name|String
argument_list|>
name|aggExprs
init|=
name|qbPI
operator|.
name|getDestToAggregationExprs
argument_list|()
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|keySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ASTNode
argument_list|,
name|String
argument_list|>
name|selExpr
range|:
name|exprToAlias
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|selAST
init|=
name|selExpr
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|aggExprs
operator|.
name|contains
argument_list|(
name|selAST
operator|.
name|toStringTree
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
specifier|final
name|String
name|aliasToCheck
init|=
name|selExpr
operator|.
name|getValue
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Object
argument_list|>
name|aliasReferences
init|=
operator|new
name|HashSet
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|TreeVisitorAction
name|action
init|=
operator|new
name|TreeVisitorAction
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|pre
parameter_list|(
name|Object
name|t
parameter_list|)
block|{
if|if
condition|(
name|ParseDriver
operator|.
name|adaptor
operator|.
name|getType
argument_list|(
name|t
argument_list|)
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
condition|)
block|{
name|Object
name|c
init|=
name|ParseDriver
operator|.
name|adaptor
operator|.
name|getChild
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
operator|&&
name|ParseDriver
operator|.
name|adaptor
operator|.
name|getType
argument_list|(
name|c
argument_list|)
operator|==
name|HiveParser
operator|.
name|Identifier
operator|&&
name|ParseDriver
operator|.
name|adaptor
operator|.
name|getText
argument_list|(
name|c
argument_list|)
operator|.
name|equals
argument_list|(
name|aliasToCheck
argument_list|)
condition|)
block|{
name|aliasReferences
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|t
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|post
parameter_list|(
name|Object
name|t
parameter_list|)
block|{
return|return
name|t
return|;
block|}
block|}
decl_stmt|;
operator|new
name|TreeVisitor
argument_list|(
name|ParseDriver
operator|.
name|adaptor
argument_list|)
operator|.
name|visit
argument_list|(
name|havingExpr
argument_list|,
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliasReferences
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|String
name|havingClause
init|=
name|ctx
operator|.
name|getTokenRewriteStream
argument_list|()
operator|.
name|toString
argument_list|(
name|havingExpr
operator|.
name|getTokenStartIndex
argument_list|()
argument_list|,
name|havingExpr
operator|.
name|getTokenStopIndex
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|msg
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Encountered Select alias '%s' in having clause '%s'"
operator|+
literal|" This non standard behavior is not supported with cbo on."
operator|+
literal|" Turn off cbo for these queries."
argument_list|,
name|aliasToCheck
argument_list|,
name|havingClause
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
name|msg
argument_list|,
name|UnsupportedFeature
operator|.
name|Select_alias_in_having_clause
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|buildHiveToCalciteColumnMap
parameter_list|(
name|RowResolver
name|rr
parameter_list|,
name|RelNode
name|rNode
parameter_list|)
block|{
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|b
init|=
operator|new
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|ci
range|:
name|rr
operator|.
name|getRowSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
control|)
block|{
name|b
operator|.
name|put
argument_list|(
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|rr
operator|.
name|getPosition
argument_list|(
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|b
operator|.
name|build
argument_list|()
return|;
block|}
specifier|private
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|buildHiveColNameToInputPosMap
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|col_list
parameter_list|,
name|RowResolver
name|inputRR
parameter_list|)
block|{
comment|// Build a map of Hive column Names (ExprNodeColumnDesc Name)
comment|// to the positions of those projections in the input
name|Map
argument_list|<
name|Integer
argument_list|,
name|ExprNodeDesc
argument_list|>
name|hashCodeTocolumnDescMap
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ExprNodeDescUtils
operator|.
name|getExprNodeColumnDesc
argument_list|(
name|col_list
argument_list|,
name|hashCodeTocolumnDescMap
argument_list|)
expr_stmt|;
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|hiveColNameToInputPosMapBuilder
init|=
operator|new
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|exprNodecolName
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|exprDesc
range|:
name|hashCodeTocolumnDescMap
operator|.
name|values
argument_list|()
control|)
block|{
name|exprNodecolName
operator|=
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|exprDesc
operator|)
operator|.
name|getColumn
argument_list|()
expr_stmt|;
name|hiveColNameToInputPosMapBuilder
operator|.
name|put
argument_list|(
name|exprNodecolName
argument_list|,
name|inputRR
operator|.
name|getPosition
argument_list|(
name|exprNodecolName
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|hiveColNameToInputPosMapBuilder
operator|.
name|build
argument_list|()
return|;
block|}
specifier|private
name|QBParseInfo
name|getQBParseInfo
parameter_list|(
name|QB
name|qb
parameter_list|)
throws|throws
name|CalciteSemanticException
block|{
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|qbp
operator|.
name|getClauseNames
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|String
name|msg
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Multi Insert is currently not supported in CBO,"
operator|+
literal|" turn off cbo to use Multi Insert."
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
name|msg
argument_list|,
name|UnsupportedFeature
operator|.
name|Multi_insert
argument_list|)
throw|;
block|}
return|return
name|qbp
return|;
block|}
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getTabAliases
parameter_list|(
name|RowResolver
name|inputRR
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|tabAliases
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// TODO: this should be
comment|// unique
for|for
control|(
name|ColumnInfo
name|ci
range|:
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|tabAliases
operator|.
name|add
argument_list|(
name|ci
operator|.
name|getTabAlias
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|tabAliases
return|;
block|}
block|}
block|}
end_class

end_unit

