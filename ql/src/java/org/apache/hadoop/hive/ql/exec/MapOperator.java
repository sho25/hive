begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|hive_metastoreConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|mr
operator|.
name|ExecMapperContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|tez
operator|.
name|MapRecordProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|RecordIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|IOContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|VirtualColumn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MapWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PartitionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableScanDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|api
operator|.
name|OperatorType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|Deserializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorConverters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorConverters
operator|.
name|Converter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|PrimitiveObjectInspectorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_comment
comment|/**  * Map operator. This triggers overall map side processing. This is a little  * different from regular operators in that it starts off by processing a  * Writable data structure from a Table (instead of a Hive Object).  **/
end_comment

begin_class
specifier|public
class|class
name|MapOperator
extends|extends
name|Operator
argument_list|<
name|MapWork
argument_list|>
implements|implements
name|Serializable
implements|,
name|Cloneable
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
comment|/**    * Counter.    *    */
specifier|public
specifier|static
enum|enum
name|Counter
block|{
name|DESERIALIZE_ERRORS
block|}
specifier|private
specifier|final
specifier|transient
name|LongWritable
name|deserialize_error_count
init|=
operator|new
name|LongWritable
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|MapInputPath
argument_list|,
name|MapOpCtx
argument_list|>
name|opCtxMap
init|=
operator|new
name|HashMap
argument_list|<
name|MapInputPath
argument_list|,
name|MapOpCtx
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|MapOpCtx
argument_list|>
name|childrenOpToOpCtxMap
init|=
operator|new
name|HashMap
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|MapOpCtx
argument_list|>
argument_list|()
decl_stmt|;
specifier|protected
specifier|transient
name|MapOpCtx
name|current
decl_stmt|;
specifier|private
specifier|transient
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|extraChildrenToClose
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Path
argument_list|>
name|normalizedPaths
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Path
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|static
class|class
name|MapInputPath
block|{
name|String
name|path
decl_stmt|;
name|String
name|alias
decl_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|op
decl_stmt|;
name|PartitionDesc
name|partDesc
decl_stmt|;
comment|/**      * @param path      * @param alias      * @param op      */
specifier|public
name|MapInputPath
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|alias
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|op
parameter_list|,
name|PartitionDesc
name|partDesc
parameter_list|)
block|{
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|alias
operator|=
name|alias
expr_stmt|;
name|this
operator|.
name|op
operator|=
name|op
expr_stmt|;
name|this
operator|.
name|partDesc
operator|=
name|partDesc
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|MapInputPath
condition|)
block|{
name|MapInputPath
name|mObj
init|=
operator|(
name|MapInputPath
operator|)
name|o
decl_stmt|;
return|return
name|path
operator|.
name|equals
argument_list|(
name|mObj
operator|.
name|path
argument_list|)
operator|&&
name|alias
operator|.
name|equals
argument_list|(
name|mObj
operator|.
name|alias
argument_list|)
operator|&&
name|op
operator|.
name|equals
argument_list|(
name|mObj
operator|.
name|op
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|ret
init|=
operator|(
name|path
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|path
operator|.
name|hashCode
argument_list|()
decl_stmt|;
name|ret
operator|+=
operator|(
name|alias
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|alias
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|ret
operator|+=
operator|(
name|op
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|op
operator|.
name|hashCode
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
specifier|protected
specifier|static
class|class
name|MapOpCtx
block|{
name|StructObjectInspector
name|tblRawRowObjectInspector
decl_stmt|;
comment|// columns
name|StructObjectInspector
name|partObjectInspector
decl_stmt|;
comment|// partition columns
name|StructObjectInspector
name|vcsObjectInspector
decl_stmt|;
comment|// virtual columns
name|StructObjectInspector
name|rowObjectInspector
decl_stmt|;
name|Converter
name|partTblObjectInspectorConverter
decl_stmt|;
name|Object
index|[]
name|rowWithPart
decl_stmt|;
name|Object
index|[]
name|rowWithPartAndVC
decl_stmt|;
name|Deserializer
name|deserializer
decl_stmt|;
name|String
name|tableName
decl_stmt|;
name|String
name|partName
decl_stmt|;
name|List
argument_list|<
name|VirtualColumn
argument_list|>
name|vcs
decl_stmt|;
name|Object
index|[]
name|vcValues
decl_stmt|;
specifier|private
name|boolean
name|isPartitioned
parameter_list|()
block|{
return|return
name|partObjectInspector
operator|!=
literal|null
return|;
block|}
specifier|private
name|boolean
name|hasVC
parameter_list|()
block|{
return|return
name|vcsObjectInspector
operator|!=
literal|null
return|;
block|}
specifier|private
name|Object
name|readRow
parameter_list|(
name|Writable
name|value
parameter_list|)
throws|throws
name|SerDeException
block|{
return|return
name|partTblObjectInspectorConverter
operator|.
name|convert
argument_list|(
name|deserializer
operator|.
name|deserialize
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|StructObjectInspector
name|getRowObjectInspector
parameter_list|()
block|{
return|return
name|rowObjectInspector
return|;
block|}
block|}
comment|/**    * Initializes this map op as the root of the tree. It sets JobConf&    * MapRedWork and starts initialization of the operator tree rooted at this    * op.    *    * @param hconf    * @param mapWork    * @throws HiveException    */
specifier|public
name|void
name|initializeAsRoot
parameter_list|(
name|Configuration
name|hconf
parameter_list|,
name|MapWork
name|mapWork
parameter_list|)
throws|throws
name|HiveException
block|{
name|setConf
argument_list|(
name|mapWork
argument_list|)
expr_stmt|;
name|setChildren
argument_list|(
name|hconf
argument_list|)
expr_stmt|;
name|initialize
argument_list|(
name|hconf
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|MapOpCtx
name|initObjectInspector
parameter_list|(
name|Configuration
name|hconf
parameter_list|,
name|MapInputPath
name|ctx
parameter_list|,
name|Map
argument_list|<
name|TableDesc
argument_list|,
name|StructObjectInspector
argument_list|>
name|convertedOI
parameter_list|)
throws|throws
name|Exception
block|{
name|PartitionDesc
name|pd
init|=
name|ctx
operator|.
name|partDesc
decl_stmt|;
name|TableDesc
name|td
init|=
name|pd
operator|.
name|getTableDesc
argument_list|()
decl_stmt|;
name|MapOpCtx
name|opCtx
init|=
operator|new
name|MapOpCtx
argument_list|()
decl_stmt|;
comment|// Use table properties in case of unpartitioned tables,
comment|// and the union of table properties and partition properties, with partition
comment|// taking precedence, in the case of partitioned tables
name|Properties
name|overlayedProps
init|=
name|SerDeUtils
operator|.
name|createOverlayedProperties
argument_list|(
name|td
operator|.
name|getProperties
argument_list|()
argument_list|,
name|pd
operator|.
name|getProperties
argument_list|()
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
name|pd
operator|.
name|getPartSpec
argument_list|()
decl_stmt|;
name|opCtx
operator|.
name|tableName
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|overlayedProps
operator|.
name|getProperty
argument_list|(
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
name|opCtx
operator|.
name|partName
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|partSpec
argument_list|)
expr_stmt|;
name|Class
name|serdeclass
init|=
name|hconf
operator|.
name|getClassByName
argument_list|(
name|pd
operator|.
name|getSerdeClassName
argument_list|()
argument_list|)
decl_stmt|;
name|opCtx
operator|.
name|deserializer
operator|=
operator|(
name|Deserializer
operator|)
name|serdeclass
operator|.
name|newInstance
argument_list|()
expr_stmt|;
name|SerDeUtils
operator|.
name|initializeSerDe
argument_list|(
name|opCtx
operator|.
name|deserializer
argument_list|,
name|hconf
argument_list|,
name|td
operator|.
name|getProperties
argument_list|()
argument_list|,
name|pd
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
name|StructObjectInspector
name|partRawRowObjectInspector
init|=
operator|(
name|StructObjectInspector
operator|)
name|opCtx
operator|.
name|deserializer
operator|.
name|getObjectInspector
argument_list|()
decl_stmt|;
name|opCtx
operator|.
name|tblRawRowObjectInspector
operator|=
name|convertedOI
operator|.
name|get
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|opCtx
operator|.
name|partTblObjectInspectorConverter
operator|=
name|ObjectInspectorConverters
operator|.
name|getConverter
argument_list|(
name|partRawRowObjectInspector
argument_list|,
name|opCtx
operator|.
name|tblRawRowObjectInspector
argument_list|)
expr_stmt|;
comment|// Next check if this table has partitions and if so
comment|// get the list of partition names as well as allocate
comment|// the serdes for the partition columns
name|String
name|pcols
init|=
name|overlayedProps
operator|.
name|getProperty
argument_list|(
name|hive_metastoreConstants
operator|.
name|META_TABLE_PARTITION_COLUMNS
argument_list|)
decl_stmt|;
if|if
condition|(
name|pcols
operator|!=
literal|null
operator|&&
name|pcols
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|String
index|[]
name|partKeys
init|=
name|pcols
operator|.
name|trim
argument_list|()
operator|.
name|split
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
name|String
name|pcolTypes
init|=
name|overlayedProps
operator|.
name|getProperty
argument_list|(
name|hive_metastoreConstants
operator|.
name|META_TABLE_PARTITION_COLUMN_TYPES
argument_list|)
decl_stmt|;
name|String
index|[]
name|partKeyTypes
init|=
name|pcolTypes
operator|.
name|trim
argument_list|()
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
if|if
condition|(
name|partKeys
operator|.
name|length
operator|>
name|partKeyTypes
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Internal error : partKeys length, "
operator|+
name|partKeys
operator|.
name|length
operator|+
literal|" greater than partKeyTypes length, "
operator|+
name|partKeyTypes
operator|.
name|length
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|partNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|partKeys
operator|.
name|length
argument_list|)
decl_stmt|;
name|Object
index|[]
name|partValues
init|=
operator|new
name|Object
index|[
name|partKeys
operator|.
name|length
index|]
decl_stmt|;
name|List
argument_list|<
name|ObjectInspector
argument_list|>
name|partObjectInspectors
init|=
operator|new
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
argument_list|(
name|partKeys
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partKeys
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|key
init|=
name|partKeys
index|[
name|i
index|]
decl_stmt|;
name|partNames
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|ObjectInspector
name|oi
init|=
name|PrimitiveObjectInspectorFactory
operator|.
name|getPrimitiveWritableObjectInspector
argument_list|(
name|TypeInfoFactory
operator|.
name|getPrimitiveTypeInfo
argument_list|(
name|partKeyTypes
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
comment|// Partitions do not exist for this table
if|if
condition|(
name|partSpec
operator|==
literal|null
condition|)
block|{
comment|// for partitionless table, initialize partValue to null
name|partValues
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|partValues
index|[
name|i
index|]
operator|=
name|ObjectInspectorConverters
operator|.
name|getConverter
argument_list|(
name|PrimitiveObjectInspectorFactory
operator|.
name|javaStringObjectInspector
argument_list|,
name|oi
argument_list|)
operator|.
name|convert
argument_list|(
name|partSpec
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|partObjectInspectors
operator|.
name|add
argument_list|(
name|oi
argument_list|)
expr_stmt|;
block|}
name|opCtx
operator|.
name|rowWithPart
operator|=
operator|new
name|Object
index|[]
block|{
literal|null
block|,
name|partValues
block|}
expr_stmt|;
name|opCtx
operator|.
name|partObjectInspector
operator|=
name|ObjectInspectorFactory
operator|.
name|getStandardStructObjectInspector
argument_list|(
name|partNames
argument_list|,
name|partObjectInspectors
argument_list|)
expr_stmt|;
block|}
comment|// The op may not be a TableScan for mapjoins
comment|// Consider the query: select /*+MAPJOIN(a)*/ count(*) FROM T1 a JOIN T2 b ON a.key = b.key;
comment|// In that case, it will be a Select, but the rowOI need not be amended
if|if
condition|(
name|ctx
operator|.
name|op
operator|instanceof
name|TableScanOperator
condition|)
block|{
name|TableScanOperator
name|tsOp
init|=
operator|(
name|TableScanOperator
operator|)
name|ctx
operator|.
name|op
decl_stmt|;
name|TableScanDesc
name|tsDesc
init|=
name|tsOp
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|tsDesc
operator|!=
literal|null
operator|&&
name|tsDesc
operator|.
name|hasVirtualCols
argument_list|()
condition|)
block|{
name|opCtx
operator|.
name|vcs
operator|=
name|tsDesc
operator|.
name|getVirtualCols
argument_list|()
expr_stmt|;
name|opCtx
operator|.
name|vcValues
operator|=
operator|new
name|Object
index|[
name|opCtx
operator|.
name|vcs
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|opCtx
operator|.
name|vcsObjectInspector
operator|=
name|VirtualColumn
operator|.
name|getVCSObjectInspector
argument_list|(
name|opCtx
operator|.
name|vcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|opCtx
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
name|opCtx
operator|.
name|rowWithPartAndVC
operator|=
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|opCtx
operator|.
name|rowWithPart
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|opCtx
operator|.
name|rowWithPartAndVC
operator|=
operator|new
name|Object
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|opCtx
operator|.
name|hasVC
argument_list|()
operator|&&
operator|!
name|opCtx
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
name|opCtx
operator|.
name|rowObjectInspector
operator|=
name|opCtx
operator|.
name|tblRawRowObjectInspector
expr_stmt|;
return|return
name|opCtx
return|;
block|}
name|List
argument_list|<
name|StructObjectInspector
argument_list|>
name|inspectors
init|=
operator|new
name|ArrayList
argument_list|<
name|StructObjectInspector
argument_list|>
argument_list|()
decl_stmt|;
name|inspectors
operator|.
name|add
argument_list|(
name|opCtx
operator|.
name|tblRawRowObjectInspector
argument_list|)
expr_stmt|;
if|if
condition|(
name|opCtx
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
name|inspectors
operator|.
name|add
argument_list|(
name|opCtx
operator|.
name|partObjectInspector
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opCtx
operator|.
name|hasVC
argument_list|()
condition|)
block|{
name|inspectors
operator|.
name|add
argument_list|(
name|opCtx
operator|.
name|vcsObjectInspector
argument_list|)
expr_stmt|;
block|}
name|opCtx
operator|.
name|rowObjectInspector
operator|=
name|ObjectInspectorFactory
operator|.
name|getUnionStructObjectInspector
argument_list|(
name|inspectors
argument_list|)
expr_stmt|;
return|return
name|opCtx
return|;
block|}
comment|// Return the mapping for table descriptor to the expected table OI
comment|/**    * Traverse all the partitions for a table, and get the OI for the table.    * Note that a conversion is required if any of the partition OI is different    * from the table OI. For eg. if the query references table T (partitions P1, P2),    * and P1's schema is same as T, whereas P2's scheme is different from T, conversion    * might be needed for both P1 and P2, since SettableOI might be needed for T    */
specifier|private
name|Map
argument_list|<
name|TableDesc
argument_list|,
name|StructObjectInspector
argument_list|>
name|getConvertedOI
parameter_list|(
name|Configuration
name|hconf
parameter_list|)
throws|throws
name|HiveException
block|{
name|Map
argument_list|<
name|TableDesc
argument_list|,
name|StructObjectInspector
argument_list|>
name|tableDescOI
init|=
operator|new
name|HashMap
argument_list|<
name|TableDesc
argument_list|,
name|StructObjectInspector
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|TableDesc
argument_list|>
name|identityConverterTableDesc
init|=
operator|new
name|HashSet
argument_list|<
name|TableDesc
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|Map
argument_list|<
name|ObjectInspector
argument_list|,
name|Boolean
argument_list|>
name|oiSettableProperties
init|=
operator|new
name|HashMap
argument_list|<
name|ObjectInspector
argument_list|,
name|Boolean
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|onefile
range|:
name|conf
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|keySet
argument_list|()
control|)
block|{
name|PartitionDesc
name|pd
init|=
name|conf
operator|.
name|getPathToPartitionInfo
argument_list|()
operator|.
name|get
argument_list|(
name|onefile
argument_list|)
decl_stmt|;
name|TableDesc
name|tableDesc
init|=
name|pd
operator|.
name|getTableDesc
argument_list|()
decl_stmt|;
name|Properties
name|tblProps
init|=
name|tableDesc
operator|.
name|getProperties
argument_list|()
decl_stmt|;
name|Class
name|sdclass
init|=
name|hconf
operator|.
name|getClassByName
argument_list|(
name|pd
operator|.
name|getSerdeClassName
argument_list|()
argument_list|)
decl_stmt|;
name|Deserializer
name|partDeserializer
init|=
operator|(
name|Deserializer
operator|)
name|sdclass
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|SerDeUtils
operator|.
name|initializeSerDe
argument_list|(
name|partDeserializer
argument_list|,
name|hconf
argument_list|,
name|tblProps
argument_list|,
name|pd
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
name|StructObjectInspector
name|partRawRowObjectInspector
init|=
operator|(
name|StructObjectInspector
operator|)
name|partDeserializer
operator|.
name|getObjectInspector
argument_list|()
decl_stmt|;
name|StructObjectInspector
name|tblRawRowObjectInspector
init|=
name|tableDescOI
operator|.
name|get
argument_list|(
name|tableDesc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|tblRawRowObjectInspector
operator|==
literal|null
operator|)
operator|||
operator|(
name|identityConverterTableDesc
operator|.
name|contains
argument_list|(
name|tableDesc
argument_list|)
operator|)
condition|)
block|{
name|sdclass
operator|=
name|hconf
operator|.
name|getClassByName
argument_list|(
name|tableDesc
operator|.
name|getSerdeClassName
argument_list|()
argument_list|)
expr_stmt|;
name|Deserializer
name|tblDeserializer
init|=
operator|(
name|Deserializer
operator|)
name|sdclass
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|SerDeUtils
operator|.
name|initializeSerDe
argument_list|(
name|tblDeserializer
argument_list|,
name|hconf
argument_list|,
name|tblProps
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|tblRawRowObjectInspector
operator|=
operator|(
name|StructObjectInspector
operator|)
name|ObjectInspectorConverters
operator|.
name|getConvertedOI
argument_list|(
name|partRawRowObjectInspector
argument_list|,
name|tblDeserializer
operator|.
name|getObjectInspector
argument_list|()
argument_list|,
name|oiSettableProperties
argument_list|)
expr_stmt|;
if|if
condition|(
name|identityConverterTableDesc
operator|.
name|contains
argument_list|(
name|tableDesc
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|partRawRowObjectInspector
operator|.
name|equals
argument_list|(
name|tblRawRowObjectInspector
argument_list|)
condition|)
block|{
name|identityConverterTableDesc
operator|.
name|remove
argument_list|(
name|tableDesc
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|partRawRowObjectInspector
operator|.
name|equals
argument_list|(
name|tblRawRowObjectInspector
argument_list|)
condition|)
block|{
name|identityConverterTableDesc
operator|.
name|add
argument_list|(
name|tableDesc
argument_list|)
expr_stmt|;
block|}
name|tableDescOI
operator|.
name|put
argument_list|(
name|tableDesc
argument_list|,
name|tblRawRowObjectInspector
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|tableDescOI
return|;
block|}
specifier|public
name|void
name|setChildren
parameter_list|(
name|Configuration
name|hconf
parameter_list|)
throws|throws
name|HiveException
block|{
name|Path
name|fpath
init|=
name|IOContext
operator|.
name|get
argument_list|(
name|hconf
argument_list|)
operator|.
name|getInputPath
argument_list|()
decl_stmt|;
name|boolean
name|schemeless
init|=
name|fpath
operator|.
name|toUri
argument_list|()
operator|.
name|getScheme
argument_list|()
operator|==
literal|null
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|TableDesc
argument_list|,
name|StructObjectInspector
argument_list|>
name|convertedOI
init|=
name|getConvertedOI
argument_list|(
name|hconf
argument_list|)
decl_stmt|;
try|try
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|conf
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|onefile
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Path
name|onepath
init|=
operator|new
name|Path
argument_list|(
name|onefile
argument_list|)
decl_stmt|;
if|if
condition|(
name|schemeless
condition|)
block|{
name|onepath
operator|=
operator|new
name|Path
argument_list|(
name|onepath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|PartitionDesc
name|partDesc
init|=
name|conf
operator|.
name|getPathToPartitionInfo
argument_list|()
operator|.
name|get
argument_list|(
name|onefile
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|onealias
range|:
name|aliases
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
name|conf
operator|.
name|getAliasToWork
argument_list|()
operator|.
name|get
argument_list|(
name|onealias
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding alias "
operator|+
name|onealias
operator|+
literal|" to work list for file "
operator|+
name|onefile
argument_list|)
expr_stmt|;
block|}
name|MapInputPath
name|inp
init|=
operator|new
name|MapInputPath
argument_list|(
name|onefile
argument_list|,
name|onealias
argument_list|,
name|op
argument_list|,
name|partDesc
argument_list|)
decl_stmt|;
if|if
condition|(
name|opCtxMap
operator|.
name|containsKey
argument_list|(
name|inp
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|MapOpCtx
name|opCtx
init|=
name|initObjectInspector
argument_list|(
name|hconf
argument_list|,
name|inp
argument_list|,
name|convertedOI
argument_list|)
decl_stmt|;
name|opCtxMap
operator|.
name|put
argument_list|(
name|inp
argument_list|,
name|opCtx
argument_list|)
expr_stmt|;
name|op
operator|.
name|setParentOperators
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|add
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// check for the operators who will process rows coming to this Map
comment|// Operator
if|if
condition|(
operator|!
name|onepath
operator|.
name|toUri
argument_list|()
operator|.
name|relativize
argument_list|(
name|fpath
operator|.
name|toUri
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|fpath
operator|.
name|toUri
argument_list|()
argument_list|)
condition|)
block|{
name|children
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|childrenOpToOpCtxMap
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|opCtx
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"dump "
operator|+
name|op
operator|+
literal|" "
operator|+
name|opCtxMap
operator|.
name|get
argument_list|(
name|inp
argument_list|)
operator|.
name|rowObjectInspector
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|current
operator|=
name|opCtx
expr_stmt|;
comment|// just need for TestOperators.testMapOperator
block|}
block|}
if|if
condition|(
name|children
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// didn't find match for input file path in configuration!
comment|// serious problem ..
name|LOG
operator|.
name|error
argument_list|(
literal|"Configuration does not have any alias for path: "
operator|+
name|fpath
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Configuration and input path are inconsistent"
argument_list|)
throw|;
block|}
comment|// we found all the operators that we are supposed to process.
name|setChildOperators
argument_list|(
name|children
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|initializeOp
parameter_list|(
name|Configuration
name|hconf
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// set that parent initialization is done and call initialize on children
name|state
operator|=
name|State
operator|.
name|INIT
expr_stmt|;
name|statsMap
operator|.
name|put
argument_list|(
name|Counter
operator|.
name|DESERIALIZE_ERRORS
argument_list|,
name|deserialize_error_count
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|children
init|=
name|getChildOperators
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|MapOpCtx
argument_list|>
name|entry
range|:
name|childrenOpToOpCtxMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|child
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|MapOpCtx
name|mapOpCtx
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// Add alias, table name, and partitions to hadoop conf so that their
comment|// children will inherit these
name|HiveConf
operator|.
name|setVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETABLENAME
argument_list|,
name|mapOpCtx
operator|.
name|tableName
argument_list|)
expr_stmt|;
name|HiveConf
operator|.
name|setVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPARTITIONNAME
argument_list|,
name|mapOpCtx
operator|.
name|partName
argument_list|)
expr_stmt|;
name|child
operator|.
name|initialize
argument_list|(
name|hconf
argument_list|,
operator|new
name|ObjectInspector
index|[]
block|{
name|mapOpCtx
operator|.
name|rowObjectInspector
block|}
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Entry
argument_list|<
name|MapInputPath
argument_list|,
name|MapOpCtx
argument_list|>
name|entry
range|:
name|opCtxMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|MapInputPath
name|input
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|MapOpCtx
name|mapOpCtx
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// Add alias, table name, and partitions to hadoop conf so that their
comment|// children will inherit these
name|HiveConf
operator|.
name|setVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETABLENAME
argument_list|,
name|mapOpCtx
operator|.
name|tableName
argument_list|)
expr_stmt|;
name|HiveConf
operator|.
name|setVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPARTITIONNAME
argument_list|,
name|mapOpCtx
operator|.
name|partName
argument_list|)
expr_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
name|input
operator|.
name|op
decl_stmt|;
if|if
condition|(
name|children
operator|.
name|indexOf
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|// op is not in the children list, so need to remember it and close it afterwards
if|if
condition|(
name|extraChildrenToClose
operator|==
literal|null
condition|)
block|{
name|extraChildrenToClose
operator|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|extraChildrenToClose
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|op
operator|.
name|initialize
argument_list|(
name|hconf
argument_list|,
operator|new
name|ObjectInspector
index|[]
block|{
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|rowObjectInspector
block|}
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * close extra child operators that are initialized but are not executed.    */
annotation|@
name|Override
specifier|public
name|void
name|closeOp
parameter_list|(
name|boolean
name|abort
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|extraChildrenToClose
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|extraChildrenToClose
control|)
block|{
name|op
operator|.
name|close
argument_list|(
name|abort
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Find context for current input file
annotation|@
name|Override
specifier|public
name|void
name|cleanUpInputFileChangedOp
parameter_list|()
throws|throws
name|HiveException
block|{
name|Path
name|fpath
init|=
name|getExecContext
argument_list|()
operator|.
name|getCurrentInputPath
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|onefile
range|:
name|conf
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Path
name|onepath
init|=
name|normalizePath
argument_list|(
name|onefile
argument_list|)
decl_stmt|;
comment|// check for the operators who will process rows coming to this Map
comment|// Operator
if|if
condition|(
name|onepath
operator|.
name|toUri
argument_list|()
operator|.
name|relativize
argument_list|(
name|fpath
operator|.
name|toUri
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|fpath
operator|.
name|toUri
argument_list|()
argument_list|)
condition|)
block|{
comment|// not from this
continue|continue;
block|}
name|PartitionDesc
name|partDesc
init|=
name|conf
operator|.
name|getPathToPartitionInfo
argument_list|()
operator|.
name|get
argument_list|(
name|onefile
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|onealias
range|:
name|conf
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|get
argument_list|(
name|onefile
argument_list|)
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
name|conf
operator|.
name|getAliasToWork
argument_list|()
operator|.
name|get
argument_list|(
name|onealias
argument_list|)
decl_stmt|;
name|MapInputPath
name|inp
init|=
operator|new
name|MapInputPath
argument_list|(
name|onefile
argument_list|,
name|onealias
argument_list|,
name|op
argument_list|,
name|partDesc
argument_list|)
decl_stmt|;
name|MapOpCtx
name|context
init|=
name|opCtxMap
operator|.
name|get
argument_list|(
name|inp
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
operator|!=
literal|null
condition|)
block|{
name|current
operator|=
name|context
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing alias "
operator|+
name|onealias
operator|+
literal|" for file "
operator|+
name|onefile
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Invalid path "
operator|+
name|fpath
argument_list|)
throw|;
block|}
specifier|private
name|Path
name|normalizePath
parameter_list|(
name|String
name|onefile
parameter_list|)
block|{
comment|//creating Path is expensive, so cache the corresponding
comment|//Path object in normalizedPaths
name|Path
name|path
init|=
name|normalizedPaths
operator|.
name|get
argument_list|(
name|onefile
argument_list|)
decl_stmt|;
if|if
condition|(
name|path
operator|==
literal|null
condition|)
block|{
name|path
operator|=
operator|new
name|Path
argument_list|(
name|onefile
argument_list|)
expr_stmt|;
name|normalizedPaths
operator|.
name|put
argument_list|(
name|onefile
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
return|return
name|path
return|;
block|}
specifier|public
name|void
name|process
parameter_list|(
name|Writable
name|value
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// A mapper can span multiple files/partitions.
comment|// The serializers need to be reset if the input file changed
name|ExecMapperContext
name|context
init|=
name|getExecContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
operator|!=
literal|null
operator|&&
name|context
operator|.
name|inputFileChanged
argument_list|()
condition|)
block|{
comment|// The child operators cleanup if input file has changed
name|cleanUpInputFileChanged
argument_list|()
expr_stmt|;
block|}
name|Object
name|row
decl_stmt|;
try|try
block|{
name|row
operator|=
name|current
operator|.
name|readRow
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|.
name|hasVC
argument_list|()
condition|)
block|{
name|current
operator|.
name|rowWithPartAndVC
index|[
literal|0
index|]
operator|=
name|row
expr_stmt|;
if|if
condition|(
name|context
operator|!=
literal|null
condition|)
block|{
name|populateVirtualColumnValues
argument_list|(
name|context
argument_list|,
name|current
operator|.
name|vcs
argument_list|,
name|current
operator|.
name|vcValues
argument_list|,
name|current
operator|.
name|deserializer
argument_list|)
expr_stmt|;
block|}
name|int
name|vcPos
init|=
name|current
operator|.
name|isPartitioned
argument_list|()
condition|?
literal|2
else|:
literal|1
decl_stmt|;
name|current
operator|.
name|rowWithPartAndVC
index|[
name|vcPos
index|]
operator|=
name|current
operator|.
name|vcValues
expr_stmt|;
name|row
operator|=
name|current
operator|.
name|rowWithPartAndVC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
name|current
operator|.
name|rowWithPart
index|[
literal|0
index|]
operator|=
name|row
expr_stmt|;
name|row
operator|=
name|current
operator|.
name|rowWithPart
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// Serialize the row and output.
name|String
name|rawRowString
decl_stmt|;
try|try
block|{
name|rawRowString
operator|=
name|value
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e2
parameter_list|)
block|{
name|rawRowString
operator|=
literal|"[Error getting row data with exception "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e2
argument_list|)
operator|+
literal|" ]"
expr_stmt|;
block|}
comment|// TODO: policy on deserialization errors
name|deserialize_error_count
operator|.
name|set
argument_list|(
name|deserialize_error_count
operator|.
name|get
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Hive Runtime Error while processing writable "
operator|+
name|rawRowString
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// The row has been converted to comply with table schema, irrespective of partition schema.
comment|// So, use tblOI (and not partOI) for forwarding
try|try
block|{
name|forward
argument_list|(
name|row
argument_list|,
name|current
operator|.
name|rowObjectInspector
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// Serialize the row and output the error message.
name|String
name|rowString
decl_stmt|;
try|try
block|{
name|rowString
operator|=
name|SerDeUtils
operator|.
name|getJSONString
argument_list|(
name|row
argument_list|,
name|current
operator|.
name|rowObjectInspector
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e2
parameter_list|)
block|{
name|rowString
operator|=
literal|"[Error getting row data with exception "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e2
argument_list|)
operator|+
literal|" ]"
expr_stmt|;
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Hive Runtime Error while processing row "
operator|+
name|rowString
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|public
specifier|static
name|Object
index|[]
name|populateVirtualColumnValues
parameter_list|(
name|ExecMapperContext
name|ctx
parameter_list|,
name|List
argument_list|<
name|VirtualColumn
argument_list|>
name|vcs
parameter_list|,
name|Object
index|[]
name|vcValues
parameter_list|,
name|Deserializer
name|deserializer
parameter_list|)
block|{
if|if
condition|(
name|vcs
operator|==
literal|null
condition|)
block|{
return|return
name|vcValues
return|;
block|}
if|if
condition|(
name|vcValues
operator|==
literal|null
condition|)
block|{
name|vcValues
operator|=
operator|new
name|Object
index|[
name|vcs
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vcs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|VirtualColumn
name|vc
init|=
name|vcs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|vc
operator|.
name|equals
argument_list|(
name|VirtualColumn
operator|.
name|FILENAME
argument_list|)
condition|)
block|{
if|if
condition|(
name|ctx
operator|.
name|inputFileChanged
argument_list|()
condition|)
block|{
name|vcValues
index|[
name|i
index|]
operator|=
operator|new
name|Text
argument_list|(
name|ctx
operator|.
name|getCurrentInputPath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|vc
operator|.
name|equals
argument_list|(
name|VirtualColumn
operator|.
name|BLOCKOFFSET
argument_list|)
condition|)
block|{
name|long
name|current
init|=
name|ctx
operator|.
name|getIoCxt
argument_list|()
operator|.
name|getCurrentBlockStart
argument_list|()
decl_stmt|;
name|LongWritable
name|old
init|=
operator|(
name|LongWritable
operator|)
name|vcValues
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|old
operator|==
literal|null
condition|)
block|{
name|old
operator|=
operator|new
name|LongWritable
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|vcValues
index|[
name|i
index|]
operator|=
name|old
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|current
operator|!=
name|old
operator|.
name|get
argument_list|()
condition|)
block|{
name|old
operator|.
name|set
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|vc
operator|.
name|equals
argument_list|(
name|VirtualColumn
operator|.
name|ROWOFFSET
argument_list|)
condition|)
block|{
name|long
name|current
init|=
name|ctx
operator|.
name|getIoCxt
argument_list|()
operator|.
name|getCurrentRow
argument_list|()
decl_stmt|;
name|LongWritable
name|old
init|=
operator|(
name|LongWritable
operator|)
name|vcValues
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|old
operator|==
literal|null
condition|)
block|{
name|old
operator|=
operator|new
name|LongWritable
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|vcValues
index|[
name|i
index|]
operator|=
name|old
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|current
operator|!=
name|old
operator|.
name|get
argument_list|()
condition|)
block|{
name|old
operator|.
name|set
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|vc
operator|.
name|equals
argument_list|(
name|VirtualColumn
operator|.
name|RAWDATASIZE
argument_list|)
condition|)
block|{
name|long
name|current
init|=
literal|0L
decl_stmt|;
name|SerDeStats
name|stats
init|=
name|deserializer
operator|.
name|getSerDeStats
argument_list|()
decl_stmt|;
if|if
condition|(
name|stats
operator|!=
literal|null
condition|)
block|{
name|current
operator|=
name|stats
operator|.
name|getRawDataSize
argument_list|()
expr_stmt|;
block|}
name|LongWritable
name|old
init|=
operator|(
name|LongWritable
operator|)
name|vcValues
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|old
operator|==
literal|null
condition|)
block|{
name|old
operator|=
operator|new
name|LongWritable
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|vcValues
index|[
name|i
index|]
operator|=
name|old
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|current
operator|!=
name|old
operator|.
name|get
argument_list|()
condition|)
block|{
name|old
operator|.
name|set
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|vc
operator|.
name|equals
argument_list|(
name|VirtualColumn
operator|.
name|ROWID
argument_list|)
condition|)
block|{
if|if
condition|(
name|ctx
operator|.
name|getIoCxt
argument_list|()
operator|.
name|ri
operator|==
literal|null
condition|)
block|{
name|vcValues
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vcValues
index|[
name|i
index|]
operator|==
literal|null
condition|)
block|{
name|vcValues
index|[
name|i
index|]
operator|=
operator|new
name|Object
index|[
name|RecordIdentifier
operator|.
name|Field
operator|.
name|values
argument_list|()
operator|.
name|length
index|]
expr_stmt|;
block|}
name|RecordIdentifier
operator|.
name|StructInfo
operator|.
name|toArray
argument_list|(
name|ctx
operator|.
name|getIoCxt
argument_list|()
operator|.
name|ri
argument_list|,
operator|(
name|Object
index|[]
operator|)
name|vcValues
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|getIoCxt
argument_list|()
operator|.
name|ri
operator|=
literal|null
expr_stmt|;
comment|//so we don't accidentally cache the value; shouldn't
comment|//happen since IO layer either knows how to produce ROW__ID or not - but to be safe
block|}
block|}
block|}
return|return
name|vcValues
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|processOp
parameter_list|(
name|Object
name|row
parameter_list|,
name|int
name|tag
parameter_list|)
throws|throws
name|HiveException
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Hive 2 Internal error: should not be called!"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|getOperatorName
argument_list|()
return|;
block|}
specifier|static
specifier|public
name|String
name|getOperatorName
parameter_list|()
block|{
return|return
literal|"MAP"
return|;
block|}
annotation|@
name|Override
specifier|public
name|OperatorType
name|getType
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|Integer
argument_list|,
name|DummyStoreOperator
argument_list|>
name|getTagToOperatorTree
parameter_list|()
block|{
return|return
name|MapRecordProcessor
operator|.
name|getConnectOps
argument_list|()
return|;
block|}
block|}
end_class

end_unit

