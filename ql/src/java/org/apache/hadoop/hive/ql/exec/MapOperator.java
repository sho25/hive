begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|hive_metastoreConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|CompilationOpContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|mr
operator|.
name|ExecMapperContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|AcidUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|RecordIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|VirtualColumn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MapWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PartitionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableScanDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|api
operator|.
name|OperatorType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|ColumnProjectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|Deserializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorConverters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorConverters
operator|.
name|Converter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|PrimitiveObjectInspectorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * Map operator. This triggers overall map side processing. This is a little  * different from regular operators in that it starts off by processing a  * Writable data structure from a Table (instead of a Hive Object).  **/
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
class|class
name|MapOperator
extends|extends
name|AbstractMapOperator
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
specifier|protected
specifier|transient
name|long
name|cntr
init|=
literal|1
decl_stmt|;
specifier|protected
specifier|transient
name|long
name|logEveryNRows
init|=
literal|0
decl_stmt|;
comment|// input path --> {operator --> context}
specifier|private
specifier|final
name|Map
argument_list|<
name|Path
argument_list|,
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|MapOpCtx
argument_list|>
argument_list|>
name|opCtxMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// child operator --> object inspector (converted OI if it's needed)
specifier|private
specifier|final
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|StructObjectInspector
argument_list|>
name|childrenOpToOI
init|=
operator|new
name|HashMap
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|StructObjectInspector
argument_list|>
argument_list|()
decl_stmt|;
comment|// context for current input file
specifier|protected
specifier|transient
name|MapOpCtx
index|[]
name|currentCtxs
decl_stmt|;
specifier|protected
specifier|static
class|class
name|MapOpCtx
block|{
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"[alias="
operator|+
name|alias
operator|+
literal|", op="
operator|+
name|op
operator|+
literal|"]"
return|;
block|}
specifier|final
name|String
name|alias
decl_stmt|;
specifier|final
name|Operator
argument_list|<
name|?
argument_list|>
name|op
decl_stmt|;
specifier|final
name|PartitionDesc
name|partDesc
decl_stmt|;
name|StructObjectInspector
name|partObjectInspector
decl_stmt|;
comment|// partition columns
name|StructObjectInspector
name|vcsObjectInspector
decl_stmt|;
comment|// virtual columns
name|StructObjectInspector
name|rowObjectInspector
decl_stmt|;
name|Converter
name|partTblObjectInspectorConverter
decl_stmt|;
name|Object
index|[]
name|rowWithPart
decl_stmt|;
name|Object
index|[]
name|rowWithPartAndVC
decl_stmt|;
name|Deserializer
name|deserializer
decl_stmt|;
name|String
name|tableName
decl_stmt|;
name|String
name|partName
decl_stmt|;
name|List
argument_list|<
name|VirtualColumn
argument_list|>
name|vcs
decl_stmt|;
name|Object
index|[]
name|vcValues
decl_stmt|;
specifier|public
name|MapOpCtx
parameter_list|(
name|String
name|alias
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|op
parameter_list|,
name|PartitionDesc
name|partDesc
parameter_list|)
block|{
name|this
operator|.
name|alias
operator|=
name|alias
expr_stmt|;
name|this
operator|.
name|op
operator|=
name|op
expr_stmt|;
name|this
operator|.
name|partDesc
operator|=
name|partDesc
expr_stmt|;
block|}
specifier|private
name|boolean
name|isPartitioned
parameter_list|()
block|{
return|return
name|partObjectInspector
operator|!=
literal|null
return|;
block|}
specifier|private
name|boolean
name|hasVC
parameter_list|()
block|{
return|return
name|vcsObjectInspector
operator|!=
literal|null
return|;
block|}
specifier|private
name|Object
name|readRow
parameter_list|(
name|Writable
name|value
parameter_list|,
name|ExecMapperContext
name|context
parameter_list|)
throws|throws
name|SerDeException
block|{
name|Object
name|deserialized
init|=
name|deserializer
operator|.
name|deserialize
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|Object
name|row
init|=
name|partTblObjectInspectorConverter
operator|.
name|convert
argument_list|(
name|deserialized
argument_list|)
decl_stmt|;
if|if
condition|(
name|hasVC
argument_list|()
condition|)
block|{
name|rowWithPartAndVC
index|[
literal|0
index|]
operator|=
name|row
expr_stmt|;
if|if
condition|(
name|context
operator|!=
literal|null
condition|)
block|{
name|populateVirtualColumnValues
argument_list|(
name|context
argument_list|,
name|vcs
argument_list|,
name|vcValues
argument_list|,
name|deserializer
argument_list|)
expr_stmt|;
block|}
name|int
name|vcPos
init|=
name|isPartitioned
argument_list|()
condition|?
literal|2
else|:
literal|1
decl_stmt|;
name|rowWithPartAndVC
index|[
name|vcPos
index|]
operator|=
name|vcValues
expr_stmt|;
return|return
name|rowWithPartAndVC
return|;
block|}
elseif|else
if|if
condition|(
name|isPartitioned
argument_list|()
condition|)
block|{
name|rowWithPart
index|[
literal|0
index|]
operator|=
name|row
expr_stmt|;
return|return
name|rowWithPart
return|;
block|}
return|return
name|row
return|;
block|}
specifier|public
name|boolean
name|forward
parameter_list|(
name|Object
name|row
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|op
operator|.
name|getDone
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|op
operator|.
name|process
argument_list|(
name|row
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Initializes this map op as the root of the tree. It sets JobConf&    * MapRedWork and starts initialization of the operator tree rooted at this    * op.    *    * @param hconf    * @param mapWork    * @throws HiveException    */
annotation|@
name|VisibleForTesting
name|void
name|initializeAsRoot
parameter_list|(
name|JobConf
name|hconf
parameter_list|,
name|MapWork
name|mapWork
parameter_list|)
throws|throws
name|Exception
block|{
name|setConf
argument_list|(
name|mapWork
argument_list|)
expr_stmt|;
name|setChildren
argument_list|(
name|hconf
argument_list|)
expr_stmt|;
name|passExecContext
argument_list|(
operator|new
name|ExecMapperContext
argument_list|(
name|hconf
argument_list|)
argument_list|)
expr_stmt|;
name|initializeMapOperator
argument_list|(
name|hconf
argument_list|)
expr_stmt|;
block|}
specifier|private
name|MapOpCtx
name|initObjectInspector
parameter_list|(
name|Configuration
name|hconf
parameter_list|,
name|MapOpCtx
name|opCtx
parameter_list|,
name|StructObjectInspector
name|tableRowOI
parameter_list|)
throws|throws
name|Exception
block|{
name|PartitionDesc
name|pd
init|=
name|opCtx
operator|.
name|partDesc
decl_stmt|;
name|TableDesc
name|td
init|=
name|pd
operator|.
name|getTableDesc
argument_list|()
decl_stmt|;
comment|// Use table properties in case of unpartitioned tables,
comment|// and the union of table properties and partition properties, with partition
comment|// taking precedence, in the case of partitioned tables
name|Properties
name|overlayedProps
init|=
name|SerDeUtils
operator|.
name|createOverlayedProperties
argument_list|(
name|td
operator|.
name|getProperties
argument_list|()
argument_list|,
name|pd
operator|.
name|getProperties
argument_list|()
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
name|pd
operator|.
name|getPartSpec
argument_list|()
decl_stmt|;
name|opCtx
operator|.
name|tableName
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|overlayedProps
operator|.
name|getProperty
argument_list|(
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
name|opCtx
operator|.
name|partName
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|partSpec
argument_list|)
expr_stmt|;
name|opCtx
operator|.
name|deserializer
operator|=
name|pd
operator|.
name|getDeserializer
argument_list|(
name|hconf
argument_list|)
expr_stmt|;
name|StructObjectInspector
name|partRawRowObjectInspector
decl_stmt|;
name|boolean
name|isAcid
init|=
name|AcidUtils
operator|.
name|isTablePropertyTransactional
argument_list|(
name|td
operator|.
name|getProperties
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|Utilities
operator|.
name|isSchemaEvolutionEnabled
argument_list|(
name|hconf
argument_list|,
name|isAcid
argument_list|)
operator|&&
name|Utilities
operator|.
name|isInputFileFormatSelfDescribing
argument_list|(
name|pd
argument_list|)
condition|)
block|{
name|partRawRowObjectInspector
operator|=
name|tableRowOI
expr_stmt|;
block|}
else|else
block|{
name|partRawRowObjectInspector
operator|=
operator|(
name|StructObjectInspector
operator|)
name|opCtx
operator|.
name|deserializer
operator|.
name|getObjectInspector
argument_list|()
expr_stmt|;
block|}
name|opCtx
operator|.
name|partTblObjectInspectorConverter
operator|=
name|ObjectInspectorConverters
operator|.
name|getConverter
argument_list|(
name|partRawRowObjectInspector
argument_list|,
name|tableRowOI
argument_list|)
expr_stmt|;
comment|// Next check if this table has partitions and if so
comment|// get the list of partition names as well as allocate
comment|// the serdes for the partition columns
name|String
name|pcols
init|=
name|overlayedProps
operator|.
name|getProperty
argument_list|(
name|hive_metastoreConstants
operator|.
name|META_TABLE_PARTITION_COLUMNS
argument_list|)
decl_stmt|;
if|if
condition|(
name|pcols
operator|!=
literal|null
operator|&&
name|pcols
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|String
index|[]
name|partKeys
init|=
name|pcols
operator|.
name|trim
argument_list|()
operator|.
name|split
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
name|String
name|pcolTypes
init|=
name|overlayedProps
operator|.
name|getProperty
argument_list|(
name|hive_metastoreConstants
operator|.
name|META_TABLE_PARTITION_COLUMN_TYPES
argument_list|)
decl_stmt|;
name|String
index|[]
name|partKeyTypes
init|=
name|pcolTypes
operator|.
name|trim
argument_list|()
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
if|if
condition|(
name|partKeys
operator|.
name|length
operator|>
name|partKeyTypes
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Internal error : partKeys length, "
operator|+
name|partKeys
operator|.
name|length
operator|+
literal|" greater than partKeyTypes length, "
operator|+
name|partKeyTypes
operator|.
name|length
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|partNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|partKeys
operator|.
name|length
argument_list|)
decl_stmt|;
name|Object
index|[]
name|partValues
init|=
operator|new
name|Object
index|[
name|partKeys
operator|.
name|length
index|]
decl_stmt|;
name|List
argument_list|<
name|ObjectInspector
argument_list|>
name|partObjectInspectors
init|=
operator|new
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
argument_list|(
name|partKeys
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partKeys
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|key
init|=
name|partKeys
index|[
name|i
index|]
decl_stmt|;
name|partNames
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|ObjectInspector
name|oi
init|=
name|PrimitiveObjectInspectorFactory
operator|.
name|getPrimitiveWritableObjectInspector
argument_list|(
name|TypeInfoFactory
operator|.
name|getPrimitiveTypeInfo
argument_list|(
name|partKeyTypes
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
comment|// Partitions do not exist for this table
if|if
condition|(
name|partSpec
operator|==
literal|null
condition|)
block|{
comment|// for partitionless table, initialize partValue to null
name|partValues
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|partValues
index|[
name|i
index|]
operator|=
name|ObjectInspectorConverters
operator|.
name|getConverter
argument_list|(
name|PrimitiveObjectInspectorFactory
operator|.
name|javaStringObjectInspector
argument_list|,
name|oi
argument_list|)
operator|.
name|convert
argument_list|(
name|partSpec
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|partObjectInspectors
operator|.
name|add
argument_list|(
name|oi
argument_list|)
expr_stmt|;
block|}
name|opCtx
operator|.
name|rowWithPart
operator|=
operator|new
name|Object
index|[]
block|{
literal|null
block|,
name|partValues
block|}
expr_stmt|;
name|opCtx
operator|.
name|partObjectInspector
operator|=
name|ObjectInspectorFactory
operator|.
name|getStandardStructObjectInspector
argument_list|(
name|partNames
argument_list|,
name|partObjectInspectors
argument_list|)
expr_stmt|;
block|}
comment|// The op may not be a TableScan for mapjoins
comment|// Consider the query: select /*+MAPJOIN(a)*/ count(*) FROM T1 a JOIN T2 b ON a.key = b.key;
comment|// In that case, it will be a Select, but the rowOI need not be amended
if|if
condition|(
name|opCtx
operator|.
name|op
operator|instanceof
name|TableScanOperator
condition|)
block|{
name|TableScanOperator
name|tsOp
init|=
operator|(
name|TableScanOperator
operator|)
name|opCtx
operator|.
name|op
decl_stmt|;
name|TableScanDesc
name|tsDesc
init|=
name|tsOp
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|tsDesc
operator|!=
literal|null
operator|&&
name|tsDesc
operator|.
name|hasVirtualCols
argument_list|()
condition|)
block|{
name|opCtx
operator|.
name|vcs
operator|=
name|tsDesc
operator|.
name|getVirtualCols
argument_list|()
expr_stmt|;
name|opCtx
operator|.
name|vcValues
operator|=
operator|new
name|Object
index|[
name|opCtx
operator|.
name|vcs
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|opCtx
operator|.
name|vcsObjectInspector
operator|=
name|VirtualColumn
operator|.
name|getVCSObjectInspector
argument_list|(
name|opCtx
operator|.
name|vcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|opCtx
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
name|opCtx
operator|.
name|rowWithPartAndVC
operator|=
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|opCtx
operator|.
name|rowWithPart
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|opCtx
operator|.
name|rowWithPartAndVC
operator|=
operator|new
name|Object
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|opCtx
operator|.
name|hasVC
argument_list|()
operator|&&
operator|!
name|opCtx
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
name|opCtx
operator|.
name|rowObjectInspector
operator|=
name|tableRowOI
expr_stmt|;
return|return
name|opCtx
return|;
block|}
name|List
argument_list|<
name|StructObjectInspector
argument_list|>
name|inspectors
init|=
operator|new
name|ArrayList
argument_list|<
name|StructObjectInspector
argument_list|>
argument_list|()
decl_stmt|;
name|inspectors
operator|.
name|add
argument_list|(
name|tableRowOI
argument_list|)
expr_stmt|;
if|if
condition|(
name|opCtx
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
name|inspectors
operator|.
name|add
argument_list|(
name|opCtx
operator|.
name|partObjectInspector
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opCtx
operator|.
name|hasVC
argument_list|()
condition|)
block|{
name|inspectors
operator|.
name|add
argument_list|(
name|opCtx
operator|.
name|vcsObjectInspector
argument_list|)
expr_stmt|;
block|}
name|opCtx
operator|.
name|rowObjectInspector
operator|=
name|ObjectInspectorFactory
operator|.
name|getUnionStructObjectInspector
argument_list|(
name|inspectors
argument_list|)
expr_stmt|;
return|return
name|opCtx
return|;
block|}
comment|// Return the mapping for table descriptor to the expected table OI
comment|/**    * Traverse all the partitions for a table, and get the OI for the table.    * Note that a conversion is required if any of the partition OI is different    * from the table OI. For eg. if the query references table T (partitions P1, P2),    * and P1's schema is same as T, whereas P2's scheme is different from T, conversion    * might be needed for both P1 and P2, since SettableOI might be needed for T    */
specifier|private
name|Map
argument_list|<
name|TableDesc
argument_list|,
name|StructObjectInspector
argument_list|>
name|getConvertedOI
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Configuration
argument_list|>
name|tableToConf
parameter_list|)
throws|throws
name|HiveException
block|{
name|Map
argument_list|<
name|TableDesc
argument_list|,
name|StructObjectInspector
argument_list|>
name|tableDescOI
init|=
operator|new
name|HashMap
argument_list|<
name|TableDesc
argument_list|,
name|StructObjectInspector
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|TableDesc
argument_list|>
name|identityConverterTableDesc
init|=
operator|new
name|HashSet
argument_list|<
name|TableDesc
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|Map
argument_list|<
name|ObjectInspector
argument_list|,
name|Boolean
argument_list|>
name|oiSettableProperties
init|=
operator|new
name|HashMap
argument_list|<
name|ObjectInspector
argument_list|,
name|Boolean
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Path
name|onefile
range|:
name|conf
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|keySet
argument_list|()
control|)
block|{
name|PartitionDesc
name|pd
init|=
name|conf
operator|.
name|getPathToPartitionInfo
argument_list|()
operator|.
name|get
argument_list|(
name|onefile
argument_list|)
decl_stmt|;
name|TableDesc
name|tableDesc
init|=
name|pd
operator|.
name|getTableDesc
argument_list|()
decl_stmt|;
name|Configuration
name|hconf
init|=
name|tableToConf
operator|.
name|get
argument_list|(
name|tableDesc
operator|.
name|getTableName
argument_list|()
argument_list|)
decl_stmt|;
name|Deserializer
name|partDeserializer
init|=
name|pd
operator|.
name|getDeserializer
argument_list|(
name|hconf
argument_list|)
decl_stmt|;
name|StructObjectInspector
name|partRawRowObjectInspector
decl_stmt|;
name|boolean
name|isAcid
init|=
name|AcidUtils
operator|.
name|isTablePropertyTransactional
argument_list|(
name|tableDesc
operator|.
name|getProperties
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|Utilities
operator|.
name|isSchemaEvolutionEnabled
argument_list|(
name|hconf
argument_list|,
name|isAcid
argument_list|)
operator|&&
name|Utilities
operator|.
name|isInputFileFormatSelfDescribing
argument_list|(
name|pd
argument_list|)
condition|)
block|{
name|Deserializer
name|tblDeserializer
init|=
name|tableDesc
operator|.
name|getDeserializer
argument_list|(
name|hconf
argument_list|)
decl_stmt|;
name|partRawRowObjectInspector
operator|=
operator|(
name|StructObjectInspector
operator|)
name|tblDeserializer
operator|.
name|getObjectInspector
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|partRawRowObjectInspector
operator|=
operator|(
name|StructObjectInspector
operator|)
name|partDeserializer
operator|.
name|getObjectInspector
argument_list|()
expr_stmt|;
block|}
name|StructObjectInspector
name|tblRawRowObjectInspector
init|=
name|tableDescOI
operator|.
name|get
argument_list|(
name|tableDesc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|tblRawRowObjectInspector
operator|==
literal|null
operator|)
operator|||
operator|(
name|identityConverterTableDesc
operator|.
name|contains
argument_list|(
name|tableDesc
argument_list|)
operator|)
condition|)
block|{
name|Deserializer
name|tblDeserializer
init|=
name|tableDesc
operator|.
name|getDeserializer
argument_list|(
name|hconf
argument_list|)
decl_stmt|;
name|tblRawRowObjectInspector
operator|=
operator|(
name|StructObjectInspector
operator|)
name|ObjectInspectorConverters
operator|.
name|getConvertedOI
argument_list|(
name|partRawRowObjectInspector
argument_list|,
name|tblDeserializer
operator|.
name|getObjectInspector
argument_list|()
argument_list|,
name|oiSettableProperties
argument_list|)
expr_stmt|;
if|if
condition|(
name|identityConverterTableDesc
operator|.
name|contains
argument_list|(
name|tableDesc
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|partRawRowObjectInspector
operator|.
name|equals
argument_list|(
name|tblRawRowObjectInspector
argument_list|)
condition|)
block|{
name|identityConverterTableDesc
operator|.
name|remove
argument_list|(
name|tableDesc
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|partRawRowObjectInspector
operator|.
name|equals
argument_list|(
name|tblRawRowObjectInspector
argument_list|)
condition|)
block|{
name|identityConverterTableDesc
operator|.
name|add
argument_list|(
name|tableDesc
argument_list|)
expr_stmt|;
block|}
name|tableDescOI
operator|.
name|put
argument_list|(
name|tableDesc
argument_list|,
name|tblRawRowObjectInspector
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|tableDescOI
return|;
block|}
comment|/**    * For each source table, combine the nested column pruning information from all its    * table scan descriptors and set it in a configuration copy. This is necessary since    * the configuration property "READ_NESTED_COLUMN_PATH_CONF_STR" is set on a per-table    * basis, so we can't just use a single configuration for all the tables.    */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Configuration
argument_list|>
name|cloneConfsForNestedColPruning
parameter_list|(
name|Configuration
name|hconf
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Configuration
argument_list|>
name|tableNameToConf
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Path
argument_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|e
range|:
name|conf
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|aliases
operator|==
literal|null
operator|||
name|aliases
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|String
name|tableName
init|=
name|conf
operator|.
name|getPathToPartitionInfo
argument_list|()
operator|.
name|get
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|getTableName
argument_list|()
decl_stmt|;
if|if
condition|(
name|tableNameToConf
operator|.
name|containsKey
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|String
name|alias
range|:
name|aliases
control|)
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|rootOp
init|=
name|conf
operator|.
name|getAliasToWork
argument_list|()
operator|.
name|get
argument_list|(
name|alias
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|rootOp
operator|instanceof
name|TableScanOperator
operator|)
condition|)
block|{
continue|continue;
block|}
name|TableScanDesc
name|tableScanDesc
init|=
operator|(
operator|(
name|TableScanOperator
operator|)
name|rootOp
operator|)
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|nestedColumnPaths
init|=
name|tableScanDesc
operator|.
name|getNeededNestedColumnPaths
argument_list|()
decl_stmt|;
if|if
condition|(
name|nestedColumnPaths
operator|==
literal|null
operator|||
name|nestedColumnPaths
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|tableNameToConf
operator|.
name|containsKey
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|Configuration
name|clonedConf
init|=
operator|new
name|Configuration
argument_list|(
name|hconf
argument_list|)
decl_stmt|;
name|clonedConf
operator|.
name|unset
argument_list|(
name|ColumnProjectionUtils
operator|.
name|READ_NESTED_COLUMN_PATH_CONF_STR
argument_list|)
expr_stmt|;
name|tableNameToConf
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|clonedConf
argument_list|)
expr_stmt|;
block|}
name|Configuration
name|newConf
init|=
name|tableNameToConf
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|ColumnProjectionUtils
operator|.
name|appendNestedColumnPaths
argument_list|(
name|newConf
argument_list|,
name|nestedColumnPaths
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Assign tables without nested column pruning info to the default conf
for|for
control|(
name|PartitionDesc
name|pd
range|:
name|conf
operator|.
name|getPathToPartitionInfo
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|tableNameToConf
operator|.
name|containsKey
argument_list|(
name|pd
operator|.
name|getTableName
argument_list|()
argument_list|)
condition|)
block|{
name|tableNameToConf
operator|.
name|put
argument_list|(
name|pd
operator|.
name|getTableName
argument_list|()
argument_list|,
name|hconf
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|PartitionDesc
name|pd
range|:
name|conf
operator|.
name|getAliasToPartnInfo
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|tableNameToConf
operator|.
name|containsKey
argument_list|(
name|pd
operator|.
name|getTableName
argument_list|()
argument_list|)
condition|)
block|{
name|tableNameToConf
operator|.
name|put
argument_list|(
name|pd
operator|.
name|getTableName
argument_list|()
argument_list|,
name|hconf
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tableNameToConf
return|;
block|}
comment|/*    * This is the same as the setChildren method below but for empty tables.    * It takes care of the following:    * 1. Create the right object inspector.    * 2. Set up the childrenOpToOI with the object inspector.    * So as to ensure that the initialization happens correctly.    */
specifier|public
name|void
name|initEmptyInputChildren
parameter_list|(
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|children
parameter_list|,
name|Configuration
name|hconf
parameter_list|)
throws|throws
name|SerDeException
throws|,
name|Exception
block|{
name|setChildOperators
argument_list|(
name|children
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Configuration
argument_list|>
name|tableNameToConf
init|=
name|cloneConfsForNestedColPruning
argument_list|(
name|hconf
argument_list|)
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|child
range|:
name|children
control|)
block|{
name|TableScanOperator
name|tsOp
init|=
operator|(
name|TableScanOperator
operator|)
name|child
decl_stmt|;
name|StructObjectInspector
name|soi
init|=
literal|null
decl_stmt|;
name|PartitionDesc
name|partDesc
init|=
name|conf
operator|.
name|getAliasToPartnInfo
argument_list|()
operator|.
name|get
argument_list|(
name|tsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|)
decl_stmt|;
name|Configuration
name|newConf
init|=
name|tableNameToConf
operator|.
name|get
argument_list|(
name|partDesc
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getTableName
argument_list|()
argument_list|)
decl_stmt|;
name|Deserializer
name|serde
init|=
name|partDesc
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getDeserializer
argument_list|()
decl_stmt|;
name|partDesc
operator|.
name|setProperties
argument_list|(
name|partDesc
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
name|MapOpCtx
name|opCtx
init|=
operator|new
name|MapOpCtx
argument_list|(
name|tsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|child
argument_list|,
name|partDesc
argument_list|)
decl_stmt|;
name|StructObjectInspector
name|tableRowOI
init|=
operator|(
name|StructObjectInspector
operator|)
name|serde
operator|.
name|getObjectInspector
argument_list|()
decl_stmt|;
name|initObjectInspector
argument_list|(
name|newConf
argument_list|,
name|opCtx
argument_list|,
name|tableRowOI
argument_list|)
expr_stmt|;
name|soi
operator|=
name|opCtx
operator|.
name|rowObjectInspector
expr_stmt|;
name|child
operator|.
name|getParentOperators
argument_list|()
operator|.
name|add
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|childrenOpToOI
operator|.
name|put
argument_list|(
name|child
argument_list|,
name|soi
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|setChildren
parameter_list|(
name|Configuration
name|hconf
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Configuration
argument_list|>
name|tableNameToConf
init|=
name|cloneConfsForNestedColPruning
argument_list|(
name|hconf
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|TableDesc
argument_list|,
name|StructObjectInspector
argument_list|>
name|convertedOI
init|=
name|getConvertedOI
argument_list|(
name|tableNameToConf
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Path
argument_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|conf
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Path
name|onefile
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|PartitionDesc
name|partDesc
init|=
name|conf
operator|.
name|getPathToPartitionInfo
argument_list|()
operator|.
name|get
argument_list|(
name|onefile
argument_list|)
decl_stmt|;
name|TableDesc
name|tableDesc
init|=
name|partDesc
operator|.
name|getTableDesc
argument_list|()
decl_stmt|;
name|Configuration
name|newConf
init|=
name|tableNameToConf
operator|.
name|get
argument_list|(
name|tableDesc
operator|.
name|getTableName
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|alias
range|:
name|aliases
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
name|conf
operator|.
name|getAliasToWork
argument_list|()
operator|.
name|get
argument_list|(
name|alias
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding alias "
operator|+
name|alias
operator|+
literal|" to work list for file "
operator|+
name|onefile
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|MapOpCtx
argument_list|>
name|contexts
init|=
name|opCtxMap
operator|.
name|computeIfAbsent
argument_list|(
name|onefile
argument_list|,
name|k
lambda|->
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|contexts
operator|.
name|containsKey
argument_list|(
name|op
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|MapOpCtx
name|context
init|=
operator|new
name|MapOpCtx
argument_list|(
name|alias
argument_list|,
name|op
argument_list|,
name|partDesc
argument_list|)
decl_stmt|;
name|StructObjectInspector
name|tableRowOI
init|=
name|convertedOI
operator|.
name|get
argument_list|(
name|partDesc
operator|.
name|getTableDesc
argument_list|()
argument_list|)
decl_stmt|;
name|contexts
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|initObjectInspector
argument_list|(
name|newConf
argument_list|,
name|context
argument_list|,
name|tableRowOI
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|children
operator|.
name|contains
argument_list|(
name|op
argument_list|)
operator|==
literal|false
condition|)
block|{
name|op
operator|.
name|setParentOperators
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|add
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|children
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|initOperatorContext
argument_list|(
name|children
argument_list|)
expr_stmt|;
comment|// we found all the operators that we are supposed to process.
name|setChildOperators
argument_list|(
name|children
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|initOperatorContext
parameter_list|(
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|children
parameter_list|)
throws|throws
name|HiveException
block|{
for|for
control|(
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|MapOpCtx
argument_list|>
name|contexts
range|:
name|opCtxMap
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|MapOpCtx
name|context
range|:
name|contexts
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|children
operator|.
name|contains
argument_list|(
name|context
operator|.
name|op
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|StructObjectInspector
name|prev
init|=
name|childrenOpToOI
operator|.
name|put
argument_list|(
name|context
operator|.
name|op
argument_list|,
name|context
operator|.
name|rowObjectInspector
argument_list|)
decl_stmt|;
if|if
condition|(
name|prev
operator|!=
literal|null
operator|&&
operator|!
name|prev
operator|.
name|equals
argument_list|(
name|context
operator|.
name|rowObjectInspector
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Conflict on row inspector for "
operator|+
name|context
operator|.
name|alias
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"dump "
operator|+
name|context
operator|.
name|op
operator|+
literal|" "
operator|+
name|context
operator|.
name|rowObjectInspector
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** Kryo ctor. */
specifier|protected
name|MapOperator
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
specifier|public
name|MapOperator
parameter_list|(
name|CompilationOpContext
name|ctx
parameter_list|)
block|{
name|super
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|initializeOp
parameter_list|(
name|Configuration
name|hconf
parameter_list|)
throws|throws
name|HiveException
block|{
name|super
operator|.
name|initializeOp
argument_list|(
name|hconf
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|initializeMapOperator
parameter_list|(
name|Configuration
name|hconf
parameter_list|)
throws|throws
name|HiveException
block|{
name|super
operator|.
name|initializeMapOperator
argument_list|(
name|hconf
argument_list|)
expr_stmt|;
name|cntr
operator|=
literal|1
expr_stmt|;
name|logEveryNRows
operator|=
name|HiveConf
operator|.
name|getLongVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_LOG_N_RECORDS
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|StructObjectInspector
argument_list|>
name|entry
range|:
name|childrenOpToOI
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|child
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|child
operator|.
name|initialize
argument_list|(
name|hconf
argument_list|,
operator|new
name|ObjectInspector
index|[]
block|{
name|entry
operator|.
name|getValue
argument_list|()
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Find context for current input file
annotation|@
name|Override
specifier|public
name|void
name|cleanUpInputFileChangedOp
parameter_list|()
throws|throws
name|HiveException
block|{
name|super
operator|.
name|cleanUpInputFileChangedOp
argument_list|()
expr_stmt|;
name|Path
name|fpath
init|=
name|getExecContext
argument_list|()
operator|.
name|getCurrentInputPath
argument_list|()
decl_stmt|;
name|Path
name|nominalPath
init|=
name|getNominalPath
argument_list|(
name|fpath
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|MapOpCtx
argument_list|>
name|contexts
init|=
name|opCtxMap
operator|.
name|get
argument_list|(
name|nominalPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|MapOpCtx
name|context
range|:
name|contexts
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|builder
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|append
argument_list|(
name|context
operator|.
name|alias
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processing alias(es) "
operator|+
name|builder
operator|.
name|toString
argument_list|()
operator|+
literal|" for file "
operator|+
name|fpath
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Add alias, table name, and partitions to hadoop conf so that their
comment|// children will inherit these
for|for
control|(
name|Entry
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|MapOpCtx
argument_list|>
name|entry
range|:
name|contexts
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|operator
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|MapOpCtx
name|context
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|operator
operator|.
name|setInputContext
argument_list|(
name|context
operator|.
name|tableName
argument_list|,
name|context
operator|.
name|partName
argument_list|)
expr_stmt|;
block|}
name|currentCtxs
operator|=
name|contexts
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|MapOpCtx
index|[
name|contexts
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|process
parameter_list|(
name|Writable
name|value
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// A mapper can span multiple files/partitions.
comment|// The serializers need to be reset if the input file changed
name|ExecMapperContext
name|context
init|=
name|getExecContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
operator|!=
literal|null
operator|&&
name|context
operator|.
name|inputFileChanged
argument_list|()
condition|)
block|{
comment|// The child operators cleanup if input file has changed
name|cleanUpInputFileChanged
argument_list|()
expr_stmt|;
block|}
name|int
name|childrenDone
init|=
literal|0
decl_stmt|;
for|for
control|(
name|MapOpCtx
name|current
range|:
name|currentCtxs
control|)
block|{
name|Object
name|row
init|=
literal|null
decl_stmt|;
try|try
block|{
name|row
operator|=
name|current
operator|.
name|readRow
argument_list|(
name|value
argument_list|,
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current
operator|.
name|forward
argument_list|(
name|row
argument_list|)
condition|)
block|{
name|childrenDone
operator|++
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// TODO: policy on deserialization errors
name|String
name|message
init|=
literal|null
decl_stmt|;
try|try
block|{
name|message
operator|=
name|toErrorMessage
argument_list|(
name|value
argument_list|,
name|row
argument_list|,
name|current
operator|.
name|rowObjectInspector
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|message
operator|=
literal|"["
operator|+
name|row
operator|+
literal|", "
operator|+
name|value
operator|+
literal|"]: cannot get error message "
operator|+
name|t
operator|.
name|getMessage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|row
operator|==
literal|null
condition|)
block|{
name|deserialize_error_count
operator|.
name|set
argument_list|(
name|deserialize_error_count
operator|.
name|get
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Hive Runtime Error while processing writable "
operator|+
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Hive Runtime Error while processing writable"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// Log the contents of the row that caused exception so that it's available for debugging. But
comment|// when exposed through an error message it can leak sensitive information, even to the
comment|// client application.
name|LOG
operator|.
name|trace
argument_list|(
literal|"Hive Runtime Error while processing row "
operator|+
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Hive Runtime Error while processing row"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|rowsForwarded
argument_list|(
name|childrenDone
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|final
name|void
name|rowsForwarded
parameter_list|(
name|int
name|childrenDone
parameter_list|,
name|int
name|rows
parameter_list|)
block|{
name|numRows
operator|+=
name|rows
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
while|while
condition|(
name|numRows
operator|>=
name|cntr
condition|)
block|{
name|cntr
operator|=
name|logEveryNRows
operator|==
literal|0
condition|?
name|cntr
operator|*
literal|10
else|:
name|numRows
operator|+
name|logEveryNRows
expr_stmt|;
if|if
condition|(
name|cntr
operator|<
literal|0
operator|||
name|numRows
operator|<
literal|0
condition|)
block|{
name|cntr
operator|=
literal|1
expr_stmt|;
name|numRows
operator|=
literal|0
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|toString
argument_list|()
operator|+
literal|": records read - "
operator|+
name|numRows
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|childrenDone
operator|==
name|currentCtxs
operator|.
name|length
condition|)
block|{
name|setDone
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|String
name|toErrorMessage
parameter_list|(
name|Writable
name|value
parameter_list|,
name|Object
name|row
parameter_list|,
name|ObjectInspector
name|inspector
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|row
operator|!=
literal|null
condition|)
block|{
return|return
name|SerDeUtils
operator|.
name|getJSONString
argument_list|(
name|row
argument_list|,
name|inspector
argument_list|)
return|;
block|}
return|return
name|String
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
literal|"[Error getting row data with exception "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
operator|+
literal|" ]"
return|;
block|}
block|}
specifier|public
specifier|static
name|Object
index|[]
name|populateVirtualColumnValues
parameter_list|(
name|ExecMapperContext
name|ctx
parameter_list|,
name|List
argument_list|<
name|VirtualColumn
argument_list|>
name|vcs
parameter_list|,
name|Object
index|[]
name|vcValues
parameter_list|,
name|Deserializer
name|deserializer
parameter_list|)
block|{
if|if
condition|(
name|vcs
operator|==
literal|null
condition|)
block|{
return|return
name|vcValues
return|;
block|}
if|if
condition|(
name|vcValues
operator|==
literal|null
condition|)
block|{
name|vcValues
operator|=
operator|new
name|Object
index|[
name|vcs
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vcs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|vcs
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
case|case
name|FILENAME
case|:
if|if
condition|(
name|ctx
operator|.
name|inputFileChanged
argument_list|()
condition|)
block|{
name|vcValues
index|[
name|i
index|]
operator|=
operator|new
name|Text
argument_list|(
name|ctx
operator|.
name|getCurrentInputPath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BLOCKOFFSET
case|:
block|{
name|long
name|current
init|=
name|ctx
operator|.
name|getIoCxt
argument_list|()
operator|.
name|getCurrentBlockStart
argument_list|()
decl_stmt|;
name|LongWritable
name|old
init|=
operator|(
name|LongWritable
operator|)
name|vcValues
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|old
operator|==
literal|null
condition|)
block|{
name|old
operator|=
operator|new
name|LongWritable
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|vcValues
index|[
name|i
index|]
operator|=
name|old
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|current
operator|!=
name|old
operator|.
name|get
argument_list|()
condition|)
block|{
name|old
operator|.
name|set
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ROWOFFSET
case|:
block|{
name|long
name|current
init|=
name|ctx
operator|.
name|getIoCxt
argument_list|()
operator|.
name|getCurrentRow
argument_list|()
decl_stmt|;
name|LongWritable
name|old
init|=
operator|(
name|LongWritable
operator|)
name|vcValues
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|old
operator|==
literal|null
condition|)
block|{
name|old
operator|=
operator|new
name|LongWritable
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|vcValues
index|[
name|i
index|]
operator|=
name|old
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|current
operator|!=
name|old
operator|.
name|get
argument_list|()
condition|)
block|{
name|old
operator|.
name|set
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|RAWDATASIZE
case|:
name|long
name|current
init|=
literal|0L
decl_stmt|;
name|SerDeStats
name|stats
init|=
name|deserializer
operator|.
name|getSerDeStats
argument_list|()
decl_stmt|;
if|if
condition|(
name|stats
operator|!=
literal|null
condition|)
block|{
name|current
operator|=
name|stats
operator|.
name|getRawDataSize
argument_list|()
expr_stmt|;
block|}
name|LongWritable
name|old
init|=
operator|(
name|LongWritable
operator|)
name|vcValues
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|old
operator|==
literal|null
condition|)
block|{
name|old
operator|=
operator|new
name|LongWritable
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|vcValues
index|[
name|i
index|]
operator|=
name|old
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|current
operator|!=
name|old
operator|.
name|get
argument_list|()
condition|)
block|{
name|old
operator|.
name|set
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ROWID
case|:
if|if
condition|(
name|ctx
operator|.
name|getIoCxt
argument_list|()
operator|.
name|getRecordIdentifier
argument_list|()
operator|==
literal|null
condition|)
block|{
name|vcValues
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vcValues
index|[
name|i
index|]
operator|==
literal|null
condition|)
block|{
name|vcValues
index|[
name|i
index|]
operator|=
operator|new
name|Object
index|[
name|RecordIdentifier
operator|.
name|Field
operator|.
name|values
argument_list|()
operator|.
name|length
index|]
expr_stmt|;
block|}
name|RecordIdentifier
operator|.
name|StructInfo
operator|.
name|toArray
argument_list|(
name|ctx
operator|.
name|getIoCxt
argument_list|()
operator|.
name|getRecordIdentifier
argument_list|()
argument_list|,
operator|(
name|Object
index|[]
operator|)
name|vcValues
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|getIoCxt
argument_list|()
operator|.
name|setRecordIdentifier
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|//so we don't accidentally cache the value; shouldn't
comment|//happen since IO layer either knows how to produce ROW__ID or not - but to be safe
block|}
break|break;
block|}
block|}
return|return
name|vcValues
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|closeOp
parameter_list|(
name|boolean
name|abort
parameter_list|)
throws|throws
name|HiveException
block|{
name|super
operator|.
name|closeOp
argument_list|(
name|abort
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{}: Total records read - {}. abort - {}"
argument_list|,
name|this
argument_list|,
name|numRows
argument_list|,
name|abort
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|process
parameter_list|(
name|Object
name|row
parameter_list|,
name|int
name|tag
parameter_list|)
throws|throws
name|HiveException
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Hive 2 Internal error: should not be called!"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|MapOperator
operator|.
name|getOperatorName
argument_list|()
return|;
block|}
specifier|static
specifier|public
name|String
name|getOperatorName
parameter_list|()
block|{
return|return
literal|"MAP"
return|;
block|}
annotation|@
name|Override
specifier|public
name|OperatorType
name|getType
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
specifier|public
name|void
name|initializeContexts
parameter_list|()
block|{
name|Path
name|fpath
init|=
name|getExecContext
argument_list|()
operator|.
name|getCurrentInputPath
argument_list|()
decl_stmt|;
name|Path
name|nominalPath
init|=
name|getNominalPath
argument_list|(
name|fpath
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|MapOpCtx
argument_list|>
name|contexts
init|=
name|opCtxMap
operator|.
name|get
argument_list|(
name|nominalPath
argument_list|)
decl_stmt|;
name|currentCtxs
operator|=
name|contexts
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|MapOpCtx
index|[
name|contexts
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Deserializer
name|getCurrentDeserializer
parameter_list|()
block|{
return|return
name|currentCtxs
index|[
literal|0
index|]
operator|.
name|deserializer
return|;
block|}
block|}
end_class

end_unit

