begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|constraint
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|TokenRewriteStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|Tree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLCheckConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLDefaultConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLForeignKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLNotNullConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLPrimaryKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLUniqueConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ErrorMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ASTNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|BaseSemanticAnalyzer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ParseDriver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|RowResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|TypeCheckCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|TypeCheckProcFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|UnparseTranslator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|serdeConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_comment
comment|/**  * Utilities for constraints.  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|ConstraintsUtils
block|{
specifier|private
name|ConstraintsUtils
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"ConstraintsUtils should not be instantiated!"
argument_list|)
throw|;
block|}
specifier|private
specifier|static
class|class
name|ConstraintInfo
block|{
specifier|final
name|String
name|colName
decl_stmt|;
specifier|final
name|String
name|constraintName
decl_stmt|;
specifier|final
name|boolean
name|enable
decl_stmt|;
specifier|final
name|boolean
name|validate
decl_stmt|;
specifier|final
name|boolean
name|rely
decl_stmt|;
specifier|final
name|String
name|defaultValue
decl_stmt|;
name|ConstraintInfo
parameter_list|(
name|String
name|colName
parameter_list|,
name|String
name|constraintName
parameter_list|,
name|boolean
name|enable
parameter_list|,
name|boolean
name|validate
parameter_list|,
name|boolean
name|rely
parameter_list|,
name|String
name|defaultValue
parameter_list|)
block|{
name|this
operator|.
name|colName
operator|=
name|colName
expr_stmt|;
name|this
operator|.
name|constraintName
operator|=
name|constraintName
expr_stmt|;
name|this
operator|.
name|enable
operator|=
name|enable
expr_stmt|;
name|this
operator|.
name|validate
operator|=
name|validate
expr_stmt|;
name|this
operator|.
name|rely
operator|=
name|rely
expr_stmt|;
name|this
operator|.
name|defaultValue
operator|=
name|defaultValue
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|void
name|processPrimaryKeys
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|ASTNode
name|child
parameter_list|,
name|List
argument_list|<
name|SQLPrimaryKey
argument_list|>
name|primaryKeys
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|primaryKeyInfos
init|=
name|generateConstraintInfos
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|constraintInfosToPrimaryKeys
argument_list|(
name|tableName
argument_list|,
name|primaryKeyInfos
argument_list|,
name|primaryKeys
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|processPrimaryKeys
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|ASTNode
name|child
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|columnNames
parameter_list|,
name|List
argument_list|<
name|SQLPrimaryKey
argument_list|>
name|primaryKeys
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|primaryKeyInfos
init|=
name|generateConstraintInfos
argument_list|(
name|child
argument_list|,
name|columnNames
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|constraintInfosToPrimaryKeys
argument_list|(
name|tableName
argument_list|,
name|primaryKeyInfos
argument_list|,
name|primaryKeys
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|constraintInfosToPrimaryKeys
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|primaryKeyInfos
parameter_list|,
name|List
argument_list|<
name|SQLPrimaryKey
argument_list|>
name|primaryKeys
parameter_list|)
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
for|for
control|(
name|ConstraintInfo
name|primaryKeyInfo
range|:
name|primaryKeyInfos
control|)
block|{
name|primaryKeys
operator|.
name|add
argument_list|(
operator|new
name|SQLPrimaryKey
argument_list|(
name|tableName
operator|.
name|getDb
argument_list|()
argument_list|,
name|tableName
operator|.
name|getTable
argument_list|()
argument_list|,
name|primaryKeyInfo
operator|.
name|colName
argument_list|,
name|i
operator|++
argument_list|,
name|primaryKeyInfo
operator|.
name|constraintName
argument_list|,
name|primaryKeyInfo
operator|.
name|enable
argument_list|,
name|primaryKeyInfo
operator|.
name|validate
argument_list|,
name|primaryKeyInfo
operator|.
name|rely
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Process the unique constraints from the ast node and populate the SQLUniqueConstraint list.    */
specifier|public
specifier|static
name|void
name|processUniqueConstraints
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|ASTNode
name|child
parameter_list|,
name|List
argument_list|<
name|SQLUniqueConstraint
argument_list|>
name|uniqueConstraints
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|uniqueInfos
init|=
name|generateConstraintInfos
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|constraintInfosToUniqueConstraints
argument_list|(
name|tableName
argument_list|,
name|uniqueInfos
argument_list|,
name|uniqueConstraints
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|processUniqueConstraints
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|ASTNode
name|child
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|columnNames
parameter_list|,
name|List
argument_list|<
name|SQLUniqueConstraint
argument_list|>
name|uniqueConstraints
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|uniqueInfos
init|=
name|generateConstraintInfos
argument_list|(
name|child
argument_list|,
name|columnNames
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|constraintInfosToUniqueConstraints
argument_list|(
name|tableName
argument_list|,
name|uniqueInfos
argument_list|,
name|uniqueConstraints
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|constraintInfosToUniqueConstraints
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|uniqueInfos
parameter_list|,
name|List
argument_list|<
name|SQLUniqueConstraint
argument_list|>
name|uniqueConstraints
parameter_list|)
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
for|for
control|(
name|ConstraintInfo
name|uniqueInfo
range|:
name|uniqueInfos
control|)
block|{
name|uniqueConstraints
operator|.
name|add
argument_list|(
operator|new
name|SQLUniqueConstraint
argument_list|(
name|tableName
operator|.
name|getCat
argument_list|()
argument_list|,
name|tableName
operator|.
name|getDb
argument_list|()
argument_list|,
name|tableName
operator|.
name|getTable
argument_list|()
argument_list|,
name|uniqueInfo
operator|.
name|colName
argument_list|,
name|i
operator|++
argument_list|,
name|uniqueInfo
operator|.
name|constraintName
argument_list|,
name|uniqueInfo
operator|.
name|enable
argument_list|,
name|uniqueInfo
operator|.
name|validate
argument_list|,
name|uniqueInfo
operator|.
name|rely
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|void
name|processCheckConstraints
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|ASTNode
name|child
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|columnNames
parameter_list|,
name|List
argument_list|<
name|SQLCheckConstraint
argument_list|>
name|checkConstraints
parameter_list|,
specifier|final
name|ASTNode
name|typeChild
parameter_list|,
specifier|final
name|TokenRewriteStream
name|tokenRewriteStream
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|checkInfos
init|=
name|generateConstraintInfos
argument_list|(
name|child
argument_list|,
name|columnNames
argument_list|,
name|typeChild
argument_list|,
name|tokenRewriteStream
argument_list|)
decl_stmt|;
name|constraintInfosToCheckConstraints
argument_list|(
name|tableName
argument_list|,
name|checkInfos
argument_list|,
name|checkConstraints
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|constraintInfosToCheckConstraints
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|checkInfos
parameter_list|,
name|List
argument_list|<
name|SQLCheckConstraint
argument_list|>
name|checkConstraints
parameter_list|)
block|{
for|for
control|(
name|ConstraintInfo
name|checkInfo
range|:
name|checkInfos
control|)
block|{
name|checkConstraints
operator|.
name|add
argument_list|(
operator|new
name|SQLCheckConstraint
argument_list|(
name|tableName
operator|.
name|getCat
argument_list|()
argument_list|,
name|tableName
operator|.
name|getDb
argument_list|()
argument_list|,
name|tableName
operator|.
name|getTable
argument_list|()
argument_list|,
name|checkInfo
operator|.
name|colName
argument_list|,
name|checkInfo
operator|.
name|defaultValue
argument_list|,
name|checkInfo
operator|.
name|constraintName
argument_list|,
name|checkInfo
operator|.
name|enable
argument_list|,
name|checkInfo
operator|.
name|validate
argument_list|,
name|checkInfo
operator|.
name|rely
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|void
name|processDefaultConstraints
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|ASTNode
name|child
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|columnNames
parameter_list|,
name|List
argument_list|<
name|SQLDefaultConstraint
argument_list|>
name|defaultConstraints
parameter_list|,
specifier|final
name|ASTNode
name|typeChild
parameter_list|,
name|TokenRewriteStream
name|tokenRewriteStream
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|defaultInfos
init|=
name|generateConstraintInfos
argument_list|(
name|child
argument_list|,
name|columnNames
argument_list|,
name|typeChild
argument_list|,
name|tokenRewriteStream
argument_list|)
decl_stmt|;
name|constraintInfosToDefaultConstraints
argument_list|(
name|tableName
argument_list|,
name|defaultInfos
argument_list|,
name|defaultConstraints
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|constraintInfosToDefaultConstraints
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|defaultInfos
parameter_list|,
name|List
argument_list|<
name|SQLDefaultConstraint
argument_list|>
name|defaultConstraints
parameter_list|)
block|{
for|for
control|(
name|ConstraintInfo
name|defaultInfo
range|:
name|defaultInfos
control|)
block|{
name|defaultConstraints
operator|.
name|add
argument_list|(
operator|new
name|SQLDefaultConstraint
argument_list|(
name|tableName
operator|.
name|getCat
argument_list|()
argument_list|,
name|tableName
operator|.
name|getDb
argument_list|()
argument_list|,
name|tableName
operator|.
name|getTable
argument_list|()
argument_list|,
name|defaultInfo
operator|.
name|colName
argument_list|,
name|defaultInfo
operator|.
name|defaultValue
argument_list|,
name|defaultInfo
operator|.
name|constraintName
argument_list|,
name|defaultInfo
operator|.
name|enable
argument_list|,
name|defaultInfo
operator|.
name|validate
argument_list|,
name|defaultInfo
operator|.
name|rely
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|void
name|processNotNullConstraints
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|ASTNode
name|child
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|columnNames
parameter_list|,
name|List
argument_list|<
name|SQLNotNullConstraint
argument_list|>
name|notNullConstraints
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|notNullInfos
init|=
name|generateConstraintInfos
argument_list|(
name|child
argument_list|,
name|columnNames
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|constraintInfosToNotNullConstraints
argument_list|(
name|tableName
argument_list|,
name|notNullInfos
argument_list|,
name|notNullConstraints
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|constraintInfosToNotNullConstraints
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|notNullInfos
parameter_list|,
name|List
argument_list|<
name|SQLNotNullConstraint
argument_list|>
name|notNullConstraints
parameter_list|)
block|{
for|for
control|(
name|ConstraintInfo
name|notNullInfo
range|:
name|notNullInfos
control|)
block|{
name|notNullConstraints
operator|.
name|add
argument_list|(
operator|new
name|SQLNotNullConstraint
argument_list|(
name|tableName
operator|.
name|getCat
argument_list|()
argument_list|,
name|tableName
operator|.
name|getDb
argument_list|()
argument_list|,
name|tableName
operator|.
name|getTable
argument_list|()
argument_list|,
name|notNullInfo
operator|.
name|colName
argument_list|,
name|notNullInfo
operator|.
name|constraintName
argument_list|,
name|notNullInfo
operator|.
name|enable
argument_list|,
name|notNullInfo
operator|.
name|validate
argument_list|,
name|notNullInfo
operator|.
name|rely
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get the constraint from the AST and populate the cstrInfos with the required information.    */
specifier|private
specifier|static
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|generateConstraintInfos
parameter_list|(
name|ASTNode
name|child
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|String
argument_list|>
name|columnNames
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChildCount
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|Tree
name|columnName
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|BaseSemanticAnalyzer
operator|.
name|checkColumnName
argument_list|(
name|columnName
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|columnNames
operator|.
name|add
argument_list|(
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|columnName
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|generateConstraintInfos
argument_list|(
name|child
argument_list|,
name|columnNames
operator|.
name|build
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|private
specifier|static
specifier|final
name|int
name|CONSTRAINT_MAX_LENGTH
init|=
literal|255
decl_stmt|;
comment|/**    * Get the constraint from the AST and populate the cstrInfos with the required information.    * @param child  The node with the constraint token    * @param columnNames The name of the columns for the primary key    * @param typeChildForDefault type of column used for default value type check    */
specifier|private
specifier|static
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|generateConstraintInfos
parameter_list|(
name|ASTNode
name|child
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|columnNames
parameter_list|,
name|ASTNode
name|typeChildForDefault
parameter_list|,
name|TokenRewriteStream
name|tokenRewriteStream
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// The ANTLR grammar looks like :
comment|// 1. KW_CONSTRAINT idfr=identifier KW_PRIMARY KW_KEY pkCols=columnParenthesesList
comment|//  constraintOptsCreate?
comment|// -> ^(TOK_PRIMARY_KEY $pkCols $idfr constraintOptsCreate?)
comment|// when the user specifies the constraint name.
comment|// 2.  KW_PRIMARY KW_KEY columnParenthesesList
comment|// constraintOptsCreate?
comment|// -> ^(TOK_PRIMARY_KEY columnParenthesesList constraintOptsCreate?)
comment|// when the user does not specify the constraint name.
comment|// Default values
name|String
name|constraintName
init|=
literal|null
decl_stmt|;
comment|//by default if user hasn't provided any optional constraint properties
comment|// it will be considered ENABLE and NOVALIDATE and RELY=true
name|boolean
name|enable
init|=
literal|true
decl_stmt|;
name|boolean
name|validate
init|=
literal|false
decl_stmt|;
name|boolean
name|rely
init|=
literal|true
decl_stmt|;
name|String
name|checkOrDefaultValue
init|=
literal|null
decl_stmt|;
name|int
name|childType
init|=
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|child
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|grandChild
init|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|type
init|=
name|grandChild
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_CONSTRAINT_NAME
condition|)
block|{
name|constraintName
operator|=
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|grandChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_ENABLE
condition|)
block|{
name|enable
operator|=
literal|true
expr_stmt|;
comment|// validate is false by default if we enable the constraint
comment|// TODO: A constraint like NOT NULL could be enabled using ALTER but VALIDATE remains
comment|//  false in such cases. Ideally VALIDATE should be set to true to validate existing data
name|validate
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_DISABLE
condition|)
block|{
name|enable
operator|=
literal|false
expr_stmt|;
comment|// validate is false by default if we disable the constraint
name|validate
operator|=
literal|false
expr_stmt|;
name|rely
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_VALIDATE
condition|)
block|{
name|validate
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_NOVALIDATE
condition|)
block|{
name|validate
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_RELY
condition|)
block|{
name|rely
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_NORELY
condition|)
block|{
name|rely
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|childType
operator|==
name|HiveParser
operator|.
name|TOK_DEFAULT_VALUE
condition|)
block|{
comment|// try to get default value only if this is DEFAULT constraint
name|checkOrDefaultValue
operator|=
name|getDefaultValue
argument_list|(
name|grandChild
argument_list|,
name|typeChildForDefault
argument_list|,
name|tokenRewriteStream
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|childType
operator|==
name|HiveParser
operator|.
name|TOK_CHECK_CONSTRAINT
condition|)
block|{
name|checkOrDefaultValue
operator|=
name|tokenRewriteStream
operator|.
name|toOriginalString
argument_list|(
name|grandChild
operator|.
name|getTokenStartIndex
argument_list|()
argument_list|,
name|grandChild
operator|.
name|getTokenStopIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// metastore schema only allows maximum 255 for constraint name column
if|if
condition|(
name|constraintName
operator|!=
literal|null
operator|&&
name|constraintName
operator|.
name|length
argument_list|()
operator|>
name|CONSTRAINT_MAX_LENGTH
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_CSTR_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|"Constraint name: "
operator|+
name|constraintName
operator|+
literal|" exceeded maximum allowed length: "
operator|+
name|CONSTRAINT_MAX_LENGTH
argument_list|)
argument_list|)
throw|;
block|}
comment|// metastore schema only allows maximum 255 for constraint value column
if|if
condition|(
name|checkOrDefaultValue
operator|!=
literal|null
operator|&&
name|checkOrDefaultValue
operator|.
name|length
argument_list|()
operator|>
name|CONSTRAINT_MAX_LENGTH
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_CSTR_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|"Constraint value: "
operator|+
name|checkOrDefaultValue
operator|+
literal|" exceeded maximum allowed length: "
operator|+
name|CONSTRAINT_MAX_LENGTH
argument_list|)
argument_list|)
throw|;
block|}
comment|// NOT NULL constraint could be enforced/enabled
if|if
condition|(
name|enable
operator|&&
name|childType
operator|!=
name|HiveParser
operator|.
name|TOK_NOT_NULL
operator|&&
name|childType
operator|!=
name|HiveParser
operator|.
name|TOK_DEFAULT_VALUE
operator|&&
name|childType
operator|!=
name|HiveParser
operator|.
name|TOK_CHECK_CONSTRAINT
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_CSTR_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|"ENABLE/ENFORCED feature not supported yet. "
operator|+
literal|"Please use DISABLE/NOT ENFORCED instead."
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|validate
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_CSTR_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|"VALIDATE feature not supported yet. "
operator|+
literal|"Please use NOVALIDATE instead."
argument_list|)
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|constraintInfos
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|columnNames
operator|==
literal|null
condition|)
block|{
name|constraintInfos
operator|.
name|add
argument_list|(
operator|new
name|ConstraintInfo
argument_list|(
literal|null
argument_list|,
name|constraintName
argument_list|,
name|enable
argument_list|,
name|validate
argument_list|,
name|rely
argument_list|,
name|checkOrDefaultValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|String
name|columnName
range|:
name|columnNames
control|)
block|{
name|constraintInfos
operator|.
name|add
argument_list|(
operator|new
name|ConstraintInfo
argument_list|(
name|columnName
argument_list|,
name|constraintName
argument_list|,
name|enable
argument_list|,
name|validate
argument_list|,
name|rely
argument_list|,
name|checkOrDefaultValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|constraintInfos
return|;
block|}
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_LEN
init|=
literal|255
decl_stmt|;
comment|/**    * Validate and get the default value from the AST.    * @param node AST node corresponding to default value    * @return retrieve the default value and return it as string    */
specifier|private
specifier|static
name|String
name|getDefaultValue
parameter_list|(
name|ASTNode
name|node
parameter_list|,
name|ASTNode
name|typeChild
parameter_list|,
name|TokenRewriteStream
name|tokenStream
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// first create expression from defaultValueAST
name|TypeCheckCtx
name|typeCheckCtx
init|=
operator|new
name|TypeCheckCtx
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|defaultValExpr
init|=
name|TypeCheckProcFactory
operator|.
name|genExprNode
argument_list|(
name|node
argument_list|,
name|typeCheckCtx
argument_list|)
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|defaultValExpr
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_CSTR_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|"Invalid Default value!"
argument_list|)
argument_list|)
throw|;
block|}
comment|//get default value to be be stored in metastore
name|String
name|defaultValueText
init|=
name|tokenStream
operator|.
name|toOriginalString
argument_list|(
name|node
operator|.
name|getTokenStartIndex
argument_list|()
argument_list|,
name|node
operator|.
name|getTokenStopIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|defaultValueText
operator|.
name|length
argument_list|()
operator|>
name|DEFAULT_MAX_LEN
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_CSTR_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|"Invalid Default value:  "
operator|+
name|defaultValueText
operator|+
literal|" .Maximum character length allowed is "
operator|+
name|DEFAULT_MAX_LEN
operator|+
literal|" ."
argument_list|)
argument_list|)
throw|;
block|}
comment|// Make sure the default value expression type is exactly same as column's type.
name|TypeInfo
name|defaultValTypeInfo
init|=
name|defaultValExpr
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|TypeInfo
name|colTypeInfo
init|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|BaseSemanticAnalyzer
operator|.
name|getTypeStringFromAST
argument_list|(
name|typeChild
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|defaultValTypeInfo
operator|.
name|equals
argument_list|(
name|colTypeInfo
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_CSTR_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|"Invalid type: "
operator|+
name|defaultValTypeInfo
operator|.
name|getTypeName
argument_list|()
operator|+
literal|" for default value: "
operator|+
name|defaultValueText
operator|+
literal|". Please make sure that "
operator|+
literal|"the type is compatible with column type: "
operator|+
name|colTypeInfo
operator|.
name|getTypeName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|// throw an error if default value isn't what hive allows
if|if
condition|(
operator|!
name|isDefaultValueAllowed
argument_list|(
name|defaultValExpr
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_CSTR_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|"Invalid Default value: "
operator|+
name|defaultValueText
operator|+
literal|". DEFAULT only allows constant or function expressions"
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|defaultValueText
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isDefaultValueAllowed
parameter_list|(
name|ExprNodeDesc
name|defaultValExpr
parameter_list|)
block|{
while|while
condition|(
name|FunctionRegistry
operator|.
name|isOpCast
argument_list|(
name|defaultValExpr
argument_list|)
condition|)
block|{
name|defaultValExpr
operator|=
name|defaultValExpr
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|defaultValExpr
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|defaultValExpr
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
for|for
control|(
name|ExprNodeDesc
name|argument
range|:
name|defaultValExpr
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|isDefaultValueAllowed
argument_list|(
name|argument
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
specifier|static
name|void
name|processForeignKeys
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|ASTNode
name|node
parameter_list|,
name|List
argument_list|<
name|SQLForeignKey
argument_list|>
name|foreignKeys
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// The ANTLR grammar looks like :
comment|// 1.  KW_CONSTRAINT idfr=identifier KW_FOREIGN KW_KEY fkCols=columnParenthesesList
comment|// KW_REFERENCES tabName=tableName parCols=columnParenthesesList
comment|// enableSpec=enableSpecification validateSpec=validateSpecification relySpec=relySpecification
comment|// -> ^(TOK_FOREIGN_KEY $idfr $fkCols $tabName $parCols $relySpec $enableSpec $validateSpec)
comment|// when the user specifies the constraint name (i.e. child.getChildCount() == 7)
comment|// 2.  KW_FOREIGN KW_KEY fkCols=columnParenthesesList
comment|// KW_REFERENCES tabName=tableName parCols=columnParenthesesList
comment|// enableSpec=enableSpecification validateSpec=validateSpecification relySpec=relySpecification
comment|// -> ^(TOK_FOREIGN_KEY $fkCols  $tabName $parCols $relySpec $enableSpec $validateSpec)
comment|// when the user does not specify the constraint name (i.e. child.getChildCount() == 6)
name|String
name|constraintName
init|=
literal|null
decl_stmt|;
name|boolean
name|enable
init|=
literal|true
decl_stmt|;
name|boolean
name|validate
init|=
literal|true
decl_stmt|;
name|boolean
name|rely
init|=
literal|false
decl_stmt|;
name|int
name|fkIndex
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|node
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|grandChild
init|=
operator|(
name|ASTNode
operator|)
name|node
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|type
init|=
name|grandChild
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_CONSTRAINT_NAME
condition|)
block|{
name|constraintName
operator|=
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|grandChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_ENABLE
condition|)
block|{
name|enable
operator|=
literal|true
expr_stmt|;
comment|// validate is true by default if we enable the constraint
name|validate
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_DISABLE
condition|)
block|{
name|enable
operator|=
literal|false
expr_stmt|;
comment|// validate is false by default if we disable the constraint
name|validate
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_VALIDATE
condition|)
block|{
name|validate
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_NOVALIDATE
condition|)
block|{
name|validate
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_RELY
condition|)
block|{
name|rely
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_TABCOLNAME
operator|&&
name|fkIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|fkIndex
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|enable
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_FK_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|"ENABLE feature not supported yet. "
operator|+
literal|"Please use DISABLE instead."
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|validate
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_FK_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|"VALIDATE feature not supported yet. "
operator|+
literal|"Please use NOVALIDATE instead."
argument_list|)
argument_list|)
throw|;
block|}
name|int
name|ptIndex
init|=
name|fkIndex
operator|+
literal|1
decl_stmt|;
name|int
name|pkIndex
init|=
name|ptIndex
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getChild
argument_list|(
name|fkIndex
argument_list|)
operator|.
name|getChildCount
argument_list|()
operator|!=
name|node
operator|.
name|getChild
argument_list|(
name|pkIndex
argument_list|)
operator|.
name|getChildCount
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_FK_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|" The number of foreign key columns should be same as number of parent key columns "
argument_list|)
argument_list|)
throw|;
block|}
name|TableName
name|parentTblName
init|=
name|BaseSemanticAnalyzer
operator|.
name|getQualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|node
operator|.
name|getChild
argument_list|(
name|ptIndex
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|node
operator|.
name|getChild
argument_list|(
name|fkIndex
argument_list|)
operator|.
name|getChildCount
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|SQLForeignKey
name|sqlForeignKey
init|=
operator|new
name|SQLForeignKey
argument_list|()
decl_stmt|;
name|sqlForeignKey
operator|.
name|setFktable_db
argument_list|(
name|tableName
operator|.
name|getDb
argument_list|()
argument_list|)
expr_stmt|;
name|sqlForeignKey
operator|.
name|setFktable_name
argument_list|(
name|tableName
operator|.
name|getTable
argument_list|()
argument_list|)
expr_stmt|;
name|Tree
name|fkgrandChild
init|=
name|node
operator|.
name|getChild
argument_list|(
name|fkIndex
argument_list|)
operator|.
name|getChild
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|BaseSemanticAnalyzer
operator|.
name|checkColumnName
argument_list|(
name|fkgrandChild
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|sqlForeignKey
operator|.
name|setFkcolumn_name
argument_list|(
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|fkgrandChild
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|sqlForeignKey
operator|.
name|setPktable_db
argument_list|(
name|parentTblName
operator|.
name|getDb
argument_list|()
argument_list|)
expr_stmt|;
name|sqlForeignKey
operator|.
name|setPktable_name
argument_list|(
name|parentTblName
operator|.
name|getTable
argument_list|()
argument_list|)
expr_stmt|;
name|Tree
name|pkgrandChild
init|=
name|node
operator|.
name|getChild
argument_list|(
name|pkIndex
argument_list|)
operator|.
name|getChild
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|sqlForeignKey
operator|.
name|setPkcolumn_name
argument_list|(
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|pkgrandChild
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|sqlForeignKey
operator|.
name|setKey_seq
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sqlForeignKey
operator|.
name|setFk_name
argument_list|(
name|constraintName
argument_list|)
expr_stmt|;
name|sqlForeignKey
operator|.
name|setEnable_cstr
argument_list|(
name|enable
argument_list|)
expr_stmt|;
name|sqlForeignKey
operator|.
name|setValidate_cstr
argument_list|(
name|validate
argument_list|)
expr_stmt|;
name|sqlForeignKey
operator|.
name|setRely_cstr
argument_list|(
name|rely
argument_list|)
expr_stmt|;
name|foreignKeys
operator|.
name|add
argument_list|(
name|sqlForeignKey
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|void
name|validateCheckConstraint
parameter_list|(
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|columns
parameter_list|,
name|List
argument_list|<
name|SQLCheckConstraint
argument_list|>
name|checkConstraints
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// create colinfo and then row resolver
name|RowResolver
name|rr
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldSchema
name|column
range|:
name|columns
control|)
block|{
name|ColumnInfo
name|ci
init|=
operator|new
name|ColumnInfo
argument_list|(
name|column
operator|.
name|getName
argument_list|()
argument_list|,
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|column
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|rr
operator|.
name|put
argument_list|(
literal|null
argument_list|,
name|column
operator|.
name|getName
argument_list|()
argument_list|,
name|ci
argument_list|)
expr_stmt|;
block|}
name|TypeCheckCtx
name|typeCheckCtx
init|=
operator|new
name|TypeCheckCtx
argument_list|(
name|rr
argument_list|)
decl_stmt|;
comment|// TypeCheckProcFactor expects typecheckctx to have unparse translator
name|UnparseTranslator
name|unparseTranslator
init|=
operator|new
name|UnparseTranslator
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|typeCheckCtx
operator|.
name|setUnparseTranslator
argument_list|(
name|unparseTranslator
argument_list|)
expr_stmt|;
for|for
control|(
name|SQLCheckConstraint
name|cc
range|:
name|checkConstraints
control|)
block|{
try|try
block|{
name|ParseDriver
name|parseDriver
init|=
operator|new
name|ParseDriver
argument_list|()
decl_stmt|;
name|ASTNode
name|checkExprAST
init|=
name|parseDriver
operator|.
name|parseExpression
argument_list|(
name|cc
operator|.
name|getCheck_expression
argument_list|()
argument_list|)
decl_stmt|;
name|validateCheckExprAST
argument_list|(
name|checkExprAST
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
name|genExprs
init|=
name|TypeCheckProcFactory
operator|.
name|genExprNode
argument_list|(
name|checkExprAST
argument_list|,
name|typeCheckCtx
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|checkExpr
init|=
name|genExprs
operator|.
name|get
argument_list|(
name|checkExprAST
argument_list|)
decl_stmt|;
if|if
condition|(
name|checkExpr
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_CSTR_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|"Invalid type for CHECK constraint: "
argument_list|)
operator|+
name|cc
operator|.
name|getCheck_expression
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|checkExpr
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|getTypeName
argument_list|()
operator|!=
name|serdeConstants
operator|.
name|BOOLEAN_TYPE_NAME
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_CSTR_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|"Only boolean type is supported for CHECK constraint: "
argument_list|)
operator|+
name|cc
operator|.
name|getCheck_expression
argument_list|()
operator|+
literal|". Found: "
operator|+
name|checkExpr
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
throw|;
block|}
name|validateCheckExpr
argument_list|(
name|checkExpr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_CSTR_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|"Invalid CHECK constraint expression: "
argument_list|)
operator|+
name|cc
operator|.
name|getCheck_expression
argument_list|()
operator|+
literal|". "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|// given an ast node this method recursively goes over checkExpr ast. If it finds a node of type TOK_SUBQUERY_EXPR
comment|// it throws an error.
comment|// This method is used to validate check expression since check expression isn't allowed to have subquery
specifier|private
specifier|static
name|void
name|validateCheckExprAST
parameter_list|(
name|ASTNode
name|checkExpr
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|checkExpr
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|checkExpr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY_EXPR
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_CSTR_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|"Subqueries are not allowed in Check Constraints"
argument_list|)
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|checkExpr
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|validateCheckExprAST
argument_list|(
operator|(
name|ASTNode
operator|)
name|checkExpr
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// recursively go through expression and make sure the following:
comment|// * If expression is UDF it is not permanent UDF
specifier|private
specifier|static
name|void
name|validateCheckExpr
parameter_list|(
name|ExprNodeDesc
name|checkExpr
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|checkExpr
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|funcDesc
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|checkExpr
decl_stmt|;
name|boolean
name|isBuiltIn
init|=
name|FunctionRegistry
operator|.
name|isBuiltInFuncExpr
argument_list|(
name|funcDesc
argument_list|)
decl_stmt|;
name|boolean
name|isPermanent
init|=
name|FunctionRegistry
operator|.
name|isPermanentFunction
argument_list|(
name|funcDesc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isBuiltIn
operator|&&
operator|!
name|isPermanent
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_CSTR_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|"Temporary UDFs are not allowed in Check Constraints"
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|FunctionRegistry
operator|.
name|impliesOrder
argument_list|(
name|funcDesc
operator|.
name|getFuncText
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_CSTR_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|"Window functions are not allowed in Check Constraints"
argument_list|)
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|checkExpr
operator|.
name|getChildren
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|ExprNodeDesc
name|childExpr
range|:
name|checkExpr
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|validateCheckExpr
argument_list|(
name|childExpr
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|boolean
name|hasEnabledOrValidatedConstraints
parameter_list|(
name|List
argument_list|<
name|SQLNotNullConstraint
argument_list|>
name|notNullConstraints
parameter_list|,
name|List
argument_list|<
name|SQLDefaultConstraint
argument_list|>
name|defaultConstraints
parameter_list|,
name|List
argument_list|<
name|SQLCheckConstraint
argument_list|>
name|checkConstraints
parameter_list|)
block|{
if|if
condition|(
name|notNullConstraints
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|SQLNotNullConstraint
name|nnC
range|:
name|notNullConstraints
control|)
block|{
if|if
condition|(
name|nnC
operator|.
name|isEnable_cstr
argument_list|()
operator|||
name|nnC
operator|.
name|isValidate_cstr
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
if|if
condition|(
name|defaultConstraints
operator|!=
literal|null
operator|&&
operator|!
name|defaultConstraints
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|checkConstraints
operator|!=
literal|null
operator|&&
operator|!
name|checkConstraints
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
end_class

end_unit

