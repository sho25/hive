begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|AppMasterEventOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|DummyStoreOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FilterOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|MapJoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RowSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TableScanOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|UDFArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|UnionOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|GenTezUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ParseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PrunedPartitionList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemiJoinBranchInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DynamicPruningEventDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDescUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDynamicListDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDynamicValueDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FilterDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ReduceSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableScanDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|stats
operator|.
name|StatsUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFBetween
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFInBloomFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPAnd
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPOr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ArrayListMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|HashMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multiset
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|TreeMultiset
import|;
end_import

begin_comment
comment|/**  * Shared computation optimizer.  *  *<p>Originally, this rule would find scan operators over the same table  * in the query plan and merge them if they met some preconditions.  *  *  TS   TS             TS  *  |    |     ->      /  \  *  Op   Op           Op  Op  *  *<p>Now the rule has been extended to find opportunities to other operators  * downstream, not only a single table scan.  *  *  TS1   TS2    TS1   TS2            TS1   TS2  *   |     |      |     |              |     |  *   |    RS      |    RS              |    RS  *    \   /        \   /       ->       \   /  *   MapJoin      MapJoin              MapJoin  *      |            |                  /   \  *      Op           Op                Op   Op  *  *<p>If the extended version of the optimizer is enabled, it can go beyond  * a work boundary to find reutilization opportunities.  *  *<p>The optimization only works with the Tez execution engine.  */
end_comment

begin_class
specifier|public
class|class
name|SharedWorkOptimizer
extends|extends
name|Transform
block|{
specifier|private
specifier|final
specifier|static
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SharedWorkOptimizer
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|ParseContext
name|transform
parameter_list|(
name|ParseContext
name|pctx
parameter_list|)
throws|throws
name|SemanticException
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|topOps
init|=
name|pctx
operator|.
name|getTopOps
argument_list|()
decl_stmt|;
if|if
condition|(
name|topOps
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
comment|// Nothing to do, bail out
return|return
name|pctx
return|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Before SharedWorkOptimizer:\n"
operator|+
name|Operator
operator|.
name|toString
argument_list|(
name|pctx
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Cache to use during optimization
name|SharedWorkOptimizerCache
name|optimizerCache
init|=
operator|new
name|SharedWorkOptimizerCache
argument_list|()
decl_stmt|;
comment|// Gather information about the DPP table scans and store it in the cache
name|gatherDPPTableScanOps
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|)
expr_stmt|;
comment|// Map of dbName.TblName -> TSOperator
name|Multimap
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|tableNameToOps
init|=
name|splitTableScanOpsByTable
argument_list|(
name|pctx
argument_list|)
decl_stmt|;
comment|// We enforce a certain order when we do the reutilization.
comment|// In particular, we use size of table x number of reads to
comment|// rank the tables.
name|List
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|>
name|sortedTables
init|=
name|rankTablesByAccumulatedSize
argument_list|(
name|pctx
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sorted tables by size: {}"
argument_list|,
name|sortedTables
argument_list|)
expr_stmt|;
comment|// Execute optimization
name|Multimap
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|existingOps
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|removedOps
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|tablePair
range|:
name|sortedTables
control|)
block|{
name|String
name|tableName
init|=
name|tablePair
operator|.
name|getKey
argument_list|()
decl_stmt|;
for|for
control|(
name|TableScanOperator
name|discardableTsOp
range|:
name|tableNameToOps
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
control|)
block|{
if|if
condition|(
name|removedOps
operator|.
name|contains
argument_list|(
name|discardableTsOp
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skip {} as it has already been removed"
argument_list|,
name|discardableTsOp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Collection
argument_list|<
name|TableScanOperator
argument_list|>
name|prevTsOps
init|=
name|existingOps
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
for|for
control|(
name|TableScanOperator
name|retainableTsOp
range|:
name|prevTsOps
control|)
block|{
if|if
condition|(
name|removedOps
operator|.
name|contains
argument_list|(
name|retainableTsOp
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skip {} as it has already been removed"
argument_list|,
name|retainableTsOp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// First we quickly check if the two table scan operators can actually be merged
name|boolean
name|mergeable
init|=
name|areMergeable
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|retainableTsOp
argument_list|,
name|discardableTsOp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mergeable
condition|)
block|{
comment|// Skip
name|LOG
operator|.
name|debug
argument_list|(
literal|"{} and {} cannot be merged"
argument_list|,
name|retainableTsOp
argument_list|,
name|discardableTsOp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// Secondly, we extract information about the part of the tree that can be merged
comment|// as well as some structural information (memory consumption) that needs to be
comment|// used to determined whether the merge can happen
name|SharedResult
name|sr
init|=
name|extractSharedOptimizationInfoForRoot
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|retainableTsOp
argument_list|,
name|discardableTsOp
argument_list|)
decl_stmt|;
comment|// It seems these two operators can be merged.
comment|// Check that plan meets some preconditions before doing it.
comment|// In particular, in the presence of map joins in the upstream plan:
comment|// - we cannot exceed the noconditional task size, and
comment|// - if we already merged the big table, we cannot merge the broadcast
comment|// tables.
if|if
condition|(
operator|!
name|validPreConditions
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|sr
argument_list|)
condition|)
block|{
comment|// Skip
name|LOG
operator|.
name|debug
argument_list|(
literal|"{} and {} do not meet preconditions"
argument_list|,
name|retainableTsOp
argument_list|,
name|discardableTsOp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// We can merge
if|if
condition|(
name|sr
operator|.
name|retainableOps
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// More than TS operator
name|Operator
argument_list|<
name|?
argument_list|>
name|lastRetainableOp
init|=
name|sr
operator|.
name|retainableOps
operator|.
name|get
argument_list|(
name|sr
operator|.
name|retainableOps
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|lastDiscardableOp
init|=
name|sr
operator|.
name|discardableOps
operator|.
name|get
argument_list|(
name|sr
operator|.
name|discardableOps
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastDiscardableOp
operator|.
name|getNumChild
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|allChildren
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|lastDiscardableOp
operator|.
name|getChildOperators
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|allChildren
control|)
block|{
name|lastDiscardableOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|remove
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|op
operator|.
name|replaceParent
argument_list|(
name|lastDiscardableOp
argument_list|,
name|lastRetainableOp
argument_list|)
expr_stmt|;
name|lastRetainableOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Merging subtree starting at {} into subtree starting at {}"
argument_list|,
name|discardableTsOp
argument_list|,
name|retainableTsOp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Only TS operator
name|ExprNodeGenericFuncDesc
name|exprNode
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|retainableTsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getFilterExpr
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// Push filter on top of children
name|pushFilterToTopOfTableScan
argument_list|(
name|optimizerCache
argument_list|,
name|retainableTsOp
argument_list|)
expr_stmt|;
comment|// Clone to push to table scan
name|exprNode
operator|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|retainableTsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getFilterExpr
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|discardableTsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getFilterExpr
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// Push filter on top
name|pushFilterToTopOfTableScan
argument_list|(
name|optimizerCache
argument_list|,
name|discardableTsOp
argument_list|)
expr_stmt|;
name|ExprNodeGenericFuncDesc
name|tsExprNode
init|=
name|discardableTsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getFilterExpr
argument_list|()
decl_stmt|;
if|if
condition|(
name|exprNode
operator|!=
literal|null
operator|&&
operator|!
name|exprNode
operator|.
name|isSame
argument_list|(
name|tsExprNode
argument_list|)
condition|)
block|{
comment|// We merge filters from previous scan by ORing with filters from current scan
if|if
condition|(
name|exprNode
operator|.
name|getGenericUDF
argument_list|()
operator|instanceof
name|GenericUDFOPOr
condition|)
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|newChildren
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|exprNode
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|childExprNode
range|:
name|exprNode
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
name|childExprNode
operator|.
name|isSame
argument_list|(
name|tsExprNode
argument_list|)
condition|)
block|{
comment|// We do not need to do anything, it is in the OR expression
break|break;
block|}
name|newChildren
operator|.
name|add
argument_list|(
name|childExprNode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exprNode
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|==
name|newChildren
operator|.
name|size
argument_list|()
condition|)
block|{
name|newChildren
operator|.
name|add
argument_list|(
name|tsExprNode
argument_list|)
expr_stmt|;
name|exprNode
operator|=
name|ExprNodeGenericFuncDesc
operator|.
name|newInstance
argument_list|(
operator|new
name|GenericUDFOPOr
argument_list|()
argument_list|,
name|newChildren
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|exprNode
operator|=
name|ExprNodeGenericFuncDesc
operator|.
name|newInstance
argument_list|(
operator|new
name|GenericUDFOPOr
argument_list|()
argument_list|,
name|Arrays
operator|.
expr|<
name|ExprNodeDesc
operator|>
name|asList
argument_list|(
name|exprNode
argument_list|,
name|tsExprNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Replace filter
name|retainableTsOp
operator|.
name|getConf
argument_list|()
operator|.
name|setFilterExpr
argument_list|(
name|exprNode
argument_list|)
expr_stmt|;
comment|// Replace table scan operator
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|allChildren
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|discardableTsOp
operator|.
name|getChildOperators
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|allChildren
control|)
block|{
name|discardableTsOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|remove
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|op
operator|.
name|replaceParent
argument_list|(
name|discardableTsOp
argument_list|,
name|retainableTsOp
argument_list|)
expr_stmt|;
name|retainableTsOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Merging {} into {}"
argument_list|,
name|discardableTsOp
argument_list|,
name|retainableTsOp
argument_list|)
expr_stmt|;
block|}
comment|// First we remove the input operators of the expression that
comment|// we are going to eliminate
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|sr
operator|.
name|discardableInputOps
control|)
block|{
name|OperatorUtils
operator|.
name|removeOperator
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|optimizerCache
operator|.
name|removeOp
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|removedOps
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|// Remove DPP predicates
if|if
condition|(
name|op
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|SemiJoinBranchInfo
name|sjbi
init|=
name|pctx
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|get
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|sjbi
operator|!=
literal|null
operator|&&
operator|!
name|sr
operator|.
name|discardableOps
operator|.
name|contains
argument_list|(
name|sjbi
operator|.
name|getTsOp
argument_list|()
argument_list|)
operator|&&
operator|!
name|sr
operator|.
name|discardableInputOps
operator|.
name|contains
argument_list|(
name|sjbi
operator|.
name|getTsOp
argument_list|()
argument_list|)
condition|)
block|{
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|pctx
argument_list|,
operator|(
name|ReduceSinkOperator
operator|)
name|op
argument_list|,
name|sjbi
operator|.
name|getTsOp
argument_list|()
argument_list|)
expr_stmt|;
name|optimizerCache
operator|.
name|tableScanToDPPSource
operator|.
name|remove
argument_list|(
name|sjbi
operator|.
name|getTsOp
argument_list|()
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|instanceof
name|AppMasterEventOperator
condition|)
block|{
name|DynamicPruningEventDesc
name|dped
init|=
operator|(
name|DynamicPruningEventDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|sr
operator|.
name|discardableOps
operator|.
name|contains
argument_list|(
name|dped
operator|.
name|getTableScan
argument_list|()
argument_list|)
operator|&&
operator|!
name|sr
operator|.
name|discardableInputOps
operator|.
name|contains
argument_list|(
name|dped
operator|.
name|getTableScan
argument_list|()
argument_list|)
condition|)
block|{
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|pctx
argument_list|,
operator|(
name|AppMasterEventOperator
operator|)
name|op
argument_list|,
name|dped
operator|.
name|getTableScan
argument_list|()
argument_list|)
expr_stmt|;
name|optimizerCache
operator|.
name|tableScanToDPPSource
operator|.
name|remove
argument_list|(
name|dped
operator|.
name|getTableScan
argument_list|()
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Input operator removed: {}"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
comment|// Then we merge the operators of the works we are going to merge
name|optimizerCache
operator|.
name|removeOpAndCombineWork
argument_list|(
name|discardableTsOp
argument_list|,
name|retainableTsOp
argument_list|)
expr_stmt|;
name|removedOps
operator|.
name|add
argument_list|(
name|discardableTsOp
argument_list|)
expr_stmt|;
comment|// Finally we remove the expression from the tree
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|sr
operator|.
name|discardableOps
control|)
block|{
name|OperatorUtils
operator|.
name|removeOperator
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|optimizerCache
operator|.
name|removeOp
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|removedOps
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr
operator|.
name|discardableOps
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// If there is a single discardable operator, it is a TableScanOperator
comment|// and it means that we have merged filter expressions for it. Thus, we
comment|// might need to remove DPP predicates from the retainable TableScanOperator
name|Collection
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|c
init|=
name|optimizerCache
operator|.
name|tableScanToDPPSource
operator|.
name|get
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|op
argument_list|)
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|dppSource
range|:
name|c
control|)
block|{
if|if
condition|(
name|dppSource
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|pctx
argument_list|,
operator|(
name|ReduceSinkOperator
operator|)
name|dppSource
argument_list|,
operator|(
name|TableScanOperator
operator|)
name|sr
operator|.
name|retainableOps
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|optimizerCache
operator|.
name|tableScanToDPPSource
operator|.
name|remove
argument_list|(
name|sr
operator|.
name|retainableOps
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dppSource
operator|instanceof
name|AppMasterEventOperator
condition|)
block|{
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|pctx
argument_list|,
operator|(
name|AppMasterEventOperator
operator|)
name|dppSource
argument_list|,
operator|(
name|TableScanOperator
operator|)
name|sr
operator|.
name|retainableOps
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|optimizerCache
operator|.
name|tableScanToDPPSource
operator|.
name|remove
argument_list|(
name|sr
operator|.
name|retainableOps
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Operator removed: {}"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|removedOps
operator|.
name|contains
argument_list|(
name|discardableTsOp
argument_list|)
condition|)
block|{
comment|// This operator has been removed, remove it from the list of existing operators
name|existingOps
operator|.
name|remove
argument_list|(
name|tableName
argument_list|,
name|discardableTsOp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// This operator has not been removed, include it in the list of existing operators
name|existingOps
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|discardableTsOp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Remove unused table scan operators
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
argument_list|>
name|it
init|=
name|topOps
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|e
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getNumChild
argument_list|()
operator|==
literal|0
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"After SharedWorkOptimizer:\n"
operator|+
name|Operator
operator|.
name|toString
argument_list|(
name|pctx
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pctx
operator|.
name|getConf
argument_list|()
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_SHARED_WORK_EXTENDED_OPTIMIZATION
argument_list|)
condition|)
block|{
comment|// Gather RS operators that 1) belong to root works, i.e., works containing TS operators,
comment|// and 2) share the same input operator.
comment|// These will be the first target for extended shared work optimization
name|Multimap
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|ReduceSinkOperator
argument_list|>
name|parentToRsOps
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|visited
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|e
range|:
name|topOps
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|gatherReduceSinkOpsByInput
argument_list|(
name|parentToRsOps
argument_list|,
name|visited
argument_list|,
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|parentToRsOps
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// As above, we enforce a certain order when we do the reutilization.
comment|// In particular, we use size of data in RS x number of uses.
name|List
argument_list|<
name|Entry
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Long
argument_list|>
argument_list|>
name|sortedRSGroups
init|=
name|rankOpsByAccumulatedSize
argument_list|(
name|parentToRsOps
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sorted operators by size: {}"
argument_list|,
name|sortedRSGroups
argument_list|)
expr_stmt|;
comment|// Execute extended optimization
comment|// For each RS, check whether other RS in same work could be merge into this one.
comment|// If they are merged, RS operators in the resulting work will be considered
comment|// mergeable in next loop iteration.
name|Multimap
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|ReduceSinkOperator
argument_list|>
name|existingRsOps
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Long
argument_list|>
name|rsGroupInfo
range|:
name|sortedRSGroups
control|)
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|rsParent
init|=
name|rsGroupInfo
operator|.
name|getKey
argument_list|()
decl_stmt|;
for|for
control|(
name|ReduceSinkOperator
name|discardableRsOp
range|:
name|parentToRsOps
operator|.
name|get
argument_list|(
name|rsParent
argument_list|)
control|)
block|{
if|if
condition|(
name|removedOps
operator|.
name|contains
argument_list|(
name|discardableRsOp
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skip {} as it has already been removed"
argument_list|,
name|discardableRsOp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Collection
argument_list|<
name|ReduceSinkOperator
argument_list|>
name|otherRsOps
init|=
name|existingRsOps
operator|.
name|get
argument_list|(
name|rsParent
argument_list|)
decl_stmt|;
for|for
control|(
name|ReduceSinkOperator
name|retainableRsOp
range|:
name|otherRsOps
control|)
block|{
if|if
condition|(
name|removedOps
operator|.
name|contains
argument_list|(
name|retainableRsOp
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skip {} as it has already been removed"
argument_list|,
name|retainableRsOp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// First we quickly check if the two RS operators can actually be merged.
comment|// We already know that these two RS operators have the same parent, but
comment|// we need to check whether both RS are actually equal. Further, we check
comment|// whether their child is also equal. If any of these conditions are not
comment|// met, we are not going to try to merge.
name|boolean
name|mergeable
init|=
name|compareOperator
argument_list|(
name|pctx
argument_list|,
name|retainableRsOp
argument_list|,
name|discardableRsOp
argument_list|)
operator|&&
name|compareOperator
argument_list|(
name|pctx
argument_list|,
name|retainableRsOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|discardableRsOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mergeable
condition|)
block|{
comment|// Skip
name|LOG
operator|.
name|debug
argument_list|(
literal|"{} and {} cannot be merged"
argument_list|,
name|retainableRsOp
argument_list|,
name|discardableRsOp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Checking additional conditions for merging subtree starting at {}"
operator|+
literal|" into subtree starting at {}"
argument_list|,
name|discardableRsOp
argument_list|,
name|retainableRsOp
argument_list|)
expr_stmt|;
comment|// Secondly, we extract information about the part of the tree that can be merged
comment|// as well as some structural information (memory consumption) that needs to be
comment|// used to determined whether the merge can happen
name|Operator
argument_list|<
name|?
argument_list|>
name|retainableRsOpChild
init|=
name|retainableRsOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|discardableRsOpChild
init|=
name|discardableRsOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|SharedResult
name|sr
init|=
name|extractSharedOptimizationInfo
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|retainableRsOp
argument_list|,
name|discardableRsOp
argument_list|,
name|retainableRsOpChild
argument_list|,
name|discardableRsOpChild
argument_list|)
decl_stmt|;
comment|// It seems these two operators can be merged.
comment|// Check that plan meets some preconditions before doing it.
comment|// In particular, in the presence of map joins in the upstream plan:
comment|// - we cannot exceed the noconditional task size, and
comment|// - if we already merged the big table, we cannot merge the broadcast
comment|// tables.
if|if
condition|(
name|sr
operator|.
name|retainableOps
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|validPreConditions
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|sr
argument_list|)
condition|)
block|{
comment|// Skip
name|LOG
operator|.
name|debug
argument_list|(
literal|"{} and {} do not meet preconditions"
argument_list|,
name|retainableRsOp
argument_list|,
name|discardableRsOp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// We can merge
name|Operator
argument_list|<
name|?
argument_list|>
name|lastRetainableOp
init|=
name|sr
operator|.
name|retainableOps
operator|.
name|get
argument_list|(
name|sr
operator|.
name|retainableOps
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|lastDiscardableOp
init|=
name|sr
operator|.
name|discardableOps
operator|.
name|get
argument_list|(
name|sr
operator|.
name|discardableOps
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastDiscardableOp
operator|.
name|getNumChild
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|allChildren
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|lastDiscardableOp
operator|.
name|getChildOperators
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|allChildren
control|)
block|{
name|lastDiscardableOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|remove
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|op
operator|.
name|replaceParent
argument_list|(
name|lastDiscardableOp
argument_list|,
name|lastRetainableOp
argument_list|)
expr_stmt|;
name|lastRetainableOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Merging subtree starting at {} into subtree starting at {}"
argument_list|,
name|discardableRsOp
argument_list|,
name|retainableRsOp
argument_list|)
expr_stmt|;
comment|// First we remove the input operators of the expression that
comment|// we are going to eliminate
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|sr
operator|.
name|discardableInputOps
control|)
block|{
name|OperatorUtils
operator|.
name|removeOperator
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|optimizerCache
operator|.
name|removeOp
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|removedOps
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|// Remove DPP predicates
if|if
condition|(
name|op
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|SemiJoinBranchInfo
name|sjbi
init|=
name|pctx
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|get
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|sjbi
operator|!=
literal|null
operator|&&
operator|!
name|sr
operator|.
name|discardableOps
operator|.
name|contains
argument_list|(
name|sjbi
operator|.
name|getTsOp
argument_list|()
argument_list|)
operator|&&
operator|!
name|sr
operator|.
name|discardableInputOps
operator|.
name|contains
argument_list|(
name|sjbi
operator|.
name|getTsOp
argument_list|()
argument_list|)
condition|)
block|{
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|pctx
argument_list|,
operator|(
name|ReduceSinkOperator
operator|)
name|op
argument_list|,
name|sjbi
operator|.
name|getTsOp
argument_list|()
argument_list|)
expr_stmt|;
name|optimizerCache
operator|.
name|tableScanToDPPSource
operator|.
name|remove
argument_list|(
name|sjbi
operator|.
name|getTsOp
argument_list|()
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|instanceof
name|AppMasterEventOperator
condition|)
block|{
name|DynamicPruningEventDesc
name|dped
init|=
operator|(
name|DynamicPruningEventDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|sr
operator|.
name|discardableOps
operator|.
name|contains
argument_list|(
name|dped
operator|.
name|getTableScan
argument_list|()
argument_list|)
operator|&&
operator|!
name|sr
operator|.
name|discardableInputOps
operator|.
name|contains
argument_list|(
name|dped
operator|.
name|getTableScan
argument_list|()
argument_list|)
condition|)
block|{
name|GenTezUtils
operator|.
name|removeSemiJoinOperator
argument_list|(
name|pctx
argument_list|,
operator|(
name|AppMasterEventOperator
operator|)
name|op
argument_list|,
name|dped
operator|.
name|getTableScan
argument_list|()
argument_list|)
expr_stmt|;
name|optimizerCache
operator|.
name|tableScanToDPPSource
operator|.
name|remove
argument_list|(
name|dped
operator|.
name|getTableScan
argument_list|()
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Input operator removed: {}"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
comment|// We remove the discardable RS operator
name|OperatorUtils
operator|.
name|removeOperator
argument_list|(
name|discardableRsOp
argument_list|)
expr_stmt|;
name|optimizerCache
operator|.
name|removeOp
argument_list|(
name|discardableRsOp
argument_list|)
expr_stmt|;
name|removedOps
operator|.
name|add
argument_list|(
name|discardableRsOp
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Operator removed: {}"
argument_list|,
name|discardableRsOp
argument_list|)
expr_stmt|;
comment|// Then we merge the operators of the works we are going to merge
name|optimizerCache
operator|.
name|removeOpAndCombineWork
argument_list|(
name|discardableRsOpChild
argument_list|,
name|retainableRsOpChild
argument_list|)
expr_stmt|;
comment|// Finally we remove the rest of the expression from the tree
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|sr
operator|.
name|discardableOps
control|)
block|{
name|OperatorUtils
operator|.
name|removeOperator
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|optimizerCache
operator|.
name|removeOp
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|removedOps
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Operator removed: {}"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|removedOps
operator|.
name|contains
argument_list|(
name|discardableRsOp
argument_list|)
condition|)
block|{
comment|// This operator has been removed, remove it from the list of existing operators
name|existingRsOps
operator|.
name|remove
argument_list|(
name|rsParent
argument_list|,
name|discardableRsOp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// This operator has not been removed, include it in the list of existing operators
name|existingRsOps
operator|.
name|put
argument_list|(
name|rsParent
argument_list|,
name|discardableRsOp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// We gather the operators that will be used for next iteration of extended optimization
comment|// (if any)
name|parentToRsOps
operator|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
expr_stmt|;
name|visited
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|ReduceSinkOperator
argument_list|>
name|e
range|:
name|existingRsOps
operator|.
name|entries
argument_list|()
control|)
block|{
if|if
condition|(
name|removedOps
operator|.
name|contains
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
operator|||
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getNumChild
argument_list|()
operator|<
literal|1
condition|)
block|{
comment|// If 1) RS has been removed, or 2) it does not have a child (for instance, it is a
comment|// semijoin RS), we can quickly skip this one
continue|continue;
block|}
name|gatherReduceSinkOpsByInput
argument_list|(
name|parentToRsOps
argument_list|,
name|visited
argument_list|,
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Remove unused table scan operators
name|it
operator|=
name|topOps
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|e
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getNumChild
argument_list|()
operator|==
literal|0
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"After SharedWorkExtendedOptimizer:\n"
operator|+
name|Operator
operator|.
name|toString
argument_list|(
name|pctx
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If we are running tests, we are going to verify that the contents of the cache
comment|// correspond with the contents of the plan, and otherwise we fail.
comment|// This check always run when we are running in test mode, independently on whether
comment|// we use the basic or the extended version of the optimizer.
if|if
condition|(
name|pctx
operator|.
name|getConf
argument_list|()
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_IN_TEST
argument_list|)
condition|)
block|{
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|visited
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|it
operator|=
name|topOps
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|e
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|OperatorUtils
operator|.
name|findOperators
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|,
name|Operator
operator|.
name|class
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|visited
operator|.
name|contains
argument_list|(
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|op
argument_list|)
operator|.
name|equals
argument_list|(
name|findWorkOperators
argument_list|(
name|op
argument_list|,
operator|new
name|HashSet
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Error in shared work optimizer: operator cache contents"
operator|+
literal|"and actual plan differ"
argument_list|)
throw|;
block|}
name|visited
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|pctx
return|;
block|}
comment|/**    * This method gathers the TS operators with DPP from the context and    * stores them into the input optimization cache.    */
specifier|private
specifier|static
name|void
name|gatherDPPTableScanOps
parameter_list|(
name|ParseContext
name|pctx
parameter_list|,
name|SharedWorkOptimizerCache
name|optimizerCache
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Find TS operators with partition pruning enabled in plan
comment|// because these TS may potentially read different data for
comment|// different pipeline.
comment|// These can be:
comment|// 1) TS with DPP.
comment|// 2) TS with semijoin DPP.
name|Map
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|topOps
init|=
name|pctx
operator|.
name|getTopOps
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|tableScanOps
init|=
name|Lists
operator|.
expr|<
name|Operator
argument_list|<
name|?
argument_list|>
operator|>
name|newArrayList
argument_list|(
name|topOps
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|AppMasterEventOperator
argument_list|>
name|s
init|=
name|OperatorUtils
operator|.
name|findOperators
argument_list|(
name|tableScanOps
argument_list|,
name|AppMasterEventOperator
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|AppMasterEventOperator
name|a
range|:
name|s
control|)
block|{
if|if
condition|(
name|a
operator|.
name|getConf
argument_list|()
operator|instanceof
name|DynamicPruningEventDesc
condition|)
block|{
name|DynamicPruningEventDesc
name|dped
init|=
operator|(
name|DynamicPruningEventDesc
operator|)
name|a
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|optimizerCache
operator|.
name|tableScanToDPPSource
operator|.
name|put
argument_list|(
name|dped
operator|.
name|getTableScan
argument_list|()
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Entry
argument_list|<
name|ReduceSinkOperator
argument_list|,
name|SemiJoinBranchInfo
argument_list|>
name|e
range|:
name|pctx
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|optimizerCache
operator|.
name|tableScanToDPPSource
operator|.
name|put
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getTsOp
argument_list|()
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"DPP information stored in the cache: {}"
argument_list|,
name|optimizerCache
operator|.
name|tableScanToDPPSource
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|Multimap
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|splitTableScanOpsByTable
parameter_list|(
name|ParseContext
name|pctx
parameter_list|)
block|{
name|Multimap
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|tableNameToOps
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
comment|// Sort by operator ID so we get deterministic results
name|Map
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|sortedTopOps
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|pctx
operator|.
name|getTopOps
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|e
range|:
name|sortedTopOps
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|TableScanOperator
name|tsOp
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|tableNameToOps
operator|.
name|put
argument_list|(
name|tsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getTableMetadata
argument_list|()
operator|.
name|getDbName
argument_list|()
operator|+
literal|"."
operator|+
name|tsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getTableMetadata
argument_list|()
operator|.
name|getTableName
argument_list|()
argument_list|,
name|tsOp
argument_list|)
expr_stmt|;
block|}
return|return
name|tableNameToOps
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|>
name|rankTablesByAccumulatedSize
parameter_list|(
name|ParseContext
name|pctx
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|tableToTotalSize
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|e
range|:
name|pctx
operator|.
name|getTopOps
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|TableScanOperator
name|tsOp
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|tableName
init|=
name|tsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getTableMetadata
argument_list|()
operator|.
name|getDbName
argument_list|()
operator|+
literal|"."
operator|+
name|tsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getTableMetadata
argument_list|()
operator|.
name|getTableName
argument_list|()
decl_stmt|;
name|long
name|tableSize
init|=
name|tsOp
operator|.
name|getStatistics
argument_list|()
operator|!=
literal|null
condition|?
name|tsOp
operator|.
name|getStatistics
argument_list|()
operator|.
name|getDataSize
argument_list|()
else|:
literal|0L
decl_stmt|;
name|Long
name|totalSize
init|=
name|tableToTotalSize
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|totalSize
operator|!=
literal|null
condition|)
block|{
name|tableToTotalSize
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|StatsUtils
operator|.
name|safeAdd
argument_list|(
name|totalSize
argument_list|,
name|tableSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tableToTotalSize
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|tableSize
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|>
name|sortedTables
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|tableToTotalSize
operator|.
name|entrySet
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|sortedTables
argument_list|,
name|Collections
operator|.
name|reverseOrder
argument_list|(
operator|new
name|Comparator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|o1
parameter_list|,
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|o2
parameter_list|)
block|{
return|return
operator|(
name|o1
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sortedTables
return|;
block|}
specifier|private
specifier|static
name|void
name|gatherReduceSinkOpsByInput
parameter_list|(
name|Multimap
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|ReduceSinkOperator
argument_list|>
name|parentToRsOps
parameter_list|,
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|visited
parameter_list|,
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|ops
parameter_list|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|ops
control|)
block|{
comment|// If the RS has other RS siblings, we will add it to be considered in next iteration
if|if
condition|(
name|op
operator|instanceof
name|ReduceSinkOperator
operator|&&
operator|!
name|visited
operator|.
name|contains
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
init|=
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|ReduceSinkOperator
argument_list|>
name|s
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|c
range|:
name|parent
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
if|if
condition|(
name|c
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
operator|(
name|ReduceSinkOperator
operator|)
name|c
argument_list|)
expr_stmt|;
name|visited
operator|.
name|add
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|parentToRsOps
operator|.
name|putAll
argument_list|(
name|parent
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|Entry
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Long
argument_list|>
argument_list|>
name|rankOpsByAccumulatedSize
parameter_list|(
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|opsSet
parameter_list|)
block|{
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Long
argument_list|>
name|opToTotalSize
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|opsSet
control|)
block|{
name|long
name|size
init|=
name|op
operator|.
name|getStatistics
argument_list|()
operator|!=
literal|null
condition|?
name|op
operator|.
name|getStatistics
argument_list|()
operator|.
name|getDataSize
argument_list|()
else|:
literal|0L
decl_stmt|;
name|opToTotalSize
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|op
operator|.
name|getChildOperators
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Entry
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Long
argument_list|>
argument_list|>
name|sortedOps
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|opToTotalSize
operator|.
name|entrySet
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|sortedOps
argument_list|,
name|Collections
operator|.
name|reverseOrder
argument_list|(
operator|new
name|Comparator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Map
operator|.
name|Entry
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Long
argument_list|>
name|o1
parameter_list|,
name|Map
operator|.
name|Entry
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Long
argument_list|>
name|o2
parameter_list|)
block|{
name|int
name|valCmp
init|=
name|o1
operator|.
name|getValue
argument_list|()
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|valCmp
operator|==
literal|0
condition|)
block|{
return|return
name|o1
operator|.
name|getKey
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|getKey
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
return|return
name|valCmp
return|;
block|}
block|}
block|)
block|)
class|;
end_class

begin_return
return|return
name|sortedOps
return|;
end_return

begin_comment
unit|}
comment|// FIXME: probably this should also be integrated with isSame() logics
end_comment

begin_function
unit|private
specifier|static
name|boolean
name|areMergeable
parameter_list|(
name|ParseContext
name|pctx
parameter_list|,
name|SharedWorkOptimizerCache
name|optimizerCache
parameter_list|,
name|TableScanOperator
name|tsOp1
parameter_list|,
name|TableScanOperator
name|tsOp2
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// First we check if the two table scan operators can actually be merged
comment|// If schemas do not match, we currently do not merge
name|List
argument_list|<
name|String
argument_list|>
name|prevTsOpNeededColumns
init|=
name|tsOp1
operator|.
name|getNeededColumns
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|tsOpNeededColumns
init|=
name|tsOp2
operator|.
name|getNeededColumns
argument_list|()
decl_stmt|;
if|if
condition|(
name|prevTsOpNeededColumns
operator|.
name|size
argument_list|()
operator|!=
name|tsOpNeededColumns
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|notEqual
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|prevTsOpNeededColumns
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|prevTsOpNeededColumns
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|equals
argument_list|(
name|tsOpNeededColumns
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|notEqual
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|notEqual
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// If row limit does not match, we currently do not merge
if|if
condition|(
name|tsOp1
operator|.
name|getConf
argument_list|()
operator|.
name|getRowLimit
argument_list|()
operator|!=
name|tsOp2
operator|.
name|getConf
argument_list|()
operator|.
name|getRowLimit
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// If partitions do not match, we currently do not merge
name|PrunedPartitionList
name|prevTsOpPPList
init|=
name|pctx
operator|.
name|getPrunedPartitions
argument_list|(
name|tsOp1
argument_list|)
decl_stmt|;
name|PrunedPartitionList
name|tsOpPPList
init|=
name|pctx
operator|.
name|getPrunedPartitions
argument_list|(
name|tsOp2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|prevTsOpPPList
operator|.
name|getPartitions
argument_list|()
operator|.
name|equals
argument_list|(
name|tsOpPPList
operator|.
name|getPartitions
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// If is a DPP, check if actually it refers to same target, column, etc.
comment|// Further, the DPP value needs to be generated from same subtree
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|dppsOp1
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|optimizerCache
operator|.
name|tableScanToDPPSource
operator|.
name|get
argument_list|(
name|tsOp1
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|dppsOp2
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|optimizerCache
operator|.
name|tableScanToDPPSource
operator|.
name|get
argument_list|(
name|tsOp2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dppsOp1
operator|.
name|isEmpty
argument_list|()
operator|&&
name|dppsOp2
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dppsOp1
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|op
init|=
name|dppsOp1
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|ascendants
init|=
name|findAscendantWorkOperators
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|ascendants
operator|.
name|contains
argument_list|(
name|tsOp2
argument_list|)
condition|)
block|{
comment|// This should not happen, we cannot merge
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dppsOp2
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|op
init|=
name|dppsOp2
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|ascendants
init|=
name|findAscendantWorkOperators
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|ascendants
operator|.
name|contains
argument_list|(
name|tsOp1
argument_list|)
condition|)
block|{
comment|// This should not happen, we cannot merge
return|return
literal|false
return|;
block|}
block|}
block|}
if|if
condition|(
name|dppsOp1
operator|.
name|size
argument_list|()
operator|!=
name|dppsOp2
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// Only first or second operator contains DPP pruning
return|return
literal|false
return|;
block|}
comment|// Check if DPP branches are equal
name|BitSet
name|bs
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dppsOp1
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|dppOp1
init|=
name|dppsOp1
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|dppsOp2
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|bs
operator|.
name|get
argument_list|(
name|j
argument_list|)
condition|)
block|{
comment|// If not visited yet
name|Operator
argument_list|<
name|?
argument_list|>
name|dppOp2
init|=
name|dppsOp2
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|compareAndGatherOps
argument_list|(
name|pctx
argument_list|,
name|dppOp1
argument_list|,
name|dppOp2
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|// The DPP operator/branch are equal
name|bs
operator|.
name|set
argument_list|(
name|j
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|bs
operator|.
name|cardinality
argument_list|()
operator|<
name|i
operator|+
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|SharedResult
name|extractSharedOptimizationInfoForRoot
parameter_list|(
name|ParseContext
name|pctx
parameter_list|,
name|SharedWorkOptimizerCache
name|optimizerCache
parameter_list|,
name|TableScanOperator
name|retainableTsOp
parameter_list|,
name|TableScanOperator
name|discardableTsOp
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LinkedHashSet
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|retainableOps
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|LinkedHashSet
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|discardableOps
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|discardableInputOps
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|long
name|dataSize
init|=
literal|0L
decl_stmt|;
name|long
name|maxDataSize
init|=
literal|0L
decl_stmt|;
name|retainableOps
operator|.
name|add
argument_list|(
name|retainableTsOp
argument_list|)
expr_stmt|;
name|discardableOps
operator|.
name|add
argument_list|(
name|discardableTsOp
argument_list|)
expr_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|equalOp1
init|=
name|retainableTsOp
decl_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|equalOp2
init|=
name|discardableTsOp
decl_stmt|;
if|if
condition|(
name|equalOp1
operator|.
name|getNumChild
argument_list|()
operator|>
literal|1
operator|||
name|equalOp2
operator|.
name|getNumChild
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// TODO: Support checking multiple child operators to merge further.
name|discardableInputOps
operator|.
name|addAll
argument_list|(
name|gatherDPPBranchOps
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|discardableOps
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|SharedResult
argument_list|(
name|retainableOps
argument_list|,
name|discardableOps
argument_list|,
name|discardableInputOps
argument_list|,
name|dataSize
argument_list|,
name|maxDataSize
argument_list|)
return|;
block|}
name|Operator
argument_list|<
name|?
argument_list|>
name|currentOp1
init|=
name|retainableTsOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|currentOp2
init|=
name|discardableTsOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// Special treatment for Filter operator that ignores the DPP predicates
if|if
condition|(
name|currentOp1
operator|instanceof
name|FilterOperator
operator|&&
name|currentOp2
operator|instanceof
name|FilterOperator
condition|)
block|{
name|boolean
name|equalFilters
init|=
literal|false
decl_stmt|;
name|FilterDesc
name|op1Conf
init|=
operator|(
operator|(
name|FilterOperator
operator|)
name|currentOp1
operator|)
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|FilterDesc
name|op2Conf
init|=
operator|(
operator|(
name|FilterOperator
operator|)
name|currentOp2
operator|)
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|op1Conf
operator|.
name|getIsSamplingPred
argument_list|()
operator|==
name|op2Conf
operator|.
name|getIsSamplingPred
argument_list|()
operator|&&
name|StringUtils
operator|.
name|equals
argument_list|(
name|op1Conf
operator|.
name|getSampleDescExpr
argument_list|()
argument_list|,
name|op2Conf
operator|.
name|getSampleDescExpr
argument_list|()
argument_list|)
condition|)
block|{
name|Multiset
argument_list|<
name|String
argument_list|>
name|conjsOp1String
init|=
name|extractConjsIgnoringDPPPreds
argument_list|(
name|op1Conf
operator|.
name|getPredicate
argument_list|()
argument_list|)
decl_stmt|;
name|Multiset
argument_list|<
name|String
argument_list|>
name|conjsOp2String
init|=
name|extractConjsIgnoringDPPPreds
argument_list|(
name|op2Conf
operator|.
name|getPredicate
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|conjsOp1String
operator|.
name|equals
argument_list|(
name|conjsOp2String
argument_list|)
condition|)
block|{
name|equalFilters
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|equalFilters
condition|)
block|{
name|equalOp1
operator|=
name|currentOp1
expr_stmt|;
name|equalOp2
operator|=
name|currentOp2
expr_stmt|;
name|retainableOps
operator|.
name|add
argument_list|(
name|equalOp1
argument_list|)
expr_stmt|;
name|discardableOps
operator|.
name|add
argument_list|(
name|equalOp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentOp1
operator|.
name|getChildOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|||
name|currentOp2
operator|.
name|getChildOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// TODO: Support checking multiple child operators to merge further.
name|discardableInputOps
operator|.
name|addAll
argument_list|(
name|gatherDPPBranchOps
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|discardableOps
argument_list|)
argument_list|)
expr_stmt|;
name|discardableInputOps
operator|.
name|addAll
argument_list|(
name|gatherDPPBranchOps
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|retainableOps
argument_list|,
name|discardableInputOps
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|SharedResult
argument_list|(
name|retainableOps
argument_list|,
name|discardableOps
argument_list|,
name|discardableInputOps
argument_list|,
name|dataSize
argument_list|,
name|maxDataSize
argument_list|)
return|;
block|}
name|currentOp1
operator|=
name|currentOp1
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|currentOp2
operator|=
name|currentOp2
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Bail out
name|discardableInputOps
operator|.
name|addAll
argument_list|(
name|gatherDPPBranchOps
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|discardableOps
argument_list|)
argument_list|)
expr_stmt|;
name|discardableInputOps
operator|.
name|addAll
argument_list|(
name|gatherDPPBranchOps
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|retainableOps
argument_list|,
name|discardableInputOps
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|SharedResult
argument_list|(
name|retainableOps
argument_list|,
name|discardableOps
argument_list|,
name|discardableInputOps
argument_list|,
name|dataSize
argument_list|,
name|maxDataSize
argument_list|)
return|;
block|}
block|}
return|return
name|extractSharedOptimizationInfo
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|equalOp1
argument_list|,
name|equalOp2
argument_list|,
name|currentOp1
argument_list|,
name|currentOp2
argument_list|,
name|retainableOps
argument_list|,
name|discardableOps
argument_list|,
name|discardableInputOps
argument_list|,
literal|false
argument_list|)
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|SharedResult
name|extractSharedOptimizationInfo
parameter_list|(
name|ParseContext
name|pctx
parameter_list|,
name|SharedWorkOptimizerCache
name|optimizerCache
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|retainableOpEqualParent
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|discardableOpEqualParent
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|retainableOp
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|discardableOp
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
name|extractSharedOptimizationInfo
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|retainableOpEqualParent
argument_list|,
name|discardableOpEqualParent
argument_list|,
name|retainableOp
argument_list|,
name|discardableOp
argument_list|,
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
argument_list|,
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
argument_list|,
operator|new
name|HashSet
argument_list|<>
argument_list|()
argument_list|,
literal|true
argument_list|)
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|SharedResult
name|extractSharedOptimizationInfo
parameter_list|(
name|ParseContext
name|pctx
parameter_list|,
name|SharedWorkOptimizerCache
name|optimizerCache
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|retainableOpEqualParent
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|discardableOpEqualParent
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|retainableOp
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|discardableOp
parameter_list|,
name|LinkedHashSet
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|retainableOps
parameter_list|,
name|LinkedHashSet
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|discardableOps
parameter_list|,
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|discardableInputOps
parameter_list|,
name|boolean
name|removeInputBranch
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|equalOp1
init|=
name|retainableOpEqualParent
decl_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|equalOp2
init|=
name|discardableOpEqualParent
decl_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|currentOp1
init|=
name|retainableOp
decl_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|currentOp2
init|=
name|discardableOp
decl_stmt|;
name|long
name|dataSize
init|=
literal|0L
decl_stmt|;
name|long
name|maxDataSize
init|=
literal|0L
decl_stmt|;
comment|// Try to merge rest of operators
while|while
condition|(
operator|!
operator|(
name|currentOp1
operator|instanceof
name|ReduceSinkOperator
operator|)
condition|)
block|{
comment|// Check whether current operators are equal
if|if
condition|(
operator|!
name|compareOperator
argument_list|(
name|pctx
argument_list|,
name|currentOp1
argument_list|,
name|currentOp2
argument_list|)
condition|)
block|{
comment|// If they are not equal, we could zip up till here
break|break;
block|}
if|if
condition|(
name|currentOp1
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
name|currentOp2
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// If they are not equal, we could zip up till here
break|break;
block|}
if|if
condition|(
name|currentOp1
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|discardableOpsForCurrentOp
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|idx
operator|<
name|currentOp1
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|parentOp1
init|=
name|currentOp1
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|parentOp2
init|=
name|currentOp2
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentOp1
operator|==
name|equalOp1
operator|&&
name|parentOp2
operator|==
name|equalOp2
operator|&&
operator|!
name|removeInputBranch
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|parentOp1
operator|==
name|equalOp1
operator|&&
name|parentOp2
operator|!=
name|equalOp2
operator|)
operator|||
operator|(
name|parentOp1
operator|!=
name|equalOp1
operator|&&
name|parentOp2
operator|==
name|equalOp2
operator|)
condition|)
block|{
comment|// Input operator is not in the same position
break|break;
block|}
comment|// Compare input
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|removeOpsForCurrentInput
init|=
name|compareAndGatherOps
argument_list|(
name|pctx
argument_list|,
name|parentOp1
argument_list|,
name|parentOp2
argument_list|)
decl_stmt|;
if|if
condition|(
name|removeOpsForCurrentInput
operator|==
literal|null
condition|)
block|{
comment|// Inputs are not the same, bail out
break|break;
block|}
comment|// Add inputs to ops to remove
name|discardableOpsForCurrentOp
operator|.
name|addAll
argument_list|(
name|removeOpsForCurrentInput
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|!=
name|currentOp1
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// If inputs are not equal, we could zip up till here
break|break;
block|}
name|discardableInputOps
operator|.
name|addAll
argument_list|(
name|discardableOpsForCurrentOp
argument_list|)
expr_stmt|;
block|}
name|equalOp1
operator|=
name|currentOp1
expr_stmt|;
name|equalOp2
operator|=
name|currentOp2
expr_stmt|;
name|retainableOps
operator|.
name|add
argument_list|(
name|equalOp1
argument_list|)
expr_stmt|;
name|discardableOps
operator|.
name|add
argument_list|(
name|equalOp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|equalOp1
operator|instanceof
name|MapJoinOperator
condition|)
block|{
name|MapJoinOperator
name|mop
init|=
operator|(
name|MapJoinOperator
operator|)
name|equalOp1
decl_stmt|;
name|dataSize
operator|=
name|StatsUtils
operator|.
name|safeAdd
argument_list|(
name|dataSize
argument_list|,
name|mop
operator|.
name|getConf
argument_list|()
operator|.
name|getInMemoryDataSize
argument_list|()
argument_list|)
expr_stmt|;
name|maxDataSize
operator|=
name|mop
operator|.
name|getConf
argument_list|()
operator|.
name|getMemoryMonitorInfo
argument_list|()
operator|.
name|getAdjustedNoConditionalTaskSize
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|currentOp1
operator|.
name|getChildOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|||
name|currentOp2
operator|.
name|getChildOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// TODO: Support checking multiple child operators to merge further.
break|break;
block|}
comment|// Update for next iteration
name|currentOp1
operator|=
name|currentOp1
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|currentOp2
operator|=
name|currentOp2
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// Add the rest to the memory consumption
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|opsWork1
init|=
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|currentOp1
argument_list|)
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|opsWork1
control|)
block|{
if|if
condition|(
name|op
operator|instanceof
name|MapJoinOperator
operator|&&
operator|!
name|retainableOps
operator|.
name|contains
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|MapJoinOperator
name|mop
init|=
operator|(
name|MapJoinOperator
operator|)
name|op
decl_stmt|;
name|dataSize
operator|=
name|StatsUtils
operator|.
name|safeAdd
argument_list|(
name|dataSize
argument_list|,
name|mop
operator|.
name|getConf
argument_list|()
operator|.
name|getInMemoryDataSize
argument_list|()
argument_list|)
expr_stmt|;
name|maxDataSize
operator|=
name|mop
operator|.
name|getConf
argument_list|()
operator|.
name|getMemoryMonitorInfo
argument_list|()
operator|.
name|getAdjustedNoConditionalTaskSize
argument_list|()
expr_stmt|;
block|}
block|}
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|opsWork2
init|=
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|currentOp2
argument_list|)
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|opsWork2
control|)
block|{
if|if
condition|(
name|op
operator|instanceof
name|MapJoinOperator
operator|&&
operator|!
name|discardableOps
operator|.
name|contains
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|MapJoinOperator
name|mop
init|=
operator|(
name|MapJoinOperator
operator|)
name|op
decl_stmt|;
name|dataSize
operator|=
name|StatsUtils
operator|.
name|safeAdd
argument_list|(
name|dataSize
argument_list|,
name|mop
operator|.
name|getConf
argument_list|()
operator|.
name|getInMemoryDataSize
argument_list|()
argument_list|)
expr_stmt|;
name|maxDataSize
operator|=
name|mop
operator|.
name|getConf
argument_list|()
operator|.
name|getMemoryMonitorInfo
argument_list|()
operator|.
name|getAdjustedNoConditionalTaskSize
argument_list|()
expr_stmt|;
block|}
block|}
name|discardableInputOps
operator|.
name|addAll
argument_list|(
name|gatherDPPBranchOps
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|discardableInputOps
argument_list|)
argument_list|)
expr_stmt|;
name|discardableInputOps
operator|.
name|addAll
argument_list|(
name|gatherDPPBranchOps
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|discardableOps
argument_list|)
argument_list|)
expr_stmt|;
name|discardableInputOps
operator|.
name|addAll
argument_list|(
name|gatherDPPBranchOps
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|retainableOps
argument_list|,
name|discardableInputOps
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|SharedResult
argument_list|(
name|retainableOps
argument_list|,
name|discardableOps
argument_list|,
name|discardableInputOps
argument_list|,
name|dataSize
argument_list|,
name|maxDataSize
argument_list|)
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|Multiset
argument_list|<
name|String
argument_list|>
name|extractConjsIgnoringDPPPreds
parameter_list|(
name|ExprNodeDesc
name|predicate
parameter_list|)
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|conjsOp
init|=
name|ExprNodeDescUtils
operator|.
name|split
argument_list|(
name|predicate
argument_list|)
decl_stmt|;
name|Multiset
argument_list|<
name|String
argument_list|>
name|conjsOpString
init|=
name|TreeMultiset
operator|.
name|create
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|conjsOp
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|conjsOp
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|func
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|conjsOp
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GenericUDFInBloomFilter
operator|.
name|class
operator|==
name|func
operator|.
name|getGenericUDF
argument_list|()
operator|.
name|getClass
argument_list|()
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|GenericUDFBetween
operator|.
name|class
operator|==
name|func
operator|.
name|getGenericUDF
argument_list|()
operator|.
name|getClass
argument_list|()
operator|&&
operator|(
name|func
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|instanceof
name|ExprNodeDynamicValueDesc
operator|||
name|func
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|3
argument_list|)
operator|instanceof
name|ExprNodeDynamicValueDesc
operator|)
condition|)
block|{
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|conjsOp
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|ExprNodeDynamicListDesc
condition|)
block|{
continue|continue;
block|}
name|conjsOpString
operator|.
name|add
argument_list|(
name|conjsOp
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|conjsOpString
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|gatherDPPBranchOps
parameter_list|(
name|ParseContext
name|pctx
parameter_list|,
name|SharedWorkOptimizerCache
name|optimizerCache
parameter_list|,
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|ops
parameter_list|)
block|{
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|dppBranches
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|ops
control|)
block|{
if|if
condition|(
name|op
operator|instanceof
name|TableScanOperator
condition|)
block|{
name|Collection
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|c
init|=
name|optimizerCache
operator|.
name|tableScanToDPPSource
operator|.
name|get
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|op
argument_list|)
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|dppSource
range|:
name|c
control|)
block|{
comment|// Remove the branches
name|Operator
argument_list|<
name|?
argument_list|>
name|currentOp
init|=
name|dppSource
decl_stmt|;
while|while
condition|(
name|currentOp
operator|.
name|getNumChild
argument_list|()
operator|<=
literal|1
condition|)
block|{
name|dppBranches
operator|.
name|add
argument_list|(
name|currentOp
argument_list|)
expr_stmt|;
name|currentOp
operator|=
name|currentOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|dppBranches
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|gatherDPPBranchOps
parameter_list|(
name|ParseContext
name|pctx
parameter_list|,
name|SharedWorkOptimizerCache
name|optimizerCache
parameter_list|,
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|ops
parameter_list|,
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|discardedOps
parameter_list|)
block|{
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|dppBranches
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|ops
control|)
block|{
if|if
condition|(
name|op
operator|instanceof
name|TableScanOperator
condition|)
block|{
name|Collection
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|c
init|=
name|optimizerCache
operator|.
name|tableScanToDPPSource
operator|.
name|get
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|op
argument_list|)
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|dppSource
range|:
name|c
control|)
block|{
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|ascendants
init|=
name|findAscendantWorkOperators
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|dppSource
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Collections
operator|.
name|disjoint
argument_list|(
name|ascendants
argument_list|,
name|discardedOps
argument_list|)
condition|)
block|{
comment|// Remove branch
name|Operator
argument_list|<
name|?
argument_list|>
name|currentOp
init|=
name|dppSource
decl_stmt|;
while|while
condition|(
name|currentOp
operator|.
name|getNumChild
argument_list|()
operator|<=
literal|1
condition|)
block|{
name|dppBranches
operator|.
name|add
argument_list|(
name|currentOp
argument_list|)
expr_stmt|;
name|currentOp
operator|=
name|currentOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|dppBranches
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|compareAndGatherOps
parameter_list|(
name|ParseContext
name|pctx
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|op1
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|op2
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|boolean
name|mergeable
init|=
name|compareAndGatherOps
argument_list|(
name|pctx
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|result
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mergeable
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|boolean
name|compareAndGatherOps
parameter_list|(
name|ParseContext
name|pctx
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|op1
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|op2
parameter_list|,
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|result
parameter_list|,
name|boolean
name|gather
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|compareOperator
argument_list|(
name|pctx
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Operators not equal: {} and {}"
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|gather
operator|&&
name|op2
operator|.
name|getChildOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// If the second operator has more than one child, we stop gathering
name|gather
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|gather
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|op2
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|op1ParentOperators
init|=
name|op1
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|op2ParentOperators
init|=
name|op2
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
if|if
condition|(
name|op1ParentOperators
operator|!=
literal|null
operator|&&
name|op2ParentOperators
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|op1ParentOperators
operator|.
name|size
argument_list|()
operator|!=
name|op2ParentOperators
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|op1ParentOperators
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|op1ParentOp
init|=
name|op1ParentOperators
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|op2ParentOp
init|=
name|op2ParentOperators
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|boolean
name|mergeable
init|=
name|compareAndGatherOps
argument_list|(
name|pctx
argument_list|,
name|op1ParentOp
argument_list|,
name|op2ParentOp
argument_list|,
name|result
argument_list|,
name|gather
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mergeable
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|op1ParentOperators
operator|!=
literal|null
operator|||
name|op2ParentOperators
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|boolean
name|compareOperator
parameter_list|(
name|ParseContext
name|pctx
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|op1
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|op2
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|op1
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|op2
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// We handle ReduceSinkOperator here as we can safely ignore table alias
comment|// and the current comparator implementation does not.
comment|// We can ignore table alias since when we compare ReduceSinkOperator, all
comment|// its ancestors need to match (down to table scan), thus we make sure that
comment|// both plans are the same.
comment|// TODO: move this to logicalEquals
if|if
condition|(
name|op1
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|ReduceSinkDesc
name|op1Conf
init|=
operator|(
operator|(
name|ReduceSinkOperator
operator|)
name|op1
operator|)
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|ReduceSinkDesc
name|op2Conf
init|=
operator|(
operator|(
name|ReduceSinkOperator
operator|)
name|op2
operator|)
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|equals
argument_list|(
name|op1Conf
operator|.
name|getKeyColString
argument_list|()
argument_list|,
name|op2Conf
operator|.
name|getKeyColString
argument_list|()
argument_list|)
operator|&&
name|StringUtils
operator|.
name|equals
argument_list|(
name|op1Conf
operator|.
name|getValueColsString
argument_list|()
argument_list|,
name|op2Conf
operator|.
name|getValueColsString
argument_list|()
argument_list|)
operator|&&
name|StringUtils
operator|.
name|equals
argument_list|(
name|op1Conf
operator|.
name|getParitionColsString
argument_list|()
argument_list|,
name|op2Conf
operator|.
name|getParitionColsString
argument_list|()
argument_list|)
operator|&&
name|op1Conf
operator|.
name|getTag
argument_list|()
operator|==
name|op2Conf
operator|.
name|getTag
argument_list|()
operator|&&
name|StringUtils
operator|.
name|equals
argument_list|(
name|op1Conf
operator|.
name|getOrder
argument_list|()
argument_list|,
name|op2Conf
operator|.
name|getOrder
argument_list|()
argument_list|)
operator|&&
name|op1Conf
operator|.
name|getTopN
argument_list|()
operator|==
name|op2Conf
operator|.
name|getTopN
argument_list|()
operator|&&
name|op1Conf
operator|.
name|isAutoParallel
argument_list|()
operator|==
name|op2Conf
operator|.
name|isAutoParallel
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// We handle TableScanOperator here as we can safely ignore table alias
comment|// and the current comparator implementation does not.
comment|// TODO: move this to logicalEquals
if|if
condition|(
name|op1
operator|instanceof
name|TableScanOperator
condition|)
block|{
name|TableScanOperator
name|tsOp1
init|=
operator|(
name|TableScanOperator
operator|)
name|op1
decl_stmt|;
name|TableScanOperator
name|tsOp2
init|=
operator|(
name|TableScanOperator
operator|)
name|op2
decl_stmt|;
name|TableScanDesc
name|op1Conf
init|=
name|tsOp1
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|TableScanDesc
name|op2Conf
init|=
name|tsOp2
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|Table
name|tableMeta1
init|=
name|op1Conf
operator|.
name|getTableMetadata
argument_list|()
decl_stmt|;
name|Table
name|tableMeta2
init|=
name|op2Conf
operator|.
name|getTableMetadata
argument_list|()
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|equals
argument_list|(
name|tableMeta1
operator|.
name|getFullyQualifiedName
argument_list|()
argument_list|,
name|tableMeta2
operator|.
name|getFullyQualifiedName
argument_list|()
argument_list|)
operator|&&
name|op1Conf
operator|.
name|getNeededColumns
argument_list|()
operator|.
name|equals
argument_list|(
name|op2Conf
operator|.
name|getNeededColumns
argument_list|()
argument_list|)
operator|&&
name|StringUtils
operator|.
name|equals
argument_list|(
name|op1Conf
operator|.
name|getFilterExprString
argument_list|()
argument_list|,
name|op2Conf
operator|.
name|getFilterExprString
argument_list|()
argument_list|)
operator|&&
name|pctx
operator|.
name|getPrunedPartitions
argument_list|(
name|tsOp1
argument_list|)
operator|.
name|getPartitions
argument_list|()
operator|.
name|equals
argument_list|(
name|pctx
operator|.
name|getPrunedPartitions
argument_list|(
name|tsOp2
argument_list|)
operator|.
name|getPartitions
argument_list|()
argument_list|)
operator|&&
name|op1Conf
operator|.
name|getRowLimit
argument_list|()
operator|==
name|op2Conf
operator|.
name|getRowLimit
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
name|op1
operator|.
name|logicalEquals
argument_list|(
name|op2
argument_list|)
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|boolean
name|validPreConditions
parameter_list|(
name|ParseContext
name|pctx
parameter_list|,
name|SharedWorkOptimizerCache
name|optimizerCache
parameter_list|,
name|SharedResult
name|sr
parameter_list|)
block|{
comment|// We check whether merging the works would cause the size of
comment|// the data in memory grow too large.
comment|// TODO: Currently ignores GBY and PTF which may also buffer data in memory.
if|if
condition|(
name|sr
operator|.
name|dataSize
operator|>
name|sr
operator|.
name|maxDataSize
condition|)
block|{
comment|// Size surpasses limit, we cannot convert
name|LOG
operator|.
name|debug
argument_list|(
literal|"accumulated data size: {} / max size: {}"
argument_list|,
name|sr
operator|.
name|dataSize
argument_list|,
name|sr
operator|.
name|maxDataSize
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|Operator
argument_list|<
name|?
argument_list|>
name|op1
init|=
name|sr
operator|.
name|retainableOps
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|op2
init|=
name|sr
operator|.
name|discardableOps
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// 1) The set of operators in the works that we are merging need to meet
comment|// some requirements. In particular:
comment|// 1.1. None of the works that we are merging can contain a Union
comment|// operator. This is not supported yet as we might end up with cycles in
comment|// the Tez DAG.
comment|// 1.2. There cannot be more than one DummyStore operator in the new resulting
comment|// work when the operators are merged. This is due to an assumption in
comment|// MergeJoinProc that needs to be further explored.
comment|// If any of these conditions are not met, we cannot merge.
comment|// TODO: Extend rule so it can be applied for these cases.
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|workOps1
init|=
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|op1
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|workOps2
init|=
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|op2
argument_list|)
decl_stmt|;
name|boolean
name|foundDummyStoreOp
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|workOps1
control|)
block|{
if|if
condition|(
name|op
operator|instanceof
name|UnionOperator
condition|)
block|{
comment|// We cannot merge (1.1)
return|return
literal|false
return|;
block|}
if|if
condition|(
name|op
operator|instanceof
name|DummyStoreOperator
condition|)
block|{
name|foundDummyStoreOp
operator|=
literal|true
expr_stmt|;
block|}
block|}
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|workOps2
control|)
block|{
if|if
condition|(
name|op
operator|instanceof
name|UnionOperator
condition|)
block|{
comment|// We cannot merge (1.1)
return|return
literal|false
return|;
block|}
if|if
condition|(
name|foundDummyStoreOp
operator|&&
name|op
operator|instanceof
name|DummyStoreOperator
condition|)
block|{
comment|// We cannot merge (1.2)
return|return
literal|false
return|;
block|}
block|}
comment|// 2) We check whether output works when we merge the operators will collide.
comment|//
comment|//   Work1   Work2    (merge TS in W1& W2)        Work1
comment|//       \   /                  ->                  | |       X
comment|//       Work3                                     Work3
comment|//
comment|// If we do, we cannot merge. The reason is that Tez currently does
comment|// not support parallel edges, i.e., multiple edges from same work x
comment|// into same work y.
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|outputWorksOps1
init|=
name|findChildWorkOperators
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|op1
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|outputWorksOps2
init|=
name|findChildWorkOperators
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|op2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Collections
operator|.
name|disjoint
argument_list|(
name|outputWorksOps1
argument_list|,
name|outputWorksOps2
argument_list|)
condition|)
block|{
comment|// We cannot merge
return|return
literal|false
return|;
block|}
comment|// 3) We check whether we will end up with same operators inputing on same work.
comment|//
comment|//       Work1        (merge TS in W2& W3)        Work1
comment|//       /   \                  ->                  | |       X
comment|//   Work2   Work3                                 Work2
comment|//
comment|// If we do, we cannot merge. The reason is the same as above, currently
comment|// Tez does not support parallel edges.
comment|//
comment|// In the check, we exclude the inputs to the root operator that we are trying
comment|// to merge (only useful for extended merging as TS do not have inputs).
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|excludeOps1
init|=
name|sr
operator|.
name|retainableOps
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getNumParent
argument_list|()
operator|>
literal|0
condition|?
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|sr
operator|.
name|retainableOps
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getParentOperators
argument_list|()
argument_list|)
else|:
name|ImmutableSet
operator|.
name|of
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|inputWorksOps1
init|=
name|findParentWorkOperators
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|op1
argument_list|,
name|excludeOps1
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|excludeOps2
init|=
name|sr
operator|.
name|discardableOps
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getNumParent
argument_list|()
operator|>
literal|0
condition|?
name|Sets
operator|.
name|union
argument_list|(
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|sr
operator|.
name|discardableOps
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getParentOperators
argument_list|()
argument_list|)
argument_list|,
name|sr
operator|.
name|discardableInputOps
argument_list|)
else|:
name|sr
operator|.
name|discardableInputOps
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|inputWorksOps2
init|=
name|findParentWorkOperators
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|op2
argument_list|,
name|excludeOps2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Collections
operator|.
name|disjoint
argument_list|(
name|inputWorksOps1
argument_list|,
name|inputWorksOps2
argument_list|)
condition|)
block|{
comment|// We cannot merge
return|return
literal|false
return|;
block|}
comment|// 4) We check whether one of the operators is part of a work that is an input for
comment|// the work of the other operator.
comment|//
comment|//   Work1            (merge TS in W1& W3)        Work1
comment|//     |                        ->                   |        X
comment|//   Work2                                         Work2
comment|//     |                                             |
comment|//   Work3                                         Work1
comment|//
comment|// If we do, we cannot merge, as we would end up with a cycle in the DAG.
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|descendantWorksOps1
init|=
name|findDescendantWorkOperators
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|op1
argument_list|,
name|sr
operator|.
name|discardableInputOps
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|descendantWorksOps2
init|=
name|findDescendantWorkOperators
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|op2
argument_list|,
name|sr
operator|.
name|discardableInputOps
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Collections
operator|.
name|disjoint
argument_list|(
name|descendantWorksOps1
argument_list|,
name|workOps2
argument_list|)
operator|||
operator|!
name|Collections
operator|.
name|disjoint
argument_list|(
name|workOps1
argument_list|,
name|descendantWorksOps2
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|findParentWorkOperators
parameter_list|(
name|ParseContext
name|pctx
parameter_list|,
name|SharedWorkOptimizerCache
name|optimizerCache
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|start
parameter_list|)
block|{
return|return
name|findParentWorkOperators
argument_list|(
name|pctx
argument_list|,
name|optimizerCache
argument_list|,
name|start
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|findParentWorkOperators
parameter_list|(
name|ParseContext
name|pctx
parameter_list|,
name|SharedWorkOptimizerCache
name|optimizerCache
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|start
parameter_list|,
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|excludeOps
parameter_list|)
block|{
comment|// Find operators in work
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|workOps
init|=
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|start
argument_list|)
decl_stmt|;
comment|// Gather input works operators
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|workOps
control|)
block|{
if|if
condition|(
name|op
operator|.
name|getParentOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
range|:
name|op
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
if|if
condition|(
name|parent
operator|instanceof
name|ReduceSinkOperator
operator|&&
operator|!
name|excludeOps
operator|.
name|contains
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|instanceof
name|TableScanOperator
condition|)
block|{
comment|// Check for DPP and semijoin DPP
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
range|:
name|optimizerCache
operator|.
name|tableScanToDPPSource
operator|.
name|get
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|op
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|excludeOps
operator|.
name|contains
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|set
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|findAscendantWorkOperators
parameter_list|(
name|ParseContext
name|pctx
parameter_list|,
name|SharedWorkOptimizerCache
name|optimizerCache
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|start
parameter_list|)
block|{
comment|// Find operators in work
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|workOps
init|=
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|start
argument_list|)
decl_stmt|;
comment|// Gather input works operators
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|HashSet
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|set
decl_stmt|;
while|while
condition|(
operator|!
name|workOps
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|set
operator|=
operator|new
name|HashSet
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|workOps
control|)
block|{
if|if
condition|(
name|op
operator|.
name|getParentOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
range|:
name|op
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
if|if
condition|(
name|parent
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|instanceof
name|TableScanOperator
condition|)
block|{
comment|// Check for DPP and semijoin DPP
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
range|:
name|optimizerCache
operator|.
name|tableScanToDPPSource
operator|.
name|get
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|op
argument_list|)
control|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|workOps
operator|=
name|set
expr_stmt|;
name|result
operator|.
name|addAll
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|findChildWorkOperators
parameter_list|(
name|ParseContext
name|pctx
parameter_list|,
name|SharedWorkOptimizerCache
name|optimizerCache
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|start
parameter_list|)
block|{
comment|// Find operators in work
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|workOps
init|=
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|start
argument_list|)
decl_stmt|;
comment|// Gather output works operators
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|workOps
control|)
block|{
if|if
condition|(
name|op
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
if|if
condition|(
name|op
operator|.
name|getChildOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// All children of RS are descendants
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|child
range|:
name|op
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|child
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Semijoin DPP work is considered a child because work needs
comment|// to finish for it to execute
name|SemiJoinBranchInfo
name|sjbi
init|=
name|pctx
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|get
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|sjbi
operator|!=
literal|null
condition|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|sjbi
operator|.
name|getTsOp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|.
name|getConf
argument_list|()
operator|instanceof
name|DynamicPruningEventDesc
condition|)
block|{
comment|// DPP work is considered a child because work needs
comment|// to finish for it to execute
name|set
operator|.
name|addAll
argument_list|(
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
operator|(
operator|(
name|DynamicPruningEventDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
operator|)
operator|.
name|getTableScan
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|set
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|findDescendantWorkOperators
parameter_list|(
name|ParseContext
name|pctx
parameter_list|,
name|SharedWorkOptimizerCache
name|optimizerCache
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|start
parameter_list|,
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|excludeOps
parameter_list|)
block|{
comment|// Find operators in work
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|workOps
init|=
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|start
argument_list|)
decl_stmt|;
comment|// Gather output works operators
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|HashSet
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|set
decl_stmt|;
while|while
condition|(
operator|!
name|workOps
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|set
operator|=
operator|new
name|HashSet
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|workOps
control|)
block|{
if|if
condition|(
name|excludeOps
operator|.
name|contains
argument_list|(
name|op
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|op
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
if|if
condition|(
name|op
operator|.
name|getChildOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// All children of RS are descendants
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|child
range|:
name|op
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|child
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Semijoin DPP work is considered a descendant because work needs
comment|// to finish for it to execute
name|SemiJoinBranchInfo
name|sjbi
init|=
name|pctx
operator|.
name|getRsToSemiJoinBranchInfo
argument_list|()
operator|.
name|get
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|sjbi
operator|!=
literal|null
condition|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
name|sjbi
operator|.
name|getTsOp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|.
name|getConf
argument_list|()
operator|instanceof
name|DynamicPruningEventDesc
condition|)
block|{
comment|// DPP work is considered a descendant because work needs
comment|// to finish for it to execute
name|set
operator|.
name|addAll
argument_list|(
name|findWorkOperators
argument_list|(
name|optimizerCache
argument_list|,
operator|(
operator|(
name|DynamicPruningEventDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
operator|)
operator|.
name|getTableScan
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|workOps
operator|=
name|set
expr_stmt|;
name|result
operator|.
name|addAll
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|// Stores result in cache
end_comment

begin_function
specifier|private
specifier|static
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|findWorkOperators
parameter_list|(
name|SharedWorkOptimizerCache
name|optimizerCache
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|start
parameter_list|)
block|{
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|c
init|=
name|optimizerCache
operator|.
name|operatorToWorkOperators
operator|.
name|get
argument_list|(
name|start
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|c
return|;
block|}
name|c
operator|=
name|findWorkOperators
argument_list|(
name|start
argument_list|,
operator|new
name|HashSet
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|c
control|)
block|{
name|optimizerCache
operator|.
name|operatorToWorkOperators
operator|.
name|putAll
argument_list|(
name|op
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|findWorkOperators
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|start
parameter_list|,
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|found
parameter_list|)
block|{
name|found
operator|.
name|add
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|.
name|getParentOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
range|:
name|start
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
if|if
condition|(
name|parent
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|found
operator|.
name|contains
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|findWorkOperators
argument_list|(
name|parent
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|start
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
return|return
name|found
return|;
block|}
if|if
condition|(
name|start
operator|.
name|getChildOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|child
range|:
name|start
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|found
operator|.
name|contains
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|findWorkOperators
argument_list|(
name|child
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|found
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|void
name|pushFilterToTopOfTableScan
parameter_list|(
name|SharedWorkOptimizerCache
name|optimizerCache
parameter_list|,
name|TableScanOperator
name|tsOp
parameter_list|)
throws|throws
name|UDFArgumentException
block|{
name|ExprNodeGenericFuncDesc
name|tableScanExprNode
init|=
name|tsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getFilterExpr
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|allChildren
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|tsOp
operator|.
name|getChildOperators
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|allChildren
control|)
block|{
if|if
condition|(
name|op
operator|instanceof
name|FilterOperator
condition|)
block|{
name|FilterOperator
name|filterOp
init|=
operator|(
name|FilterOperator
operator|)
name|op
decl_stmt|;
name|ExprNodeDesc
name|filterExprNode
init|=
name|filterOp
operator|.
name|getConf
argument_list|()
operator|.
name|getPredicate
argument_list|()
decl_stmt|;
if|if
condition|(
name|tableScanExprNode
operator|.
name|isSame
argument_list|(
name|filterExprNode
argument_list|)
condition|)
block|{
comment|// We do not need to do anything
return|return;
block|}
if|if
condition|(
name|tableScanExprNode
operator|.
name|getGenericUDF
argument_list|()
operator|instanceof
name|GenericUDFOPOr
condition|)
block|{
for|for
control|(
name|ExprNodeDesc
name|childExprNode
range|:
name|tableScanExprNode
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
name|childExprNode
operator|.
name|isSame
argument_list|(
name|filterExprNode
argument_list|)
condition|)
block|{
comment|// We do not need to do anything, it is in the OR expression
comment|// so probably we pushed previously
return|return;
block|}
block|}
block|}
name|ExprNodeGenericFuncDesc
name|newPred
init|=
name|ExprNodeGenericFuncDesc
operator|.
name|newInstance
argument_list|(
operator|new
name|GenericUDFOPAnd
argument_list|()
argument_list|,
name|Arrays
operator|.
expr|<
name|ExprNodeDesc
operator|>
name|asList
argument_list|(
name|tableScanExprNode
operator|.
name|clone
argument_list|()
argument_list|,
name|filterExprNode
argument_list|)
argument_list|)
decl_stmt|;
name|filterOp
operator|.
name|getConf
argument_list|()
operator|.
name|setPredicate
argument_list|(
name|newPred
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Operator
argument_list|<
name|FilterDesc
argument_list|>
name|newOp
init|=
name|OperatorFactory
operator|.
name|get
argument_list|(
name|tsOp
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
operator|new
name|FilterDesc
argument_list|(
name|tableScanExprNode
operator|.
name|clone
argument_list|()
argument_list|,
literal|false
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|tsOp
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|tsOp
operator|.
name|replaceChild
argument_list|(
name|op
argument_list|,
name|newOp
argument_list|)
expr_stmt|;
name|newOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|add
argument_list|(
name|tsOp
argument_list|)
expr_stmt|;
name|op
operator|.
name|replaceParent
argument_list|(
name|tsOp
argument_list|,
name|newOp
argument_list|)
expr_stmt|;
name|newOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|// Add to cache (same group as tsOp)
name|optimizerCache
operator|.
name|putIfWorkExists
argument_list|(
name|newOp
argument_list|,
name|tsOp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_class
specifier|private
specifier|static
class|class
name|SharedResult
block|{
specifier|final
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|retainableOps
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|discardableOps
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|discardableInputOps
decl_stmt|;
specifier|final
name|long
name|dataSize
decl_stmt|;
specifier|final
name|long
name|maxDataSize
decl_stmt|;
specifier|private
name|SharedResult
parameter_list|(
name|Collection
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|retainableOps
parameter_list|,
name|Collection
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|discardableOps
parameter_list|,
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|discardableInputOps
parameter_list|,
name|long
name|dataSize
parameter_list|,
name|long
name|maxDataSize
parameter_list|)
block|{
name|this
operator|.
name|retainableOps
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|retainableOps
argument_list|)
expr_stmt|;
name|this
operator|.
name|discardableOps
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|discardableOps
argument_list|)
expr_stmt|;
name|this
operator|.
name|discardableInputOps
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|discardableInputOps
argument_list|)
expr_stmt|;
name|this
operator|.
name|dataSize
operator|=
name|dataSize
expr_stmt|;
name|this
operator|.
name|maxDataSize
operator|=
name|maxDataSize
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"SharedResult { "
operator|+
name|this
operator|.
name|retainableOps
operator|+
literal|"; "
operator|+
name|this
operator|.
name|discardableOps
operator|+
literal|"; "
operator|+
name|this
operator|.
name|discardableInputOps
operator|+
literal|"};"
return|;
block|}
block|}
end_class

begin_comment
comment|/** Cache to accelerate optimization */
end_comment

begin_class
specifier|private
specifier|static
class|class
name|SharedWorkOptimizerCache
block|{
comment|// Operators that belong to each work
specifier|final
name|HashMultimap
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|operatorToWorkOperators
init|=
name|HashMultimap
operator|.
expr|<
name|Operator
argument_list|<
name|?
argument_list|>
condition|,
name|Operator
argument_list|<
name|?
argument_list|>
operator|>
name|create
argument_list|()
decl_stmt|;
comment|// Table scan operators to DPP sources
specifier|final
name|Multimap
argument_list|<
name|TableScanOperator
argument_list|,
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|tableScanToDPPSource
init|=
name|HashMultimap
operator|.
expr|<
name|TableScanOperator
decl_stmt|,
name|Operator
argument_list|<
name|?
argument_list|>
decl|>
name|create
argument_list|()
decl_stmt|;
comment|// Add new operator to cache work group of existing operator (if group exists)
name|void
name|putIfWorkExists
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|opToAdd
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|existingOp
parameter_list|)
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|c
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operatorToWorkOperators
operator|.
name|get
argument_list|(
name|existingOp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|c
control|)
block|{
name|operatorToWorkOperators
operator|.
name|get
argument_list|(
name|op
argument_list|)
operator|.
name|add
argument_list|(
name|opToAdd
argument_list|)
expr_stmt|;
block|}
name|operatorToWorkOperators
operator|.
name|putAll
argument_list|(
name|opToAdd
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|operatorToWorkOperators
operator|.
name|put
argument_list|(
name|opToAdd
argument_list|,
name|opToAdd
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Remove operator
name|void
name|removeOp
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|opToRemove
parameter_list|)
block|{
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|s
init|=
name|operatorToWorkOperators
operator|.
name|get
argument_list|(
name|opToRemove
argument_list|)
decl_stmt|;
name|s
operator|.
name|remove
argument_list|(
name|opToRemove
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|c1
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c1
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op1
range|:
name|c1
control|)
block|{
name|operatorToWorkOperators
operator|.
name|remove
argument_list|(
name|op1
argument_list|,
name|opToRemove
argument_list|)
expr_stmt|;
comment|// Remove operator
block|}
name|operatorToWorkOperators
operator|.
name|removeAll
argument_list|(
name|opToRemove
argument_list|)
expr_stmt|;
comment|// Remove entry for operator
block|}
block|}
comment|// Remove operator and combine
name|void
name|removeOpAndCombineWork
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|opToRemove
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|replacementOp
parameter_list|)
block|{
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|s
init|=
name|operatorToWorkOperators
operator|.
name|get
argument_list|(
name|opToRemove
argument_list|)
decl_stmt|;
name|s
operator|.
name|remove
argument_list|(
name|opToRemove
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|c1
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|c2
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operatorToWorkOperators
operator|.
name|get
argument_list|(
name|replacementOp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c1
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|c2
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op1
range|:
name|c1
control|)
block|{
name|operatorToWorkOperators
operator|.
name|remove
argument_list|(
name|op1
argument_list|,
name|opToRemove
argument_list|)
expr_stmt|;
comment|// Remove operator
name|operatorToWorkOperators
operator|.
name|putAll
argument_list|(
name|op1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
comment|// Add ops of new collection
block|}
name|operatorToWorkOperators
operator|.
name|removeAll
argument_list|(
name|opToRemove
argument_list|)
expr_stmt|;
comment|// Remove entry for operator
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op2
range|:
name|c2
control|)
block|{
name|operatorToWorkOperators
operator|.
name|putAll
argument_list|(
name|op2
argument_list|,
name|c1
argument_list|)
expr_stmt|;
comment|// Add ops to existing collection
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"SharedWorkOptimizerCache { \n"
operator|+
name|operatorToWorkOperators
operator|.
name|toString
argument_list|()
operator|+
literal|"\n };"
return|;
block|}
block|}
end_class

unit|}
end_unit

