begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveParser
operator|.
name|TOK_DATABASELOCATION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveParser
operator|.
name|TOK_DATABASEPROPERTIES
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|CommonTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|Tree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|collections
operator|.
name|CollectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|StatsSetupConst
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|TableType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|Warehouse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Database
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|EnvironmentContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|MetaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Order
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLCheckConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLDefaultConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLForeignKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLNotNullConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLPrimaryKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLUniqueConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SkewedInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|WMMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|WMNullablePool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|WMNullableResourcePlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|WMPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|WMResourcePlanStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|WMTrigger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|hive_metastoreConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|utils
operator|.
name|MetaStoreUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|Driver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ErrorMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|QueryState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|DDLDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|DDLWork2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|database
operator|.
name|AlterDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|database
operator|.
name|CreateDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|database
operator|.
name|DescDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|database
operator|.
name|DropDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|database
operator|.
name|LockDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|database
operator|.
name|ShowCreateDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|database
operator|.
name|ShowDatabasesDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|database
operator|.
name|SwitchDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|database
operator|.
name|UnlockDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|function
operator|.
name|DescFunctionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|function
operator|.
name|ShowFunctionsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|misc
operator|.
name|CacheMetadataDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|misc
operator|.
name|MsckDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|misc
operator|.
name|ShowConfDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|privilege
operator|.
name|PrincipalDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|privilege
operator|.
name|ShowGrantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|privilege
operator|.
name|ShowPrincipalsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|privilege
operator|.
name|ShowRoleGrantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|privilege
operator|.
name|ShowRolesDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|process
operator|.
name|AbortTransactionsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|process
operator|.
name|KillQueriesDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|process
operator|.
name|ShowCompactionsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|process
operator|.
name|ShowTransactionsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|AbstractAlterTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|AlterTableType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|column
operator|.
name|AlterTableAddColumnsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|column
operator|.
name|AlterTableChangeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|column
operator|.
name|AlterTableReplaceColumnsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|column
operator|.
name|AlterTableUpdateColumnsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|column
operator|.
name|ShowColumnsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|constaint
operator|.
name|AlterTableAddConstraintDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|constaint
operator|.
name|AlterTableDropConstraintDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|constaint
operator|.
name|Constraints
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|creation
operator|.
name|DropTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|creation
operator|.
name|ShowCreateTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|info
operator|.
name|DescTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|info
operator|.
name|ShowTablePropertiesDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|info
operator|.
name|ShowTableStatusDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|info
operator|.
name|ShowTablesDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|lock
operator|.
name|LockTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|lock
operator|.
name|ShowLocksDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|lock
operator|.
name|UnlockTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|misc
operator|.
name|AlterTableRenameDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|misc
operator|.
name|AlterTableSetOwnerDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|misc
operator|.
name|AlterTableSetPropertiesDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|misc
operator|.
name|AlterTableTouchDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|misc
operator|.
name|AlterTableUnsetPropertiesDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|misc
operator|.
name|TruncateTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|partition
operator|.
name|AlterTableAddPartitionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|partition
operator|.
name|AlterTableAlterPartitionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|partition
operator|.
name|AlterTableDropPartitionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|partition
operator|.
name|AlterTableExchangePartitionsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|partition
operator|.
name|AlterTableRenamePartitionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|partition
operator|.
name|ShowPartitionsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|storage
operator|.
name|AlterTableArchiveDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|storage
operator|.
name|AlterTableClusteredByDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|storage
operator|.
name|AlterTableCompactDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|storage
operator|.
name|AlterTableIntoBucketsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|storage
operator|.
name|AlterTableNotClusteredDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|storage
operator|.
name|AlterTableNotSkewedDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|storage
operator|.
name|AlterTableNotSortedDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|storage
operator|.
name|AlterTableConcatenateDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|storage
operator|.
name|AlterTableSetFileFormatDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|storage
operator|.
name|AlterTableSetLocationDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|storage
operator|.
name|AlterTableSetSerdeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|storage
operator|.
name|AlterTableSetSerdePropsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|storage
operator|.
name|AlterTableSetSkewedLocationDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|storage
operator|.
name|AlterTableSkewedByDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|storage
operator|.
name|AlterTableUnarchiveDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|table
operator|.
name|partition
operator|.
name|AlterTableAddPartitionDesc
operator|.
name|PartitionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|view
operator|.
name|AlterMaterializedViewRewriteDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|workloadmanagement
operator|.
name|AlterPoolAddTriggerDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|workloadmanagement
operator|.
name|AlterPoolDropTriggerDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|workloadmanagement
operator|.
name|AlterResourcePlanDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|workloadmanagement
operator|.
name|AlterWMMappingDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|workloadmanagement
operator|.
name|AlterWMPoolDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|workloadmanagement
operator|.
name|AlterWMTriggerDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|workloadmanagement
operator|.
name|CreateResourcePlanDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|workloadmanagement
operator|.
name|CreateWMMappingDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|workloadmanagement
operator|.
name|CreateWMPoolDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|workloadmanagement
operator|.
name|CreateWMTriggerDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|workloadmanagement
operator|.
name|DropResourcePlanDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|workloadmanagement
operator|.
name|DropWMMappingDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|workloadmanagement
operator|.
name|DropWMPoolDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|workloadmanagement
operator|.
name|DropWMTriggerDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|workloadmanagement
operator|.
name|ShowResourcePlanDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ArchiveUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnStatsUpdateTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Task
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TaskFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|Entity
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|ReadEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|WriteEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|WriteEntity
operator|.
name|WriteType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|AcidUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|RCFileInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|orc
operator|.
name|OrcInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lockmgr
operator|.
name|HiveTxnManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lockmgr
operator|.
name|LockException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lockmgr
operator|.
name|TxnManagerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|DefaultConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Hive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|InvalidTableException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|NotNullConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Partition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|authorization
operator|.
name|AuthorizationParseUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|authorization
operator|.
name|HiveAuthorizationTaskFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|authorization
operator|.
name|HiveAuthorizationTaskFactoryImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|BasicStatsWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ColumnStatsUpdateWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DDLDesc
operator|.
name|DDLDescWithWriteId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|HiveOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ListBucketingCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|LoadTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MoveWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PlanUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|StatsWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ValidationUtility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|serdeConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorConverters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorConverters
operator|.
name|Converter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|CharTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|DecimalTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|PrimitiveTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TimestampLocalTZTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|VarcharTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|InputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * DDLSemanticAnalyzer.  *  */
end_comment

begin_class
specifier|public
class|class
name|DDLSemanticAnalyzer
extends|extends
name|BaseSemanticAnalyzer
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|DDLSemanticAnalyzer
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|TokenToTypeName
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|reservedPartitionValues
decl_stmt|;
specifier|private
specifier|final
name|HiveAuthorizationTaskFactory
name|hiveAuthorizationTaskFactory
decl_stmt|;
specifier|private
name|WriteEntity
name|alterTableOutput
decl_stmt|;
comment|// Equivalent to acidSinks, but for DDL operations that change data.
specifier|private
name|DDLDescWithWriteId
name|ddlDescWithWriteId
decl_stmt|;
static|static
block|{
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_BOOLEAN
argument_list|,
name|serdeConstants
operator|.
name|BOOLEAN_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_TINYINT
argument_list|,
name|serdeConstants
operator|.
name|TINYINT_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_SMALLINT
argument_list|,
name|serdeConstants
operator|.
name|SMALLINT_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_INT
argument_list|,
name|serdeConstants
operator|.
name|INT_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_BIGINT
argument_list|,
name|serdeConstants
operator|.
name|BIGINT_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_FLOAT
argument_list|,
name|serdeConstants
operator|.
name|FLOAT_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_DOUBLE
argument_list|,
name|serdeConstants
operator|.
name|DOUBLE_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_STRING
argument_list|,
name|serdeConstants
operator|.
name|STRING_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_CHAR
argument_list|,
name|serdeConstants
operator|.
name|CHAR_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_VARCHAR
argument_list|,
name|serdeConstants
operator|.
name|VARCHAR_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_BINARY
argument_list|,
name|serdeConstants
operator|.
name|BINARY_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_DATE
argument_list|,
name|serdeConstants
operator|.
name|DATE_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_DATETIME
argument_list|,
name|serdeConstants
operator|.
name|DATETIME_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_TIMESTAMP
argument_list|,
name|serdeConstants
operator|.
name|TIMESTAMP_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_TIMESTAMPLOCALTZ
argument_list|,
name|serdeConstants
operator|.
name|TIMESTAMPLOCALTZ_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_INTERVAL_YEAR_MONTH
argument_list|,
name|serdeConstants
operator|.
name|INTERVAL_YEAR_MONTH_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_INTERVAL_DAY_TIME
argument_list|,
name|serdeConstants
operator|.
name|INTERVAL_DAY_TIME_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_DECIMAL
argument_list|,
name|serdeConstants
operator|.
name|DECIMAL_TYPE_NAME
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|String
name|getTypeName
parameter_list|(
name|ASTNode
name|node
parameter_list|)
throws|throws
name|SemanticException
block|{
name|int
name|token
init|=
name|node
operator|.
name|getType
argument_list|()
decl_stmt|;
name|String
name|typeName
decl_stmt|;
comment|// datetime type isn't currently supported
if|if
condition|(
name|token
operator|==
name|HiveParser
operator|.
name|TOK_DATETIME
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UNSUPPORTED_TYPE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_CHAR
case|:
name|CharTypeInfo
name|charTypeInfo
init|=
name|ParseUtils
operator|.
name|getCharTypeInfo
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|typeName
operator|=
name|charTypeInfo
operator|.
name|getQualifiedName
argument_list|()
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_VARCHAR
case|:
name|VarcharTypeInfo
name|varcharTypeInfo
init|=
name|ParseUtils
operator|.
name|getVarcharTypeInfo
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|typeName
operator|=
name|varcharTypeInfo
operator|.
name|getQualifiedName
argument_list|()
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TIMESTAMPLOCALTZ
case|:
name|TimestampLocalTZTypeInfo
name|timestampLocalTZTypeInfo
init|=
name|TypeInfoFactory
operator|.
name|getTimestampTZTypeInfo
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|typeName
operator|=
name|timestampLocalTZTypeInfo
operator|.
name|getQualifiedName
argument_list|()
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DECIMAL
case|:
name|DecimalTypeInfo
name|decTypeInfo
init|=
name|ParseUtils
operator|.
name|getDecimalTypeTypeInfo
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|typeName
operator|=
name|decTypeInfo
operator|.
name|getQualifiedName
argument_list|()
expr_stmt|;
break|break;
default|default:
name|typeName
operator|=
name|TokenToTypeName
operator|.
name|get
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
return|return
name|typeName
return|;
block|}
specifier|public
name|DDLSemanticAnalyzer
parameter_list|(
name|QueryState
name|queryState
parameter_list|)
throws|throws
name|SemanticException
block|{
name|this
argument_list|(
name|queryState
argument_list|,
name|createHiveDB
argument_list|(
name|queryState
operator|.
name|getConf
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|DDLSemanticAnalyzer
parameter_list|(
name|QueryState
name|queryState
parameter_list|,
name|Hive
name|db
parameter_list|)
throws|throws
name|SemanticException
block|{
name|super
argument_list|(
name|queryState
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|reservedPartitionValues
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
comment|// Partition can't have this name
name|reservedPartitionValues
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|DEFAULTPARTITIONNAME
argument_list|)
argument_list|)
expr_stmt|;
name|reservedPartitionValues
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|DEFAULT_ZOOKEEPER_PARTITION_NAME
argument_list|)
argument_list|)
expr_stmt|;
comment|// Partition value can't end in this suffix
name|reservedPartitionValues
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|METASTORE_INT_ORIGINAL
argument_list|)
argument_list|)
expr_stmt|;
name|reservedPartitionValues
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|METASTORE_INT_ARCHIVED
argument_list|)
argument_list|)
expr_stmt|;
name|reservedPartitionValues
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|METASTORE_INT_EXTRACTED
argument_list|)
argument_list|)
expr_stmt|;
name|hiveAuthorizationTaskFactory
operator|=
name|createAuthorizationTaskFactory
argument_list|(
name|conf
argument_list|,
name|db
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|analyzeInternal
parameter_list|(
name|ASTNode
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|ast
init|=
name|input
decl_stmt|;
switch|switch
condition|(
name|ast
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_ALTERTABLE
case|:
block|{
name|ast
operator|=
operator|(
name|ASTNode
operator|)
name|input
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|String
index|[]
name|qualified
init|=
name|getQualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|input
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|// TODO CAT - for now always use the default catalog.  Eventually will want to see if
comment|// the user specified a catalog
name|String
name|catName
init|=
name|MetaStoreUtils
operator|.
name|getDefaultCatalog
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|String
name|tableName
init|=
name|getDotName
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
name|ASTNode
name|partSpecNode
init|=
operator|(
name|ASTNode
operator|)
name|input
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|partSpecNode
operator|!=
literal|null
condition|)
block|{
comment|//  We can use alter table partition rename to convert/normalize the legacy partition
comment|//  column values. In so, we should not enable the validation to the old partition spec
comment|//  passed in this command.
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_RENAMEPART
condition|)
block|{
name|partSpec
operator|=
name|getPartSpec
argument_list|(
name|partSpecNode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|partSpec
operator|=
name|getValidatedPartSpec
argument_list|(
name|getTable
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|partSpecNode
argument_list|,
name|conf
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_RENAME
condition|)
block|{
name|analyzeAlterTableRename
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_TOUCH
condition|)
block|{
name|analyzeAlterTableTouch
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_ARCHIVE
condition|)
block|{
name|analyzeAlterTableArchive
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_UNARCHIVE
condition|)
block|{
name|analyzeAlterTableArchive
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_ADDCOLS
condition|)
block|{
name|analyzeAlterTableAddCols
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_REPLACECOLS
condition|)
block|{
name|analyzeAlterTableReplaceCols
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_RENAMECOL
condition|)
block|{
name|analyzeAlterTableRenameCol
argument_list|(
name|catName
argument_list|,
name|qualified
argument_list|,
name|ast
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_ADDPARTS
condition|)
block|{
name|analyzeAlterTableAddParts
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_DROPPARTS
condition|)
block|{
name|analyzeAlterTableDropParts
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_PARTCOLTYPE
condition|)
block|{
name|analyzeAlterTablePartColType
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_PROPERTIES
condition|)
block|{
name|analyzeAlterTableProps
argument_list|(
name|qualified
argument_list|,
literal|null
argument_list|,
name|ast
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_DROPPROPERTIES
condition|)
block|{
name|analyzeAlterTableProps
argument_list|(
name|qualified
argument_list|,
literal|null
argument_list|,
name|ast
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_UPDATESTATS
condition|)
block|{
name|analyzeAlterTableProps
argument_list|(
name|qualified
argument_list|,
name|partSpec
argument_list|,
name|ast
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_SKEWED
condition|)
block|{
name|analyzeAlterTableSkewedby
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_EXCHANGEPARTITION
condition|)
block|{
name|analyzeExchangePartition
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_FILEFORMAT
condition|)
block|{
name|analyzeAlterTableFileFormat
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_LOCATION
condition|)
block|{
name|analyzeAlterTableLocation
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_MERGEFILES
condition|)
block|{
name|analyzeAlterTablePartMergeFiles
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_SERIALIZER
condition|)
block|{
name|analyzeAlterTableSerde
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_SERDEPROPERTIES
condition|)
block|{
name|analyzeAlterTableSerdeProps
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_RENAMEPART
condition|)
block|{
name|analyzeAlterTableRenamePart
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_SKEWED_LOCATION
condition|)
block|{
name|analyzeAlterTableSkewedLocation
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_BUCKETS
condition|)
block|{
name|analyzeAlterTableBucketNum
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_CLUSTER_SORT
condition|)
block|{
name|analyzeAlterTableClusterSort
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_COMPACT
condition|)
block|{
name|analyzeAlterTableCompact
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_UPDATECOLSTATS
condition|)
block|{
name|analyzeAlterTableUpdateStats
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_DROPCONSTRAINT
condition|)
block|{
name|analyzeAlterTableDropConstraint
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_ADDCONSTRAINT
condition|)
block|{
name|analyzeAlterTableAddConstraint
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_UPDATECOLUMNS
condition|)
block|{
name|analyzeAlterTableUpdateColumns
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_OWNER
condition|)
block|{
name|analyzeAlterTableOwner
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|HiveParser
operator|.
name|TOK_DROPTABLE
case|:
name|analyzeDropTable
argument_list|(
name|ast
argument_list|,
literal|null
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TRUNCATETABLE
case|:
name|analyzeTruncateTable
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DESCTABLE
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeDescribeTable
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOWDATABASES
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowDatabases
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOWTABLES
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowTables
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOWCOLUMNS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowColumns
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_TABLESTATUS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowTableStatus
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_TBLPROPERTIES
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowTableProperties
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOWFUNCTIONS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowFunctions
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOWLOCKS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowLocks
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOWDBLOCKS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowDbLocks
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_COMPACTIONS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowCompactions
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_TRANSACTIONS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowTxns
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ABORT_TRANSACTIONS
case|:
name|analyzeAbortTxns
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_KILL_QUERY
case|:
name|analyzeKillQuery
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOWCONF
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowConf
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOWVIEWS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowViews
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOWMATERIALIZEDVIEWS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowMaterializedViews
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DESCFUNCTION
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeDescFunction
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DESCDATABASE
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeDescDatabase
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_MSCK
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeMetastoreCheck
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DROPVIEW
case|:
name|analyzeDropTable
argument_list|(
name|ast
argument_list|,
name|TableType
operator|.
name|VIRTUAL_VIEW
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DROP_MATERIALIZED_VIEW
case|:
name|analyzeDropTable
argument_list|(
name|ast
argument_list|,
name|TableType
operator|.
name|MATERIALIZED_VIEW
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERVIEW
case|:
block|{
name|String
index|[]
name|qualified
init|=
name|getQualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|ast
operator|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERVIEW_PROPERTIES
condition|)
block|{
name|analyzeAlterTableProps
argument_list|(
name|qualified
argument_list|,
literal|null
argument_list|,
name|ast
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERVIEW_DROPPROPERTIES
condition|)
block|{
name|analyzeAlterTableProps
argument_list|(
name|qualified
argument_list|,
literal|null
argument_list|,
name|ast
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERVIEW_ADDPARTS
condition|)
block|{
name|analyzeAlterTableAddParts
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERVIEW_DROPPARTS
condition|)
block|{
name|analyzeAlterTableDropParts
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERVIEW_RENAME
condition|)
block|{
name|analyzeAlterTableRename
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|HiveParser
operator|.
name|TOK_ALTER_MATERIALIZED_VIEW
case|:
block|{
name|ast
operator|=
operator|(
name|ASTNode
operator|)
name|input
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|String
index|[]
name|qualified
init|=
name|getQualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|input
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|tableName
init|=
name|getDotName
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTER_MATERIALIZED_VIEW_REWRITE
condition|)
block|{
name|analyzeAlterMaterializedViewRewrite
argument_list|(
name|tableName
argument_list|,
name|ast
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|HiveParser
operator|.
name|TOK_SHOWPARTITIONS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowPartitions
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_CREATEDATABASE
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowCreateDatabase
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_CREATETABLE
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowCreateTable
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_LOCKTABLE
case|:
name|analyzeLockTable
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_UNLOCKTABLE
case|:
name|analyzeUnlockTable
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_LOCKDB
case|:
name|analyzeLockDatabase
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_UNLOCKDB
case|:
name|analyzeUnlockDatabase
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_CREATEDATABASE
case|:
name|analyzeCreateDatabase
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DROPDATABASE
case|:
name|analyzeDropDatabase
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SWITCHDATABASE
case|:
name|analyzeSwitchDatabase
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERDATABASE_PROPERTIES
case|:
name|analyzeAlterDatabaseProperties
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERDATABASE_OWNER
case|:
name|analyzeAlterDatabaseOwner
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERDATABASE_LOCATION
case|:
name|analyzeAlterDatabaseLocation
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_CREATEROLE
case|:
name|analyzeCreateRole
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DROPROLE
case|:
name|analyzeDropRole
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_ROLE_GRANT
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowRoleGrant
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_ROLE_PRINCIPALS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowRolePrincipals
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_ROLES
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowRoles
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_GRANT_ROLE
case|:
name|analyzeGrantRevokeRole
argument_list|(
literal|true
argument_list|,
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_REVOKE_ROLE
case|:
name|analyzeGrantRevokeRole
argument_list|(
literal|false
argument_list|,
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_GRANT
case|:
name|analyzeGrant
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_GRANT
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowGrant
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_REVOKE
case|:
name|analyzeRevoke
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_SET_ROLE
case|:
name|analyzeSetShowRole
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_CACHE_METADATA
case|:
name|analyzeCacheMetadata
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_CREATE_RP
case|:
name|analyzeCreateResourcePlan
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_RP
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowResourcePlan
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTER_RP
case|:
name|analyzeAlterResourcePlan
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DROP_RP
case|:
name|analyzeDropResourcePlan
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_CREATE_TRIGGER
case|:
name|analyzeCreateTrigger
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTER_TRIGGER
case|:
name|analyzeAlterTrigger
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DROP_TRIGGER
case|:
name|analyzeDropTrigger
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_CREATE_POOL
case|:
name|analyzeCreatePool
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTER_POOL
case|:
name|analyzeAlterPool
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DROP_POOL
case|:
name|analyzeDropPool
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_CREATE_MAPPING
case|:
name|analyzeCreateOrAlterMapping
argument_list|(
name|ast
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTER_MAPPING
case|:
name|analyzeCreateOrAlterMapping
argument_list|(
name|ast
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DROP_MAPPING
case|:
name|analyzeDropMapping
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unsupported command: "
operator|+
name|ast
argument_list|)
throw|;
block|}
if|if
condition|(
name|fetchTask
operator|!=
literal|null
operator|&&
operator|!
name|rootTasks
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|rootTasks
operator|.
name|get
argument_list|(
name|rootTasks
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|setFetchSource
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeCacheMetadata
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Table
name|tbl
init|=
name|AnalyzeCommandUtils
operator|.
name|getTable
argument_list|(
name|ast
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
name|CacheMetadataDesc
name|desc
decl_stmt|;
comment|// In 2 cases out of 3, we could pass the path and type directly to metastore...
if|if
condition|(
name|AnalyzeCommandUtils
operator|.
name|isPartitionLevelStats
argument_list|(
name|ast
argument_list|)
condition|)
block|{
name|partSpec
operator|=
name|AnalyzeCommandUtils
operator|.
name|getPartKeyValuePairsFromAST
argument_list|(
name|tbl
argument_list|,
name|ast
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|Partition
name|part
init|=
name|getPartition
argument_list|(
name|tbl
argument_list|,
name|partSpec
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|desc
operator|=
operator|new
name|CacheMetadataDesc
argument_list|(
name|tbl
operator|.
name|getDbName
argument_list|()
argument_list|,
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|,
name|part
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|part
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Should we get all partitions for a partitioned table?
name|desc
operator|=
operator|new
name|CacheMetadataDesc
argument_list|(
name|tbl
operator|.
name|getDbName
argument_list|()
argument_list|,
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|,
name|tbl
operator|.
name|isPartitioned
argument_list|()
argument_list|)
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tbl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|desc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableUpdateStats
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tblName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|colName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapProp
init|=
name|getProps
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|Table
name|tbl
init|=
name|getTable
argument_list|(
name|tblName
argument_list|)
decl_stmt|;
name|String
name|partName
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|partSpec
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|partName
operator|=
name|Warehouse
operator|.
name|makePartName
argument_list|(
name|partSpec
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MetaException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"partition "
operator|+
name|partSpec
operator|.
name|toString
argument_list|()
operator|+
literal|" not found"
argument_list|)
throw|;
block|}
block|}
name|String
name|colType
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|cols
init|=
name|tbl
operator|.
name|getCols
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldSchema
name|col
range|:
name|cols
control|)
block|{
if|if
condition|(
name|colName
operator|.
name|equalsIgnoreCase
argument_list|(
name|col
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|colType
operator|=
name|col
operator|.
name|getType
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|colType
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"column type not found"
argument_list|)
throw|;
block|}
name|ColumnStatsUpdateWork
name|columnStatsUpdateWork
init|=
operator|new
name|ColumnStatsUpdateWork
argument_list|(
name|partName
argument_list|,
name|mapProp
argument_list|,
name|tbl
operator|.
name|getDbName
argument_list|()
argument_list|,
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|,
name|colName
argument_list|,
name|colType
argument_list|)
decl_stmt|;
name|ColumnStatsUpdateTask
name|cStatsUpdateTask
init|=
operator|(
name|ColumnStatsUpdateTask
operator|)
name|TaskFactory
operator|.
name|get
argument_list|(
name|columnStatsUpdateWork
argument_list|)
decl_stmt|;
comment|// TODO: doesn't look like this path is actually ever exercised. Maybe this needs to be removed.
name|addInputsOutputsAlterTable
argument_list|(
name|tblName
argument_list|,
name|partSpec
argument_list|,
literal|null
argument_list|,
name|AlterTableType
operator|.
name|UPDATESTATS
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|AcidUtils
operator|.
name|isTransactionalTable
argument_list|(
name|tbl
argument_list|)
condition|)
block|{
name|setAcidDdlDesc
argument_list|(
name|columnStatsUpdateWork
argument_list|)
expr_stmt|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|cStatsUpdateTask
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeSetShowRole
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
switch|switch
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|hiveAuthorizationTaskFactory
operator|.
name|createShowCurrentRoleTask
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|ShowRolesDesc
operator|.
name|SCHEMA
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|rootTasks
operator|.
name|add
argument_list|(
name|hiveAuthorizationTaskFactory
operator|.
name|createSetRoleTask
argument_list|(
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Internal error. ASTNode expected to have 0 or 1 child. "
operator|+
name|ast
operator|.
name|dump
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|analyzeGrantRevokeRole
parameter_list|(
name|boolean
name|grant
parameter_list|,
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Task
argument_list|<
name|?
argument_list|>
name|task
decl_stmt|;
if|if
condition|(
name|grant
condition|)
block|{
name|task
operator|=
name|hiveAuthorizationTaskFactory
operator|.
name|createGrantRoleTask
argument_list|(
name|ast
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|task
operator|=
name|hiveAuthorizationTaskFactory
operator|.
name|createRevokeRoleTask
argument_list|(
name|ast
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|task
operator|!=
literal|null
condition|)
block|{
name|rootTasks
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeShowGrant
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Task
argument_list|<
name|?
argument_list|>
name|task
init|=
name|hiveAuthorizationTaskFactory
operator|.
name|createShowGrantTask
argument_list|(
name|ast
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|task
operator|!=
literal|null
condition|)
block|{
name|rootTasks
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|ShowGrantDesc
operator|.
name|SCHEMA
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeGrant
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Task
argument_list|<
name|?
argument_list|>
name|task
init|=
name|hiveAuthorizationTaskFactory
operator|.
name|createGrantTask
argument_list|(
name|ast
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|task
operator|!=
literal|null
condition|)
block|{
name|rootTasks
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeRevoke
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Task
argument_list|<
name|?
argument_list|>
name|task
init|=
name|hiveAuthorizationTaskFactory
operator|.
name|createRevokeTask
argument_list|(
name|ast
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|task
operator|!=
literal|null
condition|)
block|{
name|rootTasks
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeCreateRole
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Task
argument_list|<
name|?
argument_list|>
name|task
init|=
name|hiveAuthorizationTaskFactory
operator|.
name|createCreateRoleTask
argument_list|(
name|ast
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|task
operator|!=
literal|null
condition|)
block|{
name|rootTasks
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeDropRole
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Task
argument_list|<
name|?
argument_list|>
name|task
init|=
name|hiveAuthorizationTaskFactory
operator|.
name|createDropRoleTask
argument_list|(
name|ast
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|task
operator|!=
literal|null
condition|)
block|{
name|rootTasks
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeShowRoleGrant
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Task
argument_list|<
name|?
argument_list|>
name|task
init|=
name|hiveAuthorizationTaskFactory
operator|.
name|createShowRoleGrantTask
argument_list|(
name|ast
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|task
operator|!=
literal|null
condition|)
block|{
name|rootTasks
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|ShowRoleGrantDesc
operator|.
name|SCHEMA
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeShowRolePrincipals
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Task
argument_list|<
name|?
argument_list|>
name|roleDDLTask
init|=
operator|(
name|Task
argument_list|<
name|?
argument_list|>
operator|)
name|hiveAuthorizationTaskFactory
operator|.
name|createShowRolePrincipalsTask
argument_list|(
name|ast
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|roleDDLTask
operator|!=
literal|null
condition|)
block|{
name|rootTasks
operator|.
name|add
argument_list|(
name|roleDDLTask
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|ShowPrincipalsDesc
operator|.
name|SCHEMA
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeShowRoles
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Task
argument_list|<
name|DDLWork2
argument_list|>
name|roleDDLTask
init|=
operator|(
name|Task
argument_list|<
name|DDLWork2
argument_list|>
operator|)
name|hiveAuthorizationTaskFactory
operator|.
name|createShowRolesTask
argument_list|(
name|ast
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|roleDDLTask
operator|!=
literal|null
condition|)
block|{
name|rootTasks
operator|.
name|add
argument_list|(
name|roleDDLTask
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|ShowRolesDesc
operator|.
name|SCHEMA
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeAlterDatabaseProperties
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|dbName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|dbProps
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|childNode
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|childNode
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_DATABASEPROPERTIES
case|:
name|dbProps
operator|=
name|DDLSemanticAnalyzer
operator|.
name|getProps
argument_list|(
operator|(
name|ASTNode
operator|)
name|childNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unrecognized token in CREATE DATABASE statement"
argument_list|)
throw|;
block|}
block|}
name|AlterDatabaseDesc
name|alterDesc
init|=
operator|new
name|AlterDatabaseDesc
argument_list|(
name|dbName
argument_list|,
name|dbProps
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|addAlterDbDesc
argument_list|(
name|alterDesc
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addAlterDbDesc
parameter_list|(
name|AlterDatabaseDesc
name|alterDesc
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Database
name|database
init|=
name|getDatabase
argument_list|(
name|alterDesc
operator|.
name|getDatabaseName
argument_list|()
argument_list|)
decl_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|database
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_NO_LOCK
argument_list|)
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterDatabaseOwner
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|dbName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|PrincipalDesc
name|principalDesc
init|=
name|AuthorizationParseUtils
operator|.
name|getPrincipalDesc
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|// The syntax should not allow these fields to be null, but lets verify
name|String
name|nullCmdMsg
init|=
literal|"can't be null in alter database set owner command"
decl_stmt|;
if|if
condition|(
name|principalDesc
operator|.
name|getName
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Owner name "
operator|+
name|nullCmdMsg
argument_list|)
throw|;
block|}
if|if
condition|(
name|principalDesc
operator|.
name|getType
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Owner type "
operator|+
name|nullCmdMsg
argument_list|)
throw|;
block|}
name|AlterDatabaseDesc
name|alterDesc
init|=
operator|new
name|AlterDatabaseDesc
argument_list|(
name|dbName
argument_list|,
name|principalDesc
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|addAlterDbDesc
argument_list|(
name|alterDesc
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterDatabaseLocation
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|dbName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|newLocation
init|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|addLocationToOutputs
argument_list|(
name|newLocation
argument_list|)
expr_stmt|;
name|AlterDatabaseDesc
name|alterDesc
init|=
operator|new
name|AlterDatabaseDesc
argument_list|(
name|dbName
argument_list|,
name|newLocation
argument_list|)
decl_stmt|;
name|addAlterDbDesc
argument_list|(
name|alterDesc
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeExchangePartition
parameter_list|(
name|String
index|[]
name|qualified
parameter_list|,
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Table
name|destTable
init|=
name|getTable
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|Table
name|sourceTable
init|=
name|getTable
argument_list|(
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|// Get the partition specs
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpecs
init|=
name|getValidatedPartSpec
argument_list|(
name|sourceTable
argument_list|,
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|conf
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|validatePartitionValues
argument_list|(
name|partSpecs
argument_list|)
expr_stmt|;
name|boolean
name|sameColumns
init|=
name|MetaStoreUtils
operator|.
name|compareFieldColumns
argument_list|(
name|destTable
operator|.
name|getAllCols
argument_list|()
argument_list|,
name|sourceTable
operator|.
name|getAllCols
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|samePartitions
init|=
name|MetaStoreUtils
operator|.
name|compareFieldColumns
argument_list|(
name|destTable
operator|.
name|getPartitionKeys
argument_list|()
argument_list|,
name|sourceTable
operator|.
name|getPartitionKeys
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sameColumns
operator|||
operator|!
name|samePartitions
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TABLES_INCOMPATIBLE_SCHEMAS
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
comment|// Exchange partition is not allowed with transactional tables.
comment|// If only source is transactional table, then target will see deleted rows too as no snapshot
comment|// isolation applicable for non-acid tables.
comment|// If only target is transactional table, then data would be visible to all ongoing transactions
comment|// affecting the snapshot isolation.
comment|// If both source and targets are transactional tables, then target partition may have delta/base
comment|// files with write IDs may not be valid. It may affect snapshot isolation for on-going txns as well.
if|if
condition|(
name|AcidUtils
operator|.
name|isTransactionalTable
argument_list|(
name|sourceTable
argument_list|)
operator|||
name|AcidUtils
operator|.
name|isTransactionalTable
argument_list|(
name|destTable
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|EXCHANGE_PARTITION_NOT_ALLOWED_WITH_TRANSACTIONAL_TABLES
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
comment|// check if source partition exists
name|getPartitions
argument_list|(
name|sourceTable
argument_list|,
name|partSpecs
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Verify that the partitions specified are continuous
comment|// If a subpartition value is specified without specifying a partition's value
comment|// then we throw an exception
name|int
name|counter
init|=
name|isPartitionValueContinuous
argument_list|(
name|sourceTable
operator|.
name|getPartitionKeys
argument_list|()
argument_list|,
name|partSpecs
argument_list|)
decl_stmt|;
if|if
condition|(
name|counter
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|PARTITION_VALUE_NOT_CONTINUOUS
operator|.
name|getMsg
argument_list|(
name|partSpecs
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|Partition
argument_list|>
name|destPartitions
init|=
literal|null
decl_stmt|;
try|try
block|{
name|destPartitions
operator|=
name|getPartitions
argument_list|(
name|destTable
argument_list|,
name|partSpecs
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|ex
parameter_list|)
block|{
comment|// We should expect a semantic exception being throw as this partition
comment|// should not be present.
block|}
if|if
condition|(
name|destPartitions
operator|!=
literal|null
condition|)
block|{
comment|// If any destination partition is present then throw a Semantic Exception.
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|PARTITION_EXISTS
operator|.
name|getMsg
argument_list|(
name|destPartitions
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|AlterTableExchangePartitionsDesc
name|alterTableExchangePartition
init|=
operator|new
name|AlterTableExchangePartitionsDesc
argument_list|(
name|sourceTable
argument_list|,
name|destTable
argument_list|,
name|partSpecs
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTableExchangePartition
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|sourceTable
argument_list|)
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|destTable
argument_list|,
name|WriteType
operator|.
name|DDL_SHARED
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param partitionKeys the list of partition keys of the table    * @param partSpecs the partition specs given by the user    * @return>=0 if no subpartition value is specified without a partition's    *         value being specified else it returns -1    */
specifier|private
name|int
name|isPartitionValueContinuous
parameter_list|(
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|partitionKeys
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpecs
parameter_list|)
block|{
name|int
name|counter
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FieldSchema
name|partitionKey
range|:
name|partitionKeys
control|)
block|{
if|if
condition|(
name|partSpecs
operator|.
name|containsKey
argument_list|(
name|partitionKey
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|counter
operator|++
expr_stmt|;
continue|continue;
block|}
return|return
name|partSpecs
operator|.
name|size
argument_list|()
operator|==
name|counter
condition|?
name|counter
else|:
operator|-
literal|1
return|;
block|}
return|return
name|counter
return|;
block|}
specifier|private
name|void
name|analyzeCreateResourcePlan
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Expected name in CREATE RESOURCE PLAN statement"
argument_list|)
throw|;
block|}
name|String
name|resourcePlanName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|Integer
name|queryParallelism
init|=
literal|null
decl_stmt|;
name|String
name|likeName
init|=
literal|null
decl_stmt|;
name|boolean
name|ifNotExists
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Tree
name|child
init|=
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|child
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_QUERY_PARALLELISM
case|:
comment|// Note: later we may be able to set multiple things together (except LIKE).
if|if
condition|(
name|queryParallelism
operator|==
literal|null
operator|&&
name|likeName
operator|==
literal|null
condition|)
block|{
name|queryParallelism
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Conflicting create arguments "
operator|+
name|ast
operator|.
name|toStringTree
argument_list|()
argument_list|)
throw|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_LIKERP
case|:
if|if
condition|(
name|queryParallelism
operator|==
literal|null
operator|&&
name|likeName
operator|==
literal|null
condition|)
block|{
name|likeName
operator|=
name|unescapeIdentifier
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Conflicting create arguments "
operator|+
name|ast
operator|.
name|toStringTree
argument_list|()
argument_list|)
throw|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_IFNOTEXISTS
case|:
name|ifNotExists
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Invalid create arguments "
operator|+
name|ast
operator|.
name|toStringTree
argument_list|()
argument_list|)
throw|;
block|}
block|}
name|CreateResourcePlanDesc
name|desc
init|=
operator|new
name|CreateResourcePlanDesc
argument_list|(
name|resourcePlanName
argument_list|,
name|queryParallelism
argument_list|,
name|likeName
argument_list|,
name|ifNotExists
argument_list|)
decl_stmt|;
name|addServiceOutput
argument_list|()
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|desc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowResourcePlan
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|rpName
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|rpName
operator|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Invalid syntax for SHOW RESOURCE PLAN statement"
argument_list|)
throw|;
block|}
name|ShowResourcePlanDesc
name|showResourcePlanDesc
init|=
operator|new
name|ShowResourcePlanDesc
argument_list|(
name|rpName
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|addServiceOutput
argument_list|()
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showResourcePlanDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showResourcePlanDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterResourcePlan
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Incorrect syntax"
argument_list|)
throw|;
block|}
name|Tree
name|nameOrGlobal
init|=
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|nameOrGlobal
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_ENABLE
case|:
comment|// This command exists solely to output this message. TODO: can we do it w/o an error?
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Activate a resource plan to enable workload management"
argument_list|)
throw|;
case|case
name|HiveParser
operator|.
name|TOK_DISABLE
case|:
name|WMNullableResourcePlan
name|anyRp
init|=
operator|new
name|WMNullableResourcePlan
argument_list|()
decl_stmt|;
name|anyRp
operator|.
name|setStatus
argument_list|(
name|WMResourcePlanStatus
operator|.
name|ENABLED
argument_list|)
expr_stmt|;
name|AlterResourcePlanDesc
name|desc
init|=
operator|new
name|AlterResourcePlanDesc
argument_list|(
name|anyRp
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|addServiceOutput
argument_list|()
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|desc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|// Continue to handle changes to a specific plan.
block|}
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Invalid syntax for ALTER RESOURCE PLAN statement"
argument_list|)
throw|;
block|}
name|String
name|rpName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|WMNullableResourcePlan
name|resourcePlan
init|=
operator|new
name|WMNullableResourcePlan
argument_list|()
decl_stmt|;
name|boolean
name|isEnableActivate
init|=
literal|false
decl_stmt|,
name|isReplace
init|=
literal|false
decl_stmt|;
name|boolean
name|validate
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Tree
name|child
init|=
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|child
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_VALIDATE
case|:
name|validate
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ACTIVATE
case|:
if|if
condition|(
name|resourcePlan
operator|.
name|getStatus
argument_list|()
operator|==
name|WMResourcePlanStatus
operator|.
name|ENABLED
condition|)
block|{
name|isEnableActivate
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Expected 0 or 1 arguments "
operator|+
name|ast
operator|.
name|toStringTree
argument_list|()
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_REPLACE
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Incorrect syntax "
operator|+
name|ast
operator|.
name|toStringTree
argument_list|()
argument_list|)
throw|;
block|}
name|isReplace
operator|=
literal|true
expr_stmt|;
name|isEnableActivate
operator|=
literal|false
expr_stmt|;
comment|// Implied.
block|}
name|resourcePlan
operator|.
name|setStatus
argument_list|(
name|WMResourcePlanStatus
operator|.
name|ACTIVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ENABLE
case|:
if|if
condition|(
name|resourcePlan
operator|.
name|getStatus
argument_list|()
operator|==
name|WMResourcePlanStatus
operator|.
name|ACTIVE
condition|)
block|{
name|isEnableActivate
operator|=
operator|!
name|isReplace
expr_stmt|;
block|}
else|else
block|{
name|resourcePlan
operator|.
name|setStatus
argument_list|(
name|WMResourcePlanStatus
operator|.
name|ENABLED
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DISABLE
case|:
name|resourcePlan
operator|.
name|setStatus
argument_list|(
name|WMResourcePlanStatus
operator|.
name|DISABLED
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_REPLACE
case|:
name|isReplace
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Expected 0 or 1 arguments "
operator|+
name|ast
operator|.
name|toStringTree
argument_list|()
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// Replace is essentially renaming a plan to the name of an existing plan, with backup.
name|resourcePlan
operator|.
name|setName
argument_list|(
name|unescapeIdentifier
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|resourcePlan
operator|.
name|setStatus
argument_list|(
name|WMResourcePlanStatus
operator|.
name|ACTIVE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_QUERY_PARALLELISM
case|:
block|{
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Expected one argument"
argument_list|)
throw|;
block|}
name|Tree
name|val
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|resourcePlan
operator|.
name|setIsSetQueryParallelism
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_NULL
condition|)
block|{
name|resourcePlan
operator|.
name|unsetQueryParallelism
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|resourcePlan
operator|.
name|setQueryParallelism
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|val
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|HiveParser
operator|.
name|TOK_DEFAULT_POOL
case|:
block|{
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Expected one argument"
argument_list|)
throw|;
block|}
name|Tree
name|val
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|resourcePlan
operator|.
name|setIsSetDefaultPoolPath
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_NULL
condition|)
block|{
name|resourcePlan
operator|.
name|unsetDefaultPoolPath
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|resourcePlan
operator|.
name|setDefaultPoolPath
argument_list|(
name|poolPath
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|HiveParser
operator|.
name|TOK_RENAME
case|:
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Expected one argument"
argument_list|)
throw|;
block|}
name|resourcePlan
operator|.
name|setName
argument_list|(
name|unescapeIdentifier
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unexpected token in alter resource plan statement: "
operator|+
name|child
operator|.
name|getType
argument_list|()
argument_list|)
throw|;
block|}
block|}
name|String
name|resFile
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|validate
condition|)
block|{
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|resFile
operator|=
name|ctx
operator|.
name|getResFile
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|AlterResourcePlanDesc
name|desc
init|=
operator|new
name|AlterResourcePlanDesc
argument_list|(
name|resourcePlan
argument_list|,
name|rpName
argument_list|,
name|validate
argument_list|,
name|isEnableActivate
argument_list|,
literal|false
argument_list|,
name|isReplace
argument_list|,
name|resFile
argument_list|)
decl_stmt|;
name|addServiceOutput
argument_list|()
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|desc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|validate
condition|)
block|{
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|AlterResourcePlanDesc
operator|.
name|SCHEMA
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeDropResourcePlan
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Expected name in DROP RESOURCE PLAN statement"
argument_list|)
throw|;
block|}
name|String
name|rpName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|ifExists
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Tree
name|child
init|=
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|child
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_IFEXISTS
case|:
name|ifExists
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Invalid create arguments "
operator|+
name|ast
operator|.
name|toStringTree
argument_list|()
argument_list|)
throw|;
block|}
block|}
name|DropResourcePlanDesc
name|desc
init|=
operator|new
name|DropResourcePlanDesc
argument_list|(
name|rpName
argument_list|,
name|ifExists
argument_list|)
decl_stmt|;
name|addServiceOutput
argument_list|()
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|desc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeCreateTrigger
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|4
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Invalid syntax for create trigger statement"
argument_list|)
throw|;
block|}
name|String
name|rpName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|triggerName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|triggerExpression
init|=
name|buildTriggerExpression
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|actionExpression
init|=
name|buildTriggerActionExpression
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|3
argument_list|)
argument_list|)
decl_stmt|;
name|WMTrigger
name|trigger
init|=
operator|new
name|WMTrigger
argument_list|(
name|rpName
argument_list|,
name|triggerName
argument_list|)
decl_stmt|;
name|trigger
operator|.
name|setTriggerExpression
argument_list|(
name|triggerExpression
argument_list|)
expr_stmt|;
name|trigger
operator|.
name|setActionExpression
argument_list|(
name|actionExpression
argument_list|)
expr_stmt|;
name|CreateWMTriggerDesc
name|desc
init|=
operator|new
name|CreateWMTriggerDesc
argument_list|(
name|trigger
argument_list|)
decl_stmt|;
name|addServiceOutput
argument_list|()
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|desc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|String
name|buildTriggerExpression
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_TRIGGER_EXPRESSION
operator|||
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Invalid trigger expression."
argument_list|)
throw|;
block|}
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
comment|// Don't strip quotes.
name|builder
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|deleteCharAt
argument_list|(
name|builder
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|String
name|poolPath
parameter_list|(
name|Tree
name|ast
parameter_list|)
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|// DOT is not affected
name|builder
operator|.
name|append
argument_list|(
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|String
name|buildTriggerActionExpression
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
switch|switch
condition|(
name|ast
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|KW_KILL
case|:
return|return
literal|"KILL"
return|;
case|case
name|HiveParser
operator|.
name|KW_MOVE
case|:
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Invalid move to clause in trigger action."
argument_list|)
throw|;
block|}
name|String
name|poolPath
init|=
name|poolPath
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
return|return
literal|"MOVE TO "
operator|+
name|poolPath
return|;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unknown token in action clause: "
operator|+
name|ast
operator|.
name|getType
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|analyzeAlterTrigger
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|4
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Invalid syntax for alter trigger statement"
argument_list|)
throw|;
block|}
name|String
name|rpName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|triggerName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|triggerExpression
init|=
name|buildTriggerExpression
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|actionExpression
init|=
name|buildTriggerActionExpression
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|3
argument_list|)
argument_list|)
decl_stmt|;
name|WMTrigger
name|trigger
init|=
operator|new
name|WMTrigger
argument_list|(
name|rpName
argument_list|,
name|triggerName
argument_list|)
decl_stmt|;
name|trigger
operator|.
name|setTriggerExpression
argument_list|(
name|triggerExpression
argument_list|)
expr_stmt|;
name|trigger
operator|.
name|setActionExpression
argument_list|(
name|actionExpression
argument_list|)
expr_stmt|;
name|AlterWMTriggerDesc
name|desc
init|=
operator|new
name|AlterWMTriggerDesc
argument_list|(
name|trigger
argument_list|)
decl_stmt|;
name|addServiceOutput
argument_list|()
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|desc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeDropTrigger
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Invalid syntax for drop trigger."
argument_list|)
throw|;
block|}
name|String
name|rpName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|triggerName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|DropWMTriggerDesc
name|desc
init|=
operator|new
name|DropWMTriggerDesc
argument_list|(
name|rpName
argument_list|,
name|triggerName
argument_list|)
decl_stmt|;
name|addServiceOutput
argument_list|()
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|desc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeCreatePool
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// TODO: allow defaults for e.g. scheduling policy.
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|<
literal|3
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Expected more arguments: "
operator|+
name|ast
operator|.
name|toStringTree
argument_list|()
argument_list|)
throw|;
block|}
name|String
name|rpName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|poolPath
init|=
name|poolPath
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|WMPool
name|pool
init|=
operator|new
name|WMPool
argument_list|(
name|rpName
argument_list|,
name|poolPath
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Tree
name|child
init|=
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Expected 1 paramter for: "
operator|+
name|child
operator|.
name|getText
argument_list|()
argument_list|)
throw|;
block|}
name|String
name|param
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|child
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_ALLOC_FRACTION
case|:
name|pool
operator|.
name|setAllocFraction
argument_list|(
name|Double
operator|.
name|parseDouble
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_QUERY_PARALLELISM
case|:
name|pool
operator|.
name|setQueryParallelism
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SCHEDULING_POLICY
case|:
name|String
name|schedulingPolicyStr
init|=
name|PlanUtils
operator|.
name|stripQuotes
argument_list|(
name|param
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|MetaStoreUtils
operator|.
name|isValidSchedulingPolicy
argument_list|(
name|schedulingPolicyStr
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Invalid scheduling policy "
operator|+
name|schedulingPolicyStr
argument_list|)
throw|;
block|}
name|pool
operator|.
name|setSchedulingPolicy
argument_list|(
name|schedulingPolicyStr
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_PATH
case|:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Invalid parameter path in create pool"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|pool
operator|.
name|isSetAllocFraction
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"alloc_fraction should be specified for a pool"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|pool
operator|.
name|isSetQueryParallelism
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"query_parallelism should be specified for a pool"
argument_list|)
throw|;
block|}
name|CreateWMPoolDesc
name|desc
init|=
operator|new
name|CreateWMPoolDesc
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|addServiceOutput
argument_list|()
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|desc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterPool
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|<
literal|3
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Invalid syntax for alter pool: "
operator|+
name|ast
operator|.
name|toStringTree
argument_list|()
argument_list|)
throw|;
block|}
name|String
name|rpName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|Tree
name|poolTarget
init|=
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|boolean
name|isUnmanagedPool
init|=
literal|false
decl_stmt|;
name|String
name|poolPath
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|poolTarget
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_UNMANAGED
condition|)
block|{
name|isUnmanagedPool
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|poolPath
operator|=
name|poolPath
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|WMNullablePool
name|poolChanges
init|=
literal|null
decl_stmt|;
name|boolean
name|hasTrigger
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Tree
name|child
init|=
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Invalid syntax in alter pool expected parameter."
argument_list|)
throw|;
block|}
name|Tree
name|param
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ADD_TRIGGER
operator|||
name|child
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_DROP_TRIGGER
condition|)
block|{
name|hasTrigger
operator|=
literal|true
expr_stmt|;
name|boolean
name|drop
init|=
name|child
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_DROP_TRIGGER
decl_stmt|;
name|String
name|triggerName
init|=
name|unescapeIdentifier
argument_list|(
name|param
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|drop
condition|)
block|{
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
operator|new
name|AlterPoolDropTriggerDesc
argument_list|(
name|rpName
argument_list|,
name|triggerName
argument_list|,
name|poolPath
argument_list|,
name|isUnmanagedPool
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
operator|new
name|AlterPoolAddTriggerDesc
argument_list|(
name|rpName
argument_list|,
name|triggerName
argument_list|,
name|poolPath
argument_list|,
name|isUnmanagedPool
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|isUnmanagedPool
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Cannot alter the unmanaged pool"
argument_list|)
throw|;
block|}
if|if
condition|(
name|poolChanges
operator|==
literal|null
condition|)
block|{
name|poolChanges
operator|=
operator|new
name|WMNullablePool
argument_list|(
name|rpName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|child
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_ALLOC_FRACTION
case|:
name|poolChanges
operator|.
name|setAllocFraction
argument_list|(
name|Double
operator|.
name|parseDouble
argument_list|(
name|param
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_QUERY_PARALLELISM
case|:
name|poolChanges
operator|.
name|setQueryParallelism
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|param
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SCHEDULING_POLICY
case|:
name|poolChanges
operator|.
name|setIsSetSchedulingPolicy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|param
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_NULL
condition|)
block|{
name|poolChanges
operator|.
name|setSchedulingPolicy
argument_list|(
name|PlanUtils
operator|.
name|stripQuotes
argument_list|(
name|param
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_PATH
case|:
name|poolChanges
operator|.
name|setPoolPath
argument_list|(
name|poolPath
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Incorrect alter syntax: "
operator|+
name|child
operator|.
name|toStringTree
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|poolChanges
operator|!=
literal|null
operator|||
name|hasTrigger
condition|)
block|{
name|addServiceOutput
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|poolChanges
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|poolChanges
operator|.
name|isSetPoolPath
argument_list|()
condition|)
block|{
name|poolChanges
operator|.
name|setPoolPath
argument_list|(
name|poolPath
argument_list|)
expr_stmt|;
block|}
name|AlterWMPoolDesc
name|ddlDesc
init|=
operator|new
name|AlterWMPoolDesc
argument_list|(
name|poolChanges
argument_list|,
name|poolPath
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|ddlDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeDropPool
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Invalid syntax for drop pool."
argument_list|)
throw|;
block|}
name|String
name|rpName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|poolPath
init|=
name|poolPath
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|DropWMPoolDesc
name|desc
init|=
operator|new
name|DropWMPoolDesc
argument_list|(
name|rpName
argument_list|,
name|poolPath
argument_list|)
decl_stmt|;
name|addServiceOutput
argument_list|()
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|desc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeCreateOrAlterMapping
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|boolean
name|update
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|<
literal|4
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Invalid syntax for create or alter mapping."
argument_list|)
throw|;
block|}
name|String
name|rpName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|entityType
init|=
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|String
name|entityName
init|=
name|PlanUtils
operator|.
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|WMMapping
name|mapping
init|=
operator|new
name|WMMapping
argument_list|(
name|rpName
argument_list|,
name|entityType
argument_list|,
name|entityName
argument_list|)
decl_stmt|;
name|Tree
name|dest
init|=
name|ast
operator|.
name|getChild
argument_list|(
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
name|dest
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_UNMANAGED
condition|)
block|{
name|mapping
operator|.
name|setPoolPath
argument_list|(
name|poolPath
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Null path => unmanaged
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|5
condition|)
block|{
name|mapping
operator|.
name|setOrdering
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|4
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ddl
operator|.
name|DDLDesc
name|desc
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|update
condition|)
block|{
name|desc
operator|=
operator|new
name|AlterWMMappingDesc
argument_list|(
name|mapping
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|desc
operator|=
operator|new
name|CreateWMMappingDesc
argument_list|(
name|mapping
argument_list|)
expr_stmt|;
block|}
name|addServiceOutput
argument_list|()
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|desc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeDropMapping
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|3
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Invalid syntax for drop mapping."
argument_list|)
throw|;
block|}
name|String
name|rpName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|entityType
init|=
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|String
name|entityName
init|=
name|PlanUtils
operator|.
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|DropWMMappingDesc
name|desc
init|=
operator|new
name|DropWMMappingDesc
argument_list|(
operator|new
name|WMMapping
argument_list|(
name|rpName
argument_list|,
name|entityType
argument_list|,
name|entityName
argument_list|)
argument_list|)
decl_stmt|;
name|addServiceOutput
argument_list|()
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|desc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeCreateDatabase
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|dbName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|ifNotExists
init|=
literal|false
decl_stmt|;
name|String
name|dbComment
init|=
literal|null
decl_stmt|;
name|String
name|dbLocation
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|dbProps
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|childNode
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|childNode
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_IFNOTEXISTS
case|:
name|ifNotExists
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DATABASECOMMENT
case|:
name|dbComment
operator|=
name|unescapeSQLString
argument_list|(
name|childNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_DATABASEPROPERTIES
case|:
name|dbProps
operator|=
name|DDLSemanticAnalyzer
operator|.
name|getProps
argument_list|(
operator|(
name|ASTNode
operator|)
name|childNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_DATABASELOCATION
case|:
name|dbLocation
operator|=
name|unescapeSQLString
argument_list|(
name|childNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|addLocationToOutputs
argument_list|(
name|dbLocation
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unrecognized token in CREATE DATABASE statement"
argument_list|)
throw|;
block|}
block|}
name|CreateDatabaseDesc
name|createDatabaseDesc
init|=
operator|new
name|CreateDatabaseDesc
argument_list|(
name|dbName
argument_list|,
name|dbComment
argument_list|,
name|dbLocation
argument_list|,
name|ifNotExists
argument_list|,
name|dbProps
argument_list|)
decl_stmt|;
name|Database
name|database
init|=
operator|new
name|Database
argument_list|(
name|dbName
argument_list|,
name|dbComment
argument_list|,
name|dbLocation
argument_list|,
name|dbProps
argument_list|)
decl_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|database
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_NO_LOCK
argument_list|)
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|createDatabaseDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeDropDatabase
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|dbName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|ifExists
init|=
literal|false
decl_stmt|;
name|boolean
name|ifCascade
init|=
literal|false
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|ast
operator|.
name|getFirstChildWithType
argument_list|(
name|HiveParser
operator|.
name|TOK_IFEXISTS
argument_list|)
condition|)
block|{
name|ifExists
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|!=
name|ast
operator|.
name|getFirstChildWithType
argument_list|(
name|HiveParser
operator|.
name|TOK_CASCADE
argument_list|)
condition|)
block|{
name|ifCascade
operator|=
literal|true
expr_stmt|;
block|}
name|Database
name|database
init|=
name|getDatabase
argument_list|(
name|dbName
argument_list|,
operator|!
name|ifExists
argument_list|)
decl_stmt|;
if|if
condition|(
name|database
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// if cascade=true, then we need to authorize the drop table action as well
if|if
condition|(
name|ifCascade
condition|)
block|{
comment|// add the tables as well to outputs
name|List
argument_list|<
name|String
argument_list|>
name|tableNames
decl_stmt|;
comment|// get names of all tables under this dbName
try|try
block|{
name|tableNames
operator|=
name|db
operator|.
name|getAllTables
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// add tables to outputs
if|if
condition|(
name|tableNames
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|tableName
range|:
name|tableNames
control|)
block|{
name|Table
name|table
init|=
name|getTable
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// We want no lock here, as the database lock will cover the tables,
comment|// and putting a lock will actually cause us to deadlock on ourselves.
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|table
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_NO_LOCK
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|database
argument_list|)
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|database
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_EXCLUSIVE
argument_list|)
argument_list|)
expr_stmt|;
name|DropDatabaseDesc
name|dropDatabaseDesc
init|=
operator|new
name|DropDatabaseDesc
argument_list|(
name|dbName
argument_list|,
name|ifExists
argument_list|,
name|ifCascade
argument_list|,
operator|new
name|ReplicationSpec
argument_list|()
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|dropDatabaseDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeSwitchDatabase
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|dbName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|Database
name|database
init|=
name|getDatabase
argument_list|(
name|dbName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|ReadEntity
name|dbReadEntity
init|=
operator|new
name|ReadEntity
argument_list|(
name|database
argument_list|)
decl_stmt|;
name|dbReadEntity
operator|.
name|noLockNeeded
argument_list|()
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
name|dbReadEntity
argument_list|)
expr_stmt|;
name|SwitchDatabaseDesc
name|switchDatabaseDesc
init|=
operator|new
name|SwitchDatabaseDesc
argument_list|(
name|dbName
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|switchDatabaseDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeDropTable
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|TableType
name|expectedType
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|boolean
name|ifExists
init|=
operator|(
name|ast
operator|.
name|getFirstChildWithType
argument_list|(
name|HiveParser
operator|.
name|TOK_IFEXISTS
argument_list|)
operator|!=
literal|null
operator|)
decl_stmt|;
comment|// we want to signal an error if the table/view doesn't exist and we're
comment|// configured not to fail silently
name|boolean
name|throwException
init|=
operator|!
name|ifExists
operator|&&
operator|!
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|DROPIGNORESNONEXISTENT
argument_list|)
decl_stmt|;
name|ReplicationSpec
name|replicationSpec
init|=
operator|new
name|ReplicationSpec
argument_list|(
name|ast
argument_list|)
decl_stmt|;
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|tableName
argument_list|,
name|throwException
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
operator|!=
literal|null
condition|)
block|{
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_EXCLUSIVE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|boolean
name|ifPurge
init|=
operator|(
name|ast
operator|.
name|getFirstChildWithType
argument_list|(
name|HiveParser
operator|.
name|KW_PURGE
argument_list|)
operator|!=
literal|null
operator|)
decl_stmt|;
name|DropTableDesc
name|dropTblDesc
init|=
operator|new
name|DropTableDesc
argument_list|(
name|tableName
argument_list|,
name|expectedType
argument_list|,
name|ifExists
argument_list|,
name|ifPurge
argument_list|,
name|replicationSpec
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|dropTblDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeTruncateTable
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|root
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// TOK_TABLE_PARTITION
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|root
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|Table
name|table
init|=
name|getTable
argument_list|(
name|tableName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|boolean
name|isForce
init|=
name|ast
operator|.
name|getFirstChildWithType
argument_list|(
name|HiveParser
operator|.
name|TOK_FORCE
argument_list|)
operator|!=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|isForce
condition|)
block|{
if|if
condition|(
name|table
operator|.
name|getTableType
argument_list|()
operator|!=
name|TableType
operator|.
name|MANAGED_TABLE
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TRUNCATE_FOR_NON_MANAGED_TABLE
operator|.
name|format
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|table
operator|.
name|isNonNative
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TRUNCATE_FOR_NON_NATIVE_TABLE
operator|.
name|format
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
comment|//TODO
block|}
if|if
condition|(
operator|!
name|table
operator|.
name|isPartitioned
argument_list|()
operator|&&
name|root
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|PARTSPEC_FOR_NON_PARTITIONED_TABLE
operator|.
name|format
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
name|getPartSpec
argument_list|(
operator|(
name|ASTNode
operator|)
name|root
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|partSpec
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|table
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|table
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_EXCLUSIVE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|Partition
name|partition
range|:
name|getPartitions
argument_list|(
name|table
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
control|)
block|{
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|partition
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_EXCLUSIVE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|isFullSpec
argument_list|(
name|table
argument_list|,
name|partSpec
argument_list|)
condition|)
block|{
name|validatePartSpec
argument_list|(
name|table
argument_list|,
name|partSpec
argument_list|,
operator|(
name|ASTNode
operator|)
name|root
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|,
name|conf
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Partition
name|partition
init|=
name|getPartition
argument_list|(
name|table
argument_list|,
name|partSpec
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|partition
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_EXCLUSIVE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|validatePartSpec
argument_list|(
name|table
argument_list|,
name|partSpec
argument_list|,
operator|(
name|ASTNode
operator|)
name|root
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|,
name|conf
argument_list|,
literal|false
argument_list|)
expr_stmt|;
for|for
control|(
name|Partition
name|partition
range|:
name|getPartitions
argument_list|(
name|table
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
control|)
block|{
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|partition
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_EXCLUSIVE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|TruncateTableDesc
name|truncateTblDesc
init|=
operator|new
name|TruncateTableDesc
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
literal|null
argument_list|,
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
name|truncateTblDesc
operator|.
name|mayNeedWriteId
argument_list|()
condition|)
block|{
name|setAcidDdlDesc
argument_list|(
name|truncateTblDesc
argument_list|)
expr_stmt|;
block|}
name|DDLWork2
name|ddlWork
init|=
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|truncateTblDesc
argument_list|)
decl_stmt|;
name|Task
argument_list|<
name|?
argument_list|>
name|truncateTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
name|ddlWork
argument_list|)
decl_stmt|;
comment|// Is this a truncate column command
name|List
argument_list|<
name|String
argument_list|>
name|columnNames
init|=
literal|null
decl_stmt|;
name|ASTNode
name|colNamesNode
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getFirstChildWithType
argument_list|(
name|HiveParser
operator|.
name|TOK_TABCOLNAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|colNamesNode
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|columnNames
operator|=
name|getColumnNames
argument_list|(
name|colNamesNode
argument_list|)
expr_stmt|;
comment|// It would be possible to support this, but this is such a pointless command.
if|if
condition|(
name|AcidUtils
operator|.
name|isInsertOnlyTable
argument_list|(
name|table
operator|.
name|getParameters
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Truncating MM table columns not presently supported"
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|bucketCols
init|=
literal|null
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|InputFormat
argument_list|>
name|inputFormatClass
init|=
literal|null
decl_stmt|;
name|boolean
name|isArchived
init|=
literal|false
decl_stmt|;
name|Path
name|newTblPartLoc
init|=
literal|null
decl_stmt|;
name|Path
name|oldTblPartLoc
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|cols
init|=
literal|null
decl_stmt|;
name|ListBucketingCtx
name|lbCtx
init|=
literal|null
decl_stmt|;
name|boolean
name|isListBucketed
init|=
literal|false
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|listBucketColNames
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|table
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
name|Partition
name|part
init|=
name|db
operator|.
name|getPartition
argument_list|(
name|table
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|Path
name|tabPath
init|=
name|table
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|Path
name|partPath
init|=
name|part
operator|.
name|getDataLocation
argument_list|()
decl_stmt|;
comment|// if the table is in a different dfs than the partition,
comment|// replace the partition's dfs with the table's dfs.
name|newTblPartLoc
operator|=
operator|new
name|Path
argument_list|(
name|tabPath
operator|.
name|toUri
argument_list|()
operator|.
name|getScheme
argument_list|()
argument_list|,
name|tabPath
operator|.
name|toUri
argument_list|()
operator|.
name|getAuthority
argument_list|()
argument_list|,
name|partPath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|oldTblPartLoc
operator|=
name|partPath
expr_stmt|;
name|cols
operator|=
name|part
operator|.
name|getCols
argument_list|()
expr_stmt|;
name|bucketCols
operator|=
name|part
operator|.
name|getBucketCols
argument_list|()
expr_stmt|;
name|inputFormatClass
operator|=
name|part
operator|.
name|getInputFormatClass
argument_list|()
expr_stmt|;
name|isArchived
operator|=
name|ArchiveUtils
operator|.
name|isArchived
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|lbCtx
operator|=
name|constructListBucketingCtx
argument_list|(
name|part
operator|.
name|getSkewedColNames
argument_list|()
argument_list|,
name|part
operator|.
name|getSkewedColValues
argument_list|()
argument_list|,
name|part
operator|.
name|getSkewedColValueLocationMaps
argument_list|()
argument_list|,
name|part
operator|.
name|isStoredAsSubDirectories
argument_list|()
argument_list|)
expr_stmt|;
name|isListBucketed
operator|=
name|part
operator|.
name|isStoredAsSubDirectories
argument_list|()
expr_stmt|;
name|listBucketColNames
operator|=
name|part
operator|.
name|getSkewedColNames
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// input and output are the same
name|oldTblPartLoc
operator|=
name|table
operator|.
name|getPath
argument_list|()
expr_stmt|;
name|newTblPartLoc
operator|=
name|table
operator|.
name|getPath
argument_list|()
expr_stmt|;
name|cols
operator|=
name|table
operator|.
name|getCols
argument_list|()
expr_stmt|;
name|bucketCols
operator|=
name|table
operator|.
name|getBucketCols
argument_list|()
expr_stmt|;
name|inputFormatClass
operator|=
name|table
operator|.
name|getInputFormatClass
argument_list|()
expr_stmt|;
name|lbCtx
operator|=
name|constructListBucketingCtx
argument_list|(
name|table
operator|.
name|getSkewedColNames
argument_list|()
argument_list|,
name|table
operator|.
name|getSkewedColValues
argument_list|()
argument_list|,
name|table
operator|.
name|getSkewedColValueLocationMaps
argument_list|()
argument_list|,
name|table
operator|.
name|isStoredAsSubDirectories
argument_list|()
argument_list|)
expr_stmt|;
name|isListBucketed
operator|=
name|table
operator|.
name|isStoredAsSubDirectories
argument_list|()
expr_stmt|;
name|listBucketColNames
operator|=
name|table
operator|.
name|getSkewedColNames
argument_list|()
expr_stmt|;
block|}
comment|// throw a HiveException for non-rcfile.
if|if
condition|(
operator|!
name|inputFormatClass
operator|.
name|equals
argument_list|(
name|RCFileInputFormat
operator|.
name|class
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TRUNCATE_COLUMN_NOT_RC
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
comment|// throw a HiveException if the table/partition is archived
if|if
condition|(
name|isArchived
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TRUNCATE_COLUMN_ARCHIVED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|Set
argument_list|<
name|Integer
argument_list|>
name|columnIndexes
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|columnName
range|:
name|columnNames
control|)
block|{
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|columnIndex
init|=
literal|0
init|;
name|columnIndex
operator|<
name|cols
operator|.
name|size
argument_list|()
condition|;
name|columnIndex
operator|++
control|)
block|{
if|if
condition|(
name|columnName
operator|.
name|equalsIgnoreCase
argument_list|(
name|cols
operator|.
name|get
argument_list|(
name|columnIndex
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|columnIndexes
operator|.
name|add
argument_list|(
name|columnIndex
argument_list|)
expr_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// Throw an exception if the user is trying to truncate a column which doesn't exist
if|if
condition|(
operator|!
name|found
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|columnName
argument_list|)
argument_list|)
throw|;
block|}
comment|// Throw an exception if the table/partition is bucketed on one of the columns
for|for
control|(
name|String
name|bucketCol
range|:
name|bucketCols
control|)
block|{
if|if
condition|(
name|bucketCol
operator|.
name|equalsIgnoreCase
argument_list|(
name|columnName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TRUNCATE_BUCKETED_COLUMN
operator|.
name|getMsg
argument_list|(
name|columnName
argument_list|)
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|isListBucketed
condition|)
block|{
for|for
control|(
name|String
name|listBucketCol
range|:
name|listBucketColNames
control|)
block|{
if|if
condition|(
name|listBucketCol
operator|.
name|equalsIgnoreCase
argument_list|(
name|columnName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TRUNCATE_LIST_BUCKETED_COLUMN
operator|.
name|getMsg
argument_list|(
name|columnName
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
block|}
name|truncateTblDesc
operator|.
name|setColumnIndexes
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|columnIndexes
argument_list|)
argument_list|)
expr_stmt|;
name|truncateTblDesc
operator|.
name|setInputDir
argument_list|(
name|oldTblPartLoc
argument_list|)
expr_stmt|;
name|truncateTblDesc
operator|.
name|setLbCtx
argument_list|(
name|lbCtx
argument_list|)
expr_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
literal|null
argument_list|,
name|AlterTableType
operator|.
name|TRUNCATE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|ddlWork
operator|.
name|setNeedLock
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|TableDesc
name|tblDesc
init|=
name|Utilities
operator|.
name|getTableDesc
argument_list|(
name|table
argument_list|)
decl_stmt|;
comment|// Write the output to temporary directory and move it to the final location at the end
comment|// so the operation is atomic.
name|Path
name|queryTmpdir
init|=
name|ctx
operator|.
name|getExternalTmpPath
argument_list|(
name|newTblPartLoc
argument_list|)
decl_stmt|;
name|truncateTblDesc
operator|.
name|setOutputDir
argument_list|(
name|queryTmpdir
argument_list|)
expr_stmt|;
name|LoadTableDesc
name|ltd
init|=
operator|new
name|LoadTableDesc
argument_list|(
name|queryTmpdir
argument_list|,
name|tblDesc
argument_list|,
name|partSpec
operator|==
literal|null
condition|?
operator|new
name|HashMap
argument_list|<>
argument_list|()
else|:
name|partSpec
argument_list|)
decl_stmt|;
name|ltd
operator|.
name|setLbCtx
argument_list|(
name|lbCtx
argument_list|)
expr_stmt|;
name|Task
argument_list|<
name|MoveWork
argument_list|>
name|moveTsk
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|MoveWork
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
name|ltd
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|truncateTask
operator|.
name|addDependentTask
argument_list|(
name|moveTsk
argument_list|)
expr_stmt|;
comment|// Recalculate the HDFS stats if auto gather stats is set
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESTATSAUTOGATHER
argument_list|)
condition|)
block|{
name|BasicStatsWork
name|basicStatsWork
decl_stmt|;
if|if
condition|(
name|oldTblPartLoc
operator|.
name|equals
argument_list|(
name|newTblPartLoc
argument_list|)
condition|)
block|{
comment|// If we're merging to the same location, we can avoid some metastore calls
name|TableSpec
name|tablepart
init|=
operator|new
name|TableSpec
argument_list|(
name|this
operator|.
name|db
argument_list|,
name|conf
argument_list|,
name|root
argument_list|)
decl_stmt|;
name|basicStatsWork
operator|=
operator|new
name|BasicStatsWork
argument_list|(
name|tablepart
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|basicStatsWork
operator|=
operator|new
name|BasicStatsWork
argument_list|(
name|ltd
argument_list|)
expr_stmt|;
block|}
name|basicStatsWork
operator|.
name|setNoStatsAggregator
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|basicStatsWork
operator|.
name|setClearAggregatorStats
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|StatsWork
name|columnStatsWork
init|=
operator|new
name|StatsWork
argument_list|(
name|table
argument_list|,
name|basicStatsWork
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|Task
argument_list|<
name|?
argument_list|>
name|statTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
name|columnStatsWork
argument_list|)
decl_stmt|;
name|moveTsk
operator|.
name|addDependentTask
argument_list|(
name|statTask
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|truncateTask
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|boolean
name|isFullSpec
parameter_list|(
name|Table
name|table
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
block|{
for|for
control|(
name|FieldSchema
name|partCol
range|:
name|table
operator|.
name|getPartCols
argument_list|()
control|)
block|{
if|if
condition|(
name|partSpec
operator|.
name|get
argument_list|(
name|partCol
operator|.
name|getName
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|validateAlterTableType
parameter_list|(
name|Table
name|tbl
parameter_list|,
name|AlterTableType
name|op
parameter_list|)
throws|throws
name|SemanticException
block|{
name|validateAlterTableType
argument_list|(
name|tbl
argument_list|,
name|op
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|validateAlterTableType
parameter_list|(
name|Table
name|tbl
parameter_list|,
name|AlterTableType
name|op
parameter_list|,
name|boolean
name|expectView
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|tbl
operator|.
name|isView
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|expectView
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_COMMAND_FOR_VIEWS
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|ADDPARTITION
case|:
case|case
name|DROPPARTITION
case|:
case|case
name|RENAMEPARTITION
case|:
case|case
name|ADDPROPS
case|:
case|case
name|DROPPROPS
case|:
case|case
name|RENAME
case|:
comment|// allow this form
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_VIEW_DISALLOWED_OP
operator|.
name|getMsg
argument_list|(
name|op
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|expectView
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_COMMAND_FOR_TABLES
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|tbl
operator|.
name|isNonNative
argument_list|()
operator|&&
operator|!
name|AlterTableType
operator|.
name|NON_NATIVE_TABLE_ALLOWED
operator|.
name|contains
argument_list|(
name|op
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_TABLE_NON_NATIVE
operator|.
name|getMsg
argument_list|(
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|private
name|boolean
name|hasConstraintsEnabled
parameter_list|(
specifier|final
name|String
name|tblName
parameter_list|)
throws|throws
name|SemanticException
block|{
name|NotNullConstraint
name|nnc
init|=
literal|null
decl_stmt|;
name|DefaultConstraint
name|dc
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// retrieve enabled NOT NULL constraint from metastore
name|nnc
operator|=
name|Hive
operator|.
name|get
argument_list|()
operator|.
name|getEnabledNotNullConstraints
argument_list|(
name|db
operator|.
name|getDatabaseCurrent
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|tblName
argument_list|)
expr_stmt|;
name|dc
operator|=
name|Hive
operator|.
name|get
argument_list|()
operator|.
name|getEnabledDefaultConstraints
argument_list|(
name|db
operator|.
name|getDatabaseCurrent
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|tblName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|SemanticException
condition|)
block|{
throw|throw
operator|(
name|SemanticException
operator|)
name|e
throw|;
block|}
else|else
block|{
throw|throw
operator|(
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
operator|)
throw|;
block|}
block|}
if|if
condition|(
operator|(
name|nnc
operator|!=
literal|null
operator|&&
operator|!
name|nnc
operator|.
name|getNotNullConstraints
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|||
operator|(
name|dc
operator|!=
literal|null
operator|&&
operator|!
name|dc
operator|.
name|getDefaultConstraints
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|void
name|analyzeAlterTableProps
parameter_list|(
name|String
index|[]
name|qualified
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|,
name|ASTNode
name|ast
parameter_list|,
name|boolean
name|expectView
parameter_list|,
name|boolean
name|isUnset
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
name|getDotName
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapProp
init|=
name|getProps
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|EnvironmentContext
name|environmentContext
init|=
literal|null
decl_stmt|;
comment|// we need to check if the properties are valid, especially for stats.
comment|// they might be changed via alter table .. update statistics or
comment|// alter table .. set tblproperties. If the property is not row_count
comment|// or raw_data_size, it could not be changed through update statistics
name|boolean
name|changeStatsSucceeded
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|mapProp
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// we make sure that we do not change anything if there is anything
comment|// wrong.
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|equals
argument_list|(
name|StatsSetupConst
operator|.
name|ROW_COUNT
argument_list|)
operator|||
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|equals
argument_list|(
name|StatsSetupConst
operator|.
name|RAW_DATA_SIZE
argument_list|)
condition|)
block|{
try|try
block|{
name|Long
operator|.
name|parseLong
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|changeStatsSucceeded
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"AlterTable "
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|+
literal|" failed with value "
operator|+
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|// if table is being modified to be external we need to make sure existing table
comment|// doesn't have enabled constraint since constraints are disallowed with such tables
elseif|else
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|equals
argument_list|(
literal|"external"
argument_list|)
operator|&&
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
if|if
condition|(
name|hasConstraintsEnabled
argument_list|(
name|qualified
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_CSTR_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|"Table: "
operator|+
name|tableName
operator|+
literal|" has constraints enabled."
operator|+
literal|"Please remove those constraints to change this property."
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|queryState
operator|.
name|getCommandType
argument_list|()
operator|.
name|equals
argument_list|(
name|HiveOperation
operator|.
name|ALTERTABLE_UPDATETABLESTATS
operator|.
name|getOperationName
argument_list|()
argument_list|)
operator|||
name|queryState
operator|.
name|getCommandType
argument_list|()
operator|.
name|equals
argument_list|(
name|HiveOperation
operator|.
name|ALTERTABLE_UPDATEPARTSTATS
operator|.
name|getOperationName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"AlterTable UpdateStats "
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|+
literal|" failed because the only valid keys are "
operator|+
name|StatsSetupConst
operator|.
name|ROW_COUNT
operator|+
literal|" and "
operator|+
name|StatsSetupConst
operator|.
name|RAW_DATA_SIZE
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|changeStatsSucceeded
condition|)
block|{
name|environmentContext
operator|=
operator|new
name|EnvironmentContext
argument_list|()
expr_stmt|;
name|environmentContext
operator|.
name|putToProperties
argument_list|(
name|StatsSetupConst
operator|.
name|STATS_GENERATED
argument_list|,
name|StatsSetupConst
operator|.
name|USER
argument_list|)
expr_stmt|;
block|}
block|}
name|boolean
name|isToTxn
init|=
name|AcidUtils
operator|.
name|isTablePropertyTransactional
argument_list|(
name|mapProp
argument_list|)
operator|||
name|mapProp
operator|.
name|containsKey
argument_list|(
name|hive_metastoreConstants
operator|.
name|TABLE_TRANSACTIONAL_PROPERTIES
argument_list|)
decl_stmt|;
name|boolean
name|isExplicitStatsUpdate
init|=
name|changeStatsSucceeded
operator|&&
name|AcidUtils
operator|.
name|isTransactionalTable
argument_list|(
name|getTable
argument_list|(
name|qualified
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
name|AbstractAlterTableDesc
name|alterTblDesc
init|=
literal|null
decl_stmt|;
name|DDLWork2
name|ddlWork
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isUnset
condition|)
block|{
name|boolean
name|dropIfExists
init|=
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|!=
literal|null
decl_stmt|;
comment|// validate Unset Non Existed Table Properties
if|if
condition|(
operator|!
name|dropIfExists
condition|)
block|{
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|tableName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|tableParams
init|=
name|tab
operator|.
name|getTTable
argument_list|()
operator|.
name|getParameters
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|currKey
range|:
name|mapProp
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|tableParams
operator|.
name|containsKey
argument_list|(
name|currKey
argument_list|)
condition|)
block|{
name|String
name|errorMsg
init|=
literal|"The following property "
operator|+
name|currKey
operator|+
literal|" does not exist in "
operator|+
name|tab
operator|.
name|getTableName
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_TBL_UNSET_NON_EXIST_PROPERTY
operator|.
name|getMsg
argument_list|(
name|errorMsg
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
name|alterTblDesc
operator|=
operator|new
name|AlterTableUnsetPropertiesDesc
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
literal|null
argument_list|,
name|expectView
argument_list|,
name|mapProp
argument_list|,
name|isExplicitStatsUpdate
argument_list|,
name|environmentContext
argument_list|)
expr_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|alterTblDesc
argument_list|,
name|alterTblDesc
operator|.
name|getType
argument_list|()
argument_list|,
name|isToTxn
argument_list|)
expr_stmt|;
name|ddlWork
operator|=
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addPropertyReadEntry
argument_list|(
name|mapProp
argument_list|,
name|inputs
argument_list|)
expr_stmt|;
name|boolean
name|isAcidConversion
init|=
name|isToTxn
operator|&&
name|AcidUtils
operator|.
name|isFullAcidTable
argument_list|(
name|mapProp
argument_list|)
operator|&&
operator|!
name|AcidUtils
operator|.
name|isFullAcidTable
argument_list|(
name|getTable
argument_list|(
name|qualified
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
name|alterTblDesc
operator|=
operator|new
name|AlterTableSetPropertiesDesc
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
literal|null
argument_list|,
name|expectView
argument_list|,
name|mapProp
argument_list|,
name|isExplicitStatsUpdate
argument_list|,
name|isAcidConversion
argument_list|,
name|environmentContext
argument_list|)
expr_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|alterTblDesc
argument_list|,
name|alterTblDesc
operator|.
name|getType
argument_list|()
argument_list|,
name|isToTxn
argument_list|)
expr_stmt|;
name|ddlWork
operator|=
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isToTxn
condition|)
block|{
name|ddlWork
operator|.
name|setNeedLock
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Hmm... why don't many other operations here need locks?
block|}
if|if
condition|(
name|isToTxn
operator|||
name|isExplicitStatsUpdate
condition|)
block|{
name|setAcidDdlDesc
argument_list|(
name|alterTblDesc
argument_list|)
expr_stmt|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
name|ddlWork
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|setAcidDdlDesc
parameter_list|(
name|DDLDescWithWriteId
name|descWithWriteId
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|ddlDescWithWriteId
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"ddlDescWithWriteId is already set: "
operator|+
name|this
operator|.
name|ddlDescWithWriteId
argument_list|)
throw|;
block|}
name|this
operator|.
name|ddlDescWithWriteId
operator|=
name|descWithWriteId
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|DDLDescWithWriteId
name|getAcidDdlDesc
parameter_list|()
block|{
return|return
name|ddlDescWithWriteId
return|;
block|}
specifier|private
name|void
name|analyzeAlterTableSerdeProps
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapProp
init|=
name|getProps
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|AlterTableSetSerdePropsDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableSetSerdePropsDesc
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|mapProp
argument_list|)
decl_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|alterTblDesc
argument_list|,
name|AlterTableType
operator|.
name|SET_SERDE_PROPS
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableSerde
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|serdeName
init|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|props
init|=
operator|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
operator|)
condition|?
name|getProps
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
else|:
literal|null
decl_stmt|;
name|AlterTableSetSerdeDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableSetSerdeDesc
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|props
argument_list|,
name|serdeName
argument_list|)
decl_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|alterTblDesc
argument_list|,
name|AlterTableType
operator|.
name|SET_SERDE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableFileFormat
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|StorageFormat
name|format
init|=
operator|new
name|StorageFormat
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|format
operator|.
name|fillStorageFormat
argument_list|(
name|child
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unknown token "
operator|+
name|child
operator|.
name|getText
argument_list|()
argument_list|)
throw|;
block|}
name|AlterTableSetFileFormatDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableSetFileFormatDesc
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|format
operator|.
name|getInputFormat
argument_list|()
argument_list|,
name|format
operator|.
name|getOutputFormat
argument_list|()
argument_list|,
name|format
operator|.
name|getSerde
argument_list|()
argument_list|)
decl_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|alterTblDesc
argument_list|,
name|AlterTableType
operator|.
name|SET_FILE_FORMAT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// For the time while all the alter table operations are getting migrated there is a duplication of this method here
specifier|private
name|WriteType
name|determineAlterTableWriteType
parameter_list|(
name|Table
name|tab
parameter_list|,
name|AbstractAlterTableDesc
name|desc
parameter_list|,
name|AlterTableType
name|op
parameter_list|)
block|{
name|boolean
name|convertingToAcid
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|desc
operator|!=
literal|null
operator|&&
name|desc
operator|.
name|getProps
argument_list|()
operator|!=
literal|null
operator|&&
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|desc
operator|.
name|getProps
argument_list|()
operator|.
name|get
argument_list|(
name|hive_metastoreConstants
operator|.
name|TABLE_IS_TRANSACTIONAL
argument_list|)
argument_list|)
condition|)
block|{
name|convertingToAcid
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|AcidUtils
operator|.
name|isTransactionalTable
argument_list|(
name|tab
argument_list|)
operator|&&
name|convertingToAcid
condition|)
block|{
comment|//non-acid to transactional conversion (property itself) must be mutexed to prevent concurrent writes.
comment|// See HIVE-16688 for use cases.
return|return
name|WriteType
operator|.
name|DDL_EXCLUSIVE
return|;
block|}
return|return
name|WriteEntity
operator|.
name|determineAlterTableWriteType
argument_list|(
name|op
argument_list|)
return|;
block|}
specifier|private
name|void
name|addInputsOutputsAlterTable
parameter_list|(
name|String
name|tableName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|,
name|AbstractAlterTableDesc
name|desc
parameter_list|,
name|AlterTableType
name|op
parameter_list|,
name|boolean
name|doForceExclusive
parameter_list|)
throws|throws
name|SemanticException
block|{
name|boolean
name|isCascade
init|=
name|desc
operator|!=
literal|null
operator|&&
name|desc
operator|.
name|isCascade
argument_list|()
decl_stmt|;
name|boolean
name|alterPartitions
init|=
name|partSpec
operator|!=
literal|null
operator|&&
operator|!
name|partSpec
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
comment|//cascade only occurs at table level then cascade to partition level
if|if
condition|(
name|isCascade
operator|&&
name|alterPartitions
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_TABLE_PARTITION_CASCADE_NOT_SUPPORTED
argument_list|,
name|op
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|tableName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// cascade only occurs with partitioned table
if|if
condition|(
name|isCascade
operator|&&
operator|!
name|tab
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_TABLE_NON_PARTITIONED_TABLE_CASCADE_NOT_SUPPORTED
argument_list|)
throw|;
block|}
comment|// Determine the lock type to acquire
name|WriteEntity
operator|.
name|WriteType
name|writeType
init|=
name|doForceExclusive
condition|?
name|WriteType
operator|.
name|DDL_EXCLUSIVE
else|:
name|determineAlterTableWriteType
argument_list|(
name|tab
argument_list|,
name|desc
argument_list|,
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|alterPartitions
condition|)
block|{
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|alterTableOutput
operator|=
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|,
name|writeType
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
name|alterTableOutput
argument_list|)
expr_stmt|;
comment|//do not need the lock for partitions since they are covered by the table lock
if|if
condition|(
name|isCascade
condition|)
block|{
for|for
control|(
name|Partition
name|part
range|:
name|getPartitions
argument_list|(
name|tab
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
control|)
block|{
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|part
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_NO_LOCK
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ReadEntity
name|re
init|=
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
decl_stmt|;
comment|// In the case of altering a table for its partitions we don't need to lock the table
comment|// itself, just the partitions.  But the table will have a ReadEntity.  So mark that
comment|// ReadEntity as no lock.
name|re
operator|.
name|noLockNeeded
argument_list|()
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFullSpec
argument_list|(
name|tab
argument_list|,
name|partSpec
argument_list|)
condition|)
block|{
comment|// Fully specified partition spec
name|Partition
name|part
init|=
name|getPartition
argument_list|(
name|tab
argument_list|,
name|partSpec
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|part
argument_list|,
name|writeType
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Partial partition spec supplied. Make sure this is allowed.
if|if
condition|(
operator|!
name|AlterTableType
operator|.
name|SUPPORT_PARTIAL_PARTITION_SPEC
operator|.
name|contains
argument_list|(
name|op
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_TABLE_TYPE_PARTIAL_PARTITION_SPEC_NO_SUPPORTED
argument_list|,
name|op
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONING
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|DYNAMIC_PARTITION_DISABLED
argument_list|)
throw|;
block|}
for|for
control|(
name|Partition
name|part
range|:
name|getPartitions
argument_list|(
name|tab
argument_list|,
name|partSpec
argument_list|,
literal|true
argument_list|)
control|)
block|{
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|part
argument_list|,
name|writeType
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|desc
operator|!=
literal|null
condition|)
block|{
name|validateAlterTableType
argument_list|(
name|tab
argument_list|,
name|op
argument_list|,
name|desc
operator|.
name|expectView
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeAlterTableOwner
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|)
throws|throws
name|SemanticException
block|{
name|PrincipalDesc
name|ownerPrincipal
init|=
name|AuthorizationParseUtils
operator|.
name|getPrincipalDesc
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ownerPrincipal
operator|.
name|getType
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Owner type can't be null in alter table set owner command"
argument_list|)
throw|;
block|}
if|if
condition|(
name|ownerPrincipal
operator|.
name|getName
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Owner name can't be null in alter table set owner command"
argument_list|)
throw|;
block|}
name|AlterTableSetOwnerDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableSetOwnerDesc
argument_list|(
name|tableName
argument_list|,
name|ownerPrincipal
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableLocation
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|newLocation
init|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
comment|// To make sure host/port pair is valid, the status of the location does not matter
name|FileSystem
operator|.
name|get
argument_list|(
operator|new
name|URI
argument_list|(
name|newLocation
argument_list|)
argument_list|,
name|conf
argument_list|)
operator|.
name|getFileStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|newLocation
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|// Only check host/port pair is valid, whether the file exist or not does not matter
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Cannot connect to namenode, please check if host/port pair for "
operator|+
name|newLocation
operator|+
literal|" is valid"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|addLocationToOutputs
argument_list|(
name|newLocation
argument_list|)
expr_stmt|;
name|AlterTableSetLocationDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableSetLocationDesc
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|newLocation
argument_list|)
decl_stmt|;
name|Table
name|tbl
init|=
name|getTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|AcidUtils
operator|.
name|isTransactionalTable
argument_list|(
name|tbl
argument_list|)
condition|)
block|{
name|setAcidDdlDesc
argument_list|(
name|alterTblDesc
argument_list|)
expr_stmt|;
block|}
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|alterTblDesc
argument_list|,
name|AlterTableType
operator|.
name|ALTERLOCATION
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTablePartMergeFiles
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|AlterTableConcatenateDesc
name|mergeDesc
init|=
operator|new
name|AlterTableConcatenateDesc
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|inputDir
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
name|Path
name|oldTblPartLoc
init|=
literal|null
decl_stmt|;
name|Path
name|newTblPartLoc
init|=
literal|null
decl_stmt|;
name|Table
name|tblObj
init|=
literal|null
decl_stmt|;
name|ListBucketingCtx
name|lbCtx
init|=
literal|null
decl_stmt|;
try|try
block|{
name|tblObj
operator|=
name|getTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
if|if
condition|(
name|AcidUtils
operator|.
name|isTransactionalTable
argument_list|(
name|tblObj
argument_list|)
condition|)
block|{
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|newPartSpec
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|partSpec
operator|!=
literal|null
condition|)
block|{
name|newPartSpec
operator|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|(
name|partSpec
argument_list|)
expr_stmt|;
block|}
name|boolean
name|isBlocking
init|=
operator|!
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|TRANSACTIONAL_CONCATENATE_NOBLOCK
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|AlterTableCompactDesc
name|desc
init|=
operator|new
name|AlterTableCompactDesc
argument_list|(
name|tableName
argument_list|,
name|newPartSpec
argument_list|,
literal|"MAJOR"
argument_list|,
name|isBlocking
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|desc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|mergeDesc
operator|.
name|setTableDesc
argument_list|(
name|Utilities
operator|.
name|getTableDesc
argument_list|(
name|tblObj
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|bucketCols
init|=
literal|null
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|InputFormat
argument_list|>
name|inputFormatClass
init|=
literal|null
decl_stmt|;
name|boolean
name|isArchived
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|tblObj
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
if|if
condition|(
name|partSpec
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"source table "
operator|+
name|tableName
operator|+
literal|" is partitioned but no partition desc found."
argument_list|)
throw|;
block|}
else|else
block|{
name|Partition
name|part
init|=
name|getPartition
argument_list|(
name|tblObj
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|part
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"source table "
operator|+
name|tableName
operator|+
literal|" is partitioned but partition not found."
argument_list|)
throw|;
block|}
name|bucketCols
operator|=
name|part
operator|.
name|getBucketCols
argument_list|()
expr_stmt|;
name|inputFormatClass
operator|=
name|part
operator|.
name|getInputFormatClass
argument_list|()
expr_stmt|;
name|isArchived
operator|=
name|ArchiveUtils
operator|.
name|isArchived
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|Path
name|tabPath
init|=
name|tblObj
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|Path
name|partPath
init|=
name|part
operator|.
name|getDataLocation
argument_list|()
decl_stmt|;
comment|// if the table is in a different dfs than the partition,
comment|// replace the partition's dfs with the table's dfs.
name|newTblPartLoc
operator|=
operator|new
name|Path
argument_list|(
name|tabPath
operator|.
name|toUri
argument_list|()
operator|.
name|getScheme
argument_list|()
argument_list|,
name|tabPath
operator|.
name|toUri
argument_list|()
operator|.
name|getAuthority
argument_list|()
argument_list|,
name|partPath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|oldTblPartLoc
operator|=
name|partPath
expr_stmt|;
name|lbCtx
operator|=
name|constructListBucketingCtx
argument_list|(
name|part
operator|.
name|getSkewedColNames
argument_list|()
argument_list|,
name|part
operator|.
name|getSkewedColValues
argument_list|()
argument_list|,
name|part
operator|.
name|getSkewedColValueLocationMaps
argument_list|()
argument_list|,
name|part
operator|.
name|isStoredAsSubDirectories
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|inputFormatClass
operator|=
name|tblObj
operator|.
name|getInputFormatClass
argument_list|()
expr_stmt|;
name|bucketCols
operator|=
name|tblObj
operator|.
name|getBucketCols
argument_list|()
expr_stmt|;
comment|// input and output are the same
name|oldTblPartLoc
operator|=
name|tblObj
operator|.
name|getPath
argument_list|()
expr_stmt|;
name|newTblPartLoc
operator|=
name|tblObj
operator|.
name|getPath
argument_list|()
expr_stmt|;
name|lbCtx
operator|=
name|constructListBucketingCtx
argument_list|(
name|tblObj
operator|.
name|getSkewedColNames
argument_list|()
argument_list|,
name|tblObj
operator|.
name|getSkewedColValues
argument_list|()
argument_list|,
name|tblObj
operator|.
name|getSkewedColValueLocationMaps
argument_list|()
argument_list|,
name|tblObj
operator|.
name|isStoredAsSubDirectories
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// throw a HiveException for other than rcfile and orcfile.
if|if
condition|(
operator|!
operator|(
operator|(
name|inputFormatClass
operator|.
name|equals
argument_list|(
name|RCFileInputFormat
operator|.
name|class
argument_list|)
operator|||
operator|(
name|inputFormatClass
operator|.
name|equals
argument_list|(
name|OrcInputFormat
operator|.
name|class
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CONCATENATE_UNSUPPORTED_FILE_FORMAT
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|mergeDesc
operator|.
name|setInputFormatClass
argument_list|(
name|inputFormatClass
argument_list|)
expr_stmt|;
comment|// throw a HiveException if the table/partition is bucketized
if|if
condition|(
name|bucketCols
operator|!=
literal|null
operator|&&
name|bucketCols
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CONCATENATE_UNSUPPORTED_TABLE_BUCKETED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
comment|// throw a HiveException if the table/partition is archived
if|if
condition|(
name|isArchived
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CONCATENATE_UNSUPPORTED_PARTITION_ARCHIVED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
comment|// non-native and non-managed tables are not supported as MoveTask requires filenames to be in specific format,
comment|// violating which can cause data loss
if|if
condition|(
name|tblObj
operator|.
name|isNonNative
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CONCATENATE_UNSUPPORTED_TABLE_NON_NATIVE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|tblObj
operator|.
name|getTableType
argument_list|()
operator|!=
name|TableType
operator|.
name|MANAGED_TABLE
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CONCATENATE_UNSUPPORTED_TABLE_NOT_MANAGED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|inputDir
operator|.
name|add
argument_list|(
name|oldTblPartLoc
argument_list|)
expr_stmt|;
name|mergeDesc
operator|.
name|setInputDir
argument_list|(
name|inputDir
argument_list|)
expr_stmt|;
name|mergeDesc
operator|.
name|setLbCtx
argument_list|(
name|lbCtx
argument_list|)
expr_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
literal|null
argument_list|,
name|AlterTableType
operator|.
name|MERGEFILES
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|DDLWork2
name|ddlWork
init|=
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|mergeDesc
argument_list|)
decl_stmt|;
name|ddlWork
operator|.
name|setNeedLock
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Task
argument_list|<
name|?
argument_list|>
name|mergeTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
name|ddlWork
argument_list|)
decl_stmt|;
name|TableDesc
name|tblDesc
init|=
name|Utilities
operator|.
name|getTableDesc
argument_list|(
name|tblObj
argument_list|)
decl_stmt|;
name|Path
name|queryTmpdir
init|=
name|ctx
operator|.
name|getExternalTmpPath
argument_list|(
name|newTblPartLoc
argument_list|)
decl_stmt|;
name|mergeDesc
operator|.
name|setOutputDir
argument_list|(
name|queryTmpdir
argument_list|)
expr_stmt|;
comment|// No need to handle MM tables - unsupported path.
name|LoadTableDesc
name|ltd
init|=
operator|new
name|LoadTableDesc
argument_list|(
name|queryTmpdir
argument_list|,
name|tblDesc
argument_list|,
name|partSpec
operator|==
literal|null
condition|?
operator|new
name|HashMap
argument_list|<>
argument_list|()
else|:
name|partSpec
argument_list|)
decl_stmt|;
name|ltd
operator|.
name|setLbCtx
argument_list|(
name|lbCtx
argument_list|)
expr_stmt|;
name|ltd
operator|.
name|setInheritTableSpecs
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Task
argument_list|<
name|MoveWork
argument_list|>
name|moveTsk
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|MoveWork
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
name|ltd
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|mergeTask
operator|.
name|addDependentTask
argument_list|(
name|moveTsk
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESTATSAUTOGATHER
argument_list|)
condition|)
block|{
name|BasicStatsWork
name|basicStatsWork
decl_stmt|;
if|if
condition|(
name|oldTblPartLoc
operator|.
name|equals
argument_list|(
name|newTblPartLoc
argument_list|)
condition|)
block|{
comment|// If we're merging to the same location, we can avoid some metastore calls
name|TableSpec
name|tableSpec
init|=
operator|new
name|TableSpec
argument_list|(
name|db
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
decl_stmt|;
name|basicStatsWork
operator|=
operator|new
name|BasicStatsWork
argument_list|(
name|tableSpec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|basicStatsWork
operator|=
operator|new
name|BasicStatsWork
argument_list|(
name|ltd
argument_list|)
expr_stmt|;
block|}
name|basicStatsWork
operator|.
name|setNoStatsAggregator
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|basicStatsWork
operator|.
name|setClearAggregatorStats
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|StatsWork
name|columnStatsWork
init|=
operator|new
name|StatsWork
argument_list|(
name|tblObj
argument_list|,
name|basicStatsWork
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|Task
argument_list|<
name|?
argument_list|>
name|statTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
name|columnStatsWork
argument_list|)
decl_stmt|;
name|moveTsk
operator|.
name|addDependentTask
argument_list|(
name|statTask
argument_list|)
expr_stmt|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|mergeTask
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|analyzeAlterTableClusterSort
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|AbstractAlterTableDesc
name|alterTblDesc
decl_stmt|;
switch|switch
condition|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_NOT_CLUSTERED
case|:
name|alterTblDesc
operator|=
operator|new
name|AlterTableNotClusteredDesc
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_NOT_SORTED
case|:
name|alterTblDesc
operator|=
operator|new
name|AlterTableNotSortedDesc
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERTABLE_BUCKETS
case|:
name|ASTNode
name|buckets
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|bucketCols
init|=
name|getColumnNames
argument_list|(
operator|(
name|ASTNode
operator|)
name|buckets
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Order
argument_list|>
name|sortCols
init|=
operator|new
name|ArrayList
argument_list|<
name|Order
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|numBuckets
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|buckets
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|numBuckets
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|buckets
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sortCols
operator|=
name|getColumnNamesOrder
argument_list|(
operator|(
name|ASTNode
operator|)
name|buckets
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|numBuckets
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|buckets
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numBuckets
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_BUCKET_NUMBER
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|alterTblDesc
operator|=
operator|new
name|AlterTableClusteredByDesc
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|numBuckets
argument_list|,
name|bucketCols
argument_list|,
name|sortCols
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Invalid operation "
operator|+
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
throw|;
block|}
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|alterTblDesc
argument_list|,
name|alterTblDesc
operator|.
name|getType
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableCompact
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|type
init|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"minor"
argument_list|)
operator|&&
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|COMPACTOR_CRUD_QUERY_BASED
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Minor compaction is not currently supported for query based compaction (enabled by setting: "
operator|+
name|ConfVars
operator|.
name|COMPACTOR_CRUD_QUERY_BASED
operator|+
literal|" to true)."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|type
operator|.
name|equals
argument_list|(
literal|"minor"
argument_list|)
operator|&&
operator|!
name|type
operator|.
name|equals
argument_list|(
literal|"major"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COMPACTION_TYPE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|newPartSpec
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|partSpec
operator|!=
literal|null
condition|)
block|{
name|newPartSpec
operator|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|partSpec
argument_list|)
expr_stmt|;
block|}
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapProp
init|=
literal|null
decl_stmt|;
name|boolean
name|isBlocking
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABLEPROPERTIES
case|:
name|mapProp
operator|=
name|getProps
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_BLOCKING
case|:
name|isBlocking
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
name|AlterTableCompactDesc
name|desc
init|=
operator|new
name|AlterTableCompactDesc
argument_list|(
name|tableName
argument_list|,
name|newPartSpec
argument_list|,
name|type
argument_list|,
name|isBlocking
argument_list|,
name|mapProp
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|desc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableDropConstraint
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|constraintName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|AlterTableDropConstraintDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDropConstraintDesc
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|,
name|constraintName
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableAddConstraint
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|parent
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|String
index|[]
name|qualifiedTabName
init|=
name|getQualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|parent
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|// TODO CAT - for now always use the default catalog.  Eventually will want to see if
comment|// the user specified a catalog
name|String
name|catName
init|=
name|MetaStoreUtils
operator|.
name|getDefaultCatalog
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|SQLPrimaryKey
argument_list|>
name|primaryKeys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SQLForeignKey
argument_list|>
name|foreignKeys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SQLUniqueConstraint
argument_list|>
name|uniqueConstraints
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SQLCheckConstraint
argument_list|>
name|checkConstraints
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_UNIQUE
case|:
name|BaseSemanticAnalyzer
operator|.
name|processUniqueConstraints
argument_list|(
name|catName
argument_list|,
name|qualifiedTabName
index|[
literal|0
index|]
argument_list|,
name|qualifiedTabName
index|[
literal|1
index|]
argument_list|,
name|child
argument_list|,
name|uniqueConstraints
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_PRIMARY_KEY
case|:
name|BaseSemanticAnalyzer
operator|.
name|processPrimaryKeys
argument_list|(
name|qualifiedTabName
index|[
literal|0
index|]
argument_list|,
name|qualifiedTabName
index|[
literal|1
index|]
argument_list|,
name|child
argument_list|,
name|primaryKeys
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_FOREIGN_KEY
case|:
name|BaseSemanticAnalyzer
operator|.
name|processForeignKeys
argument_list|(
name|qualifiedTabName
index|[
literal|0
index|]
argument_list|,
name|qualifiedTabName
index|[
literal|1
index|]
argument_list|,
name|child
argument_list|,
name|foreignKeys
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_CHECK_CONSTRAINT
case|:
name|BaseSemanticAnalyzer
operator|.
name|processCheckConstraints
argument_list|(
name|catName
argument_list|,
name|qualifiedTabName
index|[
literal|0
index|]
argument_list|,
name|qualifiedTabName
index|[
literal|1
index|]
argument_list|,
name|child
argument_list|,
literal|null
argument_list|,
name|checkConstraints
argument_list|,
name|child
argument_list|,
name|this
operator|.
name|ctx
operator|.
name|getTokenRewriteStream
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NOT_RECOGNIZED_CONSTRAINT
operator|.
name|getMsg
argument_list|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|Constraints
name|constraints
init|=
operator|new
name|Constraints
argument_list|(
name|primaryKeys
argument_list|,
name|foreignKeys
argument_list|,
literal|null
argument_list|,
name|uniqueConstraints
argument_list|,
literal|null
argument_list|,
name|checkConstraints
argument_list|)
decl_stmt|;
name|AlterTableAddConstraintDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableAddConstraintDesc
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|,
name|constraints
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableUpdateColumns
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|boolean
name|isCascade
init|=
literal|false
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|ast
operator|.
name|getFirstChildWithType
argument_list|(
name|HiveParser
operator|.
name|TOK_CASCADE
argument_list|)
condition|)
block|{
name|isCascade
operator|=
literal|true
expr_stmt|;
block|}
name|AlterTableUpdateColumnsDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableUpdateColumnsDesc
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|isCascade
argument_list|)
decl_stmt|;
name|Table
name|tbl
init|=
name|getTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|AcidUtils
operator|.
name|isTransactionalTable
argument_list|(
name|tbl
argument_list|)
condition|)
block|{
name|setAcidDdlDesc
argument_list|(
name|alterTblDesc
argument_list|)
expr_stmt|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|static
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getProps
parameter_list|(
name|ASTNode
name|prop
parameter_list|)
block|{
comment|// Must be deterministic order map for consistent q-test output across Java versions
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapProp
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|readProps
argument_list|(
name|prop
argument_list|,
name|mapProp
argument_list|)
expr_stmt|;
return|return
name|mapProp
return|;
block|}
comment|/**    * Utility class to resolve QualifiedName    */
specifier|static
class|class
name|QualifiedNameUtil
block|{
comment|// delimiter to check DOT delimited qualified names
specifier|static
specifier|final
name|String
name|delimiter
init|=
literal|"\\."
decl_stmt|;
comment|/**      * Get the fully qualified name in the ast. e.g. the ast of the form ^(DOT      * ^(DOT a b) c) will generate a name of the form a.b.c      *      * @param ast      *          The AST from which the qualified name has to be extracted      * @return String      */
specifier|static
specifier|public
name|String
name|getFullyQualifiedName
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
block|{
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|ast
operator|.
name|getText
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
return|return
name|getFullyQualifiedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|+
literal|"."
operator|+
name|getFullyQualifiedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|3
condition|)
block|{
return|return
name|getFullyQualifiedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|+
literal|"."
operator|+
name|getFullyQualifiedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|+
literal|"."
operator|+
name|getFullyQualifiedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|// get the column path
comment|// return column name if exists, column could be DOT separated.
comment|// example: lintString.$elem$.myint
comment|// return table name for column name if no column has been specified.
specifier|static
specifier|public
name|String
name|getColPath
parameter_list|(
name|Hive
name|db
parameter_list|,
name|ASTNode
name|node
parameter_list|,
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// if this ast has only one child, then no column name specified.
if|if
condition|(
name|node
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
name|tableName
return|;
block|}
name|ASTNode
name|columnNode
init|=
literal|null
decl_stmt|;
comment|// Second child node could be partitionspec or column
if|if
condition|(
name|node
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|partSpec
operator|==
literal|null
condition|)
block|{
name|columnNode
operator|=
operator|(
name|ASTNode
operator|)
name|node
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|columnNode
operator|=
operator|(
name|ASTNode
operator|)
name|node
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|columnNode
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|dbName
operator|==
literal|null
condition|)
block|{
return|return
name|tableName
operator|+
literal|"."
operator|+
name|QualifiedNameUtil
operator|.
name|getFullyQualifiedName
argument_list|(
name|columnNode
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|tableName
operator|.
name|substring
argument_list|(
name|dbName
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|,
name|tableName
operator|.
name|length
argument_list|()
argument_list|)
operator|+
literal|"."
operator|+
name|QualifiedNameUtil
operator|.
name|getFullyQualifiedName
argument_list|(
name|columnNode
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
name|tableName
return|;
block|}
block|}
comment|// get partition metadata
specifier|static
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getPartitionSpec
parameter_list|(
name|Hive
name|db
parameter_list|,
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|partNode
init|=
literal|null
decl_stmt|;
comment|// if this ast has only one child, then no partition spec specified.
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// if ast has two children
comment|// the 2nd child could be partition spec or columnName
comment|// if the ast has 3 children, the second *has to* be partition spec
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|2
operator|&&
operator|(
operator|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_PARTSPEC
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
operator|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|getType
argument_list|()
operator|+
literal|" is not a partition specification"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PARTSPEC
condition|)
block|{
name|partNode
operator|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|partNode
operator|!=
literal|null
condition|)
block|{
name|Table
name|tab
init|=
literal|null
decl_stmt|;
try|try
block|{
name|tab
operator|=
name|db
operator|.
name|getTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidTableException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
try|try
block|{
name|partSpec
operator|=
name|getValidatedPartSpec
argument_list|(
name|tab
argument_list|,
name|partNode
argument_list|,
name|db
operator|.
name|getConf
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|e
parameter_list|)
block|{
comment|// get exception in resolving partition
comment|// it could be DESCRIBE table key
comment|// return null
comment|// continue processing for DESCRIBE table key
return|return
literal|null
return|;
block|}
if|if
condition|(
name|partSpec
operator|!=
literal|null
condition|)
block|{
name|Partition
name|part
init|=
literal|null
decl_stmt|;
try|try
block|{
name|part
operator|=
name|db
operator|.
name|getPartition
argument_list|(
name|tab
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
comment|// if get exception in finding partition
comment|// it could be DESCRIBE table key
comment|// return null
comment|// continue processing for DESCRIBE table key
return|return
literal|null
return|;
block|}
comment|// if partition is not found
comment|// it is DESCRIBE table partition
comment|// invalid partition exception
if|if
condition|(
name|part
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_PARTITION
operator|.
name|getMsg
argument_list|(
name|partSpec
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|// it is DESCRIBE table partition
comment|// return partition metadata
return|return
name|partSpec
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
specifier|private
name|void
name|validateDatabase
parameter_list|(
name|String
name|databaseName
parameter_list|)
throws|throws
name|SemanticException
block|{
try|try
block|{
if|if
condition|(
operator|!
name|db
operator|.
name|databaseExists
argument_list|(
name|databaseName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|DATABASE_NOT_EXISTS
operator|.
name|getMsg
argument_list|(
name|databaseName
argument_list|)
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|DATABASE_NOT_EXISTS
operator|.
name|getMsg
argument_list|(
name|databaseName
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|validateTable
parameter_list|(
name|String
name|tableName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|partSpec
operator|!=
literal|null
condition|)
block|{
name|getPartition
argument_list|(
name|tab
argument_list|,
name|partSpec
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * A query like this will generate a tree as follows    *   "describe formatted default.maptable partition (b=100) id;"    * TOK_TABTYPE    *   TOK_TABNAME --> root for tablename, 2 child nodes mean DB specified    *     default    *     maptable    *   TOK_PARTSPEC  --> root node for partition spec. else columnName    *     TOK_PARTVAL    *       b    *       100    *   id           --> root node for columnName    * formatted    */
specifier|private
name|void
name|analyzeDescribeTable
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|tableTypeExpr
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|dbName
init|=
literal|null
decl_stmt|;
name|String
name|tableName
init|=
literal|null
decl_stmt|;
name|String
name|colPath
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
name|ASTNode
name|tableNode
init|=
literal|null
decl_stmt|;
comment|// process the first node to extract tablename
comment|// tablename is either TABLENAME or DBNAME.TABLENAME if db is given
if|if
condition|(
operator|(
operator|(
name|ASTNode
operator|)
name|tableTypeExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABNAME
condition|)
block|{
name|tableNode
operator|=
operator|(
name|ASTNode
operator|)
name|tableTypeExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tableNode
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|tableName
operator|=
operator|(
operator|(
name|ASTNode
operator|)
name|tableNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|dbName
operator|=
operator|(
operator|(
name|ASTNode
operator|)
name|tableNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getText
argument_list|()
expr_stmt|;
name|tableName
operator|=
name|dbName
operator|+
literal|"."
operator|+
operator|(
operator|(
name|ASTNode
operator|)
name|tableNode
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
operator|(
operator|(
name|ASTNode
operator|)
name|tableTypeExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getText
argument_list|()
operator|+
literal|" is not an expected token type"
argument_list|)
throw|;
block|}
comment|// process the second child,if exists, node to get partition spec(s)
name|partSpec
operator|=
name|QualifiedNameUtil
operator|.
name|getPartitionSpec
argument_list|(
name|db
argument_list|,
name|tableTypeExpr
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
comment|// process the third child node,if exists, to get partition spec(s)
name|colPath
operator|=
name|QualifiedNameUtil
operator|.
name|getColPath
argument_list|(
name|db
argument_list|,
name|tableTypeExpr
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
comment|// if database is not the one currently using
comment|// validate database
if|if
condition|(
name|dbName
operator|!=
literal|null
condition|)
block|{
name|validateDatabase
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|partSpec
operator|!=
literal|null
condition|)
block|{
name|validateTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
name|boolean
name|showColStats
init|=
literal|false
decl_stmt|;
name|boolean
name|isFormatted
init|=
literal|false
decl_stmt|;
name|boolean
name|isExt
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|int
name|descOptions
init|=
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|isFormatted
operator|=
name|descOptions
operator|==
name|HiveParser
operator|.
name|KW_FORMATTED
expr_stmt|;
name|isExt
operator|=
name|descOptions
operator|==
name|HiveParser
operator|.
name|KW_EXTENDED
expr_stmt|;
comment|// in case of "DESCRIBE FORMATTED tablename column_name" statement, colPath
comment|// will contain tablename.column_name. If column_name is not specified
comment|// colPath will be equal to tableName. This is how we can differentiate
comment|// if we are describing a table or column
if|if
condition|(
operator|!
name|colPath
operator|.
name|equalsIgnoreCase
argument_list|(
name|tableName
argument_list|)
operator|&&
name|isFormatted
condition|)
block|{
name|showColStats
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|getTable
argument_list|(
name|tableName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DescTableDesc
name|descTblDesc
init|=
operator|new
name|DescTableDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|colPath
argument_list|,
name|isExt
argument_list|,
name|isFormatted
argument_list|)
decl_stmt|;
name|Task
argument_list|<
name|?
argument_list|>
name|ddlTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|descTblDesc
argument_list|)
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|ddlTask
argument_list|)
expr_stmt|;
name|String
name|schema
init|=
name|DescTableDesc
operator|.
name|getSchema
argument_list|(
name|showColStats
argument_list|)
decl_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|schema
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"analyzeDescribeTable done"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Describe database.    *    * @param ast    * @throws SemanticException    */
specifier|private
name|void
name|analyzeDescDatabase
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|boolean
name|isExtended
decl_stmt|;
name|String
name|dbName
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|dbName
operator|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|isExtended
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|dbName
operator|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|isExtended
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unexpected Tokens at DESCRIBE DATABASE"
argument_list|)
throw|;
block|}
name|DescDatabaseDesc
name|descDbDesc
init|=
operator|new
name|DescDatabaseDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|dbName
argument_list|,
name|isExtended
argument_list|)
decl_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|getDatabase
argument_list|(
name|dbName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|descDbDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|DescDatabaseDesc
operator|.
name|DESC_DATABASE_SCHEMA
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getPartSpec
parameter_list|(
name|ASTNode
name|partspec
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|partspec
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partspec
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|partspec_val
init|=
operator|(
name|ASTNode
operator|)
name|partspec
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|key
init|=
name|partspec_val
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|String
name|val
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|partspec_val
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
name|val
operator|=
name|stripQuotes
argument_list|(
name|partspec_val
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|partSpec
operator|.
name|put
argument_list|(
name|key
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|partSpec
return|;
block|}
specifier|public
specifier|static
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getValidatedPartSpec
parameter_list|(
name|Table
name|table
parameter_list|,
name|ASTNode
name|astNode
parameter_list|,
name|HiveConf
name|conf
parameter_list|,
name|boolean
name|shouldBeFull
parameter_list|)
throws|throws
name|SemanticException
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
name|getPartSpec
argument_list|(
name|astNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|partSpec
operator|!=
literal|null
operator|&&
operator|!
name|partSpec
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|validatePartSpec
argument_list|(
name|table
argument_list|,
name|partSpec
argument_list|,
name|astNode
argument_list|,
name|conf
argument_list|,
name|shouldBeFull
argument_list|)
expr_stmt|;
block|}
return|return
name|partSpec
return|;
block|}
specifier|private
name|void
name|analyzeShowPartitions
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowPartitionsDesc
name|showPartsDesc
decl_stmt|;
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
init|=
name|getPartitionSpecs
argument_list|(
name|getTable
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|ast
argument_list|)
decl_stmt|;
comment|// We only can have a single partition spec
assert|assert
operator|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|<=
literal|1
operator|)
assert|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|partSpec
operator|=
name|partSpecs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|validateTable
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|showPartsDesc
operator|=
operator|new
name|ShowPartitionsDesc
argument_list|(
name|tableName
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|getTable
argument_list|(
name|tableName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showPartsDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|ShowPartitionsDesc
operator|.
name|SCHEMA
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowCreateDatabase
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|dbName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|ShowCreateDatabaseDesc
name|showCreateDbDesc
init|=
operator|new
name|ShowCreateDatabaseDesc
argument_list|(
name|dbName
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Database
name|database
init|=
name|getDatabase
argument_list|(
name|dbName
argument_list|)
decl_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|database
argument_list|)
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showCreateDbDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|ShowCreateDatabaseDesc
operator|.
name|SCHEMA
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowCreateTable
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowCreateTableDesc
name|showCreateTblDesc
decl_stmt|;
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|showCreateTblDesc
operator|=
operator|new
name|ShowCreateTableDesc
argument_list|(
name|tableName
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showCreateTblDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|ShowCreateTableDesc
operator|.
name|SCHEMA
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowDatabases
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowDatabasesDesc
name|showDatabasesDesc
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|String
name|databasePattern
init|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|showDatabasesDesc
operator|=
operator|new
name|ShowDatabasesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|databasePattern
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|showDatabasesDesc
operator|=
operator|new
name|ShowDatabasesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showDatabasesDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|ShowDatabasesDesc
operator|.
name|SHOW_DATABASES_SCHEMA
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowTables
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowTablesDesc
name|showTblsDesc
decl_stmt|;
name|String
name|dbName
init|=
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getCurrentDatabase
argument_list|()
decl_stmt|;
name|String
name|tableNames
init|=
literal|null
decl_stmt|;
name|TableType
name|tableTypeFilter
init|=
literal|null
decl_stmt|;
name|boolean
name|isExtended
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|4
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_AST_TREE
operator|.
name|getMsg
argument_list|(
name|ast
operator|.
name|toStringTree
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FROM
condition|)
block|{
comment|// Specifies a DB
name|dbName
operator|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
operator|++
name|i
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|validateDatabase
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_TYPE
condition|)
block|{
comment|// Filter on table type
name|String
name|tableType
init|=
name|unescapeIdentifier
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tableType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"table_type"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"SHOW TABLES statement only allows equality filter on table_type value"
argument_list|)
throw|;
block|}
name|tableTypeFilter
operator|=
name|TableType
operator|.
name|valueOf
argument_list|(
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|KW_EXTENDED
condition|)
block|{
comment|// Include table type
name|isExtended
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// Uses a pattern
name|tableNames
operator|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|showTblsDesc
operator|=
operator|new
name|ShowTablesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|dbName
argument_list|,
name|tableNames
argument_list|,
name|tableTypeFilter
argument_list|,
name|isExtended
argument_list|)
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|getDatabase
argument_list|(
name|dbName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showTblsDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showTblsDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowColumns
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// table name has to be present so min child 1 and max child 4
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|4
operator|||
name|ast
operator|.
name|getChildCount
argument_list|()
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_AST_TREE
operator|.
name|getMsg
argument_list|(
name|ast
operator|.
name|toStringTree
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|ShowColumnsDesc
name|showColumnsDesc
init|=
literal|null
decl_stmt|;
name|String
name|pattern
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
comment|//  only tablename no pattern and db
name|showColumnsDesc
operator|=
operator|new
name|ShowColumnsDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|// tablename and pattern
name|pattern
operator|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|showColumnsDesc
operator|=
operator|new
name|ShowColumnsDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|tableName
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|// specifies db
if|if
condition|(
name|tableName
operator|.
name|contains
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Duplicates declaration for database name"
argument_list|)
throw|;
block|}
name|tableName
operator|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
argument_list|)
operator|+
literal|"."
operator|+
name|tableName
expr_stmt|;
name|showColumnsDesc
operator|=
operator|new
name|ShowColumnsDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|// specifies db and pattern
if|if
condition|(
name|tableName
operator|.
name|contains
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Duplicates declaration for database name"
argument_list|)
throw|;
block|}
name|tableName
operator|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
argument_list|)
operator|+
literal|"."
operator|+
name|tableName
expr_stmt|;
name|pattern
operator|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|3
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|showColumnsDesc
operator|=
operator|new
name|ShowColumnsDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|tableName
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showColumnsDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|ShowColumnsDesc
operator|.
name|SCHEMA
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowTableStatus
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowTableStatusDesc
name|showTblStatusDesc
decl_stmt|;
name|String
name|tableNames
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|dbName
init|=
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getCurrentDatabase
argument_list|()
decl_stmt|;
name|int
name|children
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|children
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|children
operator|>
literal|3
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_AST_TREE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|children
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|Identifier
condition|)
block|{
name|dbName
operator|=
name|unescapeIdentifier
argument_list|(
name|child
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PARTSPEC
condition|)
block|{
name|partSpec
operator|=
name|getValidatedPartSpec
argument_list|(
name|getTable
argument_list|(
name|tableNames
argument_list|)
argument_list|,
name|child
argument_list|,
name|conf
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_AST_TREE
operator|.
name|getMsg
argument_list|(
name|child
operator|.
name|toStringTree
argument_list|()
operator|+
literal|" , Invalid token "
operator|+
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|partSpec
operator|!=
literal|null
condition|)
block|{
name|validateTable
argument_list|(
name|tableNames
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
name|showTblStatusDesc
operator|=
operator|new
name|ShowTableStatusDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|dbName
argument_list|,
name|tableNames
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showTblStatusDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|ShowTableStatusDesc
operator|.
name|SCHEMA
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowTableProperties
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowTablePropertiesDesc
name|showTblPropertiesDesc
decl_stmt|;
name|String
index|[]
name|qualified
init|=
name|getQualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|propertyName
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
name|propertyName
operator|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
name|tableNames
init|=
name|getDotName
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|validateTable
argument_list|(
name|tableNames
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|showTblPropertiesDesc
operator|=
operator|new
name|ShowTablePropertiesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|tableNames
argument_list|,
name|propertyName
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showTblPropertiesDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|ShowTablePropertiesDesc
operator|.
name|SCHEMA
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the task according to the parsed command tree. This is used for the CLI    * command "SHOW FUNCTIONS;".    *    * @param ast    *          The parsed command tree.    * @throws SemanticException    *           Parsin failed    */
specifier|private
name|void
name|analyzeShowFunctions
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowFunctionsDesc
name|showFuncsDesc
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|String
name|funcNames
init|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|showFuncsDesc
operator|=
operator|new
name|ShowFunctionsDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|funcNames
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
assert|assert
operator|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|KW_LIKE
operator|)
assert|;
name|String
name|funcNames
init|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|showFuncsDesc
operator|=
operator|new
name|ShowFunctionsDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|funcNames
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|showFuncsDesc
operator|=
operator|new
name|ShowFunctionsDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showFuncsDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|ShowFunctionsDesc
operator|.
name|SCHEMA
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the task according to the parsed command tree. This is used for the CLI    * command "SHOW LOCKS;".    *    * @param ast    *          The parsed command tree.    * @throws SemanticException    *           Parsing failed    */
specifier|private
name|void
name|analyzeShowLocks
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
literal|null
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
name|boolean
name|isExtended
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>=
literal|1
condition|)
block|{
comment|// table for which show locks is being executed
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABTYPE
condition|)
block|{
name|ASTNode
name|tableTypeExpr
init|=
name|child
decl_stmt|;
name|tableName
operator|=
name|QualifiedNameUtil
operator|.
name|getFullyQualifiedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|tableTypeExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// get partition metadata if partition specified
if|if
condition|(
name|tableTypeExpr
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|ASTNode
name|partSpecNode
init|=
operator|(
name|ASTNode
operator|)
name|tableTypeExpr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|partSpec
operator|=
name|getValidatedPartSpec
argument_list|(
name|getTable
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|partSpecNode
argument_list|,
name|conf
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|KW_EXTENDED
condition|)
block|{
name|isExtended
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
name|HiveTxnManager
name|txnManager
init|=
literal|null
decl_stmt|;
try|try
block|{
name|txnManager
operator|=
name|TxnManagerFactory
operator|.
name|getTxnManagerFactory
argument_list|()
operator|.
name|getTxnManager
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
name|ShowLocksDesc
name|showLocksDesc
init|=
operator|new
name|ShowLocksDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|isExtended
argument_list|,
name|txnManager
operator|.
name|useNewShowLocksFormat
argument_list|()
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showLocksDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showLocksDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Need to initialize the lock manager
name|ctx
operator|.
name|setNeedLockMgr
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add the task according to the parsed command tree. This is used for the CLI    * command "SHOW LOCKS DATABASE database [extended];".    *    * @param ast    *          The parsed command tree.    * @throws SemanticException    *           Parsing failed    */
specifier|private
name|void
name|analyzeShowDbLocks
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|boolean
name|isExtended
init|=
operator|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
operator|)
decl_stmt|;
name|String
name|dbName
init|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|HiveTxnManager
name|txnManager
init|=
literal|null
decl_stmt|;
try|try
block|{
name|txnManager
operator|=
name|TxnManagerFactory
operator|.
name|getTxnManagerFactory
argument_list|()
operator|.
name|getTxnManager
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
name|ShowLocksDesc
name|showLocksDesc
init|=
operator|new
name|ShowLocksDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|dbName
argument_list|,
name|isExtended
argument_list|,
name|txnManager
operator|.
name|useNewShowLocksFormat
argument_list|()
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showLocksDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showLocksDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Need to initialize the lock manager
name|ctx
operator|.
name|setNeedLockMgr
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowConf
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|confName
init|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|ShowConfDesc
name|showConfDesc
init|=
operator|new
name|ShowConfDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|confName
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showConfDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|ShowConfDesc
operator|.
name|SCHEMA
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowViews
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowTablesDesc
name|showViewsDesc
decl_stmt|;
name|String
name|dbName
init|=
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getCurrentDatabase
argument_list|()
decl_stmt|;
name|String
name|viewNames
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|3
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|GENERIC_ERROR
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
comment|// Uses a pattern
name|viewNames
operator|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|showViewsDesc
operator|=
operator|new
name|ShowTablesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|dbName
argument_list|,
name|viewNames
argument_list|,
name|TableType
operator|.
name|VIRTUAL_VIEW
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|// Specifies a DB
assert|assert
operator|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FROM
operator|)
assert|;
name|dbName
operator|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|validateDatabase
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|showViewsDesc
operator|=
operator|new
name|ShowTablesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|dbName
argument_list|,
name|TableType
operator|.
name|VIRTUAL_VIEW
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|// Uses a pattern and specifies a DB
assert|assert
operator|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FROM
operator|)
assert|;
name|dbName
operator|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|viewNames
operator|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|validateDatabase
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|showViewsDesc
operator|=
operator|new
name|ShowTablesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|dbName
argument_list|,
name|viewNames
argument_list|,
name|TableType
operator|.
name|VIRTUAL_VIEW
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// No pattern or DB
name|showViewsDesc
operator|=
operator|new
name|ShowTablesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|dbName
argument_list|,
name|TableType
operator|.
name|VIRTUAL_VIEW
argument_list|)
expr_stmt|;
break|break;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showViewsDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showViewsDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowMaterializedViews
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowTablesDesc
name|showMaterializedViewsDesc
decl_stmt|;
name|String
name|dbName
init|=
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getCurrentDatabase
argument_list|()
decl_stmt|;
name|String
name|materializedViewNames
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|3
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|GENERIC_ERROR
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
comment|// Uses a pattern
name|materializedViewNames
operator|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|showMaterializedViewsDesc
operator|=
operator|new
name|ShowTablesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|dbName
argument_list|,
name|materializedViewNames
argument_list|,
name|TableType
operator|.
name|MATERIALIZED_VIEW
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|// Specifies a DB
assert|assert
operator|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FROM
operator|)
assert|;
name|dbName
operator|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|validateDatabase
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|showMaterializedViewsDesc
operator|=
operator|new
name|ShowTablesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|dbName
argument_list|,
name|TableType
operator|.
name|MATERIALIZED_VIEW
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|// Uses a pattern and specifies a DB
assert|assert
operator|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FROM
operator|)
assert|;
name|dbName
operator|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|materializedViewNames
operator|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|validateDatabase
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|showMaterializedViewsDesc
operator|=
operator|new
name|ShowTablesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|dbName
argument_list|,
name|materializedViewNames
argument_list|,
name|TableType
operator|.
name|MATERIALIZED_VIEW
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// No pattern or DB
name|showMaterializedViewsDesc
operator|=
operator|new
name|ShowTablesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|dbName
argument_list|,
name|TableType
operator|.
name|MATERIALIZED_VIEW
argument_list|)
expr_stmt|;
break|break;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showMaterializedViewsDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showMaterializedViewsDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the task according to the parsed command tree. This is used for the CLI    * command "LOCK TABLE ..;".    *    * @param ast    *          The parsed command tree.    * @throws SemanticException    *           Parsing failed    */
specifier|private
name|void
name|analyzeLockTable
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|String
name|mode
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toUpperCase
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
init|=
name|getPartitionSpecs
argument_list|(
name|getTable
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|ast
argument_list|)
decl_stmt|;
comment|// We only can have a single partition spec
assert|assert
operator|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|<=
literal|1
operator|)
assert|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|partSpec
operator|=
name|partSpecs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|LockTableDesc
name|lockTblDesc
init|=
operator|new
name|LockTableDesc
argument_list|(
name|tableName
argument_list|,
name|mode
argument_list|,
name|partSpec
argument_list|,
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVEQUERYID
argument_list|)
argument_list|,
name|ctx
operator|.
name|getCmd
argument_list|()
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|lockTblDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Need to initialize the lock manager
name|ctx
operator|.
name|setNeedLockMgr
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a task to execute "SHOW COMPACTIONS"    * @param ast The parsed command tree.    * @throws SemanticException Parsing failed.    */
specifier|private
name|void
name|analyzeShowCompactions
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowCompactionsDesc
name|desc
init|=
operator|new
name|ShowCompactionsDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|desc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|ShowCompactionsDesc
operator|.
name|SCHEMA
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a task to execute "SHOW COMPACTIONS"    * @param ast The parsed command tree.    * @throws SemanticException Parsing failed.    */
specifier|private
name|void
name|analyzeShowTxns
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowTransactionsDesc
name|desc
init|=
operator|new
name|ShowTransactionsDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|desc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|ShowTransactionsDesc
operator|.
name|SCHEMA
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a task to execute "ABORT TRANSACTIONS"    * @param ast The parsed command tree    * @throws SemanticException Parsing failed    */
specifier|private
name|void
name|analyzeAbortTxns
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|Long
argument_list|>
name|txnids
init|=
operator|new
name|ArrayList
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|numChildren
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numChildren
condition|;
name|i
operator|++
control|)
block|{
name|txnids
operator|.
name|add
argument_list|(
name|Long
operator|.
name|parseLong
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|AbortTransactionsDesc
name|desc
init|=
operator|new
name|AbortTransactionsDesc
argument_list|(
name|txnids
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|desc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a task to execute "Kill query"    * @param ast The parsed command tree    * @throws SemanticException Parsing failed    */
specifier|private
name|void
name|analyzeKillQuery
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|queryIds
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|numChildren
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numChildren
condition|;
name|i
operator|++
control|)
block|{
name|queryIds
operator|.
name|add
argument_list|(
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|addServiceOutput
argument_list|()
expr_stmt|;
name|KillQueriesDesc
name|desc
init|=
operator|new
name|KillQueriesDesc
argument_list|(
name|queryIds
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|desc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addServiceOutput
parameter_list|()
throws|throws
name|SemanticException
block|{
name|String
name|hs2Hostname
init|=
name|getHS2Host
argument_list|()
decl_stmt|;
if|if
condition|(
name|hs2Hostname
operator|!=
literal|null
condition|)
block|{
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|hs2Hostname
argument_list|,
name|Type
operator|.
name|SERVICE_NAME
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|String
name|getHS2Host
parameter_list|()
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|isHiveServerQuery
argument_list|()
condition|)
block|{
return|return
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getHiveServer2Host
argument_list|()
return|;
block|}
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_TEST_AUTHORIZATION_SQLSTD_HS2_MODE
argument_list|)
condition|)
block|{
comment|// dummy value for use in tests
return|return
literal|"dummyHostnameForTest"
return|;
block|}
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Kill query is only supported in HiveServer2 (not hive cli)"
argument_list|)
throw|;
block|}
comment|/**    * Add the task according to the parsed command tree. This is used for the CLI    * command "UNLOCK TABLE ..;".    *    * @param ast    *          The parsed command tree.    * @throws SemanticException    *           Parsing failed    */
specifier|private
name|void
name|analyzeUnlockTable
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
init|=
name|getPartitionSpecs
argument_list|(
name|getTable
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|ast
argument_list|)
decl_stmt|;
comment|// We only can have a single partition spec
assert|assert
operator|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|<=
literal|1
operator|)
assert|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|partSpec
operator|=
name|partSpecs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|UnlockTableDesc
name|unlockTblDesc
init|=
operator|new
name|UnlockTableDesc
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|unlockTblDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Need to initialize the lock manager
name|ctx
operator|.
name|setNeedLockMgr
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeLockDatabase
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|dbName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|mode
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toUpperCase
argument_list|()
argument_list|)
decl_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|getDatabase
argument_list|(
name|dbName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Lock database operation is to acquire the lock explicitly, the operation
comment|// itself doesn't need to be locked. Set the WriteEntity as WriteType:
comment|// DDL_NO_LOCK here, otherwise it will conflict with Hive's transaction.
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|getDatabase
argument_list|(
name|dbName
argument_list|)
argument_list|,
name|WriteType
operator|.
name|DDL_NO_LOCK
argument_list|)
argument_list|)
expr_stmt|;
name|LockDatabaseDesc
name|lockDatabaseDesc
init|=
operator|new
name|LockDatabaseDesc
argument_list|(
name|dbName
argument_list|,
name|mode
argument_list|,
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVEQUERYID
argument_list|)
argument_list|,
name|ctx
operator|.
name|getCmd
argument_list|()
argument_list|)
decl_stmt|;
name|DDLWork2
name|work
init|=
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|lockDatabaseDesc
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setNeedLockMgr
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeUnlockDatabase
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|dbName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|getDatabase
argument_list|(
name|dbName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Unlock database operation is to release the lock explicitly, the
comment|// operation itself don't need to be locked. Set the WriteEntity as
comment|// WriteType: DDL_NO_LOCK here, otherwise it will conflict with
comment|// Hive's transaction.
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|getDatabase
argument_list|(
name|dbName
argument_list|)
argument_list|,
name|WriteType
operator|.
name|DDL_NO_LOCK
argument_list|)
argument_list|)
expr_stmt|;
name|UnlockDatabaseDesc
name|unlockDatabaseDesc
init|=
operator|new
name|UnlockDatabaseDesc
argument_list|(
name|dbName
argument_list|)
decl_stmt|;
name|DDLWork2
name|work
init|=
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|unlockDatabaseDesc
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
comment|// Need to initialize the lock manager
name|ctx
operator|.
name|setNeedLockMgr
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the task according to the parsed command tree. This is used for the CLI    * command "DESCRIBE FUNCTION;".    *    * @param ast    *          The parsed command tree.    * @throws SemanticException    *           Parsing failed    */
specifier|private
name|void
name|analyzeDescFunction
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|funcName
decl_stmt|;
name|boolean
name|isExtended
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|funcName
operator|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|isExtended
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|funcName
operator|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|isExtended
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unexpected Tokens at DESCRIBE FUNCTION"
argument_list|)
throw|;
block|}
name|DescFunctionDesc
name|descFuncDesc
init|=
operator|new
name|DescFunctionDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|funcName
argument_list|,
name|isExtended
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|descFuncDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|DescFunctionDesc
operator|.
name|SCHEMA
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableRename
parameter_list|(
name|String
index|[]
name|source
parameter_list|,
name|ASTNode
name|ast
parameter_list|,
name|boolean
name|expectView
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
index|[]
name|target
init|=
name|getQualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|sourceName
init|=
name|getDotName
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|String
name|targetName
init|=
name|getDotName
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|AlterTableRenameDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableRenameDesc
argument_list|(
name|sourceName
argument_list|,
literal|null
argument_list|,
name|expectView
argument_list|,
name|targetName
argument_list|)
decl_stmt|;
name|Table
name|table
init|=
name|getTable
argument_list|(
name|sourceName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|AcidUtils
operator|.
name|isTransactionalTable
argument_list|(
name|table
argument_list|)
condition|)
block|{
name|setAcidDdlDesc
argument_list|(
name|alterTblDesc
argument_list|)
expr_stmt|;
block|}
name|addInputsOutputsAlterTable
argument_list|(
name|sourceName
argument_list|,
literal|null
argument_list|,
name|alterTblDesc
argument_list|,
name|alterTblDesc
operator|.
name|getType
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableRenameCol
parameter_list|(
name|String
name|catName
parameter_list|,
name|String
index|[]
name|qualified
parameter_list|,
name|ASTNode
name|ast
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|newComment
init|=
literal|null
decl_stmt|;
name|boolean
name|first
init|=
literal|false
decl_stmt|;
name|String
name|flagCol
init|=
literal|null
decl_stmt|;
name|boolean
name|isCascade
init|=
literal|false
decl_stmt|;
comment|//col_old_name col_new_name column_type [COMMENT col_comment] [FIRST|AFTER column_name] [CASCADE|RESTRICT]
name|String
name|oldColName
init|=
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|String
name|newColName
init|=
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|String
name|newType
init|=
name|getTypeStringFromAST
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|ASTNode
name|constraintChild
init|=
literal|null
decl_stmt|;
name|int
name|childCount
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|3
init|;
name|i
operator|<
name|childCount
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|StringLiteral
case|:
name|newComment
operator|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERTABLE_CHANGECOL_AFTER_POSITION
case|:
name|flagCol
operator|=
name|unescapeIdentifier
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|KW_FIRST
case|:
name|first
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_CASCADE
case|:
name|isCascade
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_RESTRICT
case|:
break|break;
default|default:
name|constraintChild
operator|=
name|child
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|SQLPrimaryKey
argument_list|>
name|primaryKeys
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|SQLForeignKey
argument_list|>
name|foreignKeys
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|SQLUniqueConstraint
argument_list|>
name|uniqueConstraints
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|SQLNotNullConstraint
argument_list|>
name|notNullConstraints
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|SQLDefaultConstraint
argument_list|>
name|defaultConstraints
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|SQLCheckConstraint
argument_list|>
name|checkConstraints
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|constraintChild
operator|!=
literal|null
condition|)
block|{
comment|// Process column constraint
switch|switch
condition|(
name|constraintChild
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_CHECK_CONSTRAINT
case|:
name|checkConstraints
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|processCheckConstraints
argument_list|(
name|catName
argument_list|,
name|qualified
index|[
literal|0
index|]
argument_list|,
name|qualified
index|[
literal|1
index|]
argument_list|,
name|constraintChild
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|newColName
argument_list|)
argument_list|,
name|checkConstraints
argument_list|,
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
argument_list|,
name|this
operator|.
name|ctx
operator|.
name|getTokenRewriteStream
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DEFAULT_VALUE
case|:
name|defaultConstraints
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|processDefaultConstraints
argument_list|(
name|catName
argument_list|,
name|qualified
index|[
literal|0
index|]
argument_list|,
name|qualified
index|[
literal|1
index|]
argument_list|,
name|constraintChild
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|newColName
argument_list|)
argument_list|,
name|defaultConstraints
argument_list|,
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
argument_list|,
name|this
operator|.
name|ctx
operator|.
name|getTokenRewriteStream
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_NOT_NULL
case|:
name|notNullConstraints
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|processNotNullConstraints
argument_list|(
name|catName
argument_list|,
name|qualified
index|[
literal|0
index|]
argument_list|,
name|qualified
index|[
literal|1
index|]
argument_list|,
name|constraintChild
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|newColName
argument_list|)
argument_list|,
name|notNullConstraints
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_UNIQUE
case|:
name|uniqueConstraints
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|processUniqueConstraints
argument_list|(
name|catName
argument_list|,
name|qualified
index|[
literal|0
index|]
argument_list|,
name|qualified
index|[
literal|1
index|]
argument_list|,
name|constraintChild
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|newColName
argument_list|)
argument_list|,
name|uniqueConstraints
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_PRIMARY_KEY
case|:
name|primaryKeys
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|processPrimaryKeys
argument_list|(
name|qualified
index|[
literal|0
index|]
argument_list|,
name|qualified
index|[
literal|1
index|]
argument_list|,
name|constraintChild
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|newColName
argument_list|)
argument_list|,
name|primaryKeys
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_FOREIGN_KEY
case|:
name|foreignKeys
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|processForeignKeys
argument_list|(
name|qualified
index|[
literal|0
index|]
argument_list|,
name|qualified
index|[
literal|1
index|]
argument_list|,
name|constraintChild
argument_list|,
name|foreignKeys
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NOT_RECOGNIZED_CONSTRAINT
operator|.
name|getMsg
argument_list|(
name|constraintChild
operator|.
name|getToken
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|/* Validate the operation of renaming a column name. */
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
if|if
condition|(
name|checkConstraints
operator|!=
literal|null
operator|&&
operator|!
name|checkConstraints
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|validateCheckConstraint
argument_list|(
name|tab
operator|.
name|getCols
argument_list|()
argument_list|,
name|checkConstraints
argument_list|,
name|ctx
operator|.
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tab
operator|.
name|getTableType
argument_list|()
operator|==
name|TableType
operator|.
name|EXTERNAL_TABLE
operator|&&
name|hasEnabledOrValidatedConstraints
argument_list|(
name|notNullConstraints
argument_list|,
name|defaultConstraints
argument_list|,
name|checkConstraints
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_CSTR_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|"Constraints are disallowed with External tables. "
operator|+
literal|"Only RELY is allowed."
argument_list|)
argument_list|)
throw|;
block|}
name|SkewedInfo
name|skewInfo
init|=
name|tab
operator|.
name|getTTable
argument_list|()
operator|.
name|getSd
argument_list|()
operator|.
name|getSkewedInfo
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
literal|null
operator|!=
name|skewInfo
operator|)
operator|&&
operator|(
literal|null
operator|!=
name|skewInfo
operator|.
name|getSkewedColNames
argument_list|()
operator|)
operator|&&
name|skewInfo
operator|.
name|getSkewedColNames
argument_list|()
operator|.
name|contains
argument_list|(
name|oldColName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|oldColName
operator|+
name|ErrorMsg
operator|.
name|ALTER_TABLE_NOT_ALLOWED_RENAME_SKEWED_COLUMN
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|String
name|tblName
init|=
name|getDotName
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|Constraints
name|constraints
init|=
operator|new
name|Constraints
argument_list|(
name|primaryKeys
argument_list|,
name|foreignKeys
argument_list|,
name|notNullConstraints
argument_list|,
name|uniqueConstraints
argument_list|,
name|defaultConstraints
argument_list|,
name|checkConstraints
argument_list|)
decl_stmt|;
name|AlterTableChangeColumnDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableChangeColumnDesc
argument_list|(
name|tblName
argument_list|,
name|partSpec
argument_list|,
name|isCascade
argument_list|,
name|constraints
argument_list|,
name|unescapeIdentifier
argument_list|(
name|oldColName
argument_list|)
argument_list|,
name|unescapeIdentifier
argument_list|(
name|newColName
argument_list|)
argument_list|,
name|newType
argument_list|,
name|newComment
argument_list|,
name|first
argument_list|,
name|flagCol
argument_list|)
decl_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|tblName
argument_list|,
name|partSpec
argument_list|,
name|alterTblDesc
argument_list|,
name|alterTblDesc
operator|.
name|getType
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|AcidUtils
operator|.
name|isTransactionalTable
argument_list|(
name|tab
argument_list|)
condition|)
block|{
comment|// Note: we might actually need it only when certain changes (e.g. name or type?) are made.
name|setAcidDdlDesc
argument_list|(
name|alterTblDesc
argument_list|)
expr_stmt|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableRenamePart
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tblName
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|oldPartSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|tblName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|validateAlterTableType
argument_list|(
name|tab
argument_list|,
name|AlterTableType
operator|.
name|RENAMEPARTITION
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|newPartSpec
init|=
name|getValidatedPartSpec
argument_list|(
name|tab
argument_list|,
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|conf
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|newPartSpec
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"RENAME PARTITION Missing Destination"
operator|+
name|ast
argument_list|)
throw|;
block|}
name|ReadEntity
name|re
init|=
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
decl_stmt|;
name|re
operator|.
name|noLockNeeded
argument_list|()
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
name|re
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
init|=
operator|new
name|ArrayList
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|partSpecs
operator|.
name|add
argument_list|(
name|oldPartSpec
argument_list|)
expr_stmt|;
name|partSpecs
operator|.
name|add
argument_list|(
name|newPartSpec
argument_list|)
expr_stmt|;
name|addTablePartsOutputs
argument_list|(
name|tab
argument_list|,
name|partSpecs
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_EXCLUSIVE
argument_list|)
expr_stmt|;
name|AlterTableRenamePartitionDesc
name|renamePartitionDesc
init|=
operator|new
name|AlterTableRenamePartitionDesc
argument_list|(
name|tblName
argument_list|,
name|oldPartSpec
argument_list|,
name|newPartSpec
argument_list|,
literal|null
argument_list|,
name|tab
argument_list|)
decl_stmt|;
if|if
condition|(
name|AcidUtils
operator|.
name|isTransactionalTable
argument_list|(
name|tab
argument_list|)
condition|)
block|{
name|setAcidDdlDesc
argument_list|(
name|renamePartitionDesc
argument_list|)
expr_stmt|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|renamePartitionDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableBucketNum
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tblName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|tblName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|CollectionUtils
operator|.
name|isEmpty
argument_list|(
name|tab
operator|.
name|getBucketCols
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_BUCKETNUM_NONBUCKETIZED_TBL
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|validateAlterTableType
argument_list|(
name|tab
argument_list|,
name|AlterTableType
operator|.
name|INTO_BUCKETS
argument_list|)
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|numberOfBuckets
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|AlterTableIntoBucketsDesc
name|alterBucketNum
init|=
operator|new
name|AlterTableIntoBucketsDesc
argument_list|(
name|tblName
argument_list|,
name|partSpec
argument_list|,
name|numberOfBuckets
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterBucketNum
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableAddCols
parameter_list|(
name|String
index|[]
name|qualified
parameter_list|,
name|ASTNode
name|ast
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tblName
init|=
name|getDotName
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|newCols
init|=
name|getColumns
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|boolean
name|isCascade
init|=
literal|false
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|ast
operator|.
name|getFirstChildWithType
argument_list|(
name|HiveParser
operator|.
name|TOK_CASCADE
argument_list|)
condition|)
block|{
name|isCascade
operator|=
literal|true
expr_stmt|;
block|}
name|AlterTableAddColumnsDesc
name|desc
init|=
operator|new
name|AlterTableAddColumnsDesc
argument_list|(
name|tblName
argument_list|,
name|partSpec
argument_list|,
name|isCascade
argument_list|,
name|newCols
argument_list|)
decl_stmt|;
name|Table
name|table
init|=
name|getTable
argument_list|(
name|tblName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|AcidUtils
operator|.
name|isTransactionalTable
argument_list|(
name|table
argument_list|)
condition|)
block|{
name|setAcidDdlDesc
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
name|addInputsOutputsAlterTable
argument_list|(
name|tblName
argument_list|,
name|partSpec
argument_list|,
name|desc
argument_list|,
name|desc
operator|.
name|getType
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|desc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableReplaceCols
parameter_list|(
name|String
index|[]
name|qualified
parameter_list|,
name|ASTNode
name|ast
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tblName
init|=
name|getDotName
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|newCols
init|=
name|getColumns
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|boolean
name|isCascade
init|=
literal|false
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|ast
operator|.
name|getFirstChildWithType
argument_list|(
name|HiveParser
operator|.
name|TOK_CASCADE
argument_list|)
condition|)
block|{
name|isCascade
operator|=
literal|true
expr_stmt|;
block|}
name|AlterTableReplaceColumnsDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableReplaceColumnsDesc
argument_list|(
name|tblName
argument_list|,
name|partSpec
argument_list|,
name|isCascade
argument_list|,
name|newCols
argument_list|)
decl_stmt|;
name|Table
name|table
init|=
name|getTable
argument_list|(
name|tblName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|AcidUtils
operator|.
name|isTransactionalTable
argument_list|(
name|table
argument_list|)
condition|)
block|{
name|setAcidDdlDesc
argument_list|(
name|alterTblDesc
argument_list|)
expr_stmt|;
block|}
name|addInputsOutputsAlterTable
argument_list|(
name|tblName
argument_list|,
name|partSpec
argument_list|,
name|alterTblDesc
argument_list|,
name|alterTblDesc
operator|.
name|getType
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableDropParts
parameter_list|(
name|String
index|[]
name|qualified
parameter_list|,
name|ASTNode
name|ast
parameter_list|,
name|boolean
name|expectView
parameter_list|)
throws|throws
name|SemanticException
block|{
name|boolean
name|ifExists
init|=
operator|(
name|ast
operator|.
name|getFirstChildWithType
argument_list|(
name|HiveParser
operator|.
name|TOK_IFEXISTS
argument_list|)
operator|!=
literal|null
operator|)
operator|||
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|DROPIGNORESNONEXISTENT
argument_list|)
decl_stmt|;
comment|// If the drop has to fail on non-existent partitions, we cannot batch expressions.
comment|// That is because we actually have to check each separate expression for existence.
comment|// We could do a small optimization for the case where expr has all columns and all
comment|// operators are equality, if we assume those would always match one partition (which
comment|// may not be true with legacy, non-normalized column values). This is probably a
comment|// popular case but that's kinda hacky. Let's not do it for now.
name|boolean
name|canGroupExprs
init|=
name|ifExists
decl_stmt|;
name|boolean
name|mustPurge
init|=
operator|(
name|ast
operator|.
name|getFirstChildWithType
argument_list|(
name|HiveParser
operator|.
name|KW_PURGE
argument_list|)
operator|!=
literal|null
operator|)
decl_stmt|;
name|ReplicationSpec
name|replicationSpec
init|=
operator|new
name|ReplicationSpec
argument_list|(
name|ast
argument_list|)
decl_stmt|;
name|Table
name|tab
init|=
literal|null
decl_stmt|;
try|try
block|{
name|tab
operator|=
name|getTable
argument_list|(
name|qualified
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|se
parameter_list|)
block|{
if|if
condition|(
name|replicationSpec
operator|.
name|isInReplicationScope
argument_list|()
operator|&&
operator|(
operator|(
name|se
operator|.
name|getCause
argument_list|()
operator|instanceof
name|InvalidTableException
operator|)
operator|||
operator|(
name|se
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|()
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|// If we're inside a replication scope, then the table not existing is not an error.
comment|// We just return in that case, no drop needed.
return|return;
comment|// TODO : the contains message check is fragile, we should refactor SemanticException to be
comment|// queriable for error code, and not simply have a message
comment|// NOTE : IF_EXISTS might also want to invoke this, but there's a good possibility
comment|// that IF_EXISTS is stricter about table existence, and applies only to the ptn.
comment|// Therefore, ignoring IF_EXISTS here.
block|}
else|else
block|{
throw|throw
name|se
throw|;
block|}
block|}
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|ExprNodeGenericFuncDesc
argument_list|>
argument_list|>
name|partSpecs
init|=
name|getFullPartitionSpecs
argument_list|(
name|ast
argument_list|,
name|tab
argument_list|,
name|canGroupExprs
argument_list|)
decl_stmt|;
if|if
condition|(
name|partSpecs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
comment|// nothing to do
block|}
name|validateAlterTableType
argument_list|(
name|tab
argument_list|,
name|AlterTableType
operator|.
name|DROPPARTITION
argument_list|,
name|expectView
argument_list|)
expr_stmt|;
name|ReadEntity
name|re
init|=
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
decl_stmt|;
name|re
operator|.
name|noLockNeeded
argument_list|()
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
name|re
argument_list|)
expr_stmt|;
name|addTableDropPartsOutputs
argument_list|(
name|tab
argument_list|,
name|partSpecs
operator|.
name|values
argument_list|()
argument_list|,
operator|!
name|ifExists
argument_list|)
expr_stmt|;
name|AlterTableDropPartitionDesc
name|dropTblDesc
init|=
operator|new
name|AlterTableDropPartitionDesc
argument_list|(
name|getDotName
argument_list|(
name|qualified
argument_list|)
argument_list|,
name|partSpecs
argument_list|,
name|mustPurge
argument_list|,
name|replicationSpec
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|dropTblDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTablePartColType
parameter_list|(
name|String
index|[]
name|qualified
parameter_list|,
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// check if table exists.
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
comment|// validate the DDL is a valid operation on the table.
name|validateAlterTableType
argument_list|(
name|tab
argument_list|,
name|AlterTableType
operator|.
name|ALTERPARTITION
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Alter table ... partition column ( column newtype) only takes one column at a time.
comment|// It must have a column name followed with type.
name|ASTNode
name|colAst
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|FieldSchema
name|newCol
init|=
operator|new
name|FieldSchema
argument_list|()
decl_stmt|;
comment|// get column name
name|String
name|name
init|=
name|colAst
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|newCol
operator|.
name|setName
argument_list|(
name|unescapeIdentifier
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|// get column type
name|ASTNode
name|typeChild
init|=
call|(
name|ASTNode
call|)
argument_list|(
name|colAst
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|newCol
operator|.
name|setType
argument_list|(
name|getTypeStringFromAST
argument_list|(
name|typeChild
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|colAst
operator|.
name|getChildCount
argument_list|()
operator|==
literal|3
condition|)
block|{
name|newCol
operator|.
name|setComment
argument_list|(
name|unescapeSQLString
argument_list|(
name|colAst
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// check if column is defined or not
name|boolean
name|fFoundColumn
init|=
literal|false
decl_stmt|;
for|for
control|(
name|FieldSchema
name|col
range|:
name|tab
operator|.
name|getTTable
argument_list|()
operator|.
name|getPartitionKeys
argument_list|()
control|)
block|{
if|if
condition|(
name|col
operator|.
name|getName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|newCol
operator|.
name|getName
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fFoundColumn
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// raise error if we could not find the column
if|if
condition|(
operator|!
name|fFoundColumn
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|newCol
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|AlterTableAlterPartitionDesc
name|alterTblAlterPartDesc
init|=
operator|new
name|AlterTableAlterPartitionDesc
argument_list|(
name|getDotName
argument_list|(
name|qualified
argument_list|)
argument_list|,
name|newCol
argument_list|)
decl_stmt|;
if|if
condition|(
name|AcidUtils
operator|.
name|isTransactionalTable
argument_list|(
name|tab
argument_list|)
condition|)
block|{
name|setAcidDdlDesc
argument_list|(
name|alterTblAlterPartDesc
argument_list|)
expr_stmt|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblAlterPartDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add one or more partitions to a table. Useful when the data has been copied    * to the right location by some other process.    *    * @param ast    *          The parsed command tree.    *    * @param expectView    *          True for ALTER VIEW, false for ALTER TABLE.    *    * @throws SemanticException    *           Parsing failed    */
specifier|private
name|void
name|analyzeAlterTableAddParts
parameter_list|(
name|String
index|[]
name|qualified
parameter_list|,
name|CommonTree
name|ast
parameter_list|,
name|boolean
name|expectView
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// ^(TOK_ALTERTABLE_ADDPARTS identifier ifNotExists? alterStatementSuffixAddPartitionsElement+)
name|boolean
name|ifNotExists
init|=
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_IFNOTEXISTS
decl_stmt|;
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|boolean
name|isView
init|=
name|tab
operator|.
name|isView
argument_list|()
decl_stmt|;
name|validateAlterTableType
argument_list|(
name|tab
argument_list|,
name|AlterTableType
operator|.
name|ADDPARTITION
argument_list|,
name|expectView
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|,
comment|/*use DDL_EXCLUSIVE to cause X lock to prevent races between concurrent add partition calls         with IF NOT EXISTS.  w/o this 2 concurrent calls to add the same partition may both add         data since for transactional tables creating partition metadata and moving data there are         2 separate actions. */
name|ifNotExists
operator|&&
name|AcidUtils
operator|.
name|isTransactionalTable
argument_list|(
name|tab
argument_list|)
condition|?
name|WriteType
operator|.
name|DDL_EXCLUSIVE
else|:
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_SHARED
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|numCh
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
name|int
name|start
init|=
name|ifNotExists
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|String
name|currentLocation
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|currentPart
init|=
literal|null
decl_stmt|;
comment|// Parser has done some verification, so the order of tokens doesn't need to be verified here.
name|AlterTableAddPartitionDesc
name|addPartitionDesc
init|=
operator|new
name|AlterTableAddPartitionDesc
argument_list|(
name|tab
operator|.
name|getDbName
argument_list|()
argument_list|,
name|tab
operator|.
name|getTableName
argument_list|()
argument_list|,
name|ifNotExists
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|num
init|=
name|start
init|;
name|num
operator|<
name|numCh
condition|;
name|num
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|num
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_PARTSPEC
case|:
if|if
condition|(
name|currentPart
operator|!=
literal|null
condition|)
block|{
name|addPartitionDesc
operator|.
name|addPartition
argument_list|(
name|currentPart
argument_list|,
name|currentLocation
argument_list|)
expr_stmt|;
name|currentLocation
operator|=
literal|null
expr_stmt|;
block|}
name|currentPart
operator|=
name|getValidatedPartSpec
argument_list|(
name|tab
argument_list|,
name|child
argument_list|,
name|conf
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|validatePartitionValues
argument_list|(
name|currentPart
argument_list|)
expr_stmt|;
comment|// validate reserved values
break|break;
case|case
name|HiveParser
operator|.
name|TOK_PARTITIONLOCATION
case|:
comment|// if location specified, set in partition
if|if
condition|(
name|isView
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"LOCATION clause illegal for view partition"
argument_list|)
throw|;
block|}
name|currentLocation
operator|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
name|toReadEntity
argument_list|(
name|currentLocation
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unknown child: "
operator|+
name|child
argument_list|)
throw|;
block|}
block|}
comment|// add the last one
if|if
condition|(
name|currentPart
operator|!=
literal|null
condition|)
block|{
name|addPartitionDesc
operator|.
name|addPartition
argument_list|(
name|currentPart
argument_list|,
name|currentLocation
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESTATSAUTOGATHER
argument_list|)
condition|)
block|{
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|addPartitionDesc
operator|.
name|getPartitionCount
argument_list|()
condition|;
name|index
operator|++
control|)
block|{
name|PartitionDesc
name|desc
init|=
name|addPartitionDesc
operator|.
name|getPartition
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|.
name|getLocation
argument_list|()
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|desc
operator|.
name|getPartParams
argument_list|()
operator|==
literal|null
condition|)
block|{
name|desc
operator|.
name|setPartParams
argument_list|(
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|StatsSetupConst
operator|.
name|setStatsStateForCreateTable
argument_list|(
name|desc
operator|.
name|getPartParams
argument_list|()
argument_list|,
name|MetaStoreUtils
operator|.
name|getColumnNames
argument_list|(
name|tab
operator|.
name|getCols
argument_list|()
argument_list|)
argument_list|,
name|StatsSetupConst
operator|.
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|addPartitionDesc
operator|.
name|getPartitionCount
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// nothing to do
return|return;
block|}
name|Task
argument_list|<
name|DDLWork2
argument_list|>
name|ddlTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|addPartitionDesc
argument_list|)
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|ddlTask
argument_list|)
expr_stmt|;
name|handleTransactionalTable
argument_list|(
name|tab
argument_list|,
name|addPartitionDesc
argument_list|,
name|ddlTask
argument_list|)
expr_stmt|;
if|if
condition|(
name|isView
condition|)
block|{
comment|// Compile internal query to capture underlying table partition dependencies
name|StringBuilder
name|cmd
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|cmd
operator|.
name|append
argument_list|(
literal|"SELECT * FROM "
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|unparseIdentifier
argument_list|(
name|qualified
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|append
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|unparseIdentifier
argument_list|(
name|qualified
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|append
argument_list|(
literal|" WHERE "
argument_list|)
expr_stmt|;
name|boolean
name|firstOr
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|addPartitionDesc
operator|.
name|getPartitionCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|AlterTableAddPartitionDesc
operator|.
name|PartitionDesc
name|partitionDesc
init|=
name|addPartitionDesc
operator|.
name|getPartition
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstOr
condition|)
block|{
name|firstOr
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|.
name|append
argument_list|(
literal|" OR "
argument_list|)
expr_stmt|;
block|}
name|boolean
name|firstAnd
init|=
literal|true
decl_stmt|;
name|cmd
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|partitionDesc
operator|.
name|getPartSpec
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|firstAnd
condition|)
block|{
name|firstAnd
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|.
name|append
argument_list|(
literal|" AND "
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|unparseIdentifier
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|append
argument_list|(
literal|" = '"
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|escapeString
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|SessionState
name|ss
init|=
name|SessionState
operator|.
name|get
argument_list|()
decl_stmt|;
comment|// TODO: should this use getUserFromAuthenticator?
name|String
name|uName
init|=
operator|(
name|ss
operator|==
literal|null
condition|?
literal|null
else|:
name|ss
operator|.
name|getUserName
argument_list|()
operator|)
decl_stmt|;
name|Driver
name|driver
init|=
operator|new
name|Driver
argument_list|(
name|conf
argument_list|,
name|uName
argument_list|,
name|queryState
operator|.
name|getLineageState
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|rc
init|=
name|driver
operator|.
name|compile
argument_list|(
name|cmd
operator|.
name|toString
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NO_VALID_PARTN
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|inputs
operator|.
name|addAll
argument_list|(
name|driver
operator|.
name|getPlan
argument_list|()
operator|.
name|getInputs
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Add partition for Transactional tables needs to add (copy/rename) the data so that it lands    * in a delta_x_x/ folder in the partition dir.    */
specifier|private
name|void
name|handleTransactionalTable
parameter_list|(
name|Table
name|tab
parameter_list|,
name|AlterTableAddPartitionDesc
name|addPartitionDesc
parameter_list|,
name|Task
name|ddlTask
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|AcidUtils
operator|.
name|isTransactionalTable
argument_list|(
name|tab
argument_list|)
condition|)
block|{
return|return;
block|}
name|Long
name|writeId
init|=
literal|null
decl_stmt|;
name|int
name|stmtId
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|addPartitionDesc
operator|.
name|getPartitionCount
argument_list|()
condition|;
name|index
operator|++
control|)
block|{
name|PartitionDesc
name|desc
init|=
name|addPartitionDesc
operator|.
name|getPartition
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|.
name|getLocation
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|AcidUtils
operator|.
name|validateAcidPartitionLocation
argument_list|(
name|desc
operator|.
name|getLocation
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|addPartitionDesc
operator|.
name|isIfNotExists
argument_list|()
condition|)
block|{
comment|//Don't add partition data if it already exists
name|Partition
name|oldPart
init|=
name|getPartition
argument_list|(
name|tab
argument_list|,
name|desc
operator|.
name|getPartSpec
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldPart
operator|!=
literal|null
condition|)
block|{
continue|continue;
block|}
block|}
if|if
condition|(
name|writeId
operator|==
literal|null
condition|)
block|{
comment|//so that we only allocate a writeId only if actually adding data
comment|// (vs. adding a partition w/o data)
try|try
block|{
name|writeId
operator|=
name|getTxnMgr
argument_list|()
operator|.
name|getTableWriteId
argument_list|(
name|tab
operator|.
name|getDbName
argument_list|()
argument_list|,
name|tab
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Failed to allocate the write id"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
name|stmtId
operator|=
name|getTxnMgr
argument_list|()
operator|.
name|getStmtIdAndIncrement
argument_list|()
expr_stmt|;
block|}
name|LoadTableDesc
name|loadTableWork
init|=
operator|new
name|LoadTableDesc
argument_list|(
operator|new
name|Path
argument_list|(
name|desc
operator|.
name|getLocation
argument_list|()
argument_list|)
argument_list|,
name|Utilities
operator|.
name|getTableDesc
argument_list|(
name|tab
argument_list|)
argument_list|,
name|desc
operator|.
name|getPartSpec
argument_list|()
argument_list|,
name|LoadTableDesc
operator|.
name|LoadFileType
operator|.
name|KEEP_EXISTING
argument_list|,
comment|//not relevant - creating new partition
name|writeId
argument_list|)
decl_stmt|;
name|loadTableWork
operator|.
name|setStmtId
argument_list|(
name|stmtId
argument_list|)
expr_stmt|;
name|loadTableWork
operator|.
name|setInheritTableSpecs
argument_list|(
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
name|desc
operator|.
name|setLocation
argument_list|(
operator|new
name|Path
argument_list|(
name|tab
operator|.
name|getDataLocation
argument_list|()
argument_list|,
name|Warehouse
operator|.
name|makePartPath
argument_list|(
name|desc
operator|.
name|getPartSpec
argument_list|()
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MetaException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Could not determine partition path due to: "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ex
argument_list|)
throw|;
block|}
name|Task
argument_list|<
name|MoveWork
argument_list|>
name|moveTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|MoveWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|loadTableWork
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|,
comment|//make sure to check format
literal|false
argument_list|)
argument_list|)
decl_stmt|;
comment|//is this right?
name|ddlTask
operator|.
name|addDependentTask
argument_list|(
name|moveTask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Rewrite the metadata for one or more partitions in a table. Useful when    * an external process modifies files on HDFS and you want the pre/post    * hooks to be fired for the specified partition.    *    * @param ast    *          The parsed command tree.    * @throws SemanticException    *           Parsing failed    */
specifier|private
name|void
name|analyzeAlterTableTouch
parameter_list|(
name|String
index|[]
name|qualified
parameter_list|,
name|CommonTree
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|validateAlterTableType
argument_list|(
name|tab
argument_list|,
name|AlterTableType
operator|.
name|TOUCH
argument_list|)
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
comment|// partition name to value
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
init|=
name|getPartitionSpecs
argument_list|(
name|tab
argument_list|,
name|ast
argument_list|)
decl_stmt|;
if|if
condition|(
name|partSpecs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|AlterTableTouchDesc
name|touchDesc
init|=
operator|new
name|AlterTableTouchDesc
argument_list|(
name|getDotName
argument_list|(
name|qualified
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_NO_LOCK
argument_list|)
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|touchDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addTablePartsOutputs
argument_list|(
name|tab
argument_list|,
name|partSpecs
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_NO_LOCK
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
range|:
name|partSpecs
control|)
block|{
name|AlterTableTouchDesc
name|touchDesc
init|=
operator|new
name|AlterTableTouchDesc
argument_list|(
name|getDotName
argument_list|(
name|qualified
argument_list|)
argument_list|,
name|partSpec
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|touchDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|analyzeAlterTableArchive
parameter_list|(
name|String
index|[]
name|qualified
parameter_list|,
name|CommonTree
name|ast
parameter_list|,
name|boolean
name|isUnArchive
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEARCHIVEENABLED
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ARCHIVE_METHODS_DISABLED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
comment|// partition name to value
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
init|=
name|getPartitionSpecs
argument_list|(
name|tab
argument_list|,
name|ast
argument_list|)
decl_stmt|;
name|addTablePartsOutputs
argument_list|(
name|tab
argument_list|,
name|partSpecs
argument_list|,
literal|true
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_NO_LOCK
argument_list|)
expr_stmt|;
name|validateAlterTableType
argument_list|(
name|tab
argument_list|,
name|AlterTableType
operator|.
name|ARCHIVE
argument_list|)
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|isUnArchive
condition|?
name|ErrorMsg
operator|.
name|UNARCHIVE_ON_MULI_PARTS
operator|.
name|getMsg
argument_list|()
else|:
name|ErrorMsg
operator|.
name|ARCHIVE_ON_MULI_PARTS
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ARCHIVE_ON_TABLE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
name|partSpecs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
try|try
block|{
name|isValidPrefixSpec
argument_list|(
name|tab
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|DDLDesc
name|archiveDesc
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isUnArchive
condition|)
block|{
name|archiveDesc
operator|=
operator|new
name|AlterTableUnarchiveDesc
argument_list|(
name|getDotName
argument_list|(
name|qualified
argument_list|)
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|archiveDesc
operator|=
operator|new
name|AlterTableArchiveDesc
argument_list|(
name|getDotName
argument_list|(
name|qualified
argument_list|)
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|archiveDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check if MSCK is called to add partitions.    *    * @param keyWord    *   could be ADD, DROP or SYNC.  ADD or SYNC will indicate that add partition is on.    *    * @return true if add is on; false otherwise    */
specifier|private
specifier|static
name|boolean
name|isMsckAddPartition
parameter_list|(
name|int
name|keyWord
parameter_list|)
block|{
switch|switch
condition|(
name|keyWord
condition|)
block|{
case|case
name|HiveParser
operator|.
name|KW_DROP
case|:
return|return
literal|false
return|;
case|case
name|HiveParser
operator|.
name|KW_SYNC
case|:
case|case
name|HiveParser
operator|.
name|KW_ADD
case|:
default|default:
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Check if MSCK is called to drop partitions.    *    * @param keyWord    *   could be ADD, DROP or SYNC.  DROP or SYNC will indicate that drop partition is on.    *    * @return true if drop is on; false otherwise    */
specifier|private
specifier|static
name|boolean
name|isMsckDropPartition
parameter_list|(
name|int
name|keyWord
parameter_list|)
block|{
switch|switch
condition|(
name|keyWord
condition|)
block|{
case|case
name|HiveParser
operator|.
name|KW_DROP
case|:
case|case
name|HiveParser
operator|.
name|KW_SYNC
case|:
return|return
literal|true
return|;
case|case
name|HiveParser
operator|.
name|KW_ADD
case|:
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Verify that the information in the metastore matches up with the data on    * the fs.    *    * @param ast    *          Query tree.    * @throws SemanticException    */
specifier|private
name|void
name|analyzeMetastoreCheck
parameter_list|(
name|CommonTree
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
literal|null
decl_stmt|;
name|boolean
name|addPartitions
init|=
literal|true
decl_stmt|;
name|boolean
name|dropPartitions
init|=
literal|false
decl_stmt|;
name|boolean
name|repair
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|repair
operator|=
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|KW_REPAIR
expr_stmt|;
if|if
condition|(
operator|!
name|repair
condition|)
block|{
name|tableName
operator|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
name|addPartitions
operator|=
name|isMsckAddPartition
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|dropPartitions
operator|=
name|isMsckDropPartition
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
name|tableName
operator|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|2
condition|)
block|{
name|addPartitions
operator|=
name|isMsckAddPartition
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|dropPartitions
operator|=
name|isMsckDropPartition
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|specs
init|=
name|getPartitionSpecs
argument_list|(
name|tab
argument_list|,
name|ast
argument_list|)
decl_stmt|;
if|if
condition|(
name|repair
operator|&&
name|AcidUtils
operator|.
name|isTransactionalTable
argument_list|(
name|tab
argument_list|)
condition|)
block|{
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|,
name|WriteType
operator|.
name|DDL_EXCLUSIVE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_SHARED
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|MsckDesc
name|checkDesc
init|=
operator|new
name|MsckDesc
argument_list|(
name|tableName
argument_list|,
name|specs
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|repair
argument_list|,
name|addPartitions
argument_list|,
name|dropPartitions
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|checkDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the partition specs from the tree.    *    * @param ast    *          Tree to extract partitions from.    * @return A list of partition name to value mappings.    * @throws SemanticException    */
specifier|private
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|getPartitionSpecs
parameter_list|(
name|Table
name|tbl
parameter_list|,
name|CommonTree
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
init|=
operator|new
name|ArrayList
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|childIndex
init|=
literal|0
decl_stmt|;
comment|// get partition metadata if partition specified
for|for
control|(
name|childIndex
operator|=
literal|0
init|;
name|childIndex
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
name|childIndex
operator|++
control|)
block|{
name|ASTNode
name|partSpecNode
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|childIndex
argument_list|)
decl_stmt|;
comment|// sanity check
if|if
condition|(
name|partSpecNode
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PARTSPEC
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
name|getValidatedPartSpec
argument_list|(
name|tbl
argument_list|,
name|partSpecNode
argument_list|,
name|conf
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|partSpecs
operator|.
name|add
argument_list|(
name|partSpec
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|partSpecs
return|;
block|}
comment|/**    * Get the partition specs from the tree. This stores the full specification    * with the comparator operator into the output list.    *    * @param ast Tree to extract partitions from.    * @param tab Table.    * @return    Map of partitions by prefix length. Most of the time prefix length will    *            be the same for all partition specs, so we can just OR the expressions.    */
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|ExprNodeGenericFuncDesc
argument_list|>
argument_list|>
name|getFullPartitionSpecs
parameter_list|(
name|CommonTree
name|ast
parameter_list|,
name|Table
name|tab
parameter_list|,
name|boolean
name|canGroupExprs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|defaultPartitionName
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DEFAULTPARTITIONNAME
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|colTypes
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldSchema
name|fs
range|:
name|tab
operator|.
name|getPartitionKeys
argument_list|()
control|)
block|{
name|colTypes
operator|.
name|put
argument_list|(
name|fs
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|fs
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|ExprNodeGenericFuncDesc
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|ExprNodeGenericFuncDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|childIndex
init|=
literal|0
init|;
name|childIndex
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
name|childIndex
operator|++
control|)
block|{
name|Tree
name|partSpecTree
init|=
name|ast
operator|.
name|getChild
argument_list|(
name|childIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|partSpecTree
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_PARTSPEC
condition|)
block|{
continue|continue;
block|}
name|ExprNodeGenericFuncDesc
name|expr
init|=
literal|null
decl_stmt|;
name|HashSet
argument_list|<
name|String
argument_list|>
name|names
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|partSpecTree
operator|.
name|getChildCount
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partSpecTree
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|CommonTree
name|partSpecSingleKey
init|=
operator|(
name|CommonTree
operator|)
name|partSpecTree
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|partSpecSingleKey
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PARTVAL
operator|)
assert|;
name|String
name|key
init|=
name|stripIdentifierQuotes
argument_list|(
name|partSpecSingleKey
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|String
name|operator
init|=
name|partSpecSingleKey
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|ASTNode
name|partValNode
init|=
operator|(
name|ASTNode
operator|)
name|partSpecSingleKey
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|TypeCheckCtx
name|typeCheckCtx
init|=
operator|new
name|TypeCheckCtx
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|ExprNodeConstantDesc
name|valExpr
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|TypeCheckProcFactory
operator|.
name|genExprNode
argument_list|(
name|partValNode
argument_list|,
name|typeCheckCtx
argument_list|)
operator|.
name|get
argument_list|(
name|partValNode
argument_list|)
decl_stmt|;
name|Object
name|val
init|=
name|valExpr
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|boolean
name|isDefaultPartitionName
init|=
name|val
operator|.
name|equals
argument_list|(
name|defaultPartitionName
argument_list|)
decl_stmt|;
name|String
name|type
init|=
name|colTypes
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|PrimitiveTypeInfo
name|pti
init|=
name|TypeInfoFactory
operator|.
name|getPrimitiveTypeInfo
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Column "
operator|+
name|key
operator|+
literal|" not found"
argument_list|)
throw|;
block|}
comment|// Create the corresponding hive expression to filter on partition columns.
if|if
condition|(
operator|!
name|isDefaultPartitionName
condition|)
block|{
if|if
condition|(
operator|!
name|valExpr
operator|.
name|getTypeString
argument_list|()
operator|.
name|equals
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|Converter
name|converter
init|=
name|ObjectInspectorConverters
operator|.
name|getConverter
argument_list|(
name|TypeInfoUtils
operator|.
name|getStandardJavaObjectInspectorFromTypeInfo
argument_list|(
name|valExpr
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
argument_list|,
name|TypeInfoUtils
operator|.
name|getStandardJavaObjectInspectorFromTypeInfo
argument_list|(
name|pti
argument_list|)
argument_list|)
decl_stmt|;
name|val
operator|=
name|converter
operator|.
name|convert
argument_list|(
name|valExpr
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|ExprNodeColumnDesc
name|column
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|pti
argument_list|,
name|key
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|ExprNodeGenericFuncDesc
name|op
decl_stmt|;
if|if
condition|(
operator|!
name|isDefaultPartitionName
condition|)
block|{
name|op
operator|=
name|makeBinaryPredicate
argument_list|(
name|operator
argument_list|,
name|column
argument_list|,
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|pti
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GenericUDF
name|originalOp
init|=
name|FunctionRegistry
operator|.
name|getFunctionInfo
argument_list|(
name|operator
argument_list|)
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
name|String
name|fnName
decl_stmt|;
if|if
condition|(
name|FunctionRegistry
operator|.
name|isEq
argument_list|(
name|originalOp
argument_list|)
condition|)
block|{
name|fnName
operator|=
literal|"isnull"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FunctionRegistry
operator|.
name|isNeq
argument_list|(
name|originalOp
argument_list|)
condition|)
block|{
name|fnName
operator|=
literal|"isnotnull"
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Cannot use "
operator|+
name|operator
operator|+
literal|" in a default partition spec; only '=' and '!=' are allowed."
argument_list|)
throw|;
block|}
name|op
operator|=
name|makeUnaryPredicate
argument_list|(
name|fnName
argument_list|,
name|column
argument_list|)
expr_stmt|;
block|}
comment|// If it's multi-expr filter (e.g. a='5', b='2012-01-02'), AND with previous exprs.
name|expr
operator|=
operator|(
name|expr
operator|==
literal|null
operator|)
condition|?
name|op
else|:
name|makeBinaryPredicate
argument_list|(
literal|"and"
argument_list|,
name|expr
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|names
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expr
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
comment|// We got the expr for one full partition spec. Determine the prefix length.
name|int
name|prefixLength
init|=
name|calculatePartPrefix
argument_list|(
name|tab
argument_list|,
name|names
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeGenericFuncDesc
argument_list|>
name|orExpr
init|=
name|result
operator|.
name|get
argument_list|(
name|prefixLength
argument_list|)
decl_stmt|;
comment|// We have to tell apart partitions resulting from spec with different prefix lengths.
comment|// So, if we already have smth for the same prefix length, we can OR the two.
comment|// If we don't, create a new separate filter. In most cases there will only be one.
if|if
condition|(
name|orExpr
operator|==
literal|null
condition|)
block|{
name|result
operator|.
name|put
argument_list|(
name|prefixLength
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|canGroupExprs
condition|)
block|{
name|orExpr
operator|.
name|set
argument_list|(
literal|0
argument_list|,
name|makeBinaryPredicate
argument_list|(
literal|"or"
argument_list|,
name|expr
argument_list|,
name|orExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|orExpr
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
specifier|public
specifier|static
name|ExprNodeGenericFuncDesc
name|makeBinaryPredicate
parameter_list|(
name|String
name|fn
parameter_list|,
name|ExprNodeDesc
name|left
parameter_list|,
name|ExprNodeDesc
name|right
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
operator|new
name|ExprNodeGenericFuncDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|booleanTypeInfo
argument_list|,
name|FunctionRegistry
operator|.
name|getFunctionInfo
argument_list|(
name|fn
argument_list|)
operator|.
name|getGenericUDF
argument_list|()
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|ExprNodeGenericFuncDesc
name|makeUnaryPredicate
parameter_list|(
name|String
name|fn
parameter_list|,
name|ExprNodeDesc
name|arg
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
operator|new
name|ExprNodeGenericFuncDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|booleanTypeInfo
argument_list|,
name|FunctionRegistry
operator|.
name|getFunctionInfo
argument_list|(
name|fn
argument_list|)
operator|.
name|getGenericUDF
argument_list|()
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|arg
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Calculates the partition prefix length based on the drop spec.    * This is used to avoid deleting archived partitions with lower level.    * For example, if, for A and B key cols, drop spec is A=5, B=6, we shouldn't drop    * archived A=5/, because it can contain B-s other than 6.    * @param tbl Table    * @param partSpecKeys Keys present in drop partition spec.    */
specifier|private
name|int
name|calculatePartPrefix
parameter_list|(
name|Table
name|tbl
parameter_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
name|partSpecKeys
parameter_list|)
block|{
name|int
name|partPrefixToDrop
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FieldSchema
name|fs
range|:
name|tbl
operator|.
name|getPartCols
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|partSpecKeys
operator|.
name|contains
argument_list|(
name|fs
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
break|break;
block|}
operator|++
name|partPrefixToDrop
expr_stmt|;
block|}
return|return
name|partPrefixToDrop
return|;
block|}
comment|/**    * Certain partition values are are used by hive. e.g. the default partition    * in dynamic partitioning and the intermediate partition values used in the    * archiving process. Naturally, prohibit the user from creating partitions    * with these reserved values. The check that this function is more    * restrictive than the actual limitation, but it's simpler. Should be okay    * since the reserved names are fairly long and uncommon.    */
specifier|private
name|void
name|validatePartitionValues
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|e
range|:
name|partSpec
operator|.
name|entrySet
argument_list|()
control|)
block|{
for|for
control|(
name|String
name|s
range|:
name|reservedPartitionValues
control|)
block|{
name|String
name|value
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
name|value
operator|.
name|contains
argument_list|(
name|s
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|RESERVED_PART_VAL
operator|.
name|getMsg
argument_list|(
literal|"(User value: "
operator|+
name|e
operator|.
name|getValue
argument_list|()
operator|+
literal|" Reserved substring: "
operator|+
name|s
operator|+
literal|")"
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**    * Add the table partitions to be modified in the output, so that it is available for the    * pre-execution hook. If the partition does not exist, no error is thrown.    */
specifier|private
name|void
name|addTablePartsOutputs
parameter_list|(
name|Table
name|table
parameter_list|,
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
parameter_list|,
name|WriteEntity
operator|.
name|WriteType
name|writeType
parameter_list|)
throws|throws
name|SemanticException
block|{
name|addTablePartsOutputs
argument_list|(
name|table
argument_list|,
name|partSpecs
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|writeType
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the table partitions to be modified in the output, so that it is available for the    * pre-execution hook. If the partition does not exist, no error is thrown.    */
specifier|private
name|void
name|addTablePartsOutputs
parameter_list|(
name|Table
name|table
parameter_list|,
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
parameter_list|,
name|boolean
name|allowMany
parameter_list|,
name|WriteEntity
operator|.
name|WriteType
name|writeType
parameter_list|)
throws|throws
name|SemanticException
block|{
name|addTablePartsOutputs
argument_list|(
name|table
argument_list|,
name|partSpecs
argument_list|,
literal|false
argument_list|,
name|allowMany
argument_list|,
literal|null
argument_list|,
name|writeType
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the table partitions to be modified in the output, so that it is available for the    * pre-execution hook. If the partition does not exist, throw an error if    * throwIfNonExistent is true, otherwise ignore it.    */
specifier|private
name|void
name|addTablePartsOutputs
parameter_list|(
name|Table
name|table
parameter_list|,
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
parameter_list|,
name|boolean
name|throwIfNonExistent
parameter_list|,
name|boolean
name|allowMany
parameter_list|,
name|ASTNode
name|ast
parameter_list|,
name|WriteEntity
operator|.
name|WriteType
name|writeType
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Iterator
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|i
decl_stmt|;
name|int
name|index
decl_stmt|;
for|for
control|(
name|i
operator|=
name|partSpecs
operator|.
name|iterator
argument_list|()
operator|,
name|index
operator|=
literal|1
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
operator|++
name|index
control|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Partition
argument_list|>
name|parts
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|allowMany
condition|)
block|{
try|try
block|{
name|parts
operator|=
name|db
operator|.
name|getPartitions
argument_list|(
name|table
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Got HiveException during obtaining list of partitions"
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|parts
operator|=
operator|new
name|ArrayList
argument_list|<
name|Partition
argument_list|>
argument_list|()
expr_stmt|;
try|try
block|{
name|Partition
name|p
init|=
name|db
operator|.
name|getPartition
argument_list|(
name|table
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|parts
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Wrong specification"
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|parts
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|throwIfNonExistent
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_PARTITION
operator|.
name|getMsg
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
name|index
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
block|}
for|for
control|(
name|Partition
name|p
range|:
name|parts
control|)
block|{
comment|// Don't request any locks here, as the table has already been locked.
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|p
argument_list|,
name|writeType
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Add the table partitions to be modified in the output, so that it is available for the    * pre-execution hook. If the partition does not exist, throw an error if    * throwIfNonExistent is true, otherwise ignore it.    */
specifier|private
name|void
name|addTableDropPartsOutputs
parameter_list|(
name|Table
name|tab
parameter_list|,
name|Collection
argument_list|<
name|List
argument_list|<
name|ExprNodeGenericFuncDesc
argument_list|>
argument_list|>
name|partSpecs
parameter_list|,
name|boolean
name|throwIfNonExistent
parameter_list|)
throws|throws
name|SemanticException
block|{
for|for
control|(
name|List
argument_list|<
name|ExprNodeGenericFuncDesc
argument_list|>
name|specs
range|:
name|partSpecs
control|)
block|{
for|for
control|(
name|ExprNodeGenericFuncDesc
name|partSpec
range|:
name|specs
control|)
block|{
name|List
argument_list|<
name|Partition
argument_list|>
name|parts
init|=
operator|new
name|ArrayList
argument_list|<
name|Partition
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|hasUnknown
init|=
literal|false
decl_stmt|;
try|try
block|{
name|hasUnknown
operator|=
name|db
operator|.
name|getPartitionsByExpr
argument_list|(
name|tab
argument_list|,
name|partSpec
argument_list|,
name|conf
argument_list|,
name|parts
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_PARTITION
operator|.
name|getMsg
argument_list|(
name|partSpec
operator|.
name|getExprString
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|hasUnknown
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unexpected unknown partitions for "
operator|+
name|partSpec
operator|.
name|getExprString
argument_list|()
argument_list|)
throw|;
block|}
comment|// TODO: ifExists could be moved to metastore. In fact it already supports that. Check it
comment|//       for now since we get parts for output anyway, so we can get the error message
comment|//       earlier... If we get rid of output, we can get rid of this.
if|if
condition|(
name|parts
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|throwIfNonExistent
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_PARTITION
operator|.
name|getMsg
argument_list|(
name|partSpec
operator|.
name|getExprString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
for|for
control|(
name|Partition
name|p
range|:
name|parts
control|)
block|{
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|p
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_EXCLUSIVE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Analyze alter table's skewed table    *    * @param ast    *          node    * @throws SemanticException    */
specifier|private
name|void
name|analyzeAlterTableSkewedby
parameter_list|(
name|String
index|[]
name|qualified
parameter_list|,
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|/**      * Throw an error if the user tries to use the DDL with      * hive.internal.ddl.list.bucketing.enable set to false.      */
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getConf
argument_list|()
expr_stmt|;
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_EXCLUSIVE
argument_list|)
argument_list|)
expr_stmt|;
name|validateAlterTableType
argument_list|(
name|tab
argument_list|,
name|AlterTableType
operator|.
name|SKEWED_BY
argument_list|)
expr_stmt|;
name|String
name|tableName
init|=
name|getDotName
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|/* Convert a skewed table to non-skewed table. */
name|AlterTableNotSkewedDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableNotSkewedDesc
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
operator|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABLESKEWED
case|:
name|handleAlterTableSkewedBy
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|tab
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_STOREDASDIRS
case|:
name|handleAlterTableDisableStoredAsDirs
argument_list|(
name|tableName
argument_list|,
name|tab
argument_list|)
expr_stmt|;
break|break;
default|default:
assert|assert
literal|false
assert|;
block|}
block|}
block|}
comment|/**    * Handle alter table<name> not stored as directories    *    * @param tableName    * @param tab    * @throws SemanticException    */
specifier|private
name|void
name|handleAlterTableDisableStoredAsDirs
parameter_list|(
name|String
name|tableName
parameter_list|,
name|Table
name|tab
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|skewedColNames
init|=
name|tab
operator|.
name|getSkewedColNames
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|skewedColValues
init|=
name|tab
operator|.
name|getSkewedColValues
argument_list|()
decl_stmt|;
if|if
condition|(
name|CollectionUtils
operator|.
name|isEmpty
argument_list|(
name|skewedColNames
argument_list|)
operator|||
name|CollectionUtils
operator|.
name|isEmpty
argument_list|(
name|skewedColValues
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_TBL_STOREDASDIR_NOT_SKEWED
operator|.
name|getMsg
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
name|AlterTableSkewedByDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableSkewedByDesc
argument_list|(
name|tableName
argument_list|,
name|skewedColNames
argument_list|,
name|skewedColValues
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Process "alter table<name> skewed by .. on .. stored as directories    * @param ast    * @param tableName    * @param tab    * @throws SemanticException    */
specifier|private
name|void
name|handleAlterTableSkewedBy
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|Table
name|tab
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|skewedColNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|skewedValues
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/* skewed column names. */
name|ASTNode
name|skewedNode
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|skewedColNames
operator|=
name|analyzeSkewedTablDDLColNames
argument_list|(
name|skewedColNames
argument_list|,
name|skewedNode
argument_list|)
expr_stmt|;
comment|/* skewed value. */
name|analyzeDDLSkewedValues
argument_list|(
name|skewedValues
argument_list|,
name|skewedNode
argument_list|)
expr_stmt|;
comment|// stored as directories
name|boolean
name|storedAsDirs
init|=
name|analyzeStoredAdDirs
argument_list|(
name|skewedNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
operator|!=
literal|null
condition|)
block|{
comment|/* Validate skewed information. */
name|ValidationUtility
operator|.
name|validateSkewedInformation
argument_list|(
name|ParseUtils
operator|.
name|validateColumnNameUniqueness
argument_list|(
name|tab
operator|.
name|getCols
argument_list|()
argument_list|)
argument_list|,
name|skewedColNames
argument_list|,
name|skewedValues
argument_list|)
expr_stmt|;
block|}
name|AlterTableSkewedByDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableSkewedByDesc
argument_list|(
name|tableName
argument_list|,
name|skewedColNames
argument_list|,
name|skewedValues
argument_list|,
name|storedAsDirs
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Analyze alter table's skewed location    *    * @param ast    * @param tableName    * @param partSpec    * @throws SemanticException    */
specifier|private
name|void
name|analyzeAlterTableSkewedLocation
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|/**      * Throw an error if the user tries to use the DDL with      * hive.internal.ddl.list.bucketing.enable set to false.      */
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getConf
argument_list|()
expr_stmt|;
comment|/**      * Retrieve mappings from parser      */
name|Map
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|String
argument_list|>
name|locations
init|=
operator|new
name|HashMap
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|locNodes
init|=
name|ast
operator|.
name|getChildren
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|locNodes
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_TBL_SKEWED_LOC_NO_LOC
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
for|for
control|(
name|Node
name|locNode
range|:
name|locNodes
control|)
block|{
comment|// TOK_SKEWED_LOCATIONS
name|ASTNode
name|locAstNode
init|=
operator|(
name|ASTNode
operator|)
name|locNode
decl_stmt|;
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|locListNodes
init|=
name|locAstNode
operator|.
name|getChildren
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|locListNodes
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_TBL_SKEWED_LOC_NO_LOC
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
for|for
control|(
name|Node
name|locListNode
range|:
name|locListNodes
control|)
block|{
comment|// TOK_SKEWED_LOCATION_LIST
name|ASTNode
name|locListAstNode
init|=
operator|(
name|ASTNode
operator|)
name|locListNode
decl_stmt|;
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|locMapNodes
init|=
name|locListAstNode
operator|.
name|getChildren
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|locMapNodes
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_TBL_SKEWED_LOC_NO_LOC
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
for|for
control|(
name|Node
name|locMapNode
range|:
name|locMapNodes
control|)
block|{
comment|// TOK_SKEWED_LOCATION_MAP
name|ASTNode
name|locMapAstNode
init|=
operator|(
name|ASTNode
operator|)
name|locMapNode
decl_stmt|;
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|locMapAstNodeMaps
init|=
name|locMapAstNode
operator|.
name|getChildren
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
literal|null
operator|==
name|locMapAstNodeMaps
operator|)
operator|||
operator|(
name|locMapAstNodeMaps
operator|.
name|size
argument_list|()
operator|!=
literal|2
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_TBL_SKEWED_LOC_NO_MAP
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|List
argument_list|<
name|String
argument_list|>
name|keyList
init|=
operator|new
name|LinkedList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ASTNode
name|node
init|=
operator|(
name|ASTNode
operator|)
name|locMapAstNodeMaps
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABCOLVALUES
condition|)
block|{
name|keyList
operator|=
name|getSkewedValuesFromASTNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isConstant
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|keyList
operator|.
name|add
argument_list|(
name|PlanUtils
operator|.
name|stripQuotes
argument_list|(
name|node
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|SKEWED_TABLE_NO_COLUMN_VALUE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|String
name|newLocation
init|=
name|PlanUtils
operator|.
name|stripQuotes
argument_list|(
name|unescapeSQLString
argument_list|(
operator|(
operator|(
name|ASTNode
operator|)
name|locMapAstNodeMaps
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|validateSkewedLocationString
argument_list|(
name|newLocation
argument_list|)
expr_stmt|;
name|locations
operator|.
name|put
argument_list|(
name|keyList
argument_list|,
name|newLocation
argument_list|)
expr_stmt|;
name|addLocationToOutputs
argument_list|(
name|newLocation
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
name|AlterTableSetSkewedLocationDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableSetSkewedLocationDesc
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|locations
argument_list|)
decl_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|alterTblDesc
argument_list|,
name|AlterTableType
operator|.
name|SET_SKEWED_LOCATION
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addLocationToOutputs
parameter_list|(
name|String
name|newLocation
parameter_list|)
throws|throws
name|SemanticException
block|{
name|outputs
operator|.
name|add
argument_list|(
name|toWriteEntity
argument_list|(
name|newLocation
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check if the node is constant.    *    * @param node    * @return    */
specifier|private
name|boolean
name|isConstant
parameter_list|(
name|ASTNode
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|Number
case|:
case|case
name|HiveParser
operator|.
name|StringLiteral
case|:
case|case
name|HiveParser
operator|.
name|IntegralLiteral
case|:
case|case
name|HiveParser
operator|.
name|NumberLiteral
case|:
case|case
name|HiveParser
operator|.
name|CharSetName
case|:
case|case
name|HiveParser
operator|.
name|KW_TRUE
case|:
case|case
name|HiveParser
operator|.
name|KW_FALSE
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
specifier|private
name|void
name|validateSkewedLocationString
parameter_list|(
name|String
name|newLocation
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|/* Validate location string. */
try|try
block|{
name|URI
name|locUri
init|=
operator|new
name|URI
argument_list|(
name|newLocation
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|locUri
operator|.
name|isAbsolute
argument_list|()
operator|||
name|locUri
operator|.
name|getScheme
argument_list|()
operator|==
literal|null
operator|||
name|locUri
operator|.
name|getScheme
argument_list|()
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|newLocation
operator|+
literal|" is not absolute or has no scheme information. "
operator|+
literal|"Please specify a complete absolute uri with scheme information."
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|HiveAuthorizationTaskFactory
name|createAuthorizationTaskFactory
parameter_list|(
name|HiveConf
name|conf
parameter_list|,
name|Hive
name|db
parameter_list|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|HiveAuthorizationTaskFactory
argument_list|>
name|authProviderClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_AUTHORIZATION_TASK_FACTORY
operator|.
name|varname
argument_list|,
name|HiveAuthorizationTaskFactoryImpl
operator|.
name|class
argument_list|,
name|HiveAuthorizationTaskFactory
operator|.
name|class
argument_list|)
decl_stmt|;
name|String
name|msg
init|=
literal|"Unable to create instance of "
operator|+
name|authProviderClass
operator|.
name|getName
argument_list|()
operator|+
literal|": "
decl_stmt|;
try|try
block|{
name|Constructor
argument_list|<
name|?
extends|extends
name|HiveAuthorizationTaskFactory
argument_list|>
name|constructor
init|=
name|authProviderClass
operator|.
name|getConstructor
argument_list|(
name|HiveConf
operator|.
name|class
argument_list|,
name|Hive
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|constructor
operator|.
name|newInstance
argument_list|(
name|conf
argument_list|,
name|db
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|msg
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|msg
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InstantiationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|msg
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|msg
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|msg
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|msg
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|analyzeAlterMaterializedViewRewrite
parameter_list|(
name|String
name|fqMvName
parameter_list|,
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Value for the flag
name|boolean
name|enableFlag
decl_stmt|;
switch|switch
condition|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_REWRITE_ENABLED
case|:
name|enableFlag
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_REWRITE_DISABLED
case|:
name|enableFlag
operator|=
literal|false
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Invalid alter materialized view expression"
argument_list|)
throw|;
block|}
name|AlterMaterializedViewRewriteDesc
name|alterMVRewriteDesc
init|=
operator|new
name|AlterMaterializedViewRewriteDesc
argument_list|(
name|fqMvName
argument_list|,
name|enableFlag
argument_list|)
decl_stmt|;
comment|// It can be fully qualified name or use default database
name|Table
name|materializedViewTable
init|=
name|getTable
argument_list|(
name|fqMvName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// One last test: if we are enabling the rewrite, we need to check that query
comment|// only uses transactional (MM and ACID) tables
if|if
condition|(
name|enableFlag
condition|)
block|{
for|for
control|(
name|String
name|tableName
range|:
name|materializedViewTable
operator|.
name|getCreationMetadata
argument_list|()
operator|.
name|getTablesUsed
argument_list|()
control|)
block|{
name|Table
name|table
init|=
name|getTable
argument_list|(
name|tableName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|AcidUtils
operator|.
name|isTransactionalTable
argument_list|(
name|table
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Automatic rewriting for materialized view cannot "
operator|+
literal|"be enabled if the materialized view uses non-transactional tables"
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|AcidUtils
operator|.
name|isTransactionalTable
argument_list|(
name|materializedViewTable
argument_list|)
condition|)
block|{
name|setAcidDdlDesc
argument_list|(
name|alterMVRewriteDesc
argument_list|)
expr_stmt|;
block|}
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|materializedViewTable
argument_list|)
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|materializedViewTable
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_EXCLUSIVE
argument_list|)
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork2
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterMVRewriteDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

