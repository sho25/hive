begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveParser
operator|.
name|TOK_DATABASELOCATION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveParser
operator|.
name|TOK_DATABASEPROPERTIES
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|CommonTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|Tree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|MetaStoreUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|TableType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|Warehouse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Database
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Index
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|MetaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|NoSuchObjectException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Order
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SkewedInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|Driver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ErrorMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ArchiveUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnStatsUpdateTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FetchTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Task
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TaskFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|ReadEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|WriteEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|index
operator|.
name|HiveIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|index
operator|.
name|HiveIndex
operator|.
name|IndexType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|index
operator|.
name|HiveIndexHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|IgnoreKeyTextOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|RCFileInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|orc
operator|.
name|OrcInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lockmgr
operator|.
name|HiveTxnManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lockmgr
operator|.
name|LockException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lockmgr
operator|.
name|TxnManagerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Hive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|InvalidTableException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Partition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|authorization
operator|.
name|AuthorizationParseUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|authorization
operator|.
name|HiveAuthorizationTaskFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|authorization
operator|.
name|HiveAuthorizationTaskFactoryImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AddPartitionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AlterDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AlterIndexDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AlterIndexDesc
operator|.
name|AlterIndexTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AlterTableAlterPartDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AlterTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AlterTableDesc
operator|.
name|AlterTableTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AlterTableExchangePartition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AlterTableSimpleDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ColumnStatsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ColumnStatsUpdateWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|CreateDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|CreateIndexDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DDLWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DescDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DescFunctionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DescTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DropDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DropIndexDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DropTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FetchWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ListBucketingCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|LoadTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|LockDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|LockTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MoveWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MsckDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PlanUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PrincipalDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|RenamePartitionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|RoleDDLDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ShowColumnsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ShowCompactionsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ShowConfDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ShowCreateTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ShowDatabasesDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ShowFunctionsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ShowGrantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ShowIndexesDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ShowLocksDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ShowPartitionsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ShowTableStatusDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ShowTablesDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ShowTblPropertiesDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ShowTxnsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|StatsWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|SwitchDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TruncateTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|UnlockDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|UnlockTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|serdeConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|LazySimpleSerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorConverters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorConverters
operator|.
name|Converter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|CharTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|DecimalTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|PrimitiveTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|VarcharTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|InputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TextInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * DDLSemanticAnalyzer.  *  */
end_comment

begin_class
specifier|public
class|class
name|DDLSemanticAnalyzer
extends|extends
name|BaseSemanticAnalyzer
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|DDLSemanticAnalyzer
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|TokenToTypeName
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|reservedPartitionValues
decl_stmt|;
specifier|private
specifier|final
name|HiveAuthorizationTaskFactory
name|hiveAuthorizationTaskFactory
decl_stmt|;
static|static
block|{
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_BOOLEAN
argument_list|,
name|serdeConstants
operator|.
name|BOOLEAN_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_TINYINT
argument_list|,
name|serdeConstants
operator|.
name|TINYINT_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_SMALLINT
argument_list|,
name|serdeConstants
operator|.
name|SMALLINT_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_INT
argument_list|,
name|serdeConstants
operator|.
name|INT_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_BIGINT
argument_list|,
name|serdeConstants
operator|.
name|BIGINT_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_FLOAT
argument_list|,
name|serdeConstants
operator|.
name|FLOAT_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_DOUBLE
argument_list|,
name|serdeConstants
operator|.
name|DOUBLE_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_STRING
argument_list|,
name|serdeConstants
operator|.
name|STRING_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_CHAR
argument_list|,
name|serdeConstants
operator|.
name|CHAR_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_VARCHAR
argument_list|,
name|serdeConstants
operator|.
name|VARCHAR_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_BINARY
argument_list|,
name|serdeConstants
operator|.
name|BINARY_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_DATE
argument_list|,
name|serdeConstants
operator|.
name|DATE_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_DATETIME
argument_list|,
name|serdeConstants
operator|.
name|DATETIME_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_TIMESTAMP
argument_list|,
name|serdeConstants
operator|.
name|TIMESTAMP_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_DECIMAL
argument_list|,
name|serdeConstants
operator|.
name|DECIMAL_TYPE_NAME
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|String
name|getTypeName
parameter_list|(
name|ASTNode
name|node
parameter_list|)
throws|throws
name|SemanticException
block|{
name|int
name|token
init|=
name|node
operator|.
name|getType
argument_list|()
decl_stmt|;
name|String
name|typeName
decl_stmt|;
comment|// datetime type isn't currently supported
if|if
condition|(
name|token
operator|==
name|HiveParser
operator|.
name|TOK_DATETIME
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UNSUPPORTED_TYPE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_CHAR
case|:
name|CharTypeInfo
name|charTypeInfo
init|=
name|ParseUtils
operator|.
name|getCharTypeInfo
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|typeName
operator|=
name|charTypeInfo
operator|.
name|getQualifiedName
argument_list|()
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_VARCHAR
case|:
name|VarcharTypeInfo
name|varcharTypeInfo
init|=
name|ParseUtils
operator|.
name|getVarcharTypeInfo
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|typeName
operator|=
name|varcharTypeInfo
operator|.
name|getQualifiedName
argument_list|()
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DECIMAL
case|:
name|DecimalTypeInfo
name|decTypeInfo
init|=
name|ParseUtils
operator|.
name|getDecimalTypeTypeInfo
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|typeName
operator|=
name|decTypeInfo
operator|.
name|getQualifiedName
argument_list|()
expr_stmt|;
break|break;
default|default:
name|typeName
operator|=
name|TokenToTypeName
operator|.
name|get
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
return|return
name|typeName
return|;
block|}
specifier|public
name|DDLSemanticAnalyzer
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|SemanticException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|createHiveDB
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|DDLSemanticAnalyzer
parameter_list|(
name|HiveConf
name|conf
parameter_list|,
name|Hive
name|db
parameter_list|)
throws|throws
name|SemanticException
block|{
name|super
argument_list|(
name|conf
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|reservedPartitionValues
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
comment|// Partition can't have this name
name|reservedPartitionValues
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|DEFAULTPARTITIONNAME
argument_list|)
argument_list|)
expr_stmt|;
name|reservedPartitionValues
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|DEFAULT_ZOOKEEPER_PARTITION_NAME
argument_list|)
argument_list|)
expr_stmt|;
comment|// Partition value can't end in this suffix
name|reservedPartitionValues
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|METASTORE_INT_ORIGINAL
argument_list|)
argument_list|)
expr_stmt|;
name|reservedPartitionValues
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|METASTORE_INT_ARCHIVED
argument_list|)
argument_list|)
expr_stmt|;
name|reservedPartitionValues
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|METASTORE_INT_EXTRACTED
argument_list|)
argument_list|)
expr_stmt|;
name|hiveAuthorizationTaskFactory
operator|=
operator|new
name|HiveAuthorizationTaskFactoryImpl
argument_list|(
name|conf
argument_list|,
name|db
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|analyzeInternal
parameter_list|(
name|ASTNode
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|ast
init|=
name|input
decl_stmt|;
switch|switch
condition|(
name|ast
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_ALTERTABLE
case|:
block|{
name|ast
operator|=
operator|(
name|ASTNode
operator|)
name|input
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|String
index|[]
name|qualified
init|=
name|getQualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|input
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|tableName
init|=
name|getDotName
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
name|DDLSemanticAnalyzer
operator|.
name|getPartSpec
argument_list|(
operator|(
name|ASTNode
operator|)
name|input
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_RENAME
condition|)
block|{
name|analyzeAlterTableRename
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_TOUCH
condition|)
block|{
name|analyzeAlterTableTouch
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_ARCHIVE
condition|)
block|{
name|analyzeAlterTableArchive
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_UNARCHIVE
condition|)
block|{
name|analyzeAlterTableArchive
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_ADDCOLS
condition|)
block|{
name|analyzeAlterTableModifyCols
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
name|partSpec
argument_list|,
name|AlterTableTypes
operator|.
name|ADDCOLS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_REPLACECOLS
condition|)
block|{
name|analyzeAlterTableModifyCols
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
name|partSpec
argument_list|,
name|AlterTableTypes
operator|.
name|REPLACECOLS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_RENAMECOL
condition|)
block|{
name|analyzeAlterTableRenameCol
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_ADDPARTS
condition|)
block|{
name|analyzeAlterTableAddParts
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_DROPPARTS
condition|)
block|{
name|analyzeAlterTableDropParts
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_PARTCOLTYPE
condition|)
block|{
name|analyzeAlterTablePartColType
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_PROPERTIES
condition|)
block|{
name|analyzeAlterTableProps
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_DROPPROPERTIES
condition|)
block|{
name|analyzeAlterTableProps
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_SKEWED
condition|)
block|{
name|analyzeAltertableSkewedby
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_EXCHANGEPARTITION
condition|)
block|{
name|analyzeExchangePartition
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_FILEFORMAT
condition|)
block|{
name|analyzeAlterTableFileFormat
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_PROTECTMODE
condition|)
block|{
name|analyzeAlterTableProtectMode
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_LOCATION
condition|)
block|{
name|analyzeAlterTableLocation
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_MERGEFILES
condition|)
block|{
name|analyzeAlterTablePartMergeFiles
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_SERIALIZER
condition|)
block|{
name|analyzeAlterTableSerde
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_SERDEPROPERTIES
condition|)
block|{
name|analyzeAlterTableSerdeProps
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_RENAMEPART
condition|)
block|{
name|analyzeAlterTableRenamePart
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_SKEWED_LOCATION
condition|)
block|{
name|analyzeAlterTableSkewedLocation
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_BUCKETS
condition|)
block|{
name|analyzeAlterTableBucketNum
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_CLUSTER_SORT
condition|)
block|{
name|analyzeAlterTableClusterSort
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_COMPACT
condition|)
block|{
name|analyzeAlterTableCompact
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_UPDATECOLSTATS
condition|)
block|{
name|analyzeAlterTableUpdateStats
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|HiveParser
operator|.
name|TOK_DROPTABLE
case|:
name|analyzeDropTable
argument_list|(
name|ast
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TRUNCATETABLE
case|:
name|analyzeTruncateTable
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_CREATEINDEX
case|:
name|analyzeCreateIndex
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DROPINDEX
case|:
name|analyzeDropIndex
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DESCTABLE
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeDescribeTable
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOWDATABASES
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowDatabases
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOWTABLES
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowTables
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOWCOLUMNS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowColumns
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_TABLESTATUS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowTableStatus
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_TBLPROPERTIES
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowTableProperties
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOWFUNCTIONS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowFunctions
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOWLOCKS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowLocks
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOWDBLOCKS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowDbLocks
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_COMPACTIONS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowCompactions
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_TRANSACTIONS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowTxns
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOWCONF
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowConf
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DESCFUNCTION
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeDescFunction
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DESCDATABASE
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeDescDatabase
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_MSCK
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeMetastoreCheck
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DROPVIEW
case|:
name|analyzeDropTable
argument_list|(
name|ast
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERVIEW
case|:
block|{
name|String
index|[]
name|qualified
init|=
name|getQualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|ast
operator|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERVIEW_PROPERTIES
condition|)
block|{
name|analyzeAlterTableProps
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERVIEW_DROPPROPERTIES
condition|)
block|{
name|analyzeAlterTableProps
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERVIEW_ADDPARTS
condition|)
block|{
name|analyzeAlterTableAddParts
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERVIEW_DROPPARTS
condition|)
block|{
name|analyzeAlterTableDropParts
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERVIEW_RENAME
condition|)
block|{
name|analyzeAlterTableRename
argument_list|(
name|qualified
argument_list|,
name|ast
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|HiveParser
operator|.
name|TOK_ALTERINDEX_REBUILD
case|:
name|analyzeAlterIndexRebuild
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERINDEX_PROPERTIES
case|:
name|analyzeAlterIndexProps
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOWPARTITIONS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowPartitions
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_CREATETABLE
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowCreateTable
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOWINDEXES
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowIndexes
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_LOCKTABLE
case|:
name|analyzeLockTable
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_UNLOCKTABLE
case|:
name|analyzeUnlockTable
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_LOCKDB
case|:
name|analyzeLockDatabase
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_UNLOCKDB
case|:
name|analyzeUnlockDatabase
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_CREATEDATABASE
case|:
name|analyzeCreateDatabase
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DROPDATABASE
case|:
name|analyzeDropDatabase
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SWITCHDATABASE
case|:
name|analyzeSwitchDatabase
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERDATABASE_PROPERTIES
case|:
name|analyzeAlterDatabaseProperties
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERDATABASE_OWNER
case|:
name|analyzeAlterDatabaseOwner
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_CREATEROLE
case|:
name|analyzeCreateRole
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DROPROLE
case|:
name|analyzeDropRole
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_ROLE_GRANT
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowRoleGrant
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_ROLE_PRINCIPALS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowRolePrincipals
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_ROLES
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowRoles
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_GRANT_ROLE
case|:
name|analyzeGrantRevokeRole
argument_list|(
literal|true
argument_list|,
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_REVOKE_ROLE
case|:
name|analyzeGrantRevokeRole
argument_list|(
literal|false
argument_list|,
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_GRANT
case|:
name|analyzeGrant
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_GRANT
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|analyzeShowGrant
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_REVOKE
case|:
name|analyzeRevoke
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_SET_ROLE
case|:
name|analyzeSetShowRole
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unsupported command."
argument_list|)
throw|;
block|}
if|if
condition|(
name|fetchTask
operator|!=
literal|null
operator|&&
operator|!
name|rootTasks
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|rootTasks
operator|.
name|get
argument_list|(
name|rootTasks
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|setFetchSource
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeAlterTableUpdateStats
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tblName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|colName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapProp
init|=
name|getProps
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|Table
name|tbl
init|=
name|getTable
argument_list|(
name|tblName
argument_list|)
decl_stmt|;
name|String
name|partName
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|partSpec
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|partName
operator|=
name|Warehouse
operator|.
name|makePartName
argument_list|(
name|partSpec
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MetaException
name|e
parameter_list|)
block|{
comment|// TODO Auto-generated catch block
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"partition "
operator|+
name|partSpec
operator|.
name|toString
argument_list|()
operator|+
literal|" not found"
argument_list|)
throw|;
block|}
block|}
name|String
name|colType
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|cols
init|=
name|tbl
operator|.
name|getCols
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldSchema
name|col
range|:
name|cols
control|)
block|{
if|if
condition|(
name|colName
operator|.
name|equalsIgnoreCase
argument_list|(
name|col
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|colType
operator|=
name|col
operator|.
name|getType
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|colType
operator|==
literal|null
condition|)
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"column type not found"
argument_list|)
throw|;
name|ColumnStatsDesc
name|cStatsDesc
init|=
operator|new
name|ColumnStatsDesc
argument_list|(
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|colName
argument_list|)
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|colType
argument_list|)
argument_list|,
name|partSpec
operator|==
literal|null
argument_list|)
decl_stmt|;
name|ColumnStatsUpdateTask
name|cStatsUpdateTask
init|=
operator|(
name|ColumnStatsUpdateTask
operator|)
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|ColumnStatsUpdateWork
argument_list|(
name|cStatsDesc
argument_list|,
name|partName
argument_list|,
name|mapProp
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|cStatsUpdateTask
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeSetShowRole
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
switch|switch
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|hiveAuthorizationTaskFactory
operator|.
name|createShowCurrentRoleTask
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|RoleDDLDesc
operator|.
name|getRoleNameSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|rootTasks
operator|.
name|add
argument_list|(
name|hiveAuthorizationTaskFactory
operator|.
name|createSetRoleTask
argument_list|(
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Internal error. ASTNode expected to have 0 or 1 child. "
operator|+
name|ast
operator|.
name|dump
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|analyzeGrantRevokeRole
parameter_list|(
name|boolean
name|grant
parameter_list|,
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
decl_stmt|;
if|if
condition|(
name|grant
condition|)
block|{
name|task
operator|=
name|hiveAuthorizationTaskFactory
operator|.
name|createGrantRoleTask
argument_list|(
name|ast
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|task
operator|=
name|hiveAuthorizationTaskFactory
operator|.
name|createRevokeRoleTask
argument_list|(
name|ast
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|task
operator|!=
literal|null
condition|)
block|{
name|rootTasks
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeShowGrant
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
init|=
name|hiveAuthorizationTaskFactory
operator|.
name|createShowGrantTask
argument_list|(
name|ast
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|task
operator|!=
literal|null
condition|)
block|{
name|rootTasks
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|ShowGrantDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeGrant
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
init|=
name|hiveAuthorizationTaskFactory
operator|.
name|createGrantTask
argument_list|(
name|ast
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|task
operator|!=
literal|null
condition|)
block|{
name|rootTasks
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeRevoke
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
init|=
name|hiveAuthorizationTaskFactory
operator|.
name|createRevokeTask
argument_list|(
name|ast
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|task
operator|!=
literal|null
condition|)
block|{
name|rootTasks
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeCreateRole
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
init|=
name|hiveAuthorizationTaskFactory
operator|.
name|createCreateRoleTask
argument_list|(
name|ast
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|task
operator|!=
literal|null
condition|)
block|{
name|rootTasks
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeDropRole
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
init|=
name|hiveAuthorizationTaskFactory
operator|.
name|createDropRoleTask
argument_list|(
name|ast
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|task
operator|!=
literal|null
condition|)
block|{
name|rootTasks
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeShowRoleGrant
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
init|=
name|hiveAuthorizationTaskFactory
operator|.
name|createShowRoleGrantTask
argument_list|(
name|ast
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|task
operator|!=
literal|null
condition|)
block|{
name|rootTasks
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|RoleDDLDesc
operator|.
name|getRoleShowGrantSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeShowRolePrincipals
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Task
argument_list|<
name|DDLWork
argument_list|>
name|roleDDLTask
init|=
operator|(
name|Task
argument_list|<
name|DDLWork
argument_list|>
operator|)
name|hiveAuthorizationTaskFactory
operator|.
name|createShowRolePrincipalsTask
argument_list|(
name|ast
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|roleDDLTask
operator|!=
literal|null
condition|)
block|{
name|rootTasks
operator|.
name|add
argument_list|(
name|roleDDLTask
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|RoleDDLDesc
operator|.
name|getShowRolePrincipalsSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeShowRoles
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Task
argument_list|<
name|DDLWork
argument_list|>
name|roleDDLTask
init|=
operator|(
name|Task
argument_list|<
name|DDLWork
argument_list|>
operator|)
name|hiveAuthorizationTaskFactory
operator|.
name|createShowRolesTask
argument_list|(
name|ast
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|roleDDLTask
operator|!=
literal|null
condition|)
block|{
name|rootTasks
operator|.
name|add
argument_list|(
name|roleDDLTask
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|RoleDDLDesc
operator|.
name|getRoleNameSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeAlterDatabaseProperties
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|dbName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|dbProps
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|childNode
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|childNode
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_DATABASEPROPERTIES
case|:
name|dbProps
operator|=
name|DDLSemanticAnalyzer
operator|.
name|getProps
argument_list|(
operator|(
name|ASTNode
operator|)
name|childNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unrecognized token in CREATE DATABASE statement"
argument_list|)
throw|;
block|}
block|}
name|AlterDatabaseDesc
name|alterDesc
init|=
operator|new
name|AlterDatabaseDesc
argument_list|(
name|dbName
argument_list|,
name|dbProps
argument_list|)
decl_stmt|;
name|addAlterDbDesc
argument_list|(
name|alterDesc
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addAlterDbDesc
parameter_list|(
name|AlterDatabaseDesc
name|alterDesc
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Database
name|database
init|=
name|getDatabase
argument_list|(
name|alterDesc
operator|.
name|getDatabaseName
argument_list|()
argument_list|)
decl_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|database
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_NO_LOCK
argument_list|)
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterDatabaseOwner
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|dbName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|PrincipalDesc
name|principalDesc
init|=
name|AuthorizationParseUtils
operator|.
name|getPrincipalDesc
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|// The syntax should not allow these fields to be null, but lets verify
name|String
name|nullCmdMsg
init|=
literal|"can't be null in alter database set owner command"
decl_stmt|;
if|if
condition|(
name|principalDesc
operator|.
name|getName
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Owner name "
operator|+
name|nullCmdMsg
argument_list|)
throw|;
block|}
if|if
condition|(
name|principalDesc
operator|.
name|getType
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Owner type "
operator|+
name|nullCmdMsg
argument_list|)
throw|;
block|}
name|AlterDatabaseDesc
name|alterDesc
init|=
operator|new
name|AlterDatabaseDesc
argument_list|(
name|dbName
argument_list|,
name|principalDesc
argument_list|)
decl_stmt|;
name|addAlterDbDesc
argument_list|(
name|alterDesc
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeExchangePartition
parameter_list|(
name|String
index|[]
name|qualified
parameter_list|,
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Table
name|destTable
init|=
name|getTable
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|Table
name|sourceTable
init|=
name|getTable
argument_list|(
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|// Get the partition specs
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpecs
init|=
name|getPartSpec
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|validatePartitionValues
argument_list|(
name|partSpecs
argument_list|)
expr_stmt|;
name|boolean
name|sameColumns
init|=
name|MetaStoreUtils
operator|.
name|compareFieldColumns
argument_list|(
name|destTable
operator|.
name|getAllCols
argument_list|()
argument_list|,
name|sourceTable
operator|.
name|getAllCols
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|samePartitions
init|=
name|MetaStoreUtils
operator|.
name|compareFieldColumns
argument_list|(
name|destTable
operator|.
name|getPartitionKeys
argument_list|()
argument_list|,
name|sourceTable
operator|.
name|getPartitionKeys
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sameColumns
operator|||
operator|!
name|samePartitions
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TABLES_INCOMPATIBLE_SCHEMAS
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
comment|// check if source partition exists
name|getPartitions
argument_list|(
name|sourceTable
argument_list|,
name|partSpecs
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Verify that the partitions specified are continuous
comment|// If a subpartition value is specified without specifying a partition's value
comment|// then we throw an exception
name|int
name|counter
init|=
name|isPartitionValueContinuous
argument_list|(
name|sourceTable
operator|.
name|getPartitionKeys
argument_list|()
argument_list|,
name|partSpecs
argument_list|)
decl_stmt|;
if|if
condition|(
name|counter
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|PARTITION_VALUE_NOT_CONTINUOUS
operator|.
name|getMsg
argument_list|(
name|partSpecs
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|Partition
argument_list|>
name|destPartitions
init|=
literal|null
decl_stmt|;
try|try
block|{
name|destPartitions
operator|=
name|getPartitions
argument_list|(
name|destTable
argument_list|,
name|partSpecs
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|ex
parameter_list|)
block|{
comment|// We should expect a semantic exception being throw as this partition
comment|// should not be present.
block|}
if|if
condition|(
name|destPartitions
operator|!=
literal|null
condition|)
block|{
comment|// If any destination partition is present then throw a Semantic Exception.
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|PARTITION_EXISTS
operator|.
name|getMsg
argument_list|(
name|destPartitions
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|AlterTableExchangePartition
name|alterTableExchangePartition
init|=
operator|new
name|AlterTableExchangePartition
argument_list|(
name|sourceTable
argument_list|,
name|destTable
argument_list|,
name|partSpecs
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTableExchangePartition
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param partitionKeys the list of partition keys of the table    * @param partSpecs the partition specs given by the user    * @return>=0 if no subpartition value is specified without a partition's    *         value being specified else it returns -1    */
specifier|private
name|int
name|isPartitionValueContinuous
parameter_list|(
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|partitionKeys
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpecs
parameter_list|)
block|{
name|int
name|counter
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FieldSchema
name|partitionKey
range|:
name|partitionKeys
control|)
block|{
if|if
condition|(
name|partSpecs
operator|.
name|containsKey
argument_list|(
name|partitionKey
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|counter
operator|++
expr_stmt|;
continue|continue;
block|}
return|return
name|partSpecs
operator|.
name|size
argument_list|()
operator|==
name|counter
condition|?
name|counter
else|:
operator|-
literal|1
return|;
block|}
return|return
name|counter
return|;
block|}
specifier|private
name|void
name|analyzeCreateDatabase
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|dbName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|ifNotExists
init|=
literal|false
decl_stmt|;
name|String
name|dbComment
init|=
literal|null
decl_stmt|;
name|String
name|dbLocation
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|dbProps
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|childNode
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|childNode
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_IFNOTEXISTS
case|:
name|ifNotExists
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DATABASECOMMENT
case|:
name|dbComment
operator|=
name|unescapeSQLString
argument_list|(
name|childNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_DATABASEPROPERTIES
case|:
name|dbProps
operator|=
name|DDLSemanticAnalyzer
operator|.
name|getProps
argument_list|(
operator|(
name|ASTNode
operator|)
name|childNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_DATABASELOCATION
case|:
name|dbLocation
operator|=
name|unescapeSQLString
argument_list|(
name|childNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|addLocationToOutputs
argument_list|(
name|dbLocation
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unrecognized token in CREATE DATABASE statement"
argument_list|)
throw|;
block|}
block|}
name|CreateDatabaseDesc
name|createDatabaseDesc
init|=
operator|new
name|CreateDatabaseDesc
argument_list|(
name|dbName
argument_list|,
name|dbComment
argument_list|,
name|dbLocation
argument_list|,
name|ifNotExists
argument_list|)
decl_stmt|;
if|if
condition|(
name|dbProps
operator|!=
literal|null
condition|)
block|{
name|createDatabaseDesc
operator|.
name|setDatabaseProperties
argument_list|(
name|dbProps
argument_list|)
expr_stmt|;
block|}
name|Database
name|database
init|=
operator|new
name|Database
argument_list|(
name|dbName
argument_list|,
name|dbComment
argument_list|,
name|dbLocation
argument_list|,
name|dbProps
argument_list|)
decl_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|database
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_NO_LOCK
argument_list|)
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|createDatabaseDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeDropDatabase
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|dbName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|ifExists
init|=
literal|false
decl_stmt|;
name|boolean
name|ifCascade
init|=
literal|false
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|ast
operator|.
name|getFirstChildWithType
argument_list|(
name|HiveParser
operator|.
name|TOK_IFEXISTS
argument_list|)
condition|)
block|{
name|ifExists
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|!=
name|ast
operator|.
name|getFirstChildWithType
argument_list|(
name|HiveParser
operator|.
name|TOK_CASCADE
argument_list|)
condition|)
block|{
name|ifCascade
operator|=
literal|true
expr_stmt|;
block|}
name|Database
name|database
init|=
name|getDatabase
argument_list|(
name|dbName
argument_list|,
operator|!
name|ifExists
argument_list|)
decl_stmt|;
if|if
condition|(
name|database
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// if cascade=true, then we need to authorize the drop table action as well
if|if
condition|(
name|ifCascade
condition|)
block|{
comment|// add the tables as well to outputs
name|List
argument_list|<
name|String
argument_list|>
name|tableNames
decl_stmt|;
comment|// get names of all tables under this dbName
try|try
block|{
name|tableNames
operator|=
name|db
operator|.
name|getAllTables
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// add tables to outputs
if|if
condition|(
name|tableNames
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|tableName
range|:
name|tableNames
control|)
block|{
name|Table
name|table
init|=
name|getTable
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// We want no lock here, as the database lock will cover the tables,
comment|// and putting a lock will actually cause us to deadlock on ourselves.
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|table
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_NO_LOCK
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|database
argument_list|)
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|database
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_EXCLUSIVE
argument_list|)
argument_list|)
expr_stmt|;
name|DropDatabaseDesc
name|dropDatabaseDesc
init|=
operator|new
name|DropDatabaseDesc
argument_list|(
name|dbName
argument_list|,
name|ifExists
argument_list|,
name|ifCascade
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|dropDatabaseDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeSwitchDatabase
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|dbName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|Database
name|database
init|=
name|getDatabase
argument_list|(
name|dbName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|ReadEntity
name|dbReadEntity
init|=
operator|new
name|ReadEntity
argument_list|(
name|database
argument_list|)
decl_stmt|;
name|dbReadEntity
operator|.
name|noLockNeeded
argument_list|()
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
name|dbReadEntity
argument_list|)
expr_stmt|;
name|SwitchDatabaseDesc
name|switchDatabaseDesc
init|=
operator|new
name|SwitchDatabaseDesc
argument_list|(
name|dbName
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|switchDatabaseDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeDropTable
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|boolean
name|expectView
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|boolean
name|ifExists
init|=
operator|(
name|ast
operator|.
name|getFirstChildWithType
argument_list|(
name|HiveParser
operator|.
name|TOK_IFEXISTS
argument_list|)
operator|!=
literal|null
operator|)
decl_stmt|;
comment|// we want to signal an error if the table/view doesn't exist and we're
comment|// configured not to fail silently
name|boolean
name|throwException
init|=
operator|!
name|ifExists
operator|&&
operator|!
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|DROPIGNORESNONEXISTENT
argument_list|)
decl_stmt|;
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|tableName
argument_list|,
name|throwException
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
operator|!=
literal|null
condition|)
block|{
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_EXCLUSIVE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|boolean
name|ifPurge
init|=
operator|(
name|ast
operator|.
name|getFirstChildWithType
argument_list|(
name|HiveParser
operator|.
name|KW_PURGE
argument_list|)
operator|!=
literal|null
operator|)
decl_stmt|;
name|DropTableDesc
name|dropTblDesc
init|=
operator|new
name|DropTableDesc
argument_list|(
name|tableName
argument_list|,
name|expectView
argument_list|,
name|ifExists
argument_list|,
name|ifPurge
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|dropTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeTruncateTable
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|root
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// TOK_TABLE_PARTITION
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|root
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|Table
name|table
init|=
name|getTable
argument_list|(
name|tableName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
operator|.
name|getTableType
argument_list|()
operator|!=
name|TableType
operator|.
name|MANAGED_TABLE
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TRUNCATE_FOR_NON_MANAGED_TABLE
operator|.
name|format
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|table
operator|.
name|isNonNative
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TRUNCATE_FOR_NON_NATIVE_TABLE
operator|.
name|format
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
comment|//TODO
block|}
if|if
condition|(
operator|!
name|table
operator|.
name|isPartitioned
argument_list|()
operator|&&
name|root
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|PARTSPEC_FOR_NON_PARTITIONED_TABLE
operator|.
name|format
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
name|getPartSpec
argument_list|(
operator|(
name|ASTNode
operator|)
name|root
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|partSpec
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|table
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|table
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_EXCLUSIVE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|Partition
name|partition
range|:
name|getPartitions
argument_list|(
name|table
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
control|)
block|{
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|partition
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_EXCLUSIVE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|isFullSpec
argument_list|(
name|table
argument_list|,
name|partSpec
argument_list|)
condition|)
block|{
name|Partition
name|partition
init|=
name|getPartition
argument_list|(
name|table
argument_list|,
name|partSpec
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|partition
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_EXCLUSIVE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|Partition
name|partition
range|:
name|getPartitions
argument_list|(
name|table
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
control|)
block|{
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|partition
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_EXCLUSIVE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|TruncateTableDesc
name|truncateTblDesc
init|=
operator|new
name|TruncateTableDesc
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|)
decl_stmt|;
name|DDLWork
name|ddlWork
init|=
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|truncateTblDesc
argument_list|)
decl_stmt|;
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|truncateTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
name|ddlWork
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|// Is this a truncate column command
name|List
argument_list|<
name|String
argument_list|>
name|columnNames
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
try|try
block|{
name|columnNames
operator|=
name|getColumnNames
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// Throw an error if the table is indexed
name|List
argument_list|<
name|Index
argument_list|>
name|indexes
init|=
name|db
operator|.
name|getIndexes
argument_list|(
name|table
operator|.
name|getDbName
argument_list|()
argument_list|,
name|tableName
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexes
operator|!=
literal|null
operator|&&
name|indexes
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TRUNCATE_COLUMN_INDEXED_TABLE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|bucketCols
init|=
literal|null
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|InputFormat
argument_list|>
name|inputFormatClass
init|=
literal|null
decl_stmt|;
name|boolean
name|isArchived
init|=
literal|false
decl_stmt|;
name|Path
name|newTblPartLoc
init|=
literal|null
decl_stmt|;
name|Path
name|oldTblPartLoc
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|cols
init|=
literal|null
decl_stmt|;
name|ListBucketingCtx
name|lbCtx
init|=
literal|null
decl_stmt|;
name|boolean
name|isListBucketed
init|=
literal|false
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|listBucketColNames
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|table
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
name|Partition
name|part
init|=
name|db
operator|.
name|getPartition
argument_list|(
name|table
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|Path
name|tabPath
init|=
name|table
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|Path
name|partPath
init|=
name|part
operator|.
name|getDataLocation
argument_list|()
decl_stmt|;
comment|// if the table is in a different dfs than the partition,
comment|// replace the partition's dfs with the table's dfs.
name|newTblPartLoc
operator|=
operator|new
name|Path
argument_list|(
name|tabPath
operator|.
name|toUri
argument_list|()
operator|.
name|getScheme
argument_list|()
argument_list|,
name|tabPath
operator|.
name|toUri
argument_list|()
operator|.
name|getAuthority
argument_list|()
argument_list|,
name|partPath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|oldTblPartLoc
operator|=
name|partPath
expr_stmt|;
name|cols
operator|=
name|part
operator|.
name|getCols
argument_list|()
expr_stmt|;
name|bucketCols
operator|=
name|part
operator|.
name|getBucketCols
argument_list|()
expr_stmt|;
name|inputFormatClass
operator|=
name|part
operator|.
name|getInputFormatClass
argument_list|()
expr_stmt|;
name|isArchived
operator|=
name|ArchiveUtils
operator|.
name|isArchived
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|lbCtx
operator|=
name|constructListBucketingCtx
argument_list|(
name|part
operator|.
name|getSkewedColNames
argument_list|()
argument_list|,
name|part
operator|.
name|getSkewedColValues
argument_list|()
argument_list|,
name|part
operator|.
name|getSkewedColValueLocationMaps
argument_list|()
argument_list|,
name|part
operator|.
name|isStoredAsSubDirectories
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|isListBucketed
operator|=
name|part
operator|.
name|isStoredAsSubDirectories
argument_list|()
expr_stmt|;
name|listBucketColNames
operator|=
name|part
operator|.
name|getSkewedColNames
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// input and output are the same
name|oldTblPartLoc
operator|=
name|table
operator|.
name|getPath
argument_list|()
expr_stmt|;
name|newTblPartLoc
operator|=
name|table
operator|.
name|getPath
argument_list|()
expr_stmt|;
name|cols
operator|=
name|table
operator|.
name|getCols
argument_list|()
expr_stmt|;
name|bucketCols
operator|=
name|table
operator|.
name|getBucketCols
argument_list|()
expr_stmt|;
name|inputFormatClass
operator|=
name|table
operator|.
name|getInputFormatClass
argument_list|()
expr_stmt|;
name|lbCtx
operator|=
name|constructListBucketingCtx
argument_list|(
name|table
operator|.
name|getSkewedColNames
argument_list|()
argument_list|,
name|table
operator|.
name|getSkewedColValues
argument_list|()
argument_list|,
name|table
operator|.
name|getSkewedColValueLocationMaps
argument_list|()
argument_list|,
name|table
operator|.
name|isStoredAsSubDirectories
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|isListBucketed
operator|=
name|table
operator|.
name|isStoredAsSubDirectories
argument_list|()
expr_stmt|;
name|listBucketColNames
operator|=
name|table
operator|.
name|getSkewedColNames
argument_list|()
expr_stmt|;
block|}
comment|// throw a HiveException for non-rcfile.
if|if
condition|(
operator|!
name|inputFormatClass
operator|.
name|equals
argument_list|(
name|RCFileInputFormat
operator|.
name|class
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TRUNCATE_COLUMN_NOT_RC
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
comment|// throw a HiveException if the table/partition is archived
if|if
condition|(
name|isArchived
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TRUNCATE_COLUMN_ARCHIVED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|Set
argument_list|<
name|Integer
argument_list|>
name|columnIndexes
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|columnName
range|:
name|columnNames
control|)
block|{
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|columnIndex
init|=
literal|0
init|;
name|columnIndex
operator|<
name|cols
operator|.
name|size
argument_list|()
condition|;
name|columnIndex
operator|++
control|)
block|{
if|if
condition|(
name|columnName
operator|.
name|equalsIgnoreCase
argument_list|(
name|cols
operator|.
name|get
argument_list|(
name|columnIndex
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|columnIndexes
operator|.
name|add
argument_list|(
name|columnIndex
argument_list|)
expr_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// Throw an exception if the user is trying to truncate a column which doesn't exist
if|if
condition|(
operator|!
name|found
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|columnName
argument_list|)
argument_list|)
throw|;
block|}
comment|// Throw an exception if the table/partition is bucketed on one of the columns
for|for
control|(
name|String
name|bucketCol
range|:
name|bucketCols
control|)
block|{
if|if
condition|(
name|bucketCol
operator|.
name|equalsIgnoreCase
argument_list|(
name|columnName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TRUNCATE_BUCKETED_COLUMN
operator|.
name|getMsg
argument_list|(
name|columnName
argument_list|)
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|isListBucketed
condition|)
block|{
for|for
control|(
name|String
name|listBucketCol
range|:
name|listBucketColNames
control|)
block|{
if|if
condition|(
name|listBucketCol
operator|.
name|equalsIgnoreCase
argument_list|(
name|columnName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TRUNCATE_LIST_BUCKETED_COLUMN
operator|.
name|getMsg
argument_list|(
name|columnName
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
block|}
name|truncateTblDesc
operator|.
name|setColumnIndexes
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|columnIndexes
argument_list|)
argument_list|)
expr_stmt|;
name|truncateTblDesc
operator|.
name|setInputDir
argument_list|(
name|oldTblPartLoc
argument_list|)
expr_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
name|truncateTblDesc
operator|.
name|setLbCtx
argument_list|(
name|lbCtx
argument_list|)
expr_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
name|ddlWork
operator|.
name|setNeedLock
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|TableDesc
name|tblDesc
init|=
name|Utilities
operator|.
name|getTableDesc
argument_list|(
name|table
argument_list|)
decl_stmt|;
comment|// Write the output to temporary directory and move it to the final location at the end
comment|// so the operation is atomic.
name|Path
name|queryTmpdir
init|=
name|ctx
operator|.
name|getExternalTmpPath
argument_list|(
name|newTblPartLoc
argument_list|)
decl_stmt|;
name|truncateTblDesc
operator|.
name|setOutputDir
argument_list|(
name|queryTmpdir
argument_list|)
expr_stmt|;
name|LoadTableDesc
name|ltd
init|=
operator|new
name|LoadTableDesc
argument_list|(
name|queryTmpdir
argument_list|,
name|tblDesc
argument_list|,
name|partSpec
operator|==
literal|null
condition|?
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
else|:
name|partSpec
argument_list|)
decl_stmt|;
name|ltd
operator|.
name|setLbCtx
argument_list|(
name|lbCtx
argument_list|)
expr_stmt|;
name|Task
argument_list|<
name|MoveWork
argument_list|>
name|moveTsk
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|MoveWork
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
name|ltd
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|truncateTask
operator|.
name|addDependentTask
argument_list|(
name|moveTsk
argument_list|)
expr_stmt|;
comment|// Recalculate the HDFS stats if auto gather stats is set
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESTATSAUTOGATHER
argument_list|)
condition|)
block|{
name|StatsWork
name|statDesc
decl_stmt|;
if|if
condition|(
name|oldTblPartLoc
operator|.
name|equals
argument_list|(
name|newTblPartLoc
argument_list|)
condition|)
block|{
comment|// If we're merging to the same location, we can avoid some metastore calls
name|tableSpec
name|tablepart
init|=
operator|new
name|tableSpec
argument_list|(
name|this
operator|.
name|db
argument_list|,
name|conf
argument_list|,
name|root
argument_list|)
decl_stmt|;
name|statDesc
operator|=
operator|new
name|StatsWork
argument_list|(
name|tablepart
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|statDesc
operator|=
operator|new
name|StatsWork
argument_list|(
name|ltd
argument_list|)
expr_stmt|;
block|}
name|statDesc
operator|.
name|setNoStatsAggregator
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|statDesc
operator|.
name|setClearAggregatorStats
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|statDesc
operator|.
name|setStatsReliable
argument_list|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_STATS_RELIABLE
argument_list|)
argument_list|)
expr_stmt|;
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|statTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
name|statDesc
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|moveTsk
operator|.
name|addDependentTask
argument_list|(
name|statTask
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|truncateTask
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|boolean
name|isFullSpec
parameter_list|(
name|Table
name|table
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
block|{
for|for
control|(
name|FieldSchema
name|partCol
range|:
name|table
operator|.
name|getPartCols
argument_list|()
control|)
block|{
if|if
condition|(
name|partSpec
operator|.
name|get
argument_list|(
name|partCol
operator|.
name|getName
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|analyzeCreateIndex
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|indexName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|typeName
init|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
index|[]
name|qTabName
init|=
name|getQualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|indexedCols
init|=
name|getColumnNames
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|3
argument_list|)
argument_list|)
decl_stmt|;
name|IndexType
name|indexType
init|=
name|HiveIndex
operator|.
name|getIndexType
argument_list|(
name|typeName
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexType
operator|!=
literal|null
condition|)
block|{
name|typeName
operator|=
name|indexType
operator|.
name|getHandlerClsName
argument_list|()
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|Class
operator|.
name|forName
argument_list|(
name|typeName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"class name provided for index handler not found."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|String
name|indexTableName
init|=
literal|null
decl_stmt|;
name|boolean
name|deferredRebuild
init|=
literal|false
decl_stmt|;
name|String
name|location
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|tblProps
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|idxProps
init|=
literal|null
decl_stmt|;
name|String
name|indexComment
init|=
literal|null
decl_stmt|;
name|RowFormatParams
name|rowFormatParams
init|=
operator|new
name|RowFormatParams
argument_list|()
decl_stmt|;
name|StorageFormat
name|storageFormat
init|=
operator|new
name|StorageFormat
argument_list|(
name|conf
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|4
init|;
name|idx
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|storageFormat
operator|.
name|fillStorageFormat
argument_list|(
name|child
argument_list|)
condition|)
block|{
continue|continue;
block|}
switch|switch
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMAT
case|:
name|rowFormatParams
operator|.
name|analyzeRowFormat
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_CREATEINDEX_INDEXTBLNAME
case|:
name|ASTNode
name|ch
init|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|indexTableName
operator|=
name|getUnescapedName
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DEFERRED_REBUILDINDEX
case|:
name|deferredRebuild
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLELOCATION
case|:
name|location
operator|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|addLocationToOutputs
argument_list|(
name|location
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEPROPERTIES
case|:
name|tblProps
operator|=
name|DDLSemanticAnalyzer
operator|.
name|getProps
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_INDEXPROPERTIES
case|:
name|idxProps
operator|=
name|DDLSemanticAnalyzer
operator|.
name|getProps
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLESERIALIZER
case|:
name|child
operator|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|storageFormat
operator|.
name|setSerde
argument_list|(
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|readProps
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|storageFormat
operator|.
name|getSerdeProps
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_INDEXCOMMENT
case|:
name|child
operator|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|indexComment
operator|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|storageFormat
operator|.
name|fillDefaultStorageFormat
argument_list|()
expr_stmt|;
if|if
condition|(
name|indexTableName
operator|==
literal|null
condition|)
block|{
name|indexTableName
operator|=
name|MetaStoreUtils
operator|.
name|getIndexTableName
argument_list|(
name|qTabName
index|[
literal|0
index|]
argument_list|,
name|qTabName
index|[
literal|1
index|]
argument_list|,
name|indexName
argument_list|)
expr_stmt|;
name|indexTableName
operator|=
name|qTabName
index|[
literal|0
index|]
operator|+
literal|"."
operator|+
name|indexTableName
expr_stmt|;
comment|// on same database with base table
block|}
else|else
block|{
name|indexTableName
operator|=
name|getDotName
argument_list|(
name|Utilities
operator|.
name|getDbTableName
argument_list|(
name|indexTableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|getTable
argument_list|(
name|qTabName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CreateIndexDesc
name|crtIndexDesc
init|=
operator|new
name|CreateIndexDesc
argument_list|(
name|getDotName
argument_list|(
name|qTabName
argument_list|)
argument_list|,
name|indexName
argument_list|,
name|indexedCols
argument_list|,
name|indexTableName
argument_list|,
name|deferredRebuild
argument_list|,
name|storageFormat
operator|.
name|getInputFormat
argument_list|()
argument_list|,
name|storageFormat
operator|.
name|getOutputFormat
argument_list|()
argument_list|,
name|storageFormat
operator|.
name|getStorageHandler
argument_list|()
argument_list|,
name|typeName
argument_list|,
name|location
argument_list|,
name|idxProps
argument_list|,
name|tblProps
argument_list|,
name|storageFormat
operator|.
name|getSerde
argument_list|()
argument_list|,
name|storageFormat
operator|.
name|getSerdeProps
argument_list|()
argument_list|,
name|rowFormatParams
operator|.
name|collItemDelim
argument_list|,
name|rowFormatParams
operator|.
name|fieldDelim
argument_list|,
name|rowFormatParams
operator|.
name|fieldEscape
argument_list|,
name|rowFormatParams
operator|.
name|lineDelim
argument_list|,
name|rowFormatParams
operator|.
name|mapKeyDelim
argument_list|,
name|indexComment
argument_list|)
decl_stmt|;
name|Task
argument_list|<
name|?
argument_list|>
name|createIndex
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|crtIndexDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|createIndex
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeDropIndex
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|indexName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|boolean
name|ifExists
init|=
operator|(
name|ast
operator|.
name|getFirstChildWithType
argument_list|(
name|HiveParser
operator|.
name|TOK_IFEXISTS
argument_list|)
operator|!=
literal|null
operator|)
decl_stmt|;
comment|// we want to signal an error if the index doesn't exist and we're
comment|// configured not to ignore this
name|boolean
name|throwException
init|=
operator|!
name|ifExists
operator|&&
operator|!
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|DROPIGNORESNONEXISTENT
argument_list|)
decl_stmt|;
name|Table
name|tbl
init|=
name|getTable
argument_list|(
name|tableName
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|throwException
operator|&&
name|tbl
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
try|try
block|{
name|Index
name|idx
init|=
name|db
operator|.
name|getIndex
argument_list|(
name|tableName
argument_list|,
name|indexName
argument_list|)
decl_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|NoSuchObjectException
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|GENERIC_ERROR
operator|.
name|getMsg
argument_list|(
literal|"dropping index"
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|throwException
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_INDEX
operator|.
name|getMsg
argument_list|(
name|indexName
argument_list|)
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|tbl
operator|!=
literal|null
condition|)
block|{
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tbl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DropIndexDesc
name|dropIdxDesc
init|=
operator|new
name|DropIndexDesc
argument_list|(
name|indexName
argument_list|,
name|tableName
argument_list|,
name|throwException
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|dropIdxDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterIndexRebuild
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
index|[]
name|qualified
init|=
name|getQualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|indexName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
name|Tree
name|part
init|=
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|part
operator|!=
literal|null
condition|)
block|{
name|partSpec
operator|=
name|extractPartitionSpecs
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Task
argument_list|<
name|?
argument_list|>
argument_list|>
name|indexBuilder
init|=
name|getIndexBuilderMapRed
argument_list|(
name|qualified
argument_list|,
name|indexName
argument_list|,
name|partSpec
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|addAll
argument_list|(
name|indexBuilder
argument_list|)
expr_stmt|;
comment|// Handle updating index timestamps
name|AlterIndexDesc
name|alterIdxDesc
init|=
operator|new
name|AlterIndexDesc
argument_list|(
name|AlterIndexTypes
operator|.
name|UPDATETIMESTAMP
argument_list|)
decl_stmt|;
name|alterIdxDesc
operator|.
name|setIndexName
argument_list|(
name|indexName
argument_list|)
expr_stmt|;
name|alterIdxDesc
operator|.
name|setBaseTableName
argument_list|(
name|getDotName
argument_list|(
name|qualified
argument_list|)
argument_list|)
expr_stmt|;
name|alterIdxDesc
operator|.
name|setSpec
argument_list|(
name|partSpec
argument_list|)
expr_stmt|;
name|Task
argument_list|<
name|?
argument_list|>
name|tsTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|alterIdxDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
for|for
control|(
name|Task
argument_list|<
name|?
argument_list|>
name|t
range|:
name|indexBuilder
control|)
block|{
name|t
operator|.
name|addDependentTask
argument_list|(
name|tsTask
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeAlterIndexProps
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
index|[]
name|qualified
init|=
name|getQualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|indexName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapProp
init|=
name|getProps
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|AlterIndexDesc
name|alterIdxDesc
init|=
operator|new
name|AlterIndexDesc
argument_list|(
name|AlterIndexTypes
operator|.
name|ADDPROPS
argument_list|)
decl_stmt|;
name|alterIdxDesc
operator|.
name|setProps
argument_list|(
name|mapProp
argument_list|)
expr_stmt|;
name|alterIdxDesc
operator|.
name|setIndexName
argument_list|(
name|indexName
argument_list|)
expr_stmt|;
name|alterIdxDesc
operator|.
name|setBaseTableName
argument_list|(
name|getDotName
argument_list|(
name|qualified
argument_list|)
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|alterIdxDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|List
argument_list|<
name|Task
argument_list|<
name|?
argument_list|>
argument_list|>
name|getIndexBuilderMapRed
parameter_list|(
name|String
index|[]
name|names
parameter_list|,
name|String
name|indexName
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
try|try
block|{
name|Index
name|index
init|=
name|db
operator|.
name|getIndex
argument_list|(
name|names
index|[
literal|0
index|]
argument_list|,
name|names
index|[
literal|1
index|]
argument_list|,
name|indexName
argument_list|)
decl_stmt|;
name|Table
name|indexTbl
init|=
literal|null
decl_stmt|;
name|String
name|indexTableName
init|=
name|index
operator|.
name|getIndexTableName
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexTableName
operator|!=
literal|null
condition|)
block|{
name|indexTbl
operator|=
name|getTable
argument_list|(
name|Utilities
operator|.
name|getDbTableName
argument_list|(
name|index
operator|.
name|getDbName
argument_list|()
argument_list|,
name|indexTableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Table
name|baseTbl
init|=
name|getTable
argument_list|(
operator|new
name|String
index|[]
block|{
name|index
operator|.
name|getDbName
argument_list|()
block|,
name|index
operator|.
name|getOrigTableName
argument_list|()
block|}
argument_list|)
decl_stmt|;
name|String
name|handlerCls
init|=
name|index
operator|.
name|getIndexHandlerClass
argument_list|()
decl_stmt|;
name|HiveIndexHandler
name|handler
init|=
name|HiveUtils
operator|.
name|getIndexHandler
argument_list|(
name|conf
argument_list|,
name|handlerCls
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Partition
argument_list|>
name|indexTblPartitions
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|Partition
argument_list|>
name|baseTblPartitions
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|indexTbl
operator|!=
literal|null
condition|)
block|{
name|indexTblPartitions
operator|=
operator|new
name|ArrayList
argument_list|<
name|Partition
argument_list|>
argument_list|()
expr_stmt|;
name|baseTblPartitions
operator|=
name|preparePartitions
argument_list|(
name|baseTbl
argument_list|,
name|partSpec
argument_list|,
name|indexTbl
argument_list|,
name|db
argument_list|,
name|indexTblPartitions
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Task
argument_list|<
name|?
argument_list|>
argument_list|>
name|ret
init|=
name|handler
operator|.
name|generateIndexBuildTaskList
argument_list|(
name|baseTbl
argument_list|,
name|index
argument_list|,
name|indexTblPartitions
argument_list|,
name|baseTblPartitions
argument_list|,
name|indexTbl
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|ret
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|Partition
argument_list|>
name|preparePartitions
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
name|baseTbl
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|,
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
name|indexTbl
parameter_list|,
name|Hive
name|db
parameter_list|,
name|List
argument_list|<
name|Partition
argument_list|>
name|indexTblPartitions
parameter_list|)
throws|throws
name|HiveException
throws|,
name|MetaException
block|{
name|List
argument_list|<
name|Partition
argument_list|>
name|baseTblPartitions
init|=
operator|new
name|ArrayList
argument_list|<
name|Partition
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|partSpec
operator|!=
literal|null
condition|)
block|{
comment|// if partspec is specified, then only producing index for that
comment|// partition
name|Partition
name|part
init|=
name|db
operator|.
name|getPartition
argument_list|(
name|baseTbl
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|part
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Partition "
operator|+
name|Warehouse
operator|.
name|makePartName
argument_list|(
name|partSpec
argument_list|,
literal|false
argument_list|)
operator|+
literal|" does not exist in table "
operator|+
name|baseTbl
operator|.
name|getTableName
argument_list|()
argument_list|)
throw|;
block|}
name|baseTblPartitions
operator|.
name|add
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|Partition
name|indexPart
init|=
name|db
operator|.
name|getPartition
argument_list|(
name|indexTbl
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexPart
operator|==
literal|null
condition|)
block|{
name|indexPart
operator|=
name|db
operator|.
name|createPartition
argument_list|(
name|indexTbl
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
name|indexTblPartitions
operator|.
name|add
argument_list|(
name|indexPart
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseTbl
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
comment|// if no partition is specified, create indexes for all partitions one
comment|// by one.
name|baseTblPartitions
operator|=
name|db
operator|.
name|getPartitions
argument_list|(
name|baseTbl
argument_list|)
expr_stmt|;
for|for
control|(
name|Partition
name|basePart
range|:
name|baseTblPartitions
control|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|pSpec
init|=
name|basePart
operator|.
name|getSpec
argument_list|()
decl_stmt|;
name|Partition
name|indexPart
init|=
name|db
operator|.
name|getPartition
argument_list|(
name|indexTbl
argument_list|,
name|pSpec
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexPart
operator|==
literal|null
condition|)
block|{
name|indexPart
operator|=
name|db
operator|.
name|createPartition
argument_list|(
name|indexTbl
argument_list|,
name|pSpec
argument_list|)
expr_stmt|;
block|}
name|indexTblPartitions
operator|.
name|add
argument_list|(
name|indexPart
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|baseTblPartitions
return|;
block|}
specifier|private
name|void
name|validateAlterTableType
parameter_list|(
name|Table
name|tbl
parameter_list|,
name|AlterTableTypes
name|op
parameter_list|)
throws|throws
name|SemanticException
block|{
name|validateAlterTableType
argument_list|(
name|tbl
argument_list|,
name|op
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|validateAlterTableType
parameter_list|(
name|Table
name|tbl
parameter_list|,
name|AlterTableTypes
name|op
parameter_list|,
name|boolean
name|expectView
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|tbl
operator|.
name|isView
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|expectView
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_COMMAND_FOR_VIEWS
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|ADDPARTITION
case|:
case|case
name|DROPPARTITION
case|:
case|case
name|RENAMEPARTITION
case|:
case|case
name|ADDPROPS
case|:
case|case
name|DROPPROPS
case|:
case|case
name|RENAME
case|:
comment|// allow this form
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_VIEW_DISALLOWED_OP
operator|.
name|getMsg
argument_list|(
name|op
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|expectView
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_COMMAND_FOR_TABLES
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|tbl
operator|.
name|isNonNative
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_TABLE_NON_NATIVE
operator|.
name|getMsg
argument_list|(
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|analyzeAlterTableProps
parameter_list|(
name|String
index|[]
name|qualified
parameter_list|,
name|ASTNode
name|ast
parameter_list|,
name|boolean
name|expectView
parameter_list|,
name|boolean
name|isUnset
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
name|getDotName
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapProp
init|=
name|getProps
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|AlterTableDesc
name|alterTblDesc
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isUnset
operator|==
literal|true
condition|)
block|{
name|alterTblDesc
operator|=
operator|new
name|AlterTableDesc
argument_list|(
name|AlterTableTypes
operator|.
name|DROPPROPS
argument_list|,
name|expectView
argument_list|)
expr_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|alterTblDesc
operator|.
name|setDropIfExists
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|alterTblDesc
operator|=
operator|new
name|AlterTableDesc
argument_list|(
name|AlterTableTypes
operator|.
name|ADDPROPS
argument_list|,
name|expectView
argument_list|)
expr_stmt|;
block|}
name|alterTblDesc
operator|.
name|setProps
argument_list|(
name|mapProp
argument_list|)
expr_stmt|;
name|alterTblDesc
operator|.
name|setOldName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|,
name|alterTblDesc
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableSerdeProps
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapProp
init|=
name|getProps
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|AlterTableTypes
operator|.
name|ADDSERDEPROPS
argument_list|)
decl_stmt|;
name|alterTblDesc
operator|.
name|setProps
argument_list|(
name|mapProp
argument_list|)
expr_stmt|;
name|alterTblDesc
operator|.
name|setOldName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|alterTblDesc
operator|.
name|setPartSpec
argument_list|(
name|partSpec
argument_list|)
expr_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|alterTblDesc
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableSerde
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|serdeName
init|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|AlterTableTypes
operator|.
name|ADDSERDE
argument_list|)
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapProp
init|=
name|getProps
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|alterTblDesc
operator|.
name|setProps
argument_list|(
name|mapProp
argument_list|)
expr_stmt|;
block|}
name|alterTblDesc
operator|.
name|setOldName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|alterTblDesc
operator|.
name|setSerdeName
argument_list|(
name|serdeName
argument_list|)
expr_stmt|;
name|alterTblDesc
operator|.
name|setPartSpec
argument_list|(
name|partSpec
argument_list|)
expr_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|alterTblDesc
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableFileFormat
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|StorageFormat
name|format
init|=
operator|new
name|StorageFormat
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|format
operator|.
name|fillStorageFormat
argument_list|(
name|child
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unknown token "
operator|+
name|child
operator|.
name|getText
argument_list|()
argument_list|)
throw|;
block|}
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|tableName
argument_list|,
name|format
operator|.
name|getInputFormat
argument_list|()
argument_list|,
name|format
operator|.
name|getOutputFormat
argument_list|()
argument_list|,
name|format
operator|.
name|getSerde
argument_list|()
argument_list|,
name|format
operator|.
name|getStorageHandler
argument_list|()
argument_list|,
name|partSpec
argument_list|)
decl_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|alterTblDesc
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addInputsOutputsAlterTable
parameter_list|(
name|String
name|tableName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addInputsOutputsAlterTable
parameter_list|(
name|String
name|tableName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|,
name|AlterTableDesc
name|desc
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|tableName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// Determine the lock type to acquire
name|WriteEntity
operator|.
name|WriteType
name|writeType
init|=
name|desc
operator|==
literal|null
condition|?
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_EXCLUSIVE
else|:
name|WriteEntity
operator|.
name|determineAlterTableWriteType
argument_list|(
name|desc
operator|.
name|getOp
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|partSpec
operator|==
literal|null
operator|||
name|partSpec
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|,
name|writeType
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ReadEntity
name|re
init|=
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
decl_stmt|;
comment|// In the case of altering a table for its partitions we don't need to lock the table
comment|// itself, just the partitions.  But the table will have a ReadEntity.  So mark that
comment|// ReadEntity as no lock.
name|re
operator|.
name|noLockNeeded
argument_list|()
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFullSpec
argument_list|(
name|tab
argument_list|,
name|partSpec
argument_list|)
condition|)
block|{
comment|// Fully specified partition spec
name|Partition
name|part
init|=
name|getPartition
argument_list|(
name|tab
argument_list|,
name|partSpec
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|part
argument_list|,
name|writeType
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Partial partition spec supplied. Make sure this is allowed.
if|if
condition|(
name|desc
operator|==
literal|null
operator|||
operator|!
name|AlterTableDesc
operator|.
name|doesAlterTableTypeSupportPartialPartitionSpec
argument_list|(
name|desc
operator|.
name|getOp
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_TABLE_TYPE_PARTIAL_PARTITION_SPEC_NO_SUPPORTED
argument_list|,
name|desc
operator|.
name|getOp
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONING
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|DYNAMIC_PARTITION_DISABLED
argument_list|)
throw|;
block|}
for|for
control|(
name|Partition
name|part
range|:
name|getPartitions
argument_list|(
name|tab
argument_list|,
name|partSpec
argument_list|,
literal|true
argument_list|)
control|)
block|{
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|part
argument_list|,
name|writeType
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|desc
operator|!=
literal|null
condition|)
block|{
name|validateAlterTableType
argument_list|(
name|tab
argument_list|,
name|desc
operator|.
name|getOp
argument_list|()
argument_list|,
name|desc
operator|.
name|getExpectView
argument_list|()
argument_list|)
expr_stmt|;
comment|// validate Unset Non Existed Table Properties
if|if
condition|(
name|desc
operator|.
name|getOp
argument_list|()
operator|==
name|AlterTableDesc
operator|.
name|AlterTableTypes
operator|.
name|DROPPROPS
operator|&&
name|desc
operator|.
name|getIsDropIfExists
argument_list|()
operator|==
literal|false
condition|)
block|{
name|Iterator
argument_list|<
name|String
argument_list|>
name|keyItr
init|=
name|desc
operator|.
name|getProps
argument_list|()
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|keyItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|currKey
init|=
name|keyItr
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|tab
operator|.
name|getTTable
argument_list|()
operator|.
name|getParameters
argument_list|()
operator|.
name|containsKey
argument_list|(
name|currKey
argument_list|)
operator|==
literal|false
condition|)
block|{
name|String
name|errorMsg
init|=
literal|"The following property "
operator|+
name|currKey
operator|+
literal|" does not exist in "
operator|+
name|tab
operator|.
name|getTableName
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_TBL_UNSET_NON_EXIST_PROPERTY
operator|.
name|getMsg
argument_list|(
name|errorMsg
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
block|}
block|}
specifier|private
name|void
name|analyzeAlterTableLocation
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|newLocation
init|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|addLocationToOutputs
argument_list|(
name|newLocation
argument_list|)
expr_stmt|;
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|tableName
argument_list|,
name|newLocation
argument_list|,
name|partSpec
argument_list|)
decl_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|alterTblDesc
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableProtectMode
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|AlterTableTypes
operator|.
name|ALTERPROTECTMODE
argument_list|)
decl_stmt|;
name|alterTblDesc
operator|.
name|setOldName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|alterTblDesc
operator|.
name|setPartSpec
argument_list|(
name|partSpec
argument_list|)
expr_stmt|;
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_ENABLE
case|:
name|alterTblDesc
operator|.
name|setProtectModeEnable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DISABLE
case|:
name|alterTblDesc
operator|.
name|setProtectModeEnable
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Set Protect mode Syntax parsing error."
argument_list|)
throw|;
block|}
name|ASTNode
name|grandChild
init|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|grandChild
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_OFFLINE
case|:
name|alterTblDesc
operator|.
name|setProtectModeType
argument_list|(
name|AlterTableDesc
operator|.
name|ProtectModeType
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_NO_DROP
case|:
if|if
condition|(
name|grandChild
operator|.
name|getChildCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|alterTblDesc
operator|.
name|setProtectModeType
argument_list|(
name|AlterTableDesc
operator|.
name|ProtectModeType
operator|.
name|NO_DROP_CASCADE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|alterTblDesc
operator|.
name|setProtectModeType
argument_list|(
name|AlterTableDesc
operator|.
name|ProtectModeType
operator|.
name|NO_DROP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_READONLY
case|:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Potect mode READONLY is not implemented"
argument_list|)
throw|;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Only protect mode NO_DROP or OFFLINE supported"
argument_list|)
throw|;
block|}
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|alterTblDesc
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTablePartMergeFiles
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|AlterTablePartMergeFilesDesc
name|mergeDesc
init|=
operator|new
name|AlterTablePartMergeFilesDesc
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|inputDir
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
name|Path
name|oldTblPartLoc
init|=
literal|null
decl_stmt|;
name|Path
name|newTblPartLoc
init|=
literal|null
decl_stmt|;
name|Table
name|tblObj
init|=
literal|null
decl_stmt|;
name|ListBucketingCtx
name|lbCtx
init|=
literal|null
decl_stmt|;
try|try
block|{
name|tblObj
operator|=
name|getTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|bucketCols
init|=
literal|null
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|InputFormat
argument_list|>
name|inputFormatClass
init|=
literal|null
decl_stmt|;
name|boolean
name|isArchived
init|=
literal|false
decl_stmt|;
name|boolean
name|checkIndex
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_CONCATENATE_CHECK_INDEX
argument_list|)
decl_stmt|;
if|if
condition|(
name|checkIndex
condition|)
block|{
name|List
argument_list|<
name|Index
argument_list|>
name|indexes
init|=
name|db
operator|.
name|getIndexes
argument_list|(
name|tblObj
operator|.
name|getDbName
argument_list|()
argument_list|,
name|tblObj
operator|.
name|getTableName
argument_list|()
argument_list|,
name|Short
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexes
operator|!=
literal|null
operator|&&
name|indexes
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"can not do merge because source table "
operator|+
name|tableName
operator|+
literal|" is indexed."
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|tblObj
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
if|if
condition|(
name|partSpec
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"source table "
operator|+
name|tableName
operator|+
literal|" is partitioned but no partition desc found."
argument_list|)
throw|;
block|}
else|else
block|{
name|Partition
name|part
init|=
name|getPartition
argument_list|(
name|tblObj
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|part
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"source table "
operator|+
name|tableName
operator|+
literal|" is partitioned but partition not found."
argument_list|)
throw|;
block|}
name|bucketCols
operator|=
name|part
operator|.
name|getBucketCols
argument_list|()
expr_stmt|;
name|inputFormatClass
operator|=
name|part
operator|.
name|getInputFormatClass
argument_list|()
expr_stmt|;
name|isArchived
operator|=
name|ArchiveUtils
operator|.
name|isArchived
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|Path
name|tabPath
init|=
name|tblObj
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|Path
name|partPath
init|=
name|part
operator|.
name|getDataLocation
argument_list|()
decl_stmt|;
comment|// if the table is in a different dfs than the partition,
comment|// replace the partition's dfs with the table's dfs.
name|newTblPartLoc
operator|=
operator|new
name|Path
argument_list|(
name|tabPath
operator|.
name|toUri
argument_list|()
operator|.
name|getScheme
argument_list|()
argument_list|,
name|tabPath
operator|.
name|toUri
argument_list|()
operator|.
name|getAuthority
argument_list|()
argument_list|,
name|partPath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|oldTblPartLoc
operator|=
name|partPath
expr_stmt|;
name|lbCtx
operator|=
name|constructListBucketingCtx
argument_list|(
name|part
operator|.
name|getSkewedColNames
argument_list|()
argument_list|,
name|part
operator|.
name|getSkewedColValues
argument_list|()
argument_list|,
name|part
operator|.
name|getSkewedColValueLocationMaps
argument_list|()
argument_list|,
name|part
operator|.
name|isStoredAsSubDirectories
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|inputFormatClass
operator|=
name|tblObj
operator|.
name|getInputFormatClass
argument_list|()
expr_stmt|;
name|bucketCols
operator|=
name|tblObj
operator|.
name|getBucketCols
argument_list|()
expr_stmt|;
comment|// input and output are the same
name|oldTblPartLoc
operator|=
name|tblObj
operator|.
name|getPath
argument_list|()
expr_stmt|;
name|newTblPartLoc
operator|=
name|tblObj
operator|.
name|getPath
argument_list|()
expr_stmt|;
name|lbCtx
operator|=
name|constructListBucketingCtx
argument_list|(
name|tblObj
operator|.
name|getSkewedColNames
argument_list|()
argument_list|,
name|tblObj
operator|.
name|getSkewedColValues
argument_list|()
argument_list|,
name|tblObj
operator|.
name|getSkewedColValueLocationMaps
argument_list|()
argument_list|,
name|tblObj
operator|.
name|isStoredAsSubDirectories
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|// throw a HiveException for other than rcfile and orcfile.
if|if
condition|(
operator|!
operator|(
operator|(
name|inputFormatClass
operator|.
name|equals
argument_list|(
name|RCFileInputFormat
operator|.
name|class
argument_list|)
operator|||
operator|(
name|inputFormatClass
operator|.
name|equals
argument_list|(
name|OrcInputFormat
operator|.
name|class
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Only RCFile and ORCFile Formats are supportted right now."
argument_list|)
throw|;
block|}
name|mergeDesc
operator|.
name|setInputFormatClass
argument_list|(
name|inputFormatClass
argument_list|)
expr_stmt|;
comment|// throw a HiveException if the table/partition is bucketized
if|if
condition|(
name|bucketCols
operator|!=
literal|null
operator|&&
name|bucketCols
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Merge can not perform on bucketized partition/table."
argument_list|)
throw|;
block|}
comment|// throw a HiveException if the table/partition is archived
if|if
condition|(
name|isArchived
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Merge can not perform on archived partitions."
argument_list|)
throw|;
block|}
name|inputDir
operator|.
name|add
argument_list|(
name|oldTblPartLoc
argument_list|)
expr_stmt|;
name|mergeDesc
operator|.
name|setInputDir
argument_list|(
name|inputDir
argument_list|)
expr_stmt|;
name|mergeDesc
operator|.
name|setLbCtx
argument_list|(
name|lbCtx
argument_list|)
expr_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
name|DDLWork
name|ddlWork
init|=
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|mergeDesc
argument_list|)
decl_stmt|;
name|ddlWork
operator|.
name|setNeedLock
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|mergeTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
name|ddlWork
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|TableDesc
name|tblDesc
init|=
name|Utilities
operator|.
name|getTableDesc
argument_list|(
name|tblObj
argument_list|)
decl_stmt|;
name|Path
name|queryTmpdir
init|=
name|ctx
operator|.
name|getExternalTmpPath
argument_list|(
name|newTblPartLoc
argument_list|)
decl_stmt|;
name|mergeDesc
operator|.
name|setOutputDir
argument_list|(
name|queryTmpdir
argument_list|)
expr_stmt|;
name|LoadTableDesc
name|ltd
init|=
operator|new
name|LoadTableDesc
argument_list|(
name|queryTmpdir
argument_list|,
name|tblDesc
argument_list|,
name|partSpec
operator|==
literal|null
condition|?
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
else|:
name|partSpec
argument_list|)
decl_stmt|;
name|ltd
operator|.
name|setLbCtx
argument_list|(
name|lbCtx
argument_list|)
expr_stmt|;
name|Task
argument_list|<
name|MoveWork
argument_list|>
name|moveTsk
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|MoveWork
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
name|ltd
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|mergeTask
operator|.
name|addDependentTask
argument_list|(
name|moveTsk
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESTATSAUTOGATHER
argument_list|)
condition|)
block|{
name|StatsWork
name|statDesc
decl_stmt|;
if|if
condition|(
name|oldTblPartLoc
operator|.
name|equals
argument_list|(
name|newTblPartLoc
argument_list|)
condition|)
block|{
comment|// If we're merging to the same location, we can avoid some metastore calls
name|tableSpec
name|tablepart
init|=
operator|new
name|tableSpec
argument_list|(
name|db
argument_list|,
name|conf
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
decl_stmt|;
name|statDesc
operator|=
operator|new
name|StatsWork
argument_list|(
name|tablepart
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|statDesc
operator|=
operator|new
name|StatsWork
argument_list|(
name|ltd
argument_list|)
expr_stmt|;
block|}
name|statDesc
operator|.
name|setNoStatsAggregator
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|statDesc
operator|.
name|setClearAggregatorStats
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|statDesc
operator|.
name|setStatsReliable
argument_list|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_STATS_RELIABLE
argument_list|)
argument_list|)
expr_stmt|;
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|statTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
name|statDesc
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|moveTsk
operator|.
name|addDependentTask
argument_list|(
name|statTask
argument_list|)
expr_stmt|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|mergeTask
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|analyzeAlterTableClusterSort
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
name|AlterTableDesc
name|alterTblDesc
decl_stmt|;
switch|switch
condition|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_NOT_CLUSTERED
case|:
name|alterTblDesc
operator|=
operator|new
name|AlterTableDesc
argument_list|(
name|tableName
argument_list|,
operator|-
literal|1
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|Order
argument_list|>
argument_list|()
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_NOT_SORTED
case|:
name|alterTblDesc
operator|=
operator|new
name|AlterTableDesc
argument_list|(
name|tableName
argument_list|,
literal|true
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERTABLE_BUCKETS
case|:
name|ASTNode
name|buckets
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|bucketCols
init|=
name|getColumnNames
argument_list|(
operator|(
name|ASTNode
operator|)
name|buckets
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Order
argument_list|>
name|sortCols
init|=
operator|new
name|ArrayList
argument_list|<
name|Order
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|numBuckets
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|buckets
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|numBuckets
operator|=
operator|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|buckets
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
operator|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|sortCols
operator|=
name|getColumnNamesOrder
argument_list|(
operator|(
name|ASTNode
operator|)
name|buckets
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|numBuckets
operator|=
operator|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|buckets
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
operator|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|numBuckets
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_BUCKET_NUMBER
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|alterTblDesc
operator|=
operator|new
name|AlterTableDesc
argument_list|(
name|tableName
argument_list|,
name|numBuckets
argument_list|,
name|bucketCols
argument_list|,
name|sortCols
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
specifier|private
name|void
name|analyzeAlterTableCompact
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|type
init|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|type
operator|.
name|equals
argument_list|(
literal|"minor"
argument_list|)
operator|&&
operator|!
name|type
operator|.
name|equals
argument_list|(
literal|"major"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COMPACTION_TYPE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|newPartSpec
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|partSpec
operator|!=
literal|null
condition|)
name|newPartSpec
operator|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|partSpec
argument_list|)
expr_stmt|;
name|AlterTableSimpleDesc
name|desc
init|=
operator|new
name|AlterTableSimpleDesc
argument_list|(
name|tableName
argument_list|,
name|newPartSpec
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|desc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|static
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getProps
parameter_list|(
name|ASTNode
name|prop
parameter_list|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapProp
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|readProps
argument_list|(
name|prop
argument_list|,
name|mapProp
argument_list|)
expr_stmt|;
return|return
name|mapProp
return|;
block|}
comment|/**    * Utility class to resolve QualifiedName    */
specifier|static
class|class
name|QualifiedNameUtil
block|{
comment|// delimiter to check DOT delimited qualified names
specifier|static
name|String
name|delimiter
init|=
literal|"\\."
decl_stmt|;
comment|/**      * Get the fully qualified name in the ast. e.g. the ast of the form ^(DOT      * ^(DOT a b) c) will generate a name of the form a.b.c      *      * @param ast      *          The AST from which the qualified name has to be extracted      * @return String      */
specifier|static
specifier|public
name|String
name|getFullyQualifiedName
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
block|{
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|ast
operator|.
name|getText
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
return|return
name|getFullyQualifiedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|+
literal|"."
operator|+
name|getFullyQualifiedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|3
condition|)
block|{
return|return
name|getFullyQualifiedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|+
literal|"."
operator|+
name|getFullyQualifiedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|+
literal|"."
operator|+
name|getFullyQualifiedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|// assume the first component of DOT delimited name is tableName
comment|// get the attemptTableName
specifier|static
specifier|public
name|String
name|getAttemptTableName
parameter_list|(
name|Hive
name|db
parameter_list|,
name|String
name|qualifiedName
parameter_list|,
name|boolean
name|isColumn
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// check whether the name starts with table
comment|// DESCRIBE table
comment|// DESCRIBE table.column
comment|// DECRIBE table column
name|String
name|tableName
init|=
name|qualifiedName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|qualifiedName
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
operator|==
operator|-
literal|1
condition|?
name|qualifiedName
operator|.
name|length
argument_list|()
else|:
name|qualifiedName
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|Table
name|tab
init|=
name|db
operator|.
name|getTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|isColumn
condition|)
block|{
comment|// if attempt to get columnPath
comment|// return the whole qualifiedName(table.column or table)
return|return
name|qualifiedName
return|;
block|}
else|else
block|{
comment|// if attempt to get tableName
comment|// return table
return|return
name|tableName
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InvalidTableException
name|e
parameter_list|)
block|{
comment|// assume the first DOT delimited component is tableName
comment|// OK if it is not
comment|// do nothing when having exception
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
comment|// get Database Name
specifier|static
specifier|public
name|String
name|getDBName
parameter_list|(
name|Hive
name|db
parameter_list|,
name|ASTNode
name|ast
parameter_list|)
block|{
name|String
name|dbName
init|=
literal|null
decl_stmt|;
name|String
name|fullyQualifiedName
init|=
name|getFullyQualifiedName
argument_list|(
name|ast
argument_list|)
decl_stmt|;
comment|// if database.table or database.table.column or table.column
comment|// first try the first component of the DOT separated name
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>=
literal|2
condition|)
block|{
name|dbName
operator|=
name|fullyQualifiedName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|fullyQualifiedName
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
operator|==
operator|-
literal|1
condition|?
name|fullyQualifiedName
operator|.
name|length
argument_list|()
else|:
name|fullyQualifiedName
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
comment|// if the database name is not valid
comment|// it is table.column
comment|// return null as dbName
if|if
condition|(
operator|!
name|db
operator|.
name|databaseExists
argument_list|(
name|dbName
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
comment|// in other cases, return null
comment|// database is not validated if null
return|return
literal|null
return|;
block|}
return|return
name|dbName
return|;
block|}
comment|// get Table Name
specifier|static
specifier|public
name|String
name|getTableName
parameter_list|(
name|Hive
name|db
parameter_list|,
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
literal|null
decl_stmt|;
name|String
name|fullyQualifiedName
init|=
name|getFullyQualifiedName
argument_list|(
name|ast
argument_list|)
decl_stmt|;
comment|// assume the first component of DOT delimited name is tableName
name|String
name|attemptTableName
init|=
name|getAttemptTableName
argument_list|(
name|db
argument_list|,
name|fullyQualifiedName
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|attemptTableName
operator|!=
literal|null
condition|)
block|{
return|return
name|attemptTableName
return|;
block|}
comment|// if the name does not start with table
comment|// it should start with database
comment|// DESCRIBE database.table
comment|// DESCRIBE database.table column
if|if
condition|(
name|fullyQualifiedName
operator|.
name|split
argument_list|(
name|delimiter
argument_list|)
operator|.
name|length
operator|==
literal|3
condition|)
block|{
comment|// if DESCRIBE database.table.column
comment|// invalid syntax exception
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE_OR_COLUMN
operator|.
name|getMsg
argument_list|(
name|fullyQualifiedName
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
comment|// if DESCRIBE database.table column
comment|// return database.table as tableName
name|tableName
operator|=
name|fullyQualifiedName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|fullyQualifiedName
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fullyQualifiedName
operator|.
name|split
argument_list|(
name|delimiter
argument_list|)
operator|.
name|length
operator|==
literal|2
condition|)
block|{
comment|// if DESCRIBE database.table
comment|// return database.table as tableName
name|tableName
operator|=
name|fullyQualifiedName
expr_stmt|;
block|}
else|else
block|{
comment|// if fullyQualifiedName only have one component
comment|// it is an invalid table
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|fullyQualifiedName
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|tableName
return|;
block|}
comment|// get column path
specifier|static
specifier|public
name|String
name|getColPath
parameter_list|(
name|Hive
name|db
parameter_list|,
name|ASTNode
name|parentAst
parameter_list|,
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// if parent has two children
comment|// it could be DESCRIBE table key
comment|// or DESCRIBE table partition
if|if
condition|(
name|parentAst
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
operator|&&
name|partSpec
operator|==
literal|null
condition|)
block|{
comment|// if partitionSpec is null
comment|// it is DESCRIBE table key
comment|// return table as columnPath
return|return
name|getFullyQualifiedName
argument_list|(
name|parentAst
argument_list|)
return|;
block|}
comment|// assume the first component of DOT delimited name is tableName
name|String
name|attemptTableName
init|=
name|getAttemptTableName
argument_list|(
name|db
argument_list|,
name|tableName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|attemptTableName
operator|!=
literal|null
condition|)
block|{
return|return
name|attemptTableName
return|;
block|}
comment|// if the name does not start with table
comment|// it should start with database
comment|// DESCRIBE database.table
comment|// DESCRIBE database.table column
if|if
condition|(
name|tableName
operator|.
name|split
argument_list|(
name|delimiter
argument_list|)
operator|.
name|length
operator|==
literal|3
condition|)
block|{
comment|// if DESCRIBE database.table column
comment|// return table.column as column path
return|return
name|tableName
operator|.
name|substring
argument_list|(
name|tableName
operator|.
name|indexOf
argument_list|(
literal|"."
argument_list|)
operator|+
literal|1
argument_list|,
name|tableName
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
comment|// in other cases, column path is the same as tableName
return|return
name|tableName
return|;
block|}
comment|// get partition metadata
specifier|static
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getPartitionSpec
parameter_list|(
name|Hive
name|db
parameter_list|,
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// if ast has two children
comment|// it could be DESCRIBE table key
comment|// or DESCRIBE table partition
comment|// check whether it is DESCRIBE table partition
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|ASTNode
name|partNode
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
try|try
block|{
name|partSpec
operator|=
name|getPartSpec
argument_list|(
name|partNode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|e
parameter_list|)
block|{
comment|// get exception in resolving partition
comment|// it could be DESCRIBE table key
comment|// return null
comment|// continue processing for DESCRIBE table key
return|return
literal|null
return|;
block|}
name|Table
name|tab
init|=
literal|null
decl_stmt|;
try|try
block|{
name|tab
operator|=
name|db
operator|.
name|getTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidTableException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|partSpec
operator|!=
literal|null
condition|)
block|{
name|Partition
name|part
init|=
literal|null
decl_stmt|;
try|try
block|{
name|part
operator|=
name|db
operator|.
name|getPartition
argument_list|(
name|tab
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
comment|// if get exception in finding partition
comment|// it could be DESCRIBE table key
comment|// return null
comment|// continue processing for DESCRIBE table key
return|return
literal|null
return|;
block|}
comment|// if partition is not found
comment|// it is DESCRIBE table partition
comment|// invalid partition exception
if|if
condition|(
name|part
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_PARTITION
operator|.
name|getMsg
argument_list|(
name|partSpec
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|// it is DESCRIBE table partition
comment|// return partition metadata
return|return
name|partSpec
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Create a FetchTask for a given thrift ddl schema.    *    * @param schema    *          thrift ddl    */
specifier|private
name|FetchTask
name|createFetchTask
parameter_list|(
name|String
name|schema
parameter_list|)
block|{
name|Properties
name|prop
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|prop
operator|.
name|setProperty
argument_list|(
name|serdeConstants
operator|.
name|SERIALIZATION_FORMAT
argument_list|,
literal|"9"
argument_list|)
expr_stmt|;
name|prop
operator|.
name|setProperty
argument_list|(
name|serdeConstants
operator|.
name|SERIALIZATION_NULL_FORMAT
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|String
index|[]
name|colTypes
init|=
name|schema
operator|.
name|split
argument_list|(
literal|"#"
argument_list|)
decl_stmt|;
name|prop
operator|.
name|setProperty
argument_list|(
literal|"columns"
argument_list|,
name|colTypes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|prop
operator|.
name|setProperty
argument_list|(
literal|"columns.types"
argument_list|,
name|colTypes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|prop
operator|.
name|setProperty
argument_list|(
name|serdeConstants
operator|.
name|SERIALIZATION_LIB
argument_list|,
name|LazySimpleSerDe
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|FetchWork
name|fetch
init|=
operator|new
name|FetchWork
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
operator|new
name|TableDesc
argument_list|(
name|TextInputFormat
operator|.
name|class
argument_list|,
name|IgnoreKeyTextOutputFormat
operator|.
name|class
argument_list|,
name|prop
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|fetch
operator|.
name|setSerializationNullFormat
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
return|return
operator|(
name|FetchTask
operator|)
name|TaskFactory
operator|.
name|get
argument_list|(
name|fetch
argument_list|,
name|conf
argument_list|)
return|;
block|}
specifier|private
name|void
name|validateDatabase
parameter_list|(
name|String
name|databaseName
parameter_list|)
throws|throws
name|SemanticException
block|{
try|try
block|{
if|if
condition|(
operator|!
name|db
operator|.
name|databaseExists
argument_list|(
name|databaseName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|DATABASE_NOT_EXISTS
operator|.
name|getMsg
argument_list|(
name|databaseName
argument_list|)
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|DATABASE_NOT_EXISTS
operator|.
name|getMsg
argument_list|(
name|databaseName
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|validateTable
parameter_list|(
name|String
name|tableName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|partSpec
operator|!=
literal|null
condition|)
block|{
name|getPartition
argument_list|(
name|tab
argument_list|,
name|partSpec
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeDescribeTable
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|tableTypeExpr
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|qualifiedName
init|=
name|QualifiedNameUtil
operator|.
name|getFullyQualifiedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|tableTypeExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|tableName
init|=
name|QualifiedNameUtil
operator|.
name|getTableName
argument_list|(
name|db
argument_list|,
call|(
name|ASTNode
call|)
argument_list|(
name|tableTypeExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|dbName
init|=
name|QualifiedNameUtil
operator|.
name|getDBName
argument_list|(
name|db
argument_list|,
call|(
name|ASTNode
call|)
argument_list|(
name|tableTypeExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
name|QualifiedNameUtil
operator|.
name|getPartitionSpec
argument_list|(
name|db
argument_list|,
name|tableTypeExpr
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
name|String
name|colPath
init|=
name|QualifiedNameUtil
operator|.
name|getColPath
argument_list|(
name|db
argument_list|,
name|tableTypeExpr
argument_list|,
operator|(
name|ASTNode
operator|)
name|tableTypeExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|qualifiedName
argument_list|,
name|partSpec
argument_list|)
decl_stmt|;
comment|// if database is not the one currently using
comment|// validate database
if|if
condition|(
name|dbName
operator|!=
literal|null
condition|)
block|{
name|validateDatabase
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|partSpec
operator|!=
literal|null
condition|)
block|{
name|validateTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
name|DescTableDesc
name|descTblDesc
init|=
operator|new
name|DescTableDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|colPath
argument_list|)
decl_stmt|;
name|boolean
name|showColStats
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|int
name|descOptions
init|=
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|descTblDesc
operator|.
name|setFormatted
argument_list|(
name|descOptions
operator|==
name|HiveParser
operator|.
name|KW_FORMATTED
argument_list|)
expr_stmt|;
name|descTblDesc
operator|.
name|setExt
argument_list|(
name|descOptions
operator|==
name|HiveParser
operator|.
name|KW_EXTENDED
argument_list|)
expr_stmt|;
name|descTblDesc
operator|.
name|setPretty
argument_list|(
name|descOptions
operator|==
name|HiveParser
operator|.
name|KW_PRETTY
argument_list|)
expr_stmt|;
comment|// in case of "DESCRIBE FORMATTED tablename column_name" statement, colPath
comment|// will contain tablename.column_name. If column_name is not specified
comment|// colPath will be equal to tableName. This is how we can differentiate
comment|// if we are describing a table or column
if|if
condition|(
operator|!
name|colPath
operator|.
name|equalsIgnoreCase
argument_list|(
name|tableName
argument_list|)
operator|&&
name|descTblDesc
operator|.
name|isFormatted
argument_list|()
condition|)
block|{
name|showColStats
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|getTable
argument_list|(
name|tableName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Task
name|ddlTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|descTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|ddlTask
argument_list|)
expr_stmt|;
name|String
name|schema
init|=
name|DescTableDesc
operator|.
name|getSchema
argument_list|(
name|showColStats
argument_list|)
decl_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|schema
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"analyzeDescribeTable done"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Describe database.    *    * @param ast    * @throws SemanticException    */
specifier|private
name|void
name|analyzeDescDatabase
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|boolean
name|isExtended
decl_stmt|;
name|String
name|dbName
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|dbName
operator|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|isExtended
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|dbName
operator|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|isExtended
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unexpected Tokens at DESCRIBE DATABASE"
argument_list|)
throw|;
block|}
name|DescDatabaseDesc
name|descDbDesc
init|=
operator|new
name|DescDatabaseDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|dbName
argument_list|,
name|isExtended
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|descDbDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|descDbDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getPartSpec
parameter_list|(
name|ASTNode
name|partspec
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|partspec
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partspec
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|partspec_val
init|=
operator|(
name|ASTNode
operator|)
name|partspec
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|key
init|=
name|partspec_val
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|String
name|val
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|partspec_val
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
name|val
operator|=
name|stripQuotes
argument_list|(
name|partspec_val
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|partSpec
operator|.
name|put
argument_list|(
name|key
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|partSpec
return|;
block|}
specifier|private
name|void
name|analyzeShowPartitions
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowPartitionsDesc
name|showPartsDesc
decl_stmt|;
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
init|=
name|getPartitionSpecs
argument_list|(
name|ast
argument_list|)
decl_stmt|;
comment|// We only can have a single partition spec
assert|assert
operator|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|<=
literal|1
operator|)
assert|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|partSpec
operator|=
name|partSpecs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|validateTable
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|showPartsDesc
operator|=
operator|new
name|ShowPartitionsDesc
argument_list|(
name|tableName
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|getTable
argument_list|(
name|tableName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showPartsDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showPartsDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowCreateTable
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowCreateTableDesc
name|showCreateTblDesc
decl_stmt|;
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|showCreateTblDesc
operator|=
operator|new
name|ShowCreateTableDesc
argument_list|(
name|tableName
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
operator|.
name|getTableType
argument_list|()
operator|==
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|TableType
operator|.
name|INDEX_TABLE
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|SHOW_CREATETABLE_INDEX
operator|.
name|getMsg
argument_list|(
name|tableName
operator|+
literal|" has table type INDEX_TABLE"
argument_list|)
argument_list|)
throw|;
block|}
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showCreateTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showCreateTblDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowDatabases
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowDatabasesDesc
name|showDatabasesDesc
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|String
name|databasePattern
init|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|showDatabasesDesc
operator|=
operator|new
name|ShowDatabasesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|databasePattern
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|showDatabasesDesc
operator|=
operator|new
name|ShowDatabasesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showDatabasesDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showDatabasesDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowTables
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowTablesDesc
name|showTblsDesc
decl_stmt|;
name|String
name|dbName
init|=
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getCurrentDatabase
argument_list|()
decl_stmt|;
name|String
name|tableNames
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|3
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|GENERIC_ERROR
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
comment|// Uses a pattern
name|tableNames
operator|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|showTblsDesc
operator|=
operator|new
name|ShowTablesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|dbName
argument_list|,
name|tableNames
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|// Specifies a DB
assert|assert
operator|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FROM
operator|)
assert|;
name|dbName
operator|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|validateDatabase
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|showTblsDesc
operator|=
operator|new
name|ShowTablesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|dbName
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|// Uses a pattern and specifies a DB
assert|assert
operator|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FROM
operator|)
assert|;
name|dbName
operator|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|tableNames
operator|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|validateDatabase
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|showTblsDesc
operator|=
operator|new
name|ShowTablesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|dbName
argument_list|,
name|tableNames
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// No pattern or DB
name|showTblsDesc
operator|=
operator|new
name|ShowTablesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|dbName
argument_list|)
expr_stmt|;
break|break;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showTblsDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showTblsDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowColumns
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|tableName
operator|.
name|contains
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Duplicates declaration for database name"
argument_list|)
throw|;
block|}
name|tableName
operator|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|+
literal|"."
operator|+
name|tableName
expr_stmt|;
block|}
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|ShowColumnsDesc
name|showColumnsDesc
init|=
operator|new
name|ShowColumnsDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showColumnsDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showColumnsDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowTableStatus
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowTableStatusDesc
name|showTblStatusDesc
decl_stmt|;
name|String
name|tableNames
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|dbName
init|=
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getCurrentDatabase
argument_list|()
decl_stmt|;
name|int
name|children
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|children
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|children
operator|>
literal|3
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|GENERIC_ERROR
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|children
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|Identifier
condition|)
block|{
name|dbName
operator|=
name|unescapeIdentifier
argument_list|(
name|child
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PARTSPEC
condition|)
block|{
name|partSpec
operator|=
name|getPartSpec
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|GENERIC_ERROR
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|partSpec
operator|!=
literal|null
condition|)
block|{
name|validateTable
argument_list|(
name|tableNames
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
name|showTblStatusDesc
operator|=
operator|new
name|ShowTableStatusDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|dbName
argument_list|,
name|tableNames
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showTblStatusDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showTblStatusDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowTableProperties
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowTblPropertiesDesc
name|showTblPropertiesDesc
decl_stmt|;
name|String
index|[]
name|qualified
init|=
name|getQualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|propertyName
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
name|propertyName
operator|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
name|tableNames
init|=
name|getDotName
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|validateTable
argument_list|(
name|tableNames
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|showTblPropertiesDesc
operator|=
operator|new
name|ShowTblPropertiesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|tableNames
argument_list|,
name|propertyName
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showTblPropertiesDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showTblPropertiesDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowIndexes
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowIndexesDesc
name|showIndexesDesc
decl_stmt|;
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|showIndexesDesc
operator|=
operator|new
name|ShowIndexesDesc
argument_list|(
name|tableName
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|int
name|descOptions
init|=
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|showIndexesDesc
operator|.
name|setFormatted
argument_list|(
name|descOptions
operator|==
name|HiveParser
operator|.
name|KW_FORMATTED
argument_list|)
expr_stmt|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showIndexesDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showIndexesDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the task according to the parsed command tree. This is used for the CLI    * command "SHOW FUNCTIONS;".    *    * @param ast    *          The parsed command tree.    * @throws SemanticException    *           Parsin failed    */
specifier|private
name|void
name|analyzeShowFunctions
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowFunctionsDesc
name|showFuncsDesc
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|String
name|funcNames
init|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|showFuncsDesc
operator|=
operator|new
name|ShowFunctionsDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|funcNames
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
assert|assert
operator|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|KW_LIKE
operator|)
assert|;
name|String
name|funcNames
init|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|showFuncsDesc
operator|=
operator|new
name|ShowFunctionsDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|funcNames
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|showFuncsDesc
operator|=
operator|new
name|ShowFunctionsDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showFuncsDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showFuncsDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the task according to the parsed command tree. This is used for the CLI    * command "SHOW LOCKS;".    *    * @param ast    *          The parsed command tree.    * @throws SemanticException    *           Parsing failed    */
specifier|private
name|void
name|analyzeShowLocks
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
literal|null
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
name|boolean
name|isExtended
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>=
literal|1
condition|)
block|{
comment|// table for which show locks is being executed
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABTYPE
condition|)
block|{
name|ASTNode
name|tableTypeExpr
init|=
name|child
decl_stmt|;
name|tableName
operator|=
name|QualifiedNameUtil
operator|.
name|getFullyQualifiedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|tableTypeExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// get partition metadata if partition specified
if|if
condition|(
name|tableTypeExpr
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|ASTNode
name|partspec
init|=
operator|(
name|ASTNode
operator|)
name|tableTypeExpr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|partSpec
operator|=
name|getPartSpec
argument_list|(
name|partspec
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|KW_EXTENDED
condition|)
block|{
name|isExtended
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
name|HiveTxnManager
name|txnManager
init|=
literal|null
decl_stmt|;
try|try
block|{
name|txnManager
operator|=
name|TxnManagerFactory
operator|.
name|getTxnManagerFactory
argument_list|()
operator|.
name|getTxnManager
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
name|ShowLocksDesc
name|showLocksDesc
init|=
operator|new
name|ShowLocksDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|isExtended
argument_list|,
name|txnManager
operator|.
name|useNewShowLocksFormat
argument_list|()
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showLocksDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showLocksDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Need to initialize the lock manager
name|ctx
operator|.
name|setNeedLockMgr
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add the task according to the parsed command tree. This is used for the CLI    * command "SHOW LOCKS DATABASE database [extended];".    *    * @param ast    *          The parsed command tree.    * @throws SemanticException    *           Parsing failed    */
specifier|private
name|void
name|analyzeShowDbLocks
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|boolean
name|isExtended
init|=
operator|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
operator|)
decl_stmt|;
name|String
name|dbName
init|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|HiveTxnManager
name|txnManager
init|=
literal|null
decl_stmt|;
try|try
block|{
name|txnManager
operator|=
name|TxnManagerFactory
operator|.
name|getTxnManagerFactory
argument_list|()
operator|.
name|getTxnManager
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
name|ShowLocksDesc
name|showLocksDesc
init|=
operator|new
name|ShowLocksDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|dbName
argument_list|,
name|isExtended
argument_list|,
name|txnManager
operator|.
name|useNewShowLocksFormat
argument_list|()
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showLocksDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showLocksDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Need to initialize the lock manager
name|ctx
operator|.
name|setNeedLockMgr
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowConf
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|confName
init|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|ShowConfDesc
name|showConfDesc
init|=
operator|new
name|ShowConfDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|confName
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showConfDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showConfDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the task according to the parsed command tree. This is used for the CLI    * command "LOCK TABLE ..;".    *    * @param ast    *          The parsed command tree.    * @throws SemanticException    *           Parsing failed    */
specifier|private
name|void
name|analyzeLockTable
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|String
name|mode
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toUpperCase
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
init|=
name|getPartitionSpecs
argument_list|(
name|ast
argument_list|)
decl_stmt|;
comment|// We only can have a single partition spec
assert|assert
operator|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|<=
literal|1
operator|)
assert|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|partSpec
operator|=
name|partSpecs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|LockTableDesc
name|lockTblDesc
init|=
operator|new
name|LockTableDesc
argument_list|(
name|tableName
argument_list|,
name|mode
argument_list|,
name|partSpec
argument_list|,
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVEQUERYID
argument_list|)
argument_list|)
decl_stmt|;
name|lockTblDesc
operator|.
name|setQueryStr
argument_list|(
name|this
operator|.
name|ctx
operator|.
name|getCmd
argument_list|()
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|lockTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
comment|// Need to initialize the lock manager
name|ctx
operator|.
name|setNeedLockMgr
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a task to execute "SHOW COMPACTIONS"    * @param ast The parsed command tree.    * @throws SemanticException Parsing failed.    */
specifier|private
name|void
name|analyzeShowCompactions
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowCompactionsDesc
name|desc
init|=
operator|new
name|ShowCompactionsDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|desc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|desc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a task to execute "SHOW COMPACTIONS"    * @param ast The parsed command tree.    * @throws SemanticException Parsing failed.    */
specifier|private
name|void
name|analyzeShowTxns
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowTxnsDesc
name|desc
init|=
operator|new
name|ShowTxnsDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|desc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|desc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the task according to the parsed command tree. This is used for the CLI    * command "UNLOCK TABLE ..;".    *    * @param ast    *          The parsed command tree.    * @throws SemanticException    *           Parsing failed    */
specifier|private
name|void
name|analyzeUnlockTable
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
init|=
name|getPartitionSpecs
argument_list|(
name|ast
argument_list|)
decl_stmt|;
comment|// We only can have a single partition spec
assert|assert
operator|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|<=
literal|1
operator|)
assert|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|partSpec
operator|=
name|partSpecs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|UnlockTableDesc
name|unlockTblDesc
init|=
operator|new
name|UnlockTableDesc
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|unlockTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
comment|// Need to initialize the lock manager
name|ctx
operator|.
name|setNeedLockMgr
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeLockDatabase
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|dbName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|mode
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toUpperCase
argument_list|()
argument_list|)
decl_stmt|;
comment|//inputs.add(new ReadEntity(dbName));
comment|//outputs.add(new WriteEntity(dbName));
name|LockDatabaseDesc
name|lockDatabaseDesc
init|=
operator|new
name|LockDatabaseDesc
argument_list|(
name|dbName
argument_list|,
name|mode
argument_list|,
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVEQUERYID
argument_list|)
argument_list|)
decl_stmt|;
name|lockDatabaseDesc
operator|.
name|setQueryStr
argument_list|(
name|ctx
operator|.
name|getCmd
argument_list|()
argument_list|)
expr_stmt|;
name|DDLWork
name|work
init|=
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|lockDatabaseDesc
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
name|work
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setNeedLockMgr
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeUnlockDatabase
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|dbName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|UnlockDatabaseDesc
name|unlockDatabaseDesc
init|=
operator|new
name|UnlockDatabaseDesc
argument_list|(
name|dbName
argument_list|)
decl_stmt|;
name|DDLWork
name|work
init|=
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|unlockDatabaseDesc
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
name|work
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
comment|// Need to initialize the lock manager
name|ctx
operator|.
name|setNeedLockMgr
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the task according to the parsed command tree. This is used for the CLI    * command "DESCRIBE FUNCTION;".    *    * @param ast    *          The parsed command tree.    * @throws SemanticException    *           Parsing failed    */
specifier|private
name|void
name|analyzeDescFunction
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|funcName
decl_stmt|;
name|boolean
name|isExtended
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|funcName
operator|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|isExtended
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|funcName
operator|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|isExtended
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unexpected Tokens at DESCRIBE FUNCTION"
argument_list|)
throw|;
block|}
name|DescFunctionDesc
name|descFuncDesc
init|=
operator|new
name|DescFunctionDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|funcName
argument_list|,
name|isExtended
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|descFuncDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|descFuncDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableRename
parameter_list|(
name|String
index|[]
name|source
parameter_list|,
name|ASTNode
name|ast
parameter_list|,
name|boolean
name|expectView
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
index|[]
name|target
init|=
name|getQualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|sourceName
init|=
name|getDotName
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|String
name|targetName
init|=
name|getDotName
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|sourceName
argument_list|,
name|targetName
argument_list|,
name|expectView
argument_list|)
decl_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|sourceName
argument_list|,
literal|null
argument_list|,
name|alterTblDesc
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableRenameCol
parameter_list|(
name|String
index|[]
name|qualified
parameter_list|,
name|ASTNode
name|ast
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|newComment
init|=
literal|null
decl_stmt|;
name|String
name|newType
init|=
literal|null
decl_stmt|;
name|newType
operator|=
name|getTypeStringFromAST
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|first
init|=
literal|false
decl_stmt|;
name|String
name|flagCol
init|=
literal|null
decl_stmt|;
name|ASTNode
name|positionNode
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|5
condition|)
block|{
name|newComment
operator|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|3
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|positionNode
operator|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|ast
operator|.
name|getChild
argument_list|(
literal|3
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|StringLiteral
condition|)
block|{
name|newComment
operator|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|3
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|positionNode
operator|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|positionNode
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|positionNode
operator|.
name|getChildCount
argument_list|()
operator|==
literal|0
condition|)
block|{
name|first
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|flagCol
operator|=
name|unescapeIdentifier
argument_list|(
name|positionNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|String
name|oldColName
init|=
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|String
name|newColName
init|=
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
comment|/* Validate the operation of renaming a column name. */
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|SkewedInfo
name|skewInfo
init|=
name|tab
operator|.
name|getTTable
argument_list|()
operator|.
name|getSd
argument_list|()
operator|.
name|getSkewedInfo
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
literal|null
operator|!=
name|skewInfo
operator|)
operator|&&
operator|(
literal|null
operator|!=
name|skewInfo
operator|.
name|getSkewedColNames
argument_list|()
operator|)
operator|&&
name|skewInfo
operator|.
name|getSkewedColNames
argument_list|()
operator|.
name|contains
argument_list|(
name|oldColName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|oldColName
operator|+
name|ErrorMsg
operator|.
name|ALTER_TABLE_NOT_ALLOWED_RENAME_SKEWED_COLUMN
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|String
name|tblName
init|=
name|getDotName
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|tblName
argument_list|,
name|partSpec
argument_list|,
name|unescapeIdentifier
argument_list|(
name|oldColName
argument_list|)
argument_list|,
name|unescapeIdentifier
argument_list|(
name|newColName
argument_list|)
argument_list|,
name|newType
argument_list|,
name|newComment
argument_list|,
name|first
argument_list|,
name|flagCol
argument_list|)
decl_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|tblName
argument_list|,
name|partSpec
argument_list|,
name|alterTblDesc
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableRenamePart
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tblName
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|oldPartSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|newPartSpec
init|=
name|extractPartitionSpecs
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|newPartSpec
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"RENAME PARTITION Missing Destination"
operator|+
name|ast
argument_list|)
throw|;
block|}
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|tblName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|validateAlterTableType
argument_list|(
name|tab
argument_list|,
name|AlterTableTypes
operator|.
name|RENAMEPARTITION
argument_list|)
expr_stmt|;
name|ReadEntity
name|re
init|=
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
decl_stmt|;
name|re
operator|.
name|noLockNeeded
argument_list|()
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
name|re
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
init|=
operator|new
name|ArrayList
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|partSpecs
operator|.
name|add
argument_list|(
name|oldPartSpec
argument_list|)
expr_stmt|;
name|partSpecs
operator|.
name|add
argument_list|(
name|newPartSpec
argument_list|)
expr_stmt|;
name|addTablePartsOutputs
argument_list|(
name|tab
argument_list|,
name|partSpecs
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_EXCLUSIVE
argument_list|)
expr_stmt|;
name|RenamePartitionDesc
name|renamePartitionDesc
init|=
operator|new
name|RenamePartitionDesc
argument_list|(
name|tblName
argument_list|,
name|oldPartSpec
argument_list|,
name|newPartSpec
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|renamePartitionDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableBucketNum
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tblName
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|tblName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
operator|.
name|getBucketCols
argument_list|()
operator|==
literal|null
operator|||
name|tab
operator|.
name|getBucketCols
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_BUCKETNUM_NONBUCKETIZED_TBL
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|validateAlterTableType
argument_list|(
name|tab
argument_list|,
name|AlterTableTypes
operator|.
name|ALTERBUCKETNUM
argument_list|)
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|bucketNum
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|AlterTableDesc
name|alterBucketNum
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|tblName
argument_list|,
name|partSpec
argument_list|,
name|bucketNum
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterBucketNum
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableModifyCols
parameter_list|(
name|String
index|[]
name|qualified
parameter_list|,
name|ASTNode
name|ast
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|,
name|AlterTableTypes
name|alterType
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tblName
init|=
name|getDotName
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|newCols
init|=
name|getColumns
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|tblName
argument_list|,
name|partSpec
argument_list|,
name|newCols
argument_list|,
name|alterType
argument_list|)
decl_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|tblName
argument_list|,
name|partSpec
argument_list|,
name|alterTblDesc
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableDropParts
parameter_list|(
name|String
index|[]
name|qualified
parameter_list|,
name|ASTNode
name|ast
parameter_list|,
name|boolean
name|expectView
parameter_list|)
throws|throws
name|SemanticException
block|{
name|boolean
name|ifExists
init|=
operator|(
name|ast
operator|.
name|getFirstChildWithType
argument_list|(
name|HiveParser
operator|.
name|TOK_IFEXISTS
argument_list|)
operator|!=
literal|null
operator|)
operator|||
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|DROPIGNORESNONEXISTENT
argument_list|)
decl_stmt|;
comment|// If the drop has to fail on non-existent partitions, we cannot batch expressions.
comment|// That is because we actually have to check each separate expression for existence.
comment|// We could do a small optimization for the case where expr has all columns and all
comment|// operators are equality, if we assume those would always match one partition (which
comment|// may not be true with legacy, non-normalized column values). This is probably a
comment|// popular case but that's kinda hacky. Let's not do it for now.
name|boolean
name|canGroupExprs
init|=
name|ifExists
decl_stmt|;
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|ExprNodeGenericFuncDesc
argument_list|>
argument_list|>
name|partSpecs
init|=
name|getFullPartitionSpecs
argument_list|(
name|ast
argument_list|,
name|tab
argument_list|,
name|canGroupExprs
argument_list|)
decl_stmt|;
if|if
condition|(
name|partSpecs
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|// nothing to do
name|validateAlterTableType
argument_list|(
name|tab
argument_list|,
name|AlterTableTypes
operator|.
name|DROPPARTITION
argument_list|,
name|expectView
argument_list|)
expr_stmt|;
name|ReadEntity
name|re
init|=
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
decl_stmt|;
name|re
operator|.
name|noLockNeeded
argument_list|()
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
name|re
argument_list|)
expr_stmt|;
name|boolean
name|ignoreProtection
init|=
name|ast
operator|.
name|getFirstChildWithType
argument_list|(
name|HiveParser
operator|.
name|TOK_IGNOREPROTECTION
argument_list|)
operator|!=
literal|null
decl_stmt|;
name|addTableDropPartsOutputs
argument_list|(
name|tab
argument_list|,
name|partSpecs
operator|.
name|values
argument_list|()
argument_list|,
operator|!
name|ifExists
argument_list|,
name|ignoreProtection
argument_list|)
expr_stmt|;
name|DropTableDesc
name|dropTblDesc
init|=
operator|new
name|DropTableDesc
argument_list|(
name|getDotName
argument_list|(
name|qualified
argument_list|)
argument_list|,
name|partSpecs
argument_list|,
name|expectView
argument_list|,
name|ignoreProtection
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|dropTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTablePartColType
parameter_list|(
name|String
index|[]
name|qualified
parameter_list|,
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// check if table exists.
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
comment|// validate the DDL is a valid operation on the table.
name|validateAlterTableType
argument_list|(
name|tab
argument_list|,
name|AlterTableTypes
operator|.
name|ALTERPARTITION
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Alter table ... partition column ( column newtype) only takes one column at a time.
comment|// It must have a column name followed with type.
name|ASTNode
name|colAst
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|colAst
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
operator|)
assert|;
name|FieldSchema
name|newCol
init|=
operator|new
name|FieldSchema
argument_list|()
decl_stmt|;
comment|// get column name
name|String
name|name
init|=
name|colAst
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|newCol
operator|.
name|setName
argument_list|(
name|unescapeIdentifier
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|// get column type
name|ASTNode
name|typeChild
init|=
call|(
name|ASTNode
call|)
argument_list|(
name|colAst
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|newCol
operator|.
name|setType
argument_list|(
name|getTypeStringFromAST
argument_list|(
name|typeChild
argument_list|)
argument_list|)
expr_stmt|;
comment|// check if column is defined or not
name|boolean
name|fFoundColumn
init|=
literal|false
decl_stmt|;
for|for
control|(
name|FieldSchema
name|col
range|:
name|tab
operator|.
name|getTTable
argument_list|()
operator|.
name|getPartitionKeys
argument_list|()
control|)
block|{
if|if
condition|(
name|col
operator|.
name|getName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|newCol
operator|.
name|getName
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fFoundColumn
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// raise error if we could not find the column
if|if
condition|(
operator|!
name|fFoundColumn
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|newCol
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|AlterTableAlterPartDesc
name|alterTblAlterPartDesc
init|=
operator|new
name|AlterTableAlterPartDesc
argument_list|(
name|getDotName
argument_list|(
name|qualified
argument_list|)
argument_list|,
name|newCol
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblAlterPartDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add one or more partitions to a table. Useful when the data has been copied    * to the right location by some other process.    *    * @param ast    *          The parsed command tree.    *    * @param expectView    *          True for ALTER VIEW, false for ALTER TABLE.    *    * @throws SemanticException    *           Parsing failed    */
specifier|private
name|void
name|analyzeAlterTableAddParts
parameter_list|(
name|String
index|[]
name|qualified
parameter_list|,
name|CommonTree
name|ast
parameter_list|,
name|boolean
name|expectView
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// ^(TOK_ALTERTABLE_ADDPARTS identifier ifNotExists? alterStatementSuffixAddPartitionsElement+)
name|boolean
name|ifNotExists
init|=
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_IFNOTEXISTS
decl_stmt|;
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|boolean
name|isView
init|=
name|tab
operator|.
name|isView
argument_list|()
decl_stmt|;
name|validateAlterTableType
argument_list|(
name|tab
argument_list|,
name|AlterTableTypes
operator|.
name|ADDPARTITION
argument_list|,
name|expectView
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_SHARED
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|numCh
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
name|int
name|start
init|=
name|ifNotExists
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|String
name|currentLocation
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|currentPart
init|=
literal|null
decl_stmt|;
comment|// Parser has done some verification, so the order of tokens doesn't need to be verified here.
name|AddPartitionDesc
name|addPartitionDesc
init|=
operator|new
name|AddPartitionDesc
argument_list|(
name|tab
operator|.
name|getDbName
argument_list|()
argument_list|,
name|tab
operator|.
name|getTableName
argument_list|()
argument_list|,
name|ifNotExists
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|num
init|=
name|start
init|;
name|num
operator|<
name|numCh
condition|;
name|num
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|num
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_PARTSPEC
case|:
if|if
condition|(
name|currentPart
operator|!=
literal|null
condition|)
block|{
name|addPartitionDesc
operator|.
name|addPartition
argument_list|(
name|currentPart
argument_list|,
name|currentLocation
argument_list|)
expr_stmt|;
name|currentLocation
operator|=
literal|null
expr_stmt|;
block|}
name|currentPart
operator|=
name|getPartSpec
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|validatePartitionValues
argument_list|(
name|currentPart
argument_list|)
expr_stmt|;
comment|// validate reserved values
name|validatePartSpec
argument_list|(
name|tab
argument_list|,
name|currentPart
argument_list|,
name|child
argument_list|,
name|conf
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_PARTITIONLOCATION
case|:
comment|// if location specified, set in partition
if|if
condition|(
name|isView
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"LOCATION clause illegal for view partition"
argument_list|)
throw|;
block|}
name|currentLocation
operator|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|isLocal
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// do best effort to determine if this is a local file
name|String
name|scheme
init|=
operator|new
name|URI
argument_list|(
name|currentLocation
argument_list|)
operator|.
name|getScheme
argument_list|()
decl_stmt|;
if|if
condition|(
name|scheme
operator|!=
literal|null
condition|)
block|{
name|isLocal
operator|=
name|FileUtils
operator|.
name|isLocalFile
argument_list|(
name|conf
argument_list|,
name|currentLocation
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to create URI from "
operator|+
name|currentLocation
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
operator|new
name|Path
argument_list|(
name|currentLocation
argument_list|)
argument_list|,
name|isLocal
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unknown child: "
operator|+
name|child
argument_list|)
throw|;
block|}
block|}
comment|// add the last one
if|if
condition|(
name|currentPart
operator|!=
literal|null
condition|)
block|{
name|addPartitionDesc
operator|.
name|addPartition
argument_list|(
name|currentPart
argument_list|,
name|currentLocation
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addPartitionDesc
operator|.
name|getPartitionCount
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// nothing to do
return|return;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|addPartitionDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isView
condition|)
block|{
comment|// Compile internal query to capture underlying table partition dependencies
name|StringBuilder
name|cmd
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|cmd
operator|.
name|append
argument_list|(
literal|"SELECT * FROM "
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|unparseIdentifier
argument_list|(
name|getDotName
argument_list|(
name|qualified
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|append
argument_list|(
literal|" WHERE "
argument_list|)
expr_stmt|;
name|boolean
name|firstOr
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|addPartitionDesc
operator|.
name|getPartitionCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|AddPartitionDesc
operator|.
name|OnePartitionDesc
name|partitionDesc
init|=
name|addPartitionDesc
operator|.
name|getPartition
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstOr
condition|)
block|{
name|firstOr
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|.
name|append
argument_list|(
literal|" OR "
argument_list|)
expr_stmt|;
block|}
name|boolean
name|firstAnd
init|=
literal|true
decl_stmt|;
name|cmd
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|partitionDesc
operator|.
name|getPartSpec
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|firstAnd
condition|)
block|{
name|firstAnd
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|.
name|append
argument_list|(
literal|" AND "
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|unparseIdentifier
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|append
argument_list|(
literal|" = '"
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|escapeString
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|Driver
name|driver
init|=
operator|new
name|Driver
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|int
name|rc
init|=
name|driver
operator|.
name|compile
argument_list|(
name|cmd
operator|.
name|toString
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NO_VALID_PARTN
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|inputs
operator|.
name|addAll
argument_list|(
name|driver
operator|.
name|getPlan
argument_list|()
operator|.
name|getInputs
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|Partition
name|getPartitionForOutput
parameter_list|(
name|Table
name|tab
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|currentPart
parameter_list|)
throws|throws
name|SemanticException
block|{
name|validatePartitionValues
argument_list|(
name|currentPart
argument_list|)
expr_stmt|;
try|try
block|{
name|Partition
name|partition
init|=
name|db
operator|.
name|getPartition
argument_list|(
name|tab
argument_list|,
name|currentPart
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|partition
operator|!=
literal|null
condition|)
block|{
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|partition
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|INSERT
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|partition
return|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"wrong partition spec "
operator|+
name|currentPart
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Rewrite the metadata for one or more partitions in a table. Useful when    * an external process modifies files on HDFS and you want the pre/post    * hooks to be fired for the specified partition.    *    * @param ast    *          The parsed command tree.    * @throws SemanticException    *           Parsing failed    */
specifier|private
name|void
name|analyzeAlterTableTouch
parameter_list|(
name|String
index|[]
name|qualified
parameter_list|,
name|CommonTree
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|validateAlterTableType
argument_list|(
name|tab
argument_list|,
name|AlterTableTypes
operator|.
name|TOUCH
argument_list|)
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
comment|// partition name to value
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
init|=
name|getPartitionSpecs
argument_list|(
name|ast
argument_list|)
decl_stmt|;
if|if
condition|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|AlterTableSimpleDesc
name|touchDesc
init|=
operator|new
name|AlterTableSimpleDesc
argument_list|(
name|getDotName
argument_list|(
name|qualified
argument_list|)
argument_list|,
literal|null
argument_list|,
name|AlterTableDesc
operator|.
name|AlterTableTypes
operator|.
name|TOUCH
argument_list|)
decl_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_NO_LOCK
argument_list|)
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|touchDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addTablePartsOutputs
argument_list|(
name|tab
argument_list|,
name|partSpecs
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_NO_LOCK
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
range|:
name|partSpecs
control|)
block|{
name|AlterTableSimpleDesc
name|touchDesc
init|=
operator|new
name|AlterTableSimpleDesc
argument_list|(
name|getDotName
argument_list|(
name|qualified
argument_list|)
argument_list|,
name|partSpec
argument_list|,
name|AlterTableDesc
operator|.
name|AlterTableTypes
operator|.
name|TOUCH
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|touchDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|analyzeAlterTableArchive
parameter_list|(
name|String
index|[]
name|qualified
parameter_list|,
name|CommonTree
name|ast
parameter_list|,
name|boolean
name|isUnArchive
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEARCHIVEENABLED
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ARCHIVE_METHODS_DISABLED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
comment|// partition name to value
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
init|=
name|getPartitionSpecs
argument_list|(
name|ast
argument_list|)
decl_stmt|;
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|addTablePartsOutputs
argument_list|(
name|tab
argument_list|,
name|partSpecs
argument_list|,
literal|true
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_NO_LOCK
argument_list|)
expr_stmt|;
name|validateAlterTableType
argument_list|(
name|tab
argument_list|,
name|AlterTableTypes
operator|.
name|ARCHIVE
argument_list|)
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|isUnArchive
condition|?
name|ErrorMsg
operator|.
name|UNARCHIVE_ON_MULI_PARTS
operator|.
name|getMsg
argument_list|()
else|:
name|ErrorMsg
operator|.
name|ARCHIVE_ON_MULI_PARTS
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ARCHIVE_ON_TABLE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
name|partSpecs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
try|try
block|{
name|isValidPrefixSpec
argument_list|(
name|tab
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|AlterTableSimpleDesc
name|archiveDesc
init|=
operator|new
name|AlterTableSimpleDesc
argument_list|(
name|getDotName
argument_list|(
name|qualified
argument_list|)
argument_list|,
name|partSpec
argument_list|,
operator|(
name|isUnArchive
condition|?
name|AlterTableTypes
operator|.
name|UNARCHIVE
else|:
name|AlterTableTypes
operator|.
name|ARCHIVE
operator|)
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|archiveDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Verify that the information in the metastore matches up with the data on    * the fs.    *    * @param ast    *          Query tree.    * @throws SemanticException    */
specifier|private
name|void
name|analyzeMetastoreCheck
parameter_list|(
name|CommonTree
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
literal|null
decl_stmt|;
name|boolean
name|repair
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|repair
operator|=
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|KW_REPAIR
expr_stmt|;
if|if
condition|(
operator|!
name|repair
condition|)
block|{
name|tableName
operator|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
name|tableName
operator|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|specs
init|=
name|getPartitionSpecs
argument_list|(
name|ast
argument_list|)
decl_stmt|;
name|MsckDesc
name|checkDesc
init|=
operator|new
name|MsckDesc
argument_list|(
name|tableName
argument_list|,
name|specs
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|repair
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|checkDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the partition specs from the tree.    *    * @param ast    *          Tree to extract partitions from.    * @return A list of partition name to value mappings.    * @throws SemanticException    */
specifier|private
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|getPartitionSpecs
parameter_list|(
name|CommonTree
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
init|=
operator|new
name|ArrayList
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|childIndex
init|=
literal|0
decl_stmt|;
comment|// get partition metadata if partition specified
for|for
control|(
name|childIndex
operator|=
literal|0
init|;
name|childIndex
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
name|childIndex
operator|++
control|)
block|{
name|Tree
name|partspec
init|=
name|ast
operator|.
name|getChild
argument_list|(
name|childIndex
argument_list|)
decl_stmt|;
comment|// sanity check
if|if
condition|(
name|partspec
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PARTSPEC
condition|)
block|{
name|partSpecs
operator|.
name|add
argument_list|(
name|getPartSpec
argument_list|(
operator|(
name|ASTNode
operator|)
name|partspec
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|partSpecs
return|;
block|}
comment|/**    * Get the partition specs from the tree. This stores the full specification    * with the comparator operator into the output list.    *    * @param ast Tree to extract partitions from.    * @param tab Table.    * @return    Map of partitions by prefix length. Most of the time prefix length will    *            be the same for all partition specs, so we can just OR the expressions.    */
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|ExprNodeGenericFuncDesc
argument_list|>
argument_list|>
name|getFullPartitionSpecs
parameter_list|(
name|CommonTree
name|ast
parameter_list|,
name|Table
name|tab
parameter_list|,
name|boolean
name|canGroupExprs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|colTypes
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldSchema
name|fs
range|:
name|tab
operator|.
name|getPartitionKeys
argument_list|()
control|)
block|{
name|colTypes
operator|.
name|put
argument_list|(
name|fs
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|fs
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|ExprNodeGenericFuncDesc
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|ExprNodeGenericFuncDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|childIndex
init|=
literal|0
init|;
name|childIndex
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
name|childIndex
operator|++
control|)
block|{
name|Tree
name|partSpecTree
init|=
name|ast
operator|.
name|getChild
argument_list|(
name|childIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|partSpecTree
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_PARTSPEC
condition|)
continue|continue;
name|ExprNodeGenericFuncDesc
name|expr
init|=
literal|null
decl_stmt|;
name|HashSet
argument_list|<
name|String
argument_list|>
name|names
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|partSpecTree
operator|.
name|getChildCount
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partSpecTree
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|CommonTree
name|partSpecSingleKey
init|=
operator|(
name|CommonTree
operator|)
name|partSpecTree
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|partSpecSingleKey
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PARTVAL
operator|)
assert|;
name|String
name|key
init|=
name|partSpecSingleKey
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|String
name|operator
init|=
name|partSpecSingleKey
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|String
name|val
init|=
name|stripQuotes
argument_list|(
name|partSpecSingleKey
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|type
init|=
name|colTypes
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Column "
operator|+
name|key
operator|+
literal|" not found"
argument_list|)
throw|;
block|}
comment|// Create the corresponding hive expression to filter on partition columns.
name|PrimitiveTypeInfo
name|pti
init|=
name|TypeInfoFactory
operator|.
name|getPrimitiveTypeInfo
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|Converter
name|converter
init|=
name|ObjectInspectorConverters
operator|.
name|getConverter
argument_list|(
name|TypeInfoUtils
operator|.
name|getStandardJavaObjectInspectorFromTypeInfo
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|)
argument_list|,
name|TypeInfoUtils
operator|.
name|getStandardJavaObjectInspectorFromTypeInfo
argument_list|(
name|pti
argument_list|)
argument_list|)
decl_stmt|;
name|ExprNodeColumnDesc
name|column
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|pti
argument_list|,
name|key
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|ExprNodeGenericFuncDesc
name|op
init|=
name|makeBinaryPredicate
argument_list|(
name|operator
argument_list|,
name|column
argument_list|,
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|pti
argument_list|,
name|converter
operator|.
name|convert
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|// If it's multi-expr filter (e.g. a='5', b='2012-01-02'), AND with previous exprs.
name|expr
operator|=
operator|(
name|expr
operator|==
literal|null
operator|)
condition|?
name|op
else|:
name|makeBinaryPredicate
argument_list|(
literal|"and"
argument_list|,
name|expr
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|names
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expr
operator|==
literal|null
condition|)
continue|continue;
comment|// We got the expr for one full partition spec. Determine the prefix length.
name|int
name|prefixLength
init|=
name|calculatePartPrefix
argument_list|(
name|tab
argument_list|,
name|names
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeGenericFuncDesc
argument_list|>
name|orExpr
init|=
name|result
operator|.
name|get
argument_list|(
name|prefixLength
argument_list|)
decl_stmt|;
comment|// We have to tell apart partitions resulting from spec with different prefix lengths.
comment|// So, if we already have smth for the same prefix length, we can OR the two.
comment|// If we don't, create a new separate filter. In most cases there will only be one.
if|if
condition|(
name|orExpr
operator|==
literal|null
condition|)
block|{
name|result
operator|.
name|put
argument_list|(
name|prefixLength
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|canGroupExprs
condition|)
block|{
name|orExpr
operator|.
name|set
argument_list|(
literal|0
argument_list|,
name|makeBinaryPredicate
argument_list|(
literal|"or"
argument_list|,
name|expr
argument_list|,
name|orExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|orExpr
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
specifier|private
specifier|static
name|ExprNodeGenericFuncDesc
name|makeBinaryPredicate
parameter_list|(
name|String
name|fn
parameter_list|,
name|ExprNodeDesc
name|left
parameter_list|,
name|ExprNodeDesc
name|right
parameter_list|)
block|{
return|return
operator|new
name|ExprNodeGenericFuncDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|booleanTypeInfo
argument_list|,
name|FunctionRegistry
operator|.
name|getFunctionInfo
argument_list|(
name|fn
argument_list|)
operator|.
name|getGenericUDF
argument_list|()
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Calculates the partition prefix length based on the drop spec.    * This is used to avoid deleting archived partitions with lower level.    * For example, if, for A and B key cols, drop spec is A=5, B=6, we shouldn't drop    * archived A=5/, because it can contain B-s other than 6.    * @param tbl Table    * @param partSpecKeys Keys present in drop partition spec.    */
specifier|private
name|int
name|calculatePartPrefix
parameter_list|(
name|Table
name|tbl
parameter_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
name|partSpecKeys
parameter_list|)
block|{
name|int
name|partPrefixToDrop
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FieldSchema
name|fs
range|:
name|tbl
operator|.
name|getPartCols
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|partSpecKeys
operator|.
name|contains
argument_list|(
name|fs
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
break|break;
operator|++
name|partPrefixToDrop
expr_stmt|;
block|}
return|return
name|partPrefixToDrop
return|;
block|}
comment|/**    * Certain partition values are are used by hive. e.g. the default partition    * in dynamic partitioning and the intermediate partition values used in the    * archiving process. Naturally, prohibit the user from creating partitions    * with these reserved values. The check that this function is more    * restrictive than the actual limitation, but it's simpler. Should be okay    * since the reserved names are fairly long and uncommon.    */
specifier|private
name|void
name|validatePartitionValues
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|e
range|:
name|partSpec
operator|.
name|entrySet
argument_list|()
control|)
block|{
for|for
control|(
name|String
name|s
range|:
name|reservedPartitionValues
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|contains
argument_list|(
name|s
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|RESERVED_PART_VAL
operator|.
name|getMsg
argument_list|(
literal|"(User value: "
operator|+
name|e
operator|.
name|getValue
argument_list|()
operator|+
literal|" Reserved substring: "
operator|+
name|s
operator|+
literal|")"
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**    * Add the table partitions to be modified in the output, so that it is available for the    * pre-execution hook. If the partition does not exist, no error is thrown.    */
specifier|private
name|void
name|addTablePartsOutputs
parameter_list|(
name|Table
name|table
parameter_list|,
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
parameter_list|,
name|WriteEntity
operator|.
name|WriteType
name|writeType
parameter_list|)
throws|throws
name|SemanticException
block|{
name|addTablePartsOutputs
argument_list|(
name|table
argument_list|,
name|partSpecs
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|writeType
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the table partitions to be modified in the output, so that it is available for the    * pre-execution hook. If the partition does not exist, no error is thrown.    */
specifier|private
name|void
name|addTablePartsOutputs
parameter_list|(
name|Table
name|table
parameter_list|,
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
parameter_list|,
name|boolean
name|allowMany
parameter_list|,
name|WriteEntity
operator|.
name|WriteType
name|writeType
parameter_list|)
throws|throws
name|SemanticException
block|{
name|addTablePartsOutputs
argument_list|(
name|table
argument_list|,
name|partSpecs
argument_list|,
literal|false
argument_list|,
name|allowMany
argument_list|,
literal|null
argument_list|,
name|writeType
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the table partitions to be modified in the output, so that it is available for the    * pre-execution hook. If the partition does not exist, throw an error if    * throwIfNonExistent is true, otherwise ignore it.    */
specifier|private
name|void
name|addTablePartsOutputs
parameter_list|(
name|Table
name|table
parameter_list|,
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
parameter_list|,
name|boolean
name|throwIfNonExistent
parameter_list|,
name|boolean
name|allowMany
parameter_list|,
name|ASTNode
name|ast
parameter_list|,
name|WriteEntity
operator|.
name|WriteType
name|writeType
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Iterator
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|i
decl_stmt|;
name|int
name|index
decl_stmt|;
for|for
control|(
name|i
operator|=
name|partSpecs
operator|.
name|iterator
argument_list|()
operator|,
name|index
operator|=
literal|1
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
operator|++
name|index
control|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Partition
argument_list|>
name|parts
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|allowMany
condition|)
block|{
try|try
block|{
name|parts
operator|=
name|db
operator|.
name|getPartitions
argument_list|(
name|table
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Got HiveException during obtaining list of partitions"
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|parts
operator|=
operator|new
name|ArrayList
argument_list|<
name|Partition
argument_list|>
argument_list|()
expr_stmt|;
try|try
block|{
name|Partition
name|p
init|=
name|db
operator|.
name|getPartition
argument_list|(
name|table
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|parts
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Wrong specification"
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|parts
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|throwIfNonExistent
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_PARTITION
operator|.
name|getMsg
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
name|index
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
block|}
for|for
control|(
name|Partition
name|p
range|:
name|parts
control|)
block|{
comment|// Don't request any locks here, as the table has already been locked.
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|p
argument_list|,
name|writeType
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Add the table partitions to be modified in the output, so that it is available for the    * pre-execution hook. If the partition does not exist, throw an error if    * throwIfNonExistent is true, otherwise ignore it.    */
specifier|private
name|void
name|addTableDropPartsOutputs
parameter_list|(
name|Table
name|tab
parameter_list|,
name|Collection
argument_list|<
name|List
argument_list|<
name|ExprNodeGenericFuncDesc
argument_list|>
argument_list|>
name|partSpecs
parameter_list|,
name|boolean
name|throwIfNonExistent
parameter_list|,
name|boolean
name|ignoreProtection
parameter_list|)
throws|throws
name|SemanticException
block|{
for|for
control|(
name|List
argument_list|<
name|ExprNodeGenericFuncDesc
argument_list|>
name|specs
range|:
name|partSpecs
control|)
block|{
for|for
control|(
name|ExprNodeGenericFuncDesc
name|partSpec
range|:
name|specs
control|)
block|{
name|List
argument_list|<
name|Partition
argument_list|>
name|parts
init|=
operator|new
name|ArrayList
argument_list|<
name|Partition
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|hasUnknown
init|=
literal|false
decl_stmt|;
try|try
block|{
name|hasUnknown
operator|=
name|db
operator|.
name|getPartitionsByExpr
argument_list|(
name|tab
argument_list|,
name|partSpec
argument_list|,
name|conf
argument_list|,
name|parts
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_PARTITION
operator|.
name|getMsg
argument_list|(
name|partSpec
operator|.
name|getExprString
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|hasUnknown
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unexpected unknown partitions for "
operator|+
name|partSpec
operator|.
name|getExprString
argument_list|()
argument_list|)
throw|;
block|}
comment|// TODO: ifExists could be moved to metastore. In fact it already supports that. Check it
comment|//       for now since we get parts for output anyway, so we can get the error message
comment|//       earlier... If we get rid of output, we can get rid of this.
if|if
condition|(
name|parts
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|throwIfNonExistent
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_PARTITION
operator|.
name|getMsg
argument_list|(
name|partSpec
operator|.
name|getExprString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
for|for
control|(
name|Partition
name|p
range|:
name|parts
control|)
block|{
comment|// TODO: same thing, metastore already checks this but check here if we can.
if|if
condition|(
operator|!
name|ignoreProtection
operator|&&
operator|!
name|p
operator|.
name|canDrop
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|DROP_COMMAND_NOT_ALLOWED_FOR_PARTITION
operator|.
name|getMsg
argument_list|(
name|p
operator|.
name|getCompleteName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|p
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_EXCLUSIVE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Analyze alter table's skewed table    *    * @param ast    *          node    * @throws SemanticException    */
specifier|private
name|void
name|analyzeAltertableSkewedby
parameter_list|(
name|String
index|[]
name|qualified
parameter_list|,
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|/**      * Throw an error if the user tries to use the DDL with      * hive.internal.ddl.list.bucketing.enable set to false.      */
name|HiveConf
name|hiveConf
init|=
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|Table
name|tab
init|=
name|getTable
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|,
name|WriteEntity
operator|.
name|WriteType
operator|.
name|DDL_EXCLUSIVE
argument_list|)
argument_list|)
expr_stmt|;
name|validateAlterTableType
argument_list|(
name|tab
argument_list|,
name|AlterTableTypes
operator|.
name|ADDSKEWEDBY
argument_list|)
expr_stmt|;
name|String
name|tableName
init|=
name|getDotName
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|/* Convert a skewed table to non-skewed table. */
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|tableName
argument_list|,
literal|true
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
name|alterTblDesc
operator|.
name|setStoredAsSubDirectories
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
operator|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABLESKEWED
case|:
name|handleAlterTableSkewedBy
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|tab
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_STOREDASDIRS
case|:
name|handleAlterTableDisableStoredAsDirs
argument_list|(
name|tableName
argument_list|,
name|tab
argument_list|)
expr_stmt|;
break|break;
default|default:
assert|assert
literal|false
assert|;
block|}
block|}
block|}
comment|/**    * Handle alter table<name> not stored as directories    *    * @param tableName    * @param tab    * @throws SemanticException    */
specifier|private
name|void
name|handleAlterTableDisableStoredAsDirs
parameter_list|(
name|String
name|tableName
parameter_list|,
name|Table
name|tab
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|skewedColNames
init|=
name|tab
operator|.
name|getSkewedColNames
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|skewedColValues
init|=
name|tab
operator|.
name|getSkewedColValues
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|skewedColNames
operator|==
literal|null
operator|)
operator|||
operator|(
name|skewedColNames
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|||
operator|(
name|skewedColValues
operator|==
literal|null
operator|)
operator|||
operator|(
name|skewedColValues
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_TBL_STOREDASDIR_NOT_SKEWED
operator|.
name|getMsg
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|tableName
argument_list|,
literal|false
argument_list|,
name|skewedColNames
argument_list|,
name|skewedColValues
argument_list|)
decl_stmt|;
name|alterTblDesc
operator|.
name|setStoredAsSubDirectories
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Process "alter table<name> skewed by .. on .. stored as directories    * @param ast    * @param tableName    * @param tab    * @throws SemanticException    */
specifier|private
name|void
name|handleAlterTableSkewedBy
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|Table
name|tab
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|skewedColNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|skewedValues
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/* skewed column names. */
name|ASTNode
name|skewedNode
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|skewedColNames
operator|=
name|analyzeSkewedTablDDLColNames
argument_list|(
name|skewedColNames
argument_list|,
name|skewedNode
argument_list|)
expr_stmt|;
comment|/* skewed value. */
name|analyzeDDLSkewedValues
argument_list|(
name|skewedValues
argument_list|,
name|skewedNode
argument_list|)
expr_stmt|;
comment|// stored as directories
name|boolean
name|storedAsDirs
init|=
name|analyzeStoredAdDirs
argument_list|(
name|skewedNode
argument_list|)
decl_stmt|;
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|tableName
argument_list|,
literal|false
argument_list|,
name|skewedColNames
argument_list|,
name|skewedValues
argument_list|)
decl_stmt|;
name|alterTblDesc
operator|.
name|setStoredAsSubDirectories
argument_list|(
name|storedAsDirs
argument_list|)
expr_stmt|;
comment|/**      * Validate information about skewed table      */
name|alterTblDesc
operator|.
name|setTable
argument_list|(
name|tab
argument_list|)
expr_stmt|;
name|alterTblDesc
operator|.
name|validate
argument_list|()
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Analyze skewed column names    *    * @param skewedColNames    * @param child    * @return    * @throws SemanticException    */
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|analyzeAlterTableSkewedColNames
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|skewedColNames
parameter_list|,
name|ASTNode
name|child
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Tree
name|nNode
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|nNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|SKEWED_TABLE_NO_COLUMN_NAME
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|ASTNode
name|nAstNode
init|=
operator|(
name|ASTNode
operator|)
name|nNode
decl_stmt|;
if|if
condition|(
name|nAstNode
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_TABCOLNAME
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|SKEWED_TABLE_NO_COLUMN_NAME
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|skewedColNames
operator|=
name|getColumnNames
argument_list|(
name|nAstNode
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|skewedColNames
return|;
block|}
comment|/**    * Given a ASTNode, return list of values.    *    * use case:    * create table xyz list bucketed (col1) with skew (1,2,5)    * AST Node is for (1,2,5)    *    * @param ast    * @return    */
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getColumnValues
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|colList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|numCh
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numCh
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|colList
operator|.
name|add
argument_list|(
name|stripQuotes
argument_list|(
name|child
operator|.
name|getText
argument_list|()
argument_list|)
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|colList
return|;
block|}
comment|/**    * Analyze alter table's skewed location    *    * @param ast    * @param tableName    * @param partSpec    * @throws SemanticException    */
specifier|private
name|void
name|analyzeAlterTableSkewedLocation
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|/**      * Throw an error if the user tries to use the DDL with      * hive.internal.ddl.list.bucketing.enable set to false.      */
name|HiveConf
name|hiveConf
init|=
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getConf
argument_list|()
decl_stmt|;
comment|/**      * Retrieve mappings from parser      */
name|Map
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|String
argument_list|>
name|locations
init|=
operator|new
name|HashMap
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|locNodes
init|=
name|ast
operator|.
name|getChildren
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|locNodes
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_TBL_SKEWED_LOC_NO_LOC
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
for|for
control|(
name|Node
name|locNode
range|:
name|locNodes
control|)
block|{
comment|// TOK_SKEWED_LOCATIONS
name|ASTNode
name|locAstNode
init|=
operator|(
name|ASTNode
operator|)
name|locNode
decl_stmt|;
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|locListNodes
init|=
name|locAstNode
operator|.
name|getChildren
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|locListNodes
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_TBL_SKEWED_LOC_NO_LOC
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
for|for
control|(
name|Node
name|locListNode
range|:
name|locListNodes
control|)
block|{
comment|// TOK_SKEWED_LOCATION_LIST
name|ASTNode
name|locListAstNode
init|=
operator|(
name|ASTNode
operator|)
name|locListNode
decl_stmt|;
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|locMapNodes
init|=
name|locListAstNode
operator|.
name|getChildren
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|locMapNodes
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_TBL_SKEWED_LOC_NO_LOC
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
for|for
control|(
name|Node
name|locMapNode
range|:
name|locMapNodes
control|)
block|{
comment|// TOK_SKEWED_LOCATION_MAP
name|ASTNode
name|locMapAstNode
init|=
operator|(
name|ASTNode
operator|)
name|locMapNode
decl_stmt|;
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|locMapAstNodeMaps
init|=
name|locMapAstNode
operator|.
name|getChildren
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
literal|null
operator|==
name|locMapAstNodeMaps
operator|)
operator|||
operator|(
name|locMapAstNodeMaps
operator|.
name|size
argument_list|()
operator|!=
literal|2
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_TBL_SKEWED_LOC_NO_MAP
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|List
argument_list|<
name|String
argument_list|>
name|keyList
init|=
operator|new
name|LinkedList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ASTNode
name|node
init|=
operator|(
name|ASTNode
operator|)
name|locMapAstNodeMaps
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABCOLVALUES
condition|)
block|{
name|keyList
operator|=
name|getSkewedValuesFromASTNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isConstant
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|keyList
operator|.
name|add
argument_list|(
name|PlanUtils
operator|.
name|stripQuotes
argument_list|(
name|node
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|SKEWED_TABLE_NO_COLUMN_VALUE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|String
name|newLocation
init|=
name|PlanUtils
operator|.
name|stripQuotes
argument_list|(
name|unescapeSQLString
argument_list|(
operator|(
operator|(
name|ASTNode
operator|)
name|locMapAstNodeMaps
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|validateSkewedLocationString
argument_list|(
name|newLocation
argument_list|)
expr_stmt|;
name|locations
operator|.
name|put
argument_list|(
name|keyList
argument_list|,
name|newLocation
argument_list|)
expr_stmt|;
name|addLocationToOutputs
argument_list|(
name|newLocation
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|tableName
argument_list|,
name|locations
argument_list|,
name|partSpec
argument_list|)
decl_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addLocationToOutputs
parameter_list|(
name|String
name|newLocation
parameter_list|)
block|{
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
operator|new
name|Path
argument_list|(
name|newLocation
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|isLocalFile
argument_list|(
name|conf
argument_list|,
name|newLocation
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check if the node is constant.    *    * @param node    * @return    */
specifier|private
name|boolean
name|isConstant
parameter_list|(
name|ASTNode
name|node
parameter_list|)
block|{
name|boolean
name|result
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|Number
case|:
name|result
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|StringLiteral
case|:
name|result
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|BigintLiteral
case|:
name|result
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|SmallintLiteral
case|:
name|result
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TinyintLiteral
case|:
name|result
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|DecimalLiteral
case|:
name|result
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|CharSetName
case|:
name|result
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|KW_TRUE
case|:
case|case
name|HiveParser
operator|.
name|KW_FALSE
case|:
name|result
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|result
return|;
block|}
specifier|private
name|void
name|validateSkewedLocationString
parameter_list|(
name|String
name|newLocation
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|/* Validate location string. */
try|try
block|{
name|URI
name|locUri
init|=
operator|new
name|URI
argument_list|(
name|newLocation
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|locUri
operator|.
name|isAbsolute
argument_list|()
operator|||
name|locUri
operator|.
name|getScheme
argument_list|()
operator|==
literal|null
operator|||
name|locUri
operator|.
name|getScheme
argument_list|()
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|newLocation
operator|+
literal|" is not absolute or has no scheme information. "
operator|+
literal|"Please specify a complete absolute uri with scheme information."
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

