begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveParser
operator|.
name|TOK_DATABASECOMMENT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveParser
operator|.
name|TOK_IFEXISTS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveParser
operator|.
name|TOK_IFNOTEXISTS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveParser
operator|.
name|TOK_SHOWDATABASES
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|CommonTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|Tree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|Warehouse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Index
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|MetaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Order
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|PrincipalType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|Driver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FetchTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Task
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TaskFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|ReadEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|WriteEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|index
operator|.
name|HiveIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|index
operator|.
name|HiveIndexHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|index
operator|.
name|HiveIndex
operator|.
name|IndexType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|IgnoreKeyTextOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|RCFileInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Hive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Partition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AddPartitionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AlterDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AlterIndexDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AlterTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AlterTableSimpleDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|CreateDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|CreateIndexDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|GrantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|GrantRevokeRoleDDL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PrincipalDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PrivilegeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PrivilegeObjectDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|RevokeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|RoleDDLDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DDLWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DescDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DescFunctionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DescTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DropDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DropIndexDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DropTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FetchWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|LockTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MsckDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ShowDatabasesDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ShowFunctionsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ShowGrantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ShowIndexesDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ShowLocksDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ShowPartitionsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ShowTableStatusDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ShowTablesDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|StatsWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|SwitchDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|UnlockTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AlterIndexDesc
operator|.
name|AlterIndexTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AlterTableDesc
operator|.
name|AlterTableTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|security
operator|.
name|authorization
operator|.
name|Privilege
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|security
operator|.
name|authorization
operator|.
name|PrivilegeRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|LazySimpleSerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|InputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TextInputFormat
import|;
end_import

begin_comment
comment|/**  * DDLSemanticAnalyzer.  *  */
end_comment

begin_class
specifier|public
class|class
name|DDLSemanticAnalyzer
extends|extends
name|BaseSemanticAnalyzer
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
literal|"hive.ql.parse.DDLSemanticAnalyzer"
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|TokenToTypeName
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|reservedPartitionValues
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_BOOLEAN
argument_list|,
name|Constants
operator|.
name|BOOLEAN_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_TINYINT
argument_list|,
name|Constants
operator|.
name|TINYINT_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_SMALLINT
argument_list|,
name|Constants
operator|.
name|SMALLINT_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_INT
argument_list|,
name|Constants
operator|.
name|INT_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_BIGINT
argument_list|,
name|Constants
operator|.
name|BIGINT_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_FLOAT
argument_list|,
name|Constants
operator|.
name|FLOAT_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_DOUBLE
argument_list|,
name|Constants
operator|.
name|DOUBLE_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_STRING
argument_list|,
name|Constants
operator|.
name|STRING_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_DATE
argument_list|,
name|Constants
operator|.
name|DATE_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_DATETIME
argument_list|,
name|Constants
operator|.
name|DATETIME_TYPE_NAME
argument_list|)
expr_stmt|;
name|TokenToTypeName
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_TIMESTAMP
argument_list|,
name|Constants
operator|.
name|TIMESTAMP_TYPE_NAME
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|String
name|getTypeName
parameter_list|(
name|int
name|token
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// date, datetime, and timestamp types aren't currently supported
if|if
condition|(
name|token
operator|==
name|HiveParser
operator|.
name|TOK_DATE
operator|||
name|token
operator|==
name|HiveParser
operator|.
name|TOK_DATETIME
operator|||
name|token
operator|==
name|HiveParser
operator|.
name|TOK_TIMESTAMP
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UNSUPPORTED_TYPE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|TokenToTypeName
operator|.
name|get
argument_list|(
name|token
argument_list|)
return|;
block|}
specifier|static
class|class
name|TablePartition
block|{
name|String
name|tableName
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
specifier|public
name|TablePartition
parameter_list|()
block|{     }
specifier|public
name|TablePartition
parameter_list|(
name|ASTNode
name|tblPart
parameter_list|)
throws|throws
name|SemanticException
block|{
name|tableName
operator|=
name|unescapeIdentifier
argument_list|(
name|tblPart
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|tblPart
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
name|ASTNode
name|part
init|=
operator|(
name|ASTNode
operator|)
name|tblPart
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|part
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PARTSPEC
condition|)
block|{
name|this
operator|.
name|partSpec
operator|=
name|DDLSemanticAnalyzer
operator|.
name|getPartSpec
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|public
name|DDLSemanticAnalyzer
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|SemanticException
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// Partition can't have this name
name|reservedPartitionValues
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|DEFAULTPARTITIONNAME
argument_list|)
argument_list|)
expr_stmt|;
name|reservedPartitionValues
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|DEFAULT_ZOOKEEPER_PARTITION_NAME
argument_list|)
argument_list|)
expr_stmt|;
comment|// Partition value can't end in this suffix
name|reservedPartitionValues
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|METASTORE_INT_ORIGINAL
argument_list|)
argument_list|)
expr_stmt|;
name|reservedPartitionValues
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|METASTORE_INT_ARCHIVED
argument_list|)
argument_list|)
expr_stmt|;
name|reservedPartitionValues
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|METASTORE_INT_EXTRACTED
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|analyzeInternal
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
switch|switch
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_ALTERTABLE_PARTITION
case|:
block|{
name|ASTNode
name|tablePart
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|TablePartition
name|tblPart
init|=
operator|new
name|TablePartition
argument_list|(
name|tablePart
argument_list|)
decl_stmt|;
name|String
name|tableName
init|=
name|tblPart
operator|.
name|tableName
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
name|tblPart
operator|.
name|partSpec
decl_stmt|;
name|ast
operator|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_FILEFORMAT
condition|)
block|{
name|analyzeAlterTableFileFormat
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_ALTERPARTS_PROTECTMODE
condition|)
block|{
name|analyzeAlterTableProtectMode
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_LOCATION
condition|)
block|{
name|analyzeAlterTableLocation
argument_list|(
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERTABLE_ALTERPARTS_MERGEFILES
condition|)
block|{
name|analyzeAlterTablePartMergeFiles
argument_list|(
name|tablePart
argument_list|,
name|ast
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|HiveParser
operator|.
name|TOK_DROPTABLE
case|:
name|analyzeDropTable
argument_list|(
name|ast
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_CREATEINDEX
case|:
name|analyzeCreateIndex
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DROPINDEX
case|:
name|analyzeDropIndex
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DESCTABLE
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
operator|new
name|Path
argument_list|(
name|ctx
operator|.
name|getLocalTmpFileURI
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|analyzeDescribeTable
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_SHOWDATABASES
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
operator|new
name|Path
argument_list|(
name|ctx
operator|.
name|getLocalTmpFileURI
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|analyzeShowDatabases
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOWTABLES
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
operator|new
name|Path
argument_list|(
name|ctx
operator|.
name|getLocalTmpFileURI
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|analyzeShowTables
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_TABLESTATUS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
operator|new
name|Path
argument_list|(
name|ctx
operator|.
name|getLocalTmpFileURI
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|analyzeShowTableStatus
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOWFUNCTIONS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
operator|new
name|Path
argument_list|(
name|ctx
operator|.
name|getLocalTmpFileURI
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|analyzeShowFunctions
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOWLOCKS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
operator|new
name|Path
argument_list|(
name|ctx
operator|.
name|getLocalTmpFileURI
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|analyzeShowLocks
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DESCFUNCTION
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
operator|new
name|Path
argument_list|(
name|ctx
operator|.
name|getLocalTmpFileURI
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|analyzeDescFunction
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DESCDATABASE
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
operator|new
name|Path
argument_list|(
name|ctx
operator|.
name|getLocalTmpFileURI
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|analyzeDescDatabase
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_MSCK
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
operator|new
name|Path
argument_list|(
name|ctx
operator|.
name|getLocalTmpFileURI
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|analyzeMetastoreCheck
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DROPVIEW
case|:
name|analyzeDropTable
argument_list|(
name|ast
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERVIEW_PROPERTIES
case|:
name|analyzeAlterTableProps
argument_list|(
name|ast
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERVIEW_ADDPARTS
case|:
comment|// for ALTER VIEW ADD PARTITION, we wrapped the ADD to discriminate
comment|// view from table; unwrap it now
name|analyzeAlterTableAddParts
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERVIEW_DROPPARTS
case|:
comment|// for ALTER VIEW DROP PARTITION, we wrapped the DROP to discriminate
comment|// view from table; unwrap it now
name|analyzeAlterTableDropParts
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERTABLE_RENAME
case|:
name|analyzeAlterTableRename
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERTABLE_TOUCH
case|:
name|analyzeAlterTableTouch
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERTABLE_ARCHIVE
case|:
name|analyzeAlterTableArchive
argument_list|(
name|ast
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERTABLE_UNARCHIVE
case|:
name|analyzeAlterTableArchive
argument_list|(
name|ast
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERTABLE_ADDCOLS
case|:
name|analyzeAlterTableModifyCols
argument_list|(
name|ast
argument_list|,
name|AlterTableTypes
operator|.
name|ADDCOLS
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERTABLE_REPLACECOLS
case|:
name|analyzeAlterTableModifyCols
argument_list|(
name|ast
argument_list|,
name|AlterTableTypes
operator|.
name|REPLACECOLS
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERTABLE_RENAMECOL
case|:
name|analyzeAlterTableRenameCol
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERTABLE_ADDPARTS
case|:
name|analyzeAlterTableAddParts
argument_list|(
name|ast
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERTABLE_DROPPARTS
case|:
name|analyzeAlterTableDropParts
argument_list|(
name|ast
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERTABLE_PROPERTIES
case|:
name|analyzeAlterTableProps
argument_list|(
name|ast
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERTABLE_SERDEPROPERTIES
case|:
name|analyzeAlterTableSerdeProps
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERTABLE_SERIALIZER
case|:
name|analyzeAlterTableSerde
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERTABLE_CLUSTER_SORT
case|:
name|analyzeAlterTableClusterSort
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERINDEX_REBUILD
case|:
name|analyzeAlterIndexRebuild
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERINDEX_PROPERTIES
case|:
name|analyzeAlterIndexProps
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOWPARTITIONS
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
operator|new
name|Path
argument_list|(
name|ctx
operator|.
name|getLocalTmpFileURI
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|analyzeShowPartitions
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOWINDEXES
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
operator|new
name|Path
argument_list|(
name|ctx
operator|.
name|getLocalTmpFileURI
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|analyzeShowIndexes
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_LOCKTABLE
case|:
name|analyzeLockTable
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_UNLOCKTABLE
case|:
name|analyzeUnlockTable
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_CREATEDATABASE
case|:
name|analyzeCreateDatabase
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DROPDATABASE
case|:
name|analyzeDropDatabase
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SWITCHDATABASE
case|:
name|analyzeSwitchDatabase
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ALTERDATABASE_PROPERTIES
case|:
name|analyzeAlterDatabase
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_CREATEROLE
case|:
name|analyzeCreateRole
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DROPROLE
case|:
name|analyzeDropRole
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_ROLE_GRANT
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
operator|new
name|Path
argument_list|(
name|ctx
operator|.
name|getLocalTmpFileURI
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|analyzeShowRoleGrant
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_GRANT_ROLE
case|:
name|analyzeGrantRevokeRole
argument_list|(
literal|true
argument_list|,
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_REVOKE_ROLE
case|:
name|analyzeGrantRevokeRole
argument_list|(
literal|false
argument_list|,
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_GRANT
case|:
name|analyzeGrant
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SHOW_GRANT
case|:
name|ctx
operator|.
name|setResFile
argument_list|(
operator|new
name|Path
argument_list|(
name|ctx
operator|.
name|getLocalTmpFileURI
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|analyzeShowGrant
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_REVOKE
case|:
name|analyzeRevoke
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unsupported command."
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|analyzeGrantRevokeRole
parameter_list|(
name|boolean
name|grant
parameter_list|,
name|ASTNode
name|ast
parameter_list|)
block|{
name|List
argument_list|<
name|PrincipalDesc
argument_list|>
name|principalDesc
init|=
name|analyzePrincipalListDef
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|roles
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|roles
operator|.
name|add
argument_list|(
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|String
name|roleOwnerName
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|SessionState
operator|.
name|get
argument_list|()
operator|!=
literal|null
operator|&&
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getAuthenticator
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|roleOwnerName
operator|=
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getAuthenticator
argument_list|()
operator|.
name|getUserName
argument_list|()
expr_stmt|;
block|}
name|GrantRevokeRoleDDL
name|grantRevokeRoleDDL
init|=
operator|new
name|GrantRevokeRoleDDL
argument_list|(
name|grant
argument_list|,
name|roles
argument_list|,
name|principalDesc
argument_list|,
name|roleOwnerName
argument_list|,
name|PrincipalType
operator|.
name|USER
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|grantRevokeRoleDDL
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowGrant
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|PrivilegeObjectDesc
name|privHiveObj
init|=
literal|null
decl_stmt|;
name|ASTNode
name|principal
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|PrincipalType
name|type
init|=
name|PrincipalType
operator|.
name|USER
decl_stmt|;
switch|switch
condition|(
name|principal
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_USER
case|:
name|type
operator|=
name|PrincipalType
operator|.
name|USER
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_GROUP
case|:
name|type
operator|=
name|PrincipalType
operator|.
name|GROUP
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ROLE
case|:
name|type
operator|=
name|PrincipalType
operator|.
name|ROLE
expr_stmt|;
break|break;
block|}
name|String
name|principalName
init|=
name|unescapeIdentifier
argument_list|(
name|principal
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|PrincipalDesc
name|principalDesc
init|=
operator|new
name|PrincipalDesc
argument_list|(
name|principalName
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|cols
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PRIV_OBJECT_COL
condition|)
block|{
name|privHiveObj
operator|=
operator|new
name|PrivilegeObjectDesc
argument_list|()
expr_stmt|;
name|privHiveObj
operator|.
name|setObject
argument_list|(
name|unescapeIdentifier
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|child
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|grandChild
init|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|grandChild
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PARTSPEC
condition|)
block|{
name|privHiveObj
operator|.
name|setPartSpec
argument_list|(
name|DDLSemanticAnalyzer
operator|.
name|getPartSpec
argument_list|(
name|grandChild
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|grandChild
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABCOLNAME
condition|)
block|{
name|cols
operator|=
name|getColumnNames
argument_list|(
operator|(
name|ASTNode
operator|)
name|grandChild
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|privHiveObj
operator|.
name|setTable
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|!=
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|privHiveObj
operator|==
literal|null
operator|&&
name|cols
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"For user-level privileges, column sets should be null. columns="
operator|+
name|cols
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|ShowGrantDesc
name|showGrant
init|=
operator|new
name|ShowGrantDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|principalDesc
argument_list|,
name|privHiveObj
argument_list|,
name|cols
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showGrant
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeGrant
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|PrivilegeDesc
argument_list|>
name|privilegeDesc
init|=
name|analyzePrivilegeListDef
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|PrincipalDesc
argument_list|>
name|principalDesc
init|=
name|analyzePrincipalListDef
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|boolean
name|grantOption
init|=
literal|false
decl_stmt|;
name|PrivilegeObjectDesc
name|privilegeObj
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|2
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|astChild
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|astChild
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_GRANT_WITH_OPTION
condition|)
block|{
name|grantOption
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|astChild
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PRIV_OBJECT
condition|)
block|{
name|privilegeObj
operator|=
name|analyzePrivilegeObject
argument_list|(
name|astChild
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|String
name|userName
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|SessionState
operator|.
name|get
argument_list|()
operator|!=
literal|null
operator|&&
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getAuthenticator
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|userName
operator|=
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getAuthenticator
argument_list|()
operator|.
name|getUserName
argument_list|()
expr_stmt|;
block|}
name|GrantDesc
name|grantDesc
init|=
operator|new
name|GrantDesc
argument_list|(
name|privilegeObj
argument_list|,
name|privilegeDesc
argument_list|,
name|principalDesc
argument_list|,
name|userName
argument_list|,
name|PrincipalType
operator|.
name|USER
argument_list|,
name|grantOption
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|grantDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeRevoke
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|PrivilegeDesc
argument_list|>
name|privilegeDesc
init|=
name|analyzePrivilegeListDef
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|PrincipalDesc
argument_list|>
name|principalDesc
init|=
name|analyzePrincipalListDef
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|PrivilegeObjectDesc
name|hiveObj
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|2
condition|)
block|{
name|ASTNode
name|astChild
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|hiveObj
operator|=
name|analyzePrivilegeObject
argument_list|(
name|astChild
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|RevokeDesc
name|revokeDesc
init|=
operator|new
name|RevokeDesc
argument_list|(
name|privilegeDesc
argument_list|,
name|principalDesc
argument_list|,
name|hiveObj
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|revokeDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|PrivilegeObjectDesc
name|analyzePrivilegeObject
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|HashSet
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|PrivilegeObjectDesc
name|subject
init|=
operator|new
name|PrivilegeObjectDesc
argument_list|()
decl_stmt|;
name|subject
operator|.
name|setObject
argument_list|(
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|astChild
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|astChild
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PARTSPEC
condition|)
block|{
name|subject
operator|.
name|setPartSpec
argument_list|(
name|DDLSemanticAnalyzer
operator|.
name|getPartSpec
argument_list|(
name|astChild
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|subject
operator|.
name|setTable
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|!=
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
try|try
block|{
if|if
condition|(
name|subject
operator|.
name|getTable
argument_list|()
condition|)
block|{
name|Table
name|tbl
init|=
name|db
operator|.
name|getTable
argument_list|(
name|subject
operator|.
name|getObject
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|subject
operator|.
name|getPartSpec
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Partition
name|part
init|=
name|db
operator|.
name|getPartition
argument_list|(
name|tbl
argument_list|,
name|subject
operator|.
name|getPartSpec
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|part
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tbl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|subject
return|;
block|}
specifier|private
name|List
argument_list|<
name|PrincipalDesc
argument_list|>
name|analyzePrincipalListDef
parameter_list|(
name|ASTNode
name|node
parameter_list|)
block|{
name|List
argument_list|<
name|PrincipalDesc
argument_list|>
name|principalList
init|=
operator|new
name|ArrayList
argument_list|<
name|PrincipalDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|node
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|node
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|PrincipalType
name|type
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|child
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_USER
case|:
name|type
operator|=
name|PrincipalType
operator|.
name|USER
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_GROUP
case|:
name|type
operator|=
name|PrincipalType
operator|.
name|GROUP
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ROLE
case|:
name|type
operator|=
name|PrincipalType
operator|.
name|ROLE
expr_stmt|;
break|break;
block|}
name|String
name|principalName
init|=
name|unescapeIdentifier
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|PrincipalDesc
name|principalDesc
init|=
operator|new
name|PrincipalDesc
argument_list|(
name|principalName
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|principalList
operator|.
name|add
argument_list|(
name|principalDesc
argument_list|)
expr_stmt|;
block|}
return|return
name|principalList
return|;
block|}
specifier|private
name|List
argument_list|<
name|PrivilegeDesc
argument_list|>
name|analyzePrivilegeListDef
parameter_list|(
name|ASTNode
name|node
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|PrivilegeDesc
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<
name|PrivilegeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|node
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|privilegeDef
init|=
operator|(
name|ASTNode
operator|)
name|node
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ASTNode
name|privilegeType
init|=
operator|(
name|ASTNode
operator|)
name|privilegeDef
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Privilege
name|privObj
init|=
name|PrivilegeRegistry
operator|.
name|getPrivilege
argument_list|(
name|privilegeType
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|privObj
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"undefined privilege "
operator|+
name|privilegeType
operator|.
name|getType
argument_list|()
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|cols
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|privilegeDef
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
name|cols
operator|=
name|getColumnNames
argument_list|(
operator|(
name|ASTNode
operator|)
name|privilegeDef
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PrivilegeDesc
name|privilegeDesc
init|=
operator|new
name|PrivilegeDesc
argument_list|(
name|privObj
argument_list|,
name|cols
argument_list|)
decl_stmt|;
name|ret
operator|.
name|add
argument_list|(
name|privilegeDesc
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
specifier|private
name|void
name|analyzeCreateRole
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
block|{
name|String
name|roleName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|RoleDDLDesc
name|createRoleDesc
init|=
operator|new
name|RoleDDLDesc
argument_list|(
name|roleName
argument_list|,
name|RoleDDLDesc
operator|.
name|RoleOperation
operator|.
name|CREATE_ROLE
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|createRoleDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeDropRole
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
block|{
name|String
name|roleName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|RoleDDLDesc
name|createRoleDesc
init|=
operator|new
name|RoleDDLDesc
argument_list|(
name|roleName
argument_list|,
name|RoleDDLDesc
operator|.
name|RoleOperation
operator|.
name|DROP_ROLE
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|createRoleDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowRoleGrant
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|PrincipalType
name|principalType
init|=
name|PrincipalType
operator|.
name|USER
decl_stmt|;
switch|switch
condition|(
name|child
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_USER
case|:
name|principalType
operator|=
name|PrincipalType
operator|.
name|USER
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_GROUP
case|:
name|principalType
operator|=
name|PrincipalType
operator|.
name|GROUP
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ROLE
case|:
name|principalType
operator|=
name|PrincipalType
operator|.
name|ROLE
expr_stmt|;
break|break;
block|}
name|String
name|principalName
init|=
name|unescapeIdentifier
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|RoleDDLDesc
name|createRoleDesc
init|=
operator|new
name|RoleDDLDesc
argument_list|(
name|principalName
argument_list|,
name|principalType
argument_list|,
name|RoleDDLDesc
operator|.
name|RoleOperation
operator|.
name|SHOW_ROLE_GRANT
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|createRoleDesc
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|createRoleDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterDatabase
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|dbName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|dbProps
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|childNode
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|childNode
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_DATABASEPROPERTIES
case|:
name|dbProps
operator|=
name|DDLSemanticAnalyzer
operator|.
name|getProps
argument_list|(
operator|(
name|ASTNode
operator|)
name|childNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unrecognized token in CREATE DATABASE statement"
argument_list|)
throw|;
block|}
block|}
comment|// currently alter database command can only change properties
name|AlterDatabaseDesc
name|alterDesc
init|=
operator|new
name|AlterDatabaseDesc
argument_list|(
name|dbName
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|alterDesc
operator|.
name|setDatabaseProperties
argument_list|(
name|dbProps
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeCreateDatabase
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|dbName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|ifNotExists
init|=
literal|false
decl_stmt|;
name|String
name|dbComment
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|dbProps
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|childNode
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|childNode
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|TOK_IFNOTEXISTS
case|:
name|ifNotExists
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|TOK_DATABASECOMMENT
case|:
name|dbComment
operator|=
name|unescapeSQLString
argument_list|(
name|childNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DATABASEPROPERTIES
case|:
name|dbProps
operator|=
name|DDLSemanticAnalyzer
operator|.
name|getProps
argument_list|(
operator|(
name|ASTNode
operator|)
name|childNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unrecognized token in CREATE DATABASE statement"
argument_list|)
throw|;
block|}
block|}
name|CreateDatabaseDesc
name|createDatabaseDesc
init|=
operator|new
name|CreateDatabaseDesc
argument_list|()
decl_stmt|;
name|createDatabaseDesc
operator|.
name|setName
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|createDatabaseDesc
operator|.
name|setComment
argument_list|(
name|dbComment
argument_list|)
expr_stmt|;
name|createDatabaseDesc
operator|.
name|setIfNotExists
argument_list|(
name|ifNotExists
argument_list|)
expr_stmt|;
name|createDatabaseDesc
operator|.
name|setLocationUri
argument_list|(
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbProps
operator|!=
literal|null
condition|)
block|{
name|createDatabaseDesc
operator|.
name|setDatabaseProperties
argument_list|(
name|dbProps
argument_list|)
expr_stmt|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|createDatabaseDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeDropDatabase
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|dbName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|ifExists
init|=
literal|false
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|ast
operator|.
name|getFirstChildWithType
argument_list|(
name|TOK_IFEXISTS
argument_list|)
condition|)
block|{
name|ifExists
operator|=
literal|true
expr_stmt|;
block|}
name|DropDatabaseDesc
name|dropDatabaseDesc
init|=
operator|new
name|DropDatabaseDesc
argument_list|(
name|dbName
argument_list|,
name|ifExists
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|dropDatabaseDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeSwitchDatabase
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
block|{
name|String
name|dbName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|SwitchDatabaseDesc
name|switchDatabaseDesc
init|=
operator|new
name|SwitchDatabaseDesc
argument_list|(
name|dbName
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|switchDatabaseDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeDropTable
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|boolean
name|expectView
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|boolean
name|ifExists
init|=
operator|(
name|ast
operator|.
name|getFirstChildWithType
argument_list|(
name|TOK_IFEXISTS
argument_list|)
operator|!=
literal|null
operator|)
decl_stmt|;
comment|// we want to signal an error if the table/view doesn't exist and we're
comment|// configured not to fail silently
name|boolean
name|throwException
init|=
operator|!
name|ifExists
operator|&&
operator|!
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|DROPIGNORESNONEXISTENT
argument_list|)
decl_stmt|;
try|try
block|{
name|Table
name|tab
init|=
name|db
operator|.
name|getTable
argument_list|(
name|db
operator|.
name|getCurrentDatabase
argument_list|()
argument_list|,
name|tableName
argument_list|,
name|throwException
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
operator|!=
literal|null
condition|)
block|{
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
name|DropTableDesc
name|dropTblDesc
init|=
operator|new
name|DropTableDesc
argument_list|(
name|tableName
argument_list|,
name|expectView
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|dropTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeCreateIndex
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|indexName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|typeName
init|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|indexedCols
init|=
name|getColumnNames
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|3
argument_list|)
argument_list|)
decl_stmt|;
name|IndexType
name|indexType
init|=
name|HiveIndex
operator|.
name|getIndexType
argument_list|(
name|typeName
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexType
operator|!=
literal|null
condition|)
block|{
name|typeName
operator|=
name|indexType
operator|.
name|getHandlerClsName
argument_list|()
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|Class
operator|.
name|forName
argument_list|(
name|typeName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"class name provided for index handler not found."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|String
name|indexTableName
init|=
literal|null
decl_stmt|;
name|boolean
name|deferredRebuild
init|=
literal|false
decl_stmt|;
name|String
name|location
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|tblProps
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|idxProps
init|=
literal|null
decl_stmt|;
name|String
name|indexComment
init|=
literal|null
decl_stmt|;
name|RowFormatParams
name|rowFormatParams
init|=
operator|new
name|RowFormatParams
argument_list|()
decl_stmt|;
name|StorageFormat
name|storageFormat
init|=
operator|new
name|StorageFormat
argument_list|()
decl_stmt|;
name|AnalyzeCreateCommonVars
name|shared
init|=
operator|new
name|AnalyzeCreateCommonVars
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|4
init|;
name|idx
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|storageFormat
operator|.
name|fillStorageFormat
argument_list|(
name|child
argument_list|,
name|shared
argument_list|)
condition|)
block|{
continue|continue;
block|}
switch|switch
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMAT
case|:
name|rowFormatParams
operator|.
name|analyzeRowFormat
argument_list|(
name|shared
argument_list|,
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_CREATEINDEX_INDEXTBLNAME
case|:
name|ASTNode
name|ch
init|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|indexTableName
operator|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DEFERRED_REBUILDINDEX
case|:
name|deferredRebuild
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLELOCATION
case|:
name|location
operator|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEPROPERTIES
case|:
name|tblProps
operator|=
name|DDLSemanticAnalyzer
operator|.
name|getProps
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_INDEXPROPERTIES
case|:
name|idxProps
operator|=
name|DDLSemanticAnalyzer
operator|.
name|getProps
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLESERIALIZER
case|:
name|child
operator|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|shared
operator|.
name|serde
operator|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|readProps
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|shared
operator|.
name|serdeProps
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_INDEXCOMMENT
case|:
name|child
operator|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|indexComment
operator|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|storageFormat
operator|.
name|fillDefaultStorageFormat
argument_list|(
name|shared
argument_list|)
expr_stmt|;
name|CreateIndexDesc
name|crtIndexDesc
init|=
operator|new
name|CreateIndexDesc
argument_list|(
name|tableName
argument_list|,
name|indexName
argument_list|,
name|indexedCols
argument_list|,
name|indexTableName
argument_list|,
name|deferredRebuild
argument_list|,
name|storageFormat
operator|.
name|inputFormat
argument_list|,
name|storageFormat
operator|.
name|outputFormat
argument_list|,
name|storageFormat
operator|.
name|storageHandler
argument_list|,
name|typeName
argument_list|,
name|location
argument_list|,
name|idxProps
argument_list|,
name|tblProps
argument_list|,
name|shared
operator|.
name|serde
argument_list|,
name|shared
operator|.
name|serdeProps
argument_list|,
name|rowFormatParams
operator|.
name|collItemDelim
argument_list|,
name|rowFormatParams
operator|.
name|fieldDelim
argument_list|,
name|rowFormatParams
operator|.
name|fieldEscape
argument_list|,
name|rowFormatParams
operator|.
name|lineDelim
argument_list|,
name|rowFormatParams
operator|.
name|mapKeyDelim
argument_list|,
name|indexComment
argument_list|)
decl_stmt|;
name|Task
argument_list|<
name|?
argument_list|>
name|createIndex
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|crtIndexDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|createIndex
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeDropIndex
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|indexName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|boolean
name|ifExists
init|=
operator|(
name|ast
operator|.
name|getFirstChildWithType
argument_list|(
name|TOK_IFEXISTS
argument_list|)
operator|!=
literal|null
operator|)
decl_stmt|;
comment|// we want to signal an error if the index doesn't exist and we're
comment|// configured not to ignore this
name|boolean
name|throwException
init|=
operator|!
name|ifExists
operator|&&
operator|!
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|DROPIGNORESNONEXISTENT
argument_list|)
decl_stmt|;
if|if
condition|(
name|throwException
condition|)
block|{
try|try
block|{
name|Index
name|idx
init|=
name|db
operator|.
name|getIndex
argument_list|(
name|tableName
argument_list|,
name|indexName
argument_list|)
decl_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_INDEX
operator|.
name|getMsg
argument_list|(
name|indexName
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|DropIndexDesc
name|dropIdxDesc
init|=
operator|new
name|DropIndexDesc
argument_list|(
name|indexName
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|dropIdxDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterIndexRebuild
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|baseTableName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|indexName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
name|Tree
name|part
init|=
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|part
operator|!=
literal|null
condition|)
block|{
name|partSpec
operator|=
name|extractPartitionSpecs
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Task
argument_list|<
name|?
argument_list|>
argument_list|>
name|indexBuilder
init|=
name|getIndexBuilderMapRed
argument_list|(
name|baseTableName
argument_list|,
name|indexName
argument_list|,
name|partSpec
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|addAll
argument_list|(
name|indexBuilder
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterIndexProps
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|baseTableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|indexName
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapProp
init|=
name|getProps
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|AlterIndexDesc
name|alterIdxDesc
init|=
operator|new
name|AlterIndexDesc
argument_list|(
name|AlterIndexTypes
operator|.
name|ADDPROPS
argument_list|)
decl_stmt|;
name|alterIdxDesc
operator|.
name|setProps
argument_list|(
name|mapProp
argument_list|)
expr_stmt|;
name|alterIdxDesc
operator|.
name|setIndexName
argument_list|(
name|indexName
argument_list|)
expr_stmt|;
name|alterIdxDesc
operator|.
name|setBaseTableName
argument_list|(
name|baseTableName
argument_list|)
expr_stmt|;
name|alterIdxDesc
operator|.
name|setDbName
argument_list|(
name|db
operator|.
name|getCurrentDatabase
argument_list|()
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|alterIdxDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|List
argument_list|<
name|Task
argument_list|<
name|?
argument_list|>
argument_list|>
name|getIndexBuilderMapRed
parameter_list|(
name|String
name|baseTableName
parameter_list|,
name|String
name|indexName
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
try|try
block|{
name|String
name|dbName
init|=
name|db
operator|.
name|getCurrentDatabase
argument_list|()
decl_stmt|;
name|Index
name|index
init|=
name|db
operator|.
name|getIndex
argument_list|(
name|dbName
argument_list|,
name|baseTableName
argument_list|,
name|indexName
argument_list|)
decl_stmt|;
name|Table
name|indexTbl
init|=
name|db
operator|.
name|getTable
argument_list|(
name|dbName
argument_list|,
name|index
operator|.
name|getIndexTableName
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|baseTblName
init|=
name|index
operator|.
name|getOrigTableName
argument_list|()
decl_stmt|;
name|Table
name|baseTbl
init|=
name|db
operator|.
name|getTable
argument_list|(
name|dbName
argument_list|,
name|baseTblName
argument_list|)
decl_stmt|;
name|String
name|handlerCls
init|=
name|index
operator|.
name|getIndexHandlerClass
argument_list|()
decl_stmt|;
name|HiveIndexHandler
name|handler
init|=
name|HiveUtils
operator|.
name|getIndexHandler
argument_list|(
name|conf
argument_list|,
name|handlerCls
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Partition
argument_list|>
name|indexTblPartitions
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|Partition
argument_list|>
name|baseTblPartitions
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|indexTbl
operator|!=
literal|null
condition|)
block|{
name|indexTblPartitions
operator|=
operator|new
name|ArrayList
argument_list|<
name|Partition
argument_list|>
argument_list|()
expr_stmt|;
name|baseTblPartitions
operator|=
name|preparePartitions
argument_list|(
name|baseTbl
argument_list|,
name|partSpec
argument_list|,
name|indexTbl
argument_list|,
name|db
argument_list|,
name|indexTblPartitions
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Task
argument_list|<
name|?
argument_list|>
argument_list|>
name|ret
init|=
name|handler
operator|.
name|generateIndexBuildTaskList
argument_list|(
name|baseTbl
argument_list|,
name|index
argument_list|,
name|indexTblPartitions
argument_list|,
name|baseTblPartitions
argument_list|,
name|indexTbl
argument_list|,
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|ret
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|Partition
argument_list|>
name|preparePartitions
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
name|baseTbl
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|,
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
name|indexTbl
parameter_list|,
name|Hive
name|db
parameter_list|,
name|List
argument_list|<
name|Partition
argument_list|>
name|indexTblPartitions
parameter_list|)
throws|throws
name|HiveException
throws|,
name|MetaException
block|{
name|List
argument_list|<
name|Partition
argument_list|>
name|baseTblPartitions
init|=
operator|new
name|ArrayList
argument_list|<
name|Partition
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|partSpec
operator|!=
literal|null
condition|)
block|{
comment|// if partspec is specified, then only producing index for that
comment|// partition
name|Partition
name|part
init|=
name|db
operator|.
name|getPartition
argument_list|(
name|baseTbl
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|part
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Partition "
operator|+
name|Warehouse
operator|.
name|makePartName
argument_list|(
name|partSpec
argument_list|,
literal|false
argument_list|)
operator|+
literal|" does not exist in table "
operator|+
name|baseTbl
operator|.
name|getTableName
argument_list|()
argument_list|)
throw|;
block|}
name|baseTblPartitions
operator|.
name|add
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|Partition
name|indexPart
init|=
name|db
operator|.
name|getPartition
argument_list|(
name|indexTbl
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexPart
operator|==
literal|null
condition|)
block|{
name|indexPart
operator|=
name|db
operator|.
name|createPartition
argument_list|(
name|indexTbl
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
name|indexTblPartitions
operator|.
name|add
argument_list|(
name|indexPart
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseTbl
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
comment|// if no partition is specified, create indexes for all partitions one
comment|// by one.
name|baseTblPartitions
operator|=
name|db
operator|.
name|getPartitions
argument_list|(
name|baseTbl
argument_list|)
expr_stmt|;
for|for
control|(
name|Partition
name|basePart
range|:
name|baseTblPartitions
control|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|pSpec
init|=
name|basePart
operator|.
name|getSpec
argument_list|()
decl_stmt|;
name|Partition
name|indexPart
init|=
name|db
operator|.
name|getPartition
argument_list|(
name|indexTbl
argument_list|,
name|pSpec
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexPart
operator|==
literal|null
condition|)
block|{
name|indexPart
operator|=
name|db
operator|.
name|createPartition
argument_list|(
name|indexTbl
argument_list|,
name|pSpec
argument_list|)
expr_stmt|;
block|}
name|indexTblPartitions
operator|.
name|add
argument_list|(
name|indexPart
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|baseTblPartitions
return|;
block|}
specifier|private
name|void
name|analyzeAlterTableProps
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|boolean
name|expectView
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapProp
init|=
name|getProps
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|AlterTableTypes
operator|.
name|ADDPROPS
argument_list|,
name|expectView
argument_list|)
decl_stmt|;
name|alterTblDesc
operator|.
name|setProps
argument_list|(
name|mapProp
argument_list|)
expr_stmt|;
name|alterTblDesc
operator|.
name|setOldName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
try|try
block|{
name|Table
name|tab
init|=
name|db
operator|.
name|getTable
argument_list|(
name|db
operator|.
name|getCurrentDatabase
argument_list|()
argument_list|,
name|tableName
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
operator|!=
literal|null
condition|)
block|{
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableSerdeProps
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapProp
init|=
name|getProps
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|AlterTableTypes
operator|.
name|ADDSERDEPROPS
argument_list|)
decl_stmt|;
name|alterTblDesc
operator|.
name|setProps
argument_list|(
name|mapProp
argument_list|)
expr_stmt|;
name|alterTblDesc
operator|.
name|setOldName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
try|try
block|{
name|Table
name|tab
init|=
name|db
operator|.
name|getTable
argument_list|(
name|db
operator|.
name|getCurrentDatabase
argument_list|()
argument_list|,
name|tableName
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
operator|!=
literal|null
condition|)
block|{
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableSerde
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|serdeName
init|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|AlterTableTypes
operator|.
name|ADDSERDE
argument_list|)
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|2
condition|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapProp
init|=
name|getProps
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|alterTblDesc
operator|.
name|setProps
argument_list|(
name|mapProp
argument_list|)
expr_stmt|;
block|}
name|alterTblDesc
operator|.
name|setOldName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|alterTblDesc
operator|.
name|setSerdeName
argument_list|(
name|serdeName
argument_list|)
expr_stmt|;
try|try
block|{
name|Table
name|tab
init|=
name|db
operator|.
name|getTable
argument_list|(
name|db
operator|.
name|getCurrentDatabase
argument_list|()
argument_list|,
name|tableName
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
operator|!=
literal|null
condition|)
block|{
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableFileFormat
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|inputFormat
init|=
literal|null
decl_stmt|;
name|String
name|outputFormat
init|=
literal|null
decl_stmt|;
name|String
name|storageHandler
init|=
literal|null
decl_stmt|;
name|String
name|serde
init|=
literal|null
decl_stmt|;
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABLEFILEFORMAT
case|:
name|inputFormat
operator|=
name|unescapeSQLString
argument_list|(
operator|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|outputFormat
operator|=
name|unescapeSQLString
argument_list|(
operator|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|Class
operator|.
name|forName
argument_list|(
name|inputFormat
argument_list|)
expr_stmt|;
name|Class
operator|.
name|forName
argument_list|(
name|outputFormat
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_STORAGEHANDLER
case|:
name|storageHandler
operator|=
name|unescapeSQLString
argument_list|(
operator|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|Class
operator|.
name|forName
argument_list|(
name|storageHandler
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TBLSEQUENCEFILE
case|:
name|inputFormat
operator|=
name|SEQUENCEFILE_INPUT
expr_stmt|;
name|outputFormat
operator|=
name|SEQUENCEFILE_OUTPUT
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TBLTEXTFILE
case|:
name|inputFormat
operator|=
name|TEXTFILE_INPUT
expr_stmt|;
name|outputFormat
operator|=
name|TEXTFILE_OUTPUT
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TBLRCFILE
case|:
name|inputFormat
operator|=
name|RCFILE_INPUT
expr_stmt|;
name|outputFormat
operator|=
name|RCFILE_OUTPUT
expr_stmt|;
name|serde
operator|=
name|COLUMNAR_SERDE
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_FILEFORMAT_GENERIC
case|:
name|handleGenericFileFormat
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
block|}
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|tableName
argument_list|,
name|inputFormat
argument_list|,
name|outputFormat
argument_list|,
name|serde
argument_list|,
name|storageHandler
argument_list|,
name|partSpec
argument_list|)
decl_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addInputsOutputsAlterTable
parameter_list|(
name|String
name|tableName
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
try|try
block|{
name|Table
name|tab
init|=
name|db
operator|.
name|getTable
argument_list|(
name|db
operator|.
name|getCurrentDatabase
argument_list|()
argument_list|,
name|tableName
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
operator|!=
literal|null
condition|)
block|{
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|partSpec
operator|==
literal|null
operator|)
operator|||
operator|(
name|partSpec
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Partition
name|part
init|=
name|db
operator|.
name|getPartition
argument_list|(
name|tab
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|part
operator|!=
literal|null
condition|)
block|{
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|part
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|analyzeAlterTableLocation
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|newLocation
init|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|tableName
argument_list|,
name|newLocation
argument_list|,
name|partSpec
argument_list|)
decl_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableProtectMode
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|AlterTableTypes
operator|.
name|ALTERPROTECTMODE
argument_list|)
decl_stmt|;
name|alterTblDesc
operator|.
name|setOldName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|alterTblDesc
operator|.
name|setPartSpec
argument_list|(
name|partSpec
argument_list|)
expr_stmt|;
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_ENABLE
case|:
name|alterTblDesc
operator|.
name|setProtectModeEnable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DISABLE
case|:
name|alterTblDesc
operator|.
name|setProtectModeEnable
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Set Protect mode Syntax parsing error."
argument_list|)
throw|;
block|}
name|ASTNode
name|grandChild
init|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|grandChild
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_OFFLINE
case|:
name|alterTblDesc
operator|.
name|setProtectModeType
argument_list|(
name|AlterTableDesc
operator|.
name|ProtectModeType
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_NO_DROP
case|:
name|alterTblDesc
operator|.
name|setProtectModeType
argument_list|(
name|AlterTableDesc
operator|.
name|ProtectModeType
operator|.
name|NO_DROP
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_READONLY
case|:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Potect mode READONLY is not implemented"
argument_list|)
throw|;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Only protect mode NO_DROP or OFFLINE supported"
argument_list|)
throw|;
block|}
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTablePartMergeFiles
parameter_list|(
name|ASTNode
name|tablePartAST
parameter_list|,
name|ASTNode
name|ast
parameter_list|,
name|String
name|tableName
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|AlterTablePartMergeFilesDesc
name|mergeDesc
init|=
operator|new
name|AlterTablePartMergeFilesDesc
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|inputDir
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|outputDir
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Table
name|tblObj
init|=
name|db
operator|.
name|getTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|bucketCols
init|=
literal|null
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|InputFormat
argument_list|>
name|inputFormatClass
init|=
literal|null
decl_stmt|;
name|boolean
name|isArchived
init|=
literal|false
decl_stmt|;
name|List
argument_list|<
name|Index
argument_list|>
name|indexes
init|=
name|db
operator|.
name|getIndexes
argument_list|(
name|tblObj
operator|.
name|getDbName
argument_list|()
argument_list|,
name|tableName
argument_list|,
name|Short
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexes
operator|!=
literal|null
operator|&&
name|indexes
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"can not do merge because source table "
operator|+
name|tableName
operator|+
literal|" is indexed."
argument_list|)
throw|;
block|}
if|if
condition|(
name|tblObj
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
if|if
condition|(
name|partSpec
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"source table "
operator|+
name|tableName
operator|+
literal|" is partitioned but no partition desc found."
argument_list|)
throw|;
block|}
else|else
block|{
name|Partition
name|part
init|=
name|db
operator|.
name|getPartition
argument_list|(
name|tblObj
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|part
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"source table "
operator|+
name|tableName
operator|+
literal|" is partitioned but partition not found."
argument_list|)
throw|;
block|}
name|bucketCols
operator|=
name|part
operator|.
name|getBucketCols
argument_list|()
expr_stmt|;
name|inputFormatClass
operator|=
name|part
operator|.
name|getInputFormatClass
argument_list|()
expr_stmt|;
name|isArchived
operator|=
name|Utilities
operator|.
name|isArchived
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|outputDir
operator|=
name|part
operator|.
name|getDataLocation
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|inputFormatClass
operator|=
name|tblObj
operator|.
name|getInputFormatClass
argument_list|()
expr_stmt|;
name|bucketCols
operator|=
name|tblObj
operator|.
name|getBucketCols
argument_list|()
expr_stmt|;
name|outputDir
operator|=
name|tblObj
operator|.
name|getDataLocation
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
comment|// throw a HiveException for non-rcfile.
if|if
condition|(
operator|!
name|inputFormatClass
operator|.
name|equals
argument_list|(
name|RCFileInputFormat
operator|.
name|class
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Only RCFileFormat is supportted right now."
argument_list|)
throw|;
block|}
comment|// throw a HiveException if the table/partition is bucketized
if|if
condition|(
name|bucketCols
operator|!=
literal|null
operator|&&
name|bucketCols
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Merge can not perform on bucketized partition/table."
argument_list|)
throw|;
block|}
comment|// throw a HiveException if the table/partition is archived
if|if
condition|(
name|isArchived
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Merge can not perform on archived partitions."
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// input and output are the same
name|inputDir
operator|.
name|add
argument_list|(
name|outputDir
argument_list|)
expr_stmt|;
name|mergeDesc
operator|.
name|setInputDir
argument_list|(
name|inputDir
argument_list|)
expr_stmt|;
name|mergeDesc
operator|.
name|setOutputDir
argument_list|(
name|outputDir
argument_list|)
expr_stmt|;
name|addInputsOutputsAlterTable
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|mergeTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|mergeDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|tableSpec
name|tablepart
init|=
operator|new
name|tableSpec
argument_list|(
name|this
operator|.
name|db
argument_list|,
name|conf
argument_list|,
name|tablePartAST
argument_list|)
decl_stmt|;
name|StatsWork
name|statDesc
init|=
operator|new
name|StatsWork
argument_list|(
name|tablepart
argument_list|)
decl_stmt|;
name|statDesc
operator|.
name|setNoStatsAggregator
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|statTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
name|statDesc
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|mergeTask
operator|.
name|addDependentTask
argument_list|(
name|statTask
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|mergeTask
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableClusterSort
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|Table
name|tab
init|=
name|db
operator|.
name|getTable
argument_list|(
name|db
operator|.
name|getCurrentDatabase
argument_list|()
argument_list|,
name|tableName
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
operator|!=
literal|null
condition|)
block|{
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// This means that we want to turn off bucketing
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|tableName
argument_list|,
operator|-
literal|1
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|Order
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASTNode
name|buckets
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|bucketCols
init|=
name|getColumnNames
argument_list|(
operator|(
name|ASTNode
operator|)
name|buckets
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Order
argument_list|>
name|sortCols
init|=
operator|new
name|ArrayList
argument_list|<
name|Order
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|numBuckets
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|buckets
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|numBuckets
operator|=
operator|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|buckets
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
operator|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|sortCols
operator|=
name|getColumnNamesOrder
argument_list|(
operator|(
name|ASTNode
operator|)
name|buckets
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|numBuckets
operator|=
operator|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|buckets
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
operator|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|numBuckets
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_BUCKET_NUMBER
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|tableName
argument_list|,
name|numBuckets
argument_list|,
name|bucketCols
argument_list|,
name|sortCols
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getProps
parameter_list|(
name|ASTNode
name|prop
parameter_list|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapProp
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|readProps
argument_list|(
name|prop
argument_list|,
name|mapProp
argument_list|)
expr_stmt|;
return|return
name|mapProp
return|;
block|}
comment|/**    * Get the fully qualified name in the ast. e.g. the ast of the form ^(DOT    * ^(DOT a b) c) will generate a name of the form a.b.c    *    * @param ast    *          The AST from which the qualified name has to be extracted    * @return String    */
specifier|private
name|String
name|getFullyQualifiedName
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
block|{
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|ast
operator|.
name|getText
argument_list|()
return|;
block|}
return|return
name|getFullyQualifiedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|+
literal|"."
operator|+
name|getFullyQualifiedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Create a FetchTask for a given table and thrift ddl schema.    *    * @param tablename    *          tablename    * @param schema    *          thrift ddl    */
specifier|private
name|FetchTask
name|createFetchTask
parameter_list|(
name|String
name|schema
parameter_list|)
block|{
name|Properties
name|prop
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|prop
operator|.
name|setProperty
argument_list|(
name|Constants
operator|.
name|SERIALIZATION_FORMAT
argument_list|,
literal|"9"
argument_list|)
expr_stmt|;
name|prop
operator|.
name|setProperty
argument_list|(
name|Constants
operator|.
name|SERIALIZATION_NULL_FORMAT
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|String
index|[]
name|colTypes
init|=
name|schema
operator|.
name|split
argument_list|(
literal|"#"
argument_list|)
decl_stmt|;
name|prop
operator|.
name|setProperty
argument_list|(
literal|"columns"
argument_list|,
name|colTypes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|prop
operator|.
name|setProperty
argument_list|(
literal|"columns.types"
argument_list|,
name|colTypes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|FetchWork
name|fetch
init|=
operator|new
name|FetchWork
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
operator|new
name|TableDesc
argument_list|(
name|LazySimpleSerDe
operator|.
name|class
argument_list|,
name|TextInputFormat
operator|.
name|class
argument_list|,
name|IgnoreKeyTextOutputFormat
operator|.
name|class
argument_list|,
name|prop
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|fetch
operator|.
name|setSerializationNullFormat
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
return|return
operator|(
name|FetchTask
operator|)
name|TaskFactory
operator|.
name|get
argument_list|(
name|fetch
argument_list|,
name|conf
argument_list|)
return|;
block|}
specifier|private
name|void
name|analyzeDescribeTable
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|tableTypeExpr
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|tableName
init|=
name|getFullyQualifiedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|tableTypeExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
comment|// get partition metadata if partition specified
if|if
condition|(
name|tableTypeExpr
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|ASTNode
name|partspec
init|=
operator|(
name|ASTNode
operator|)
name|tableTypeExpr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|partSpec
operator|=
name|getPartSpec
argument_list|(
name|partspec
argument_list|)
expr_stmt|;
block|}
name|DescTableDesc
name|descTblDesc
init|=
operator|new
name|DescTableDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|)
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|int
name|descOptions
init|=
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|descTblDesc
operator|.
name|setFormatted
argument_list|(
name|descOptions
operator|==
name|HiveParser
operator|.
name|KW_FORMATTED
argument_list|)
expr_stmt|;
name|descTblDesc
operator|.
name|setExt
argument_list|(
name|descOptions
operator|==
name|HiveParser
operator|.
name|KW_EXTENDED
argument_list|)
expr_stmt|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|descTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|DescTableDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"analyzeDescribeTable done"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Describe database.    * @param ast    * @throws SemanticException    */
specifier|private
name|void
name|analyzeDescDatabase
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|boolean
name|isExtended
decl_stmt|;
name|String
name|dbName
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|dbName
operator|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|isExtended
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|dbName
operator|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|isExtended
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unexpected Tokens at DESCRIBE DATABASE"
argument_list|)
throw|;
block|}
name|DescDatabaseDesc
name|descDbDesc
init|=
operator|new
name|DescDatabaseDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|dbName
argument_list|,
name|isExtended
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|descDbDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|descDbDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getPartSpec
parameter_list|(
name|ASTNode
name|partspec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partspec
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|partspec_val
init|=
operator|(
name|ASTNode
operator|)
name|partspec
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|val
init|=
name|stripQuotes
argument_list|(
name|partspec_val
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|partSpec
operator|.
name|put
argument_list|(
name|partspec_val
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|partSpec
return|;
block|}
specifier|private
name|void
name|analyzeShowPartitions
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowPartitionsDesc
name|showPartsDesc
decl_stmt|;
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
init|=
name|getPartitionSpecs
argument_list|(
name|ast
argument_list|)
decl_stmt|;
comment|// We only can have a single partition spec
assert|assert
operator|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|<=
literal|1
operator|)
assert|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|partSpec
operator|=
name|partSpecs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|showPartsDesc
operator|=
operator|new
name|ShowPartitionsDesc
argument_list|(
name|tableName
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showPartsDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showPartsDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowDatabases
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowDatabasesDesc
name|showDatabasesDesc
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|String
name|databasePattern
init|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|showDatabasesDesc
operator|=
operator|new
name|ShowDatabasesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|databasePattern
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|showDatabasesDesc
operator|=
operator|new
name|ShowDatabasesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showDatabasesDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showDatabasesDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowTables
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowTablesDesc
name|showTblsDesc
decl_stmt|;
name|String
name|dbName
init|=
name|db
operator|.
name|getCurrentDatabase
argument_list|()
decl_stmt|;
name|String
name|tableNames
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|3
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|GENERIC_ERROR
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
comment|// Uses a pattern
name|tableNames
operator|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|showTblsDesc
operator|=
operator|new
name|ShowTablesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|dbName
argument_list|,
name|tableNames
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|// Specifies a DB
assert|assert
operator|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FROM
operator|)
assert|;
name|dbName
operator|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|showTblsDesc
operator|=
operator|new
name|ShowTablesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|dbName
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|// Uses a pattern and specifies a DB
assert|assert
operator|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FROM
operator|)
assert|;
name|dbName
operator|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|tableNames
operator|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|showTblsDesc
operator|=
operator|new
name|ShowTablesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|dbName
argument_list|,
name|tableNames
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// No pattern or DB
name|showTblsDesc
operator|=
operator|new
name|ShowTablesDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|dbName
argument_list|)
expr_stmt|;
break|break;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showTblsDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showTblsDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowTableStatus
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowTableStatusDesc
name|showTblStatusDesc
decl_stmt|;
name|String
name|tableNames
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|dbName
init|=
name|db
operator|.
name|getCurrentDatabase
argument_list|()
decl_stmt|;
name|int
name|children
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|children
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|children
operator|>
literal|3
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|GENERIC_ERROR
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|children
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|Identifier
condition|)
block|{
name|dbName
operator|=
name|unescapeIdentifier
argument_list|(
name|child
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PARTSPEC
condition|)
block|{
name|partSpec
operator|=
name|getPartSpec
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|GENERIC_ERROR
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
name|showTblStatusDesc
operator|=
operator|new
name|ShowTableStatusDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|dbName
argument_list|,
name|tableNames
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showTblStatusDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showTblStatusDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeShowIndexes
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowIndexesDesc
name|showIndexesDesc
decl_stmt|;
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|showIndexesDesc
operator|=
operator|new
name|ShowIndexesDesc
argument_list|(
name|tableName
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|int
name|descOptions
init|=
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|showIndexesDesc
operator|.
name|setFormatted
argument_list|(
name|descOptions
operator|==
name|HiveParser
operator|.
name|KW_FORMATTED
argument_list|)
expr_stmt|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showIndexesDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showIndexesDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the task according to the parsed command tree. This is used for the CLI    * command "SHOW FUNCTIONS;".    *    * @param ast    *          The parsed command tree.    * @throws SemanticException    *           Parsin failed    */
specifier|private
name|void
name|analyzeShowFunctions
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ShowFunctionsDesc
name|showFuncsDesc
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|String
name|funcNames
init|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|showFuncsDesc
operator|=
operator|new
name|ShowFunctionsDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|funcNames
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|showFuncsDesc
operator|=
operator|new
name|ShowFunctionsDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showFuncsDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showFuncsDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the task according to the parsed command tree. This is used for the CLI    * command "SHOW LOCKS;".    *    * @param ast    *          The parsed command tree.    * @throws SemanticException    *           Parsing failed    */
specifier|private
name|void
name|analyzeShowLocks
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
literal|null
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
name|boolean
name|isExtended
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>=
literal|1
condition|)
block|{
comment|// table for which show locks is being executed
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABTYPE
condition|)
block|{
name|ASTNode
name|tableTypeExpr
init|=
operator|(
name|ASTNode
operator|)
name|child
decl_stmt|;
name|tableName
operator|=
name|getFullyQualifiedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|tableTypeExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// get partition metadata if partition specified
if|if
condition|(
name|tableTypeExpr
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|ASTNode
name|partspec
init|=
operator|(
name|ASTNode
operator|)
name|tableTypeExpr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|partSpec
operator|=
name|getPartSpec
argument_list|(
name|partspec
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|KW_EXTENDED
condition|)
block|{
name|isExtended
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
name|ShowLocksDesc
name|showLocksDesc
init|=
operator|new
name|ShowLocksDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|isExtended
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|showLocksDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|showLocksDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Need to initialize the lock manager
name|ctx
operator|.
name|setNeedLockMgr
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the task according to the parsed command tree. This is used for the CLI    * command "LOCK TABLE ..;".    *    * @param ast    *          The parsed command tree.    * @throws SemanticException    *           Parsing failed    */
specifier|private
name|void
name|analyzeLockTable
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|String
name|mode
init|=
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toUpperCase
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
init|=
name|getPartitionSpecs
argument_list|(
name|ast
argument_list|)
decl_stmt|;
comment|// We only can have a single partition spec
assert|assert
operator|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|<=
literal|1
operator|)
assert|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|partSpec
operator|=
name|partSpecs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|LockTableDesc
name|lockTblDesc
init|=
operator|new
name|LockTableDesc
argument_list|(
name|tableName
argument_list|,
name|mode
argument_list|,
name|partSpec
argument_list|,
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVEQUERYID
argument_list|)
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|lockTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
comment|// Need to initialize the lock manager
name|ctx
operator|.
name|setNeedLockMgr
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the task according to the parsed command tree. This is used for the CLI    * command "UNLOCK TABLE ..;".    *    * @param ast    *          The parsed command tree.    * @throws SemanticException    *           Parsing failed    */
specifier|private
name|void
name|analyzeUnlockTable
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
init|=
name|getPartitionSpecs
argument_list|(
name|ast
argument_list|)
decl_stmt|;
comment|// We only can have a single partition spec
assert|assert
operator|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|<=
literal|1
operator|)
assert|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|partSpec
operator|=
name|partSpecs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|UnlockTableDesc
name|unlockTblDesc
init|=
operator|new
name|UnlockTableDesc
argument_list|(
name|tableName
argument_list|,
name|partSpec
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|unlockTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
comment|// Need to initialize the lock manager
name|ctx
operator|.
name|setNeedLockMgr
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the task according to the parsed command tree. This is used for the CLI    * command "DESCRIBE FUNCTION;".    *    * @param ast    *          The parsed command tree.    * @throws SemanticException    *           Parsing failed    */
specifier|private
name|void
name|analyzeDescFunction
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|funcName
decl_stmt|;
name|boolean
name|isExtended
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|funcName
operator|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|isExtended
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|funcName
operator|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|isExtended
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unexpected Tokens at DESCRIBE FUNCTION"
argument_list|)
throw|;
block|}
name|DescFunctionDesc
name|descFuncDesc
init|=
operator|new
name|DescFunctionDesc
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|funcName
argument_list|,
name|isExtended
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|descFuncDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|descFuncDesc
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableRename
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tblName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|tblName
argument_list|,
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|Table
name|tab
init|=
name|db
operator|.
name|getTable
argument_list|(
name|db
operator|.
name|getCurrentDatabase
argument_list|()
argument_list|,
name|tblName
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
operator|!=
literal|null
condition|)
block|{
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|tblName
argument_list|)
argument_list|)
throw|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableRenameCol
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tblName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|newComment
init|=
literal|null
decl_stmt|;
name|String
name|newType
init|=
literal|null
decl_stmt|;
name|newType
operator|=
name|getTypeStringFromAST
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|first
init|=
literal|false
decl_stmt|;
name|String
name|flagCol
init|=
literal|null
decl_stmt|;
name|ASTNode
name|positionNode
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|6
condition|)
block|{
name|newComment
operator|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|4
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|positionNode
operator|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|5
condition|)
block|{
if|if
condition|(
name|ast
operator|.
name|getChild
argument_list|(
literal|4
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|StringLiteral
condition|)
block|{
name|newComment
operator|=
name|unescapeSQLString
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|4
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|positionNode
operator|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|positionNode
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|positionNode
operator|.
name|getChildCount
argument_list|()
operator|==
literal|0
condition|)
block|{
name|first
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|flagCol
operator|=
name|unescapeIdentifier
argument_list|(
name|positionNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|tblName
argument_list|,
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
name|unescapeIdentifier
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
name|newType
argument_list|,
name|newComment
argument_list|,
name|first
argument_list|,
name|flagCol
argument_list|)
decl_stmt|;
try|try
block|{
name|Table
name|tab
init|=
name|db
operator|.
name|getTable
argument_list|(
name|db
operator|.
name|getCurrentDatabase
argument_list|()
argument_list|,
name|tblName
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
operator|!=
literal|null
condition|)
block|{
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|tblName
argument_list|)
argument_list|)
throw|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableModifyCols
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|AlterTableTypes
name|alterType
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tblName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|newCols
init|=
name|getColumns
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|tblName
argument_list|,
name|newCols
argument_list|,
name|alterType
argument_list|)
decl_stmt|;
try|try
block|{
name|Table
name|tab
init|=
name|db
operator|.
name|getTable
argument_list|(
name|db
operator|.
name|getCurrentDatabase
argument_list|()
argument_list|,
name|tblName
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
operator|!=
literal|null
condition|)
block|{
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|tblName
argument_list|)
argument_list|)
throw|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|analyzeAlterTableDropParts
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|boolean
name|expectView
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tblName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|// get table metadata
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
init|=
name|getPartitionSpecs
argument_list|(
name|ast
argument_list|)
decl_stmt|;
name|DropTableDesc
name|dropTblDesc
init|=
operator|new
name|DropTableDesc
argument_list|(
name|tblName
argument_list|,
name|partSpecs
argument_list|,
name|expectView
argument_list|)
decl_stmt|;
try|try
block|{
name|Table
name|tab
init|=
name|db
operator|.
name|getTable
argument_list|(
name|db
operator|.
name|getCurrentDatabase
argument_list|()
argument_list|,
name|tblName
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
operator|!=
literal|null
condition|)
block|{
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|tblName
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|partSpecs
operator|!=
literal|null
condition|)
block|{
name|boolean
name|ifExists
init|=
operator|(
name|ast
operator|.
name|getFirstChildWithType
argument_list|(
name|TOK_IFEXISTS
argument_list|)
operator|!=
literal|null
operator|)
decl_stmt|;
comment|// we want to signal an error if the partition doesn't exist and we're
comment|// configured not to fail silently
name|boolean
name|throwException
init|=
operator|!
name|ifExists
operator|&&
operator|!
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|DROPIGNORESNONEXISTENT
argument_list|)
decl_stmt|;
name|addTablePartsOutputs
argument_list|(
name|tblName
argument_list|,
name|partSpecs
argument_list|,
name|throwException
argument_list|,
name|ast
argument_list|)
expr_stmt|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|dropTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add one or more partitions to a table. Useful when the data has been copied    * to the right location by some other process.    *    * @param ast    *          The parsed command tree.    *    * @param expectView    *          True for ALTER VIEW, false for ALTER TABLE.    *    * @throws SemanticException    *           Parsing failed    */
specifier|private
name|void
name|analyzeAlterTableAddParts
parameter_list|(
name|CommonTree
name|ast
parameter_list|,
name|boolean
name|expectView
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tblName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|boolean
name|isView
init|=
literal|false
decl_stmt|;
name|Table
name|tab
decl_stmt|;
try|try
block|{
name|tab
operator|=
name|db
operator|.
name|getTable
argument_list|(
name|db
operator|.
name|getCurrentDatabase
argument_list|()
argument_list|,
name|tblName
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|tab
operator|!=
literal|null
condition|)
block|{
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|isView
operator|=
name|tab
operator|.
name|isView
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|tblName
argument_list|)
argument_list|)
throw|;
block|}
comment|// partition name to value
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
init|=
name|getPartitionSpecs
argument_list|(
name|ast
argument_list|)
decl_stmt|;
name|addTablePartsOutputs
argument_list|(
name|tblName
argument_list|,
name|partSpecs
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partIter
init|=
name|partSpecs
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|String
name|currentLocation
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|currentPart
init|=
literal|null
decl_stmt|;
name|boolean
name|ifNotExists
init|=
literal|false
decl_stmt|;
name|List
argument_list|<
name|AddPartitionDesc
argument_list|>
name|partitionDescs
init|=
operator|new
name|ArrayList
argument_list|<
name|AddPartitionDesc
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|numCh
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|num
init|=
literal|1
init|;
name|num
operator|<
name|numCh
condition|;
name|num
operator|++
control|)
block|{
name|CommonTree
name|child
init|=
operator|(
name|CommonTree
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|num
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_IFNOTEXISTS
case|:
name|ifNotExists
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_PARTSPEC
case|:
if|if
condition|(
name|currentPart
operator|!=
literal|null
condition|)
block|{
name|validatePartitionValues
argument_list|(
name|currentPart
argument_list|)
expr_stmt|;
name|AddPartitionDesc
name|addPartitionDesc
init|=
operator|new
name|AddPartitionDesc
argument_list|(
name|db
operator|.
name|getCurrentDatabase
argument_list|()
argument_list|,
name|tblName
argument_list|,
name|currentPart
argument_list|,
name|currentLocation
argument_list|,
name|ifNotExists
argument_list|,
name|expectView
argument_list|)
decl_stmt|;
name|partitionDescs
operator|.
name|add
argument_list|(
name|addPartitionDesc
argument_list|)
expr_stmt|;
block|}
comment|// create new partition, set values
name|currentLocation
operator|=
literal|null
expr_stmt|;
name|currentPart
operator|=
name|partIter
operator|.
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_PARTITIONLOCATION
case|:
comment|// if location specified, set in partition
name|currentLocation
operator|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unknown child: "
operator|+
name|child
argument_list|)
throw|;
block|}
block|}
comment|// add the last one
if|if
condition|(
name|currentPart
operator|!=
literal|null
condition|)
block|{
name|validatePartitionValues
argument_list|(
name|currentPart
argument_list|)
expr_stmt|;
name|AddPartitionDesc
name|addPartitionDesc
init|=
operator|new
name|AddPartitionDesc
argument_list|(
name|db
operator|.
name|getCurrentDatabase
argument_list|()
argument_list|,
name|tblName
argument_list|,
name|currentPart
argument_list|,
name|currentLocation
argument_list|,
name|ifNotExists
argument_list|,
name|expectView
argument_list|)
decl_stmt|;
name|partitionDescs
operator|.
name|add
argument_list|(
name|addPartitionDesc
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|AddPartitionDesc
name|addPartitionDesc
range|:
name|partitionDescs
control|)
block|{
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|addPartitionDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isView
condition|)
block|{
comment|// Compile internal query to capture underlying table partition
comment|// dependencies
name|StringBuilder
name|cmd
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|cmd
operator|.
name|append
argument_list|(
literal|"SELECT * FROM "
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|unparseIdentifier
argument_list|(
name|tblName
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|append
argument_list|(
literal|" WHERE "
argument_list|)
expr_stmt|;
name|boolean
name|firstOr
init|=
literal|true
decl_stmt|;
for|for
control|(
name|AddPartitionDesc
name|partitionDesc
range|:
name|partitionDescs
control|)
block|{
comment|// Perform this check early so that we get a better error message.
try|try
block|{
comment|// Note that isValidSpec throws an exception (it never
comment|// actually returns false).
name|tab
operator|.
name|isValidSpec
argument_list|(
name|partitionDesc
operator|.
name|getPartSpec
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ex
argument_list|)
throw|;
block|}
if|if
condition|(
name|firstOr
condition|)
block|{
name|firstOr
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|.
name|append
argument_list|(
literal|" OR "
argument_list|)
expr_stmt|;
block|}
name|boolean
name|firstAnd
init|=
literal|true
decl_stmt|;
name|cmd
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|partitionDesc
operator|.
name|getPartSpec
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|firstAnd
condition|)
block|{
name|firstAnd
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|.
name|append
argument_list|(
literal|" AND "
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|unparseIdentifier
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|append
argument_list|(
literal|" = '"
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|escapeString
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|Driver
name|driver
init|=
operator|new
name|Driver
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|int
name|rc
init|=
name|driver
operator|.
name|compile
argument_list|(
name|cmd
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NO_VALID_PARTN
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|inputs
operator|.
name|addAll
argument_list|(
name|driver
operator|.
name|getPlan
argument_list|()
operator|.
name|getInputs
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Rewrite the metadata for one or more partitions in a table. Useful when    * an external process modifies files on HDFS and you want the pre/post    * hooks to be fired for the specified partition.    *    * @param ast    *          The parsed command tree.    * @throws SemanticException    *           Parsin failed    */
specifier|private
name|void
name|analyzeAlterTableTouch
parameter_list|(
name|CommonTree
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tblName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|Table
name|tab
decl_stmt|;
try|try
block|{
name|tab
operator|=
name|db
operator|.
name|getTable
argument_list|(
name|db
operator|.
name|getCurrentDatabase
argument_list|()
argument_list|,
name|tblName
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|tab
operator|!=
literal|null
condition|)
block|{
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|tblName
argument_list|)
argument_list|)
throw|;
block|}
comment|// partition name to value
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
init|=
name|getPartitionSpecs
argument_list|(
name|ast
argument_list|)
decl_stmt|;
if|if
condition|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|AlterTableSimpleDesc
name|touchDesc
init|=
operator|new
name|AlterTableSimpleDesc
argument_list|(
name|db
operator|.
name|getCurrentDatabase
argument_list|()
argument_list|,
name|tblName
argument_list|,
literal|null
argument_list|,
name|AlterTableDesc
operator|.
name|AlterTableTypes
operator|.
name|TOUCH
argument_list|)
decl_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|touchDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addTablePartsOutputs
argument_list|(
name|tblName
argument_list|,
name|partSpecs
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
range|:
name|partSpecs
control|)
block|{
name|AlterTableSimpleDesc
name|touchDesc
init|=
operator|new
name|AlterTableSimpleDesc
argument_list|(
name|db
operator|.
name|getCurrentDatabase
argument_list|()
argument_list|,
name|tblName
argument_list|,
name|partSpec
argument_list|,
name|AlterTableDesc
operator|.
name|AlterTableTypes
operator|.
name|TOUCH
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|touchDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|analyzeAlterTableArchive
parameter_list|(
name|CommonTree
name|ast
parameter_list|,
name|boolean
name|isUnArchive
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEARCHIVEENABLED
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ARCHIVE_METHODS_DISABLED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|String
name|tblName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|// partition name to value
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
init|=
name|getPartitionSpecs
argument_list|(
name|ast
argument_list|)
decl_stmt|;
try|try
block|{
name|Table
name|tab
init|=
name|db
operator|.
name|getTable
argument_list|(
name|db
operator|.
name|getCurrentDatabase
argument_list|()
argument_list|,
name|tblName
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
operator|!=
literal|null
condition|)
block|{
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|tblName
argument_list|)
argument_list|)
throw|;
block|}
name|addTablePartsOutputs
argument_list|(
name|tblName
argument_list|,
name|partSpecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|isUnArchive
condition|?
name|ErrorMsg
operator|.
name|UNARCHIVE_ON_MULI_PARTS
operator|.
name|getMsg
argument_list|()
else|:
name|ErrorMsg
operator|.
name|ARCHIVE_ON_MULI_PARTS
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|partSpecs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ARCHIVE_ON_TABLE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
name|partSpecs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|AlterTableSimpleDesc
name|archiveDesc
init|=
operator|new
name|AlterTableSimpleDesc
argument_list|(
name|db
operator|.
name|getCurrentDatabase
argument_list|()
argument_list|,
name|tblName
argument_list|,
name|partSpec
argument_list|,
operator|(
name|isUnArchive
condition|?
name|AlterTableTypes
operator|.
name|UNARCHIVE
else|:
name|AlterTableTypes
operator|.
name|ARCHIVE
operator|)
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|archiveDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Verify that the information in the metastore matches up with the data on    * the fs.    *    * @param ast    *          Query tree.    * @throws SemanticException    */
specifier|private
name|void
name|analyzeMetastoreCheck
parameter_list|(
name|CommonTree
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
literal|null
decl_stmt|;
name|boolean
name|repair
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|repair
operator|=
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|KW_REPAIR
expr_stmt|;
if|if
condition|(
operator|!
name|repair
condition|)
block|{
name|tableName
operator|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
name|tableName
operator|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|specs
init|=
name|getPartitionSpecs
argument_list|(
name|ast
argument_list|)
decl_stmt|;
name|MsckDesc
name|checkDesc
init|=
operator|new
name|MsckDesc
argument_list|(
name|tableName
argument_list|,
name|specs
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|repair
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|checkDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the partition specs from the tree.    *    * @param ast    *          Tree to extract partitions from.    * @return A list of partition name to value mappings.    * @throws SemanticException    */
specifier|private
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|getPartitionSpecs
parameter_list|(
name|CommonTree
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
init|=
operator|new
name|ArrayList
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|childIndex
init|=
literal|0
decl_stmt|;
comment|// get partition metadata if partition specified
for|for
control|(
name|childIndex
operator|=
literal|1
init|;
name|childIndex
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
name|childIndex
operator|++
control|)
block|{
name|Tree
name|partspec
init|=
name|ast
operator|.
name|getChild
argument_list|(
name|childIndex
argument_list|)
decl_stmt|;
comment|// sanity check
if|if
condition|(
name|partspec
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PARTSPEC
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partspec
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|CommonTree
name|partspec_val
init|=
operator|(
name|CommonTree
operator|)
name|partspec
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|val
init|=
name|stripQuotes
argument_list|(
name|partspec_val
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|partSpec
operator|.
name|put
argument_list|(
name|partspec_val
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|partSpecs
operator|.
name|add
argument_list|(
name|partSpec
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|partSpecs
return|;
block|}
comment|/**    * Certain partition values are are used by hive. e.g. the default partition    * in dynamic partitioning and the intermediate partition values used in the    * archiving process. Naturally, prohibit the user from creating partitions    * with these reserved values. The check that this function is more    * restrictive than the actual limitation, but it's simpler. Should be okay    * since the reserved names are fairly long and uncommon.    */
specifier|private
name|void
name|validatePartitionValues
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|e
range|:
name|partSpec
operator|.
name|entrySet
argument_list|()
control|)
block|{
for|for
control|(
name|String
name|s
range|:
name|reservedPartitionValues
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|contains
argument_list|(
name|s
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|RESERVED_PART_VAL
operator|.
name|getMsg
argument_list|(
literal|"(User value: "
operator|+
name|e
operator|.
name|getValue
argument_list|()
operator|+
literal|" Reserved substring: "
operator|+
name|s
operator|+
literal|")"
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**    * Add the table partitions to be modified in the output, so that it is available for the    * pre-execution hook. If the partition does not exist, no error is thrown.    */
specifier|private
name|void
name|addTablePartsOutputs
parameter_list|(
name|String
name|tblName
parameter_list|,
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|addTablePartsOutputs
argument_list|(
name|tblName
argument_list|,
name|partSpecs
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the table partitions to be modified in the output, so that it is available for the    * pre-execution hook. If the partition does not exist, throw an error if    * throwIfNonExistent is true, otherwise ignore it.    */
specifier|private
name|void
name|addTablePartsOutputs
parameter_list|(
name|String
name|tblName
parameter_list|,
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partSpecs
parameter_list|,
name|boolean
name|throwIfNonExistent
parameter_list|,
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Table
name|tab
decl_stmt|;
try|try
block|{
name|tab
operator|=
name|db
operator|.
name|getTable
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|tblName
argument_list|)
argument_list|)
throw|;
block|}
name|Iterator
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|i
decl_stmt|;
name|int
name|index
decl_stmt|;
for|for
control|(
name|i
operator|=
name|partSpecs
operator|.
name|iterator
argument_list|()
operator|,
name|index
operator|=
literal|1
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
operator|++
name|index
control|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|Partition
name|part
init|=
name|db
operator|.
name|getPartition
argument_list|(
name|tab
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|part
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|part
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
comment|// Ignore the error if the partition does not exist
if|if
condition|(
name|throwIfNonExistent
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_PARTITION
operator|.
name|getMsg
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
name|index
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

