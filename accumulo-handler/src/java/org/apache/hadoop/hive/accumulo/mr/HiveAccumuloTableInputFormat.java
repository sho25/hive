begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|accumulo
operator|.
name|mr
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|accumulo
operator|.
name|core
operator|.
name|client
operator|.
name|AccumuloException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|accumulo
operator|.
name|core
operator|.
name|client
operator|.
name|AccumuloSecurityException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|accumulo
operator|.
name|core
operator|.
name|client
operator|.
name|Connector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|accumulo
operator|.
name|core
operator|.
name|client
operator|.
name|Instance
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|accumulo
operator|.
name|core
operator|.
name|client
operator|.
name|IteratorSetting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|accumulo
operator|.
name|core
operator|.
name|client
operator|.
name|mapred
operator|.
name|AccumuloInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|accumulo
operator|.
name|core
operator|.
name|client
operator|.
name|mapred
operator|.
name|AccumuloRowInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|accumulo
operator|.
name|core
operator|.
name|client
operator|.
name|mapred
operator|.
name|RangeInputSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|accumulo
operator|.
name|core
operator|.
name|client
operator|.
name|mock
operator|.
name|MockInstance
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|accumulo
operator|.
name|core
operator|.
name|client
operator|.
name|security
operator|.
name|tokens
operator|.
name|AuthenticationToken
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|accumulo
operator|.
name|core
operator|.
name|client
operator|.
name|security
operator|.
name|tokens
operator|.
name|PasswordToken
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|accumulo
operator|.
name|core
operator|.
name|data
operator|.
name|Key
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|accumulo
operator|.
name|core
operator|.
name|data
operator|.
name|Range
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|accumulo
operator|.
name|core
operator|.
name|data
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|accumulo
operator|.
name|core
operator|.
name|security
operator|.
name|Authorizations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|accumulo
operator|.
name|core
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|accumulo
operator|.
name|core
operator|.
name|util
operator|.
name|PeekingIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|accumulo
operator|.
name|AccumuloConnectionParameters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|accumulo
operator|.
name|AccumuloHiveRow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|accumulo
operator|.
name|columns
operator|.
name|ColumnMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|accumulo
operator|.
name|columns
operator|.
name|ColumnMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|accumulo
operator|.
name|columns
operator|.
name|HiveAccumuloColumnMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|accumulo
operator|.
name|columns
operator|.
name|HiveAccumuloMapColumnMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|accumulo
operator|.
name|predicate
operator|.
name|AccumuloPredicateHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|accumulo
operator|.
name|serde
operator|.
name|AccumuloSerDeParameters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|accumulo
operator|.
name|serde
operator|.
name|TooManyAccumuloColumnsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|serdeConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|ColumnProjectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|shims
operator|.
name|ShimLoader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|InputSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|RecordReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Reporter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Job
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|FileInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Wraps older InputFormat for use with Hive.  *  * Configure input scan with proper ranges, iterators, and columns based on serde properties for  * Hive table.  */
end_comment

begin_class
specifier|public
class|class
name|HiveAccumuloTableInputFormat
implements|implements
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|InputFormat
argument_list|<
name|Text
argument_list|,
name|AccumuloHiveRow
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|HiveAccumuloTableInputFormat
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Visible for testing
specifier|protected
name|AccumuloRowInputFormat
name|accumuloInputFormat
init|=
operator|new
name|AccumuloRowInputFormat
argument_list|()
decl_stmt|;
specifier|protected
name|AccumuloPredicateHandler
name|predicateHandler
init|=
name|AccumuloPredicateHandler
operator|.
name|getInstance
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|InputSplit
index|[]
name|getSplits
parameter_list|(
name|JobConf
name|jobConf
parameter_list|,
name|int
name|numSplits
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|AccumuloConnectionParameters
name|accumuloParams
init|=
operator|new
name|AccumuloConnectionParameters
argument_list|(
name|jobConf
argument_list|)
decl_stmt|;
specifier|final
name|Instance
name|instance
init|=
name|accumuloParams
operator|.
name|getInstance
argument_list|()
decl_stmt|;
specifier|final
name|ColumnMapper
name|columnMapper
decl_stmt|;
try|try
block|{
name|columnMapper
operator|=
name|getColumnMapper
argument_list|(
name|jobConf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TooManyAccumuloColumnsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|JobContext
name|context
init|=
name|ShimLoader
operator|.
name|getHadoopShims
argument_list|()
operator|.
name|newJobContext
argument_list|(
name|Job
operator|.
name|getInstance
argument_list|(
name|jobConf
argument_list|)
argument_list|)
decl_stmt|;
name|Path
index|[]
name|tablePaths
init|=
name|FileInputFormat
operator|.
name|getInputPaths
argument_list|(
name|context
argument_list|)
decl_stmt|;
try|try
block|{
specifier|final
name|Connector
name|connector
init|=
name|accumuloParams
operator|.
name|getConnector
argument_list|(
name|instance
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|ColumnMapping
argument_list|>
name|columnMappings
init|=
name|columnMapper
operator|.
name|getColumnMappings
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|IteratorSetting
argument_list|>
name|iterators
init|=
name|predicateHandler
operator|.
name|getIterators
argument_list|(
name|jobConf
argument_list|,
name|columnMapper
argument_list|)
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|Range
argument_list|>
name|ranges
init|=
name|predicateHandler
operator|.
name|getRanges
argument_list|(
name|jobConf
argument_list|,
name|columnMapper
argument_list|)
decl_stmt|;
comment|// Setting an empty collection of ranges will, unexpectedly, scan all data
comment|// We don't want that.
if|if
condition|(
literal|null
operator|!=
name|ranges
operator|&&
name|ranges
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
operator|new
name|InputSplit
index|[
literal|0
index|]
return|;
block|}
comment|// Set the relevant information in the Configuration for the AccumuloInputFormat
name|configure
argument_list|(
name|jobConf
argument_list|,
name|instance
argument_list|,
name|connector
argument_list|,
name|accumuloParams
argument_list|,
name|columnMapper
argument_list|,
name|iterators
argument_list|,
name|ranges
argument_list|)
expr_stmt|;
name|int
name|numColumns
init|=
name|columnMappings
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|readColIds
init|=
name|ColumnProjectionUtils
operator|.
name|getReadColumnIDs
argument_list|(
name|jobConf
argument_list|)
decl_stmt|;
comment|// Sanity check
if|if
condition|(
name|numColumns
operator|<
name|readColIds
operator|.
name|size
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Number of column mappings ("
operator|+
name|numColumns
operator|+
literal|")"
operator|+
literal|" numbers less than the hive table columns. ("
operator|+
name|readColIds
operator|.
name|size
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
comment|// get splits from Accumulo
name|InputSplit
index|[]
name|splits
init|=
name|accumuloInputFormat
operator|.
name|getSplits
argument_list|(
name|jobConf
argument_list|,
name|numSplits
argument_list|)
decl_stmt|;
name|HiveAccumuloSplit
index|[]
name|hiveSplits
init|=
operator|new
name|HiveAccumuloSplit
index|[
name|splits
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|splits
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|RangeInputSplit
name|ris
init|=
operator|(
name|RangeInputSplit
operator|)
name|splits
index|[
name|i
index|]
decl_stmt|;
name|hiveSplits
index|[
name|i
index|]
operator|=
operator|new
name|HiveAccumuloSplit
argument_list|(
name|ris
argument_list|,
name|tablePaths
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|hiveSplits
return|;
block|}
catch|catch
parameter_list|(
name|AccumuloException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Could not configure AccumuloInputFormat"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|AccumuloSecurityException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Could not configure AccumuloInputFormat"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|SerDeException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Could not configure AccumuloInputFormat"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|/**    * Setup accumulo input format from conf properties. Delegates to final RecordReader from mapred    * package.    *    * @param inputSplit    * @param jobConf    * @param reporter    * @return RecordReader    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|RecordReader
argument_list|<
name|Text
argument_list|,
name|AccumuloHiveRow
argument_list|>
name|getRecordReader
parameter_list|(
name|InputSplit
name|inputSplit
parameter_list|,
specifier|final
name|JobConf
name|jobConf
parameter_list|,
specifier|final
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ColumnMapper
name|columnMapper
decl_stmt|;
try|try
block|{
name|columnMapper
operator|=
name|getColumnMapper
argument_list|(
name|jobConf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TooManyAccumuloColumnsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
try|try
block|{
specifier|final
name|List
argument_list|<
name|IteratorSetting
argument_list|>
name|iterators
init|=
name|predicateHandler
operator|.
name|getIterators
argument_list|(
name|jobConf
argument_list|,
name|columnMapper
argument_list|)
decl_stmt|;
name|HiveAccumuloSplit
name|hiveSplit
init|=
operator|(
name|HiveAccumuloSplit
operator|)
name|inputSplit
decl_stmt|;
name|RangeInputSplit
name|rangeSplit
init|=
name|hiveSplit
operator|.
name|getSplit
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Split: "
operator|+
name|rangeSplit
argument_list|)
expr_stmt|;
comment|// The RangeInputSplit *should* have all of the necesary information contained in it
comment|// which alleviates us from re-parsing our configuration from the AccumuloStorageHandler
comment|// and re-setting it into the Configuration (like we did in getSplits(...)). Thus, it should
comment|// be unnecessary to re-invoke configure(...)
comment|// ACCUMULO-2962 Iterators weren't getting serialized into the InputSplit, but we can
comment|// compensate because we still have that info.
comment|// Should be fixed in Accumulo 1.5.2 and 1.6.1
if|if
condition|(
literal|null
operator|==
name|rangeSplit
operator|.
name|getIterators
argument_list|()
operator|||
operator|(
name|rangeSplit
operator|.
name|getIterators
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|iterators
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Re-setting iterators on InputSplit due to Accumulo bug."
argument_list|)
expr_stmt|;
name|rangeSplit
operator|.
name|setIterators
argument_list|(
name|iterators
argument_list|)
expr_stmt|;
block|}
comment|// ACCUMULO-3015 Like the above, RangeInputSplit should have the table name
comment|// but we want it to, so just re-set it if it's null.
if|if
condition|(
literal|null
operator|==
name|getTableName
argument_list|(
name|rangeSplit
argument_list|)
condition|)
block|{
specifier|final
name|AccumuloConnectionParameters
name|accumuloParams
init|=
operator|new
name|AccumuloConnectionParameters
argument_list|(
name|jobConf
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Re-setting table name on InputSplit due to Accumulo bug."
argument_list|)
expr_stmt|;
name|setTableName
argument_list|(
name|rangeSplit
argument_list|,
name|accumuloParams
operator|.
name|getAccumuloTableName
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RecordReader
argument_list|<
name|Text
argument_list|,
name|PeekingIterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Key
argument_list|,
name|Value
argument_list|>
argument_list|>
argument_list|>
name|recordReader
init|=
name|accumuloInputFormat
operator|.
name|getRecordReader
argument_list|(
name|rangeSplit
argument_list|,
name|jobConf
argument_list|,
name|reporter
argument_list|)
decl_stmt|;
return|return
operator|new
name|HiveAccumuloRecordReader
argument_list|(
name|recordReader
argument_list|,
name|iterators
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SerDeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|ColumnMapper
name|getColumnMapper
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|TooManyAccumuloColumnsException
block|{
specifier|final
name|String
name|defaultStorageType
init|=
name|conf
operator|.
name|get
argument_list|(
name|AccumuloSerDeParameters
operator|.
name|DEFAULT_STORAGE_TYPE
argument_list|)
decl_stmt|;
name|String
index|[]
name|columnNamesArr
init|=
name|conf
operator|.
name|getStrings
argument_list|(
name|serdeConstants
operator|.
name|LIST_COLUMNS
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|columnNamesArr
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Hive column names must be provided to InputFormat in the Configuration"
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|columnNames
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|columnNamesArr
argument_list|)
decl_stmt|;
name|String
name|serializedTypes
init|=
name|conf
operator|.
name|get
argument_list|(
name|serdeConstants
operator|.
name|LIST_COLUMN_TYPES
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|serializedTypes
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Hive column types must be provided to InputFormat in the Configuration"
argument_list|)
throw|;
block|}
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
name|columnTypes
init|=
name|TypeInfoUtils
operator|.
name|getTypeInfosFromTypeString
argument_list|(
name|serializedTypes
argument_list|)
decl_stmt|;
return|return
operator|new
name|ColumnMapper
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|AccumuloSerDeParameters
operator|.
name|COLUMN_MAPPINGS
argument_list|)
argument_list|,
name|defaultStorageType
argument_list|,
name|columnNames
argument_list|,
name|columnTypes
argument_list|)
return|;
block|}
comment|/**    * Configure the underlying AccumuloInputFormat    *    * @param conf    *          Job configuration    * @param instance    *          Accumulo instance    * @param connector    *          Accumulo connector    * @param accumuloParams    *          Connection information to the Accumulo instance    * @param columnMapper    *          Configuration of Hive to Accumulo columns    * @param iterators    *          Any iterators to be configured server-side    * @param ranges    *          Accumulo ranges on for the query    * @throws AccumuloSecurityException    * @throws AccumuloException    * @throws SerDeException    */
specifier|protected
name|void
name|configure
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|Instance
name|instance
parameter_list|,
name|Connector
name|connector
parameter_list|,
name|AccumuloConnectionParameters
name|accumuloParams
parameter_list|,
name|ColumnMapper
name|columnMapper
parameter_list|,
name|List
argument_list|<
name|IteratorSetting
argument_list|>
name|iterators
parameter_list|,
name|Collection
argument_list|<
name|Range
argument_list|>
name|ranges
parameter_list|)
throws|throws
name|AccumuloSecurityException
throws|,
name|AccumuloException
throws|,
name|SerDeException
block|{
comment|// Handle implementation of Instance and invoke appropriate InputFormat method
if|if
condition|(
name|instance
operator|instanceof
name|MockInstance
condition|)
block|{
name|setMockInstance
argument_list|(
name|conf
argument_list|,
name|instance
operator|.
name|getInstanceName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setZooKeeperInstance
argument_list|(
name|conf
argument_list|,
name|instance
operator|.
name|getInstanceName
argument_list|()
argument_list|,
name|instance
operator|.
name|getZooKeepers
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Set the username/passwd for the Accumulo connection
name|setConnectorInfo
argument_list|(
name|conf
argument_list|,
name|accumuloParams
operator|.
name|getAccumuloUserName
argument_list|()
argument_list|,
operator|new
name|PasswordToken
argument_list|(
name|accumuloParams
operator|.
name|getAccumuloPassword
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Read from the given Accumulo table
name|setInputTableName
argument_list|(
name|conf
argument_list|,
name|accumuloParams
operator|.
name|getAccumuloTableName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Check Configuration for any user-provided Authorization definition
name|Authorizations
name|auths
init|=
name|AccumuloSerDeParameters
operator|.
name|getAuthorizationsFromConf
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|auths
condition|)
block|{
comment|// Default to all of user's authorizations when no configuration is provided
name|auths
operator|=
name|connector
operator|.
name|securityOperations
argument_list|()
operator|.
name|getUserAuthorizations
argument_list|(
name|accumuloParams
operator|.
name|getAccumuloUserName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Implicitly handles users providing invalid authorizations
name|setScanAuthorizations
argument_list|(
name|conf
argument_list|,
name|auths
argument_list|)
expr_stmt|;
comment|// restrict with any filters found from WHERE predicates.
name|addIterators
argument_list|(
name|conf
argument_list|,
name|iterators
argument_list|)
expr_stmt|;
comment|// restrict with any ranges found from WHERE predicates.
comment|// not setting ranges scans the entire table
if|if
condition|(
literal|null
operator|!=
name|ranges
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Setting ranges: "
operator|+
name|ranges
argument_list|)
expr_stmt|;
name|setRanges
argument_list|(
name|conf
argument_list|,
name|ranges
argument_list|)
expr_stmt|;
block|}
comment|// Restrict the set of columns that we want to read from the Accumulo table
name|HashSet
argument_list|<
name|Pair
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|>
name|pairs
init|=
name|getPairCollection
argument_list|(
name|columnMapper
operator|.
name|getColumnMappings
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|pairs
operator|&&
operator|!
name|pairs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fetchColumns
argument_list|(
name|conf
argument_list|,
name|pairs
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Wrap the static AccumuloInputFormat methods with methods that we can
comment|// verify were correctly called via Mockito
specifier|protected
name|void
name|setMockInstance
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|String
name|instanceName
parameter_list|)
block|{
try|try
block|{
name|AccumuloInputFormat
operator|.
name|setMockInstance
argument_list|(
name|conf
argument_list|,
name|instanceName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|e
parameter_list|)
block|{
comment|// AccumuloInputFormat complains if you re-set an already set value. We just don't care.
name|log
operator|.
name|debug
argument_list|(
literal|"Ignoring exception setting mock instance of "
operator|+
name|instanceName
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|protected
name|void
name|setZooKeeperInstance
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|String
name|instanceName
parameter_list|,
name|String
name|zkHosts
parameter_list|)
block|{
comment|// To support builds against 1.5, we can't use the new 1.6 setZooKeeperInstance which
comment|// takes a ClientConfiguration class that only exists in 1.6
try|try
block|{
name|AccumuloInputFormat
operator|.
name|setZooKeeperInstance
argument_list|(
name|conf
argument_list|,
name|instanceName
argument_list|,
name|zkHosts
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|ise
parameter_list|)
block|{
comment|// AccumuloInputFormat complains if you re-set an already set value. We just don't care.
name|log
operator|.
name|debug
argument_list|(
literal|"Ignoring exception setting ZooKeeper instance of "
operator|+
name|instanceName
operator|+
literal|" at "
operator|+
name|zkHosts
argument_list|,
name|ise
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|setConnectorInfo
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|String
name|user
parameter_list|,
name|AuthenticationToken
name|token
parameter_list|)
throws|throws
name|AccumuloSecurityException
block|{
try|try
block|{
name|AccumuloInputFormat
operator|.
name|setConnectorInfo
argument_list|(
name|conf
argument_list|,
name|user
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|e
parameter_list|)
block|{
comment|// AccumuloInputFormat complains if you re-set an already set value. We just don't care.
name|log
operator|.
name|debug
argument_list|(
literal|"Ignoring exception setting Accumulo Connector instance for user "
operator|+
name|user
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|setInputTableName
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|String
name|tableName
parameter_list|)
block|{
name|AccumuloInputFormat
operator|.
name|setInputTableName
argument_list|(
name|conf
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|setScanAuthorizations
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|Authorizations
name|auths
parameter_list|)
block|{
name|AccumuloInputFormat
operator|.
name|setScanAuthorizations
argument_list|(
name|conf
argument_list|,
name|auths
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|addIterators
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|List
argument_list|<
name|IteratorSetting
argument_list|>
name|iterators
parameter_list|)
block|{
for|for
control|(
name|IteratorSetting
name|is
range|:
name|iterators
control|)
block|{
name|AccumuloInputFormat
operator|.
name|addIterator
argument_list|(
name|conf
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|setRanges
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|Collection
argument_list|<
name|Range
argument_list|>
name|ranges
parameter_list|)
block|{
name|AccumuloInputFormat
operator|.
name|setRanges
argument_list|(
name|conf
argument_list|,
name|ranges
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|fetchColumns
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|Set
argument_list|<
name|Pair
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|>
name|cfCqPairs
parameter_list|)
block|{
name|AccumuloInputFormat
operator|.
name|fetchColumns
argument_list|(
name|conf
argument_list|,
name|cfCqPairs
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create col fam/qual pairs from pipe separated values, usually from config object. Ignores    * rowID.    *    * @param columnMappings    *          The list of ColumnMappings for the given query    * @return a Set of Pairs of colfams and colquals    */
specifier|protected
name|HashSet
argument_list|<
name|Pair
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|>
name|getPairCollection
parameter_list|(
name|List
argument_list|<
name|ColumnMapping
argument_list|>
name|columnMappings
parameter_list|)
block|{
specifier|final
name|HashSet
argument_list|<
name|Pair
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|HashSet
argument_list|<
name|Pair
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnMapping
name|columnMapping
range|:
name|columnMappings
control|)
block|{
if|if
condition|(
name|columnMapping
operator|instanceof
name|HiveAccumuloColumnMapping
condition|)
block|{
name|HiveAccumuloColumnMapping
name|accumuloColumnMapping
init|=
operator|(
name|HiveAccumuloColumnMapping
operator|)
name|columnMapping
decl_stmt|;
name|Text
name|cf
init|=
operator|new
name|Text
argument_list|(
name|accumuloColumnMapping
operator|.
name|getColumnFamily
argument_list|()
argument_list|)
decl_stmt|;
name|Text
name|cq
init|=
literal|null
decl_stmt|;
comment|// A null cq implies an empty column qualifier
if|if
condition|(
literal|null
operator|!=
name|accumuloColumnMapping
operator|.
name|getColumnQualifier
argument_list|()
condition|)
block|{
name|cq
operator|=
operator|new
name|Text
argument_list|(
name|accumuloColumnMapping
operator|.
name|getColumnQualifier
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|Pair
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|(
name|cf
argument_list|,
name|cq
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|columnMapping
operator|instanceof
name|HiveAccumuloMapColumnMapping
condition|)
block|{
name|HiveAccumuloMapColumnMapping
name|mapMapping
init|=
operator|(
name|HiveAccumuloMapColumnMapping
operator|)
name|columnMapping
decl_stmt|;
comment|// Can't fetch prefix on colqual, must pull the entire qualifier
comment|// TODO use an iterator to do the filter, server-side.
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|Pair
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|(
operator|new
name|Text
argument_list|(
name|mapMapping
operator|.
name|getColumnFamily
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Computed columns to fetch ("
operator|+
name|pairs
operator|+
literal|") from "
operator|+
name|columnMappings
argument_list|)
expr_stmt|;
return|return
name|pairs
return|;
block|}
comment|/**    * Reflection to work around Accumulo 1.5 and 1.6 incompatibilities. Throws an {@link IOException}    * for any reflection related exceptions    *    * @param split    *          A RangeInputSplit    * @return The name of the table from the split    * @throws IOException    */
specifier|protected
name|String
name|getTableName
parameter_list|(
name|RangeInputSplit
name|split
parameter_list|)
throws|throws
name|IOException
block|{
comment|// ACCUMULO-3017 shenanigans with method names changing without deprecation
name|Method
name|getTableName
init|=
literal|null
decl_stmt|;
try|try
block|{
name|getTableName
operator|=
name|RangeInputSplit
operator|.
name|class
operator|.
name|getMethod
argument_list|(
literal|"getTableName"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Could not get getTableName method from RangeInputSplit"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Could not get getTableName method from RangeInputSplit"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|!=
name|getTableName
condition|)
block|{
try|try
block|{
return|return
operator|(
name|String
operator|)
name|getTableName
operator|.
name|invoke
argument_list|(
name|split
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Could not invoke getTableName method from RangeInputSplit"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Could not invoke getTableName method from RangeInputSplit"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Could not invoke getTableName method from RangeInputSplit"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|Method
name|getTable
decl_stmt|;
try|try
block|{
name|getTable
operator|=
name|RangeInputSplit
operator|.
name|class
operator|.
name|getMethod
argument_list|(
literal|"getTable"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not get table name from RangeInputSplit"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not get table name from RangeInputSplit"
argument_list|,
name|e
argument_list|)
throw|;
block|}
try|try
block|{
return|return
operator|(
name|String
operator|)
name|getTable
operator|.
name|invoke
argument_list|(
name|split
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not get table name from RangeInputSplit"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not get table name from RangeInputSplit"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not get table name from RangeInputSplit"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Sets the table name on a RangeInputSplit, accounting for change in method name. Any reflection    * related exception is wrapped in an {@link IOException}    *    * @param split    *          The RangeInputSplit to operate on    * @param tableName    *          The name of the table to set    * @throws IOException    */
specifier|protected
name|void
name|setTableName
parameter_list|(
name|RangeInputSplit
name|split
parameter_list|,
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
comment|// ACCUMULO-3017 shenanigans with method names changing without deprecation
name|Method
name|setTableName
init|=
literal|null
decl_stmt|;
try|try
block|{
name|setTableName
operator|=
name|RangeInputSplit
operator|.
name|class
operator|.
name|getMethod
argument_list|(
literal|"setTableName"
argument_list|,
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Could not get getTableName method from RangeInputSplit"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Could not get getTableName method from RangeInputSplit"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|!=
name|setTableName
condition|)
block|{
try|try
block|{
name|setTableName
operator|.
name|invoke
argument_list|(
name|split
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Could not invoke getTableName method from RangeInputSplit"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Could not invoke getTableName method from RangeInputSplit"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Could not invoke getTableName method from RangeInputSplit"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|Method
name|setTable
decl_stmt|;
try|try
block|{
name|setTable
operator|=
name|RangeInputSplit
operator|.
name|class
operator|.
name|getMethod
argument_list|(
literal|"setTable"
argument_list|,
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not set table name from RangeInputSplit"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not set table name from RangeInputSplit"
argument_list|,
name|e
argument_list|)
throw|;
block|}
try|try
block|{
name|setTable
operator|.
name|invoke
argument_list|(
name|split
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not set table name from RangeInputSplit"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not set table name from RangeInputSplit"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not set table name from RangeInputSplit"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

