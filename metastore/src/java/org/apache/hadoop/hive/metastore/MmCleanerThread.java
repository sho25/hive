begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ValidWriteIds
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|RawStore
operator|.
name|FullTableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|MetaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|model
operator|.
name|MTableWrite
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Supplier
import|;
end_import

begin_class
specifier|public
class|class
name|MmCleanerThread
extends|extends
name|Thread
implements|implements
name|MetaStoreThread
block|{
specifier|private
specifier|final
specifier|static
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MmCleanerThread
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|HiveConf
name|conf
decl_stmt|;
specifier|private
name|int
name|threadId
decl_stmt|;
specifier|private
name|AtomicBoolean
name|stop
decl_stmt|;
specifier|private
name|long
name|intervalMs
decl_stmt|;
specifier|private
name|long
name|heartbeatTimeoutMs
decl_stmt|,
name|absTimeoutMs
decl_stmt|,
name|abortedGraceMs
decl_stmt|;
comment|/** Time override for tests. Only used for MM timestamp logic, not for the thread timing. */
specifier|private
name|Supplier
argument_list|<
name|Long
argument_list|>
name|timeOverride
init|=
literal|null
decl_stmt|;
specifier|public
name|MmCleanerThread
parameter_list|(
name|long
name|intervalMs
parameter_list|)
block|{
name|this
operator|.
name|intervalMs
operator|=
name|intervalMs
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
name|void
name|overrideTime
parameter_list|(
name|Supplier
argument_list|<
name|Long
argument_list|>
name|timeOverride
parameter_list|)
block|{
name|this
operator|.
name|timeOverride
operator|=
name|timeOverride
expr_stmt|;
block|}
specifier|private
name|long
name|getTimeMs
parameter_list|()
block|{
return|return
name|timeOverride
operator|==
literal|null
condition|?
name|System
operator|.
name|currentTimeMillis
argument_list|()
else|:
name|timeOverride
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setHiveConf
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|heartbeatTimeoutMs
operator|=
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_METASTORE_MM_HEARTBEAT_TIMEOUT
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|absTimeoutMs
operator|=
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_METASTORE_MM_ABSOLUTE_TIMEOUT
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|abortedGraceMs
operator|=
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_METASTORE_MM_ABORTED_GRACE_PERIOD
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|heartbeatTimeoutMs
operator|>
name|absTimeoutMs
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Heartbeat timeout "
operator|+
name|heartbeatTimeoutMs
operator|+
literal|" cannot be larger than the absolute timeout "
operator|+
name|absTimeoutMs
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|setThreadId
parameter_list|(
name|int
name|threadId
parameter_list|)
block|{
name|this
operator|.
name|threadId
operator|=
name|threadId
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|init
parameter_list|(
name|AtomicBoolean
name|stop
parameter_list|,
name|AtomicBoolean
name|looped
parameter_list|)
throws|throws
name|MetaException
block|{
name|this
operator|.
name|stop
operator|=
name|stop
expr_stmt|;
name|setPriority
argument_list|(
name|MIN_PRIORITY
argument_list|)
expr_stmt|;
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// Only get RS here, when we are already on the thread.
name|RawStore
name|rs
init|=
name|getRs
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|checkStop
argument_list|()
condition|)
return|return;
name|long
name|endTimeNs
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
name|intervalMs
operator|*
literal|1000000L
decl_stmt|;
name|runOneIteration
argument_list|(
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|checkStop
argument_list|()
condition|)
return|return;
name|long
name|waitTimeMs
init|=
operator|(
name|endTimeNs
operator|-
name|System
operator|.
name|nanoTime
argument_list|()
operator|)
operator|/
literal|1000000L
decl_stmt|;
if|if
condition|(
name|waitTimeMs
operator|<=
literal|0
condition|)
continue|continue;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|waitTimeMs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Thread was interrupted and will now exit"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
specifier|private
name|RawStore
name|getRs
parameter_list|()
block|{
try|try
block|{
return|return
name|RawStoreProxy
operator|.
name|getProxy
argument_list|(
name|conf
argument_list|,
name|conf
argument_list|,
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTORE_RAW_STORE_IMPL
argument_list|)
argument_list|,
name|threadId
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|MetaException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to get RawStore; the thread will now die"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|boolean
name|checkStop
parameter_list|()
block|{
if|if
condition|(
operator|!
name|stop
operator|.
name|get
argument_list|()
condition|)
return|return
literal|false
return|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping due to an external request"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|VisibleForTesting
name|void
name|runOneIteration
parameter_list|(
name|RawStore
name|rs
parameter_list|)
block|{
comment|// We only get the names here; we want to get and process each table in a separate DB txn.
name|List
argument_list|<
name|FullTableName
argument_list|>
name|mmTables
init|=
literal|null
decl_stmt|;
try|try
block|{
name|mmTables
operator|=
name|rs
operator|.
name|getAllMmTablesForCleanup
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MetaException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to get tables"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|FullTableName
name|tableName
range|:
name|mmTables
control|)
block|{
try|try
block|{
name|processOneTable
argument_list|(
name|tableName
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MetaException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to process "
operator|+
name|tableName
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|processOneTable
parameter_list|(
name|FullTableName
name|table
parameter_list|,
name|RawStore
name|rs
parameter_list|)
throws|throws
name|MetaException
block|{
comment|// 1. Time out writes that have been running for a while.
comment|//    a) Heartbeat timeouts (not enabled right now as heartbeat is not implemented).
comment|//    b) Absolute timeouts.
comment|//    c) Gaps that have the next ID and the derived absolute timeout. This is a small special
comment|//       case that can happen if we increment next ID but fail to insert the write ID record,
comment|//       which we do in separate txns to avoid making the conflict-prone increment txn longer.
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing table "
operator|+
name|table
argument_list|)
expr_stmt|;
name|Table
name|t
init|=
name|rs
operator|.
name|getTable
argument_list|(
name|table
operator|.
name|dbName
argument_list|,
name|table
operator|.
name|tblName
argument_list|)
decl_stmt|;
name|HashSet
argument_list|<
name|Long
argument_list|>
name|removeWriteIds
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|,
name|cleanupOnlyWriteIds
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|getWritesThatReadyForCleanUp
argument_list|(
name|t
argument_list|,
name|table
argument_list|,
name|rs
argument_list|,
name|removeWriteIds
argument_list|,
name|cleanupOnlyWriteIds
argument_list|)
expr_stmt|;
comment|// 2. Delete the aborted writes' files from the FS.
name|deleteAbortedWriteIdFiles
argument_list|(
name|table
argument_list|,
name|rs
argument_list|,
name|t
argument_list|,
name|removeWriteIds
argument_list|)
expr_stmt|;
name|deleteAbortedWriteIdFiles
argument_list|(
name|table
argument_list|,
name|rs
argument_list|,
name|t
argument_list|,
name|cleanupOnlyWriteIds
argument_list|)
expr_stmt|;
comment|// removeWriteIds-s now only contains the writes that were fully cleaned up after.
comment|// 3. Advance the watermark.
name|advanceWatermark
argument_list|(
name|table
argument_list|,
name|rs
argument_list|,
name|removeWriteIds
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|getWritesThatReadyForCleanUp
parameter_list|(
name|Table
name|t
parameter_list|,
name|FullTableName
name|table
parameter_list|,
name|RawStore
name|rs
parameter_list|,
name|HashSet
argument_list|<
name|Long
argument_list|>
name|removeWriteIds
parameter_list|,
name|HashSet
argument_list|<
name|Long
argument_list|>
name|cleanupOnlyWriteIds
parameter_list|)
throws|throws
name|MetaException
block|{
comment|// We will generally ignore errors here. First, we expect some conflicts; second, we will get
comment|// the final view of things after we do (or try, at any rate) all the updates.
name|long
name|watermarkId
init|=
name|t
operator|.
name|isSetMmWatermarkWriteId
argument_list|()
condition|?
name|t
operator|.
name|getMmWatermarkWriteId
argument_list|()
else|:
operator|-
literal|1
decl_stmt|,
name|nextWriteId
init|=
name|t
operator|.
name|isSetMmNextWriteId
argument_list|()
condition|?
name|t
operator|.
name|getMmNextWriteId
argument_list|()
else|:
literal|0
decl_stmt|;
name|long
name|now
init|=
name|getTimeMs
argument_list|()
decl_stmt|,
name|earliestOkHeartbeatMs
init|=
name|now
operator|-
name|heartbeatTimeoutMs
decl_stmt|,
name|earliestOkCreateMs
init|=
name|now
operator|-
name|absTimeoutMs
decl_stmt|,
name|latestAbortedMs
init|=
name|now
operator|-
name|abortedGraceMs
decl_stmt|;
name|List
argument_list|<
name|MTableWrite
argument_list|>
name|writes
init|=
name|rs
operator|.
name|getTableWrites
argument_list|(
name|table
operator|.
name|dbName
argument_list|,
name|table
operator|.
name|tblName
argument_list|,
name|watermarkId
argument_list|,
name|nextWriteId
argument_list|)
decl_stmt|;
name|ListIterator
argument_list|<
name|MTableWrite
argument_list|>
name|iter
init|=
name|writes
operator|.
name|listIterator
argument_list|(
name|writes
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|expectedId
init|=
operator|-
literal|1
decl_stmt|,
name|nextCreated
init|=
operator|-
literal|1
decl_stmt|;
comment|// We will go in reverse order and add aborted writes for the gaps that have a following
comment|// write ID that would imply that the previous one (created earlier) would have already
comment|// expired, had it been open and not updated.
while|while
condition|(
name|iter
operator|.
name|hasPrevious
argument_list|()
condition|)
block|{
name|MTableWrite
name|write
init|=
name|iter
operator|.
name|previous
argument_list|()
decl_stmt|;
name|addTimedOutMissingWriteIds
argument_list|(
name|rs
argument_list|,
name|table
operator|.
name|dbName
argument_list|,
name|table
operator|.
name|tblName
argument_list|,
name|write
operator|.
name|getWriteId
argument_list|()
argument_list|,
name|nextCreated
argument_list|,
name|expectedId
argument_list|,
name|earliestOkHeartbeatMs
argument_list|,
name|cleanupOnlyWriteIds
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|expectedId
operator|=
name|write
operator|.
name|getWriteId
argument_list|()
operator|-
literal|1
expr_stmt|;
name|nextCreated
operator|=
name|write
operator|.
name|getCreated
argument_list|()
expr_stmt|;
name|char
name|state
init|=
name|write
operator|.
name|getState
argument_list|()
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|HiveMetaStore
operator|.
name|MM_WRITE_ABORTED
condition|)
block|{
if|if
condition|(
name|write
operator|.
name|getLastHeartbeat
argument_list|()
operator|<
name|latestAbortedMs
condition|)
block|{
name|removeWriteIds
operator|.
name|add
argument_list|(
name|write
operator|.
name|getWriteId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cleanupOnlyWriteIds
operator|.
name|add
argument_list|(
name|write
operator|.
name|getWriteId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|HiveMetaStore
operator|.
name|MM_WRITE_OPEN
operator|&&
name|write
operator|.
name|getCreated
argument_list|()
operator|<
name|earliestOkCreateMs
condition|)
block|{
comment|// TODO: also check for heartbeat here.
if|if
condition|(
name|expireTimedOutWriteId
argument_list|(
name|rs
argument_list|,
name|table
operator|.
name|dbName
argument_list|,
name|table
operator|.
name|tblName
argument_list|,
name|write
operator|.
name|getWriteId
argument_list|()
argument_list|,
name|now
argument_list|,
name|earliestOkCreateMs
argument_list|,
name|earliestOkHeartbeatMs
argument_list|,
name|cleanupOnlyWriteIds
argument_list|)
condition|)
block|{
name|cleanupOnlyWriteIds
operator|.
name|add
argument_list|(
name|write
operator|.
name|getWriteId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|addTimedOutMissingWriteIds
argument_list|(
name|rs
argument_list|,
name|table
operator|.
name|dbName
argument_list|,
name|table
operator|.
name|tblName
argument_list|,
name|watermarkId
argument_list|,
name|nextCreated
argument_list|,
name|expectedId
argument_list|,
name|earliestOkHeartbeatMs
argument_list|,
name|cleanupOnlyWriteIds
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|advanceWatermark
parameter_list|(
name|FullTableName
name|table
parameter_list|,
name|RawStore
name|rs
parameter_list|,
name|HashSet
argument_list|<
name|Long
argument_list|>
name|cleanedUpWriteIds
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rs
operator|.
name|openTransaction
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot open transaction"
argument_list|)
expr_stmt|;
return|return;
block|}
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|Table
name|t
init|=
name|rs
operator|.
name|getTable
argument_list|(
name|table
operator|.
name|dbName
argument_list|,
name|table
operator|.
name|tblName
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|long
name|watermarkId
init|=
name|t
operator|.
name|getMmWatermarkWriteId
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|writeIds
init|=
name|rs
operator|.
name|getTableWriteIds
argument_list|(
name|table
operator|.
name|dbName
argument_list|,
name|table
operator|.
name|tblName
argument_list|,
name|watermarkId
argument_list|,
name|t
operator|.
name|getMmNextWriteId
argument_list|()
argument_list|,
name|HiveMetaStore
operator|.
name|MM_WRITE_COMMITTED
argument_list|)
decl_stmt|;
name|long
name|expectedId
init|=
name|watermarkId
operator|+
literal|1
decl_stmt|;
name|boolean
name|hasGap
init|=
literal|false
decl_stmt|;
name|Iterator
argument_list|<
name|Long
argument_list|>
name|idIter
init|=
name|writeIds
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|idIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|long
name|next
init|=
name|idIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|next
operator|<
name|expectedId
condition|)
continue|continue;
while|while
condition|(
name|next
operator|>
name|expectedId
condition|)
block|{
if|if
condition|(
operator|!
name|cleanedUpWriteIds
operator|.
name|contains
argument_list|(
name|expectedId
argument_list|)
condition|)
block|{
name|hasGap
operator|=
literal|true
expr_stmt|;
break|break;
block|}
operator|++
name|expectedId
expr_stmt|;
block|}
if|if
condition|(
name|hasGap
condition|)
break|break;
operator|++
name|expectedId
expr_stmt|;
block|}
comment|// Make sure we also advance over the trailing aborted ones.
if|if
condition|(
operator|!
name|hasGap
condition|)
block|{
while|while
condition|(
name|cleanedUpWriteIds
operator|.
name|contains
argument_list|(
name|expectedId
argument_list|)
condition|)
block|{
operator|++
name|expectedId
expr_stmt|;
block|}
block|}
name|long
name|newWatermarkId
init|=
name|expectedId
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|newWatermarkId
operator|>
name|watermarkId
condition|)
block|{
name|t
operator|.
name|setMmWatermarkWriteId
argument_list|(
name|newWatermarkId
argument_list|)
expr_stmt|;
name|rs
operator|.
name|alterTable
argument_list|(
name|table
operator|.
name|dbName
argument_list|,
name|table
operator|.
name|tblName
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|rs
operator|.
name|deleteTableWrites
argument_list|(
name|table
operator|.
name|dbName
argument_list|,
name|table
operator|.
name|tblName
argument_list|,
operator|-
literal|1
argument_list|,
name|expectedId
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
comment|// TODO: should we try a couple times on conflicts? Aborted writes cannot be unaborted.
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to advance watermark"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|rs
operator|.
name|rollbackTransaction
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|tryCommit
argument_list|(
name|rs
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|deleteAbortedWriteIdFiles
parameter_list|(
name|FullTableName
name|table
parameter_list|,
name|RawStore
name|rs
parameter_list|,
name|Table
name|t
parameter_list|,
name|HashSet
argument_list|<
name|Long
argument_list|>
name|cleanUpWriteIds
parameter_list|)
block|{
if|if
condition|(
name|cleanUpWriteIds
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
name|t
operator|.
name|getPartitionKeysSize
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|String
name|location
range|:
name|rs
operator|.
name|getAllPartitionLocations
argument_list|(
name|table
operator|.
name|dbName
argument_list|,
name|table
operator|.
name|tblName
argument_list|)
control|)
block|{
name|deleteAbortedWriteIdFiles
argument_list|(
name|location
argument_list|,
name|cleanUpWriteIds
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|deleteAbortedWriteIdFiles
argument_list|(
name|t
operator|.
name|getSd
argument_list|()
operator|.
name|getLocation
argument_list|()
argument_list|,
name|cleanUpWriteIds
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|deleteAbortedWriteIdFiles
parameter_list|(
name|String
name|location
parameter_list|,
name|HashSet
argument_list|<
name|Long
argument_list|>
name|abortedWriteIds
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Looking for "
operator|+
name|abortedWriteIds
operator|.
name|size
argument_list|()
operator|+
literal|" aborted write output in "
operator|+
name|location
argument_list|)
expr_stmt|;
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|location
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
decl_stmt|;
name|FileStatus
index|[]
name|files
decl_stmt|;
try|try
block|{
name|fs
operator|=
name|path
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|path
operator|+
literal|" does not exist; assuming that the cleanup is not needed."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// TODO# do we need to account for any subdirectories here? decide after special-case jiras
name|files
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to get files for "
operator|+
name|path
operator|+
literal|"; cannot ensure cleanup for any writes"
argument_list|)
expr_stmt|;
name|abortedWriteIds
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
for|for
control|(
name|FileStatus
name|file
range|:
name|files
control|)
block|{
name|Path
name|childPath
init|=
name|file
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Skipping a non-directory file "
operator|+
name|childPath
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Long
name|writeId
init|=
name|ValidWriteIds
operator|.
name|extractWriteId
argument_list|(
name|childPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|writeId
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Skipping an unknown directory "
operator|+
name|childPath
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|abortedWriteIds
operator|.
name|contains
argument_list|(
name|writeId
operator|.
name|longValue
argument_list|()
argument_list|)
condition|)
continue|continue;
try|try
block|{
if|if
condition|(
operator|!
name|fs
operator|.
name|delete
argument_list|(
name|childPath
argument_list|,
literal|true
argument_list|)
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"delete returned false"
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Couldn't delete "
operator|+
name|childPath
operator|+
literal|"; not cleaning up "
operator|+
name|writeId
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|abortedWriteIds
operator|.
name|remove
argument_list|(
name|writeId
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|boolean
name|expireTimedOutWriteId
parameter_list|(
name|RawStore
name|rs
parameter_list|,
name|String
name|dbName
parameter_list|,
name|String
name|tblName
parameter_list|,
name|long
name|writeId
parameter_list|,
name|long
name|now
parameter_list|,
name|long
name|earliestOkCreatedMs
parameter_list|,
name|long
name|earliestOkHeartbeatMs
parameter_list|,
name|HashSet
argument_list|<
name|Long
argument_list|>
name|cleanupOnlyWriteIds
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rs
operator|.
name|openTransaction
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
try|try
block|{
name|MTableWrite
name|tw
init|=
name|rs
operator|.
name|getTableWrite
argument_list|(
name|dbName
argument_list|,
name|tblName
argument_list|,
name|writeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|tw
operator|==
literal|null
condition|)
block|{
comment|// The write have been updated since the time when we thought it has expired.
name|tryCommit
argument_list|(
name|rs
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|char
name|state
init|=
name|tw
operator|.
name|getState
argument_list|()
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|!=
name|HiveMetaStore
operator|.
name|MM_WRITE_OPEN
operator|||
operator|(
name|tw
operator|.
name|getCreated
argument_list|()
operator|>
name|earliestOkCreatedMs
operator|&&
name|tw
operator|.
name|getLastHeartbeat
argument_list|()
operator|>
name|earliestOkHeartbeatMs
operator|)
condition|)
block|{
name|tryCommit
argument_list|(
name|rs
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
comment|// The write has been updated since the time when we thought it has expired.
block|}
name|tw
operator|.
name|setState
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|HiveMetaStore
operator|.
name|MM_WRITE_ABORTED
argument_list|)
argument_list|)
expr_stmt|;
name|tw
operator|.
name|setLastHeartbeat
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|rs
operator|.
name|updateTableWrite
argument_list|(
name|tw
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to update an expired table write"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|rs
operator|.
name|rollbackTransaction
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|boolean
name|result
init|=
name|tryCommit
argument_list|(
name|rs
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|cleanupOnlyWriteIds
operator|.
name|add
argument_list|(
name|writeId
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|private
name|boolean
name|tryCommit
parameter_list|(
name|RawStore
name|rs
parameter_list|)
block|{
try|try
block|{
return|return
name|rs
operator|.
name|commitTransaction
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to commit transaction"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
specifier|private
name|boolean
name|addTimedOutMissingWriteIds
parameter_list|(
name|RawStore
name|rs
parameter_list|,
name|String
name|dbName
parameter_list|,
name|String
name|tblName
parameter_list|,
name|long
name|foundPrevId
parameter_list|,
name|long
name|nextCreated
parameter_list|,
name|long
name|expectedId
parameter_list|,
name|long
name|earliestOkHeartbeatMs
parameter_list|,
name|HashSet
argument_list|<
name|Long
argument_list|>
name|cleanupOnlyWriteIds
parameter_list|,
name|long
name|now
parameter_list|)
throws|throws
name|MetaException
block|{
comment|// Assume all missing ones are created at the same time as the next present write ID.
comment|// We also assume missing writes never had any heartbeats.
if|if
condition|(
name|nextCreated
operator|>=
name|earliestOkHeartbeatMs
operator|||
name|expectedId
operator|<
literal|0
condition|)
return|return
literal|true
return|;
name|Table
name|t
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|localCleanupOnlyWriteIds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|foundPrevId
operator|<
name|expectedId
condition|)
block|{
if|if
condition|(
name|t
operator|==
literal|null
operator|&&
operator|!
name|rs
operator|.
name|openTransaction
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot open transaction; skipping"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
try|try
block|{
if|if
condition|(
name|t
operator|==
literal|null
condition|)
block|{
name|t
operator|=
name|rs
operator|.
name|getTable
argument_list|(
name|dbName
argument_list|,
name|tblName
argument_list|)
expr_stmt|;
block|}
comment|// We don't need to double check if the write exists; the unique index will cause an error.
name|rs
operator|.
name|createTableWrite
argument_list|(
name|t
argument_list|,
name|expectedId
argument_list|,
name|HiveMetaStore
operator|.
name|MM_WRITE_ABORTED
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
comment|// TODO: don't log conflict exceptions?.. although we barely ever expect them.
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to create a missing table write"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|rs
operator|.
name|rollbackTransaction
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|localCleanupOnlyWriteIds
operator|.
name|add
argument_list|(
name|expectedId
argument_list|)
expr_stmt|;
operator|--
name|expectedId
expr_stmt|;
block|}
name|boolean
name|result
init|=
operator|(
name|t
operator|==
literal|null
operator|||
name|tryCommit
argument_list|(
name|rs
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|cleanupOnlyWriteIds
operator|.
name|addAll
argument_list|(
name|localCleanupOnlyWriteIds
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
end_class

end_unit

