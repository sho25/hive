begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
operator|.
name|join
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
operator|.
name|repeat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jdo
operator|.
name|PersistenceManager
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jdo
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jdo
operator|.
name|Transaction
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jdo
operator|.
name|datastore
operator|.
name|JDOConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|AggregateStatsCache
operator|.
name|AggrColStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|AggrStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ColumnStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ColumnStatisticsData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ColumnStatisticsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ColumnStatisticsObj
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Database
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|MetaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Order
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Partition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|PrincipalType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLForeignKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLPrimaryKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SerDeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SkewedInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|StorageDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|model
operator|.
name|MConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|model
operator|.
name|MDatabase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|model
operator|.
name|MPartitionColumnStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|model
operator|.
name|MTableColumnStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|parser
operator|.
name|ExpressionTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|parser
operator|.
name|ExpressionTree
operator|.
name|FilterBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|parser
operator|.
name|ExpressionTree
operator|.
name|LeafNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|parser
operator|.
name|ExpressionTree
operator|.
name|LogicalOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|parser
operator|.
name|ExpressionTree
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|parser
operator|.
name|ExpressionTree
operator|.
name|TreeNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|parser
operator|.
name|ExpressionTree
operator|.
name|TreeVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|serdeConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|common
operator|.
name|util
operator|.
name|BloomFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|datanucleus
operator|.
name|store
operator|.
name|rdbms
operator|.
name|query
operator|.
name|ForwardQueryResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * This class contains the optimizations for MetaStore that rely on direct SQL access to  * the underlying database. It should use ANSI SQL and be compatible with common databases  * such as MySQL (note that MySQL doesn't use full ANSI mode by default), Postgres, etc.  *  * As of now, only the partition retrieval is done this way to improve job startup time;  * JDOQL partition retrieval is still present so as not to limit the ORM solution we have  * to SQL stores only. There's always a way to do without direct SQL.  */
end_comment

begin_class
class|class
name|MetaStoreDirectSql
block|{
specifier|private
specifier|static
specifier|final
name|int
name|NO_BATCHING
init|=
operator|-
literal|1
decl_stmt|,
name|DETECT_BATCHING
init|=
literal|0
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MetaStoreDirectSql
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|PersistenceManager
name|pm
decl_stmt|;
comment|/**    * We want to avoid db-specific code in this class and stick with ANSI SQL. However:    * 1) mysql and postgres are differently ansi-incompatible (mysql by default doesn't support    * quoted identifiers, and postgres contravenes ANSI by coercing unquoted ones to lower case).    * MySQL's way of working around this is simpler (just set ansi quotes mode on), so we will    * use that. MySQL detection is done by actually issuing the set-ansi-quotes command;    *    * Use sparingly, we don't want to devolve into another DataNucleus...    */
specifier|private
specifier|final
name|DatabaseProduct
name|dbType
decl_stmt|;
specifier|private
specifier|final
name|int
name|batchSize
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|convertMapNullsToEmptyStrings
decl_stmt|;
specifier|private
specifier|final
name|String
name|defaultPartName
decl_stmt|;
comment|/**    * Whether direct SQL can be used with the current datastore backing {@link #pm}.    */
specifier|private
specifier|final
name|boolean
name|isCompatibleDatastore
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|isAggregateStatsCacheEnabled
decl_stmt|;
specifier|private
name|AggregateStatsCache
name|aggrStatsCache
decl_stmt|;
specifier|public
name|MetaStoreDirectSql
parameter_list|(
name|PersistenceManager
name|pm
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|DatabaseProduct
name|dbType
parameter_list|)
block|{
name|this
operator|.
name|pm
operator|=
name|pm
expr_stmt|;
name|this
operator|.
name|dbType
operator|=
name|dbType
expr_stmt|;
name|int
name|batchSize
init|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|METASTORE_DIRECT_SQL_PARTITION_BATCH_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|batchSize
operator|==
name|DETECT_BATCHING
condition|)
block|{
name|batchSize
operator|=
name|DatabaseProduct
operator|.
name|needsInBatching
argument_list|(
name|dbType
argument_list|)
condition|?
literal|1000
else|:
name|NO_BATCHING
expr_stmt|;
block|}
name|this
operator|.
name|batchSize
operator|=
name|batchSize
expr_stmt|;
name|convertMapNullsToEmptyStrings
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|METASTORE_ORM_RETRIEVE_MAPNULLS_AS_EMPTY_STRINGS
argument_list|)
expr_stmt|;
name|defaultPartName
operator|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|DEFAULTPARTITIONNAME
argument_list|)
expr_stmt|;
name|String
name|jdoIdFactory
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|METASTORE_IDENTIFIER_FACTORY
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
literal|"datanucleus1"
operator|.
name|equalsIgnoreCase
argument_list|(
name|jdoIdFactory
argument_list|)
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Underlying metastore does not use 'datanucleus1' for its ORM naming scheme."
operator|+
literal|" Disabling directSQL as it uses hand-hardcoded SQL with that assumption."
argument_list|)
expr_stmt|;
name|isCompatibleDatastore
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|isCompatibleDatastore
operator|=
name|ensureDbInit
argument_list|()
operator|&&
name|runTestQuery
argument_list|()
expr_stmt|;
if|if
condition|(
name|isCompatibleDatastore
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Using direct SQL, underlying DB is "
operator|+
name|dbType
argument_list|)
expr_stmt|;
block|}
block|}
name|isAggregateStatsCacheEnabled
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|METASTORE_AGGREGATE_STATS_CACHE_ENABLED
argument_list|)
expr_stmt|;
if|if
condition|(
name|isAggregateStatsCacheEnabled
condition|)
block|{
name|aggrStatsCache
operator|=
name|AggregateStatsCache
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|String
name|getProductName
parameter_list|()
block|{
name|JDOConnection
name|jdoConn
init|=
name|pm
operator|.
name|getDataStoreConnection
argument_list|()
decl_stmt|;
try|try
block|{
return|return
operator|(
operator|(
name|Connection
operator|)
name|jdoConn
operator|.
name|getNativeConnection
argument_list|()
operator|)
operator|.
name|getMetaData
argument_list|()
operator|.
name|getDatabaseProductName
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error retrieving product name"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|jdoConn
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// We must release the connection before we call other pm methods.
block|}
block|}
specifier|private
name|boolean
name|ensureDbInit
parameter_list|()
block|{
name|Transaction
name|tx
init|=
name|pm
operator|.
name|currentTransaction
argument_list|()
decl_stmt|;
name|boolean
name|doCommit
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|tx
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|tx
operator|.
name|begin
argument_list|()
expr_stmt|;
name|doCommit
operator|=
literal|true
expr_stmt|;
block|}
name|Query
name|dbQuery
init|=
literal|null
decl_stmt|,
name|tblColumnQuery
init|=
literal|null
decl_stmt|,
name|partColumnQuery
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// Force the underlying db to initialize.
name|dbQuery
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
name|MDatabase
operator|.
name|class
argument_list|,
literal|"name == ''"
argument_list|)
expr_stmt|;
name|dbQuery
operator|.
name|execute
argument_list|()
expr_stmt|;
name|tblColumnQuery
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
name|MTableColumnStatistics
operator|.
name|class
argument_list|,
literal|"dbName == ''"
argument_list|)
expr_stmt|;
name|tblColumnQuery
operator|.
name|execute
argument_list|()
expr_stmt|;
name|partColumnQuery
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
name|MPartitionColumnStatistics
operator|.
name|class
argument_list|,
literal|"dbName == ''"
argument_list|)
expr_stmt|;
name|partColumnQuery
operator|.
name|execute
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|doCommit
operator|=
literal|false
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Database initialization failed; direct SQL is disabled"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|tx
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|doCommit
condition|)
block|{
name|tx
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dbQuery
operator|!=
literal|null
condition|)
block|{
name|dbQuery
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tblColumnQuery
operator|!=
literal|null
condition|)
block|{
name|tblColumnQuery
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|partColumnQuery
operator|!=
literal|null
condition|)
block|{
name|partColumnQuery
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|boolean
name|runTestQuery
parameter_list|()
block|{
name|Transaction
name|tx
init|=
name|pm
operator|.
name|currentTransaction
argument_list|()
decl_stmt|;
name|boolean
name|doCommit
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|tx
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|tx
operator|.
name|begin
argument_list|()
expr_stmt|;
name|doCommit
operator|=
literal|true
expr_stmt|;
block|}
name|Query
name|query
init|=
literal|null
decl_stmt|;
comment|// Run a self-test query. If it doesn't work, we will self-disable. What a PITA...
name|String
name|selfTestQuery
init|=
literal|"select \"DB_ID\" from \"DBS\""
decl_stmt|;
try|try
block|{
name|prepareTxn
argument_list|()
expr_stmt|;
name|query
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|selfTestQuery
argument_list|)
expr_stmt|;
name|query
operator|.
name|execute
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|doCommit
operator|=
literal|false
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Self-test query ["
operator|+
name|selfTestQuery
operator|+
literal|"] failed; direct SQL is disabled"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|tx
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|doCommit
condition|)
block|{
name|tx
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|query
operator|!=
literal|null
condition|)
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|boolean
name|isCompatibleDatastore
parameter_list|()
block|{
return|return
name|isCompatibleDatastore
return|;
block|}
specifier|private
name|void
name|executeNoResult
parameter_list|(
specifier|final
name|String
name|queryText
parameter_list|)
throws|throws
name|SQLException
block|{
name|JDOConnection
name|jdoConn
init|=
name|pm
operator|.
name|getDataStoreConnection
argument_list|()
decl_stmt|;
name|Statement
name|statement
init|=
literal|null
decl_stmt|;
name|boolean
name|doTrace
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
try|try
block|{
name|long
name|start
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|statement
operator|=
operator|(
operator|(
name|Connection
operator|)
name|jdoConn
operator|.
name|getNativeConnection
argument_list|()
operator|)
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|statement
operator|.
name|execute
argument_list|(
name|queryText
argument_list|)
expr_stmt|;
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|statement
operator|!=
literal|null
condition|)
block|{
name|statement
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|jdoConn
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// We must release the connection before we call other pm methods.
block|}
block|}
specifier|public
name|Database
name|getDatabase
parameter_list|(
name|String
name|dbName
parameter_list|)
throws|throws
name|MetaException
block|{
name|Query
name|queryDbSelector
init|=
literal|null
decl_stmt|;
name|Query
name|queryDbParams
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbName
operator|=
name|dbName
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|String
name|queryTextDbSelector
init|=
literal|"select "
operator|+
literal|"\"DB_ID\", \"NAME\", \"DB_LOCATION_URI\", \"DESC\", "
operator|+
literal|"\"OWNER_NAME\", \"OWNER_TYPE\" "
operator|+
literal|"FROM \"DBS\" where \"NAME\" = ? "
decl_stmt|;
name|Object
index|[]
name|params
init|=
operator|new
name|Object
index|[]
block|{
name|dbName
block|}
decl_stmt|;
name|queryDbSelector
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryTextDbSelector
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"getDatabase:query instantiated : "
operator|+
name|queryTextDbSelector
operator|+
literal|" with param ["
operator|+
name|params
index|[
literal|0
index|]
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|sqlResult
init|=
name|executeWithArray
argument_list|(
name|queryDbSelector
argument_list|,
name|params
argument_list|,
name|queryTextDbSelector
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|sqlResult
operator|==
literal|null
operator|)
operator|||
name|sqlResult
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
assert|assert
operator|(
name|sqlResult
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
assert|;
if|if
condition|(
name|sqlResult
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Object
index|[]
name|dbline
init|=
name|sqlResult
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Long
name|dbid
init|=
name|extractSqlLong
argument_list|(
name|dbline
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|String
name|queryTextDbParams
init|=
literal|"select \"PARAM_KEY\", \"PARAM_VALUE\" "
operator|+
literal|" FROM \"DATABASE_PARAMS\" "
operator|+
literal|" WHERE \"DB_ID\" = ? "
operator|+
literal|" AND \"PARAM_KEY\" IS NOT NULL"
decl_stmt|;
name|params
index|[
literal|0
index|]
operator|=
name|dbid
expr_stmt|;
name|queryDbParams
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryTextDbParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"getDatabase:query2 instantiated : "
operator|+
name|queryTextDbParams
operator|+
literal|" with param ["
operator|+
name|params
index|[
literal|0
index|]
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|dbParams
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|sqlResult2
init|=
name|ensureList
argument_list|(
name|executeWithArray
argument_list|(
name|queryDbParams
argument_list|,
name|params
argument_list|,
name|queryTextDbParams
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sqlResult2
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Object
index|[]
name|line
range|:
name|sqlResult2
control|)
block|{
name|dbParams
operator|.
name|put
argument_list|(
name|extractSqlString
argument_list|(
name|line
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|extractSqlString
argument_list|(
name|line
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Database
name|db
init|=
operator|new
name|Database
argument_list|()
decl_stmt|;
name|db
operator|.
name|setName
argument_list|(
name|extractSqlString
argument_list|(
name|dbline
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|.
name|setLocationUri
argument_list|(
name|extractSqlString
argument_list|(
name|dbline
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|.
name|setDescription
argument_list|(
name|extractSqlString
argument_list|(
name|dbline
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|.
name|setOwnerName
argument_list|(
name|extractSqlString
argument_list|(
name|dbline
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|type
init|=
name|extractSqlString
argument_list|(
name|dbline
index|[
literal|5
index|]
argument_list|)
decl_stmt|;
name|db
operator|.
name|setOwnerType
argument_list|(
operator|(
literal|null
operator|==
name|type
operator|||
name|type
operator|.
name|trim
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
literal|null
else|:
name|PrincipalType
operator|.
name|valueOf
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|.
name|setParameters
argument_list|(
name|MetaStoreUtils
operator|.
name|trimMapNulls
argument_list|(
name|dbParams
argument_list|,
name|convertMapNullsToEmptyStrings
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"getDatabase: directsql returning db "
operator|+
name|db
operator|.
name|getName
argument_list|()
operator|+
literal|" locn["
operator|+
name|db
operator|.
name|getLocationUri
argument_list|()
operator|+
literal|"] desc ["
operator|+
name|db
operator|.
name|getDescription
argument_list|()
operator|+
literal|"] owner ["
operator|+
name|db
operator|.
name|getOwnerName
argument_list|()
operator|+
literal|"] ownertype ["
operator|+
name|db
operator|.
name|getOwnerType
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
return|return
name|db
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|queryDbSelector
operator|!=
literal|null
condition|)
block|{
name|queryDbSelector
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|queryDbParams
operator|!=
literal|null
condition|)
block|{
name|queryDbParams
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Gets partitions by using direct SQL queries.    * Note that batching is not needed for this method - list of names implies the batch size;    * @param dbName Metastore db name.    * @param tblName Metastore table name.    * @param partNames Partition names to get.    * @return List of partitions.    */
specifier|public
name|List
argument_list|<
name|Partition
argument_list|>
name|getPartitionsViaSqlFilter
parameter_list|(
specifier|final
name|String
name|dbName
parameter_list|,
specifier|final
name|String
name|tblName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|partNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
operator|new
name|ArrayList
argument_list|<
name|Partition
argument_list|>
argument_list|()
return|;
block|}
return|return
name|runBatched
argument_list|(
name|partNames
argument_list|,
operator|new
name|Batchable
argument_list|<
name|String
argument_list|,
name|Partition
argument_list|>
argument_list|()
block|{
specifier|public
name|List
argument_list|<
name|Partition
argument_list|>
name|run
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|input
parameter_list|)
throws|throws
name|MetaException
block|{
name|String
name|filter
init|=
literal|"\"PARTITIONS\".\"PART_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|input
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
decl_stmt|;
return|return
name|getPartitionsViaSqlFilterInternal
argument_list|(
name|dbName
argument_list|,
name|tblName
argument_list|,
literal|null
argument_list|,
name|filter
argument_list|,
name|input
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Gets partitions by using direct SQL queries.    * @param filter The filter.    * @param max The maximum number of partitions to return.    * @return List of partitions.    */
specifier|public
name|List
argument_list|<
name|Partition
argument_list|>
name|getPartitionsViaSqlFilter
parameter_list|(
name|SqlFilterForPushdown
name|filter
parameter_list|,
name|Integer
name|max
parameter_list|)
throws|throws
name|MetaException
block|{
name|Boolean
name|isViewTable
init|=
name|isViewTable
argument_list|(
name|filter
operator|.
name|table
argument_list|)
decl_stmt|;
return|return
name|getPartitionsViaSqlFilterInternal
argument_list|(
name|filter
operator|.
name|table
operator|.
name|getDbName
argument_list|()
argument_list|,
name|filter
operator|.
name|table
operator|.
name|getTableName
argument_list|()
argument_list|,
name|isViewTable
argument_list|,
name|filter
operator|.
name|filter
argument_list|,
name|filter
operator|.
name|params
argument_list|,
name|filter
operator|.
name|joins
argument_list|,
name|max
argument_list|)
return|;
block|}
specifier|public
specifier|static
class|class
name|SqlFilterForPushdown
block|{
specifier|private
name|List
argument_list|<
name|Object
argument_list|>
name|params
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|joins
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|String
name|filter
decl_stmt|;
specifier|private
name|Table
name|table
decl_stmt|;
block|}
specifier|public
name|boolean
name|generateSqlFilterForPushdown
parameter_list|(
name|Table
name|table
parameter_list|,
name|ExpressionTree
name|tree
parameter_list|,
name|SqlFilterForPushdown
name|result
parameter_list|)
throws|throws
name|MetaException
block|{
comment|// Derby and Oracle do not interpret filters ANSI-properly in some cases and need a workaround.
name|boolean
name|dbHasJoinCastBug
init|=
name|DatabaseProduct
operator|.
name|hasJoinOperationOrderBug
argument_list|(
name|dbType
argument_list|)
decl_stmt|;
name|result
operator|.
name|table
operator|=
name|table
expr_stmt|;
name|result
operator|.
name|filter
operator|=
name|PartitionFilterGenerator
operator|.
name|generateSqlFilter
argument_list|(
name|table
argument_list|,
name|tree
argument_list|,
name|result
operator|.
name|params
argument_list|,
name|result
operator|.
name|joins
argument_list|,
name|dbHasJoinCastBug
argument_list|,
name|defaultPartName
argument_list|,
name|dbType
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|filter
operator|!=
literal|null
return|;
block|}
comment|/**    * Gets all partitions of a table by using direct SQL queries.    * @param dbName Metastore db name.    * @param tblName Metastore table name.    * @param max The maximum number of partitions to return.    * @return List of partitions.    */
specifier|public
name|List
argument_list|<
name|Partition
argument_list|>
name|getPartitions
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tblName
parameter_list|,
name|Integer
name|max
parameter_list|)
throws|throws
name|MetaException
block|{
return|return
name|getPartitionsViaSqlFilterInternal
argument_list|(
name|dbName
argument_list|,
name|tblName
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|,
name|max
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|Boolean
name|isViewTable
parameter_list|(
name|Table
name|t
parameter_list|)
block|{
return|return
name|t
operator|.
name|isSetTableType
argument_list|()
condition|?
name|t
operator|.
name|getTableType
argument_list|()
operator|.
name|equals
argument_list|(
name|TableType
operator|.
name|VIRTUAL_VIEW
operator|.
name|toString
argument_list|()
argument_list|)
else|:
literal|null
return|;
block|}
specifier|private
name|boolean
name|isViewTable
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tblName
parameter_list|)
throws|throws
name|MetaException
block|{
name|Query
name|query
init|=
literal|null
decl_stmt|;
try|try
block|{
name|String
name|queryText
init|=
literal|"select \"TBL_TYPE\" from \"TBLS\""
operator|+
literal|" inner join \"DBS\" on \"TBLS\".\"DB_ID\" = \"DBS\".\"DB_ID\" "
operator|+
literal|" where \"TBLS\".\"TBL_NAME\" = ? and \"DBS\".\"NAME\" = ?"
decl_stmt|;
name|Object
index|[]
name|params
init|=
operator|new
name|Object
index|[]
block|{
name|tblName
block|,
name|dbName
block|}
decl_stmt|;
name|query
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
name|query
operator|.
name|setUnique
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Object
name|result
init|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|params
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
return|return
operator|(
name|result
operator|!=
literal|null
operator|)
operator|&&
name|result
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|TableType
operator|.
name|VIRTUAL_VIEW
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|query
operator|!=
literal|null
condition|)
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Get partition objects for the query using direct SQL queries, to avoid bazillion    * queries created by DN retrieving stuff for each object individually.    * @param dbName Metastore db name.    * @param tblName Metastore table name.    * @param isView Whether table is a view. Can be passed as null if not immediately    *               known, then this method will get it only if necessary.    * @param sqlFilter SQL filter to use. Better be SQL92-compliant.    * @param paramsForFilter params for ?-s in SQL filter text. Params must be in order.    * @param joinsForFilter if the filter needs additional join statement, they must be in    *                       this list. Better be SQL92-compliant.    * @param max The maximum number of partitions to return.    * @return List of partition objects.    */
specifier|private
name|List
argument_list|<
name|Partition
argument_list|>
name|getPartitionsViaSqlFilterInternal
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tblName
parameter_list|,
specifier|final
name|Boolean
name|isView
parameter_list|,
name|String
name|sqlFilter
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|Object
argument_list|>
name|paramsForFilter
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|joinsForFilter
parameter_list|,
name|Integer
name|max
parameter_list|)
throws|throws
name|MetaException
block|{
name|boolean
name|doTrace
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
specifier|final
name|String
name|dbNameLcase
init|=
name|dbName
operator|.
name|toLowerCase
argument_list|()
decl_stmt|,
name|tblNameLcase
init|=
name|tblName
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
comment|// We have to be mindful of order during filtering if we are not returning all partitions.
name|String
name|orderForFilter
init|=
operator|(
name|max
operator|!=
literal|null
operator|)
condition|?
literal|" order by \"PART_NAME\" asc"
else|:
literal|""
decl_stmt|;
comment|// Get all simple fields for partitions and related objects, which we can map one-on-one.
comment|// We will do this in 2 queries to use different existing indices for each one.
comment|// We do not get table and DB name, assuming they are the same as we are using to filter.
comment|// TODO: We might want to tune the indexes instead. With current ones MySQL performs
comment|// poorly, esp. with 'order by' w/o index on large tables, even if the number of actual
comment|// results is small (query that returns 8 out of 32k partitions can go 4sec. to 0sec. by
comment|// just adding a \"PART_ID\" IN (...) filter that doesn't alter the results to it, probably
comment|// causing it to not sort the entire table due to not knowing how selective the filter is.
name|String
name|queryText
init|=
literal|"select \"PARTITIONS\".\"PART_ID\" from \"PARTITIONS\""
operator|+
literal|"  inner join \"TBLS\" on \"PARTITIONS\".\"TBL_ID\" = \"TBLS\".\"TBL_ID\" "
operator|+
literal|"    and \"TBLS\".\"TBL_NAME\" = ? "
operator|+
literal|"  inner join \"DBS\" on \"TBLS\".\"DB_ID\" = \"DBS\".\"DB_ID\" "
operator|+
literal|"     and \"DBS\".\"NAME\" = ? "
operator|+
name|join
argument_list|(
name|joinsForFilter
argument_list|,
literal|' '
argument_list|)
operator|+
operator|(
name|StringUtils
operator|.
name|isBlank
argument_list|(
name|sqlFilter
argument_list|)
condition|?
literal|""
else|:
operator|(
literal|" where "
operator|+
name|sqlFilter
operator|)
operator|)
operator|+
name|orderForFilter
decl_stmt|;
name|Object
index|[]
name|params
init|=
operator|new
name|Object
index|[
name|paramsForFilter
operator|.
name|size
argument_list|()
operator|+
literal|2
index|]
decl_stmt|;
name|params
index|[
literal|0
index|]
operator|=
name|tblNameLcase
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|dbNameLcase
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paramsForFilter
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|params
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|paramsForFilter
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|long
name|start
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|Query
name|query
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
if|if
condition|(
name|max
operator|!=
literal|null
condition|)
block|{
name|query
operator|.
name|setRange
argument_list|(
literal|0
argument_list|,
name|max
operator|.
name|shortValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Object
argument_list|>
name|sqlResult
init|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|params
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|long
name|queryTime
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|queryTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|sqlResult
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
operator|new
name|ArrayList
argument_list|<
name|Partition
argument_list|>
argument_list|()
return|;
comment|// no partitions, bail early.
block|}
comment|// Get full objects. For Oracle/etc. do it in batches.
name|List
argument_list|<
name|Partition
argument_list|>
name|result
init|=
name|runBatched
argument_list|(
name|sqlResult
argument_list|,
operator|new
name|Batchable
argument_list|<
name|Object
argument_list|,
name|Partition
argument_list|>
argument_list|()
block|{
specifier|public
name|List
argument_list|<
name|Partition
argument_list|>
name|run
parameter_list|(
name|List
argument_list|<
name|Object
argument_list|>
name|input
parameter_list|)
throws|throws
name|MetaException
block|{
return|return
name|getPartitionsFromPartitionIds
argument_list|(
name|dbNameLcase
argument_list|,
name|tblNameLcase
argument_list|,
name|isView
argument_list|,
name|input
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/** Should be called with the list short enough to not trip up Oracle/etc. */
specifier|private
name|List
argument_list|<
name|Partition
argument_list|>
name|getPartitionsFromPartitionIds
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tblName
parameter_list|,
name|Boolean
name|isView
parameter_list|,
name|List
argument_list|<
name|Object
argument_list|>
name|partIdList
parameter_list|)
throws|throws
name|MetaException
block|{
name|boolean
name|doTrace
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
name|int
name|idStringWidth
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|Math
operator|.
name|log10
argument_list|(
name|partIdList
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|// 1 for comma
name|int
name|sbCapacity
init|=
name|partIdList
operator|.
name|size
argument_list|()
operator|*
name|idStringWidth
decl_stmt|;
comment|// Prepare StringBuilder for "PART_ID in (...)" to use in future queries.
name|StringBuilder
name|partSb
init|=
operator|new
name|StringBuilder
argument_list|(
name|sbCapacity
argument_list|)
decl_stmt|;
for|for
control|(
name|Object
name|partitionId
range|:
name|partIdList
control|)
block|{
name|partSb
operator|.
name|append
argument_list|(
name|extractSqlLong
argument_list|(
name|partitionId
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|String
name|partIds
init|=
name|trimCommaList
argument_list|(
name|partSb
argument_list|)
decl_stmt|;
comment|// Get most of the fields for the IDs provided.
comment|// Assume db and table names are the same for all partition, as provided in arguments.
name|String
name|queryText
init|=
literal|"select \"PARTITIONS\".\"PART_ID\", \"SDS\".\"SD_ID\", \"SDS\".\"CD_ID\","
operator|+
literal|" \"SERDES\".\"SERDE_ID\", \"PARTITIONS\".\"CREATE_TIME\","
operator|+
literal|" \"PARTITIONS\".\"LAST_ACCESS_TIME\", \"SDS\".\"INPUT_FORMAT\", \"SDS\".\"IS_COMPRESSED\","
operator|+
literal|" \"SDS\".\"IS_STOREDASSUBDIRECTORIES\", \"SDS\".\"LOCATION\", \"SDS\".\"NUM_BUCKETS\","
operator|+
literal|" \"SDS\".\"OUTPUT_FORMAT\", \"SERDES\".\"NAME\", \"SERDES\".\"SLIB\" "
operator|+
literal|"from \"PARTITIONS\""
operator|+
literal|"  left outer join \"SDS\" on \"PARTITIONS\".\"SD_ID\" = \"SDS\".\"SD_ID\" "
operator|+
literal|"  left outer join \"SERDES\" on \"SDS\".\"SERDE_ID\" = \"SERDES\".\"SERDE_ID\" "
operator|+
literal|"where \"PART_ID\" in ("
operator|+
name|partIds
operator|+
literal|") order by \"PART_NAME\" asc"
decl_stmt|;
name|long
name|start
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|Query
name|query
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|sqlResult
init|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
literal|null
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|long
name|queryTime
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
comment|// Read all the fields and create partitions, SDs and serdes.
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
name|partitions
init|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sds
init|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|SerDeInfo
argument_list|>
name|serdes
init|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|SerDeInfo
argument_list|>
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
name|colss
init|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// Keep order by name, consistent with JDO.
name|ArrayList
argument_list|<
name|Partition
argument_list|>
name|orderedResult
init|=
operator|new
name|ArrayList
argument_list|<
name|Partition
argument_list|>
argument_list|(
name|partIdList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// Prepare StringBuilder-s for "in (...)" lists to use in one-to-many queries.
name|StringBuilder
name|sdSb
init|=
operator|new
name|StringBuilder
argument_list|(
name|sbCapacity
argument_list|)
decl_stmt|,
name|serdeSb
init|=
operator|new
name|StringBuilder
argument_list|(
name|sbCapacity
argument_list|)
decl_stmt|;
name|StringBuilder
name|colsSb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|7
argument_list|)
decl_stmt|;
comment|// We expect that there's only one field schema.
name|tblName
operator|=
name|tblName
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|dbName
operator|=
name|dbName
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
for|for
control|(
name|Object
index|[]
name|fields
range|:
name|sqlResult
control|)
block|{
comment|// Here comes the ugly part...
name|long
name|partitionId
init|=
name|extractSqlLong
argument_list|(
name|fields
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|Long
name|sdId
init|=
name|extractSqlLong
argument_list|(
name|fields
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|Long
name|colId
init|=
name|extractSqlLong
argument_list|(
name|fields
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|Long
name|serdeId
init|=
name|extractSqlLong
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
comment|// A partition must have at least sdId and serdeId set, or nothing set if it's a view.
if|if
condition|(
name|sdId
operator|==
literal|null
operator|||
name|serdeId
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|isView
operator|==
literal|null
condition|)
block|{
name|isView
operator|=
name|isViewTable
argument_list|(
name|dbName
argument_list|,
name|tblName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sdId
operator|!=
literal|null
operator|||
name|colId
operator|!=
literal|null
operator|||
name|serdeId
operator|!=
literal|null
operator|)
operator|||
operator|!
name|isView
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unexpected null for one of the IDs, SD "
operator|+
name|sdId
operator|+
literal|", serde "
operator|+
name|serdeId
operator|+
literal|" for a "
operator|+
operator|(
name|isView
condition|?
literal|""
else|:
literal|"non-"
operator|)
operator|+
literal|" view"
argument_list|)
throw|;
block|}
block|}
name|Partition
name|part
init|=
operator|new
name|Partition
argument_list|()
decl_stmt|;
name|orderedResult
operator|.
name|add
argument_list|(
name|part
argument_list|)
expr_stmt|;
comment|// Set the collection fields; some code might not check presence before accessing them.
name|part
operator|.
name|setParameters
argument_list|(
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|part
operator|.
name|setValues
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|part
operator|.
name|setDbName
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|part
operator|.
name|setTableName
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
index|[
literal|4
index|]
operator|!=
literal|null
condition|)
name|part
operator|.
name|setCreateTime
argument_list|(
name|extractSqlInt
argument_list|(
name|fields
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
index|[
literal|5
index|]
operator|!=
literal|null
condition|)
name|part
operator|.
name|setLastAccessTime
argument_list|(
name|extractSqlInt
argument_list|(
name|fields
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|partitions
operator|.
name|put
argument_list|(
name|partitionId
argument_list|,
name|part
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdId
operator|==
literal|null
condition|)
continue|continue;
comment|// Probably a view.
assert|assert
name|serdeId
operator|!=
literal|null
assert|;
comment|// We assume each partition has an unique SD.
name|StorageDescriptor
name|sd
init|=
operator|new
name|StorageDescriptor
argument_list|()
decl_stmt|;
name|StorageDescriptor
name|oldSd
init|=
name|sds
operator|.
name|put
argument_list|(
name|sdId
argument_list|,
name|sd
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldSd
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Partitions reuse SDs; we don't expect that"
argument_list|)
throw|;
block|}
comment|// Set the collection fields; some code might not check presence before accessing them.
name|sd
operator|.
name|setSortCols
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|Order
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|sd
operator|.
name|setBucketCols
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|sd
operator|.
name|setParameters
argument_list|(
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|sd
operator|.
name|setSkewedInfo
argument_list|(
operator|new
name|SkewedInfo
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
argument_list|,
operator|new
name|HashMap
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|String
argument_list|>
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|sd
operator|.
name|setInputFormat
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|Boolean
name|tmpBoolean
init|=
name|extractSqlBoolean
argument_list|(
name|fields
index|[
literal|7
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmpBoolean
operator|!=
literal|null
condition|)
name|sd
operator|.
name|setCompressed
argument_list|(
name|tmpBoolean
argument_list|)
expr_stmt|;
name|tmpBoolean
operator|=
name|extractSqlBoolean
argument_list|(
name|fields
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpBoolean
operator|!=
literal|null
condition|)
name|sd
operator|.
name|setStoredAsSubDirectories
argument_list|(
name|tmpBoolean
argument_list|)
expr_stmt|;
name|sd
operator|.
name|setLocation
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
index|[
literal|10
index|]
operator|!=
literal|null
condition|)
name|sd
operator|.
name|setNumBuckets
argument_list|(
name|extractSqlInt
argument_list|(
name|fields
index|[
literal|10
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|sd
operator|.
name|setOutputFormat
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
name|sdSb
operator|.
name|append
argument_list|(
name|sdId
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|part
operator|.
name|setSd
argument_list|(
name|sd
argument_list|)
expr_stmt|;
if|if
condition|(
name|colId
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|cols
init|=
name|colss
operator|.
name|get
argument_list|(
name|colId
argument_list|)
decl_stmt|;
comment|// We expect that colId will be the same for all (or many) SDs.
if|if
condition|(
name|cols
operator|==
literal|null
condition|)
block|{
name|cols
operator|=
operator|new
name|ArrayList
argument_list|<
name|FieldSchema
argument_list|>
argument_list|()
expr_stmt|;
name|colss
operator|.
name|put
argument_list|(
name|colId
argument_list|,
name|cols
argument_list|)
expr_stmt|;
name|colsSb
operator|.
name|append
argument_list|(
name|colId
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sd
operator|.
name|setCols
argument_list|(
name|cols
argument_list|)
expr_stmt|;
block|}
comment|// We assume each SD has an unique serde.
name|SerDeInfo
name|serde
init|=
operator|new
name|SerDeInfo
argument_list|()
decl_stmt|;
name|SerDeInfo
name|oldSerde
init|=
name|serdes
operator|.
name|put
argument_list|(
name|serdeId
argument_list|,
name|serde
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldSerde
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"SDs reuse serdes; we don't expect that"
argument_list|)
throw|;
block|}
name|serde
operator|.
name|setParameters
argument_list|(
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|serde
operator|.
name|setName
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
name|serde
operator|.
name|setSerializationLib
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|13
index|]
argument_list|)
expr_stmt|;
name|serdeSb
operator|.
name|append
argument_list|(
name|serdeId
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|sd
operator|.
name|setSerdeInfo
argument_list|(
name|serde
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
block|}
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|queryTime
argument_list|)
expr_stmt|;
comment|// Now get all the one-to-many things. Start with partitions.
name|queryText
operator|=
literal|"select \"PART_ID\", \"PARAM_KEY\", \"PARAM_VALUE\" from \"PARTITION_PARAMS\""
operator|+
literal|" where \"PART_ID\" in ("
operator|+
name|partIds
operator|+
literal|") and \"PARAM_KEY\" is not null"
operator|+
literal|" order by \"PART_ID\" asc"
expr_stmt|;
name|loopJoinOrderedResult
argument_list|(
name|partitions
argument_list|,
name|queryText
argument_list|,
literal|0
argument_list|,
operator|new
name|ApplyFunc
argument_list|<
name|Partition
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|Partition
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
block|{
name|t
operator|.
name|putToParameters
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|1
index|]
argument_list|,
operator|(
name|String
operator|)
name|fields
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Perform conversion of null map values
for|for
control|(
name|Partition
name|t
range|:
name|partitions
operator|.
name|values
argument_list|()
control|)
block|{
name|t
operator|.
name|setParameters
argument_list|(
name|MetaStoreUtils
operator|.
name|trimMapNulls
argument_list|(
name|t
operator|.
name|getParameters
argument_list|()
argument_list|,
name|convertMapNullsToEmptyStrings
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|queryText
operator|=
literal|"select \"PART_ID\", \"PART_KEY_VAL\" from \"PARTITION_KEY_VALS\""
operator|+
literal|" where \"PART_ID\" in ("
operator|+
name|partIds
operator|+
literal|") and \"INTEGER_IDX\">= 0"
operator|+
literal|" order by \"PART_ID\" asc, \"INTEGER_IDX\" asc"
expr_stmt|;
name|loopJoinOrderedResult
argument_list|(
name|partitions
argument_list|,
name|queryText
argument_list|,
literal|0
argument_list|,
operator|new
name|ApplyFunc
argument_list|<
name|Partition
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|Partition
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
block|{
name|t
operator|.
name|addToValues
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Prepare IN (blah) lists for the following queries. Cut off the final ','s.
if|if
condition|(
name|sdSb
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
assert|assert
name|serdeSb
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|&&
name|colsSb
operator|.
name|length
argument_list|()
operator|==
literal|0
assert|;
return|return
name|orderedResult
return|;
comment|// No SDs, probably a view.
block|}
name|String
name|sdIds
init|=
name|trimCommaList
argument_list|(
name|sdSb
argument_list|)
decl_stmt|;
name|String
name|serdeIds
init|=
name|trimCommaList
argument_list|(
name|serdeSb
argument_list|)
decl_stmt|;
name|String
name|colIds
init|=
name|trimCommaList
argument_list|(
name|colsSb
argument_list|)
decl_stmt|;
comment|// Get all the stuff for SD. Don't do empty-list check - we expect partitions do have SDs.
name|queryText
operator|=
literal|"select \"SD_ID\", \"PARAM_KEY\", \"PARAM_VALUE\" from \"SD_PARAMS\""
operator|+
literal|" where \"SD_ID\" in ("
operator|+
name|sdIds
operator|+
literal|") and \"PARAM_KEY\" is not null"
operator|+
literal|" order by \"SD_ID\" asc"
expr_stmt|;
name|loopJoinOrderedResult
argument_list|(
name|sds
argument_list|,
name|queryText
argument_list|,
literal|0
argument_list|,
operator|new
name|ApplyFunc
argument_list|<
name|StorageDescriptor
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|StorageDescriptor
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
block|{
name|t
operator|.
name|putToParameters
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|1
index|]
argument_list|,
operator|(
name|String
operator|)
name|fields
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Perform conversion of null map values
for|for
control|(
name|StorageDescriptor
name|t
range|:
name|sds
operator|.
name|values
argument_list|()
control|)
block|{
name|t
operator|.
name|setParameters
argument_list|(
name|MetaStoreUtils
operator|.
name|trimMapNulls
argument_list|(
name|t
operator|.
name|getParameters
argument_list|()
argument_list|,
name|convertMapNullsToEmptyStrings
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|queryText
operator|=
literal|"select \"SD_ID\", \"COLUMN_NAME\", \"SORT_COLS\".\"ORDER\""
operator|+
literal|" from \"SORT_COLS\""
operator|+
literal|" where \"SD_ID\" in ("
operator|+
name|sdIds
operator|+
literal|") and \"INTEGER_IDX\">= 0"
operator|+
literal|" order by \"SD_ID\" asc, \"INTEGER_IDX\" asc"
expr_stmt|;
name|loopJoinOrderedResult
argument_list|(
name|sds
argument_list|,
name|queryText
argument_list|,
literal|0
argument_list|,
operator|new
name|ApplyFunc
argument_list|<
name|StorageDescriptor
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|StorageDescriptor
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
block|{
if|if
condition|(
name|fields
index|[
literal|2
index|]
operator|==
literal|null
condition|)
return|return;
name|t
operator|.
name|addToSortCols
argument_list|(
operator|new
name|Order
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|1
index|]
argument_list|,
name|extractSqlInt
argument_list|(
name|fields
index|[
literal|2
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|queryText
operator|=
literal|"select \"SD_ID\", \"BUCKET_COL_NAME\" from \"BUCKETING_COLS\""
operator|+
literal|" where \"SD_ID\" in ("
operator|+
name|sdIds
operator|+
literal|") and \"INTEGER_IDX\">= 0"
operator|+
literal|" order by \"SD_ID\" asc, \"INTEGER_IDX\" asc"
expr_stmt|;
name|loopJoinOrderedResult
argument_list|(
name|sds
argument_list|,
name|queryText
argument_list|,
literal|0
argument_list|,
operator|new
name|ApplyFunc
argument_list|<
name|StorageDescriptor
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|StorageDescriptor
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
block|{
name|t
operator|.
name|addToBucketCols
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Skewed columns stuff.
name|queryText
operator|=
literal|"select \"SD_ID\", \"SKEWED_COL_NAME\" from \"SKEWED_COL_NAMES\""
operator|+
literal|" where \"SD_ID\" in ("
operator|+
name|sdIds
operator|+
literal|") and \"INTEGER_IDX\">= 0"
operator|+
literal|" order by \"SD_ID\" asc, \"INTEGER_IDX\" asc"
expr_stmt|;
name|boolean
name|hasSkewedColumns
init|=
name|loopJoinOrderedResult
argument_list|(
name|sds
argument_list|,
name|queryText
argument_list|,
literal|0
argument_list|,
operator|new
name|ApplyFunc
argument_list|<
name|StorageDescriptor
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|StorageDescriptor
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
block|{
if|if
condition|(
operator|!
name|t
operator|.
name|isSetSkewedInfo
argument_list|()
condition|)
name|t
operator|.
name|setSkewedInfo
argument_list|(
operator|new
name|SkewedInfo
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|getSkewedInfo
argument_list|()
operator|.
name|addToSkewedColNames
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
operator|>
literal|0
decl_stmt|;
comment|// Assume we don't need to fetch the rest of the skewed column data if we have no columns.
if|if
condition|(
name|hasSkewedColumns
condition|)
block|{
comment|// We are skipping the SKEWED_STRING_LIST table here, as it seems to be totally useless.
name|queryText
operator|=
literal|"select \"SKEWED_VALUES\".\"SD_ID_OID\","
operator|+
literal|"  \"SKEWED_STRING_LIST_VALUES\".\"STRING_LIST_ID\","
operator|+
literal|"  \"SKEWED_STRING_LIST_VALUES\".\"STRING_LIST_VALUE\" "
operator|+
literal|"from \"SKEWED_VALUES\" "
operator|+
literal|"  left outer join \"SKEWED_STRING_LIST_VALUES\" on \"SKEWED_VALUES\"."
operator|+
literal|"\"STRING_LIST_ID_EID\" = \"SKEWED_STRING_LIST_VALUES\".\"STRING_LIST_ID\" "
operator|+
literal|"where \"SKEWED_VALUES\".\"SD_ID_OID\" in ("
operator|+
name|sdIds
operator|+
literal|") "
operator|+
literal|"  and \"SKEWED_VALUES\".\"STRING_LIST_ID_EID\" is not null "
operator|+
literal|"  and \"SKEWED_VALUES\".\"INTEGER_IDX\">= 0 "
operator|+
literal|"order by \"SKEWED_VALUES\".\"SD_ID_OID\" asc, \"SKEWED_VALUES\".\"INTEGER_IDX\" asc,"
operator|+
literal|"  \"SKEWED_STRING_LIST_VALUES\".\"INTEGER_IDX\" asc"
expr_stmt|;
name|loopJoinOrderedResult
argument_list|(
name|sds
argument_list|,
name|queryText
argument_list|,
literal|0
argument_list|,
operator|new
name|ApplyFunc
argument_list|<
name|StorageDescriptor
argument_list|>
argument_list|()
block|{
specifier|private
name|Long
name|currentListId
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|currentList
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|StorageDescriptor
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
operator|!
name|t
operator|.
name|isSetSkewedInfo
argument_list|()
condition|)
name|t
operator|.
name|setSkewedInfo
argument_list|(
operator|new
name|SkewedInfo
argument_list|()
argument_list|)
expr_stmt|;
comment|// Note that this is not a typical list accumulator - there's no call to finalize
comment|// the last list. Instead we add list to SD first, as well as locally to add elements.
if|if
condition|(
name|fields
index|[
literal|1
index|]
operator|==
literal|null
condition|)
block|{
name|currentList
operator|=
literal|null
expr_stmt|;
comment|// left outer join produced a list with no values
name|currentListId
operator|=
literal|null
expr_stmt|;
name|t
operator|.
name|getSkewedInfo
argument_list|()
operator|.
name|addToSkewedColValues
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|long
name|fieldsListId
init|=
name|extractSqlLong
argument_list|(
name|fields
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentListId
operator|==
literal|null
operator|||
name|fieldsListId
operator|!=
name|currentListId
condition|)
block|{
name|currentList
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|currentListId
operator|=
name|fieldsListId
expr_stmt|;
name|t
operator|.
name|getSkewedInfo
argument_list|()
operator|.
name|addToSkewedColValues
argument_list|(
name|currentList
argument_list|)
expr_stmt|;
block|}
name|currentList
operator|.
name|add
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|// We are skipping the SKEWED_STRING_LIST table here, as it seems to be totally useless.
name|queryText
operator|=
literal|"select \"SKEWED_COL_VALUE_LOC_MAP\".\"SD_ID\","
operator|+
literal|" \"SKEWED_STRING_LIST_VALUES\".STRING_LIST_ID,"
operator|+
literal|" \"SKEWED_COL_VALUE_LOC_MAP\".\"LOCATION\","
operator|+
literal|" \"SKEWED_STRING_LIST_VALUES\".\"STRING_LIST_VALUE\" "
operator|+
literal|"from \"SKEWED_COL_VALUE_LOC_MAP\""
operator|+
literal|"  left outer join \"SKEWED_STRING_LIST_VALUES\" on \"SKEWED_COL_VALUE_LOC_MAP\"."
operator|+
literal|"\"STRING_LIST_ID_KID\" = \"SKEWED_STRING_LIST_VALUES\".\"STRING_LIST_ID\" "
operator|+
literal|"where \"SKEWED_COL_VALUE_LOC_MAP\".\"SD_ID\" in ("
operator|+
name|sdIds
operator|+
literal|")"
operator|+
literal|"  and \"SKEWED_COL_VALUE_LOC_MAP\".\"STRING_LIST_ID_KID\" is not null "
operator|+
literal|"order by \"SKEWED_COL_VALUE_LOC_MAP\".\"SD_ID\" asc,"
operator|+
literal|"  \"SKEWED_STRING_LIST_VALUES\".\"STRING_LIST_ID\" asc,"
operator|+
literal|"  \"SKEWED_STRING_LIST_VALUES\".\"INTEGER_IDX\" asc"
expr_stmt|;
name|loopJoinOrderedResult
argument_list|(
name|sds
argument_list|,
name|queryText
argument_list|,
literal|0
argument_list|,
operator|new
name|ApplyFunc
argument_list|<
name|StorageDescriptor
argument_list|>
argument_list|()
block|{
specifier|private
name|Long
name|currentListId
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|currentList
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|StorageDescriptor
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
operator|!
name|t
operator|.
name|isSetSkewedInfo
argument_list|()
condition|)
block|{
name|SkewedInfo
name|skewedInfo
init|=
operator|new
name|SkewedInfo
argument_list|()
decl_stmt|;
name|skewedInfo
operator|.
name|setSkewedColValueLocationMaps
argument_list|(
operator|new
name|HashMap
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|setSkewedInfo
argument_list|(
name|skewedInfo
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|String
argument_list|>
name|skewMap
init|=
name|t
operator|.
name|getSkewedInfo
argument_list|()
operator|.
name|getSkewedColValueLocationMaps
argument_list|()
decl_stmt|;
comment|// Note that this is not a typical list accumulator - there's no call to finalize
comment|// the last list. Instead we add list to SD first, as well as locally to add elements.
if|if
condition|(
name|fields
index|[
literal|1
index|]
operator|==
literal|null
condition|)
block|{
name|currentList
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
comment|// left outer join produced a list with no values
name|currentListId
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|long
name|fieldsListId
init|=
name|extractSqlLong
argument_list|(
name|fields
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentListId
operator|==
literal|null
operator|||
name|fieldsListId
operator|!=
name|currentListId
condition|)
block|{
name|currentList
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|currentListId
operator|=
name|fieldsListId
expr_stmt|;
block|}
else|else
block|{
name|skewMap
operator|.
name|remove
argument_list|(
name|currentList
argument_list|)
expr_stmt|;
comment|// value based compare.. remove first
block|}
name|currentList
operator|.
name|add
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
name|skewMap
operator|.
name|put
argument_list|(
name|currentList
argument_list|,
operator|(
name|String
operator|)
name|fields
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|// if (hasSkewedColumns)
comment|// Get FieldSchema stuff if any.
if|if
condition|(
operator|!
name|colss
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// We are skipping the CDS table here, as it seems to be totally useless.
name|queryText
operator|=
literal|"select \"CD_ID\", \"COMMENT\", \"COLUMN_NAME\", \"TYPE_NAME\""
operator|+
literal|" from \"COLUMNS_V2\" where \"CD_ID\" in ("
operator|+
name|colIds
operator|+
literal|") and \"INTEGER_IDX\">= 0"
operator|+
literal|" order by \"CD_ID\" asc, \"INTEGER_IDX\" asc"
expr_stmt|;
name|loopJoinOrderedResult
argument_list|(
name|colss
argument_list|,
name|queryText
argument_list|,
literal|0
argument_list|,
operator|new
name|ApplyFunc
argument_list|<
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
block|{
name|t
operator|.
name|add
argument_list|(
operator|new
name|FieldSchema
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|2
index|]
argument_list|,
operator|(
name|String
operator|)
name|fields
index|[
literal|3
index|]
argument_list|,
operator|(
name|String
operator|)
name|fields
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|// Finally, get all the stuff for serdes - just the params.
name|queryText
operator|=
literal|"select \"SERDE_ID\", \"PARAM_KEY\", \"PARAM_VALUE\" from \"SERDE_PARAMS\""
operator|+
literal|" where \"SERDE_ID\" in ("
operator|+
name|serdeIds
operator|+
literal|") and \"PARAM_KEY\" is not null"
operator|+
literal|" order by \"SERDE_ID\" asc"
expr_stmt|;
name|loopJoinOrderedResult
argument_list|(
name|serdes
argument_list|,
name|queryText
argument_list|,
literal|0
argument_list|,
operator|new
name|ApplyFunc
argument_list|<
name|SerDeInfo
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|SerDeInfo
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
block|{
name|t
operator|.
name|putToParameters
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|1
index|]
argument_list|,
operator|(
name|String
operator|)
name|fields
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Perform conversion of null map values
for|for
control|(
name|SerDeInfo
name|t
range|:
name|serdes
operator|.
name|values
argument_list|()
control|)
block|{
name|t
operator|.
name|setParameters
argument_list|(
name|MetaStoreUtils
operator|.
name|trimMapNulls
argument_list|(
name|t
operator|.
name|getParameters
argument_list|()
argument_list|,
name|convertMapNullsToEmptyStrings
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|orderedResult
return|;
block|}
specifier|public
name|int
name|getNumPartitionsViaSqlFilter
parameter_list|(
name|SqlFilterForPushdown
name|filter
parameter_list|)
throws|throws
name|MetaException
block|{
name|boolean
name|doTrace
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
name|String
name|dbName
init|=
name|filter
operator|.
name|table
operator|.
name|getDbName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|String
name|tblName
init|=
name|filter
operator|.
name|table
operator|.
name|getTableName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
comment|// Get number of partitions by doing count on PART_ID.
name|String
name|queryText
init|=
literal|"select count(\"PARTITIONS\".\"PART_ID\") from \"PARTITIONS\""
operator|+
literal|"  inner join \"TBLS\" on \"PARTITIONS\".\"TBL_ID\" = \"TBLS\".\"TBL_ID\" "
operator|+
literal|"    and \"TBLS\".\"TBL_NAME\" = ? "
operator|+
literal|"  inner join \"DBS\" on \"TBLS\".\"DB_ID\" = \"DBS\".\"DB_ID\" "
operator|+
literal|"     and \"DBS\".\"NAME\" = ? "
operator|+
name|join
argument_list|(
name|filter
operator|.
name|joins
argument_list|,
literal|' '
argument_list|)
operator|+
operator|(
name|filter
operator|.
name|filter
operator|==
literal|null
operator|||
name|filter
operator|.
name|filter
operator|.
name|trim
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
literal|""
else|:
operator|(
literal|" where "
operator|+
name|filter
operator|.
name|filter
operator|)
operator|)
decl_stmt|;
name|Object
index|[]
name|params
init|=
operator|new
name|Object
index|[
name|filter
operator|.
name|params
operator|.
name|size
argument_list|()
operator|+
literal|2
index|]
decl_stmt|;
name|params
index|[
literal|0
index|]
operator|=
name|tblName
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|dbName
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|filter
operator|.
name|params
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|params
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|filter
operator|.
name|params
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|long
name|start
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|Query
name|query
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|query
operator|.
name|setUnique
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|int
name|sqlResult
init|=
name|extractSqlInt
argument_list|(
name|query
operator|.
name|executeWithArray
argument_list|(
name|params
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|queryTime
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|queryTime
argument_list|)
expr_stmt|;
return|return
name|sqlResult
return|;
block|}
specifier|private
name|void
name|timingTrace
parameter_list|(
name|boolean
name|doTrace
parameter_list|,
name|String
name|queryText
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|queryTime
parameter_list|)
block|{
if|if
condition|(
operator|!
name|doTrace
condition|)
return|return;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Direct SQL query in "
operator|+
operator|(
name|queryTime
operator|-
name|start
operator|)
operator|/
literal|1000000.0
operator|+
literal|"ms + "
operator|+
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|queryTime
operator|)
operator|/
literal|1000000.0
operator|+
literal|"ms, the query is ["
operator|+
name|queryText
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
specifier|static
name|Long
name|extractSqlLong
parameter_list|(
name|Object
name|obj
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|Number
operator|)
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Expected numeric type but got "
operator|+
name|obj
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
return|return
operator|(
operator|(
name|Number
operator|)
name|obj
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|Boolean
name|extractSqlBoolean
parameter_list|(
name|Object
name|value
parameter_list|)
throws|throws
name|MetaException
block|{
comment|// MySQL has booleans, but e.g. Derby uses 'Y'/'N' mapping. People using derby probably
comment|// don't care about performance anyway, but let's cover the common case.
if|if
condition|(
name|value
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
return|return
operator|(
name|Boolean
operator|)
name|value
return|;
name|Character
name|c
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|String
operator|&&
operator|(
operator|(
name|String
operator|)
name|value
operator|)
operator|.
name|length
argument_list|()
operator|==
literal|1
condition|)
block|{
name|c
operator|=
operator|(
operator|(
name|String
operator|)
name|value
operator|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|c
operator|==
literal|'Y'
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|c
operator|==
literal|'N'
condition|)
return|return
literal|false
return|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Cannot extract boolean from column value "
operator|+
name|value
argument_list|)
throw|;
block|}
specifier|private
name|int
name|extractSqlInt
parameter_list|(
name|Object
name|field
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|field
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
specifier|private
name|String
name|extractSqlString
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|value
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|static
name|Double
name|extractSqlDouble
parameter_list|(
name|Object
name|obj
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|Number
operator|)
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Expected numeric type but got "
operator|+
name|obj
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
return|return
operator|(
operator|(
name|Number
operator|)
name|obj
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|String
name|trimCommaList
parameter_list|(
name|StringBuilder
name|sb
parameter_list|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|setLength
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
specifier|abstract
class|class
name|ApplyFunc
parameter_list|<
name|Target
parameter_list|>
block|{
specifier|public
specifier|abstract
name|void
name|apply
parameter_list|(
name|Target
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
throws|throws
name|MetaException
function_decl|;
block|}
comment|/**    * Merges applies the result of a PM SQL query into a tree of object.    * Essentially it's an object join. DN could do this for us, but it issues queries    * separately for every object, which is suboptimal.    * @param tree The object tree, by ID.    * @param queryText The query text.    * @param keyIndex Index of the Long column corresponding to the map ID in query result rows.    * @param func The function that is called on each (object,row) pair with the same id.    * @return the count of results returned from the query.    */
specifier|private
parameter_list|<
name|T
parameter_list|>
name|int
name|loopJoinOrderedResult
parameter_list|(
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|T
argument_list|>
name|tree
parameter_list|,
name|String
name|queryText
parameter_list|,
name|int
name|keyIndex
parameter_list|,
name|ApplyFunc
argument_list|<
name|T
argument_list|>
name|func
parameter_list|)
throws|throws
name|MetaException
block|{
name|boolean
name|doTrace
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
name|long
name|start
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|Query
name|query
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|Object
name|result
init|=
name|query
operator|.
name|execute
argument_list|()
decl_stmt|;
name|long
name|queryTime
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|list
init|=
name|ensureList
argument_list|(
name|result
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Object
index|[]
argument_list|>
name|iter
init|=
name|list
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Object
index|[]
name|fields
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|T
argument_list|>
name|entry
range|:
name|tree
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|fields
operator|==
literal|null
operator|&&
operator|!
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
break|break;
name|long
name|id
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
while|while
condition|(
name|fields
operator|!=
literal|null
operator|||
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
name|fields
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
name|long
name|nestedId
init|=
name|extractSqlLong
argument_list|(
name|fields
index|[
name|keyIndex
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|nestedId
operator|<
name|id
condition|)
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Found entries for unknown ID "
operator|+
name|nestedId
argument_list|)
throw|;
if|if
condition|(
name|nestedId
operator|>
name|id
condition|)
break|break;
comment|// fields belong to one of the next entries
name|func
operator|.
name|apply
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|fields
argument_list|)
expr_stmt|;
name|fields
operator|=
literal|null
expr_stmt|;
block|}
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
block|}
name|int
name|rv
init|=
name|list
operator|.
name|size
argument_list|()
decl_stmt|;
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|queryTime
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
specifier|private
specifier|static
class|class
name|PartitionFilterGenerator
extends|extends
name|TreeVisitor
block|{
specifier|private
specifier|final
name|Table
name|table
decl_stmt|;
specifier|private
specifier|final
name|FilterBuilder
name|filterBuffer
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|Object
argument_list|>
name|params
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|joins
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|dbHasJoinCastBug
decl_stmt|;
specifier|private
specifier|final
name|String
name|defaultPartName
decl_stmt|;
specifier|private
specifier|final
name|DatabaseProduct
name|dbType
decl_stmt|;
specifier|private
name|PartitionFilterGenerator
parameter_list|(
name|Table
name|table
parameter_list|,
name|List
argument_list|<
name|Object
argument_list|>
name|params
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|joins
parameter_list|,
name|boolean
name|dbHasJoinCastBug
parameter_list|,
name|String
name|defaultPartName
parameter_list|,
name|DatabaseProduct
name|dbType
parameter_list|)
block|{
name|this
operator|.
name|table
operator|=
name|table
expr_stmt|;
name|this
operator|.
name|params
operator|=
name|params
expr_stmt|;
name|this
operator|.
name|joins
operator|=
name|joins
expr_stmt|;
name|this
operator|.
name|dbHasJoinCastBug
operator|=
name|dbHasJoinCastBug
expr_stmt|;
name|this
operator|.
name|filterBuffer
operator|=
operator|new
name|FilterBuilder
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|defaultPartName
operator|=
name|defaultPartName
expr_stmt|;
name|this
operator|.
name|dbType
operator|=
name|dbType
expr_stmt|;
block|}
comment|/**      * Generate the ANSI SQL92 filter for the given expression tree      * @param table the table being queried      * @param params the ordered parameters for the resulting expression      * @param joins the joins necessary for the resulting expression      * @return the string representation of the expression tree      */
specifier|private
specifier|static
name|String
name|generateSqlFilter
parameter_list|(
name|Table
name|table
parameter_list|,
name|ExpressionTree
name|tree
parameter_list|,
name|List
argument_list|<
name|Object
argument_list|>
name|params
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|joins
parameter_list|,
name|boolean
name|dbHasJoinCastBug
parameter_list|,
name|String
name|defaultPartName
parameter_list|,
name|DatabaseProduct
name|dbType
parameter_list|)
throws|throws
name|MetaException
block|{
assert|assert
name|table
operator|!=
literal|null
assert|;
if|if
condition|(
name|tree
operator|==
literal|null
condition|)
block|{
comment|// consistent with other APIs like makeExpressionTree, null is returned to indicate that
comment|// the filter could not pushed down due to parsing issue etc
return|return
literal|null
return|;
block|}
if|if
condition|(
name|tree
operator|.
name|getRoot
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|""
return|;
block|}
name|PartitionFilterGenerator
name|visitor
init|=
operator|new
name|PartitionFilterGenerator
argument_list|(
name|table
argument_list|,
name|params
argument_list|,
name|joins
argument_list|,
name|dbHasJoinCastBug
argument_list|,
name|defaultPartName
argument_list|,
name|dbType
argument_list|)
decl_stmt|;
name|tree
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
if|if
condition|(
name|visitor
operator|.
name|filterBuffer
operator|.
name|hasError
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Unable to push down SQL filter: "
operator|+
name|visitor
operator|.
name|filterBuffer
operator|.
name|getErrorMessage
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Some joins might be null (see processNode for LeafNode), clean them up.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|joins
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|joins
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|!=
literal|null
condition|)
continue|continue;
name|joins
operator|.
name|remove
argument_list|(
name|i
operator|--
argument_list|)
expr_stmt|;
block|}
return|return
literal|"("
operator|+
name|visitor
operator|.
name|filterBuffer
operator|.
name|getFilter
argument_list|()
operator|+
literal|")"
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|beginTreeNode
parameter_list|(
name|TreeNode
name|node
parameter_list|)
throws|throws
name|MetaException
block|{
name|filterBuffer
operator|.
name|append
argument_list|(
literal|" ("
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|midTreeNode
parameter_list|(
name|TreeNode
name|node
parameter_list|)
throws|throws
name|MetaException
block|{
name|filterBuffer
operator|.
name|append
argument_list|(
operator|(
name|node
operator|.
name|getAndOr
argument_list|()
operator|==
name|LogicalOperator
operator|.
name|AND
operator|)
condition|?
literal|" and "
else|:
literal|" or "
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|endTreeNode
parameter_list|(
name|TreeNode
name|node
parameter_list|)
throws|throws
name|MetaException
block|{
name|filterBuffer
operator|.
name|append
argument_list|(
literal|") "
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|shouldStop
parameter_list|()
block|{
return|return
name|filterBuffer
operator|.
name|hasError
argument_list|()
return|;
block|}
specifier|private
specifier|static
enum|enum
name|FilterType
block|{
name|Integral
block|,
name|String
block|,
name|Date
block|,
name|Invalid
block|;
specifier|static
name|FilterType
name|fromType
parameter_list|(
name|String
name|colTypeStr
parameter_list|)
block|{
if|if
condition|(
name|colTypeStr
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|STRING_TYPE_NAME
argument_list|)
condition|)
block|{
return|return
name|FilterType
operator|.
name|String
return|;
block|}
elseif|else
if|if
condition|(
name|colTypeStr
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|DATE_TYPE_NAME
argument_list|)
condition|)
block|{
return|return
name|FilterType
operator|.
name|Date
return|;
block|}
elseif|else
if|if
condition|(
name|serdeConstants
operator|.
name|IntegralTypes
operator|.
name|contains
argument_list|(
name|colTypeStr
argument_list|)
condition|)
block|{
return|return
name|FilterType
operator|.
name|Integral
return|;
block|}
return|return
name|FilterType
operator|.
name|Invalid
return|;
block|}
specifier|public
specifier|static
name|FilterType
name|fromClass
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
return|return
name|FilterType
operator|.
name|String
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Long
condition|)
block|{
return|return
name|FilterType
operator|.
name|Integral
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|java
operator|.
name|sql
operator|.
name|Date
condition|)
block|{
return|return
name|FilterType
operator|.
name|Date
return|;
block|}
return|return
name|FilterType
operator|.
name|Invalid
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LeafNode
name|node
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|node
operator|.
name|operator
operator|==
name|Operator
operator|.
name|LIKE
condition|)
block|{
name|filterBuffer
operator|.
name|setError
argument_list|(
literal|"LIKE is not supported for SQL filter pushdown"
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|partColCount
init|=
name|table
operator|.
name|getPartitionKeys
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|partColIndex
init|=
name|node
operator|.
name|getPartColIndexForFilter
argument_list|(
name|table
argument_list|,
name|filterBuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|filterBuffer
operator|.
name|hasError
argument_list|()
condition|)
return|return;
comment|// We skipped 'like', other ops should all work as long as the types are right.
name|String
name|colTypeStr
init|=
name|table
operator|.
name|getPartitionKeys
argument_list|()
operator|.
name|get
argument_list|(
name|partColIndex
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|FilterType
name|colType
init|=
name|FilterType
operator|.
name|fromType
argument_list|(
name|colTypeStr
argument_list|)
decl_stmt|;
if|if
condition|(
name|colType
operator|==
name|FilterType
operator|.
name|Invalid
condition|)
block|{
name|filterBuffer
operator|.
name|setError
argument_list|(
literal|"Filter pushdown not supported for type "
operator|+
name|colTypeStr
argument_list|)
expr_stmt|;
return|return;
block|}
name|FilterType
name|valType
init|=
name|FilterType
operator|.
name|fromClass
argument_list|(
name|node
operator|.
name|value
argument_list|)
decl_stmt|;
name|Object
name|nodeValue
init|=
name|node
operator|.
name|value
decl_stmt|;
if|if
condition|(
name|valType
operator|==
name|FilterType
operator|.
name|Invalid
condition|)
block|{
name|filterBuffer
operator|.
name|setError
argument_list|(
literal|"Filter pushdown not supported for value "
operator|+
name|node
operator|.
name|value
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// if Filter.g does date parsing for quoted strings, we'd need to verify there's no
comment|// type mismatch when string col is filtered by a string that looks like date.
if|if
condition|(
name|colType
operator|==
name|FilterType
operator|.
name|Date
operator|&&
name|valType
operator|==
name|FilterType
operator|.
name|String
condition|)
block|{
comment|// Filter.g cannot parse a quoted date; try to parse date here too.
try|try
block|{
name|nodeValue
operator|=
operator|new
name|java
operator|.
name|sql
operator|.
name|Date
argument_list|(
name|HiveMetaStore
operator|.
name|PARTITION_DATE_FORMAT
operator|.
name|get
argument_list|()
operator|.
name|parse
argument_list|(
operator|(
name|String
operator|)
name|nodeValue
argument_list|)
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
name|valType
operator|=
name|FilterType
operator|.
name|Date
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|pe
parameter_list|)
block|{
comment|// do nothing, handled below - types will mismatch
block|}
block|}
if|if
condition|(
name|colType
operator|!=
name|valType
condition|)
block|{
comment|// It's not clear how filtering for e.g. "stringCol> 5" should work (which side is
comment|// to be coerced?). Let the expression evaluation sort this one out, not metastore.
name|filterBuffer
operator|.
name|setError
argument_list|(
literal|"Cannot push down filter for "
operator|+
name|colTypeStr
operator|+
literal|" column and value "
operator|+
name|nodeValue
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|joins
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// There's a fixed number of partition cols that we might have filters on. To avoid
comment|// joining multiple times for one column (if there are several filters on it), we will
comment|// keep numCols elements in the list, one for each column; we will fill it with nulls,
comment|// put each join at a corresponding index when necessary, and remove nulls in the end.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partColCount
condition|;
operator|++
name|i
control|)
block|{
name|joins
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|joins
operator|.
name|get
argument_list|(
name|partColIndex
argument_list|)
operator|==
literal|null
condition|)
block|{
name|joins
operator|.
name|set
argument_list|(
name|partColIndex
argument_list|,
literal|"inner join \"PARTITION_KEY_VALS\" \"FILTER"
operator|+
name|partColIndex
operator|+
literal|"\" on \"FILTER"
operator|+
name|partColIndex
operator|+
literal|"\".\"PART_ID\" = \"PARTITIONS\".\"PART_ID\""
operator|+
literal|" and \"FILTER"
operator|+
name|partColIndex
operator|+
literal|"\".\"INTEGER_IDX\" = "
operator|+
name|partColIndex
argument_list|)
expr_stmt|;
block|}
comment|// Build the filter and add parameters linearly; we are traversing leaf nodes LTR.
name|String
name|tableValue
init|=
literal|"\"FILTER"
operator|+
name|partColIndex
operator|+
literal|"\".\"PART_KEY_VAL\""
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|isReverseOrder
condition|)
block|{
name|params
operator|.
name|add
argument_list|(
name|nodeValue
argument_list|)
expr_stmt|;
block|}
name|String
name|tableColumn
init|=
name|tableValue
decl_stmt|;
if|if
condition|(
name|colType
operator|!=
name|FilterType
operator|.
name|String
condition|)
block|{
comment|// The underlying database field is varchar, we need to compare numbers.
if|if
condition|(
name|colType
operator|==
name|FilterType
operator|.
name|Integral
condition|)
block|{
name|tableValue
operator|=
literal|"cast("
operator|+
name|tableValue
operator|+
literal|" as decimal(21,0))"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|colType
operator|==
name|FilterType
operator|.
name|Date
condition|)
block|{
if|if
condition|(
name|dbType
operator|==
name|DatabaseProduct
operator|.
name|ORACLE
condition|)
block|{
comment|// Oracle requires special treatment... as usual.
name|tableValue
operator|=
literal|"TO_DATE("
operator|+
name|tableValue
operator|+
literal|", 'YYYY-MM-DD')"
expr_stmt|;
block|}
else|else
block|{
name|tableValue
operator|=
literal|"cast("
operator|+
name|tableValue
operator|+
literal|" as date)"
expr_stmt|;
block|}
block|}
comment|// Workaround for HIVE_DEFAULT_PARTITION - ignore it like JDO does, for now.
name|String
name|tableValue0
init|=
name|tableValue
decl_stmt|;
name|tableValue
operator|=
literal|"(case when "
operator|+
name|tableColumn
operator|+
literal|"<> ?"
expr_stmt|;
name|params
operator|.
name|add
argument_list|(
name|defaultPartName
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbHasJoinCastBug
condition|)
block|{
comment|// This is a workaround for DERBY-6358 and Oracle bug; it is pretty horrible.
name|tableValue
operator|+=
operator|(
literal|" and \"TBLS\".\"TBL_NAME\" = ? and \"DBS\".\"NAME\" = ? and "
operator|+
literal|"\"FILTER"
operator|+
name|partColIndex
operator|+
literal|"\".\"PART_ID\" = \"PARTITIONS\".\"PART_ID\" and "
operator|+
literal|"\"FILTER"
operator|+
name|partColIndex
operator|+
literal|"\".\"INTEGER_IDX\" = "
operator|+
name|partColIndex
operator|)
expr_stmt|;
name|params
operator|.
name|add
argument_list|(
name|table
operator|.
name|getTableName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
name|params
operator|.
name|add
argument_list|(
name|table
operator|.
name|getDbName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|tableValue
operator|+=
literal|" then "
operator|+
name|tableValue0
operator|+
literal|" else null end)"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|node
operator|.
name|isReverseOrder
condition|)
block|{
name|params
operator|.
name|add
argument_list|(
name|nodeValue
argument_list|)
expr_stmt|;
block|}
name|filterBuffer
operator|.
name|append
argument_list|(
name|node
operator|.
name|isReverseOrder
condition|?
literal|"(? "
operator|+
name|node
operator|.
name|operator
operator|.
name|getSqlOp
argument_list|()
operator|+
literal|" "
operator|+
name|tableValue
operator|+
literal|")"
else|:
literal|"("
operator|+
name|tableValue
operator|+
literal|" "
operator|+
name|node
operator|.
name|operator
operator|.
name|getSqlOp
argument_list|()
operator|+
literal|" ?)"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Retrieve the column statistics for the specified columns of the table. NULL    * is returned if the columns are not provided.    * @param dbName      the database name of the table    * @param tableName   the table name    * @param colNames    the list of the column names    * @return            the column statistics for the specified columns    * @throws MetaException    */
specifier|public
name|ColumnStatistics
name|getTableStats
parameter_list|(
specifier|final
name|String
name|dbName
parameter_list|,
specifier|final
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|colNames
operator|==
literal|null
operator|||
name|colNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|boolean
name|doTrace
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
specifier|final
name|String
name|queryText0
init|=
literal|"select "
operator|+
name|STATS_COLLIST
operator|+
literal|" from \"TAB_COL_STATS\" "
operator|+
literal|" where \"DB_NAME\" = ? and \"TABLE_NAME\" = ? and \"COLUMN_NAME\" in ("
decl_stmt|;
name|Batchable
argument_list|<
name|String
argument_list|,
name|Object
index|[]
argument_list|>
name|b
init|=
operator|new
name|Batchable
argument_list|<
name|String
argument_list|,
name|Object
index|[]
argument_list|>
argument_list|()
block|{
specifier|public
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|run
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|input
parameter_list|)
throws|throws
name|MetaException
block|{
name|String
name|queryText
init|=
name|queryText0
operator|+
name|makeParams
argument_list|(
name|input
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
decl_stmt|;
name|Object
index|[]
name|params
init|=
operator|new
name|Object
index|[
name|input
operator|.
name|size
argument_list|()
operator|+
literal|2
index|]
decl_stmt|;
name|params
index|[
literal|0
index|]
operator|=
name|dbName
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|tableName
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|input
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|params
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|input
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|long
name|start
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|Query
name|query
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|Object
name|qResult
init|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|params
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText0
operator|+
literal|"...)"
argument_list|,
name|start
argument_list|,
operator|(
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qResult
operator|==
literal|null
condition|)
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
name|addQueryAfterUse
argument_list|(
name|query
argument_list|)
expr_stmt|;
return|return
name|ensureList
argument_list|(
name|qResult
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|list
init|=
name|runBatched
argument_list|(
name|colNames
argument_list|,
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|null
return|;
name|ColumnStatisticsDesc
name|csd
init|=
operator|new
name|ColumnStatisticsDesc
argument_list|(
literal|true
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
name|ColumnStatistics
name|result
init|=
name|makeColumnStats
argument_list|(
name|list
argument_list|,
name|csd
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|b
operator|.
name|closeAllQueries
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|public
name|AggrStats
name|aggrColStatsForPartitions
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|,
name|boolean
name|useDensityFunctionForNDVEstimation
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|colNames
operator|.
name|isEmpty
argument_list|()
operator|||
name|partNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Columns is empty or partNames is empty : Short-circuiting stats eval"
argument_list|)
expr_stmt|;
return|return
operator|new
name|AggrStats
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ColumnStatisticsObj
argument_list|>
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
comment|// Nothing to aggregate
block|}
name|long
name|partsFound
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|colStatsList
decl_stmt|;
comment|// Try to read from the cache first
if|if
condition|(
name|isAggregateStatsCacheEnabled
operator|&&
operator|(
name|partNames
operator|.
name|size
argument_list|()
operator|<
name|aggrStatsCache
operator|.
name|getMaxPartsPerCacheNode
argument_list|()
operator|)
condition|)
block|{
name|AggrColStats
name|colStatsAggrCached
decl_stmt|;
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|colStatsAggrFromDB
decl_stmt|;
name|int
name|maxPartsPerCacheNode
init|=
name|aggrStatsCache
operator|.
name|getMaxPartsPerCacheNode
argument_list|()
decl_stmt|;
name|float
name|fpp
init|=
name|aggrStatsCache
operator|.
name|getFalsePositiveProbability
argument_list|()
decl_stmt|;
name|colStatsList
operator|=
operator|new
name|ArrayList
argument_list|<
name|ColumnStatisticsObj
argument_list|>
argument_list|()
expr_stmt|;
comment|// Bloom filter for the new node that we will eventually add to the cache
name|BloomFilter
name|bloomFilter
init|=
name|createPartsBloomFilter
argument_list|(
name|maxPartsPerCacheNode
argument_list|,
name|fpp
argument_list|,
name|partNames
argument_list|)
decl_stmt|;
name|boolean
name|computePartsFound
init|=
literal|true
decl_stmt|;
for|for
control|(
name|String
name|colName
range|:
name|colNames
control|)
block|{
comment|// Check the cache first
name|colStatsAggrCached
operator|=
name|aggrStatsCache
operator|.
name|get
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|colName
argument_list|,
name|partNames
argument_list|)
expr_stmt|;
if|if
condition|(
name|colStatsAggrCached
operator|!=
literal|null
condition|)
block|{
name|colStatsList
operator|.
name|add
argument_list|(
name|colStatsAggrCached
operator|.
name|getColStats
argument_list|()
argument_list|)
expr_stmt|;
name|partsFound
operator|=
name|colStatsAggrCached
operator|.
name|getNumPartsCached
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|computePartsFound
condition|)
block|{
name|partsFound
operator|=
name|partsFoundForPartitions
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|colNames
argument_list|)
expr_stmt|;
name|computePartsFound
operator|=
literal|false
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|colNamesForDB
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|colNamesForDB
operator|.
name|add
argument_list|(
name|colName
argument_list|)
expr_stmt|;
comment|// Read aggregated stats for one column
name|colStatsAggrFromDB
operator|=
name|columnStatisticsObjForPartitions
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|colNamesForDB
argument_list|,
name|partsFound
argument_list|,
name|useDensityFunctionForNDVEstimation
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|colStatsAggrFromDB
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ColumnStatisticsObj
name|colStatsAggr
init|=
name|colStatsAggrFromDB
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|colStatsList
operator|.
name|add
argument_list|(
name|colStatsAggr
argument_list|)
expr_stmt|;
comment|// Update the cache to add this new aggregate node
name|aggrStatsCache
operator|.
name|add
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|colName
argument_list|,
name|partsFound
argument_list|,
name|colStatsAggr
argument_list|,
name|bloomFilter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|partsFound
operator|=
name|partsFoundForPartitions
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|colNames
argument_list|)
expr_stmt|;
name|colStatsList
operator|=
name|columnStatisticsObjForPartitions
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|colNames
argument_list|,
name|partsFound
argument_list|,
name|useDensityFunctionForNDVEstimation
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"useDensityFunctionForNDVEstimation = "
operator|+
name|useDensityFunctionForNDVEstimation
operator|+
literal|"\npartsFound = "
operator|+
name|partsFound
operator|+
literal|"\nColumnStatisticsObj = "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|colStatsList
operator|.
name|toArray
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|AggrStats
argument_list|(
name|colStatsList
argument_list|,
name|partsFound
argument_list|)
return|;
block|}
specifier|private
name|BloomFilter
name|createPartsBloomFilter
parameter_list|(
name|int
name|maxPartsPerCacheNode
parameter_list|,
name|float
name|fpp
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|)
block|{
name|BloomFilter
name|bloomFilter
init|=
operator|new
name|BloomFilter
argument_list|(
name|maxPartsPerCacheNode
argument_list|,
name|fpp
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|partName
range|:
name|partNames
control|)
block|{
name|bloomFilter
operator|.
name|add
argument_list|(
name|partName
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|bloomFilter
return|;
block|}
specifier|private
name|long
name|partsFoundForPartitions
parameter_list|(
specifier|final
name|String
name|dbName
parameter_list|,
specifier|final
name|String
name|tableName
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|)
throws|throws
name|MetaException
block|{
assert|assert
operator|!
name|colNames
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|partNames
operator|.
name|isEmpty
argument_list|()
assert|;
specifier|final
name|boolean
name|doTrace
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
specifier|final
name|String
name|queryText0
init|=
literal|"select count(\"COLUMN_NAME\") from \"PART_COL_STATS\""
operator|+
literal|" where \"DB_NAME\" = ? and \"TABLE_NAME\" = ? "
operator|+
literal|" and \"COLUMN_NAME\" in (%1$s) and \"PARTITION_NAME\" in (%2$s)"
operator|+
literal|" group by \"PARTITION_NAME\""
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|allCounts
init|=
name|runBatched
argument_list|(
name|colNames
argument_list|,
operator|new
name|Batchable
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|()
block|{
specifier|public
name|List
argument_list|<
name|Long
argument_list|>
name|run
parameter_list|(
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|inputColName
parameter_list|)
throws|throws
name|MetaException
block|{
return|return
name|runBatched
argument_list|(
name|partNames
argument_list|,
operator|new
name|Batchable
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|()
block|{
specifier|public
name|List
argument_list|<
name|Long
argument_list|>
name|run
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|inputPartNames
parameter_list|)
throws|throws
name|MetaException
block|{
name|long
name|partsFound
init|=
literal|0
decl_stmt|;
name|String
name|queryText
init|=
name|String
operator|.
name|format
argument_list|(
name|queryText0
argument_list|,
name|makeParams
argument_list|(
name|inputColName
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|makeParams
argument_list|(
name|inputPartNames
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|start
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|Query
name|query
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
try|try
block|{
name|Object
name|qResult
init|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|prepareParams
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|inputPartNames
argument_list|,
name|inputColName
argument_list|)
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|long
name|end
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|ForwardQueryResult
name|fqr
init|=
operator|(
name|ForwardQueryResult
operator|)
name|qResult
decl_stmt|;
name|Iterator
argument_list|<
name|?
argument_list|>
name|iter
init|=
name|fqr
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|extractSqlLong
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|==
name|inputColName
operator|.
name|size
argument_list|()
condition|)
block|{
name|partsFound
operator|++
expr_stmt|;
block|}
block|}
return|return
name|Lists
operator|.
expr|<
name|Long
operator|>
name|newArrayList
argument_list|(
name|partsFound
argument_list|)
return|;
block|}
finally|finally
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|long
name|partsFound
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Long
name|val
range|:
name|allCounts
control|)
block|{
name|partsFound
operator|+=
name|val
expr_stmt|;
block|}
return|return
name|partsFound
return|;
block|}
specifier|private
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|columnStatisticsObjForPartitions
parameter_list|(
specifier|final
name|String
name|dbName
parameter_list|,
specifier|final
name|String
name|tableName
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|,
name|long
name|partsFound
parameter_list|,
specifier|final
name|boolean
name|useDensityFunctionForNDVEstimation
parameter_list|)
throws|throws
name|MetaException
block|{
specifier|final
name|boolean
name|areAllPartsFound
init|=
operator|(
name|partsFound
operator|==
name|partNames
operator|.
name|size
argument_list|()
operator|)
decl_stmt|;
return|return
name|runBatched
argument_list|(
name|colNames
argument_list|,
operator|new
name|Batchable
argument_list|<
name|String
argument_list|,
name|ColumnStatisticsObj
argument_list|>
argument_list|()
block|{
specifier|public
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|run
parameter_list|(
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|inputColNames
parameter_list|)
throws|throws
name|MetaException
block|{
return|return
name|runBatched
argument_list|(
name|partNames
argument_list|,
operator|new
name|Batchable
argument_list|<
name|String
argument_list|,
name|ColumnStatisticsObj
argument_list|>
argument_list|()
block|{
specifier|public
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|run
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|inputPartNames
parameter_list|)
throws|throws
name|MetaException
block|{
return|return
name|columnStatisticsObjForPartitionsBatch
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|inputPartNames
argument_list|,
name|inputColNames
argument_list|,
name|areAllPartsFound
argument_list|,
name|useDensityFunctionForNDVEstimation
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/** Should be called with the list short enough to not trip up Oracle/etc. */
specifier|private
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|columnStatisticsObjForPartitionsBatch
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|,
name|boolean
name|areAllPartsFound
parameter_list|,
name|boolean
name|useDensityFunctionForNDVEstimation
parameter_list|)
throws|throws
name|MetaException
block|{
comment|// TODO: all the extrapolation logic should be moved out of this class,
comment|// only mechanical data retrieval should remain here.
name|String
name|commonPrefix
init|=
literal|"select \"COLUMN_NAME\", \"COLUMN_TYPE\", "
operator|+
literal|"min(\"LONG_LOW_VALUE\"), max(\"LONG_HIGH_VALUE\"), min(\"DOUBLE_LOW_VALUE\"), max(\"DOUBLE_HIGH_VALUE\"), "
operator|+
literal|"min(cast(\"BIG_DECIMAL_LOW_VALUE\" as decimal)), max(cast(\"BIG_DECIMAL_HIGH_VALUE\" as decimal)), "
operator|+
literal|"sum(\"NUM_NULLS\"), max(\"NUM_DISTINCTS\"), "
operator|+
literal|"max(\"AVG_COL_LEN\"), max(\"MAX_COL_LEN\"), sum(\"NUM_TRUES\"), sum(\"NUM_FALSES\"), "
comment|// The following data is used to compute a partitioned table's NDV based
comment|// on partitions' NDV when useDensityFunctionForNDVEstimation = true. Global NDVs cannot be
comment|// accurately derived from partition NDVs, because the domain of column value two partitions
comment|// can overlap. If there is no overlap then global NDV is just the sum
comment|// of partition NDVs (UpperBound). But if there is some overlay then
comment|// global NDV can be anywhere between sum of partition NDVs (no overlap)
comment|// and same as one of the partition NDV (domain of column value in all other
comment|// partitions is subset of the domain value in one of the partition)
comment|// (LowerBound).But under uniform distribution, we can roughly estimate the global
comment|// NDV by leveraging the min/max values.
comment|// And, we also guarantee that the estimation makes sense by comparing it to the
comment|// UpperBound (calculated by "sum(\"NUM_DISTINCTS\")")
comment|// and LowerBound (calculated by "max(\"NUM_DISTINCTS\")")
operator|+
literal|"avg((\"LONG_HIGH_VALUE\"-\"LONG_LOW_VALUE\")/cast(\"NUM_DISTINCTS\" as decimal)),"
operator|+
literal|"avg((\"DOUBLE_HIGH_VALUE\"-\"DOUBLE_LOW_VALUE\")/\"NUM_DISTINCTS\"),"
operator|+
literal|"avg((cast(\"BIG_DECIMAL_HIGH_VALUE\" as decimal)-cast(\"BIG_DECIMAL_LOW_VALUE\" as decimal))/\"NUM_DISTINCTS\"),"
operator|+
literal|"sum(\"NUM_DISTINCTS\")"
operator|+
literal|" from \"PART_COL_STATS\""
operator|+
literal|" where \"DB_NAME\" = ? and \"TABLE_NAME\" = ? "
decl_stmt|;
name|String
name|queryText
init|=
literal|null
decl_stmt|;
name|long
name|start
init|=
literal|0
decl_stmt|;
name|long
name|end
init|=
literal|0
decl_stmt|;
name|Query
name|query
init|=
literal|null
decl_stmt|;
name|boolean
name|doTrace
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
name|Object
name|qResult
init|=
literal|null
decl_stmt|;
name|ForwardQueryResult
name|fqr
init|=
literal|null
decl_stmt|;
comment|// Check if the status of all the columns of all the partitions exists
comment|// Extrapolation is not needed.
if|if
condition|(
name|areAllPartsFound
condition|)
block|{
name|queryText
operator|=
name|commonPrefix
operator|+
literal|" and \"COLUMN_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|colNames
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
operator|+
literal|" and \"PARTITION_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|partNames
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
operator|+
literal|" group by \"COLUMN_NAME\", \"COLUMN_TYPE\""
expr_stmt|;
name|start
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|query
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
name|qResult
operator|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|prepareParams
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|colNames
argument_list|)
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
if|if
condition|(
name|qResult
operator|==
literal|null
condition|)
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
return|return
name|Lists
operator|.
name|newArrayList
argument_list|()
return|;
block|}
name|end
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|list
init|=
name|ensureList
argument_list|(
name|qResult
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|colStats
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnStatisticsObj
argument_list|>
argument_list|(
name|list
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Object
index|[]
name|row
range|:
name|list
control|)
block|{
name|colStats
operator|.
name|add
argument_list|(
name|prepareCSObjWithAdjustedNDV
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|useDensityFunctionForNDVEstimation
argument_list|)
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
block|}
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
return|return
name|colStats
return|;
block|}
else|else
block|{
comment|// Extrapolation is needed for some columns.
comment|// In this case, at least a column status for a partition is missing.
comment|// We need to extrapolate this partition based on the other partitions
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|colStats
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnStatisticsObj
argument_list|>
argument_list|(
name|colNames
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|queryText
operator|=
literal|"select \"COLUMN_NAME\", \"COLUMN_TYPE\", count(\"PARTITION_NAME\") "
operator|+
literal|" from \"PART_COL_STATS\""
operator|+
literal|" where \"DB_NAME\" = ? and \"TABLE_NAME\" = ? "
operator|+
literal|" and \"COLUMN_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|colNames
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
operator|+
literal|" and \"PARTITION_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|partNames
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
operator|+
literal|" group by \"COLUMN_NAME\", \"COLUMN_TYPE\""
expr_stmt|;
name|start
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|query
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
name|qResult
operator|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|prepareParams
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|colNames
argument_list|)
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
name|end
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|qResult
operator|==
literal|null
condition|)
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
return|return
name|Lists
operator|.
name|newArrayList
argument_list|()
return|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|noExtraColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
index|[]
argument_list|>
name|extraColumnNameTypeParts
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
index|[]
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|list
init|=
name|ensureList
argument_list|(
name|qResult
argument_list|)
decl_stmt|;
for|for
control|(
name|Object
index|[]
name|row
range|:
name|list
control|)
block|{
name|String
name|colName
init|=
operator|(
name|String
operator|)
name|row
index|[
literal|0
index|]
decl_stmt|;
name|String
name|colType
init|=
operator|(
name|String
operator|)
name|row
index|[
literal|1
index|]
decl_stmt|;
comment|// Extrapolation is not needed for this column if
comment|// count(\"PARTITION_NAME\")==partNames.size()
comment|// Or, extrapolation is not possible for this column if
comment|// count(\"PARTITION_NAME\")<2
name|Long
name|count
init|=
name|extractSqlLong
argument_list|(
name|row
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|==
name|partNames
operator|.
name|size
argument_list|()
operator|||
name|count
operator|<
literal|2
condition|)
block|{
name|noExtraColumnNames
operator|.
name|add
argument_list|(
name|colName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|extraColumnNameTypeParts
operator|.
name|put
argument_list|(
name|colName
argument_list|,
operator|new
name|String
index|[]
block|{
name|colType
block|,
name|String
operator|.
name|valueOf
argument_list|(
name|count
argument_list|)
block|}
argument_list|)
expr_stmt|;
block|}
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
block|}
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
comment|// Extrapolation is not needed for columns noExtraColumnNames
if|if
condition|(
name|noExtraColumnNames
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|queryText
operator|=
name|commonPrefix
operator|+
literal|" and \"COLUMN_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|noExtraColumnNames
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
operator|+
literal|" and \"PARTITION_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|partNames
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
operator|+
literal|" group by \"COLUMN_NAME\", \"COLUMN_TYPE\""
expr_stmt|;
name|start
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|query
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
name|qResult
operator|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|prepareParams
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|noExtraColumnNames
argument_list|)
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
if|if
condition|(
name|qResult
operator|==
literal|null
condition|)
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
return|return
name|Lists
operator|.
name|newArrayList
argument_list|()
return|;
block|}
name|list
operator|=
name|ensureList
argument_list|(
name|qResult
argument_list|)
expr_stmt|;
for|for
control|(
name|Object
index|[]
name|row
range|:
name|list
control|)
block|{
name|colStats
operator|.
name|add
argument_list|(
name|prepareCSObjWithAdjustedNDV
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|useDensityFunctionForNDVEstimation
argument_list|)
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
block|}
name|end
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
comment|// Extrapolation is needed for extraColumnNames.
comment|// give a sequence number for all the partitions
if|if
condition|(
name|extraColumnNameTypeParts
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|indexMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|partNames
operator|.
name|size
argument_list|()
condition|;
name|index
operator|++
control|)
block|{
name|indexMap
operator|.
name|put
argument_list|(
name|partNames
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
comment|// get sum for all columns to reduce the number of queries
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|Object
argument_list|>
argument_list|>
name|sumMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|Object
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|queryText
operator|=
literal|"select \"COLUMN_NAME\", sum(\"NUM_NULLS\"), sum(\"NUM_TRUES\"), sum(\"NUM_FALSES\"), sum(\"NUM_DISTINCTS\")"
operator|+
literal|" from \"PART_COL_STATS\" where \"DB_NAME\" = ? and \"TABLE_NAME\" = ? "
operator|+
literal|" and \"COLUMN_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|extraColumnNameTypeParts
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|") and \"PARTITION_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|partNames
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|") group by \"COLUMN_NAME\""
expr_stmt|;
name|start
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|query
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|extraColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|extraColumnNames
operator|.
name|addAll
argument_list|(
name|extraColumnNameTypeParts
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|qResult
operator|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|prepareParams
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|extraColumnNames
argument_list|)
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
if|if
condition|(
name|qResult
operator|==
literal|null
condition|)
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
return|return
name|Lists
operator|.
name|newArrayList
argument_list|()
return|;
block|}
name|list
operator|=
name|ensureList
argument_list|(
name|qResult
argument_list|)
expr_stmt|;
comment|// see the indexes for colstats in IExtrapolatePartStatus
name|Integer
index|[]
name|sumIndex
init|=
operator|new
name|Integer
index|[]
block|{
literal|6
block|,
literal|10
block|,
literal|11
block|,
literal|15
block|}
decl_stmt|;
for|for
control|(
name|Object
index|[]
name|row
range|:
name|list
control|)
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|Object
argument_list|>
name|indexToObject
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|ind
init|=
literal|1
init|;
name|ind
operator|<
name|row
operator|.
name|length
condition|;
name|ind
operator|++
control|)
block|{
name|indexToObject
operator|.
name|put
argument_list|(
name|sumIndex
index|[
name|ind
operator|-
literal|1
index|]
argument_list|,
name|row
index|[
name|ind
index|]
argument_list|)
expr_stmt|;
block|}
comment|// row[0] is the column name
name|sumMap
operator|.
name|put
argument_list|(
operator|(
name|String
operator|)
name|row
index|[
literal|0
index|]
argument_list|,
name|indexToObject
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
block|}
name|end
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
index|[]
argument_list|>
name|entry
range|:
name|extraColumnNameTypeParts
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Object
index|[]
name|row
init|=
operator|new
name|Object
index|[
name|IExtrapolatePartStatus
operator|.
name|colStatNames
operator|.
name|length
operator|+
literal|2
index|]
decl_stmt|;
name|String
name|colName
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|colType
init|=
name|entry
operator|.
name|getValue
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
name|Long
name|sumVal
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
comment|// fill in colname
name|row
index|[
literal|0
index|]
operator|=
name|colName
expr_stmt|;
comment|// fill in coltype
name|row
index|[
literal|1
index|]
operator|=
name|colType
expr_stmt|;
comment|// use linear extrapolation. more complicated one can be added in the
comment|// future.
name|IExtrapolatePartStatus
name|extrapolateMethod
init|=
operator|new
name|LinearExtrapolatePartStatus
argument_list|()
decl_stmt|;
comment|// fill in colstatus
name|Integer
index|[]
name|index
init|=
literal|null
decl_stmt|;
name|boolean
name|decimal
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|colType
operator|.
name|toLowerCase
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"decimal"
argument_list|)
condition|)
block|{
name|index
operator|=
name|IExtrapolatePartStatus
operator|.
name|indexMaps
operator|.
name|get
argument_list|(
literal|"decimal"
argument_list|)
expr_stmt|;
name|decimal
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|index
operator|=
name|IExtrapolatePartStatus
operator|.
name|indexMaps
operator|.
name|get
argument_list|(
name|colType
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// if the colType is not the known type, long, double, etc, then get
comment|// all index.
if|if
condition|(
name|index
operator|==
literal|null
condition|)
block|{
name|index
operator|=
name|IExtrapolatePartStatus
operator|.
name|indexMaps
operator|.
name|get
argument_list|(
literal|"default"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|colStatIndex
range|:
name|index
control|)
block|{
name|String
name|colStatName
init|=
name|IExtrapolatePartStatus
operator|.
name|colStatNames
index|[
name|colStatIndex
index|]
decl_stmt|;
comment|// if the aggregation type is sum, we do a scale-up
if|if
condition|(
name|IExtrapolatePartStatus
operator|.
name|aggrTypes
index|[
name|colStatIndex
index|]
operator|==
name|IExtrapolatePartStatus
operator|.
name|AggrType
operator|.
name|Sum
condition|)
block|{
name|Object
name|o
init|=
name|sumMap
operator|.
name|get
argument_list|(
name|colName
argument_list|)
operator|.
name|get
argument_list|(
name|colStatIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
name|row
index|[
literal|2
operator|+
name|colStatIndex
index|]
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|Long
name|val
init|=
name|extractSqlLong
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|row
index|[
literal|2
operator|+
name|colStatIndex
index|]
operator|=
call|(
name|Long
call|)
argument_list|(
name|val
operator|/
name|sumVal
operator|*
operator|(
name|partNames
operator|.
name|size
argument_list|()
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IExtrapolatePartStatus
operator|.
name|aggrTypes
index|[
name|colStatIndex
index|]
operator|==
name|IExtrapolatePartStatus
operator|.
name|AggrType
operator|.
name|Min
operator|||
name|IExtrapolatePartStatus
operator|.
name|aggrTypes
index|[
name|colStatIndex
index|]
operator|==
name|IExtrapolatePartStatus
operator|.
name|AggrType
operator|.
name|Max
condition|)
block|{
comment|// if the aggregation type is min/max, we extrapolate from the
comment|// left/right borders
if|if
condition|(
operator|!
name|decimal
condition|)
block|{
name|queryText
operator|=
literal|"select \""
operator|+
name|colStatName
operator|+
literal|"\",\"PARTITION_NAME\" from \"PART_COL_STATS\""
operator|+
literal|" where \"DB_NAME\" = ? and \"TABLE_NAME\" = ?"
operator|+
literal|" and \"COLUMN_NAME\" = ?"
operator|+
literal|" and \"PARTITION_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|partNames
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
operator|+
literal|" order by \""
operator|+
name|colStatName
operator|+
literal|"\""
expr_stmt|;
block|}
else|else
block|{
name|queryText
operator|=
literal|"select \""
operator|+
name|colStatName
operator|+
literal|"\",\"PARTITION_NAME\" from \"PART_COL_STATS\""
operator|+
literal|" where \"DB_NAME\" = ? and \"TABLE_NAME\" = ?"
operator|+
literal|" and \"COLUMN_NAME\" = ?"
operator|+
literal|" and \"PARTITION_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|partNames
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
operator|+
literal|" order by cast(\""
operator|+
name|colStatName
operator|+
literal|"\" as decimal)"
expr_stmt|;
block|}
name|start
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|query
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
name|qResult
operator|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|prepareParams
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|colName
argument_list|)
argument_list|)
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
if|if
condition|(
name|qResult
operator|==
literal|null
condition|)
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
return|return
name|Lists
operator|.
name|newArrayList
argument_list|()
return|;
block|}
name|fqr
operator|=
operator|(
name|ForwardQueryResult
operator|)
name|qResult
expr_stmt|;
name|Object
index|[]
name|min
init|=
operator|(
name|Object
index|[]
operator|)
operator|(
name|fqr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
decl_stmt|;
name|Object
index|[]
name|max
init|=
operator|(
name|Object
index|[]
operator|)
operator|(
name|fqr
operator|.
name|get
argument_list|(
name|fqr
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|)
decl_stmt|;
name|end
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
if|if
condition|(
name|min
index|[
literal|0
index|]
operator|==
literal|null
operator|||
name|max
index|[
literal|0
index|]
operator|==
literal|null
condition|)
block|{
name|row
index|[
literal|2
operator|+
name|colStatIndex
index|]
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|row
index|[
literal|2
operator|+
name|colStatIndex
index|]
operator|=
name|extrapolateMethod
operator|.
name|extrapolate
argument_list|(
name|min
argument_list|,
name|max
argument_list|,
name|colStatIndex
argument_list|,
name|indexMap
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// if the aggregation type is avg, we use the average on the existing ones.
name|queryText
operator|=
literal|"select "
operator|+
literal|"avg((\"LONG_HIGH_VALUE\"-\"LONG_LOW_VALUE\")/cast(\"NUM_DISTINCTS\" as decimal)),"
operator|+
literal|"avg((\"DOUBLE_HIGH_VALUE\"-\"DOUBLE_LOW_VALUE\")/\"NUM_DISTINCTS\"),"
operator|+
literal|"avg((cast(\"BIG_DECIMAL_HIGH_VALUE\" as decimal)-cast(\"BIG_DECIMAL_LOW_VALUE\" as decimal))/\"NUM_DISTINCTS\")"
operator|+
literal|" from \"PART_COL_STATS\""
operator|+
literal|" where \"DB_NAME\" = ? and \"TABLE_NAME\" = ?"
operator|+
literal|" and \"COLUMN_NAME\" = ?"
operator|+
literal|" and \"PARTITION_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|partNames
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
operator|+
literal|" group by \"COLUMN_NAME\""
expr_stmt|;
name|start
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|query
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
name|qResult
operator|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|prepareParams
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|colName
argument_list|)
argument_list|)
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
if|if
condition|(
name|qResult
operator|==
literal|null
condition|)
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
return|return
name|Lists
operator|.
name|newArrayList
argument_list|()
return|;
block|}
name|fqr
operator|=
operator|(
name|ForwardQueryResult
operator|)
name|qResult
expr_stmt|;
name|Object
index|[]
name|avg
init|=
operator|(
name|Object
index|[]
operator|)
operator|(
name|fqr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
decl_stmt|;
comment|// colStatIndex=12,13,14 respond to "AVG_LONG", "AVG_DOUBLE",
comment|// "AVG_DECIMAL"
name|row
index|[
literal|2
operator|+
name|colStatIndex
index|]
operator|=
name|avg
index|[
name|colStatIndex
operator|-
literal|12
index|]
expr_stmt|;
name|end
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
block|}
name|colStats
operator|.
name|add
argument_list|(
name|prepareCSObjWithAdjustedNDV
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|useDensityFunctionForNDVEstimation
argument_list|)
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|colStats
return|;
block|}
block|}
specifier|private
name|ColumnStatisticsObj
name|prepareCSObj
parameter_list|(
name|Object
index|[]
name|row
parameter_list|,
name|int
name|i
parameter_list|)
throws|throws
name|MetaException
block|{
name|ColumnStatisticsData
name|data
init|=
operator|new
name|ColumnStatisticsData
argument_list|()
decl_stmt|;
name|ColumnStatisticsObj
name|cso
init|=
operator|new
name|ColumnStatisticsObj
argument_list|(
operator|(
name|String
operator|)
name|row
index|[
name|i
operator|++
index|]
argument_list|,
operator|(
name|String
operator|)
name|row
index|[
name|i
operator|++
index|]
argument_list|,
name|data
argument_list|)
decl_stmt|;
name|Object
name|llow
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|lhigh
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|dlow
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|dhigh
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|declow
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|dechigh
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|nulls
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|dist
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|avglen
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|maxlen
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|trues
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|falses
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|;
name|StatObjectConverter
operator|.
name|fillColumnStatisticsData
argument_list|(
name|cso
operator|.
name|getColType
argument_list|()
argument_list|,
name|data
argument_list|,
name|llow
argument_list|,
name|lhigh
argument_list|,
name|dlow
argument_list|,
name|dhigh
argument_list|,
name|declow
argument_list|,
name|dechigh
argument_list|,
name|nulls
argument_list|,
name|dist
argument_list|,
name|avglen
argument_list|,
name|maxlen
argument_list|,
name|trues
argument_list|,
name|falses
argument_list|)
expr_stmt|;
return|return
name|cso
return|;
block|}
specifier|private
name|ColumnStatisticsObj
name|prepareCSObjWithAdjustedNDV
parameter_list|(
name|Object
index|[]
name|row
parameter_list|,
name|int
name|i
parameter_list|,
name|boolean
name|useDensityFunctionForNDVEstimation
parameter_list|)
throws|throws
name|MetaException
block|{
name|ColumnStatisticsData
name|data
init|=
operator|new
name|ColumnStatisticsData
argument_list|()
decl_stmt|;
name|ColumnStatisticsObj
name|cso
init|=
operator|new
name|ColumnStatisticsObj
argument_list|(
operator|(
name|String
operator|)
name|row
index|[
name|i
operator|++
index|]
argument_list|,
operator|(
name|String
operator|)
name|row
index|[
name|i
operator|++
index|]
argument_list|,
name|data
argument_list|)
decl_stmt|;
name|Object
name|llow
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|lhigh
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|dlow
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|dhigh
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|declow
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|dechigh
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|nulls
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|dist
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|avglen
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|maxlen
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|trues
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|falses
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|avgLong
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|avgDouble
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|avgDecimal
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|sumDist
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|;
name|StatObjectConverter
operator|.
name|fillColumnStatisticsData
argument_list|(
name|cso
operator|.
name|getColType
argument_list|()
argument_list|,
name|data
argument_list|,
name|llow
argument_list|,
name|lhigh
argument_list|,
name|dlow
argument_list|,
name|dhigh
argument_list|,
name|declow
argument_list|,
name|dechigh
argument_list|,
name|nulls
argument_list|,
name|dist
argument_list|,
name|avglen
argument_list|,
name|maxlen
argument_list|,
name|trues
argument_list|,
name|falses
argument_list|,
name|avgLong
argument_list|,
name|avgDouble
argument_list|,
name|avgDecimal
argument_list|,
name|sumDist
argument_list|,
name|useDensityFunctionForNDVEstimation
argument_list|)
expr_stmt|;
return|return
name|cso
return|;
block|}
specifier|private
name|Object
index|[]
name|prepareParams
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|)
throws|throws
name|MetaException
block|{
name|Object
index|[]
name|params
init|=
operator|new
name|Object
index|[
name|colNames
operator|.
name|size
argument_list|()
operator|+
name|partNames
operator|.
name|size
argument_list|()
operator|+
literal|2
index|]
decl_stmt|;
name|int
name|paramI
init|=
literal|0
decl_stmt|;
name|params
index|[
name|paramI
operator|++
index|]
operator|=
name|dbName
expr_stmt|;
name|params
index|[
name|paramI
operator|++
index|]
operator|=
name|tableName
expr_stmt|;
for|for
control|(
name|String
name|colName
range|:
name|colNames
control|)
block|{
name|params
index|[
name|paramI
operator|++
index|]
operator|=
name|colName
expr_stmt|;
block|}
for|for
control|(
name|String
name|partName
range|:
name|partNames
control|)
block|{
name|params
index|[
name|paramI
operator|++
index|]
operator|=
name|partName
expr_stmt|;
block|}
return|return
name|params
return|;
block|}
specifier|public
name|List
argument_list|<
name|ColumnStatistics
argument_list|>
name|getPartitionStats
parameter_list|(
specifier|final
name|String
name|dbName
parameter_list|,
specifier|final
name|String
name|tableName
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|colNames
operator|.
name|isEmpty
argument_list|()
operator|||
name|partNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Lists
operator|.
name|newArrayList
argument_list|()
return|;
block|}
specifier|final
name|boolean
name|doTrace
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
specifier|final
name|String
name|queryText0
init|=
literal|"select \"PARTITION_NAME\", "
operator|+
name|STATS_COLLIST
operator|+
literal|" from "
operator|+
literal|" \"PART_COL_STATS\" where \"DB_NAME\" = ? and \"TABLE_NAME\" = ? and \"COLUMN_NAME\""
operator|+
literal|"  in (%1$s) AND \"PARTITION_NAME\" in (%2$s) order by \"PARTITION_NAME\""
decl_stmt|;
name|Batchable
argument_list|<
name|String
argument_list|,
name|Object
index|[]
argument_list|>
name|b
init|=
operator|new
name|Batchable
argument_list|<
name|String
argument_list|,
name|Object
index|[]
argument_list|>
argument_list|()
block|{
specifier|public
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|run
parameter_list|(
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|inputColNames
parameter_list|)
throws|throws
name|MetaException
block|{
name|Batchable
argument_list|<
name|String
argument_list|,
name|Object
index|[]
argument_list|>
name|b2
init|=
operator|new
name|Batchable
argument_list|<
name|String
argument_list|,
name|Object
index|[]
argument_list|>
argument_list|()
block|{
specifier|public
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|run
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|inputPartNames
parameter_list|)
throws|throws
name|MetaException
block|{
name|String
name|queryText
init|=
name|String
operator|.
name|format
argument_list|(
name|queryText0
argument_list|,
name|makeParams
argument_list|(
name|inputColNames
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|makeParams
argument_list|(
name|inputPartNames
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|start
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|Query
name|query
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|Object
name|qResult
init|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|prepareParams
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|inputPartNames
argument_list|,
name|inputColNames
argument_list|)
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText0
argument_list|,
name|start
argument_list|,
operator|(
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qResult
operator|==
literal|null
condition|)
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
return|return
name|Lists
operator|.
name|newArrayList
argument_list|()
return|;
block|}
name|addQueryAfterUse
argument_list|(
name|query
argument_list|)
expr_stmt|;
return|return
name|ensureList
argument_list|(
name|qResult
argument_list|)
return|;
block|}
block|}
decl_stmt|;
try|try
block|{
return|return
name|runBatched
argument_list|(
name|partNames
argument_list|,
name|b2
argument_list|)
return|;
block|}
finally|finally
block|{
name|addQueryAfterUse
argument_list|(
name|b2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|list
init|=
name|runBatched
argument_list|(
name|colNames
argument_list|,
name|b
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ColumnStatistics
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnStatistics
argument_list|>
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|list
operator|.
name|size
argument_list|()
argument_list|,
name|partNames
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|lastPartName
init|=
literal|null
decl_stmt|;
name|int
name|from
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|boolean
name|isLast
init|=
name|i
operator|==
name|list
operator|.
name|size
argument_list|()
decl_stmt|;
name|String
name|partName
init|=
name|isLast
condition|?
literal|null
else|:
operator|(
name|String
operator|)
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|isLast
operator|&&
name|partName
operator|.
name|equals
argument_list|(
name|lastPartName
argument_list|)
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|from
operator|!=
name|i
condition|)
block|{
name|ColumnStatisticsDesc
name|csd
init|=
operator|new
name|ColumnStatisticsDesc
argument_list|(
literal|false
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
name|csd
operator|.
name|setPartName
argument_list|(
name|lastPartName
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
name|makeColumnStats
argument_list|(
name|list
operator|.
name|subList
argument_list|(
name|from
argument_list|,
name|i
argument_list|)
argument_list|,
name|csd
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lastPartName
operator|=
name|partName
expr_stmt|;
name|from
operator|=
name|i
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
block|}
name|b
operator|.
name|closeAllQueries
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/** The common query part for table and partition stats */
specifier|private
specifier|static
specifier|final
name|String
name|STATS_COLLIST
init|=
literal|"\"COLUMN_NAME\", \"COLUMN_TYPE\", \"LONG_LOW_VALUE\", \"LONG_HIGH_VALUE\", "
operator|+
literal|"\"DOUBLE_LOW_VALUE\", \"DOUBLE_HIGH_VALUE\", \"BIG_DECIMAL_LOW_VALUE\", "
operator|+
literal|"\"BIG_DECIMAL_HIGH_VALUE\", \"NUM_NULLS\", \"NUM_DISTINCTS\", \"AVG_COL_LEN\", "
operator|+
literal|"\"MAX_COL_LEN\", \"NUM_TRUES\", \"NUM_FALSES\", \"LAST_ANALYZED\" "
decl_stmt|;
specifier|private
name|ColumnStatistics
name|makeColumnStats
parameter_list|(
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|list
parameter_list|,
name|ColumnStatisticsDesc
name|csd
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|MetaException
block|{
name|ColumnStatistics
name|result
init|=
operator|new
name|ColumnStatistics
argument_list|()
decl_stmt|;
name|result
operator|.
name|setStatsDesc
argument_list|(
name|csd
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|csos
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnStatisticsObj
argument_list|>
argument_list|(
name|list
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Object
index|[]
name|row
range|:
name|list
control|)
block|{
comment|// LastAnalyzed is stored per column but thrift has it per several;
comment|// get the lowest for now as nobody actually uses this field.
name|Object
name|laObj
init|=
name|row
index|[
name|offset
operator|+
literal|14
index|]
decl_stmt|;
if|if
condition|(
name|laObj
operator|!=
literal|null
operator|&&
operator|(
operator|!
name|csd
operator|.
name|isSetLastAnalyzed
argument_list|()
operator|||
name|csd
operator|.
name|getLastAnalyzed
argument_list|()
operator|>
name|extractSqlLong
argument_list|(
name|laObj
argument_list|)
operator|)
condition|)
block|{
name|csd
operator|.
name|setLastAnalyzed
argument_list|(
name|extractSqlLong
argument_list|(
name|laObj
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|csos
operator|.
name|add
argument_list|(
name|prepareCSObj
argument_list|(
name|row
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|setStatsObj
argument_list|(
name|csos
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|ensureList
parameter_list|(
name|Object
name|result
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
operator|!
operator|(
name|result
operator|instanceof
name|List
argument_list|<
name|?
argument_list|>
operator|)
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Wrong result type "
operator|+
name|result
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
return|return
operator|(
name|List
argument_list|<
name|Object
index|[]
argument_list|>
operator|)
name|result
return|;
block|}
specifier|private
name|String
name|makeParams
parameter_list|(
name|int
name|size
parameter_list|)
block|{
comment|// W/ size 0, query will fail, but at least we'd get to see the query in debug output.
return|return
operator|(
name|size
operator|==
literal|0
operator|)
condition|?
literal|""
else|:
name|repeat
argument_list|(
literal|",?"
argument_list|,
name|size
argument_list|)
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
parameter_list|<
name|T
parameter_list|>
name|T
name|executeWithArray
parameter_list|(
name|Query
name|query
parameter_list|,
name|Object
index|[]
name|params
parameter_list|,
name|String
name|sql
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
return|return
call|(
name|T
call|)
argument_list|(
operator|(
name|params
operator|==
literal|null
operator|)
condition|?
name|query
operator|.
name|execute
argument_list|()
else|:
name|query
operator|.
name|executeWithArray
argument_list|(
name|params
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|String
name|error
init|=
literal|"Failed to execute ["
operator|+
name|sql
operator|+
literal|"] with parameters ["
decl_stmt|;
if|if
condition|(
name|params
operator|!=
literal|null
condition|)
block|{
name|boolean
name|isFirst
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Object
name|param
range|:
name|params
control|)
block|{
name|error
operator|+=
operator|(
name|isFirst
condition|?
literal|""
else|:
literal|", "
operator|)
operator|+
name|param
expr_stmt|;
name|isFirst
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|warn
argument_list|(
name|error
operator|+
literal|"]"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
comment|// We just logged an exception with (in case of JDO) a humongous callstack. Make a new one.
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"See previous errors; "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * This run the necessary logic to prepare for queries. It should be called once, after the    * txn on DataNucleus connection is opened, and before any queries are issued. What it does    * currently is run db-specific logic, e.g. setting ansi quotes mode for MySQL. The reason it    * must be used inside of the txn is connection pooling; there's no way to guarantee that the    * effect will apply to the connection that is executing the queries otherwise.    */
specifier|public
name|void
name|prepareTxn
parameter_list|()
throws|throws
name|MetaException
block|{
if|if
condition|(
name|dbType
operator|!=
name|DatabaseProduct
operator|.
name|MYSQL
condition|)
return|return;
try|try
block|{
assert|assert
name|pm
operator|.
name|currentTransaction
argument_list|()
operator|.
name|isActive
argument_list|()
assert|;
comment|// must be inside tx together with queries
name|executeNoResult
argument_list|(
literal|"SET @@session.sql_mode=ANSI_QUOTES"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|sqlEx
parameter_list|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Error setting ansi quotes: "
operator|+
name|sqlEx
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
specifier|abstract
class|class
name|Batchable
parameter_list|<
name|I
parameter_list|,
name|R
parameter_list|>
block|{
specifier|private
name|List
argument_list|<
name|Query
argument_list|>
name|queries
init|=
literal|null
decl_stmt|;
specifier|public
specifier|abstract
name|List
argument_list|<
name|R
argument_list|>
name|run
parameter_list|(
name|List
argument_list|<
name|I
argument_list|>
name|input
parameter_list|)
throws|throws
name|MetaException
function_decl|;
specifier|public
name|void
name|addQueryAfterUse
parameter_list|(
name|Query
name|query
parameter_list|)
block|{
if|if
condition|(
name|queries
operator|==
literal|null
condition|)
block|{
name|queries
operator|=
operator|new
name|ArrayList
argument_list|<
name|Query
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|queries
operator|.
name|add
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|addQueryAfterUse
parameter_list|(
name|Batchable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|b
parameter_list|)
block|{
if|if
condition|(
name|b
operator|.
name|queries
operator|==
literal|null
condition|)
return|return;
if|if
condition|(
name|queries
operator|==
literal|null
condition|)
block|{
name|queries
operator|=
operator|new
name|ArrayList
argument_list|<
name|Query
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|queries
operator|.
name|addAll
argument_list|(
name|b
operator|.
name|queries
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|closeAllQueries
parameter_list|()
block|{
for|for
control|(
name|Query
name|q
range|:
name|queries
control|)
block|{
try|try
block|{
name|q
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to close a query"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
parameter_list|<
name|I
parameter_list|,
name|R
parameter_list|>
name|List
argument_list|<
name|R
argument_list|>
name|runBatched
parameter_list|(
name|List
argument_list|<
name|I
argument_list|>
name|input
parameter_list|,
name|Batchable
argument_list|<
name|I
argument_list|,
name|R
argument_list|>
name|runnable
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|batchSize
operator|==
name|NO_BATCHING
operator|||
name|batchSize
operator|>=
name|input
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|runnable
operator|.
name|run
argument_list|(
name|input
argument_list|)
return|;
block|}
name|List
argument_list|<
name|R
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|R
argument_list|>
argument_list|(
name|input
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|fromIndex
init|=
literal|0
init|,
name|toIndex
init|=
literal|0
init|;
name|toIndex
operator|<
name|input
operator|.
name|size
argument_list|()
condition|;
name|fromIndex
operator|=
name|toIndex
control|)
block|{
name|toIndex
operator|=
name|Math
operator|.
name|min
argument_list|(
name|fromIndex
operator|+
name|batchSize
argument_list|,
name|input
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|I
argument_list|>
name|batchedInput
init|=
name|input
operator|.
name|subList
argument_list|(
name|fromIndex
argument_list|,
name|toIndex
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|R
argument_list|>
name|batchedOutput
init|=
name|runnable
operator|.
name|run
argument_list|(
name|batchedInput
argument_list|)
decl_stmt|;
if|if
condition|(
name|batchedOutput
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|addAll
argument_list|(
name|batchedOutput
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
specifier|public
name|List
argument_list|<
name|SQLForeignKey
argument_list|>
name|getForeignKeys
parameter_list|(
name|String
name|parent_db_name
parameter_list|,
name|String
name|parent_tbl_name
parameter_list|,
name|String
name|foreign_db_name
parameter_list|,
name|String
name|foreign_tbl_name
parameter_list|)
throws|throws
name|MetaException
block|{
name|List
argument_list|<
name|SQLForeignKey
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<
name|SQLForeignKey
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|queryText
init|=
literal|"SELECT  \"D2\".\"NAME\", \"T2\".\"TBL_NAME\", \"C2\".\"COLUMN_NAME\","
operator|+
literal|"\"DBS\".\"NAME\", \"TBLS\".\"TBL_NAME\", \"COLUMNS_V2\".\"COLUMN_NAME\", "
operator|+
literal|"\"KEY_CONSTRAINTS\".\"POSITION\", \"KEY_CONSTRAINTS\".\"UPDATE_RULE\", \"KEY_CONSTRAINTS\".\"DELETE_RULE\", "
operator|+
literal|"\"KEY_CONSTRAINTS\".\"CONSTRAINT_NAME\" , \"KEY_CONSTRAINTS2\".\"CONSTRAINT_NAME\", \"KEY_CONSTRAINTS\".\"ENABLE_VALIDATE_RELY\" "
operator|+
literal|" FROM \"TBLS\" "
operator|+
literal|" INNER JOIN \"KEY_CONSTRAINTS\" ON \"TBLS\".\"TBL_ID\" = \"KEY_CONSTRAINTS\".\"CHILD_TBL_ID\" "
operator|+
literal|" INNER JOIN \"KEY_CONSTRAINTS\" \"KEY_CONSTRAINTS2\" ON \"KEY_CONSTRAINTS2\".\"PARENT_TBL_ID\"  = \"KEY_CONSTRAINTS\".\"PARENT_TBL_ID\" "
operator|+
literal|" AND \"KEY_CONSTRAINTS2\".\"PARENT_CD_ID\"  = \"KEY_CONSTRAINTS\".\"PARENT_CD_ID\" AND "
operator|+
literal|" \"KEY_CONSTRAINTS2\".\"PARENT_INTEGER_IDX\"  = \"KEY_CONSTRAINTS\".\"PARENT_INTEGER_IDX\" "
operator|+
literal|" INNER JOIN \"DBS\" ON \"TBLS\".\"DB_ID\" = \"DBS\".\"DB_ID\" "
operator|+
literal|" INNER JOIN \"TBLS\" \"T2\" ON  \"KEY_CONSTRAINTS\".\"PARENT_TBL_ID\" = \"T2\".\"TBL_ID\" "
operator|+
literal|" INNER JOIN \"DBS\" \"D2\" ON \"T2\".\"DB_ID\" = \"D2\".\"DB_ID\" "
operator|+
literal|" INNER JOIN \"COLUMNS_V2\"  ON \"COLUMNS_V2\".\"CD_ID\" = \"KEY_CONSTRAINTS\".\"CHILD_CD_ID\" AND "
operator|+
literal|" \"COLUMNS_V2\".\"INTEGER_IDX\" = \"KEY_CONSTRAINTS\".\"CHILD_INTEGER_IDX\" "
operator|+
literal|" INNER JOIN \"COLUMNS_V2\" \"C2\" ON \"C2\".\"CD_ID\" = \"KEY_CONSTRAINTS\".\"PARENT_CD_ID\" AND "
operator|+
literal|" \"C2\".\"INTEGER_IDX\" = \"KEY_CONSTRAINTS\".\"PARENT_INTEGER_IDX\" "
operator|+
literal|" WHERE \"KEY_CONSTRAINTS\".\"CONSTRAINT_TYPE\" = "
operator|+
name|MConstraint
operator|.
name|FOREIGN_KEY_CONSTRAINT
operator|+
literal|" AND \"KEY_CONSTRAINTS2\".\"CONSTRAINT_TYPE\" = "
operator|+
name|MConstraint
operator|.
name|PRIMARY_KEY_CONSTRAINT
operator|+
literal|" AND"
operator|+
operator|(
name|foreign_db_name
operator|==
literal|null
condition|?
literal|""
else|:
literal|" \"DBS\".\"NAME\" = ? AND"
operator|)
operator|+
operator|(
name|foreign_tbl_name
operator|==
literal|null
condition|?
literal|""
else|:
literal|" \"TBLS\".\"TBL_NAME\" = ? AND"
operator|)
operator|+
operator|(
name|parent_tbl_name
operator|==
literal|null
condition|?
literal|""
else|:
literal|" \"T2\".\"TBL_NAME\" = ? AND"
operator|)
operator|+
operator|(
name|parent_db_name
operator|==
literal|null
condition|?
literal|""
else|:
literal|" \"D2\".\"NAME\" = ?"
operator|)
decl_stmt|;
name|queryText
operator|=
name|queryText
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|queryText
operator|.
name|endsWith
argument_list|(
literal|"WHERE"
argument_list|)
condition|)
block|{
name|queryText
operator|=
name|queryText
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|queryText
operator|.
name|length
argument_list|()
operator|-
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|queryText
operator|.
name|endsWith
argument_list|(
literal|"AND"
argument_list|)
condition|)
block|{
name|queryText
operator|=
name|queryText
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|queryText
operator|.
name|length
argument_list|()
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|pms
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|foreign_db_name
operator|!=
literal|null
condition|)
block|{
name|pms
operator|.
name|add
argument_list|(
name|foreign_db_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|foreign_tbl_name
operator|!=
literal|null
condition|)
block|{
name|pms
operator|.
name|add
argument_list|(
name|foreign_tbl_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parent_tbl_name
operator|!=
literal|null
condition|)
block|{
name|pms
operator|.
name|add
argument_list|(
name|parent_tbl_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parent_db_name
operator|!=
literal|null
condition|)
block|{
name|pms
operator|.
name|add
argument_list|(
name|parent_db_name
argument_list|)
expr_stmt|;
block|}
name|Query
name|queryParams
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|sqlResult
init|=
name|ensureList
argument_list|(
name|executeWithArray
argument_list|(
name|queryParams
argument_list|,
name|pms
operator|.
name|toArray
argument_list|()
argument_list|,
name|queryText
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sqlResult
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Object
index|[]
name|line
range|:
name|sqlResult
control|)
block|{
name|int
name|enableValidateRely
init|=
name|extractSqlInt
argument_list|(
name|line
index|[
literal|11
index|]
argument_list|)
decl_stmt|;
name|boolean
name|enable
init|=
operator|(
name|enableValidateRely
operator|&
literal|4
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|validate
init|=
operator|(
name|enableValidateRely
operator|&
literal|2
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|rely
init|=
operator|(
name|enableValidateRely
operator|&
literal|1
operator|)
operator|!=
literal|0
decl_stmt|;
name|SQLForeignKey
name|currKey
init|=
operator|new
name|SQLForeignKey
argument_list|(
name|extractSqlString
argument_list|(
name|line
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|extractSqlString
argument_list|(
name|line
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|extractSqlString
argument_list|(
name|line
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|extractSqlString
argument_list|(
name|line
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|extractSqlString
argument_list|(
name|line
index|[
literal|4
index|]
argument_list|)
argument_list|,
name|extractSqlString
argument_list|(
name|line
index|[
literal|5
index|]
argument_list|)
argument_list|,
name|extractSqlInt
argument_list|(
name|line
index|[
literal|6
index|]
argument_list|)
argument_list|,
name|extractSqlInt
argument_list|(
name|line
index|[
literal|7
index|]
argument_list|)
argument_list|,
name|extractSqlInt
argument_list|(
name|line
index|[
literal|8
index|]
argument_list|)
argument_list|,
name|extractSqlString
argument_list|(
name|line
index|[
literal|9
index|]
argument_list|)
argument_list|,
name|extractSqlString
argument_list|(
name|line
index|[
literal|10
index|]
argument_list|)
argument_list|,
name|enable
argument_list|,
name|validate
argument_list|,
name|rely
argument_list|)
decl_stmt|;
name|ret
operator|.
name|add
argument_list|(
name|currKey
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
specifier|public
name|List
argument_list|<
name|SQLPrimaryKey
argument_list|>
name|getPrimaryKeys
parameter_list|(
name|String
name|db_name
parameter_list|,
name|String
name|tbl_name
parameter_list|)
throws|throws
name|MetaException
block|{
name|List
argument_list|<
name|SQLPrimaryKey
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<
name|SQLPrimaryKey
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|queryText
init|=
literal|"SELECT \"DBS\".\"NAME\", \"TBLS\".\"TBL_NAME\", \"COLUMNS_V2\".\"COLUMN_NAME\","
operator|+
literal|"\"KEY_CONSTRAINTS\".\"POSITION\", "
operator|+
literal|"\"KEY_CONSTRAINTS\".\"CONSTRAINT_NAME\", \"KEY_CONSTRAINTS\".\"ENABLE_VALIDATE_RELY\" "
operator|+
literal|" FROM  \"TBLS\" "
operator|+
literal|" INNER  JOIN \"KEY_CONSTRAINTS\" ON \"TBLS\".\"TBL_ID\" = \"KEY_CONSTRAINTS\".\"PARENT_TBL_ID\" "
operator|+
literal|" INNER JOIN \"DBS\" ON \"TBLS\".\"DB_ID\" = \"DBS\".\"DB_ID\" "
operator|+
literal|" INNER JOIN \"COLUMNS_V2\" ON \"COLUMNS_V2\".\"CD_ID\" = \"KEY_CONSTRAINTS\".\"PARENT_CD_ID\" AND "
operator|+
literal|" \"COLUMNS_V2\".\"INTEGER_IDX\" = \"KEY_CONSTRAINTS\".\"PARENT_INTEGER_IDX\" "
operator|+
literal|" WHERE \"KEY_CONSTRAINTS\".\"CONSTRAINT_TYPE\" = "
operator|+
name|MConstraint
operator|.
name|PRIMARY_KEY_CONSTRAINT
operator|+
literal|" AND "
operator|+
operator|(
name|db_name
operator|==
literal|null
condition|?
literal|""
else|:
literal|"\"DBS\".\"NAME\" = ? AND"
operator|)
operator|+
operator|(
name|tbl_name
operator|==
literal|null
condition|?
literal|""
else|:
literal|" \"TBLS\".\"TBL_NAME\" = ? "
operator|)
decl_stmt|;
name|queryText
operator|=
name|queryText
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|queryText
operator|.
name|endsWith
argument_list|(
literal|"WHERE"
argument_list|)
condition|)
block|{
name|queryText
operator|=
name|queryText
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|queryText
operator|.
name|length
argument_list|()
operator|-
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|queryText
operator|.
name|endsWith
argument_list|(
literal|"AND"
argument_list|)
condition|)
block|{
name|queryText
operator|=
name|queryText
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|queryText
operator|.
name|length
argument_list|()
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|pms
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|db_name
operator|!=
literal|null
condition|)
block|{
name|pms
operator|.
name|add
argument_list|(
name|db_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tbl_name
operator|!=
literal|null
condition|)
block|{
name|pms
operator|.
name|add
argument_list|(
name|tbl_name
argument_list|)
expr_stmt|;
block|}
name|Query
name|queryParams
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|sqlResult
init|=
name|ensureList
argument_list|(
name|executeWithArray
argument_list|(
name|queryParams
argument_list|,
name|pms
operator|.
name|toArray
argument_list|()
argument_list|,
name|queryText
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sqlResult
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Object
index|[]
name|line
range|:
name|sqlResult
control|)
block|{
name|int
name|enableValidateRely
init|=
name|extractSqlInt
argument_list|(
name|line
index|[
literal|5
index|]
argument_list|)
decl_stmt|;
name|boolean
name|enable
init|=
operator|(
name|enableValidateRely
operator|&
literal|4
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|validate
init|=
operator|(
name|enableValidateRely
operator|&
literal|2
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|rely
init|=
operator|(
name|enableValidateRely
operator|&
literal|1
operator|)
operator|!=
literal|0
decl_stmt|;
name|SQLPrimaryKey
name|currKey
init|=
operator|new
name|SQLPrimaryKey
argument_list|(
name|extractSqlString
argument_list|(
name|line
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|extractSqlString
argument_list|(
name|line
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|extractSqlString
argument_list|(
name|line
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|extractSqlInt
argument_list|(
name|line
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|extractSqlString
argument_list|(
name|line
index|[
literal|4
index|]
argument_list|)
argument_list|,
name|enable
argument_list|,
name|validate
argument_list|,
name|rely
argument_list|)
decl_stmt|;
name|ret
operator|.
name|add
argument_list|(
name|currKey
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
block|}
end_class

end_unit

