begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|CompareFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|RowFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|MetaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|hbase
operator|.
name|PartitionKeyComparator
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|parser
operator|.
name|ExpressionTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|parser
operator|.
name|ExpressionTree
operator|.
name|LeafNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|parser
operator|.
name|ExpressionTree
operator|.
name|TreeNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|parser
operator|.
name|ExpressionTree
operator|.
name|TreeVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorConverters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorConverters
operator|.
name|Converter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|PrimitiveObjectInspectorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_comment
comment|/**  * Utility function for generating hbase partition filtering plan representation  * from ExpressionTree.  * Optimizations to be done -  *  - Case where all partition keys are specified. Should use a get  *  * {@link PartitionFilterGenerator} is a visitor on the given filter expression tree. After  * walking it it produces the HBase execution plan represented by {@link FilterPlan}. See  * their javadocs for more details.  */
end_comment

begin_class
class|class
name|HBaseFilterPlanUtil
block|{
comment|/**    * Compare two byte arrays.    *    * @param ar1    *          first byte array    * @param ar2    *          second byte array    * @return -1 if ar1< ar2, 0 if == , 1 if>    */
specifier|static
name|int
name|compare
parameter_list|(
name|byte
index|[]
name|ar1
parameter_list|,
name|byte
index|[]
name|ar2
parameter_list|)
block|{
comment|// null check is not needed, nulls are not passed here
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ar1
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|ar2
operator|.
name|length
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|ar1
index|[
name|i
index|]
operator|==
name|ar2
index|[
name|i
index|]
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ar1
index|[
name|i
index|]
operator|>
name|ar2
index|[
name|i
index|]
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
comment|// ar2 equal until length of ar1.
if|if
condition|(
name|ar1
operator|.
name|length
operator|==
name|ar2
operator|.
name|length
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|// ar2 has more bytes
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * Represents the execution plan for hbase to find the set of partitions that    * match given filter expression.    * If you have an AND or OR of two expressions, you can determine FilterPlan for each    * children and then call lhs.and(rhs) or lhs.or(rhs) respectively    * to generate a new plan for the expression.    *    * The execution plan has one or more ScanPlan objects. To get the results the set union of all    * ScanPlan objects needs to be done.    */
specifier|public
specifier|static
specifier|abstract
class|class
name|FilterPlan
block|{
specifier|abstract
name|FilterPlan
name|and
parameter_list|(
name|FilterPlan
name|other
parameter_list|)
function_decl|;
specifier|abstract
name|FilterPlan
name|or
parameter_list|(
name|FilterPlan
name|other
parameter_list|)
function_decl|;
specifier|abstract
name|List
argument_list|<
name|ScanPlan
argument_list|>
name|getPlans
parameter_list|()
function_decl|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getPlans
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Represents a union/OR of single scan plans (ScanPlan).    */
specifier|public
specifier|static
class|class
name|MultiScanPlan
extends|extends
name|FilterPlan
block|{
specifier|final
name|ImmutableList
argument_list|<
name|ScanPlan
argument_list|>
name|scanPlans
decl_stmt|;
specifier|public
name|MultiScanPlan
parameter_list|(
name|List
argument_list|<
name|ScanPlan
argument_list|>
name|scanPlans
parameter_list|)
block|{
name|this
operator|.
name|scanPlans
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|scanPlans
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|FilterPlan
name|and
parameter_list|(
name|FilterPlan
name|other
parameter_list|)
block|{
comment|// Convert to disjunctive normal form (DNF), ie OR of ANDs
comment|// First get a new set of FilterPlans by doing an AND
comment|// on each ScanPlan in this one with the other FilterPlan
name|List
argument_list|<
name|FilterPlan
argument_list|>
name|newFPlans
init|=
operator|new
name|ArrayList
argument_list|<
name|FilterPlan
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ScanPlan
name|splan
range|:
name|getPlans
argument_list|()
control|)
block|{
name|newFPlans
operator|.
name|add
argument_list|(
name|splan
operator|.
name|and
argument_list|(
name|other
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//now combine scanPlans in multiple new FilterPlans into one
comment|// MultiScanPlan
name|List
argument_list|<
name|ScanPlan
argument_list|>
name|newScanPlans
init|=
operator|new
name|ArrayList
argument_list|<
name|ScanPlan
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|FilterPlan
name|fp
range|:
name|newFPlans
control|)
block|{
name|newScanPlans
operator|.
name|addAll
argument_list|(
name|fp
operator|.
name|getPlans
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|MultiScanPlan
argument_list|(
name|newScanPlans
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|FilterPlan
name|or
parameter_list|(
name|FilterPlan
name|other
parameter_list|)
block|{
comment|// just combine the ScanPlans
name|List
argument_list|<
name|ScanPlan
argument_list|>
name|newScanPlans
init|=
operator|new
name|ArrayList
argument_list|<
name|ScanPlan
argument_list|>
argument_list|(
name|this
operator|.
name|getPlans
argument_list|()
argument_list|)
decl_stmt|;
name|newScanPlans
operator|.
name|addAll
argument_list|(
name|other
operator|.
name|getPlans
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|MultiScanPlan
argument_list|(
name|newScanPlans
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|ScanPlan
argument_list|>
name|getPlans
parameter_list|()
block|{
return|return
name|scanPlans
return|;
block|}
block|}
comment|/**    * Represents a single Hbase Scan api call    */
specifier|public
specifier|static
class|class
name|ScanPlan
extends|extends
name|FilterPlan
block|{
specifier|public
specifier|static
class|class
name|ScanMarker
block|{
specifier|final
name|String
name|value
decl_stmt|;
comment|/**        * If inclusive = true, it means that the        * marker includes those bytes.        * If it is false, it means the marker starts at the next possible byte array        * or ends at the next possible byte array        */
specifier|final
name|boolean
name|isInclusive
decl_stmt|;
specifier|final
name|String
name|type
decl_stmt|;
name|ScanMarker
parameter_list|(
name|String
name|obj
parameter_list|,
name|boolean
name|i
parameter_list|,
name|String
name|type
parameter_list|)
block|{
name|this
operator|.
name|value
operator|=
name|obj
expr_stmt|;
name|this
operator|.
name|isInclusive
operator|=
name|i
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ScanMarker ["
operator|+
literal|"value="
operator|+
name|value
operator|.
name|toString
argument_list|()
operator|+
literal|", isInclusive="
operator|+
name|isInclusive
operator|+
literal|", type="
operator|+
name|type
operator|+
literal|"]"
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
specifier|final
name|int
name|prime
init|=
literal|31
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
name|result
operator|=
name|prime
operator|*
name|result
operator|+
name|value
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|result
operator|=
name|prime
operator|*
name|result
operator|+
operator|(
name|isInclusive
condition|?
literal|1231
else|:
literal|1237
operator|)
expr_stmt|;
name|result
operator|=
name|prime
operator|*
name|result
operator|+
name|type
operator|.
name|hashCode
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|getClass
argument_list|()
operator|!=
name|obj
operator|.
name|getClass
argument_list|()
condition|)
return|return
literal|false
return|;
name|ScanMarker
name|other
init|=
operator|(
name|ScanMarker
operator|)
name|obj
decl_stmt|;
if|if
condition|(
operator|!
name|value
operator|.
name|equals
argument_list|(
name|other
operator|.
name|value
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|isInclusive
operator|!=
name|other
operator|.
name|isInclusive
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|type
operator|!=
name|other
operator|.
name|type
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|ScanMarkerPair
block|{
specifier|public
name|ScanMarkerPair
parameter_list|(
name|ScanMarker
name|startMarker
parameter_list|,
name|ScanMarker
name|endMarker
parameter_list|)
block|{
name|this
operator|.
name|startMarker
operator|=
name|startMarker
expr_stmt|;
name|this
operator|.
name|endMarker
operator|=
name|endMarker
expr_stmt|;
block|}
name|ScanMarker
name|startMarker
decl_stmt|;
name|ScanMarker
name|endMarker
decl_stmt|;
block|}
comment|// represent Scan start, partition key name -> scanMarkerPair
name|Map
argument_list|<
name|String
argument_list|,
name|ScanMarkerPair
argument_list|>
name|markers
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ScanMarkerPair
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|>
name|ops
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|>
argument_list|()
decl_stmt|;
comment|// Get the number of partition key prefixes which can be used in the scan range.
comment|// For example, if partition key is (year, month, state)
comment|// 1. year = 2015 and month>= 1 and month< 5
comment|//    year + month can be used in scan range, majorParts = 2
comment|// 2. year = 2015 and state = 'CA'
comment|//    only year can be used in scan range, majorParts = 1
comment|// 3. month = 10 and state = 'CA'
comment|//    nothing can be used in scan range, majorParts = 0
specifier|private
name|int
name|getMajorPartsCount
parameter_list|(
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|parts
parameter_list|)
block|{
name|int
name|majorPartsCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|majorPartsCount
operator|<
name|parts
operator|.
name|size
argument_list|()
operator|&&
name|markers
operator|.
name|containsKey
argument_list|(
name|parts
operator|.
name|get
argument_list|(
name|majorPartsCount
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|ScanMarkerPair
name|pair
init|=
name|markers
operator|.
name|get
argument_list|(
name|parts
operator|.
name|get
argument_list|(
name|majorPartsCount
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|majorPartsCount
operator|++
expr_stmt|;
if|if
condition|(
name|pair
operator|.
name|startMarker
operator|!=
literal|null
operator|&&
name|pair
operator|.
name|endMarker
operator|!=
literal|null
operator|&&
name|pair
operator|.
name|startMarker
operator|.
name|value
operator|.
name|equals
argument_list|(
name|pair
operator|.
name|endMarker
operator|.
name|value
argument_list|)
operator|&&
name|pair
operator|.
name|startMarker
operator|.
name|isInclusive
operator|&&
name|pair
operator|.
name|endMarker
operator|.
name|isInclusive
condition|)
block|{
comment|// is equal
continue|continue;
block|}
else|else
block|{
break|break;
block|}
block|}
return|return
name|majorPartsCount
return|;
block|}
specifier|public
name|Filter
name|getFilter
parameter_list|(
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|parts
parameter_list|)
block|{
name|int
name|majorPartsCount
init|=
name|getMajorPartsCount
argument_list|(
name|parts
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|majorKeys
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|majorPartsCount
condition|;
name|i
operator|++
control|)
block|{
name|majorKeys
operator|.
name|add
argument_list|(
name|parts
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|HBaseUtils
operator|.
name|getPartitionNames
argument_list|(
name|parts
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|PartitionKeyComparator
operator|.
name|Range
argument_list|>
name|ranges
init|=
operator|new
name|ArrayList
argument_list|<
name|PartitionKeyComparator
operator|.
name|Range
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ScanMarkerPair
argument_list|>
name|entry
range|:
name|markers
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|names
operator|.
name|contains
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|&&
operator|!
name|majorKeys
operator|.
name|contains
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|PartitionKeyComparator
operator|.
name|Mark
name|startMark
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|startMarker
operator|!=
literal|null
condition|)
block|{
name|startMark
operator|=
operator|new
name|PartitionKeyComparator
operator|.
name|Mark
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|startMarker
operator|.
name|value
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|startMarker
operator|.
name|isInclusive
argument_list|)
expr_stmt|;
block|}
name|PartitionKeyComparator
operator|.
name|Mark
name|endMark
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|endMarker
operator|!=
literal|null
condition|)
block|{
name|startMark
operator|=
operator|new
name|PartitionKeyComparator
operator|.
name|Mark
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|endMarker
operator|.
name|value
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|endMarker
operator|.
name|isInclusive
argument_list|)
expr_stmt|;
block|}
name|PartitionKeyComparator
operator|.
name|Range
name|range
init|=
operator|new
name|PartitionKeyComparator
operator|.
name|Range
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|startMark
argument_list|,
name|endMark
argument_list|)
decl_stmt|;
name|ranges
operator|.
name|add
argument_list|(
name|range
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ranges
operator|.
name|isEmpty
argument_list|()
operator|&&
name|ops
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
operator|new
name|RowFilter
argument_list|(
name|CompareFilter
operator|.
name|CompareOp
operator|.
name|EQUAL
argument_list|,
operator|new
name|PartitionKeyComparator
argument_list|(
name|StringUtils
operator|.
name|join
argument_list|(
name|names
argument_list|,
literal|","
argument_list|)
argument_list|,
name|StringUtils
operator|.
name|join
argument_list|(
name|HBaseUtils
operator|.
name|getPartitionKeyTypes
argument_list|(
name|parts
argument_list|)
argument_list|,
literal|","
argument_list|)
argument_list|,
name|ranges
argument_list|,
name|ops
argument_list|)
argument_list|)
return|;
block|}
block|}
specifier|public
name|void
name|setStartMarker
parameter_list|(
name|String
name|keyName
parameter_list|,
name|String
name|keyType
parameter_list|,
name|String
name|start
parameter_list|,
name|boolean
name|isInclusive
parameter_list|)
block|{
if|if
condition|(
name|markers
operator|.
name|containsKey
argument_list|(
name|keyName
argument_list|)
condition|)
block|{
name|markers
operator|.
name|get
argument_list|(
name|keyName
argument_list|)
operator|.
name|startMarker
operator|=
operator|new
name|ScanMarker
argument_list|(
name|start
argument_list|,
name|isInclusive
argument_list|,
name|keyType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ScanMarkerPair
name|marker
init|=
operator|new
name|ScanMarkerPair
argument_list|(
operator|new
name|ScanMarker
argument_list|(
name|start
argument_list|,
name|isInclusive
argument_list|,
name|keyType
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|markers
operator|.
name|put
argument_list|(
name|keyName
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|ScanMarker
name|getStartMarker
parameter_list|(
name|String
name|keyName
parameter_list|)
block|{
if|if
condition|(
name|markers
operator|.
name|containsKey
argument_list|(
name|keyName
argument_list|)
condition|)
block|{
return|return
name|markers
operator|.
name|get
argument_list|(
name|keyName
argument_list|)
operator|.
name|startMarker
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|void
name|setEndMarker
parameter_list|(
name|String
name|keyName
parameter_list|,
name|String
name|keyType
parameter_list|,
name|String
name|end
parameter_list|,
name|boolean
name|isInclusive
parameter_list|)
block|{
if|if
condition|(
name|markers
operator|.
name|containsKey
argument_list|(
name|keyName
argument_list|)
condition|)
block|{
name|markers
operator|.
name|get
argument_list|(
name|keyName
argument_list|)
operator|.
name|endMarker
operator|=
operator|new
name|ScanMarker
argument_list|(
name|end
argument_list|,
name|isInclusive
argument_list|,
name|keyType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ScanMarkerPair
name|marker
init|=
operator|new
name|ScanMarkerPair
argument_list|(
literal|null
argument_list|,
operator|new
name|ScanMarker
argument_list|(
name|end
argument_list|,
name|isInclusive
argument_list|,
name|keyType
argument_list|)
argument_list|)
decl_stmt|;
name|markers
operator|.
name|put
argument_list|(
name|keyName
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|ScanMarker
name|getEndMarker
parameter_list|(
name|String
name|keyName
parameter_list|)
block|{
if|if
condition|(
name|markers
operator|.
name|containsKey
argument_list|(
name|keyName
argument_list|)
condition|)
block|{
return|return
name|markers
operator|.
name|get
argument_list|(
name|keyName
argument_list|)
operator|.
name|endMarker
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|FilterPlan
name|and
parameter_list|(
name|FilterPlan
name|other
parameter_list|)
block|{
name|List
argument_list|<
name|ScanPlan
argument_list|>
name|newSPlans
init|=
operator|new
name|ArrayList
argument_list|<
name|ScanPlan
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ScanPlan
name|otherSPlan
range|:
name|other
operator|.
name|getPlans
argument_list|()
control|)
block|{
name|newSPlans
operator|.
name|add
argument_list|(
name|this
operator|.
name|and
argument_list|(
name|otherSPlan
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|MultiScanPlan
argument_list|(
name|newSPlans
argument_list|)
return|;
block|}
specifier|private
name|ScanPlan
name|and
parameter_list|(
name|ScanPlan
name|other
parameter_list|)
block|{
comment|// create combined FilterPlan based on existing lhs and rhs plan
name|ScanPlan
name|newPlan
init|=
operator|new
name|ScanPlan
argument_list|()
decl_stmt|;
name|newPlan
operator|.
name|markers
operator|.
name|putAll
argument_list|(
name|markers
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|keyName
range|:
name|other
operator|.
name|markers
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|newPlan
operator|.
name|markers
operator|.
name|containsKey
argument_list|(
name|keyName
argument_list|)
condition|)
block|{
comment|// create new scan start
name|ScanMarker
name|greaterStartMarker
init|=
name|getComparedMarker
argument_list|(
name|this
operator|.
name|getStartMarker
argument_list|(
name|keyName
argument_list|)
argument_list|,
name|other
operator|.
name|getStartMarker
argument_list|(
name|keyName
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|greaterStartMarker
operator|!=
literal|null
condition|)
block|{
name|newPlan
operator|.
name|setStartMarker
argument_list|(
name|keyName
argument_list|,
name|greaterStartMarker
operator|.
name|type
argument_list|,
name|greaterStartMarker
operator|.
name|value
argument_list|,
name|greaterStartMarker
operator|.
name|isInclusive
argument_list|)
expr_stmt|;
block|}
comment|// create new scan end
name|ScanMarker
name|lesserEndMarker
init|=
name|getComparedMarker
argument_list|(
name|this
operator|.
name|getEndMarker
argument_list|(
name|keyName
argument_list|)
argument_list|,
name|other
operator|.
name|getEndMarker
argument_list|(
name|keyName
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|lesserEndMarker
operator|!=
literal|null
condition|)
block|{
name|newPlan
operator|.
name|setEndMarker
argument_list|(
name|keyName
argument_list|,
name|lesserEndMarker
operator|.
name|type
argument_list|,
name|lesserEndMarker
operator|.
name|value
argument_list|,
name|lesserEndMarker
operator|.
name|isInclusive
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|newPlan
operator|.
name|markers
operator|.
name|put
argument_list|(
name|keyName
argument_list|,
name|other
operator|.
name|markers
operator|.
name|get
argument_list|(
name|keyName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|newPlan
operator|.
name|ops
operator|.
name|addAll
argument_list|(
name|ops
argument_list|)
expr_stmt|;
name|newPlan
operator|.
name|ops
operator|.
name|addAll
argument_list|(
name|other
operator|.
name|ops
argument_list|)
expr_stmt|;
return|return
name|newPlan
return|;
block|}
comment|/**      * @param lStartMarker      * @param rStartMarker      * @param getGreater if true return greater startmarker, else return smaller one      * @return greater/lesser marker depending on value of getGreater      */
annotation|@
name|VisibleForTesting
specifier|static
name|ScanMarker
name|getComparedMarker
parameter_list|(
name|ScanMarker
name|lStartMarker
parameter_list|,
name|ScanMarker
name|rStartMarker
parameter_list|,
name|boolean
name|getGreater
parameter_list|)
block|{
comment|// if one of them has null bytes, just return other
if|if
condition|(
name|lStartMarker
operator|==
literal|null
condition|)
block|{
return|return
name|rStartMarker
return|;
block|}
elseif|else
if|if
condition|(
name|rStartMarker
operator|==
literal|null
condition|)
block|{
return|return
name|lStartMarker
return|;
block|}
name|TypeInfo
name|expectedType
init|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|lStartMarker
operator|.
name|type
argument_list|)
decl_stmt|;
name|ObjectInspector
name|outputOI
init|=
name|TypeInfoUtils
operator|.
name|getStandardWritableObjectInspectorFromTypeInfo
argument_list|(
name|expectedType
argument_list|)
decl_stmt|;
name|Converter
name|lConverter
init|=
name|ObjectInspectorConverters
operator|.
name|getConverter
argument_list|(
name|PrimitiveObjectInspectorFactory
operator|.
name|javaStringObjectInspector
argument_list|,
name|outputOI
argument_list|)
decl_stmt|;
name|Converter
name|rConverter
init|=
name|ObjectInspectorConverters
operator|.
name|getConverter
argument_list|(
name|PrimitiveObjectInspectorFactory
operator|.
name|javaStringObjectInspector
argument_list|,
name|outputOI
argument_list|)
decl_stmt|;
name|Comparable
name|lValue
init|=
operator|(
name|Comparable
operator|)
name|lConverter
operator|.
name|convert
argument_list|(
name|lStartMarker
operator|.
name|value
argument_list|)
decl_stmt|;
name|Comparable
name|rValue
init|=
operator|(
name|Comparable
operator|)
name|rConverter
operator|.
name|convert
argument_list|(
name|rStartMarker
operator|.
name|value
argument_list|)
decl_stmt|;
name|int
name|compareRes
init|=
name|lValue
operator|.
name|compareTo
argument_list|(
name|rValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|compareRes
operator|==
literal|0
condition|)
block|{
comment|// bytes are equal, now compare the isInclusive flags
if|if
condition|(
name|lStartMarker
operator|.
name|isInclusive
operator|==
name|rStartMarker
operator|.
name|isInclusive
condition|)
block|{
comment|// actually equal, so return any one
return|return
name|lStartMarker
return|;
block|}
name|boolean
name|isInclusive
init|=
literal|true
decl_stmt|;
comment|// one that does not include the current bytes is greater
if|if
condition|(
name|getGreater
condition|)
block|{
name|isInclusive
operator|=
literal|false
expr_stmt|;
block|}
comment|// else
return|return
operator|new
name|ScanMarker
argument_list|(
name|lStartMarker
operator|.
name|value
argument_list|,
name|isInclusive
argument_list|,
name|lStartMarker
operator|.
name|type
argument_list|)
return|;
block|}
if|if
condition|(
name|getGreater
condition|)
block|{
return|return
name|compareRes
operator|==
literal|1
condition|?
name|lStartMarker
else|:
name|rStartMarker
return|;
block|}
comment|// else
return|return
name|compareRes
operator|==
operator|-
literal|1
condition|?
name|lStartMarker
else|:
name|rStartMarker
return|;
block|}
annotation|@
name|Override
specifier|public
name|FilterPlan
name|or
parameter_list|(
name|FilterPlan
name|other
parameter_list|)
block|{
name|List
argument_list|<
name|ScanPlan
argument_list|>
name|plans
init|=
operator|new
name|ArrayList
argument_list|<
name|ScanPlan
argument_list|>
argument_list|(
name|getPlans
argument_list|()
argument_list|)
decl_stmt|;
name|plans
operator|.
name|addAll
argument_list|(
name|other
operator|.
name|getPlans
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|MultiScanPlan
argument_list|(
name|plans
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|ScanPlan
argument_list|>
name|getPlans
parameter_list|()
block|{
return|return
name|Arrays
operator|.
name|asList
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**      * @return row suffix - This is appended to db + table, to generate start row for the Scan      */
specifier|public
name|byte
index|[]
name|getStartRowSuffix
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|parts
parameter_list|)
block|{
name|int
name|majorPartsCount
init|=
name|getMajorPartsCount
argument_list|(
name|parts
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|majorPartTypes
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|components
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|endPrefix
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|majorPartsCount
condition|;
name|i
operator|++
control|)
block|{
name|majorPartTypes
operator|.
name|add
argument_list|(
name|parts
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|ScanMarker
name|marker
init|=
name|markers
operator|.
name|get
argument_list|(
name|parts
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|startMarker
decl_stmt|;
if|if
condition|(
name|marker
operator|!=
literal|null
condition|)
block|{
name|components
operator|.
name|add
argument_list|(
name|marker
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|majorPartsCount
operator|-
literal|1
condition|)
block|{
name|endPrefix
operator|=
operator|!
name|marker
operator|.
name|isInclusive
expr_stmt|;
block|}
block|}
else|else
block|{
name|components
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|majorPartsCount
operator|-
literal|1
condition|)
block|{
name|endPrefix
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
name|byte
index|[]
name|bytes
init|=
name|HBaseUtils
operator|.
name|buildPartitionKey
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|majorPartTypes
argument_list|,
name|components
argument_list|,
name|endPrefix
argument_list|)
decl_stmt|;
return|return
name|bytes
return|;
block|}
comment|/**      * @return row suffix - This is appended to db + table, to generate end row for the Scan      */
specifier|public
name|byte
index|[]
name|getEndRowSuffix
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|parts
parameter_list|)
block|{
name|int
name|majorPartsCount
init|=
name|getMajorPartsCount
argument_list|(
name|parts
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|majorPartTypes
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|components
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|endPrefix
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|majorPartsCount
condition|;
name|i
operator|++
control|)
block|{
name|majorPartTypes
operator|.
name|add
argument_list|(
name|parts
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|ScanMarker
name|marker
init|=
name|markers
operator|.
name|get
argument_list|(
name|parts
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|endMarker
decl_stmt|;
if|if
condition|(
name|marker
operator|!=
literal|null
condition|)
block|{
name|components
operator|.
name|add
argument_list|(
name|marker
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|majorPartsCount
operator|-
literal|1
condition|)
block|{
name|endPrefix
operator|=
name|marker
operator|.
name|isInclusive
expr_stmt|;
block|}
block|}
else|else
block|{
name|components
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|majorPartsCount
operator|-
literal|1
condition|)
block|{
name|endPrefix
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
name|byte
index|[]
name|bytes
init|=
name|HBaseUtils
operator|.
name|buildPartitionKey
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|majorPartTypes
argument_list|,
name|components
argument_list|,
name|endPrefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|components
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|bytes
index|[
name|bytes
operator|.
name|length
operator|-
literal|1
index|]
operator|++
expr_stmt|;
block|}
return|return
name|bytes
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"ScanPlan:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ScanMarkerPair
argument_list|>
name|entry
range|:
name|markers
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"key="
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|+
literal|"[startMarker="
operator|+
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|startMarker
operator|+
literal|", endMarker="
operator|+
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|endMarker
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Visitor for ExpressionTree.    * It first generates the ScanPlan for the leaf nodes. The higher level nodes are    * either AND or OR operations. It then calls FilterPlan.and and FilterPlan.or with    * the child nodes to generate the plans for higher level nodes.    */
annotation|@
name|VisibleForTesting
specifier|static
class|class
name|PartitionFilterGenerator
extends|extends
name|TreeVisitor
block|{
specifier|private
name|FilterPlan
name|curPlan
decl_stmt|;
comment|// this tells us if there is a condition that did not get included in the plan
comment|// such condition would be treated as getting evaluated to TRUE
specifier|private
name|boolean
name|hasUnsupportedCondition
init|=
literal|false
decl_stmt|;
comment|//Need to cache the left plans for the TreeNode. Use IdentityHashMap here
comment|// as we don't want to dedupe on two TreeNode that are otherwise considered equal
name|Map
argument_list|<
name|TreeNode
argument_list|,
name|FilterPlan
argument_list|>
name|leftPlans
init|=
operator|new
name|IdentityHashMap
argument_list|<
name|TreeNode
argument_list|,
name|FilterPlan
argument_list|>
argument_list|()
decl_stmt|;
comment|// temporary params for current left and right side plans, for AND, OR
specifier|private
name|FilterPlan
name|rPlan
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|nameToType
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|PartitionFilterGenerator
parameter_list|(
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|parts
parameter_list|)
block|{
for|for
control|(
name|FieldSchema
name|part
range|:
name|parts
control|)
block|{
name|nameToType
operator|.
name|put
argument_list|(
name|part
operator|.
name|getName
argument_list|()
argument_list|,
name|part
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|FilterPlan
name|getPlan
parameter_list|()
block|{
return|return
name|curPlan
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|beginTreeNode
parameter_list|(
name|TreeNode
name|node
parameter_list|)
throws|throws
name|MetaException
block|{
comment|// reset the params
name|curPlan
operator|=
name|rPlan
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|midTreeNode
parameter_list|(
name|TreeNode
name|node
parameter_list|)
throws|throws
name|MetaException
block|{
name|leftPlans
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|curPlan
argument_list|)
expr_stmt|;
name|curPlan
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|endTreeNode
parameter_list|(
name|TreeNode
name|node
parameter_list|)
throws|throws
name|MetaException
block|{
name|rPlan
operator|=
name|curPlan
expr_stmt|;
name|FilterPlan
name|lPlan
init|=
name|leftPlans
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|leftPlans
operator|.
name|remove
argument_list|(
name|node
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getAndOr
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
name|curPlan
operator|=
name|lPlan
operator|.
name|and
argument_list|(
name|rPlan
argument_list|)
expr_stmt|;
break|break;
case|case
name|OR
case|:
name|curPlan
operator|=
name|lPlan
operator|.
name|or
argument_list|(
name|rPlan
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unexpected logical operation "
operator|+
name|node
operator|.
name|getAndOr
argument_list|()
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LeafNode
name|node
parameter_list|)
throws|throws
name|MetaException
block|{
name|ScanPlan
name|leafPlan
init|=
operator|new
name|ScanPlan
argument_list|()
decl_stmt|;
name|curPlan
operator|=
name|leafPlan
expr_stmt|;
comment|// this is a condition on first partition column, so might influence the
comment|// start and end of the scan
specifier|final
name|boolean
name|INCLUSIVE
init|=
literal|true
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|operator
condition|)
block|{
case|case
name|EQUALS
case|:
name|leafPlan
operator|.
name|setStartMarker
argument_list|(
name|node
operator|.
name|keyName
argument_list|,
name|nameToType
operator|.
name|get
argument_list|(
name|node
operator|.
name|keyName
argument_list|)
argument_list|,
name|node
operator|.
name|value
operator|.
name|toString
argument_list|()
argument_list|,
name|INCLUSIVE
argument_list|)
expr_stmt|;
name|leafPlan
operator|.
name|setEndMarker
argument_list|(
name|node
operator|.
name|keyName
argument_list|,
name|nameToType
operator|.
name|get
argument_list|(
name|node
operator|.
name|keyName
argument_list|)
argument_list|,
name|node
operator|.
name|value
operator|.
name|toString
argument_list|()
argument_list|,
name|INCLUSIVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREATERTHAN
case|:
name|leafPlan
operator|.
name|setStartMarker
argument_list|(
name|node
operator|.
name|keyName
argument_list|,
name|nameToType
operator|.
name|get
argument_list|(
name|node
operator|.
name|keyName
argument_list|)
argument_list|,
name|node
operator|.
name|value
operator|.
name|toString
argument_list|()
argument_list|,
operator|!
name|INCLUSIVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREATERTHANOREQUALTO
case|:
name|leafPlan
operator|.
name|setStartMarker
argument_list|(
name|node
operator|.
name|keyName
argument_list|,
name|nameToType
operator|.
name|get
argument_list|(
name|node
operator|.
name|keyName
argument_list|)
argument_list|,
name|node
operator|.
name|value
operator|.
name|toString
argument_list|()
argument_list|,
name|INCLUSIVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|LESSTHAN
case|:
name|leafPlan
operator|.
name|setEndMarker
argument_list|(
name|node
operator|.
name|keyName
argument_list|,
name|nameToType
operator|.
name|get
argument_list|(
name|node
operator|.
name|keyName
argument_list|)
argument_list|,
name|node
operator|.
name|value
operator|.
name|toString
argument_list|()
argument_list|,
operator|!
name|INCLUSIVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|LESSTHANOREQUALTO
case|:
name|leafPlan
operator|.
name|setEndMarker
argument_list|(
name|node
operator|.
name|keyName
argument_list|,
name|nameToType
operator|.
name|get
argument_list|(
name|node
operator|.
name|keyName
argument_list|)
argument_list|,
name|node
operator|.
name|value
operator|.
name|toString
argument_list|()
argument_list|,
name|INCLUSIVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIKE
case|:
name|leafPlan
operator|.
name|ops
operator|.
name|add
argument_list|(
operator|new
name|Operator
argument_list|(
name|Operator
operator|.
name|Type
operator|.
name|LIKE
argument_list|,
name|node
operator|.
name|keyName
argument_list|,
name|node
operator|.
name|value
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTEQUALS
case|:
case|case
name|NOTEQUALS2
case|:
name|leafPlan
operator|.
name|ops
operator|.
name|add
argument_list|(
operator|new
name|Operator
argument_list|(
name|Operator
operator|.
name|Type
operator|.
name|NOTEQUALS
argument_list|,
name|node
operator|.
name|keyName
argument_list|,
name|node
operator|.
name|value
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
specifier|private
name|boolean
name|hasUnsupportedCondition
parameter_list|()
block|{
return|return
name|hasUnsupportedCondition
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|PlanResult
block|{
specifier|public
specifier|final
name|FilterPlan
name|plan
decl_stmt|;
specifier|public
specifier|final
name|boolean
name|hasUnsupportedCondition
decl_stmt|;
name|PlanResult
parameter_list|(
name|FilterPlan
name|plan
parameter_list|,
name|boolean
name|hasUnsupportedCondition
parameter_list|)
block|{
name|this
operator|.
name|plan
operator|=
name|plan
expr_stmt|;
name|this
operator|.
name|hasUnsupportedCondition
operator|=
name|hasUnsupportedCondition
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|PlanResult
name|getFilterPlan
parameter_list|(
name|ExpressionTree
name|exprTree
parameter_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|parts
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|exprTree
operator|==
literal|null
condition|)
block|{
comment|// TODO: if exprTree is null, we should do what ObjectStore does. See HIVE-10102
return|return
operator|new
name|PlanResult
argument_list|(
operator|new
name|ScanPlan
argument_list|()
argument_list|,
literal|true
argument_list|)
return|;
block|}
name|PartitionFilterGenerator
name|pGenerator
init|=
operator|new
name|PartitionFilterGenerator
argument_list|(
name|parts
argument_list|)
decl_stmt|;
name|exprTree
operator|.
name|accept
argument_list|(
name|pGenerator
argument_list|)
expr_stmt|;
return|return
operator|new
name|PlanResult
argument_list|(
name|pGenerator
operator|.
name|getPlan
argument_list|()
argument_list|,
name|pGenerator
operator|.
name|hasUnsupportedCondition
argument_list|()
argument_list|)
return|;
block|}
block|}
end_class

end_unit

