begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|MetaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|parser
operator|.
name|ExpressionTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|parser
operator|.
name|ExpressionTree
operator|.
name|LeafNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|parser
operator|.
name|ExpressionTree
operator|.
name|TreeNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|parser
operator|.
name|ExpressionTree
operator|.
name|TreeVisitor
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_comment
comment|/**  * Utility function for generating hbase partition filtering plan representation  * from ExpressionTree.  * Optimizations to be done -  *  - Case where all partition keys are specified. Should use a get  *  * {@link PartitionFilterGenerator} is a visitor on the given filter expression tree. After  * walking it it produces the HBase execution plan represented by {@link FilterPlan}. See  * their javadocs for more details.  */
end_comment

begin_class
class|class
name|HBaseFilterPlanUtil
block|{
comment|/**    * Compare two byte arrays.    *    * @param ar1    *          first byte array    * @param ar2    *          second byte array    * @return -1 if ar1< ar2, 0 if == , 1 if>    */
specifier|static
name|int
name|compare
parameter_list|(
name|byte
index|[]
name|ar1
parameter_list|,
name|byte
index|[]
name|ar2
parameter_list|)
block|{
comment|// null check is not needed, nulls are not passed here
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ar1
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|ar2
operator|.
name|length
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|ar1
index|[
name|i
index|]
operator|==
name|ar2
index|[
name|i
index|]
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ar1
index|[
name|i
index|]
operator|>
name|ar2
index|[
name|i
index|]
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
comment|// ar2 equal until length of ar1.
if|if
condition|(
name|ar1
operator|.
name|length
operator|==
name|ar2
operator|.
name|length
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|// ar2 has more bytes
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * Represents the execution plan for hbase to find the set of partitions that    * match given filter expression.    * If you have an AND or OR of two expressions, you can determine FilterPlan for each    * children and then call lhs.and(rhs) or lhs.or(rhs) respectively    * to generate a new plan for the expression.    *    * The execution plan has one or more ScanPlan objects. To get the results the set union of all    * ScanPlan objects needs to be done.    */
specifier|public
specifier|static
specifier|abstract
class|class
name|FilterPlan
block|{
specifier|abstract
name|FilterPlan
name|and
parameter_list|(
name|FilterPlan
name|other
parameter_list|)
function_decl|;
specifier|abstract
name|FilterPlan
name|or
parameter_list|(
name|FilterPlan
name|other
parameter_list|)
function_decl|;
specifier|abstract
name|List
argument_list|<
name|ScanPlan
argument_list|>
name|getPlans
parameter_list|()
function_decl|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getPlans
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Represents a union/OR of single scan plans (ScanPlan).    */
specifier|public
specifier|static
class|class
name|MultiScanPlan
extends|extends
name|FilterPlan
block|{
specifier|final
name|ImmutableList
argument_list|<
name|ScanPlan
argument_list|>
name|scanPlans
decl_stmt|;
specifier|public
name|MultiScanPlan
parameter_list|(
name|List
argument_list|<
name|ScanPlan
argument_list|>
name|scanPlans
parameter_list|)
block|{
name|this
operator|.
name|scanPlans
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|scanPlans
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|FilterPlan
name|and
parameter_list|(
name|FilterPlan
name|other
parameter_list|)
block|{
comment|// Convert to disjunctive normal form (DNF), ie OR of ANDs
comment|// First get a new set of FilterPlans by doing an AND
comment|// on each ScanPlan in this one with the other FilterPlan
name|List
argument_list|<
name|FilterPlan
argument_list|>
name|newFPlans
init|=
operator|new
name|ArrayList
argument_list|<
name|FilterPlan
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ScanPlan
name|splan
range|:
name|getPlans
argument_list|()
control|)
block|{
name|newFPlans
operator|.
name|add
argument_list|(
name|splan
operator|.
name|and
argument_list|(
name|other
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//now combine scanPlans in multiple new FilterPlans into one
comment|// MultiScanPlan
name|List
argument_list|<
name|ScanPlan
argument_list|>
name|newScanPlans
init|=
operator|new
name|ArrayList
argument_list|<
name|ScanPlan
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|FilterPlan
name|fp
range|:
name|newFPlans
control|)
block|{
name|newScanPlans
operator|.
name|addAll
argument_list|(
name|fp
operator|.
name|getPlans
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|MultiScanPlan
argument_list|(
name|newScanPlans
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|FilterPlan
name|or
parameter_list|(
name|FilterPlan
name|other
parameter_list|)
block|{
comment|// just combine the ScanPlans
name|List
argument_list|<
name|ScanPlan
argument_list|>
name|newScanPlans
init|=
operator|new
name|ArrayList
argument_list|<
name|ScanPlan
argument_list|>
argument_list|(
name|this
operator|.
name|getPlans
argument_list|()
argument_list|)
decl_stmt|;
name|newScanPlans
operator|.
name|addAll
argument_list|(
name|other
operator|.
name|getPlans
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|MultiScanPlan
argument_list|(
name|newScanPlans
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|ScanPlan
argument_list|>
name|getPlans
parameter_list|()
block|{
return|return
name|scanPlans
return|;
block|}
block|}
comment|/**    * Represents a single Hbase Scan api call    */
specifier|public
specifier|static
class|class
name|ScanPlan
extends|extends
name|FilterPlan
block|{
specifier|public
specifier|static
class|class
name|ScanMarker
block|{
specifier|final
name|byte
index|[]
name|bytes
decl_stmt|;
comment|/**        * If inclusive = true, it means that the        * marker includes those bytes.        * If it is false, it means the marker starts at the next possible byte array        * or ends at the next possible byte array        */
specifier|final
name|boolean
name|isInclusive
decl_stmt|;
name|ScanMarker
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|boolean
name|i
parameter_list|)
block|{
name|this
operator|.
name|bytes
operator|=
name|b
expr_stmt|;
name|this
operator|.
name|isInclusive
operator|=
name|i
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ScanMarker [bytes="
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|bytes
argument_list|)
operator|+
literal|", isInclusive="
operator|+
name|isInclusive
operator|+
literal|"]"
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
specifier|final
name|int
name|prime
init|=
literal|31
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
name|result
operator|=
name|prime
operator|*
name|result
operator|+
name|Arrays
operator|.
name|hashCode
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|result
operator|=
name|prime
operator|*
name|result
operator|+
operator|(
name|isInclusive
condition|?
literal|1231
else|:
literal|1237
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|getClass
argument_list|()
operator|!=
name|obj
operator|.
name|getClass
argument_list|()
condition|)
return|return
literal|false
return|;
name|ScanMarker
name|other
init|=
operator|(
name|ScanMarker
operator|)
name|obj
decl_stmt|;
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|bytes
argument_list|,
name|other
operator|.
name|bytes
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|isInclusive
operator|!=
name|other
operator|.
name|isInclusive
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
block|}
comment|// represent Scan start
specifier|private
name|ScanMarker
name|startMarker
init|=
operator|new
name|ScanMarker
argument_list|(
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// represent Scan end
specifier|private
name|ScanMarker
name|endMarker
init|=
operator|new
name|ScanMarker
argument_list|(
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|private
name|ScanFilter
name|filter
decl_stmt|;
specifier|public
name|ScanFilter
name|getFilter
parameter_list|()
block|{
return|return
name|filter
return|;
block|}
specifier|public
name|void
name|setFilter
parameter_list|(
name|ScanFilter
name|filter
parameter_list|)
block|{
name|this
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
block|}
specifier|public
name|ScanMarker
name|getStartMarker
parameter_list|()
block|{
return|return
name|startMarker
return|;
block|}
specifier|public
name|void
name|setStartMarker
parameter_list|(
name|ScanMarker
name|startMarker
parameter_list|)
block|{
name|this
operator|.
name|startMarker
operator|=
name|startMarker
expr_stmt|;
block|}
specifier|public
name|void
name|setStartMarker
parameter_list|(
name|byte
index|[]
name|start
parameter_list|,
name|boolean
name|isInclusive
parameter_list|)
block|{
name|setStartMarker
argument_list|(
operator|new
name|ScanMarker
argument_list|(
name|start
argument_list|,
name|isInclusive
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ScanMarker
name|getEndMarker
parameter_list|()
block|{
return|return
name|endMarker
return|;
block|}
specifier|public
name|void
name|setEndMarker
parameter_list|(
name|ScanMarker
name|endMarker
parameter_list|)
block|{
name|this
operator|.
name|endMarker
operator|=
name|endMarker
expr_stmt|;
block|}
specifier|public
name|void
name|setEndMarker
parameter_list|(
name|byte
index|[]
name|end
parameter_list|,
name|boolean
name|isInclusive
parameter_list|)
block|{
name|setEndMarker
argument_list|(
operator|new
name|ScanMarker
argument_list|(
name|end
argument_list|,
name|isInclusive
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|FilterPlan
name|and
parameter_list|(
name|FilterPlan
name|other
parameter_list|)
block|{
name|List
argument_list|<
name|ScanPlan
argument_list|>
name|newSPlans
init|=
operator|new
name|ArrayList
argument_list|<
name|ScanPlan
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ScanPlan
name|otherSPlan
range|:
name|other
operator|.
name|getPlans
argument_list|()
control|)
block|{
name|newSPlans
operator|.
name|add
argument_list|(
name|this
operator|.
name|and
argument_list|(
name|otherSPlan
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|MultiScanPlan
argument_list|(
name|newSPlans
argument_list|)
return|;
block|}
specifier|private
name|ScanPlan
name|and
parameter_list|(
name|ScanPlan
name|other
parameter_list|)
block|{
comment|// create combined FilterPlan based on existing lhs and rhs plan
name|ScanPlan
name|newPlan
init|=
operator|new
name|ScanPlan
argument_list|()
decl_stmt|;
comment|// create new scan start
name|ScanMarker
name|greaterStartMarker
init|=
name|getComparedMarker
argument_list|(
name|this
operator|.
name|getStartMarker
argument_list|()
argument_list|,
name|other
operator|.
name|getStartMarker
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|newPlan
operator|.
name|setStartMarker
argument_list|(
name|greaterStartMarker
argument_list|)
expr_stmt|;
comment|// create new scan end
name|ScanMarker
name|lesserEndMarker
init|=
name|getComparedMarker
argument_list|(
name|this
operator|.
name|getEndMarker
argument_list|()
argument_list|,
name|other
operator|.
name|getEndMarker
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|newPlan
operator|.
name|setEndMarker
argument_list|(
name|lesserEndMarker
argument_list|)
expr_stmt|;
comment|// create new filter plan
name|newPlan
operator|.
name|setFilter
argument_list|(
name|createCombinedFilter
argument_list|(
name|this
operator|.
name|getFilter
argument_list|()
argument_list|,
name|other
operator|.
name|getFilter
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|newPlan
return|;
block|}
specifier|private
name|ScanFilter
name|createCombinedFilter
parameter_list|(
name|ScanFilter
name|filter1
parameter_list|,
name|ScanFilter
name|filter2
parameter_list|)
block|{
comment|// TODO create combined filter - filter1&& filter2
return|return
literal|null
return|;
block|}
comment|/**      * @param lStartMarker      * @param rStartMarker      * @param getGreater if true return greater startmarker, else return smaller one      * @return greater/lesser marker depending on value of getGreater      */
annotation|@
name|VisibleForTesting
specifier|static
name|ScanMarker
name|getComparedMarker
parameter_list|(
name|ScanMarker
name|lStartMarker
parameter_list|,
name|ScanMarker
name|rStartMarker
parameter_list|,
name|boolean
name|getGreater
parameter_list|)
block|{
comment|// if one of them has null bytes, just return other
if|if
condition|(
name|lStartMarker
operator|.
name|bytes
operator|==
literal|null
condition|)
block|{
return|return
name|rStartMarker
return|;
block|}
elseif|else
if|if
condition|(
name|rStartMarker
operator|.
name|bytes
operator|==
literal|null
condition|)
block|{
return|return
name|lStartMarker
return|;
block|}
name|int
name|compareRes
init|=
name|compare
argument_list|(
name|lStartMarker
operator|.
name|bytes
argument_list|,
name|rStartMarker
operator|.
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|compareRes
operator|==
literal|0
condition|)
block|{
comment|// bytes are equal, now compare the isInclusive flags
if|if
condition|(
name|lStartMarker
operator|.
name|isInclusive
operator|==
name|rStartMarker
operator|.
name|isInclusive
condition|)
block|{
comment|// actually equal, so return any one
return|return
name|lStartMarker
return|;
block|}
name|boolean
name|isInclusive
init|=
literal|true
decl_stmt|;
comment|// one that does not include the current bytes is greater
if|if
condition|(
name|getGreater
condition|)
block|{
name|isInclusive
operator|=
literal|false
expr_stmt|;
block|}
comment|// else
return|return
operator|new
name|ScanMarker
argument_list|(
name|lStartMarker
operator|.
name|bytes
argument_list|,
name|isInclusive
argument_list|)
return|;
block|}
if|if
condition|(
name|getGreater
condition|)
block|{
return|return
name|compareRes
operator|==
literal|1
condition|?
name|lStartMarker
else|:
name|rStartMarker
return|;
block|}
comment|// else
return|return
name|compareRes
operator|==
operator|-
literal|1
condition|?
name|lStartMarker
else|:
name|rStartMarker
return|;
block|}
annotation|@
name|Override
specifier|public
name|FilterPlan
name|or
parameter_list|(
name|FilterPlan
name|other
parameter_list|)
block|{
name|List
argument_list|<
name|ScanPlan
argument_list|>
name|plans
init|=
operator|new
name|ArrayList
argument_list|<
name|ScanPlan
argument_list|>
argument_list|(
name|getPlans
argument_list|()
argument_list|)
decl_stmt|;
name|plans
operator|.
name|addAll
argument_list|(
name|other
operator|.
name|getPlans
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|MultiScanPlan
argument_list|(
name|plans
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|ScanPlan
argument_list|>
name|getPlans
parameter_list|()
block|{
return|return
name|Arrays
operator|.
name|asList
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**      * @return row suffix - This is appended to db + table, to generate start row for the Scan      */
specifier|public
name|byte
index|[]
name|getStartRowSuffix
parameter_list|()
block|{
if|if
condition|(
name|startMarker
operator|.
name|isInclusive
condition|)
block|{
return|return
name|startMarker
operator|.
name|bytes
return|;
block|}
else|else
block|{
return|return
name|HBaseUtils
operator|.
name|getEndPrefix
argument_list|(
name|startMarker
operator|.
name|bytes
argument_list|)
return|;
block|}
block|}
comment|/**      * @return row suffix - This is appended to db + table, to generate end row for the Scan      */
specifier|public
name|byte
index|[]
name|getEndRowSuffix
parameter_list|()
block|{
if|if
condition|(
name|endMarker
operator|.
name|isInclusive
condition|)
block|{
return|return
name|HBaseUtils
operator|.
name|getEndPrefix
argument_list|(
name|endMarker
operator|.
name|bytes
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|endMarker
operator|.
name|bytes
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ScanPlan [startMarker="
operator|+
name|startMarker
operator|+
literal|", endMarker="
operator|+
name|endMarker
operator|+
literal|", filter="
operator|+
name|filter
operator|+
literal|"]"
return|;
block|}
block|}
comment|/**    * represent a plan that can be used to create a hbase filter and then set in    * Scan.setFilter()    */
specifier|public
specifier|static
class|class
name|ScanFilter
block|{
comment|// TODO: implement this
block|}
comment|/**    * Visitor for ExpressionTree.    * It first generates the ScanPlan for the leaf nodes. The higher level nodes are    * either AND or OR operations. It then calls FilterPlan.and and FilterPlan.or with    * the child nodes to generate the plans for higher level nodes.    */
annotation|@
name|VisibleForTesting
specifier|static
class|class
name|PartitionFilterGenerator
extends|extends
name|TreeVisitor
block|{
specifier|private
name|FilterPlan
name|curPlan
decl_stmt|;
comment|// this tells us if there is a condition that did not get included in the plan
comment|// such condition would be treated as getting evaluated to TRUE
specifier|private
name|boolean
name|hasUnsupportedCondition
init|=
literal|false
decl_stmt|;
comment|//Need to cache the left plans for the TreeNode. Use IdentityHashMap here
comment|// as we don't want to dedupe on two TreeNode that are otherwise considered equal
name|Map
argument_list|<
name|TreeNode
argument_list|,
name|FilterPlan
argument_list|>
name|leftPlans
init|=
operator|new
name|IdentityHashMap
argument_list|<
name|TreeNode
argument_list|,
name|FilterPlan
argument_list|>
argument_list|()
decl_stmt|;
comment|// temporary params for current left and right side plans, for AND, OR
specifier|private
name|FilterPlan
name|rPlan
decl_stmt|;
specifier|private
specifier|final
name|String
name|firstPartcolumn
decl_stmt|;
specifier|public
name|PartitionFilterGenerator
parameter_list|(
name|String
name|firstPartitionColumn
parameter_list|)
block|{
name|this
operator|.
name|firstPartcolumn
operator|=
name|firstPartitionColumn
expr_stmt|;
block|}
name|FilterPlan
name|getPlan
parameter_list|()
block|{
return|return
name|curPlan
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|beginTreeNode
parameter_list|(
name|TreeNode
name|node
parameter_list|)
throws|throws
name|MetaException
block|{
comment|// reset the params
name|curPlan
operator|=
name|rPlan
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|midTreeNode
parameter_list|(
name|TreeNode
name|node
parameter_list|)
throws|throws
name|MetaException
block|{
name|leftPlans
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|curPlan
argument_list|)
expr_stmt|;
name|curPlan
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|endTreeNode
parameter_list|(
name|TreeNode
name|node
parameter_list|)
throws|throws
name|MetaException
block|{
name|rPlan
operator|=
name|curPlan
expr_stmt|;
name|FilterPlan
name|lPlan
init|=
name|leftPlans
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|leftPlans
operator|.
name|remove
argument_list|(
name|node
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getAndOr
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
name|curPlan
operator|=
name|lPlan
operator|.
name|and
argument_list|(
name|rPlan
argument_list|)
expr_stmt|;
break|break;
case|case
name|OR
case|:
name|curPlan
operator|=
name|lPlan
operator|.
name|or
argument_list|(
name|rPlan
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unexpected logical operation "
operator|+
name|node
operator|.
name|getAndOr
argument_list|()
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LeafNode
name|node
parameter_list|)
throws|throws
name|MetaException
block|{
name|ScanPlan
name|leafPlan
init|=
operator|new
name|ScanPlan
argument_list|()
decl_stmt|;
name|curPlan
operator|=
name|leafPlan
expr_stmt|;
if|if
condition|(
operator|!
name|isFirstParitionColumn
argument_list|(
name|node
operator|.
name|keyName
argument_list|)
condition|)
block|{
name|leafPlan
operator|.
name|setFilter
argument_list|(
name|generateScanFilter
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|node
operator|.
name|value
operator|instanceof
name|String
operator|)
condition|)
block|{
comment|// only string type is supported currently
comment|// treat conditions on other types as true
return|return;
block|}
comment|// this is a condition on first partition column, so might influence the
comment|// start and end of the scan
specifier|final
name|boolean
name|INCLUSIVE
init|=
literal|true
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|operator
condition|)
block|{
case|case
name|EQUALS
case|:
name|leafPlan
operator|.
name|setStartMarker
argument_list|(
name|toBytes
argument_list|(
name|node
operator|.
name|value
argument_list|)
argument_list|,
name|INCLUSIVE
argument_list|)
expr_stmt|;
name|leafPlan
operator|.
name|setEndMarker
argument_list|(
name|toBytes
argument_list|(
name|node
operator|.
name|value
argument_list|)
argument_list|,
name|INCLUSIVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREATERTHAN
case|:
name|leafPlan
operator|.
name|setStartMarker
argument_list|(
name|toBytes
argument_list|(
name|node
operator|.
name|value
argument_list|)
argument_list|,
operator|!
name|INCLUSIVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREATERTHANOREQUALTO
case|:
name|leafPlan
operator|.
name|setStartMarker
argument_list|(
name|toBytes
argument_list|(
name|node
operator|.
name|value
argument_list|)
argument_list|,
name|INCLUSIVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|LESSTHAN
case|:
name|leafPlan
operator|.
name|setEndMarker
argument_list|(
name|toBytes
argument_list|(
name|node
operator|.
name|value
argument_list|)
argument_list|,
operator|!
name|INCLUSIVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|LESSTHANOREQUALTO
case|:
name|leafPlan
operator|.
name|setEndMarker
argument_list|(
name|toBytes
argument_list|(
name|node
operator|.
name|value
argument_list|)
argument_list|,
name|INCLUSIVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIKE
case|:
case|case
name|NOTEQUALS
case|:
case|case
name|NOTEQUALS2
case|:
comment|// TODO: create filter plan for these
name|hasUnsupportedCondition
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|static
name|byte
index|[]
name|toBytes
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
comment|// TODO: actually implement this
comment|// We need to determine the actual type and use appropriate
comment|// serialization format for that type
return|return
operator|(
operator|(
name|String
operator|)
name|value
operator|)
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
return|;
block|}
specifier|private
name|ScanFilter
name|generateScanFilter
parameter_list|(
name|LeafNode
name|node
parameter_list|)
block|{
comment|// TODO Auto-generated method stub
name|hasUnsupportedCondition
operator|=
literal|true
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|private
name|boolean
name|isFirstParitionColumn
parameter_list|(
name|String
name|keyName
parameter_list|)
block|{
return|return
name|keyName
operator|.
name|equalsIgnoreCase
argument_list|(
name|firstPartcolumn
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|hasUnsupportedCondition
parameter_list|()
block|{
return|return
name|hasUnsupportedCondition
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|PlanResult
block|{
specifier|public
specifier|final
name|FilterPlan
name|plan
decl_stmt|;
specifier|public
specifier|final
name|boolean
name|hasUnsupportedCondition
decl_stmt|;
name|PlanResult
parameter_list|(
name|FilterPlan
name|plan
parameter_list|,
name|boolean
name|hasUnsupportedCondition
parameter_list|)
block|{
name|this
operator|.
name|plan
operator|=
name|plan
expr_stmt|;
name|this
operator|.
name|hasUnsupportedCondition
operator|=
name|hasUnsupportedCondition
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|PlanResult
name|getFilterPlan
parameter_list|(
name|ExpressionTree
name|exprTree
parameter_list|,
name|String
name|firstPartitionColumn
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|exprTree
operator|==
literal|null
condition|)
block|{
comment|// TODO: if exprTree is null, we should do what ObjectStore does. See HIVE-10102
return|return
operator|new
name|PlanResult
argument_list|(
operator|new
name|ScanPlan
argument_list|()
argument_list|,
literal|true
argument_list|)
return|;
block|}
name|PartitionFilterGenerator
name|pGenerator
init|=
operator|new
name|PartitionFilterGenerator
argument_list|(
name|firstPartitionColumn
argument_list|)
decl_stmt|;
name|exprTree
operator|.
name|accept
argument_list|(
name|pGenerator
argument_list|)
expr_stmt|;
return|return
operator|new
name|PlanResult
argument_list|(
name|pGenerator
operator|.
name|getPlan
argument_list|()
argument_list|,
name|pGenerator
operator|.
name|hasUnsupportedCondition
argument_list|()
argument_list|)
return|;
block|}
block|}
end_class

end_unit

