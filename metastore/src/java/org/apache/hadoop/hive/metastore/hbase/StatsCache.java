begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ColumnStatisticsObj
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_comment
comment|/**  * Caching for stats.  This implements an LRU cache.   It does not remove entries explicitly as  * that is generally expensive to find all entries for a table or partition.  Instead it lets them  * time out. When the cache is full a sweep is done in the background to remove expired entries.  * This cache is shared across all threads, and so operations are protected by reader or writer  * locks as appropriate.  */
end_comment

begin_class
class|class
name|StatsCache
block|{
specifier|static
specifier|final
specifier|private
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|StatsCache
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|StatsCache
name|self
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|long
name|timeToLive
decl_stmt|;
specifier|private
specifier|final
name|int
name|maxSize
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|Key
argument_list|,
name|StatsInfo
argument_list|>
name|cache
decl_stmt|;
specifier|private
name|ReadWriteLock
name|lock
decl_stmt|;
specifier|private
name|boolean
name|cleaning
decl_stmt|;
specifier|private
name|Counter
name|tableMisses
decl_stmt|;
specifier|private
name|Counter
name|partMisses
decl_stmt|;
specifier|private
name|Counter
name|tableHits
decl_stmt|;
specifier|private
name|Counter
name|partHits
decl_stmt|;
specifier|private
name|Counter
name|cleans
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Counter
argument_list|>
name|counters
decl_stmt|;
specifier|static
specifier|synchronized
name|StatsCache
name|getInstance
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
if|if
condition|(
name|self
operator|==
literal|null
condition|)
block|{
name|int
name|totalObjectsToCache
init|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTORE_HBASE_CACHE_SIZE
argument_list|)
decl_stmt|;
name|long
name|timeToLive
init|=
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTORE_HBASE_CACHE_TIME_TO_LIVE
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
decl_stmt|;
name|self
operator|=
operator|new
name|StatsCache
argument_list|(
name|totalObjectsToCache
operator|/
literal|2
argument_list|,
name|timeToLive
argument_list|)
expr_stmt|;
block|}
return|return
name|self
return|;
block|}
comment|/**    * @param max maximum number of objects to store in the cache.  When max is reached, eviction    *            policy is MRU.    * @param timeToLive time (in seconds) that an entry is valid.  After this time the record will    *                   discarded lazily    */
specifier|private
name|StatsCache
parameter_list|(
name|int
name|max
parameter_list|,
name|long
name|timeToLive
parameter_list|)
block|{
name|maxSize
operator|=
name|max
expr_stmt|;
name|this
operator|.
name|timeToLive
operator|=
name|timeToLive
operator|*
literal|1000
expr_stmt|;
name|cache
operator|=
operator|new
name|HashMap
argument_list|<
name|Key
argument_list|,
name|StatsInfo
argument_list|>
argument_list|()
expr_stmt|;
name|lock
operator|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
expr_stmt|;
name|cleaning
operator|=
literal|false
expr_stmt|;
name|counters
operator|=
operator|new
name|ArrayList
argument_list|<
name|Counter
argument_list|>
argument_list|()
expr_stmt|;
name|tableMisses
operator|=
operator|new
name|Counter
argument_list|(
literal|"Stats cache table misses"
argument_list|)
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|tableMisses
argument_list|)
expr_stmt|;
name|tableHits
operator|=
operator|new
name|Counter
argument_list|(
literal|"Stats cache table hits"
argument_list|)
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|tableHits
argument_list|)
expr_stmt|;
name|partMisses
operator|=
operator|new
name|Counter
argument_list|(
literal|"Stats cache partition misses"
argument_list|)
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|partMisses
argument_list|)
expr_stmt|;
name|partHits
operator|=
operator|new
name|Counter
argument_list|(
literal|"Stats cache partition hits"
argument_list|)
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|partHits
argument_list|)
expr_stmt|;
name|cleans
operator|=
operator|new
name|Counter
argument_list|(
literal|"Stats cache cleans"
argument_list|)
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|cleans
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add an object to the cache.    * @param dbName name of database table is in    * @param tableName name of table    * @param partName name of partition, can be null if these are table level statistics    * @param colName name of the column these statistics are for    * @param stats stats    * @param lastAnalyzed last time these stats were analyzed    */
name|void
name|put
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|partName
parameter_list|,
name|String
name|colName
parameter_list|,
name|ColumnStatisticsObj
name|stats
parameter_list|,
name|long
name|lastAnalyzed
parameter_list|)
block|{
comment|// TODO - we may want to not put an entry in if we're full.
if|if
condition|(
name|cache
operator|.
name|size
argument_list|()
operator|>=
name|maxSize
condition|)
name|clean
argument_list|()
expr_stmt|;
name|Key
name|key
init|=
operator|new
name|Key
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partName
argument_list|,
name|colName
argument_list|)
decl_stmt|;
name|StatsInfo
name|info
init|=
operator|new
name|StatsInfo
argument_list|(
name|stats
argument_list|,
name|lastAnalyzed
argument_list|)
decl_stmt|;
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|cache
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get table level statistics    * @param dbName name of database table is in    * @param tableName name of table    * @param colName of column to get stats for    * @return stats object for this column, or null if none cached    */
name|StatsInfo
name|getTableStatistics
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|colName
parameter_list|)
block|{
return|return
name|getStatistics
argument_list|(
operator|new
name|Key
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|colName
argument_list|)
argument_list|,
name|tableHits
argument_list|,
name|tableMisses
argument_list|)
return|;
block|}
comment|/**    * Get partition level statistics    * @param dbName name of database table is in    * @param tableName name of table    * @param partName name of this partition    * @param colName of column to get stats for    * @return stats object for this column, or null if none cached    */
name|StatsInfo
name|getPartitionStatistics
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|partName
parameter_list|,
name|String
name|colName
parameter_list|)
block|{
return|return
name|getStatistics
argument_list|(
operator|new
name|Key
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partName
argument_list|,
name|colName
argument_list|)
argument_list|,
name|partHits
argument_list|,
name|partMisses
argument_list|)
return|;
block|}
name|String
index|[]
name|dumpMetrics
parameter_list|()
block|{
name|String
index|[]
name|strs
init|=
operator|new
name|String
index|[
name|counters
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|strs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|strs
index|[
name|i
index|]
operator|=
name|counters
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|dump
argument_list|()
expr_stmt|;
block|}
return|return
name|strs
return|;
block|}
specifier|private
name|StatsInfo
name|getStatistics
parameter_list|(
name|Key
name|key
parameter_list|,
name|Counter
name|hits
parameter_list|,
name|Counter
name|misses
parameter_list|)
block|{
name|StatsInfo
name|s
init|=
literal|null
decl_stmt|;
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|s
operator|=
name|cache
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
name|misses
operator|.
name|incr
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|tooLate
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|misses
operator|.
name|incr
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
name|s
operator|.
name|lastTouched
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|hits
operator|.
name|incr
argument_list|()
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
specifier|private
name|void
name|remove
parameter_list|(
name|Key
name|key
parameter_list|)
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// It's possible that multiple callers will call remove for a given key, so don't complain
comment|// if the indicated key is already gone.
name|cache
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|clean
parameter_list|()
block|{
comment|// TODO - we may want to add intelligence to check if we cleaned anything after a cleaning
comment|// pass.  If we're still at or near capacity we may want to reduce ttl and make another run.
comment|// This spawns a separate thread to walk through the cache and clean.
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|cleaning
condition|)
return|return;
name|cleaning
operator|=
literal|true
expr_stmt|;
name|cleans
operator|.
name|incr
argument_list|()
expr_stmt|;
block|}
name|Thread
name|cleaner
init|=
operator|new
name|Thread
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
comment|// Get the read lock and then make a copy of the map.  This is so we can work through it
comment|// without having concurrent modification exceptions.  Then walk through and remove things
comment|// one at a time.
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Key
argument_list|,
name|StatsInfo
argument_list|>
argument_list|>
name|entries
init|=
literal|null
decl_stmt|;
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|entries
operator|=
operator|new
name|ArrayList
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Key
argument_list|,
name|StatsInfo
argument_list|>
argument_list|>
argument_list|(
name|cache
operator|.
name|entrySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Key
argument_list|,
name|StatsInfo
argument_list|>
name|entry
range|:
name|entries
control|)
block|{
if|if
condition|(
name|tooLate
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|remove
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// We want to make sure this runs at a low priority in the background
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Don't let anything past this thread that could end up killing the metastore
name|LOG
operator|.
name|error
argument_list|(
literal|"Caught exception in stats cleaner thread"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cleaning
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
name|cleaner
operator|.
name|setPriority
argument_list|(
name|Thread
operator|.
name|MIN_PRIORITY
argument_list|)
expr_stmt|;
name|cleaner
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|cleaner
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
specifier|private
name|boolean
name|tooLate
parameter_list|(
name|StatsInfo
name|stats
parameter_list|)
block|{
return|return
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|stats
operator|.
name|lastTouched
operator|>
name|timeToLive
return|;
block|}
specifier|private
specifier|static
class|class
name|Key
block|{
specifier|private
specifier|final
name|String
name|dbName
decl_stmt|,
name|tableName
decl_stmt|,
name|partName
decl_stmt|,
name|colName
decl_stmt|;
name|Key
parameter_list|(
name|String
name|db
parameter_list|,
name|String
name|table
parameter_list|,
name|String
name|col
parameter_list|)
block|{
name|this
argument_list|(
name|db
argument_list|,
name|table
argument_list|,
literal|null
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
name|Key
parameter_list|(
name|String
name|db
parameter_list|,
name|String
name|table
parameter_list|,
name|String
name|part
parameter_list|,
name|String
name|col
parameter_list|)
block|{
name|dbName
operator|=
name|db
expr_stmt|;
name|tableName
operator|=
name|table
expr_stmt|;
name|partName
operator|=
name|part
expr_stmt|;
name|colName
operator|=
name|col
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|==
literal|null
operator|||
operator|!
operator|(
name|other
operator|instanceof
name|Key
operator|)
condition|)
return|return
literal|false
return|;
name|Key
name|that
init|=
operator|(
name|Key
operator|)
name|other
decl_stmt|;
if|if
condition|(
name|partName
operator|==
literal|null
condition|)
block|{
return|return
name|that
operator|.
name|partName
operator|==
literal|null
operator|&&
name|dbName
operator|.
name|equals
argument_list|(
name|that
operator|.
name|dbName
argument_list|)
operator|&&
name|tableName
operator|.
name|equals
argument_list|(
name|that
operator|.
name|tableName
argument_list|)
operator|&&
name|colName
operator|.
name|equals
argument_list|(
name|that
operator|.
name|colName
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|dbName
operator|.
name|equals
argument_list|(
name|that
operator|.
name|dbName
argument_list|)
operator|&&
name|tableName
operator|.
name|equals
argument_list|(
name|that
operator|.
name|tableName
argument_list|)
operator|&&
name|partName
operator|.
name|equals
argument_list|(
name|that
operator|.
name|partName
argument_list|)
operator|&&
name|colName
operator|.
name|equals
argument_list|(
name|that
operator|.
name|colName
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|hashCode
init|=
name|dbName
operator|.
name|hashCode
argument_list|()
operator|*
literal|31
operator|+
name|tableName
operator|.
name|hashCode
argument_list|()
decl_stmt|;
if|if
condition|(
name|partName
operator|!=
literal|null
condition|)
name|hashCode
operator|=
name|hashCode
operator|*
literal|31
operator|+
name|partName
operator|.
name|hashCode
argument_list|()
expr_stmt|;
return|return
name|hashCode
operator|*
literal|31
operator|+
name|colName
operator|.
name|hashCode
argument_list|()
return|;
block|}
block|}
specifier|static
class|class
name|StatsInfo
block|{
specifier|final
name|ColumnStatisticsObj
name|stats
decl_stmt|;
specifier|final
name|long
name|lastAnalyzed
decl_stmt|;
name|long
name|lastTouched
decl_stmt|;
name|StatsInfo
parameter_list|(
name|ColumnStatisticsObj
name|obj
parameter_list|,
name|long
name|la
parameter_list|)
block|{
name|stats
operator|=
name|obj
expr_stmt|;
name|lastAnalyzed
operator|=
name|la
expr_stmt|;
name|lastTouched
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * This returns a stats cache that will store nothing and return nothing, useful    * for unit testing when you don't want the cache in your way.    * @return    */
annotation|@
name|VisibleForTesting
specifier|static
name|StatsCache
name|getBogusStatsCache
parameter_list|()
block|{
return|return
operator|new
name|StatsCache
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|{
annotation|@
name|Override
name|void
name|put
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|partName
parameter_list|,
name|String
name|colName
parameter_list|,
name|ColumnStatisticsObj
name|stats
parameter_list|,
name|long
name|lastAnalyzed
parameter_list|)
block|{       }
annotation|@
name|Override
name|StatsInfo
name|getTableStatistics
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|colName
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
name|StatsInfo
name|getPartitionStatistics
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|partName
parameter_list|,
name|String
name|colName
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
return|;
block|}
comment|/**    * Go through and make all the entries in the cache old so they will time out when requested    */
annotation|@
name|VisibleForTesting
name|void
name|makeWayOld
parameter_list|()
block|{
for|for
control|(
name|StatsInfo
name|stats
range|:
name|cache
operator|.
name|values
argument_list|()
control|)
block|{
name|stats
operator|.
name|lastTouched
operator|=
literal|1
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
name|int
name|cacheSize
parameter_list|()
block|{
return|return
name|cache
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
name|boolean
name|cleaning
parameter_list|()
block|{
return|return
name|cleaning
return|;
block|}
annotation|@
name|VisibleForTesting
name|void
name|clear
parameter_list|()
block|{
name|cache
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

