begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HColumnDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Delete
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Get
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|HBaseAdmin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|HConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|HConnectionManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|HTableInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Put
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ResultScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Scan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|CompareFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|RegexStringComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|RowFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ObjectPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ColumnStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ColumnStatisticsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ColumnStatisticsObj
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Database
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|NoSuchObjectException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Partition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Role
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|StorageDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|MessageDigest
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchAlgorithmException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * Class to manage storing object in and reading them from HBase.  */
end_comment

begin_class
class|class
name|HBaseReadWrite
block|{
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|String
name|DB_TABLE
init|=
literal|"DBS"
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|String
name|PART_TABLE
init|=
literal|"PARTITIONS"
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|String
name|ROLE_TABLE
init|=
literal|"ROLES"
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|String
name|SD_TABLE
init|=
literal|"SDS"
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|String
name|TABLE_TABLE
init|=
literal|"TBLS"
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|byte
index|[]
name|CATALOG_CF
init|=
literal|"c"
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|byte
index|[]
name|STATS_CF
init|=
literal|"s"
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|String
name|NO_CACHE_CONF
init|=
literal|"no.use.cache"
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|byte
index|[]
name|CATALOG_COL
init|=
literal|"cat"
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|byte
index|[]
name|REF_COUNT_COL
init|=
literal|"ref"
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|int
name|TABLES_TO_CACHE
init|=
literal|10
decl_stmt|;
comment|// TODO Add privileges as a second column in the CATALOG_CF
specifier|private
specifier|final
specifier|static
name|String
index|[]
name|tableNames
init|=
block|{
name|DB_TABLE
block|,
name|PART_TABLE
block|,
name|ROLE_TABLE
block|,
name|SD_TABLE
block|,
name|TABLE_TABLE
block|}
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HBaseReadWrite
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|ThreadLocal
argument_list|<
name|HBaseReadWrite
argument_list|>
name|self
init|=
operator|new
name|ThreadLocal
argument_list|<
name|HBaseReadWrite
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|HBaseReadWrite
name|initialValue
parameter_list|()
block|{
if|if
condition|(
name|staticConf
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Attempt to create HBaseReadWrite with no configuration set"
argument_list|)
throw|;
block|}
return|return
operator|new
name|HBaseReadWrite
argument_list|(
name|staticConf
argument_list|)
return|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|static
name|boolean
name|tablesCreated
init|=
literal|false
decl_stmt|;
specifier|private
specifier|static
name|Configuration
name|staticConf
init|=
literal|null
decl_stmt|;
specifier|private
name|Configuration
name|conf
decl_stmt|;
specifier|private
name|HConnection
name|conn
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|HTableInterface
argument_list|>
name|tables
decl_stmt|;
specifier|private
name|MessageDigest
name|md
decl_stmt|;
specifier|private
name|ObjectCache
argument_list|<
name|ObjectPair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|,
name|Table
argument_list|>
name|tableCache
decl_stmt|;
specifier|private
name|ObjectCache
argument_list|<
name|ByteArrayWrapper
argument_list|,
name|StorageDescriptor
argument_list|>
name|sdCache
decl_stmt|;
specifier|private
name|PartitionCache
name|partCache
decl_stmt|;
specifier|private
name|StatsCache
name|statsCache
decl_stmt|;
specifier|private
name|Counter
name|tableHits
decl_stmt|;
specifier|private
name|Counter
name|tableMisses
decl_stmt|;
specifier|private
name|Counter
name|tableOverflows
decl_stmt|;
specifier|private
name|Counter
name|partHits
decl_stmt|;
specifier|private
name|Counter
name|partMisses
decl_stmt|;
specifier|private
name|Counter
name|partOverflows
decl_stmt|;
specifier|private
name|Counter
name|sdHits
decl_stmt|;
specifier|private
name|Counter
name|sdMisses
decl_stmt|;
specifier|private
name|Counter
name|sdOverflows
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Counter
argument_list|>
name|counters
decl_stmt|;
comment|/**    * Get the instance of HBaseReadWrite for the current thread.  This is intended to be used by    * {@link org.apache.hadoop.hive.metastore.hbase.HBaseStore} since it creates the thread local    * version of this class.    * @param configuration Configuration object    * @return thread's instance of HBaseReadWrite    */
specifier|static
name|HBaseReadWrite
name|getInstance
parameter_list|(
name|Configuration
name|configuration
parameter_list|)
block|{
name|staticConf
operator|=
name|configuration
expr_stmt|;
return|return
name|self
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Get the instance of HBaseReadWrite for the current thread.  This is inteded to be used after    * the thread has been initialized.  Woe betide you if that's not the case.    * @return thread's instance of HBaseReadWrite    */
specifier|static
name|HBaseReadWrite
name|getInstance
parameter_list|()
block|{
return|return
name|self
operator|.
name|get
argument_list|()
return|;
block|}
specifier|private
name|HBaseReadWrite
parameter_list|(
name|Configuration
name|configuration
parameter_list|)
block|{
name|conf
operator|=
name|configuration
expr_stmt|;
name|HBaseConfiguration
operator|.
name|addHbaseResources
argument_list|(
name|conf
argument_list|)
expr_stmt|;
try|try
block|{
name|conn
operator|=
name|HConnectionManager
operator|.
name|createConnection
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|tables
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|HTableInterface
argument_list|>
argument_list|()
expr_stmt|;
try|try
block|{
name|md
operator|=
name|MessageDigest
operator|.
name|getInstance
argument_list|(
literal|"MD5"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|int
name|totalObjectsToCache
init|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTORE_HBASE_CACHE_SIZE
argument_list|)
decl_stmt|;
name|tableHits
operator|=
operator|new
name|Counter
argument_list|(
literal|"table cache hits"
argument_list|)
expr_stmt|;
name|tableMisses
operator|=
operator|new
name|Counter
argument_list|(
literal|"table cache misses"
argument_list|)
expr_stmt|;
name|tableOverflows
operator|=
operator|new
name|Counter
argument_list|(
literal|"table cache overflows"
argument_list|)
expr_stmt|;
name|partHits
operator|=
operator|new
name|Counter
argument_list|(
literal|"partition cache hits"
argument_list|)
expr_stmt|;
name|partMisses
operator|=
operator|new
name|Counter
argument_list|(
literal|"partition cache misses"
argument_list|)
expr_stmt|;
name|partOverflows
operator|=
operator|new
name|Counter
argument_list|(
literal|"partition cache overflows"
argument_list|)
expr_stmt|;
name|sdHits
operator|=
operator|new
name|Counter
argument_list|(
literal|"storage descriptor cache hits"
argument_list|)
expr_stmt|;
name|sdMisses
operator|=
operator|new
name|Counter
argument_list|(
literal|"storage descriptor cache misses"
argument_list|)
expr_stmt|;
name|sdOverflows
operator|=
operator|new
name|Counter
argument_list|(
literal|"storage descriptor cache overflows"
argument_list|)
expr_stmt|;
name|counters
operator|=
operator|new
name|ArrayList
argument_list|<
name|Counter
argument_list|>
argument_list|()
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|tableHits
argument_list|)
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|tableMisses
argument_list|)
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|tableOverflows
argument_list|)
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|partHits
argument_list|)
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|partMisses
argument_list|)
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|partOverflows
argument_list|)
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|sdHits
argument_list|)
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|sdMisses
argument_list|)
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|sdOverflows
argument_list|)
expr_stmt|;
comment|// Divide 50/50 between catalog and stats, then give 1% of catalog space to storage
comment|// descriptors (storage descriptors are shared, so 99% should be the same for a
comment|// given table).
name|int
name|sdsCacheSize
init|=
name|totalObjectsToCache
operator|/
literal|100
decl_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|NO_CACHE_CONF
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|tableCache
operator|=
operator|new
name|BogusObjectCache
argument_list|<
name|ObjectPair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|,
name|Table
argument_list|>
argument_list|()
expr_stmt|;
name|sdCache
operator|=
operator|new
name|BogusObjectCache
argument_list|<
name|ByteArrayWrapper
argument_list|,
name|StorageDescriptor
argument_list|>
argument_list|()
expr_stmt|;
name|partCache
operator|=
operator|new
name|BogusPartitionCache
argument_list|()
expr_stmt|;
name|statsCache
operator|=
name|StatsCache
operator|.
name|getBogusStatsCache
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|tableCache
operator|=
operator|new
name|ObjectCache
argument_list|<
name|ObjectPair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|,
name|Table
argument_list|>
argument_list|(
name|TABLES_TO_CACHE
argument_list|,
name|tableHits
argument_list|,
name|tableMisses
argument_list|,
name|tableOverflows
argument_list|)
expr_stmt|;
name|sdCache
operator|=
operator|new
name|ObjectCache
argument_list|<
name|ByteArrayWrapper
argument_list|,
name|StorageDescriptor
argument_list|>
argument_list|(
name|sdsCacheSize
argument_list|,
name|sdHits
argument_list|,
name|sdMisses
argument_list|,
name|sdOverflows
argument_list|)
expr_stmt|;
name|partCache
operator|=
operator|new
name|PartitionCache
argument_list|(
name|totalObjectsToCache
operator|/
literal|2
argument_list|,
name|partHits
argument_list|,
name|partMisses
argument_list|,
name|partOverflows
argument_list|)
expr_stmt|;
name|statsCache
operator|=
name|StatsCache
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Synchronize this so not everyone's doing it at once.
specifier|static
specifier|synchronized
name|void
name|createTablesIfNotExist
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|tablesCreated
condition|)
block|{
name|HBaseAdmin
name|admin
init|=
operator|new
name|HBaseAdmin
argument_list|(
name|self
operator|.
name|get
argument_list|()
operator|.
name|conn
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|tableNames
control|)
block|{
if|if
condition|(
name|self
operator|.
name|get
argument_list|()
operator|.
name|getHTable
argument_list|(
name|name
argument_list|)
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Creating HBase table "
operator|+
name|name
argument_list|)
expr_stmt|;
name|HTableDescriptor
name|tableDesc
init|=
operator|new
name|HTableDescriptor
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
name|tableDesc
operator|.
name|addFamily
argument_list|(
operator|new
name|HColumnDescriptor
argument_list|(
name|CATALOG_CF
argument_list|)
argument_list|)
expr_stmt|;
comment|// Only table and partitions need stats
if|if
condition|(
name|TABLE_TABLE
operator|.
name|equals
argument_list|(
name|name
argument_list|)
operator|||
name|PART_TABLE
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|tableDesc
operator|.
name|addFamily
argument_list|(
operator|new
name|HColumnDescriptor
argument_list|(
name|STATS_CF
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|admin
operator|.
name|createTable
argument_list|(
name|tableDesc
argument_list|)
expr_stmt|;
block|}
block|}
name|admin
operator|.
name|close
argument_list|()
expr_stmt|;
name|tablesCreated
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/**    * Begin a transaction    */
name|void
name|begin
parameter_list|()
block|{
comment|// NOP for now
block|}
comment|/**    * Commit a transaction    */
name|void
name|commit
parameter_list|()
block|{
comment|// NOP for now
block|}
name|void
name|rollback
parameter_list|()
block|{
comment|// NOP for now
block|}
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|HTableInterface
name|htab
range|:
name|tables
operator|.
name|values
argument_list|()
control|)
name|htab
operator|.
name|close
argument_list|()
expr_stmt|;
name|conn
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Fetch a database object    * @param name name of the database to fetch    * @return the database object, or null if there is no such database    * @throws IOException    */
name|Database
name|getDb
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|byte
index|[]
name|serialized
init|=
name|read
argument_list|(
name|DB_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|DatabaseWritable
name|db
init|=
operator|new
name|DatabaseWritable
argument_list|()
decl_stmt|;
name|HBaseUtils
operator|.
name|deserialize
argument_list|(
name|db
argument_list|,
name|serialized
argument_list|)
expr_stmt|;
return|return
name|db
operator|.
name|db
return|;
block|}
comment|/**    * Get a list of databases.    * @param regex Regular expression to use in searching for database names.  It is expected to    *              be a Java regular expression.  If it is null then all databases will be returned.    * @return list of databases matching the regular expression.    * @throws IOException    */
name|List
argument_list|<
name|Database
argument_list|>
name|scanDatabases
parameter_list|(
name|String
name|regex
parameter_list|)
throws|throws
name|IOException
block|{
name|Filter
name|filter
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|regex
operator|!=
literal|null
condition|)
block|{
name|filter
operator|=
operator|new
name|RowFilter
argument_list|(
name|CompareFilter
operator|.
name|CompareOp
operator|.
name|EQUAL
argument_list|,
operator|new
name|RegexStringComparator
argument_list|(
name|regex
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|Result
argument_list|>
name|iter
init|=
name|scanWithFilter
argument_list|(
name|DB_TABLE
argument_list|,
literal|null
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Database
argument_list|>
name|databases
init|=
operator|new
name|ArrayList
argument_list|<
name|Database
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|DatabaseWritable
name|db
init|=
operator|new
name|DatabaseWritable
argument_list|()
decl_stmt|;
name|HBaseUtils
operator|.
name|deserialize
argument_list|(
name|db
argument_list|,
name|iter
operator|.
name|next
argument_list|()
operator|.
name|getValue
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
argument_list|)
expr_stmt|;
name|databases
operator|.
name|add
argument_list|(
name|db
operator|.
name|db
argument_list|)
expr_stmt|;
block|}
return|return
name|databases
return|;
block|}
comment|/**    * Store a database object    * @param database database object to store    * @throws IOException    */
name|void
name|putDb
parameter_list|(
name|Database
name|database
parameter_list|)
throws|throws
name|IOException
block|{
name|DatabaseWritable
name|db
init|=
operator|new
name|DatabaseWritable
argument_list|(
name|database
argument_list|)
decl_stmt|;
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|db
operator|.
name|db
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|byte
index|[]
name|serialized
init|=
name|HBaseUtils
operator|.
name|serialize
argument_list|(
name|db
argument_list|)
decl_stmt|;
name|store
argument_list|(
name|DB_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|serialized
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**    * Drop a database    * @param name name of db to drop    * @throws IOException    */
name|void
name|deleteDb
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|delete
argument_list|(
name|DB_TABLE
argument_list|,
name|key
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**    * Fetch one partition    * @param dbName database table is in    * @param tableName table partition is in    * @param partVals list of values that specify the partition, given in the same order as the    *                 columns they belong to    * @return The partition objec,t or null if there is no such partition    * @throws IOException    */
name|Partition
name|getPartition
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partVals
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getPartition
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partVals
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Add a partition    * @param partition partition object to add    * @throws IOException    */
name|void
name|putPartition
parameter_list|(
name|Partition
name|partition
parameter_list|)
throws|throws
name|IOException
block|{
name|PartitionWritable
name|part
init|=
operator|new
name|PartitionWritable
argument_list|(
name|partition
argument_list|)
decl_stmt|;
name|byte
index|[]
name|key
init|=
name|buildPartitionKey
argument_list|(
name|part
argument_list|)
decl_stmt|;
name|byte
index|[]
name|serialized
init|=
name|HBaseUtils
operator|.
name|serialize
argument_list|(
name|part
argument_list|)
decl_stmt|;
name|store
argument_list|(
name|PART_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|serialized
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|partCache
operator|.
name|put
argument_list|(
name|partition
operator|.
name|getDbName
argument_list|()
argument_list|,
name|partition
operator|.
name|getTableName
argument_list|()
argument_list|,
name|partition
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a group of partitions    * @param partitions list of partitions to add    * @throws IOException    */
name|void
name|putPartitions
parameter_list|(
name|List
argument_list|<
name|Partition
argument_list|>
name|partitions
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|Put
argument_list|>
name|puts
init|=
operator|new
name|ArrayList
argument_list|<
name|Put
argument_list|>
argument_list|(
name|partitions
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Partition
name|partition
range|:
name|partitions
control|)
block|{
name|PartitionWritable
name|part
init|=
operator|new
name|PartitionWritable
argument_list|(
name|partition
argument_list|)
decl_stmt|;
name|byte
index|[]
name|key
init|=
name|buildPartitionKey
argument_list|(
name|part
argument_list|)
decl_stmt|;
name|byte
index|[]
name|serialized
init|=
name|HBaseUtils
operator|.
name|serialize
argument_list|(
name|part
argument_list|)
decl_stmt|;
name|Put
name|p
init|=
operator|new
name|Put
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|p
operator|.
name|add
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|serialized
argument_list|)
expr_stmt|;
name|puts
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|partCache
operator|.
name|put
argument_list|(
name|partition
operator|.
name|getDbName
argument_list|()
argument_list|,
name|partition
operator|.
name|getTableName
argument_list|()
argument_list|,
name|partition
argument_list|)
expr_stmt|;
block|}
name|getHTable
argument_list|(
name|PART_TABLE
argument_list|)
operator|.
name|put
argument_list|(
name|puts
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**    * Find all the partitions in a table.    * @param dbName name of the database the table is in    * @param tableName table name    * @param maxPartitions max partitions to fetch.  If negative all partitions will be returned.    * @return List of partitions that match the criteria.    * @throws IOException    */
name|List
argument_list|<
name|Partition
argument_list|>
name|scanPartitionsInTable
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|int
name|maxPartitions
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|maxPartitions
operator|<
literal|0
condition|)
name|maxPartitions
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
name|Collection
argument_list|<
name|Partition
argument_list|>
name|cached
init|=
name|partCache
operator|.
name|getAllForTable
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cached
operator|!=
literal|null
condition|)
block|{
return|return
name|maxPartitions
operator|<
name|cached
operator|.
name|size
argument_list|()
condition|?
operator|new
name|ArrayList
argument_list|<
name|Partition
argument_list|>
argument_list|(
name|cached
argument_list|)
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|maxPartitions
argument_list|)
else|:
operator|new
name|ArrayList
argument_list|<
name|Partition
argument_list|>
argument_list|(
name|cached
argument_list|)
return|;
block|}
name|byte
index|[]
name|keyPrefix
init|=
name|HBaseUtils
operator|.
name|buildKeyWithTrailingSeparator
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Partition
argument_list|>
name|parts
init|=
name|scanPartitions
argument_list|(
name|keyPrefix
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|partCache
operator|.
name|put
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|parts
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|maxPartitions
operator|<
name|parts
operator|.
name|size
argument_list|()
condition|?
name|parts
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|maxPartitions
argument_list|)
else|:
name|parts
return|;
block|}
comment|/**    * Scan partitions based on partial key information.    * @param dbName name of database, required    * @param tableName name of table, required    * @param partVals partial specification of values.  Any values that are unknown can instead be    *                 a '*'.  For example, if a table had two partition columns date    *                 and region (in that order), and partitions ('today', 'na'), ('today', 'eu'),    *                 ('tomorrow', 'na'), ('tomorrow', 'eu') then passing ['today', '*'] would return    *                 ('today', 'na') and ('today', 'eu') while passing ['*', 'eu'] would return    *                 ('today', 'eu') and ('tomorrow', 'eu').  Also the list can terminate early,    *                 which will be the equivalent of adding '*' for all non-included values.    *                 I.e. ['today'] is the same as ['today', '*'].    * @param maxPartitions Maximum number of entries to return.    * @return list of partitions that match the specified information    * @throws IOException    * @throws org.apache.hadoop.hive.metastore.api.NoSuchObjectException if the table containing    * the partitions can't be found.    */
name|List
argument_list|<
name|Partition
argument_list|>
name|scanPartitions
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partVals
parameter_list|,
name|int
name|maxPartitions
parameter_list|)
throws|throws
name|IOException
throws|,
name|NoSuchObjectException
block|{
comment|// First, build as much of the key as we can so that we make the scan as tight as possible.
name|List
argument_list|<
name|String
argument_list|>
name|keyElements
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|keyElements
operator|.
name|add
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|keyElements
operator|.
name|add
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|int
name|firstStar
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partVals
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
literal|"*"
operator|.
name|equals
argument_list|(
name|partVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|firstStar
operator|=
name|i
expr_stmt|;
break|break;
block|}
else|else
block|{
name|keyElements
operator|.
name|add
argument_list|(
name|partVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|byte
index|[]
name|keyPrefix
decl_stmt|;
comment|// We need to fetch the table to determine if the user fully specified the partitions or
comment|// not, as it affects how we build the key.
name|Table
name|table
init|=
name|getTable
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchObjectException
argument_list|(
literal|"Unable to find table "
operator|+
name|dbName
operator|+
literal|"."
operator|+
name|tableName
argument_list|)
throw|;
block|}
if|if
condition|(
name|partVals
operator|.
name|size
argument_list|()
operator|==
name|table
operator|.
name|getPartitionKeys
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
name|keyPrefix
operator|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|keyElements
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|keyElements
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|keyPrefix
operator|=
name|HBaseUtils
operator|.
name|buildKeyWithTrailingSeparator
argument_list|(
name|keyElements
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|keyElements
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Now, build a filter out of the remaining keys
name|String
name|regex
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|partVals
operator|.
name|size
argument_list|()
operator|==
name|table
operator|.
name|getPartitionKeys
argument_list|()
operator|.
name|size
argument_list|()
operator|&&
name|firstStar
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|".*"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|firstStar
argument_list|)
init|;
name|i
operator|<
name|table
operator|.
name|getPartitionKeys
argument_list|()
operator|.
name|size
argument_list|()
operator|&&
name|i
operator|<
name|partVals
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|HBaseUtils
operator|.
name|KEY_SEPARATOR
argument_list|)
expr_stmt|;
if|if
condition|(
literal|"*"
operator|.
name|equals
argument_list|(
name|partVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"[^"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|HBaseUtils
operator|.
name|KEY_SEPARATOR
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"]+"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
name|partVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|partVals
operator|.
name|size
argument_list|()
operator|<
name|table
operator|.
name|getPartitionKeys
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|HBaseUtils
operator|.
name|KEY_SEPARATOR
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|".*"
argument_list|)
expr_stmt|;
block|}
name|regex
operator|=
name|buf
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|Filter
name|filter
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|regex
operator|!=
literal|null
condition|)
block|{
name|filter
operator|=
operator|new
name|RowFilter
argument_list|(
name|CompareFilter
operator|.
name|CompareOp
operator|.
name|EQUAL
argument_list|,
operator|new
name|RegexStringComparator
argument_list|(
name|regex
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Scanning partitions with prefix<"
operator|+
operator|new
name|String
argument_list|(
name|keyPrefix
argument_list|)
operator|+
literal|"> and filter<"
operator|+
name|regex
operator|+
literal|">"
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Partition
argument_list|>
name|parts
init|=
name|scanPartitionsWithFilter
argument_list|(
name|keyPrefix
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|maxPartitions
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|partCache
operator|.
name|put
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|parts
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|parts
return|;
block|}
comment|/**    * Delete a partition    * @param dbName database name that table is in    * @param tableName table partition is in    * @param partVals partition values that define this partition, in the same order as the    *                 partition columns they are values for    * @throws IOException    */
name|void
name|deletePartition
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partVals
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Find the partition so I can get the storage descriptor and drop it
name|partCache
operator|.
name|remove
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partVals
argument_list|)
expr_stmt|;
name|Partition
name|p
init|=
name|getPartition
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partVals
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|decrementStorageDescriptorRefCount
argument_list|(
name|p
operator|.
name|getSd
argument_list|()
argument_list|)
expr_stmt|;
name|byte
index|[]
name|key
init|=
name|buildPartitionKey
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partVals
argument_list|)
decl_stmt|;
name|delete
argument_list|(
name|PART_TABLE
argument_list|,
name|key
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**    * Fetch a role    * @param roleName name of the role    * @return role object, or null if no such role    * @throws IOException    */
name|Role
name|getRole
parameter_list|(
name|String
name|roleName
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|roleName
argument_list|)
decl_stmt|;
name|byte
index|[]
name|serialized
init|=
name|read
argument_list|(
name|ROLE_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|RoleWritable
name|role
init|=
operator|new
name|RoleWritable
argument_list|()
decl_stmt|;
name|HBaseUtils
operator|.
name|deserialize
argument_list|(
name|role
argument_list|,
name|serialized
argument_list|)
expr_stmt|;
return|return
name|role
operator|.
name|role
return|;
block|}
comment|/**    * Get a list of roles.    * @return list of all known roles.    * @throws IOException    */
name|List
argument_list|<
name|Role
argument_list|>
name|scanRoles
parameter_list|()
throws|throws
name|IOException
block|{
name|Iterator
argument_list|<
name|Result
argument_list|>
name|iter
init|=
name|scanWithFilter
argument_list|(
name|ROLE_TABLE
argument_list|,
literal|null
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Role
argument_list|>
name|roles
init|=
operator|new
name|ArrayList
argument_list|<
name|Role
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|RoleWritable
name|role
init|=
operator|new
name|RoleWritable
argument_list|()
decl_stmt|;
name|HBaseUtils
operator|.
name|deserialize
argument_list|(
name|role
argument_list|,
name|iter
operator|.
name|next
argument_list|()
operator|.
name|getValue
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
argument_list|)
expr_stmt|;
name|roles
operator|.
name|add
argument_list|(
name|role
operator|.
name|role
argument_list|)
expr_stmt|;
block|}
return|return
name|roles
return|;
block|}
comment|/**    * Add a new role    * @param role role object    * @throws IOException    */
name|void
name|putRole
parameter_list|(
name|Role
name|role
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|role
operator|.
name|getRoleName
argument_list|()
argument_list|)
decl_stmt|;
name|byte
index|[]
name|serialized
init|=
name|HBaseUtils
operator|.
name|serialize
argument_list|(
operator|new
name|RoleWritable
argument_list|(
name|role
argument_list|)
argument_list|)
decl_stmt|;
name|store
argument_list|(
name|ROLE_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|serialized
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**    * Drop a role    * @param roleName name of role to drop    * @throws IOException    */
name|void
name|deleteRole
parameter_list|(
name|String
name|roleName
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|roleName
argument_list|)
decl_stmt|;
name|delete
argument_list|(
name|ROLE_TABLE
argument_list|,
name|key
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**    * Fetch a table object    * @param dbName database the table is in    * @param tableName table name    * @return Table object, or null if no such table    * @throws IOException    */
name|Table
name|getTable
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getTable
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Fetch a list of table objects.    * @param dbName Database that all fetched tables are in    * @param tableNames list of table names    * @return list of tables, in the same order as the provided names.    * @throws IOException    */
name|List
argument_list|<
name|Table
argument_list|>
name|getTables
parameter_list|(
name|String
name|dbName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|tableNames
parameter_list|)
throws|throws
name|IOException
block|{
comment|// I could implement getTable in terms of this method.  But it is such a core function
comment|// that I don't want to slow it down for the much less common fetching of multiple tables.
name|List
argument_list|<
name|Table
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|Table
argument_list|>
argument_list|(
name|tableNames
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|ObjectPair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
index|[]
name|hashKeys
init|=
operator|new
name|ObjectPair
index|[
name|tableNames
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|boolean
name|atLeastOneMissing
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tableNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|hashKeys
index|[
name|i
index|]
operator|=
operator|new
name|ObjectPair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|dbName
argument_list|,
name|tableNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|// The result may be null, but we still want to add it so that we have a slot in the list
comment|// for it.
name|results
operator|.
name|add
argument_list|(
name|tableCache
operator|.
name|get
argument_list|(
name|hashKeys
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|==
literal|null
condition|)
name|atLeastOneMissing
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|atLeastOneMissing
condition|)
return|return
name|results
return|;
comment|// Now build a single get that will fetch the remaining tables
name|List
argument_list|<
name|Get
argument_list|>
name|gets
init|=
operator|new
name|ArrayList
argument_list|<
name|Get
argument_list|>
argument_list|()
decl_stmt|;
name|HTableInterface
name|htab
init|=
name|getHTable
argument_list|(
name|TABLE_TABLE
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tableNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|results
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|!=
literal|null
condition|)
continue|continue;
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|dbName
argument_list|,
name|tableNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|Get
name|g
init|=
operator|new
name|Get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|g
operator|.
name|addColumn
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
expr_stmt|;
name|gets
operator|.
name|add
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
name|Result
index|[]
name|res
init|=
name|htab
operator|.
name|get
argument_list|(
name|gets
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|nextGet
init|=
literal|0
init|;
name|i
operator|<
name|tableNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|results
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|!=
literal|null
condition|)
continue|continue;
name|byte
index|[]
name|serialized
init|=
name|res
index|[
name|nextGet
operator|++
index|]
operator|.
name|getValue
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|!=
literal|null
condition|)
block|{
name|TableWritable
name|table
init|=
operator|new
name|TableWritable
argument_list|()
decl_stmt|;
name|HBaseUtils
operator|.
name|deserialize
argument_list|(
name|table
argument_list|,
name|serialized
argument_list|)
expr_stmt|;
name|tableCache
operator|.
name|put
argument_list|(
name|hashKeys
index|[
name|i
index|]
argument_list|,
name|table
operator|.
name|table
argument_list|)
expr_stmt|;
name|results
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|table
operator|.
name|table
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|results
return|;
block|}
comment|/**    * Get a list of tables.    * @param dbName Database these tables are in    * @param regex Regular expression to use in searching for table names.  It is expected to    *              be a Java regular expression.  If it is null then all tables in the indicated    *              database will be returned.    * @return list of tables matching the regular expression.    * @throws IOException    */
name|List
argument_list|<
name|Table
argument_list|>
name|scanTables
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|regex
parameter_list|)
throws|throws
name|IOException
block|{
comment|// There's no way to know whether all the tables we are looking for are
comment|// in the cache, so we would need to scan one way or another.  Thus there's no value in hitting
comment|// the cache for this function.
name|Filter
name|filter
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|regex
operator|!=
literal|null
condition|)
block|{
name|filter
operator|=
operator|new
name|RowFilter
argument_list|(
name|CompareFilter
operator|.
name|CompareOp
operator|.
name|EQUAL
argument_list|,
operator|new
name|RegexStringComparator
argument_list|(
name|regex
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|keyPrefix
init|=
name|HBaseUtils
operator|.
name|buildKeyWithTrailingSeparator
argument_list|(
name|dbName
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Result
argument_list|>
name|iter
init|=
name|scanWithFilter
argument_list|(
name|TABLE_TABLE
argument_list|,
name|keyPrefix
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Table
argument_list|>
name|tables
init|=
operator|new
name|ArrayList
argument_list|<
name|Table
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|TableWritable
name|table
init|=
operator|new
name|TableWritable
argument_list|()
decl_stmt|;
name|HBaseUtils
operator|.
name|deserialize
argument_list|(
name|table
argument_list|,
name|iter
operator|.
name|next
argument_list|()
operator|.
name|getValue
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
argument_list|)
expr_stmt|;
name|tables
operator|.
name|add
argument_list|(
name|table
operator|.
name|table
argument_list|)
expr_stmt|;
block|}
return|return
name|tables
return|;
block|}
comment|/**    * Put a table object    * @param table table object    * @throws IOException    */
name|void
name|putTable
parameter_list|(
name|Table
name|table
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|table
operator|.
name|getDbName
argument_list|()
argument_list|,
name|table
operator|.
name|getTableName
argument_list|()
argument_list|)
decl_stmt|;
name|byte
index|[]
name|serialized
init|=
name|HBaseUtils
operator|.
name|serialize
argument_list|(
operator|new
name|TableWritable
argument_list|(
name|table
argument_list|)
argument_list|)
decl_stmt|;
name|store
argument_list|(
name|TABLE_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|serialized
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|tableCache
operator|.
name|put
argument_list|(
operator|new
name|ObjectPair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|table
operator|.
name|getDbName
argument_list|()
argument_list|,
name|table
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete a table    * @param dbName name of database table is in    * @param tableName table to drop    * @throws IOException    */
name|void
name|deleteTable
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|tableCache
operator|.
name|remove
argument_list|(
operator|new
name|ObjectPair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
comment|// Find the table so I can get the storage descriptor and drop it
name|Table
name|t
init|=
name|getTable
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|decrementStorageDescriptorRefCount
argument_list|(
name|t
operator|.
name|getSd
argument_list|()
argument_list|)
expr_stmt|;
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
name|delete
argument_list|(
name|TABLE_TABLE
argument_list|,
name|key
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**    * If this serde has already been read, then return it from the cache.  If not, read it, then    * return it.    * @param hash    * @return    * @throws IOException    */
name|StorageDescriptor
name|getStorageDescriptor
parameter_list|(
name|byte
index|[]
name|hash
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteArrayWrapper
name|hashKey
init|=
operator|new
name|ByteArrayWrapper
argument_list|(
name|hash
argument_list|)
decl_stmt|;
name|StorageDescriptor
name|cached
init|=
name|sdCache
operator|.
name|get
argument_list|(
name|hashKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|cached
operator|!=
literal|null
condition|)
return|return
name|cached
return|;
name|byte
index|[]
name|serialized
init|=
name|read
argument_list|(
name|SD_TABLE
argument_list|,
name|hash
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Woh, bad!  Trying to fetch a non-existent storage descriptor "
operator|+
literal|"from hash "
operator|+
name|hash
argument_list|)
throw|;
block|}
name|StorageDescriptor
name|sd
init|=
operator|new
name|StorageDescriptor
argument_list|()
decl_stmt|;
name|HBaseUtils
operator|.
name|deserializeStorageDescriptor
argument_list|(
name|sd
argument_list|,
name|serialized
argument_list|)
expr_stmt|;
name|sdCache
operator|.
name|put
argument_list|(
name|hashKey
argument_list|,
name|sd
argument_list|)
expr_stmt|;
return|return
name|sd
return|;
block|}
comment|/**    * Lower the reference count on the storage descriptor by one.  If it goes to zero, then it    * will be deleted.    * @param sd Storage descriptor    * @throws IOException    */
name|void
name|decrementStorageDescriptorRefCount
parameter_list|(
name|StorageDescriptor
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|serialized
init|=
name|HBaseUtils
operator|.
name|serializeStorageDescriptor
argument_list|(
name|sd
argument_list|)
decl_stmt|;
name|byte
index|[]
name|key
init|=
name|hash
argument_list|(
name|serialized
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|byte
index|[]
name|serializedRefCnt
init|=
name|read
argument_list|(
name|SD_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|REF_COUNT_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serializedRefCnt
operator|==
literal|null
condition|)
block|{
comment|// Someone deleted it before we got to it, no worries
return|return;
block|}
name|int
name|refCnt
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
operator|new
name|String
argument_list|(
name|serializedRefCnt
argument_list|,
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
argument_list|)
decl_stmt|;
name|HTableInterface
name|htab
init|=
name|getHTable
argument_list|(
name|SD_TABLE
argument_list|)
decl_stmt|;
if|if
condition|(
name|refCnt
operator|--
operator|<
literal|1
condition|)
block|{
name|Delete
name|d
init|=
operator|new
name|Delete
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|htab
operator|.
name|checkAndDelete
argument_list|(
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|REF_COUNT_COL
argument_list|,
name|serializedRefCnt
argument_list|,
name|d
argument_list|)
condition|)
block|{
name|sdCache
operator|.
name|remove
argument_list|(
operator|new
name|ByteArrayWrapper
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|Put
name|p
init|=
operator|new
name|Put
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|p
operator|.
name|add
argument_list|(
name|CATALOG_CF
argument_list|,
name|REF_COUNT_COL
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|refCnt
argument_list|)
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|.
name|checkAndPut
argument_list|(
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|REF_COUNT_COL
argument_list|,
name|serializedRefCnt
argument_list|,
name|p
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Too many unsuccessful attepts to decrement storage counter"
argument_list|)
throw|;
block|}
comment|/**    * Place the common parts of a storage descriptor into the cache.    * @param storageDescriptor storage descriptor to store.    * @return id of the entry in the cache, to be written in for the storage descriptor    */
name|byte
index|[]
name|putStorageDescriptor
parameter_list|(
name|StorageDescriptor
name|storageDescriptor
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|sd
init|=
name|HBaseUtils
operator|.
name|serializeStorageDescriptor
argument_list|(
name|storageDescriptor
argument_list|)
decl_stmt|;
name|byte
index|[]
name|key
init|=
name|hash
argument_list|(
name|sd
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|byte
index|[]
name|serializedRefCnt
init|=
name|read
argument_list|(
name|SD_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|REF_COUNT_COL
argument_list|)
decl_stmt|;
name|HTableInterface
name|htab
init|=
name|getHTable
argument_list|(
name|SD_TABLE
argument_list|)
decl_stmt|;
if|if
condition|(
name|serializedRefCnt
operator|==
literal|null
condition|)
block|{
comment|// We are the first to put it in the DB
name|Put
name|p
init|=
operator|new
name|Put
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|p
operator|.
name|add
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|p
operator|.
name|add
argument_list|(
name|CATALOG_CF
argument_list|,
name|REF_COUNT_COL
argument_list|,
literal|"0"
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|.
name|checkAndPut
argument_list|(
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|REF_COUNT_COL
argument_list|,
literal|null
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|sdCache
operator|.
name|put
argument_list|(
operator|new
name|ByteArrayWrapper
argument_list|(
name|key
argument_list|)
argument_list|,
name|storageDescriptor
argument_list|)
expr_stmt|;
return|return
name|key
return|;
block|}
block|}
else|else
block|{
comment|// Just increment the reference count
name|int
name|refCnt
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
operator|new
name|String
argument_list|(
name|serializedRefCnt
argument_list|,
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
argument_list|)
operator|+
literal|1
decl_stmt|;
name|Put
name|p
init|=
operator|new
name|Put
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|p
operator|.
name|add
argument_list|(
name|CATALOG_CF
argument_list|,
name|REF_COUNT_COL
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|refCnt
argument_list|)
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|.
name|checkAndPut
argument_list|(
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|REF_COUNT_COL
argument_list|,
name|serializedRefCnt
argument_list|,
name|p
argument_list|)
condition|)
block|{
return|return
name|key
return|;
block|}
block|}
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Too many unsuccessful attepts to increment storage counter"
argument_list|)
throw|;
block|}
comment|/**    * Update statistics for one or more columns for a table or a partition.    * @param dbName database the table is in    * @param tableName table to update statistics for    * @param partName name of the partition, can be null if these are table level statistics.    * @param partVals partition values that define partition to update statistics for.  If this is    *                 null, then these will be assumed to be table level statistics.    * @param stats Stats object with stats for one or more columns.    * @throws IOException    */
name|void
name|updateStatistics
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|partName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partVals
parameter_list|,
name|ColumnStatistics
name|stats
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|getStatisticsKey
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partVals
argument_list|)
decl_stmt|;
name|String
name|hbaseTable
init|=
name|getStatisticsTable
argument_list|(
name|partVals
argument_list|)
decl_stmt|;
name|byte
index|[]
index|[]
name|colnames
init|=
operator|new
name|byte
index|[
name|stats
operator|.
name|getStatsObjSize
argument_list|()
index|]
index|[]
decl_stmt|;
name|byte
index|[]
index|[]
name|serializeds
init|=
operator|new
name|byte
index|[
name|stats
operator|.
name|getStatsObjSize
argument_list|()
index|]
index|[]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stats
operator|.
name|getStatsObjSize
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ColumnStatisticsObj
name|obj
init|=
name|stats
operator|.
name|getStatsObj
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|serializeds
index|[
name|i
index|]
operator|=
name|HBaseUtils
operator|.
name|serializeStatsForOneColumn
argument_list|(
name|stats
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|String
name|colname
init|=
name|obj
operator|.
name|getColName
argument_list|()
decl_stmt|;
name|colnames
index|[
name|i
index|]
operator|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|colname
argument_list|)
expr_stmt|;
name|statsCache
operator|.
name|put
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partName
argument_list|,
name|colname
argument_list|,
name|obj
argument_list|,
name|stats
operator|.
name|getStatsDesc
argument_list|()
operator|.
name|getLastAnalyzed
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|store
argument_list|(
name|hbaseTable
argument_list|,
name|key
argument_list|,
name|STATS_CF
argument_list|,
name|colnames
argument_list|,
name|serializeds
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**    * Get Statistics for a table    * @param dbName name of database table is in    * @param tableName name of table    * @param colNames list of column names to get statistics for    * @return column statistics for indicated table    * @throws IOException    */
name|ColumnStatistics
name|getTableStatistics
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
name|ColumnStatistics
name|stats
init|=
operator|new
name|ColumnStatistics
argument_list|()
decl_stmt|;
name|ColumnStatisticsDesc
name|desc
init|=
operator|new
name|ColumnStatisticsDesc
argument_list|()
decl_stmt|;
name|desc
operator|.
name|setIsTblLevel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|desc
operator|.
name|setDbName
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|desc
operator|.
name|setTableName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setStatsDesc
argument_list|(
name|desc
argument_list|)
expr_stmt|;
comment|// First we have to go through and see what's in the cache and fetch what we can from there.
comment|// Then we'll fetch the rest from HBase
name|List
argument_list|<
name|String
argument_list|>
name|stillLookingFor
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|colNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|StatsCache
operator|.
name|StatsInfo
name|info
init|=
name|statsCache
operator|.
name|getTableStatistics
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|colNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
name|stillLookingFor
operator|.
name|add
argument_list|(
name|colNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|info
operator|.
name|stats
operator|.
name|setColName
argument_list|(
name|colNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|stats
operator|.
name|addToStatsObj
argument_list|(
name|info
operator|.
name|stats
argument_list|)
expr_stmt|;
name|stats
operator|.
name|getStatsDesc
argument_list|()
operator|.
name|setLastAnalyzed
argument_list|(
name|Math
operator|.
name|max
argument_list|(
name|stats
operator|.
name|getStatsDesc
argument_list|()
operator|.
name|getLastAnalyzed
argument_list|()
argument_list|,
name|info
operator|.
name|lastAnalyzed
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stillLookingFor
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
name|stats
return|;
name|byte
index|[]
index|[]
name|colKeys
init|=
operator|new
name|byte
index|[
name|stillLookingFor
operator|.
name|size
argument_list|()
index|]
index|[]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|colKeys
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|colKeys
index|[
name|i
index|]
operator|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|stillLookingFor
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Result
name|res
init|=
name|read
argument_list|(
name|TABLE_TABLE
argument_list|,
name|key
argument_list|,
name|STATS_CF
argument_list|,
name|colKeys
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|colKeys
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|byte
index|[]
name|serialized
init|=
name|res
operator|.
name|getValue
argument_list|(
name|STATS_CF
argument_list|,
name|colKeys
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|==
literal|null
condition|)
block|{
comment|// There were no stats for this column, so skip it
continue|continue;
block|}
name|ColumnStatisticsObj
name|obj
init|=
name|HBaseUtils
operator|.
name|deserializeStatsForOneColumn
argument_list|(
name|stats
argument_list|,
name|serialized
argument_list|)
decl_stmt|;
name|statsCache
operator|.
name|put
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
literal|null
argument_list|,
name|stillLookingFor
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|obj
argument_list|,
name|stats
operator|.
name|getStatsDesc
argument_list|()
operator|.
name|getLastAnalyzed
argument_list|()
argument_list|)
expr_stmt|;
name|obj
operator|.
name|setColName
argument_list|(
name|stillLookingFor
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|stats
operator|.
name|addToStatsObj
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
return|return
name|stats
return|;
block|}
comment|/**    * Get statistics for a set of partitions    * @param dbName name of database table is in    * @param tableName table partitions are in    * @param partNames names of the partitions, used only to set values inside the return stats    *                  objects.    * @param partVals partition values for each partition, needed because this class doesn't know    *                 how to translate from partName to partVals    * @param colNames column names to fetch stats for.  These columns will be fetched for all    *                 requested partitions.    * @return list of ColumnStats, one for each partition.  The values will be in the same order    * as the partNames list that was passed in.    * @throws IOException    */
name|List
argument_list|<
name|ColumnStatistics
argument_list|>
name|getPartitionStatistics
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|,
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|partVals
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Go through the cache first, see what we can fetch from there.  This is complicated because
comment|// we may have different columns for different partitions
name|List
argument_list|<
name|ColumnStatistics
argument_list|>
name|statsList
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnStatistics
argument_list|>
argument_list|(
name|partNames
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|PartStatsInfo
argument_list|>
name|stillLookingFor
init|=
operator|new
name|ArrayList
argument_list|<
name|PartStatsInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pOff
init|=
literal|0
init|;
name|pOff
operator|<
name|partVals
operator|.
name|size
argument_list|()
condition|;
name|pOff
operator|++
control|)
block|{
comment|// Add an entry for this partition in the list
name|ColumnStatistics
name|stats
init|=
operator|new
name|ColumnStatistics
argument_list|()
decl_stmt|;
name|ColumnStatisticsDesc
name|desc
init|=
operator|new
name|ColumnStatisticsDesc
argument_list|()
decl_stmt|;
name|desc
operator|.
name|setIsTblLevel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|desc
operator|.
name|setDbName
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|desc
operator|.
name|setTableName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|desc
operator|.
name|setPartName
argument_list|(
name|partNames
operator|.
name|get
argument_list|(
name|pOff
argument_list|)
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setStatsDesc
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|statsList
operator|.
name|add
argument_list|(
name|stats
argument_list|)
expr_stmt|;
name|PartStatsInfo
name|missing
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|cOff
init|=
literal|0
init|;
name|cOff
operator|<
name|colNames
operator|.
name|size
argument_list|()
condition|;
name|cOff
operator|++
control|)
block|{
name|StatsCache
operator|.
name|StatsInfo
name|info
init|=
name|statsCache
operator|.
name|getPartitionStatistics
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
operator|.
name|get
argument_list|(
name|pOff
argument_list|)
argument_list|,
name|colNames
operator|.
name|get
argument_list|(
name|cOff
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|missing
operator|==
literal|null
condition|)
block|{
comment|// We haven't started an entry for this one yet
name|missing
operator|=
operator|new
name|PartStatsInfo
argument_list|(
name|stats
argument_list|,
name|partVals
operator|.
name|get
argument_list|(
name|pOff
argument_list|)
argument_list|,
name|partNames
operator|.
name|get
argument_list|(
name|pOff
argument_list|)
argument_list|)
expr_stmt|;
name|stillLookingFor
operator|.
name|add
argument_list|(
name|missing
argument_list|)
expr_stmt|;
block|}
name|missing
operator|.
name|colNames
operator|.
name|add
argument_list|(
name|colNames
operator|.
name|get
argument_list|(
name|cOff
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|info
operator|.
name|stats
operator|.
name|setColName
argument_list|(
name|colNames
operator|.
name|get
argument_list|(
name|cOff
argument_list|)
argument_list|)
expr_stmt|;
name|stats
operator|.
name|addToStatsObj
argument_list|(
name|info
operator|.
name|stats
argument_list|)
expr_stmt|;
name|stats
operator|.
name|getStatsDesc
argument_list|()
operator|.
name|setLastAnalyzed
argument_list|(
name|Math
operator|.
name|max
argument_list|(
name|stats
operator|.
name|getStatsDesc
argument_list|()
operator|.
name|getLastAnalyzed
argument_list|()
argument_list|,
name|info
operator|.
name|lastAnalyzed
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|stillLookingFor
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
name|statsList
return|;
comment|// Build the list of gets. It may be different for each partition now depending on what we
comment|// found in the cache.
name|List
argument_list|<
name|Get
argument_list|>
name|gets
init|=
operator|new
name|ArrayList
argument_list|<
name|Get
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|PartStatsInfo
name|pi
range|:
name|stillLookingFor
control|)
block|{
name|byte
index|[]
index|[]
name|colKeys
init|=
operator|new
name|byte
index|[
name|pi
operator|.
name|colNames
operator|.
name|size
argument_list|()
index|]
index|[]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|colKeys
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|colKeys
index|[
name|i
index|]
operator|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|pi
operator|.
name|colNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pi
operator|.
name|colKeys
operator|=
name|colKeys
expr_stmt|;
name|byte
index|[]
name|key
init|=
name|buildPartitionKey
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|pi
operator|.
name|partVals
argument_list|)
decl_stmt|;
name|Get
name|g
init|=
operator|new
name|Get
argument_list|(
name|key
argument_list|)
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|colName
range|:
name|colKeys
control|)
name|g
operator|.
name|addColumn
argument_list|(
name|STATS_CF
argument_list|,
name|colName
argument_list|)
expr_stmt|;
name|gets
operator|.
name|add
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
name|HTableInterface
name|htab
init|=
name|getHTable
argument_list|(
name|PART_TABLE
argument_list|)
decl_stmt|;
name|Result
index|[]
name|results
init|=
name|htab
operator|.
name|get
argument_list|(
name|gets
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|pOff
init|=
literal|0
init|;
name|pOff
operator|<
name|results
operator|.
name|length
condition|;
name|pOff
operator|++
control|)
block|{
name|PartStatsInfo
name|pi
init|=
name|stillLookingFor
operator|.
name|get
argument_list|(
name|pOff
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|cOff
init|=
literal|0
init|;
name|cOff
operator|<
name|pi
operator|.
name|colNames
operator|.
name|size
argument_list|()
condition|;
name|cOff
operator|++
control|)
block|{
name|byte
index|[]
name|serialized
init|=
name|results
index|[
name|pOff
index|]
operator|.
name|getValue
argument_list|(
name|STATS_CF
argument_list|,
name|pi
operator|.
name|colKeys
index|[
name|cOff
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|==
literal|null
condition|)
block|{
comment|// There were no stats for this column, so skip it
continue|continue;
block|}
name|ColumnStatisticsObj
name|obj
init|=
name|HBaseUtils
operator|.
name|deserializeStatsForOneColumn
argument_list|(
name|pi
operator|.
name|stats
argument_list|,
name|serialized
argument_list|)
decl_stmt|;
name|statsCache
operator|.
name|put
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|pi
operator|.
name|partName
argument_list|,
name|pi
operator|.
name|colNames
operator|.
name|get
argument_list|(
name|cOff
argument_list|)
argument_list|,
name|obj
argument_list|,
name|pi
operator|.
name|stats
operator|.
name|getStatsDesc
argument_list|()
operator|.
name|getLastAnalyzed
argument_list|()
argument_list|)
expr_stmt|;
name|obj
operator|.
name|setColName
argument_list|(
name|pi
operator|.
name|colNames
operator|.
name|get
argument_list|(
name|cOff
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|.
name|stats
operator|.
name|addToStatsObj
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|statsList
return|;
block|}
comment|/**    * This should be called whenever a new query is started.    */
name|void
name|flushCatalogCache
parameter_list|()
block|{
for|for
control|(
name|Counter
name|counter
range|:
name|counters
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|counter
operator|.
name|dump
argument_list|()
argument_list|)
expr_stmt|;
name|counter
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|tableCache
operator|.
name|flush
argument_list|()
expr_stmt|;
name|sdCache
operator|.
name|flush
argument_list|()
expr_stmt|;
name|partCache
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
name|int
name|countStorageDescriptor
parameter_list|()
throws|throws
name|IOException
block|{
name|ResultScanner
name|scanner
init|=
name|getHTable
argument_list|(
name|SD_TABLE
argument_list|)
operator|.
name|getScanner
argument_list|(
operator|new
name|Scan
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|scanner
operator|.
name|next
argument_list|()
operator|!=
literal|null
condition|)
name|cnt
operator|++
expr_stmt|;
return|return
name|cnt
return|;
block|}
specifier|private
name|Table
name|getTable
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|boolean
name|populateCache
parameter_list|)
throws|throws
name|IOException
block|{
name|ObjectPair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|hashKey
init|=
operator|new
name|ObjectPair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
name|Table
name|cached
init|=
name|tableCache
operator|.
name|get
argument_list|(
name|hashKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|cached
operator|!=
literal|null
condition|)
return|return
name|cached
return|;
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
name|byte
index|[]
name|serialized
init|=
name|read
argument_list|(
name|TABLE_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|TableWritable
name|table
init|=
operator|new
name|TableWritable
argument_list|()
decl_stmt|;
name|HBaseUtils
operator|.
name|deserialize
argument_list|(
name|table
argument_list|,
name|serialized
argument_list|)
expr_stmt|;
if|if
condition|(
name|populateCache
condition|)
name|tableCache
operator|.
name|put
argument_list|(
name|hashKey
argument_list|,
name|table
operator|.
name|table
argument_list|)
expr_stmt|;
return|return
name|table
operator|.
name|table
return|;
block|}
specifier|private
name|Partition
name|getPartition
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partVals
parameter_list|,
name|boolean
name|populateCache
parameter_list|)
throws|throws
name|IOException
block|{
name|Partition
name|cached
init|=
name|partCache
operator|.
name|get
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partVals
argument_list|)
decl_stmt|;
if|if
condition|(
name|cached
operator|!=
literal|null
condition|)
return|return
name|cached
return|;
name|byte
index|[]
name|key
init|=
name|buildPartitionKey
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partVals
argument_list|)
decl_stmt|;
name|byte
index|[]
name|serialized
init|=
name|read
argument_list|(
name|PART_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|PartitionWritable
name|part
init|=
operator|new
name|PartitionWritable
argument_list|()
decl_stmt|;
name|HBaseUtils
operator|.
name|deserialize
argument_list|(
name|part
argument_list|,
name|serialized
argument_list|)
expr_stmt|;
if|if
condition|(
name|populateCache
condition|)
name|partCache
operator|.
name|put
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|part
operator|.
name|part
argument_list|)
expr_stmt|;
return|return
name|part
operator|.
name|part
return|;
block|}
specifier|private
name|void
name|store
parameter_list|(
name|String
name|table
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|byte
index|[]
name|colFam
parameter_list|,
name|byte
index|[]
name|colName
parameter_list|,
name|byte
index|[]
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableInterface
name|htab
init|=
name|getHTable
argument_list|(
name|table
argument_list|)
decl_stmt|;
name|Put
name|p
init|=
operator|new
name|Put
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|p
operator|.
name|add
argument_list|(
name|colFam
argument_list|,
name|colName
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|htab
operator|.
name|put
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|store
parameter_list|(
name|String
name|table
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|byte
index|[]
name|colFam
parameter_list|,
name|byte
index|[]
index|[]
name|colName
parameter_list|,
name|byte
index|[]
index|[]
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableInterface
name|htab
init|=
name|getHTable
argument_list|(
name|table
argument_list|)
decl_stmt|;
name|Put
name|p
init|=
operator|new
name|Put
argument_list|(
name|key
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|colName
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|.
name|add
argument_list|(
name|colFam
argument_list|,
name|colName
index|[
name|i
index|]
argument_list|,
name|obj
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|htab
operator|.
name|put
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
specifier|private
name|byte
index|[]
name|read
parameter_list|(
name|String
name|table
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|byte
index|[]
name|colFam
parameter_list|,
name|byte
index|[]
name|colName
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableInterface
name|htab
init|=
name|getHTable
argument_list|(
name|table
argument_list|)
decl_stmt|;
name|Get
name|g
init|=
operator|new
name|Get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|g
operator|.
name|addColumn
argument_list|(
name|colFam
argument_list|,
name|colName
argument_list|)
expr_stmt|;
name|Result
name|res
init|=
name|htab
operator|.
name|get
argument_list|(
name|g
argument_list|)
decl_stmt|;
return|return
name|res
operator|.
name|getValue
argument_list|(
name|colFam
argument_list|,
name|colName
argument_list|)
return|;
block|}
specifier|private
name|Result
name|read
parameter_list|(
name|String
name|table
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|byte
index|[]
name|colFam
parameter_list|,
name|byte
index|[]
index|[]
name|colNames
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableInterface
name|htab
init|=
name|getHTable
argument_list|(
name|table
argument_list|)
decl_stmt|;
name|Get
name|g
init|=
operator|new
name|Get
argument_list|(
name|key
argument_list|)
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|colName
range|:
name|colNames
control|)
name|g
operator|.
name|addColumn
argument_list|(
name|colFam
argument_list|,
name|colName
argument_list|)
expr_stmt|;
return|return
name|htab
operator|.
name|get
argument_list|(
name|g
argument_list|)
return|;
block|}
comment|// Delete a row.  If colFam and colName are not null, then only the named column will be
comment|// deleted.  If colName is null and colFam is not, only the named family will be deleted.  If
comment|// both are null the entire row will be deleted.
specifier|private
name|void
name|delete
parameter_list|(
name|String
name|table
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|byte
index|[]
name|colFam
parameter_list|,
name|byte
index|[]
name|colName
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableInterface
name|htab
init|=
name|getHTable
argument_list|(
name|table
argument_list|)
decl_stmt|;
name|Delete
name|d
init|=
operator|new
name|Delete
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|colName
operator|!=
literal|null
condition|)
name|d
operator|.
name|deleteColumn
argument_list|(
name|colFam
argument_list|,
name|colName
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|colFam
operator|!=
literal|null
condition|)
name|d
operator|.
name|deleteFamily
argument_list|(
name|colFam
argument_list|)
expr_stmt|;
name|htab
operator|.
name|delete
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
specifier|private
name|List
argument_list|<
name|Partition
argument_list|>
name|scanPartitions
parameter_list|(
name|byte
index|[]
name|keyPrefix
parameter_list|,
name|byte
index|[]
name|colFam
parameter_list|,
name|byte
index|[]
name|colName
parameter_list|,
name|int
name|maxResults
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|scanPartitionsWithFilter
argument_list|(
name|keyPrefix
argument_list|,
name|colFam
argument_list|,
name|colName
argument_list|,
name|maxResults
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|private
name|List
argument_list|<
name|Partition
argument_list|>
name|scanPartitionsWithFilter
parameter_list|(
name|byte
index|[]
name|keyPrefix
parameter_list|,
name|byte
index|[]
name|colFam
parameter_list|,
name|byte
index|[]
name|colName
parameter_list|,
name|int
name|maxResults
parameter_list|,
name|Filter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|Iterator
argument_list|<
name|Result
argument_list|>
name|iter
init|=
name|scanWithFilter
argument_list|(
name|PART_TABLE
argument_list|,
name|keyPrefix
argument_list|,
name|colFam
argument_list|,
name|colName
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Partition
argument_list|>
name|parts
init|=
operator|new
name|ArrayList
argument_list|<
name|Partition
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|numToFetch
init|=
name|maxResults
operator|<
literal|0
condition|?
name|Integer
operator|.
name|MAX_VALUE
else|:
name|maxResults
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numToFetch
operator|&&
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|PartitionWritable
name|p
init|=
operator|new
name|PartitionWritable
argument_list|()
decl_stmt|;
name|HBaseUtils
operator|.
name|deserialize
argument_list|(
name|p
argument_list|,
name|iter
operator|.
name|next
argument_list|()
operator|.
name|getValue
argument_list|(
name|colFam
argument_list|,
name|colName
argument_list|)
argument_list|)
expr_stmt|;
name|parts
operator|.
name|add
argument_list|(
name|p
operator|.
name|part
argument_list|)
expr_stmt|;
block|}
return|return
name|parts
return|;
block|}
specifier|private
name|Iterator
argument_list|<
name|Result
argument_list|>
name|scanWithFilter
parameter_list|(
name|String
name|table
parameter_list|,
name|byte
index|[]
name|keyPrefix
parameter_list|,
name|byte
index|[]
name|colFam
parameter_list|,
name|byte
index|[]
name|colName
parameter_list|,
name|Filter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableInterface
name|htab
init|=
name|getHTable
argument_list|(
name|table
argument_list|)
decl_stmt|;
name|Scan
name|s
decl_stmt|;
if|if
condition|(
name|keyPrefix
operator|==
literal|null
condition|)
block|{
name|s
operator|=
operator|new
name|Scan
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|byte
index|[]
name|stop
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|keyPrefix
argument_list|,
name|keyPrefix
operator|.
name|length
argument_list|)
decl_stmt|;
name|stop
index|[
name|stop
operator|.
name|length
operator|-
literal|1
index|]
operator|++
expr_stmt|;
name|s
operator|=
operator|new
name|Scan
argument_list|(
name|keyPrefix
argument_list|,
name|stop
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|addColumn
argument_list|(
name|colFam
argument_list|,
name|colName
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter
operator|!=
literal|null
condition|)
name|s
operator|.
name|setFilter
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|ResultScanner
name|scanner
init|=
name|htab
operator|.
name|getScanner
argument_list|(
name|s
argument_list|)
decl_stmt|;
return|return
name|scanner
operator|.
name|iterator
argument_list|()
return|;
block|}
specifier|private
name|HTableInterface
name|getHTable
parameter_list|(
name|String
name|table
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableInterface
name|htab
init|=
name|tables
operator|.
name|get
argument_list|(
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
name|htab
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying to connect to table "
operator|+
name|table
argument_list|)
expr_stmt|;
try|try
block|{
name|htab
operator|=
name|conn
operator|.
name|getTable
argument_list|(
name|table
argument_list|)
expr_stmt|;
comment|// Calling gettable doesn't actually connect to the region server, it's very light
comment|// weight, so call something else so we actually reach out and touch the region server
comment|// and see if the table is there.
name|Result
name|r
init|=
name|htab
operator|.
name|get
argument_list|(
operator|new
name|Get
argument_list|(
literal|"nosuchkey"
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Caught exception when table was missing"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|htab
operator|.
name|setAutoFlushTo
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|tables
operator|.
name|put
argument_list|(
name|table
argument_list|,
name|htab
argument_list|)
expr_stmt|;
block|}
return|return
name|htab
return|;
block|}
specifier|private
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|HTableInterface
name|htab
range|:
name|tables
operator|.
name|values
argument_list|()
control|)
name|htab
operator|.
name|flushCommits
argument_list|()
expr_stmt|;
block|}
specifier|private
name|byte
index|[]
name|buildPartitionKey
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partVals
parameter_list|)
block|{
name|Deque
argument_list|<
name|String
argument_list|>
name|keyParts
init|=
operator|new
name|ArrayDeque
argument_list|<
name|String
argument_list|>
argument_list|(
name|partVals
argument_list|)
decl_stmt|;
name|keyParts
operator|.
name|addFirst
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|keyParts
operator|.
name|addFirst
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
return|return
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|keyParts
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|keyParts
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|byte
index|[]
name|buildPartitionKey
parameter_list|(
name|PartitionWritable
name|part
parameter_list|)
throws|throws
name|IOException
block|{
name|Deque
argument_list|<
name|String
argument_list|>
name|keyParts
init|=
operator|new
name|ArrayDeque
argument_list|<
name|String
argument_list|>
argument_list|(
name|part
operator|.
name|part
operator|.
name|getValues
argument_list|()
argument_list|)
decl_stmt|;
name|keyParts
operator|.
name|addFirst
argument_list|(
name|part
operator|.
name|part
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
name|keyParts
operator|.
name|addFirst
argument_list|(
name|part
operator|.
name|part
operator|.
name|getDbName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|keyParts
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|keyParts
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|byte
index|[]
name|hash
parameter_list|(
name|byte
index|[]
name|serialized
parameter_list|)
throws|throws
name|IOException
block|{
name|md
operator|.
name|update
argument_list|(
name|serialized
argument_list|)
expr_stmt|;
return|return
name|md
operator|.
name|digest
argument_list|()
return|;
block|}
specifier|private
name|byte
index|[]
name|getStatisticsKey
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partVals
parameter_list|)
block|{
return|return
name|partVals
operator|==
literal|null
condition|?
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
else|:
name|buildPartitionKey
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partVals
argument_list|)
return|;
block|}
specifier|private
name|String
name|getStatisticsTable
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|partVals
parameter_list|)
block|{
return|return
name|partVals
operator|==
literal|null
condition|?
name|TABLE_TABLE
else|:
name|PART_TABLE
return|;
block|}
comment|/**    * Use this for unit testing only, so that a mock connection object can be passed in.    * @param connection Mock connection objecct    */
annotation|@
name|VisibleForTesting
name|void
name|setConnection
parameter_list|(
name|HConnection
name|connection
parameter_list|)
block|{
name|conn
operator|=
name|connection
expr_stmt|;
block|}
specifier|private
specifier|static
class|class
name|ByteArrayWrapper
block|{
name|byte
index|[]
name|wrapped
decl_stmt|;
name|ByteArrayWrapper
parameter_list|(
name|byte
index|[]
name|b
parameter_list|)
block|{
name|wrapped
operator|=
name|b
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|instanceof
name|ByteArrayWrapper
condition|)
block|{
return|return
name|Arrays
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteArrayWrapper
operator|)
name|other
operator|)
operator|.
name|wrapped
argument_list|,
name|wrapped
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Arrays
operator|.
name|hashCode
argument_list|(
name|wrapped
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|PartStatsInfo
block|{
name|ColumnStatistics
name|stats
decl_stmt|;
name|String
name|partName
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|colNames
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|partVals
decl_stmt|;
name|byte
index|[]
index|[]
name|colKeys
decl_stmt|;
name|PartStatsInfo
parameter_list|(
name|ColumnStatistics
name|s
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|pv
parameter_list|,
name|String
name|pn
parameter_list|)
block|{
name|stats
operator|=
name|s
expr_stmt|;
name|partVals
operator|=
name|pv
expr_stmt|;
name|partName
operator|=
name|pn
expr_stmt|;
name|colNames
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|colKeys
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// For testing without the cache
specifier|private
specifier|static
class|class
name|BogusObjectCache
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ObjectCache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
specifier|static
name|Counter
name|bogus
init|=
operator|new
name|Counter
argument_list|(
literal|"bogus"
argument_list|)
decl_stmt|;
name|BogusObjectCache
parameter_list|()
block|{
name|super
argument_list|(
literal|1
argument_list|,
name|bogus
argument_list|,
name|bogus
argument_list|,
name|bogus
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|V
name|get
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|BogusPartitionCache
extends|extends
name|PartitionCache
block|{
specifier|static
name|Counter
name|bogus
init|=
operator|new
name|Counter
argument_list|(
literal|"bogus"
argument_list|)
decl_stmt|;
name|BogusPartitionCache
parameter_list|()
block|{
name|super
argument_list|(
literal|1
argument_list|,
name|bogus
argument_list|,
name|bogus
argument_list|,
name|bogus
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|Collection
argument_list|<
name|Partition
argument_list|>
name|getAllForTable
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
name|Partition
name|get
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partVals
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
end_class

end_unit

