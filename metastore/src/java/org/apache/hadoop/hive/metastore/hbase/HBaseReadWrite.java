begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|codec
operator|.
name|binary
operator|.
name|Base64
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|ArrayUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Delete
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Get
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|HTableInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Put
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ResultScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Row
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Scan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|CompareFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|RegexStringComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|RowFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
operator|.
name|MultiRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ObjectPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|AggrStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ColumnStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ColumnStatisticsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ColumnStatisticsObj
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Database
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|NoSuchObjectException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Partition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|PrincipalPrivilegeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|PrincipalType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Role
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|StorageDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|hbase
operator|.
name|PartitionKeyComparator
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|common
operator|.
name|util
operator|.
name|BloomFilter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|MessageDigest
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchAlgorithmException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * Class to manage storing object in and reading them from HBase.  */
end_comment

begin_class
specifier|public
class|class
name|HBaseReadWrite
block|{
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|String
name|AGGR_STATS_TABLE
init|=
literal|"HBMS_AGGR_STATS"
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|String
name|DB_TABLE
init|=
literal|"HBMS_DBS"
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|String
name|FUNC_TABLE
init|=
literal|"HBMS_FUNCS"
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|String
name|GLOBAL_PRIVS_TABLE
init|=
literal|"HBMS_GLOBAL_PRIVS"
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|String
name|PART_TABLE
init|=
literal|"HBMS_PARTITIONS"
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|String
name|ROLE_TABLE
init|=
literal|"HBMS_ROLES"
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|String
name|SD_TABLE
init|=
literal|"HBMS_SDS"
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|String
name|SECURITY_TABLE
init|=
literal|"HBMS_SECURITY"
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|String
name|SEQUENCES_TABLE
init|=
literal|"HBMS_SEQUENCES"
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|String
name|TABLE_TABLE
init|=
literal|"HBMS_TBLS"
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|String
name|USER_TO_ROLE_TABLE
init|=
literal|"HBMS_USER_TO_ROLE"
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|String
name|FILE_METADATA_TABLE
init|=
literal|"HBMS_FILE_METADATA"
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|byte
index|[]
name|CATALOG_CF
init|=
literal|"c"
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|byte
index|[]
name|STATS_CF
init|=
literal|"s"
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|String
name|NO_CACHE_CONF
init|=
literal|"no.use.cache"
decl_stmt|;
comment|/**    * List of tables in HBase    */
specifier|public
specifier|final
specifier|static
name|String
index|[]
name|tableNames
init|=
block|{
name|AGGR_STATS_TABLE
block|,
name|DB_TABLE
block|,
name|FUNC_TABLE
block|,
name|GLOBAL_PRIVS_TABLE
block|,
name|PART_TABLE
block|,
name|USER_TO_ROLE_TABLE
block|,
name|ROLE_TABLE
block|,
name|SD_TABLE
block|,
name|SECURITY_TABLE
block|,
name|SEQUENCES_TABLE
block|,
name|TABLE_TABLE
block|,
name|FILE_METADATA_TABLE
block|}
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|>
name|columnFamilies
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|>
argument_list|(
name|tableNames
operator|.
name|length
argument_list|)
decl_stmt|;
static|static
block|{
name|columnFamilies
operator|.
name|put
argument_list|(
name|AGGR_STATS_TABLE
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|CATALOG_CF
argument_list|)
argument_list|)
expr_stmt|;
name|columnFamilies
operator|.
name|put
argument_list|(
name|DB_TABLE
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|CATALOG_CF
argument_list|)
argument_list|)
expr_stmt|;
name|columnFamilies
operator|.
name|put
argument_list|(
name|FUNC_TABLE
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|CATALOG_CF
argument_list|)
argument_list|)
expr_stmt|;
name|columnFamilies
operator|.
name|put
argument_list|(
name|GLOBAL_PRIVS_TABLE
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|CATALOG_CF
argument_list|)
argument_list|)
expr_stmt|;
name|columnFamilies
operator|.
name|put
argument_list|(
name|PART_TABLE
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|CATALOG_CF
argument_list|,
name|STATS_CF
argument_list|)
argument_list|)
expr_stmt|;
name|columnFamilies
operator|.
name|put
argument_list|(
name|USER_TO_ROLE_TABLE
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|CATALOG_CF
argument_list|)
argument_list|)
expr_stmt|;
name|columnFamilies
operator|.
name|put
argument_list|(
name|ROLE_TABLE
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|CATALOG_CF
argument_list|)
argument_list|)
expr_stmt|;
name|columnFamilies
operator|.
name|put
argument_list|(
name|SD_TABLE
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|CATALOG_CF
argument_list|)
argument_list|)
expr_stmt|;
name|columnFamilies
operator|.
name|put
argument_list|(
name|SECURITY_TABLE
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|CATALOG_CF
argument_list|)
argument_list|)
expr_stmt|;
name|columnFamilies
operator|.
name|put
argument_list|(
name|SEQUENCES_TABLE
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|CATALOG_CF
argument_list|)
argument_list|)
expr_stmt|;
name|columnFamilies
operator|.
name|put
argument_list|(
name|TABLE_TABLE
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|CATALOG_CF
argument_list|,
name|STATS_CF
argument_list|)
argument_list|)
expr_stmt|;
comment|// Stats CF will contain PPD stats.
name|columnFamilies
operator|.
name|put
argument_list|(
name|FILE_METADATA_TABLE
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|CATALOG_CF
argument_list|,
name|STATS_CF
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Stores the bloom filter for the aggregated stats, to determine what partitions are in this    * aggregate.    */
specifier|final
specifier|static
name|byte
index|[]
name|MASTER_KEY_SEQUENCE
init|=
literal|"mk"
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
decl_stmt|;
specifier|final
specifier|static
name|byte
index|[]
name|AGGR_STATS_BLOOM_COL
init|=
literal|"b"
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|byte
index|[]
name|CATALOG_COL
init|=
literal|"c"
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|byte
index|[]
name|ROLES_COL
init|=
literal|"roles"
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|byte
index|[]
name|REF_COUNT_COL
init|=
literal|"ref"
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|byte
index|[]
name|DELEGATION_TOKEN_COL
init|=
literal|"dt"
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|byte
index|[]
name|MASTER_KEY_COL
init|=
literal|"mk"
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|byte
index|[]
name|AGGR_STATS_STATS_COL
init|=
literal|"s"
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|byte
index|[]
name|GLOBAL_PRIVS_KEY
init|=
literal|"gp"
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|byte
index|[]
name|SEQUENCES_KEY
init|=
literal|"seq"
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|int
name|TABLES_TO_CACHE
init|=
literal|10
decl_stmt|;
comment|// False positives are very bad here because they cause us to invalidate entries we shouldn't.
comment|// Space used and # of hash functions grows in proportion to ln of num bits so a 10x increase
comment|// in accuracy doubles the required space and number of hash functions.
specifier|private
specifier|final
specifier|static
name|double
name|STATS_BF_ERROR_RATE
init|=
literal|0.001
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
specifier|static
name|String
name|TEST_CONN
init|=
literal|"test_connection"
decl_stmt|;
specifier|private
specifier|static
name|HBaseConnection
name|testConn
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HBaseReadWrite
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|ThreadLocal
argument_list|<
name|HBaseReadWrite
argument_list|>
name|self
init|=
operator|new
name|ThreadLocal
argument_list|<
name|HBaseReadWrite
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|HBaseReadWrite
name|initialValue
parameter_list|()
block|{
if|if
condition|(
name|staticConf
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Attempt to create HBaseReadWrite with no configuration set"
argument_list|)
throw|;
block|}
return|return
operator|new
name|HBaseReadWrite
argument_list|(
name|staticConf
argument_list|)
return|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|static
name|boolean
name|tablesCreated
init|=
literal|false
decl_stmt|;
specifier|private
specifier|static
name|Configuration
name|staticConf
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
specifier|private
name|HBaseConnection
name|conn
decl_stmt|;
specifier|private
name|MessageDigest
name|md
decl_stmt|;
specifier|private
name|ObjectCache
argument_list|<
name|ObjectPair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|,
name|Table
argument_list|>
name|tableCache
decl_stmt|;
specifier|private
name|ObjectCache
argument_list|<
name|ByteArrayWrapper
argument_list|,
name|StorageDescriptor
argument_list|>
name|sdCache
decl_stmt|;
specifier|private
name|PartitionCache
name|partCache
decl_stmt|;
specifier|private
name|StatsCache
name|statsCache
decl_stmt|;
specifier|private
name|Counter
name|tableHits
decl_stmt|;
specifier|private
name|Counter
name|tableMisses
decl_stmt|;
specifier|private
name|Counter
name|tableOverflows
decl_stmt|;
specifier|private
name|Counter
name|partHits
decl_stmt|;
specifier|private
name|Counter
name|partMisses
decl_stmt|;
specifier|private
name|Counter
name|partOverflows
decl_stmt|;
specifier|private
name|Counter
name|sdHits
decl_stmt|;
specifier|private
name|Counter
name|sdMisses
decl_stmt|;
specifier|private
name|Counter
name|sdOverflows
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Counter
argument_list|>
name|counters
decl_stmt|;
comment|// roleCache doesn't use ObjectCache because I don't want to limit the size.  I am assuming
comment|// that the number of roles will always be small (< 100) so caching the whole thing should not
comment|// be painful.
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfoList
argument_list|>
name|roleCache
decl_stmt|;
name|boolean
name|entireRoleTableInCache
decl_stmt|;
comment|/**    * Get the instance of HBaseReadWrite for the current thread.  This is intended to be used by    * {@link org.apache.hadoop.hive.metastore.hbase.HBaseStore} since it creates the thread local    * version of this class.    * @param configuration Configuration object    * @return thread's instance of HBaseReadWrite    */
specifier|public
specifier|static
name|HBaseReadWrite
name|getInstance
parameter_list|(
name|Configuration
name|configuration
parameter_list|)
block|{
name|staticConf
operator|=
name|configuration
expr_stmt|;
return|return
name|self
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Get the instance of HBaseReadWrite for the current thread.  This is inteded to be used after    * the thread has been initialized.  Woe betide you if that's not the case.    * @return thread's instance of HBaseReadWrite    */
specifier|static
name|HBaseReadWrite
name|getInstance
parameter_list|()
block|{
return|return
name|self
operator|.
name|get
argument_list|()
return|;
block|}
specifier|private
name|HBaseReadWrite
parameter_list|(
name|Configuration
name|configuration
parameter_list|)
block|{
name|conf
operator|=
name|configuration
expr_stmt|;
name|HBaseConfiguration
operator|.
name|addHbaseResources
argument_list|(
name|conf
argument_list|)
expr_stmt|;
try|try
block|{
name|String
name|connClass
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTORE_HBASE_CONNECTION_CLASS
argument_list|)
decl_stmt|;
if|if
condition|(
name|TEST_CONN
operator|.
name|equals
argument_list|(
name|connClass
argument_list|)
condition|)
block|{
name|conn
operator|=
name|testConn
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using test connection."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Instantiating connection class "
operator|+
name|connClass
argument_list|)
expr_stmt|;
name|Class
name|c
init|=
name|Class
operator|.
name|forName
argument_list|(
name|connClass
argument_list|)
decl_stmt|;
name|Object
name|o
init|=
name|c
operator|.
name|newInstance
argument_list|()
decl_stmt|;
if|if
condition|(
name|HBaseConnection
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|o
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
name|conn
operator|=
operator|(
name|HBaseConnection
operator|)
name|o
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|connClass
operator|+
literal|" is not an instance of HBaseConnection."
argument_list|)
throw|;
block|}
name|conn
operator|.
name|setConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|conn
operator|.
name|connect
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
try|try
block|{
name|md
operator|=
name|MessageDigest
operator|.
name|getInstance
argument_list|(
literal|"MD5"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|int
name|totalCatalogObjectsToCache
init|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTORE_HBASE_CATALOG_CACHE_SIZE
argument_list|)
decl_stmt|;
name|tableHits
operator|=
operator|new
name|Counter
argument_list|(
literal|"table cache hits"
argument_list|)
expr_stmt|;
name|tableMisses
operator|=
operator|new
name|Counter
argument_list|(
literal|"table cache misses"
argument_list|)
expr_stmt|;
name|tableOverflows
operator|=
operator|new
name|Counter
argument_list|(
literal|"table cache overflows"
argument_list|)
expr_stmt|;
name|partHits
operator|=
operator|new
name|Counter
argument_list|(
literal|"partition cache hits"
argument_list|)
expr_stmt|;
name|partMisses
operator|=
operator|new
name|Counter
argument_list|(
literal|"partition cache misses"
argument_list|)
expr_stmt|;
name|partOverflows
operator|=
operator|new
name|Counter
argument_list|(
literal|"partition cache overflows"
argument_list|)
expr_stmt|;
name|sdHits
operator|=
operator|new
name|Counter
argument_list|(
literal|"storage descriptor cache hits"
argument_list|)
expr_stmt|;
name|sdMisses
operator|=
operator|new
name|Counter
argument_list|(
literal|"storage descriptor cache misses"
argument_list|)
expr_stmt|;
name|sdOverflows
operator|=
operator|new
name|Counter
argument_list|(
literal|"storage descriptor cache overflows"
argument_list|)
expr_stmt|;
name|counters
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|tableHits
argument_list|)
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|tableMisses
argument_list|)
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|tableOverflows
argument_list|)
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|partHits
argument_list|)
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|partMisses
argument_list|)
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|partOverflows
argument_list|)
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|sdHits
argument_list|)
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|sdMisses
argument_list|)
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|sdOverflows
argument_list|)
expr_stmt|;
comment|// Give 1% of catalog cache space to storage descriptors
comment|// (storage descriptors are shared, so 99% should be the same for a given table)
name|int
name|sdsCacheSize
init|=
name|totalCatalogObjectsToCache
operator|/
literal|100
decl_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|NO_CACHE_CONF
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|tableCache
operator|=
operator|new
name|BogusObjectCache
argument_list|<>
argument_list|()
expr_stmt|;
name|sdCache
operator|=
operator|new
name|BogusObjectCache
argument_list|<>
argument_list|()
expr_stmt|;
name|partCache
operator|=
operator|new
name|BogusPartitionCache
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|tableCache
operator|=
operator|new
name|ObjectCache
argument_list|<>
argument_list|(
name|TABLES_TO_CACHE
argument_list|,
name|tableHits
argument_list|,
name|tableMisses
argument_list|,
name|tableOverflows
argument_list|)
expr_stmt|;
name|sdCache
operator|=
operator|new
name|ObjectCache
argument_list|<>
argument_list|(
name|sdsCacheSize
argument_list|,
name|sdHits
argument_list|,
name|sdMisses
argument_list|,
name|sdOverflows
argument_list|)
expr_stmt|;
name|partCache
operator|=
operator|new
name|PartitionCache
argument_list|(
name|totalCatalogObjectsToCache
argument_list|,
name|partHits
argument_list|,
name|partMisses
argument_list|,
name|partOverflows
argument_list|)
expr_stmt|;
block|}
name|statsCache
operator|=
name|StatsCache
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|roleCache
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|entireRoleTableInCache
operator|=
literal|false
expr_stmt|;
block|}
comment|// Synchronize this so not everyone's doing it at once.
specifier|static
specifier|synchronized
name|void
name|createTablesIfNotExist
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|tablesCreated
condition|)
block|{
for|for
control|(
name|String
name|name
range|:
name|tableNames
control|)
block|{
if|if
condition|(
name|self
operator|.
name|get
argument_list|()
operator|.
name|conn
operator|.
name|getHBaseTable
argument_list|(
name|name
argument_list|,
literal|true
argument_list|)
operator|==
literal|null
condition|)
block|{
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|families
init|=
name|columnFamilies
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|self
operator|.
name|get
argument_list|()
operator|.
name|conn
operator|.
name|createHBaseTable
argument_list|(
name|name
argument_list|,
name|families
argument_list|)
expr_stmt|;
block|}
block|}
name|tablesCreated
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/**********************************************************************************************    * Transaction related methods    *********************************************************************************************/
comment|/**    * Begin a transaction    */
name|void
name|begin
parameter_list|()
block|{
try|try
block|{
name|conn
operator|.
name|beginTransaction
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Commit a transaction    */
name|void
name|commit
parameter_list|()
block|{
try|try
block|{
name|conn
operator|.
name|commitTransaction
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
name|void
name|rollback
parameter_list|()
block|{
try|try
block|{
name|conn
operator|.
name|rollbackTransaction
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|conn
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**********************************************************************************************    * Database related methods    *********************************************************************************************/
comment|/**    * Fetch a database object    * @param name name of the database to fetch    * @return the database object, or null if there is no such database    * @throws IOException    */
name|Database
name|getDb
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|byte
index|[]
name|serialized
init|=
name|read
argument_list|(
name|DB_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|HBaseUtils
operator|.
name|deserializeDatabase
argument_list|(
name|name
argument_list|,
name|serialized
argument_list|)
return|;
block|}
comment|/**    * Get a list of databases.    * @param regex Regular expression to use in searching for database names.  It is expected to    *              be a Java regular expression.  If it is null then all databases will be returned.    * @return list of databases matching the regular expression.    * @throws IOException    */
name|List
argument_list|<
name|Database
argument_list|>
name|scanDatabases
parameter_list|(
name|String
name|regex
parameter_list|)
throws|throws
name|IOException
block|{
name|Filter
name|filter
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|regex
operator|!=
literal|null
condition|)
block|{
name|filter
operator|=
operator|new
name|RowFilter
argument_list|(
name|CompareFilter
operator|.
name|CompareOp
operator|.
name|EQUAL
argument_list|,
operator|new
name|RegexStringComparator
argument_list|(
name|regex
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|Result
argument_list|>
name|iter
init|=
name|scan
argument_list|(
name|DB_TABLE
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Database
argument_list|>
name|databases
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Result
name|result
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|databases
operator|.
name|add
argument_list|(
name|HBaseUtils
operator|.
name|deserializeDatabase
argument_list|(
name|result
operator|.
name|getRow
argument_list|()
argument_list|,
name|result
operator|.
name|getValue
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|databases
return|;
block|}
comment|/**    * Store a database object    * @param database database object to store    * @throws IOException    */
name|void
name|putDb
parameter_list|(
name|Database
name|database
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
index|[]
name|serialized
init|=
name|HBaseUtils
operator|.
name|serializeDatabase
argument_list|(
name|database
argument_list|)
decl_stmt|;
name|store
argument_list|(
name|DB_TABLE
argument_list|,
name|serialized
index|[
literal|0
index|]
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|serialized
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/**    * Drop a database    * @param name name of db to drop    * @throws IOException    */
name|void
name|deleteDb
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|delete
argument_list|(
name|DB_TABLE
argument_list|,
name|key
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**********************************************************************************************    * Function related methods    *********************************************************************************************/
comment|/**    * Fetch a function object    * @param dbName name of the database the function is in    * @param functionName name of the function to fetch    * @return the function object, or null if there is no such function    * @throws IOException    */
name|Function
name|getFunction
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|functionName
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|dbName
argument_list|,
name|functionName
argument_list|)
decl_stmt|;
name|byte
index|[]
name|serialized
init|=
name|read
argument_list|(
name|FUNC_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|HBaseUtils
operator|.
name|deserializeFunction
argument_list|(
name|dbName
argument_list|,
name|functionName
argument_list|,
name|serialized
argument_list|)
return|;
block|}
comment|/**    * Get a list of functions.    * @param dbName Name of the database to search in.    * @param regex Regular expression to use in searching for function names.  It is expected to    *              be a Java regular expression.  If it is null then all functions will be returned.    * @return list of functions matching the regular expression.    * @throws IOException    */
name|List
argument_list|<
name|Function
argument_list|>
name|scanFunctions
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|regex
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|keyPrefix
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|dbName
operator|!=
literal|null
condition|)
block|{
name|keyPrefix
operator|=
name|HBaseUtils
operator|.
name|buildKeyWithTrailingSeparator
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
block|}
name|Filter
name|filter
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|regex
operator|!=
literal|null
condition|)
block|{
name|filter
operator|=
operator|new
name|RowFilter
argument_list|(
name|CompareFilter
operator|.
name|CompareOp
operator|.
name|EQUAL
argument_list|,
operator|new
name|RegexStringComparator
argument_list|(
name|regex
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|Result
argument_list|>
name|iter
init|=
name|scan
argument_list|(
name|FUNC_TABLE
argument_list|,
name|keyPrefix
argument_list|,
name|HBaseUtils
operator|.
name|getEndPrefix
argument_list|(
name|keyPrefix
argument_list|)
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Function
argument_list|>
name|functions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Result
name|result
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|functions
operator|.
name|add
argument_list|(
name|HBaseUtils
operator|.
name|deserializeFunction
argument_list|(
name|result
operator|.
name|getRow
argument_list|()
argument_list|,
name|result
operator|.
name|getValue
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|functions
return|;
block|}
comment|/**    * Store a function object    * @param function function object to store    * @throws IOException    */
name|void
name|putFunction
parameter_list|(
name|Function
name|function
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
index|[]
name|serialized
init|=
name|HBaseUtils
operator|.
name|serializeFunction
argument_list|(
name|function
argument_list|)
decl_stmt|;
name|store
argument_list|(
name|FUNC_TABLE
argument_list|,
name|serialized
index|[
literal|0
index|]
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|serialized
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/**    * Drop a function    * @param dbName name of database the function is in    * @param functionName name of function to drop    * @throws IOException    */
name|void
name|deleteFunction
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|functionName
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|dbName
argument_list|,
name|functionName
argument_list|)
decl_stmt|;
name|delete
argument_list|(
name|FUNC_TABLE
argument_list|,
name|key
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**********************************************************************************************    * Global privilege related methods    *********************************************************************************************/
comment|/**    * Fetch the global privileges object    * @return    * @throws IOException    */
name|PrincipalPrivilegeSet
name|getGlobalPrivs
parameter_list|()
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|GLOBAL_PRIVS_KEY
decl_stmt|;
name|byte
index|[]
name|serialized
init|=
name|read
argument_list|(
name|GLOBAL_PRIVS_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|HBaseUtils
operator|.
name|deserializePrincipalPrivilegeSet
argument_list|(
name|serialized
argument_list|)
return|;
block|}
comment|/**    * Store the global privileges object    * @throws IOException    */
name|void
name|putGlobalPrivs
parameter_list|(
name|PrincipalPrivilegeSet
name|privs
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|GLOBAL_PRIVS_KEY
decl_stmt|;
name|byte
index|[]
name|serialized
init|=
name|HBaseUtils
operator|.
name|serializePrincipalPrivilegeSet
argument_list|(
name|privs
argument_list|)
decl_stmt|;
name|store
argument_list|(
name|GLOBAL_PRIVS_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|serialized
argument_list|)
expr_stmt|;
block|}
comment|/**********************************************************************************************    * Partition related methods    *********************************************************************************************/
comment|/**    * Fetch one partition    * @param dbName database table is in    * @param tableName table partition is in    * @param partVals list of values that specify the partition, given in the same order as the    *                 columns they belong to    * @return The partition objec,t or null if there is no such partition    * @throws IOException    */
name|Partition
name|getPartition
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partVals
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getPartition
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partVals
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Get a set of specific partitions.  This cannot be used to do a scan, each partition must be    * completely specified.  This does not use the partition cache.    * @param dbName database table is in    * @param tableName table partitions are in    * @param partValLists list of list of values, each list should uniquely identify one partition    * @return a list of partition objects.    * @throws IOException    */
name|List
argument_list|<
name|Partition
argument_list|>
name|getPartitions
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partTypes
parameter_list|,
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|partValLists
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|Partition
argument_list|>
name|parts
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|partValLists
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Get
argument_list|>
name|gets
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|partValLists
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|String
argument_list|>
name|partVals
range|:
name|partValLists
control|)
block|{
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildPartitionKey
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partTypes
argument_list|,
name|partVals
argument_list|)
decl_stmt|;
name|Get
name|get
init|=
operator|new
name|Get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|get
operator|.
name|addColumn
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
expr_stmt|;
name|gets
operator|.
name|add
argument_list|(
name|get
argument_list|)
expr_stmt|;
block|}
name|HTableInterface
name|htab
init|=
name|conn
operator|.
name|getHBaseTable
argument_list|(
name|PART_TABLE
argument_list|)
decl_stmt|;
name|Result
index|[]
name|results
init|=
name|htab
operator|.
name|get
argument_list|(
name|gets
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|results
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|HBaseUtils
operator|.
name|StorageDescriptorParts
name|sdParts
init|=
name|HBaseUtils
operator|.
name|deserializePartition
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partValLists
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|results
index|[
name|i
index|]
operator|.
name|getValue
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
argument_list|)
decl_stmt|;
name|StorageDescriptor
name|sd
init|=
name|getStorageDescriptor
argument_list|(
name|sdParts
operator|.
name|sdHash
argument_list|)
decl_stmt|;
name|HBaseUtils
operator|.
name|assembleStorageDescriptor
argument_list|(
name|sd
argument_list|,
name|sdParts
argument_list|)
expr_stmt|;
name|parts
operator|.
name|add
argument_list|(
name|sdParts
operator|.
name|containingPartition
argument_list|)
expr_stmt|;
block|}
return|return
name|parts
return|;
block|}
comment|/**    * Add a partition.  This should only be called for new partitions.  For altering existing    * partitions this should not be called as it will blindly increment the ref counter for the    * storage descriptor.    * @param partition partition object to add    * @throws IOException    */
name|void
name|putPartition
parameter_list|(
name|Partition
name|partition
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|hash
init|=
name|putStorageDescriptor
argument_list|(
name|partition
operator|.
name|getSd
argument_list|()
argument_list|)
decl_stmt|;
name|byte
index|[]
index|[]
name|serialized
init|=
name|HBaseUtils
operator|.
name|serializePartition
argument_list|(
name|partition
argument_list|,
name|HBaseUtils
operator|.
name|getPartitionKeyTypes
argument_list|(
name|getTable
argument_list|(
name|partition
operator|.
name|getDbName
argument_list|()
argument_list|,
name|partition
operator|.
name|getTableName
argument_list|()
argument_list|)
operator|.
name|getPartitionKeys
argument_list|()
argument_list|)
argument_list|,
name|hash
argument_list|)
decl_stmt|;
name|store
argument_list|(
name|PART_TABLE
argument_list|,
name|serialized
index|[
literal|0
index|]
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|serialized
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|partCache
operator|.
name|put
argument_list|(
name|partition
operator|.
name|getDbName
argument_list|()
argument_list|,
name|partition
operator|.
name|getTableName
argument_list|()
argument_list|,
name|partition
argument_list|)
expr_stmt|;
block|}
comment|/**    * Replace an existing partition.    * @param oldPart partition to be replaced    * @param newPart partitiion to replace it with    * @throws IOException    */
name|void
name|replacePartition
parameter_list|(
name|Partition
name|oldPart
parameter_list|,
name|Partition
name|newPart
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partTypes
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|hash
decl_stmt|;
name|byte
index|[]
name|oldHash
init|=
name|HBaseUtils
operator|.
name|hashStorageDescriptor
argument_list|(
name|oldPart
operator|.
name|getSd
argument_list|()
argument_list|,
name|md
argument_list|)
decl_stmt|;
name|byte
index|[]
name|newHash
init|=
name|HBaseUtils
operator|.
name|hashStorageDescriptor
argument_list|(
name|newPart
operator|.
name|getSd
argument_list|()
argument_list|,
name|md
argument_list|)
decl_stmt|;
if|if
condition|(
name|Arrays
operator|.
name|equals
argument_list|(
name|oldHash
argument_list|,
name|newHash
argument_list|)
condition|)
block|{
name|hash
operator|=
name|oldHash
expr_stmt|;
block|}
else|else
block|{
name|decrementStorageDescriptorRefCount
argument_list|(
name|oldPart
operator|.
name|getSd
argument_list|()
argument_list|)
expr_stmt|;
name|hash
operator|=
name|putStorageDescriptor
argument_list|(
name|newPart
operator|.
name|getSd
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
index|[]
name|serialized
init|=
name|HBaseUtils
operator|.
name|serializePartition
argument_list|(
name|newPart
argument_list|,
name|HBaseUtils
operator|.
name|getPartitionKeyTypes
argument_list|(
name|getTable
argument_list|(
name|newPart
operator|.
name|getDbName
argument_list|()
argument_list|,
name|newPart
operator|.
name|getTableName
argument_list|()
argument_list|)
operator|.
name|getPartitionKeys
argument_list|()
argument_list|)
argument_list|,
name|hash
argument_list|)
decl_stmt|;
name|store
argument_list|(
name|PART_TABLE
argument_list|,
name|serialized
index|[
literal|0
index|]
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|serialized
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|partCache
operator|.
name|put
argument_list|(
name|newPart
operator|.
name|getDbName
argument_list|()
argument_list|,
name|newPart
operator|.
name|getTableName
argument_list|()
argument_list|,
name|newPart
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oldPart
operator|.
name|getTableName
argument_list|()
operator|.
name|equals
argument_list|(
name|newPart
operator|.
name|getTableName
argument_list|()
argument_list|)
condition|)
block|{
name|deletePartition
argument_list|(
name|oldPart
operator|.
name|getDbName
argument_list|()
argument_list|,
name|oldPart
operator|.
name|getTableName
argument_list|()
argument_list|,
name|partTypes
argument_list|,
name|oldPart
operator|.
name|getValues
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Add a group of partitions.  This should only be used when all partitions are new.  It    * blindly increments the ref count on the storage descriptor.    * @param partitions list of partitions to add    * @throws IOException    */
name|void
name|putPartitions
parameter_list|(
name|List
argument_list|<
name|Partition
argument_list|>
name|partitions
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|Put
argument_list|>
name|puts
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|partitions
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Partition
name|partition
range|:
name|partitions
control|)
block|{
name|byte
index|[]
name|hash
init|=
name|putStorageDescriptor
argument_list|(
name|partition
operator|.
name|getSd
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|partTypes
init|=
name|HBaseUtils
operator|.
name|getPartitionKeyTypes
argument_list|(
name|getTable
argument_list|(
name|partition
operator|.
name|getDbName
argument_list|()
argument_list|,
name|partition
operator|.
name|getTableName
argument_list|()
argument_list|)
operator|.
name|getPartitionKeys
argument_list|()
argument_list|)
decl_stmt|;
name|byte
index|[]
index|[]
name|serialized
init|=
name|HBaseUtils
operator|.
name|serializePartition
argument_list|(
name|partition
argument_list|,
name|partTypes
argument_list|,
name|hash
argument_list|)
decl_stmt|;
name|Put
name|p
init|=
operator|new
name|Put
argument_list|(
name|serialized
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|p
operator|.
name|add
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|serialized
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|puts
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|partCache
operator|.
name|put
argument_list|(
name|partition
operator|.
name|getDbName
argument_list|()
argument_list|,
name|partition
operator|.
name|getTableName
argument_list|()
argument_list|,
name|partition
argument_list|)
expr_stmt|;
block|}
name|HTableInterface
name|htab
init|=
name|conn
operator|.
name|getHBaseTable
argument_list|(
name|PART_TABLE
argument_list|)
decl_stmt|;
name|htab
operator|.
name|put
argument_list|(
name|puts
argument_list|)
expr_stmt|;
name|conn
operator|.
name|flush
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
name|void
name|replacePartitions
parameter_list|(
name|List
argument_list|<
name|Partition
argument_list|>
name|oldParts
parameter_list|,
name|List
argument_list|<
name|Partition
argument_list|>
name|newParts
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|oldPartTypes
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|oldParts
operator|.
name|size
argument_list|()
operator|!=
name|newParts
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Number of old and new partitions must match."
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|Put
argument_list|>
name|puts
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|newParts
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newParts
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|byte
index|[]
name|hash
decl_stmt|;
name|byte
index|[]
name|oldHash
init|=
name|HBaseUtils
operator|.
name|hashStorageDescriptor
argument_list|(
name|oldParts
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getSd
argument_list|()
argument_list|,
name|md
argument_list|)
decl_stmt|;
name|byte
index|[]
name|newHash
init|=
name|HBaseUtils
operator|.
name|hashStorageDescriptor
argument_list|(
name|newParts
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getSd
argument_list|()
argument_list|,
name|md
argument_list|)
decl_stmt|;
if|if
condition|(
name|Arrays
operator|.
name|equals
argument_list|(
name|oldHash
argument_list|,
name|newHash
argument_list|)
condition|)
block|{
name|hash
operator|=
name|oldHash
expr_stmt|;
block|}
else|else
block|{
name|decrementStorageDescriptorRefCount
argument_list|(
name|oldParts
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getSd
argument_list|()
argument_list|)
expr_stmt|;
name|hash
operator|=
name|putStorageDescriptor
argument_list|(
name|newParts
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getSd
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Partition
name|newPart
init|=
name|newParts
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|byte
index|[]
index|[]
name|serialized
init|=
name|HBaseUtils
operator|.
name|serializePartition
argument_list|(
name|newPart
argument_list|,
name|HBaseUtils
operator|.
name|getPartitionKeyTypes
argument_list|(
name|getTable
argument_list|(
name|newPart
operator|.
name|getDbName
argument_list|()
argument_list|,
name|newPart
operator|.
name|getTableName
argument_list|()
argument_list|)
operator|.
name|getPartitionKeys
argument_list|()
argument_list|)
argument_list|,
name|hash
argument_list|)
decl_stmt|;
name|Put
name|p
init|=
operator|new
name|Put
argument_list|(
name|serialized
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|p
operator|.
name|add
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|serialized
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|puts
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|partCache
operator|.
name|put
argument_list|(
name|newParts
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getDbName
argument_list|()
argument_list|,
name|newParts
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTableName
argument_list|()
argument_list|,
name|newParts
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newParts
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTableName
argument_list|()
operator|.
name|equals
argument_list|(
name|oldParts
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTableName
argument_list|()
argument_list|)
condition|)
block|{
comment|// We need to remove the old record as well.
name|deletePartition
argument_list|(
name|oldParts
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getDbName
argument_list|()
argument_list|,
name|oldParts
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTableName
argument_list|()
argument_list|,
name|oldPartTypes
argument_list|,
name|oldParts
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getValues
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
name|HTableInterface
name|htab
init|=
name|conn
operator|.
name|getHBaseTable
argument_list|(
name|PART_TABLE
argument_list|)
decl_stmt|;
name|htab
operator|.
name|put
argument_list|(
name|puts
argument_list|)
expr_stmt|;
name|conn
operator|.
name|flush
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
comment|/**    * Find all the partitions in a table.    * @param dbName name of the database the table is in    * @param tableName table name    * @param maxPartitions max partitions to fetch.  If negative all partitions will be returned.    * @return List of partitions that match the criteria.    * @throws IOException    */
name|List
argument_list|<
name|Partition
argument_list|>
name|scanPartitionsInTable
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|int
name|maxPartitions
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|maxPartitions
operator|<
literal|0
condition|)
name|maxPartitions
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
name|Collection
argument_list|<
name|Partition
argument_list|>
name|cached
init|=
name|partCache
operator|.
name|getAllForTable
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cached
operator|!=
literal|null
condition|)
block|{
return|return
name|maxPartitions
operator|<
name|cached
operator|.
name|size
argument_list|()
condition|?
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|cached
argument_list|)
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|maxPartitions
argument_list|)
else|:
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|cached
argument_list|)
return|;
block|}
name|byte
index|[]
name|keyPrefix
init|=
name|HBaseUtils
operator|.
name|buildPartitionKey
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Partition
argument_list|>
name|parts
init|=
name|scanPartitionsWithFilter
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|keyPrefix
argument_list|,
name|HBaseUtils
operator|.
name|getEndPrefix
argument_list|(
name|keyPrefix
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|partCache
operator|.
name|put
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|parts
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|maxPartitions
operator|<
name|parts
operator|.
name|size
argument_list|()
condition|?
name|parts
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|maxPartitions
argument_list|)
else|:
name|parts
return|;
block|}
comment|/**    * Scan partitions based on partial key information.    * @param dbName name of database, required    * @param tableName name of table, required    * @param partVals partial specification of values.  Any values that are unknown can instead be    *                 a '*'.  For example, if a table had two partition columns date    *                 and region (in that order), and partitions ('today', 'na'), ('today', 'eu'),    *                 ('tomorrow', 'na'), ('tomorrow', 'eu') then passing ['today', '*'] would return    *                 ('today', 'na') and ('today', 'eu') while passing ['*', 'eu'] would return    *                 ('today', 'eu') and ('tomorrow', 'eu').  Also the list can terminate early,    *                 which will be the equivalent of adding '*' for all non-included values.    *                 I.e. ['today'] is the same as ['today', '*'].    * @param maxPartitions Maximum number of entries to return.    * @return list of partitions that match the specified information    * @throws IOException    * @throws org.apache.hadoop.hive.metastore.api.NoSuchObjectException if the table containing    * the partitions can't be found.    */
name|List
argument_list|<
name|Partition
argument_list|>
name|scanPartitions
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partVals
parameter_list|,
name|int
name|maxPartitions
parameter_list|)
throws|throws
name|IOException
throws|,
name|NoSuchObjectException
block|{
comment|// First, build as much of the key as we can so that we make the scan as tight as possible.
name|List
argument_list|<
name|String
argument_list|>
name|keyElements
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|keyElements
operator|.
name|add
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|keyElements
operator|.
name|add
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|int
name|firstStar
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partVals
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
literal|"*"
operator|.
name|equals
argument_list|(
name|partVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|firstStar
operator|=
name|i
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|// empty string equals to null partition,
comment|// means star
if|if
condition|(
name|partVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
break|break;
block|}
else|else
block|{
name|keyElements
operator|.
name|add
argument_list|(
name|partVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|byte
index|[]
name|keyPrefix
decl_stmt|;
comment|// We need to fetch the table to determine if the user fully specified the partitions or
comment|// not, as it affects how we build the key.
name|Table
name|table
init|=
name|getTable
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchObjectException
argument_list|(
literal|"Unable to find table "
operator|+
name|dbName
operator|+
literal|"."
operator|+
name|tableName
argument_list|)
throw|;
block|}
name|keyPrefix
operator|=
name|HBaseUtils
operator|.
name|buildPartitionKey
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|HBaseUtils
operator|.
name|getPartitionKeyTypes
argument_list|(
name|table
operator|.
name|getPartitionKeys
argument_list|()
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|keyElements
operator|.
name|size
argument_list|()
operator|-
literal|2
argument_list|)
argument_list|)
argument_list|,
name|keyElements
operator|.
name|subList
argument_list|(
literal|2
argument_list|,
name|keyElements
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Now, build a filter out of the remaining keys
name|List
argument_list|<
name|PartitionKeyComparator
operator|.
name|Range
argument_list|>
name|ranges
init|=
operator|new
name|ArrayList
argument_list|<
name|PartitionKeyComparator
operator|.
name|Range
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|>
name|ops
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|partVals
operator|.
name|size
argument_list|()
operator|==
name|table
operator|.
name|getPartitionKeys
argument_list|()
operator|.
name|size
argument_list|()
operator|&&
name|firstStar
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|firstStar
argument_list|)
init|;
name|i
operator|<
name|table
operator|.
name|getPartitionKeys
argument_list|()
operator|.
name|size
argument_list|()
operator|&&
name|i
operator|<
name|partVals
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
literal|"*"
operator|.
name|equals
argument_list|(
name|partVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|PartitionKeyComparator
operator|.
name|Operator
name|op
init|=
operator|new
name|PartitionKeyComparator
operator|.
name|Operator
argument_list|(
name|PartitionKeyComparator
operator|.
name|Operator
operator|.
name|Type
operator|.
name|LIKE
argument_list|,
name|table
operator|.
name|getPartitionKeys
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|,
literal|".*"
argument_list|)
decl_stmt|;
name|ops
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PartitionKeyComparator
operator|.
name|Range
name|range
init|=
operator|new
name|PartitionKeyComparator
operator|.
name|Range
argument_list|(
name|table
operator|.
name|getPartitionKeys
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|PartitionKeyComparator
operator|.
name|Mark
argument_list|(
name|partVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|,
operator|new
name|PartitionKeyComparator
operator|.
name|Mark
argument_list|(
name|partVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
name|ranges
operator|.
name|add
argument_list|(
name|range
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Filter
name|filter
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|ranges
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|ops
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|filter
operator|=
operator|new
name|RowFilter
argument_list|(
name|CompareFilter
operator|.
name|CompareOp
operator|.
name|EQUAL
argument_list|,
operator|new
name|PartitionKeyComparator
argument_list|(
name|StringUtils
operator|.
name|join
argument_list|(
name|HBaseUtils
operator|.
name|getPartitionNames
argument_list|(
name|table
operator|.
name|getPartitionKeys
argument_list|()
argument_list|)
argument_list|,
literal|","
argument_list|)
argument_list|,
name|StringUtils
operator|.
name|join
argument_list|(
name|HBaseUtils
operator|.
name|getPartitionKeyTypes
argument_list|(
name|table
operator|.
name|getPartitionKeys
argument_list|()
argument_list|)
argument_list|,
literal|","
argument_list|)
argument_list|,
name|ranges
argument_list|,
name|ops
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Scanning partitions with prefix<"
operator|+
operator|new
name|String
argument_list|(
name|keyPrefix
argument_list|)
operator|+
literal|"> and filter<"
operator|+
name|filter
operator|+
literal|">"
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Partition
argument_list|>
name|parts
init|=
name|scanPartitionsWithFilter
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|keyPrefix
argument_list|,
name|HBaseUtils
operator|.
name|getEndPrefix
argument_list|(
name|keyPrefix
argument_list|)
argument_list|,
name|maxPartitions
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|partCache
operator|.
name|put
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|parts
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|parts
return|;
block|}
name|List
argument_list|<
name|Partition
argument_list|>
name|scanPartitions
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|byte
index|[]
name|keyStart
parameter_list|,
name|byte
index|[]
name|keyEnd
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|int
name|maxPartitions
parameter_list|)
throws|throws
name|IOException
throws|,
name|NoSuchObjectException
block|{
name|byte
index|[]
name|startRow
init|=
name|keyStart
decl_stmt|;
name|byte
index|[]
name|endRow
decl_stmt|;
if|if
condition|(
name|keyEnd
operator|==
literal|null
operator|||
name|keyEnd
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|// stop when current db+table entries are over
name|endRow
operator|=
name|HBaseUtils
operator|.
name|getEndPrefix
argument_list|(
name|startRow
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|endRow
operator|=
name|keyEnd
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Scanning partitions with start row<"
operator|+
operator|new
name|String
argument_list|(
name|startRow
argument_list|)
operator|+
literal|"> and end row<"
operator|+
operator|new
name|String
argument_list|(
name|endRow
argument_list|)
operator|+
literal|">"
argument_list|)
expr_stmt|;
block|}
return|return
name|scanPartitionsWithFilter
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|startRow
argument_list|,
name|endRow
argument_list|,
name|maxPartitions
argument_list|,
name|filter
argument_list|)
return|;
block|}
comment|/**    * Delete a partition    * @param dbName database name that table is in    * @param tableName table partition is in    * @param partVals partition values that define this partition, in the same order as the    *                 partition columns they are values for    * @throws IOException    */
name|void
name|deletePartition
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partTypes
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partVals
parameter_list|)
throws|throws
name|IOException
block|{
name|deletePartition
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partTypes
argument_list|,
name|partVals
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|deletePartition
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partTypes
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partVals
parameter_list|,
name|boolean
name|decrementRefCnt
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Find the partition so I can get the storage descriptor and drop it
name|partCache
operator|.
name|remove
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partVals
argument_list|)
expr_stmt|;
if|if
condition|(
name|decrementRefCnt
condition|)
block|{
name|Partition
name|p
init|=
name|getPartition
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partVals
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|decrementStorageDescriptorRefCount
argument_list|(
name|p
operator|.
name|getSd
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildPartitionKey
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partTypes
argument_list|,
name|partVals
argument_list|)
decl_stmt|;
name|delete
argument_list|(
name|PART_TABLE
argument_list|,
name|key
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Partition
name|getPartition
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partVals
parameter_list|,
name|boolean
name|populateCache
parameter_list|)
throws|throws
name|IOException
block|{
name|Partition
name|cached
init|=
name|partCache
operator|.
name|get
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partVals
argument_list|)
decl_stmt|;
if|if
condition|(
name|cached
operator|!=
literal|null
condition|)
return|return
name|cached
return|;
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildPartitionKey
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|HBaseUtils
operator|.
name|getPartitionKeyTypes
argument_list|(
name|getTable
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
operator|.
name|getPartitionKeys
argument_list|()
argument_list|)
argument_list|,
name|partVals
argument_list|)
decl_stmt|;
name|byte
index|[]
name|serialized
init|=
name|read
argument_list|(
name|PART_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|HBaseUtils
operator|.
name|StorageDescriptorParts
name|sdParts
init|=
name|HBaseUtils
operator|.
name|deserializePartition
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partVals
argument_list|,
name|serialized
argument_list|)
decl_stmt|;
name|StorageDescriptor
name|sd
init|=
name|getStorageDescriptor
argument_list|(
name|sdParts
operator|.
name|sdHash
argument_list|)
decl_stmt|;
name|HBaseUtils
operator|.
name|assembleStorageDescriptor
argument_list|(
name|sd
argument_list|,
name|sdParts
argument_list|)
expr_stmt|;
if|if
condition|(
name|populateCache
condition|)
name|partCache
operator|.
name|put
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|sdParts
operator|.
name|containingPartition
argument_list|)
expr_stmt|;
return|return
name|sdParts
operator|.
name|containingPartition
return|;
block|}
specifier|private
name|List
argument_list|<
name|Partition
argument_list|>
name|scanPartitionsWithFilter
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|byte
index|[]
name|startRow
parameter_list|,
name|byte
index|[]
name|endRow
parameter_list|,
name|int
name|maxResults
parameter_list|,
name|Filter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|Iterator
argument_list|<
name|Result
argument_list|>
name|iter
init|=
name|scan
argument_list|(
name|PART_TABLE
argument_list|,
name|startRow
argument_list|,
name|endRow
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|tablePartitions
init|=
name|getTable
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
operator|.
name|getPartitionKeys
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Partition
argument_list|>
name|parts
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|numToFetch
init|=
name|maxResults
operator|<
literal|0
condition|?
name|Integer
operator|.
name|MAX_VALUE
else|:
name|maxResults
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numToFetch
operator|&&
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Result
name|result
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|HBaseUtils
operator|.
name|StorageDescriptorParts
name|sdParts
init|=
name|HBaseUtils
operator|.
name|deserializePartition
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|tablePartitions
argument_list|,
name|result
operator|.
name|getRow
argument_list|()
argument_list|,
name|result
operator|.
name|getValue
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
argument_list|,
name|staticConf
argument_list|)
decl_stmt|;
name|StorageDescriptor
name|sd
init|=
name|getStorageDescriptor
argument_list|(
name|sdParts
operator|.
name|sdHash
argument_list|)
decl_stmt|;
name|HBaseUtils
operator|.
name|assembleStorageDescriptor
argument_list|(
name|sd
argument_list|,
name|sdParts
argument_list|)
expr_stmt|;
name|parts
operator|.
name|add
argument_list|(
name|sdParts
operator|.
name|containingPartition
argument_list|)
expr_stmt|;
block|}
return|return
name|parts
return|;
block|}
comment|/**********************************************************************************************    * Role related methods    *********************************************************************************************/
comment|/**    * Fetch the list of all roles for a user    * @param userName name of the user    * @return the list of all roles this user participates in    * @throws IOException    */
name|List
argument_list|<
name|String
argument_list|>
name|getUserRoles
parameter_list|(
name|String
name|userName
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|userName
argument_list|)
decl_stmt|;
name|byte
index|[]
name|serialized
init|=
name|read
argument_list|(
name|USER_TO_ROLE_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|HBaseUtils
operator|.
name|deserializeRoleList
argument_list|(
name|serialized
argument_list|)
return|;
block|}
comment|/**    * Find all roles directly participated in by a given principal.  This builds the role cache    * because it assumes that subsequent calls may be made to find roles participated in indirectly.    * @param name username or role name    * @param type user or role    * @return map of role name to grant info for all roles directly participated in.    */
name|List
argument_list|<
name|Role
argument_list|>
name|getPrincipalDirectRoles
parameter_list|(
name|String
name|name
parameter_list|,
name|PrincipalType
name|type
parameter_list|)
throws|throws
name|IOException
block|{
name|buildRoleCache
argument_list|()
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|rolesFound
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfoList
argument_list|>
name|e
range|:
name|roleCache
operator|.
name|entrySet
argument_list|()
control|)
block|{
for|for
control|(
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfo
name|giw
range|:
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getGrantInfoList
argument_list|()
control|)
block|{
if|if
condition|(
name|HBaseUtils
operator|.
name|convertPrincipalTypes
argument_list|(
name|giw
operator|.
name|getPrincipalType
argument_list|()
argument_list|)
operator|==
name|type
operator|&&
name|giw
operator|.
name|getPrincipalName
argument_list|()
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|rolesFound
operator|.
name|add
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|List
argument_list|<
name|Role
argument_list|>
name|directRoles
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|rolesFound
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Get
argument_list|>
name|gets
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|HTableInterface
name|htab
init|=
name|conn
operator|.
name|getHBaseTable
argument_list|(
name|ROLE_TABLE
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|roleFound
range|:
name|rolesFound
control|)
block|{
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|roleFound
argument_list|)
decl_stmt|;
name|Get
name|g
init|=
operator|new
name|Get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|g
operator|.
name|addColumn
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
expr_stmt|;
name|gets
operator|.
name|add
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
name|Result
index|[]
name|results
init|=
name|htab
operator|.
name|get
argument_list|(
name|gets
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|results
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|byte
index|[]
name|serialized
init|=
name|results
index|[
name|i
index|]
operator|.
name|getValue
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|!=
literal|null
condition|)
block|{
name|directRoles
operator|.
name|add
argument_list|(
name|HBaseUtils
operator|.
name|deserializeRole
argument_list|(
name|results
index|[
name|i
index|]
operator|.
name|getRow
argument_list|()
argument_list|,
name|serialized
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|directRoles
return|;
block|}
comment|/**    * Fetch all roles and users included directly in a given role.    * @param roleName name of the principal    * @return a list of all roles included in this role    * @throws IOException    */
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfoList
name|getRolePrincipals
parameter_list|(
name|String
name|roleName
parameter_list|)
throws|throws
name|IOException
throws|,
name|NoSuchObjectException
block|{
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfoList
name|rolePrincipals
init|=
name|roleCache
operator|.
name|get
argument_list|(
name|roleName
argument_list|)
decl_stmt|;
if|if
condition|(
name|rolePrincipals
operator|!=
literal|null
condition|)
return|return
name|rolePrincipals
return|;
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|roleName
argument_list|)
decl_stmt|;
name|byte
index|[]
name|serialized
init|=
name|read
argument_list|(
name|ROLE_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|ROLES_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|rolePrincipals
operator|=
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfoList
operator|.
name|parseFrom
argument_list|(
name|serialized
argument_list|)
expr_stmt|;
name|roleCache
operator|.
name|put
argument_list|(
name|roleName
argument_list|,
name|rolePrincipals
argument_list|)
expr_stmt|;
return|return
name|rolePrincipals
return|;
block|}
comment|/**    * Given a role, find all users who are either directly or indirectly participate in this role.    * This is expensive, it should be used sparingly.  It scan the entire userToRole table and    * does a linear search on each entry.    * @param roleName name of the role    * @return set of all users in the role    * @throws IOException    */
name|Set
argument_list|<
name|String
argument_list|>
name|findAllUsersInRole
parameter_list|(
name|String
name|roleName
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Walk the userToRole table and collect every user that matches this role.
name|Set
argument_list|<
name|String
argument_list|>
name|users
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Result
argument_list|>
name|iter
init|=
name|scan
argument_list|(
name|USER_TO_ROLE_TABLE
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Result
name|result
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|roleList
init|=
name|HBaseUtils
operator|.
name|deserializeRoleList
argument_list|(
name|result
operator|.
name|getValue
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|rn
range|:
name|roleList
control|)
block|{
if|if
condition|(
name|rn
operator|.
name|equals
argument_list|(
name|roleName
argument_list|)
condition|)
block|{
name|users
operator|.
name|add
argument_list|(
operator|new
name|String
argument_list|(
name|result
operator|.
name|getRow
argument_list|()
argument_list|,
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|users
return|;
block|}
comment|/**    * Add a principal to a role.    * @param roleName name of the role to add principal to    * @param grantInfo grant information for this principal.    * @throws java.io.IOException    * @throws NoSuchObjectException    *    */
name|void
name|addPrincipalToRole
parameter_list|(
name|String
name|roleName
parameter_list|,
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfo
name|grantInfo
parameter_list|)
throws|throws
name|IOException
throws|,
name|NoSuchObjectException
block|{
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfoList
name|proto
init|=
name|getRolePrincipals
argument_list|(
name|roleName
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfo
argument_list|>
name|rolePrincipals
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|proto
operator|!=
literal|null
condition|)
block|{
name|rolePrincipals
operator|.
name|addAll
argument_list|(
name|proto
operator|.
name|getGrantInfoList
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|rolePrincipals
operator|.
name|add
argument_list|(
name|grantInfo
argument_list|)
expr_stmt|;
name|proto
operator|=
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfoList
operator|.
name|newBuilder
argument_list|()
operator|.
name|addAllGrantInfo
argument_list|(
name|rolePrincipals
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|roleName
argument_list|)
decl_stmt|;
name|store
argument_list|(
name|ROLE_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|ROLES_COL
argument_list|,
name|proto
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
name|roleCache
operator|.
name|put
argument_list|(
name|roleName
argument_list|,
name|proto
argument_list|)
expr_stmt|;
block|}
comment|/**    * Drop a principal from a role.    * @param roleName Name of the role to drop the principal from    * @param principalName name of the principal to drop from the role    * @param type user or role    * @param grantOnly if this is true, just remove the grant option, don't actually remove the    *                  user from the role.    * @throws NoSuchObjectException    * @throws IOException    */
name|void
name|dropPrincipalFromRole
parameter_list|(
name|String
name|roleName
parameter_list|,
name|String
name|principalName
parameter_list|,
name|PrincipalType
name|type
parameter_list|,
name|boolean
name|grantOnly
parameter_list|)
throws|throws
name|NoSuchObjectException
throws|,
name|IOException
block|{
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfoList
name|proto
init|=
name|getRolePrincipals
argument_list|(
name|roleName
argument_list|)
decl_stmt|;
if|if
condition|(
name|proto
operator|==
literal|null
condition|)
return|return;
name|List
argument_list|<
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfo
argument_list|>
name|rolePrincipals
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|rolePrincipals
operator|.
name|addAll
argument_list|(
name|proto
operator|.
name|getGrantInfoList
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rolePrincipals
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|HBaseUtils
operator|.
name|convertPrincipalTypes
argument_list|(
name|rolePrincipals
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getPrincipalType
argument_list|()
argument_list|)
operator|==
name|type
operator|&&
name|rolePrincipals
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getPrincipalName
argument_list|()
operator|.
name|equals
argument_list|(
name|principalName
argument_list|)
condition|)
block|{
if|if
condition|(
name|grantOnly
condition|)
block|{
name|rolePrincipals
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfo
operator|.
name|newBuilder
argument_list|(
name|rolePrincipals
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|setGrantOption
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rolePrincipals
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|roleName
argument_list|)
decl_stmt|;
name|proto
operator|=
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfoList
operator|.
name|newBuilder
argument_list|()
operator|.
name|addAllGrantInfo
argument_list|(
name|rolePrincipals
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|store
argument_list|(
name|ROLE_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|ROLES_COL
argument_list|,
name|proto
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
name|roleCache
operator|.
name|put
argument_list|(
name|roleName
argument_list|,
name|proto
argument_list|)
expr_stmt|;
block|}
comment|/**    * Rebuild the row for a given user in the USER_TO_ROLE table.  This is expensive.  It    * should be called as infrequently as possible.    * @param userName name of the user    * @throws IOException    */
name|void
name|buildRoleMapForUser
parameter_list|(
name|String
name|userName
parameter_list|)
throws|throws
name|IOException
throws|,
name|NoSuchObjectException
block|{
comment|// This is mega ugly.  Hopefully we don't have to do this too often.
comment|// First, scan the role table and put it all in memory
name|buildRoleCache
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Building role map for "
operator|+
name|userName
argument_list|)
expr_stmt|;
comment|// Second, find every role the user participates in directly.
name|Set
argument_list|<
name|String
argument_list|>
name|rolesToAdd
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|rolesToCheckNext
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfoList
argument_list|>
name|e
range|:
name|roleCache
operator|.
name|entrySet
argument_list|()
control|)
block|{
for|for
control|(
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfo
name|grantInfo
range|:
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getGrantInfoList
argument_list|()
control|)
block|{
if|if
condition|(
name|HBaseUtils
operator|.
name|convertPrincipalTypes
argument_list|(
name|grantInfo
operator|.
name|getPrincipalType
argument_list|()
argument_list|)
operator|==
name|PrincipalType
operator|.
name|USER
operator|&&
name|userName
operator|.
name|equals
argument_list|(
name|grantInfo
operator|.
name|getPrincipalName
argument_list|()
argument_list|)
condition|)
block|{
name|rolesToAdd
operator|.
name|add
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|rolesToCheckNext
operator|.
name|add
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding "
operator|+
name|e
operator|.
name|getKey
argument_list|()
operator|+
literal|" to list of roles user is in directly"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|// Third, find every role the user participates in indirectly (that is, they have been
comment|// granted into role X and role Y has been granted into role X).
while|while
condition|(
name|rolesToCheckNext
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|tmpRolesToCheckNext
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|roleName
range|:
name|rolesToCheckNext
control|)
block|{
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfoList
name|grantInfos
init|=
name|roleCache
operator|.
name|get
argument_list|(
name|roleName
argument_list|)
decl_stmt|;
if|if
condition|(
name|grantInfos
operator|==
literal|null
condition|)
continue|continue;
comment|// happens when a role contains no grants
for|for
control|(
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfo
name|grantInfo
range|:
name|grantInfos
operator|.
name|getGrantInfoList
argument_list|()
control|)
block|{
if|if
condition|(
name|HBaseUtils
operator|.
name|convertPrincipalTypes
argument_list|(
name|grantInfo
operator|.
name|getPrincipalType
argument_list|()
argument_list|)
operator|==
name|PrincipalType
operator|.
name|ROLE
operator|&&
name|rolesToAdd
operator|.
name|add
argument_list|(
name|grantInfo
operator|.
name|getPrincipalName
argument_list|()
argument_list|)
condition|)
block|{
name|tmpRolesToCheckNext
operator|.
name|add
argument_list|(
name|grantInfo
operator|.
name|getPrincipalName
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding "
operator|+
name|grantInfo
operator|.
name|getPrincipalName
argument_list|()
operator|+
literal|" to list of roles user is in indirectly"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|rolesToCheckNext
operator|=
name|tmpRolesToCheckNext
expr_stmt|;
block|}
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|userName
argument_list|)
decl_stmt|;
name|byte
index|[]
name|serialized
init|=
name|HBaseUtils
operator|.
name|serializeRoleList
argument_list|(
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|rolesToAdd
argument_list|)
argument_list|)
decl_stmt|;
name|store
argument_list|(
name|USER_TO_ROLE_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|serialized
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove all of the grants for a role.  This is not cheap.    * @param roleName Role to remove from all other roles and grants    * @throws IOException    */
name|void
name|removeRoleGrants
parameter_list|(
name|String
name|roleName
parameter_list|)
throws|throws
name|IOException
block|{
name|buildRoleCache
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|Put
argument_list|>
name|puts
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// First, walk the role table and remove any references to this role
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfoList
argument_list|>
name|e
range|:
name|roleCache
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|boolean
name|madeAChange
init|=
literal|false
decl_stmt|;
name|List
argument_list|<
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfo
argument_list|>
name|rgil
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|rgil
operator|.
name|addAll
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getGrantInfoList
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rgil
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|HBaseUtils
operator|.
name|convertPrincipalTypes
argument_list|(
name|rgil
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getPrincipalType
argument_list|()
argument_list|)
operator|==
name|PrincipalType
operator|.
name|ROLE
operator|&&
name|rgil
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getPrincipalName
argument_list|()
operator|.
name|equals
argument_list|(
name|roleName
argument_list|)
condition|)
block|{
name|rgil
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|madeAChange
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|madeAChange
condition|)
block|{
name|Put
name|put
init|=
operator|new
name|Put
argument_list|(
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfoList
name|proto
init|=
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfoList
operator|.
name|newBuilder
argument_list|()
operator|.
name|addAllGrantInfo
argument_list|(
name|rgil
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|put
operator|.
name|add
argument_list|(
name|CATALOG_CF
argument_list|,
name|ROLES_COL
argument_list|,
name|proto
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
name|puts
operator|.
name|add
argument_list|(
name|put
argument_list|)
expr_stmt|;
name|roleCache
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|proto
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|puts
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|HTableInterface
name|htab
init|=
name|conn
operator|.
name|getHBaseTable
argument_list|(
name|ROLE_TABLE
argument_list|)
decl_stmt|;
name|htab
operator|.
name|put
argument_list|(
name|puts
argument_list|)
expr_stmt|;
name|conn
operator|.
name|flush
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
comment|// Remove any global privileges held by this role
name|PrincipalPrivilegeSet
name|global
init|=
name|getGlobalPrivs
argument_list|()
decl_stmt|;
if|if
condition|(
name|global
operator|!=
literal|null
operator|&&
name|global
operator|.
name|getRolePrivileges
argument_list|()
operator|!=
literal|null
operator|&&
name|global
operator|.
name|getRolePrivileges
argument_list|()
operator|.
name|remove
argument_list|(
name|roleName
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|putGlobalPrivs
argument_list|(
name|global
argument_list|)
expr_stmt|;
block|}
comment|// Now, walk the db table
name|puts
operator|.
name|clear
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|Database
argument_list|>
name|dbs
init|=
name|scanDatabases
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|dbs
operator|==
literal|null
condition|)
name|dbs
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
comment|// rare, but can happen
for|for
control|(
name|Database
name|db
range|:
name|dbs
control|)
block|{
if|if
condition|(
name|db
operator|.
name|getPrivileges
argument_list|()
operator|!=
literal|null
operator|&&
name|db
operator|.
name|getPrivileges
argument_list|()
operator|.
name|getRolePrivileges
argument_list|()
operator|!=
literal|null
operator|&&
name|db
operator|.
name|getPrivileges
argument_list|()
operator|.
name|getRolePrivileges
argument_list|()
operator|.
name|remove
argument_list|(
name|roleName
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
index|[]
name|serialized
init|=
name|HBaseUtils
operator|.
name|serializeDatabase
argument_list|(
name|db
argument_list|)
decl_stmt|;
name|Put
name|put
init|=
operator|new
name|Put
argument_list|(
name|serialized
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|put
operator|.
name|add
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|serialized
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|puts
operator|.
name|add
argument_list|(
name|put
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|puts
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|HTableInterface
name|htab
init|=
name|conn
operator|.
name|getHBaseTable
argument_list|(
name|DB_TABLE
argument_list|)
decl_stmt|;
name|htab
operator|.
name|put
argument_list|(
name|puts
argument_list|)
expr_stmt|;
name|conn
operator|.
name|flush
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
comment|// Finally, walk the table table
name|puts
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|Database
name|db
range|:
name|dbs
control|)
block|{
name|List
argument_list|<
name|Table
argument_list|>
name|tables
init|=
name|scanTables
argument_list|(
name|db
operator|.
name|getName
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|tables
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Table
name|table
range|:
name|tables
control|)
block|{
if|if
condition|(
name|table
operator|.
name|getPrivileges
argument_list|()
operator|!=
literal|null
operator|&&
name|table
operator|.
name|getPrivileges
argument_list|()
operator|.
name|getRolePrivileges
argument_list|()
operator|!=
literal|null
operator|&&
name|table
operator|.
name|getPrivileges
argument_list|()
operator|.
name|getRolePrivileges
argument_list|()
operator|.
name|remove
argument_list|(
name|roleName
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
index|[]
name|serialized
init|=
name|HBaseUtils
operator|.
name|serializeTable
argument_list|(
name|table
argument_list|,
name|HBaseUtils
operator|.
name|hashStorageDescriptor
argument_list|(
name|table
operator|.
name|getSd
argument_list|()
argument_list|,
name|md
argument_list|)
argument_list|)
decl_stmt|;
name|Put
name|put
init|=
operator|new
name|Put
argument_list|(
name|serialized
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|put
operator|.
name|add
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|serialized
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|puts
operator|.
name|add
argument_list|(
name|put
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|puts
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|HTableInterface
name|htab
init|=
name|conn
operator|.
name|getHBaseTable
argument_list|(
name|TABLE_TABLE
argument_list|)
decl_stmt|;
name|htab
operator|.
name|put
argument_list|(
name|puts
argument_list|)
expr_stmt|;
name|conn
operator|.
name|flush
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Fetch a role    * @param roleName name of the role    * @return role object, or null if no such role    * @throws IOException    */
name|Role
name|getRole
parameter_list|(
name|String
name|roleName
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|roleName
argument_list|)
decl_stmt|;
name|byte
index|[]
name|serialized
init|=
name|read
argument_list|(
name|ROLE_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|HBaseUtils
operator|.
name|deserializeRole
argument_list|(
name|roleName
argument_list|,
name|serialized
argument_list|)
return|;
block|}
comment|/**    * Get a list of roles.    * @return list of all known roles.    * @throws IOException    */
name|List
argument_list|<
name|Role
argument_list|>
name|scanRoles
parameter_list|()
throws|throws
name|IOException
block|{
name|Iterator
argument_list|<
name|Result
argument_list|>
name|iter
init|=
name|scan
argument_list|(
name|ROLE_TABLE
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Role
argument_list|>
name|roles
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Result
name|result
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|roles
operator|.
name|add
argument_list|(
name|HBaseUtils
operator|.
name|deserializeRole
argument_list|(
name|result
operator|.
name|getRow
argument_list|()
argument_list|,
name|result
operator|.
name|getValue
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|roles
return|;
block|}
comment|/**    * Add a new role    * @param role role object    * @throws IOException    */
name|void
name|putRole
parameter_list|(
name|Role
name|role
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
index|[]
name|serialized
init|=
name|HBaseUtils
operator|.
name|serializeRole
argument_list|(
name|role
argument_list|)
decl_stmt|;
name|store
argument_list|(
name|ROLE_TABLE
argument_list|,
name|serialized
index|[
literal|0
index|]
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|serialized
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/**    * Drop a role    * @param roleName name of role to drop    * @throws IOException    */
name|void
name|deleteRole
parameter_list|(
name|String
name|roleName
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|roleName
argument_list|)
decl_stmt|;
name|delete
argument_list|(
name|ROLE_TABLE
argument_list|,
name|key
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|roleCache
operator|.
name|remove
argument_list|(
name|roleName
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|buildRoleCache
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|entireRoleTableInCache
condition|)
block|{
name|Iterator
argument_list|<
name|Result
argument_list|>
name|roles
init|=
name|scan
argument_list|(
name|ROLE_TABLE
argument_list|,
name|CATALOG_CF
argument_list|,
name|ROLES_COL
argument_list|)
decl_stmt|;
while|while
condition|(
name|roles
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Result
name|res
init|=
name|roles
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|roleName
init|=
operator|new
name|String
argument_list|(
name|res
operator|.
name|getRow
argument_list|()
argument_list|,
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
decl_stmt|;
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfoList
name|grantInfos
init|=
name|HbaseMetastoreProto
operator|.
name|RoleGrantInfoList
operator|.
name|parseFrom
argument_list|(
name|res
operator|.
name|getValue
argument_list|(
name|CATALOG_CF
argument_list|,
name|ROLES_COL
argument_list|)
argument_list|)
decl_stmt|;
name|roleCache
operator|.
name|put
argument_list|(
name|roleName
argument_list|,
name|grantInfos
argument_list|)
expr_stmt|;
block|}
name|entireRoleTableInCache
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/**********************************************************************************************    * Table related methods    *********************************************************************************************/
comment|/**    * Fetch a table object    * @param dbName database the table is in    * @param tableName table name    * @return Table object, or null if no such table    * @throws IOException    */
name|Table
name|getTable
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getTable
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Fetch a list of table objects.    * @param dbName Database that all fetched tables are in    * @param tableNames list of table names    * @return list of tables, in the same order as the provided names.    * @throws IOException    */
name|List
argument_list|<
name|Table
argument_list|>
name|getTables
parameter_list|(
name|String
name|dbName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|tableNames
parameter_list|)
throws|throws
name|IOException
block|{
comment|// I could implement getTable in terms of this method.  But it is such a core function
comment|// that I don't want to slow it down for the much less common fetching of multiple tables.
name|List
argument_list|<
name|Table
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|tableNames
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|ObjectPair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
index|[]
name|hashKeys
init|=
operator|new
name|ObjectPair
index|[
name|tableNames
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|boolean
name|atLeastOneMissing
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tableNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|hashKeys
index|[
name|i
index|]
operator|=
operator|new
name|ObjectPair
argument_list|<>
argument_list|(
name|dbName
argument_list|,
name|tableNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|// The result may be null, but we still want to add it so that we have a slot in the list
comment|// for it.
name|results
operator|.
name|add
argument_list|(
name|tableCache
operator|.
name|get
argument_list|(
name|hashKeys
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|==
literal|null
condition|)
name|atLeastOneMissing
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|atLeastOneMissing
condition|)
return|return
name|results
return|;
comment|// Now build a single get that will fetch the remaining tables
name|List
argument_list|<
name|Get
argument_list|>
name|gets
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|HTableInterface
name|htab
init|=
name|conn
operator|.
name|getHBaseTable
argument_list|(
name|TABLE_TABLE
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tableNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|results
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|!=
literal|null
condition|)
continue|continue;
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|dbName
argument_list|,
name|tableNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|Get
name|g
init|=
operator|new
name|Get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|g
operator|.
name|addColumn
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
expr_stmt|;
name|gets
operator|.
name|add
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
name|Result
index|[]
name|res
init|=
name|htab
operator|.
name|get
argument_list|(
name|gets
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|nextGet
init|=
literal|0
init|;
name|i
operator|<
name|tableNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|results
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|!=
literal|null
condition|)
continue|continue;
name|byte
index|[]
name|serialized
init|=
name|res
index|[
name|nextGet
operator|++
index|]
operator|.
name|getValue
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|!=
literal|null
condition|)
block|{
name|HBaseUtils
operator|.
name|StorageDescriptorParts
name|sdParts
init|=
name|HBaseUtils
operator|.
name|deserializeTable
argument_list|(
name|dbName
argument_list|,
name|tableNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|serialized
argument_list|)
decl_stmt|;
name|StorageDescriptor
name|sd
init|=
name|getStorageDescriptor
argument_list|(
name|sdParts
operator|.
name|sdHash
argument_list|)
decl_stmt|;
name|HBaseUtils
operator|.
name|assembleStorageDescriptor
argument_list|(
name|sd
argument_list|,
name|sdParts
argument_list|)
expr_stmt|;
name|tableCache
operator|.
name|put
argument_list|(
name|hashKeys
index|[
name|i
index|]
argument_list|,
name|sdParts
operator|.
name|containingTable
argument_list|)
expr_stmt|;
name|results
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|sdParts
operator|.
name|containingTable
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|results
return|;
block|}
comment|/**    * Get a list of tables.    * @param dbName Database these tables are in    * @param regex Regular expression to use in searching for table names.  It is expected to    *              be a Java regular expression.  If it is null then all tables in the indicated    *              database will be returned.    * @return list of tables matching the regular expression.    * @throws IOException    */
name|List
argument_list|<
name|Table
argument_list|>
name|scanTables
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|regex
parameter_list|)
throws|throws
name|IOException
block|{
comment|// There's no way to know whether all the tables we are looking for are
comment|// in the cache, so we would need to scan one way or another.  Thus there's no value in hitting
comment|// the cache for this function.
name|byte
index|[]
name|keyPrefix
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|dbName
operator|!=
literal|null
condition|)
block|{
name|keyPrefix
operator|=
name|HBaseUtils
operator|.
name|buildKeyWithTrailingSeparator
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
block|}
name|Filter
name|filter
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|regex
operator|!=
literal|null
condition|)
block|{
name|filter
operator|=
operator|new
name|RowFilter
argument_list|(
name|CompareFilter
operator|.
name|CompareOp
operator|.
name|EQUAL
argument_list|,
operator|new
name|RegexStringComparator
argument_list|(
name|regex
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|Result
argument_list|>
name|iter
init|=
name|scan
argument_list|(
name|TABLE_TABLE
argument_list|,
name|keyPrefix
argument_list|,
name|HBaseUtils
operator|.
name|getEndPrefix
argument_list|(
name|keyPrefix
argument_list|)
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Table
argument_list|>
name|tables
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Result
name|result
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|HBaseUtils
operator|.
name|StorageDescriptorParts
name|sdParts
init|=
name|HBaseUtils
operator|.
name|deserializeTable
argument_list|(
name|result
operator|.
name|getRow
argument_list|()
argument_list|,
name|result
operator|.
name|getValue
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
argument_list|)
decl_stmt|;
name|StorageDescriptor
name|sd
init|=
name|getStorageDescriptor
argument_list|(
name|sdParts
operator|.
name|sdHash
argument_list|)
decl_stmt|;
name|HBaseUtils
operator|.
name|assembleStorageDescriptor
argument_list|(
name|sd
argument_list|,
name|sdParts
argument_list|)
expr_stmt|;
name|tables
operator|.
name|add
argument_list|(
name|sdParts
operator|.
name|containingTable
argument_list|)
expr_stmt|;
block|}
return|return
name|tables
return|;
block|}
comment|/**    * Put a table object.  This should only be called when the table is new (create table) as it    * will blindly add/increment the storage descriptor.  If you are altering an existing table    * call {@link #replaceTable} instead.    * @param table table object    * @throws IOException    */
name|void
name|putTable
parameter_list|(
name|Table
name|table
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|hash
init|=
name|putStorageDescriptor
argument_list|(
name|table
operator|.
name|getSd
argument_list|()
argument_list|)
decl_stmt|;
name|byte
index|[]
index|[]
name|serialized
init|=
name|HBaseUtils
operator|.
name|serializeTable
argument_list|(
name|table
argument_list|,
name|hash
argument_list|)
decl_stmt|;
name|store
argument_list|(
name|TABLE_TABLE
argument_list|,
name|serialized
index|[
literal|0
index|]
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|serialized
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|tableCache
operator|.
name|put
argument_list|(
operator|new
name|ObjectPair
argument_list|<>
argument_list|(
name|table
operator|.
name|getDbName
argument_list|()
argument_list|,
name|table
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
comment|/**    * Replace an existing table.  This will also compare the storage descriptors and see if the    * reference count needs to be adjusted    * @param oldTable old version of the table    * @param newTable new version of the table    */
name|void
name|replaceTable
parameter_list|(
name|Table
name|oldTable
parameter_list|,
name|Table
name|newTable
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|hash
decl_stmt|;
name|byte
index|[]
name|oldHash
init|=
name|HBaseUtils
operator|.
name|hashStorageDescriptor
argument_list|(
name|oldTable
operator|.
name|getSd
argument_list|()
argument_list|,
name|md
argument_list|)
decl_stmt|;
name|byte
index|[]
name|newHash
init|=
name|HBaseUtils
operator|.
name|hashStorageDescriptor
argument_list|(
name|newTable
operator|.
name|getSd
argument_list|()
argument_list|,
name|md
argument_list|)
decl_stmt|;
if|if
condition|(
name|Arrays
operator|.
name|equals
argument_list|(
name|oldHash
argument_list|,
name|newHash
argument_list|)
condition|)
block|{
name|hash
operator|=
name|oldHash
expr_stmt|;
block|}
else|else
block|{
name|decrementStorageDescriptorRefCount
argument_list|(
name|oldTable
operator|.
name|getSd
argument_list|()
argument_list|)
expr_stmt|;
name|hash
operator|=
name|putStorageDescriptor
argument_list|(
name|newTable
operator|.
name|getSd
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
index|[]
name|serialized
init|=
name|HBaseUtils
operator|.
name|serializeTable
argument_list|(
name|newTable
argument_list|,
name|hash
argument_list|)
decl_stmt|;
name|store
argument_list|(
name|TABLE_TABLE
argument_list|,
name|serialized
index|[
literal|0
index|]
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|serialized
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|tableCache
operator|.
name|put
argument_list|(
operator|new
name|ObjectPair
argument_list|<>
argument_list|(
name|newTable
operator|.
name|getDbName
argument_list|()
argument_list|,
name|newTable
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|,
name|newTable
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oldTable
operator|.
name|getTableName
argument_list|()
operator|.
name|equals
argument_list|(
name|newTable
operator|.
name|getTableName
argument_list|()
argument_list|)
condition|)
block|{
name|deleteTable
argument_list|(
name|oldTable
operator|.
name|getDbName
argument_list|()
argument_list|,
name|oldTable
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Delete a table    * @param dbName name of database table is in    * @param tableName table to drop    * @throws IOException    */
name|void
name|deleteTable
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|deleteTable
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|deleteTable
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|boolean
name|decrementRefCnt
parameter_list|)
throws|throws
name|IOException
block|{
name|tableCache
operator|.
name|remove
argument_list|(
operator|new
name|ObjectPair
argument_list|<>
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|decrementRefCnt
condition|)
block|{
comment|// Find the table so I can get the storage descriptor and drop it
name|Table
name|t
init|=
name|getTable
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|decrementStorageDescriptorRefCount
argument_list|(
name|t
operator|.
name|getSd
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
name|delete
argument_list|(
name|TABLE_TABLE
argument_list|,
name|key
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Table
name|getTable
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|boolean
name|populateCache
parameter_list|)
throws|throws
name|IOException
block|{
name|ObjectPair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|hashKey
init|=
operator|new
name|ObjectPair
argument_list|<>
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
name|Table
name|cached
init|=
name|tableCache
operator|.
name|get
argument_list|(
name|hashKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|cached
operator|!=
literal|null
condition|)
return|return
name|cached
return|;
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
name|byte
index|[]
name|serialized
init|=
name|read
argument_list|(
name|TABLE_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|HBaseUtils
operator|.
name|StorageDescriptorParts
name|sdParts
init|=
name|HBaseUtils
operator|.
name|deserializeTable
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|serialized
argument_list|)
decl_stmt|;
name|StorageDescriptor
name|sd
init|=
name|getStorageDescriptor
argument_list|(
name|sdParts
operator|.
name|sdHash
argument_list|)
decl_stmt|;
name|HBaseUtils
operator|.
name|assembleStorageDescriptor
argument_list|(
name|sd
argument_list|,
name|sdParts
argument_list|)
expr_stmt|;
if|if
condition|(
name|populateCache
condition|)
name|tableCache
operator|.
name|put
argument_list|(
name|hashKey
argument_list|,
name|sdParts
operator|.
name|containingTable
argument_list|)
expr_stmt|;
return|return
name|sdParts
operator|.
name|containingTable
return|;
block|}
comment|/**********************************************************************************************    * StorageDescriptor related methods    *********************************************************************************************/
comment|/**    * If this serde has already been read, then return it from the cache.  If not, read it, then    * return it.    * @param hash hash of the storage descriptor to read    * @return the storage descriptor    * @throws IOException    */
name|StorageDescriptor
name|getStorageDescriptor
parameter_list|(
name|byte
index|[]
name|hash
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteArrayWrapper
name|hashKey
init|=
operator|new
name|ByteArrayWrapper
argument_list|(
name|hash
argument_list|)
decl_stmt|;
name|StorageDescriptor
name|cached
init|=
name|sdCache
operator|.
name|get
argument_list|(
name|hashKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|cached
operator|!=
literal|null
condition|)
return|return
name|cached
return|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not found in cache, looking in hbase"
argument_list|)
expr_stmt|;
name|byte
index|[]
name|serialized
init|=
name|read
argument_list|(
name|SD_TABLE
argument_list|,
name|hash
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Woh, bad!  Trying to fetch a non-existent storage descriptor "
operator|+
literal|"from hash "
operator|+
name|Base64
operator|.
name|encodeBase64String
argument_list|(
name|hash
argument_list|)
argument_list|)
throw|;
block|}
name|StorageDescriptor
name|sd
init|=
name|HBaseUtils
operator|.
name|deserializeStorageDescriptor
argument_list|(
name|serialized
argument_list|)
decl_stmt|;
name|sdCache
operator|.
name|put
argument_list|(
name|hashKey
argument_list|,
name|sd
argument_list|)
expr_stmt|;
return|return
name|sd
return|;
block|}
comment|/**    * Lower the reference count on the storage descriptor by one.  If it goes to zero, then it    * will be deleted.    * @param sd Storage descriptor    * @throws IOException    */
name|void
name|decrementStorageDescriptorRefCount
parameter_list|(
name|StorageDescriptor
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|hashStorageDescriptor
argument_list|(
name|sd
argument_list|,
name|md
argument_list|)
decl_stmt|;
name|byte
index|[]
name|serializedRefCnt
init|=
name|read
argument_list|(
name|SD_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|REF_COUNT_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serializedRefCnt
operator|==
literal|null
condition|)
block|{
comment|// Someone deleted it before we got to it, no worries
return|return;
block|}
name|int
name|refCnt
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
operator|new
name|String
argument_list|(
name|serializedRefCnt
argument_list|,
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
argument_list|)
decl_stmt|;
name|HTableInterface
name|htab
init|=
name|conn
operator|.
name|getHBaseTable
argument_list|(
name|SD_TABLE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|--
name|refCnt
operator|<
literal|1
condition|)
block|{
name|Delete
name|d
init|=
operator|new
name|Delete
argument_list|(
name|key
argument_list|)
decl_stmt|;
comment|// We don't use checkAndDelete here because it isn't compatible with the transaction
comment|// managers.  If the transaction managers are doing their jobs then we should not need it
comment|// anyway.
name|htab
operator|.
name|delete
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|sdCache
operator|.
name|remove
argument_list|(
operator|new
name|ByteArrayWrapper
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Put
name|p
init|=
operator|new
name|Put
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|p
operator|.
name|add
argument_list|(
name|CATALOG_CF
argument_list|,
name|REF_COUNT_COL
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|refCnt
argument_list|)
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
argument_list|)
expr_stmt|;
name|htab
operator|.
name|put
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|conn
operator|.
name|flush
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Place the common parts of a storage descriptor into the cache and write the storage    * descriptor out to HBase.  This should only be called if you are sure that the storage    * descriptor needs to be added.  If you have changed a table or partition but not it's storage    * descriptor do not call this method, as it will increment the reference count of the storage    * descriptor.    * @param storageDescriptor storage descriptor to store.    * @return id of the entry in the cache, to be written in for the storage descriptor    */
name|byte
index|[]
name|putStorageDescriptor
parameter_list|(
name|StorageDescriptor
name|storageDescriptor
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|sd
init|=
name|HBaseUtils
operator|.
name|serializeStorageDescriptor
argument_list|(
name|storageDescriptor
argument_list|)
decl_stmt|;
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|hashStorageDescriptor
argument_list|(
name|storageDescriptor
argument_list|,
name|md
argument_list|)
decl_stmt|;
name|byte
index|[]
name|serializedRefCnt
init|=
name|read
argument_list|(
name|SD_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|REF_COUNT_COL
argument_list|)
decl_stmt|;
name|HTableInterface
name|htab
init|=
name|conn
operator|.
name|getHBaseTable
argument_list|(
name|SD_TABLE
argument_list|)
decl_stmt|;
if|if
condition|(
name|serializedRefCnt
operator|==
literal|null
condition|)
block|{
comment|// We are the first to put it in the DB
name|Put
name|p
init|=
operator|new
name|Put
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|p
operator|.
name|add
argument_list|(
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|p
operator|.
name|add
argument_list|(
name|CATALOG_CF
argument_list|,
name|REF_COUNT_COL
argument_list|,
literal|"1"
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
argument_list|)
expr_stmt|;
name|htab
operator|.
name|put
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sdCache
operator|.
name|put
argument_list|(
operator|new
name|ByteArrayWrapper
argument_list|(
name|key
argument_list|)
argument_list|,
name|storageDescriptor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Just increment the reference count
name|int
name|refCnt
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
operator|new
name|String
argument_list|(
name|serializedRefCnt
argument_list|,
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
argument_list|)
operator|+
literal|1
decl_stmt|;
name|Put
name|p
init|=
operator|new
name|Put
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|p
operator|.
name|add
argument_list|(
name|CATALOG_CF
argument_list|,
name|REF_COUNT_COL
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|refCnt
argument_list|)
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
argument_list|)
expr_stmt|;
name|htab
operator|.
name|put
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|conn
operator|.
name|flush
argument_list|(
name|htab
argument_list|)
expr_stmt|;
return|return
name|key
return|;
block|}
specifier|private
specifier|static
class|class
name|ByteArrayWrapper
block|{
name|byte
index|[]
name|wrapped
decl_stmt|;
name|ByteArrayWrapper
parameter_list|(
name|byte
index|[]
name|b
parameter_list|)
block|{
name|wrapped
operator|=
name|b
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|instanceof
name|ByteArrayWrapper
condition|)
block|{
return|return
name|Arrays
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteArrayWrapper
operator|)
name|other
operator|)
operator|.
name|wrapped
argument_list|,
name|wrapped
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Arrays
operator|.
name|hashCode
argument_list|(
name|wrapped
argument_list|)
return|;
block|}
block|}
comment|/**********************************************************************************************    * Statistics related methods    *********************************************************************************************/
comment|/**    * Update statistics for one or more columns for a table or a partition.    *    * @param dbName database the table is in    * @param tableName table to update statistics for    * @param partVals partition values that define partition to update statistics for. If this is    *          null, then these will be assumed to be table level statistics    * @param stats Stats object with stats for one or more columns    * @throws IOException    */
name|void
name|updateStatistics
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partVals
parameter_list|,
name|ColumnStatistics
name|stats
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|getStatisticsKey
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partVals
argument_list|)
decl_stmt|;
name|String
name|hbaseTable
init|=
name|getStatisticsTable
argument_list|(
name|partVals
argument_list|)
decl_stmt|;
name|byte
index|[]
index|[]
name|colnames
init|=
operator|new
name|byte
index|[
name|stats
operator|.
name|getStatsObjSize
argument_list|()
index|]
index|[]
decl_stmt|;
name|byte
index|[]
index|[]
name|serialized
init|=
operator|new
name|byte
index|[
name|stats
operator|.
name|getStatsObjSize
argument_list|()
index|]
index|[]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stats
operator|.
name|getStatsObjSize
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ColumnStatisticsObj
name|obj
init|=
name|stats
operator|.
name|getStatsObj
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|serialized
index|[
name|i
index|]
operator|=
name|HBaseUtils
operator|.
name|serializeStatsForOneColumn
argument_list|(
name|stats
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|String
name|colname
init|=
name|obj
operator|.
name|getColName
argument_list|()
decl_stmt|;
name|colnames
index|[
name|i
index|]
operator|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|colname
argument_list|)
expr_stmt|;
block|}
name|store
argument_list|(
name|hbaseTable
argument_list|,
name|key
argument_list|,
name|STATS_CF
argument_list|,
name|colnames
argument_list|,
name|serialized
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get statistics for a table    *    * @param dbName name of database table is in    * @param tblName name of table    * @param colNames list of column names to get statistics for    * @return column statistics for indicated table    * @throws IOException    */
name|ColumnStatistics
name|getTableStatistics
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tblName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|tabKey
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|dbName
argument_list|,
name|tblName
argument_list|)
decl_stmt|;
name|ColumnStatistics
name|tableStats
init|=
operator|new
name|ColumnStatistics
argument_list|()
decl_stmt|;
name|ColumnStatisticsDesc
name|statsDesc
init|=
operator|new
name|ColumnStatisticsDesc
argument_list|()
decl_stmt|;
name|statsDesc
operator|.
name|setIsTblLevel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|statsDesc
operator|.
name|setDbName
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|statsDesc
operator|.
name|setTableName
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
name|tableStats
operator|.
name|setStatsDesc
argument_list|(
name|statsDesc
argument_list|)
expr_stmt|;
name|byte
index|[]
index|[]
name|colKeys
init|=
operator|new
name|byte
index|[
name|colNames
operator|.
name|size
argument_list|()
index|]
index|[]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|colKeys
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|colKeys
index|[
name|i
index|]
operator|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|colNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Result
name|result
init|=
name|read
argument_list|(
name|TABLE_TABLE
argument_list|,
name|tabKey
argument_list|,
name|STATS_CF
argument_list|,
name|colKeys
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|colKeys
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|byte
index|[]
name|serializedColStats
init|=
name|result
operator|.
name|getValue
argument_list|(
name|STATS_CF
argument_list|,
name|colKeys
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|serializedColStats
operator|==
literal|null
condition|)
block|{
comment|// There were no stats for this column, so skip it
continue|continue;
block|}
name|ColumnStatisticsObj
name|obj
init|=
name|HBaseUtils
operator|.
name|deserializeStatsForOneColumn
argument_list|(
name|tableStats
argument_list|,
name|serializedColStats
argument_list|)
decl_stmt|;
name|obj
operator|.
name|setColName
argument_list|(
name|colNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|tableStats
operator|.
name|addToStatsObj
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
return|return
name|tableStats
return|;
block|}
comment|/**    * Get statistics for a set of partitions    *    * @param dbName name of database table is in    * @param tblName table partitions are in    * @param partNames names of the partitions, used only to set values inside the return stats    *          objects    * @param partVals partition values for each partition, needed because this class doesn't know how    *          to translate from partName to partVals    * @param colNames column names to fetch stats for. These columns will be fetched for all    *          requested partitions    * @return list of ColumnStats, one for each partition for which we found at least one column's    * stats.    * @throws IOException    */
name|List
argument_list|<
name|ColumnStatistics
argument_list|>
name|getPartitionStatistics
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tblName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|,
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|partVals
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|ColumnStatistics
argument_list|>
name|statsList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|partNames
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|String
argument_list|>
name|valToPartMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|partNames
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Get
argument_list|>
name|gets
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|partNames
operator|.
name|size
argument_list|()
operator|*
name|colNames
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|partNames
operator|.
name|size
argument_list|()
operator|==
name|partVals
operator|.
name|size
argument_list|()
assert|;
name|byte
index|[]
index|[]
name|colNameBytes
init|=
operator|new
name|byte
index|[
name|colNames
operator|.
name|size
argument_list|()
index|]
index|[]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|colNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|colNameBytes
index|[
name|i
index|]
operator|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|colNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|valToPartMap
operator|.
name|put
argument_list|(
name|partVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|partNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|byte
index|[]
name|partKey
init|=
name|HBaseUtils
operator|.
name|buildPartitionKey
argument_list|(
name|dbName
argument_list|,
name|tblName
argument_list|,
name|HBaseUtils
operator|.
name|getPartitionKeyTypes
argument_list|(
name|getTable
argument_list|(
name|dbName
argument_list|,
name|tblName
argument_list|)
operator|.
name|getPartitionKeys
argument_list|()
argument_list|)
argument_list|,
name|partVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|Get
name|get
init|=
operator|new
name|Get
argument_list|(
name|partKey
argument_list|)
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|colName
range|:
name|colNameBytes
control|)
block|{
name|get
operator|.
name|addColumn
argument_list|(
name|STATS_CF
argument_list|,
name|colName
argument_list|)
expr_stmt|;
block|}
name|gets
operator|.
name|add
argument_list|(
name|get
argument_list|)
expr_stmt|;
block|}
name|HTableInterface
name|htab
init|=
name|conn
operator|.
name|getHBaseTable
argument_list|(
name|PART_TABLE
argument_list|)
decl_stmt|;
name|Result
index|[]
name|results
init|=
name|htab
operator|.
name|get
argument_list|(
name|gets
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|results
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ColumnStatistics
name|colStats
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|colNameBytes
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|byte
index|[]
name|serializedColStats
init|=
name|results
index|[
name|i
index|]
operator|.
name|getValue
argument_list|(
name|STATS_CF
argument_list|,
name|colNameBytes
index|[
name|j
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|serializedColStats
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|colStats
operator|==
literal|null
condition|)
block|{
comment|// We initialize this late so that we don't create extras in the case of
comment|// partitions with no stats
name|colStats
operator|=
operator|new
name|ColumnStatistics
argument_list|()
expr_stmt|;
name|statsList
operator|.
name|add
argument_list|(
name|colStats
argument_list|)
expr_stmt|;
name|ColumnStatisticsDesc
name|csd
init|=
operator|new
name|ColumnStatisticsDesc
argument_list|()
decl_stmt|;
comment|// We need to figure out which partition these call stats are from.  To do that we
comment|// recontruct the key.  We have to pull the dbName and tableName out of the key to
comment|// find the partition values.
name|byte
index|[]
name|key
init|=
name|results
index|[
name|i
index|]
operator|.
name|getRow
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|reconstructedPartVals
init|=
name|HBaseUtils
operator|.
name|deserializePartitionKey
argument_list|(
name|getTable
argument_list|(
name|dbName
argument_list|,
name|tblName
argument_list|)
operator|.
name|getPartitionKeys
argument_list|()
argument_list|,
name|key
argument_list|,
name|staticConf
argument_list|)
decl_stmt|;
name|String
name|partName
init|=
name|valToPartMap
operator|.
name|get
argument_list|(
name|reconstructedPartVals
argument_list|)
decl_stmt|;
assert|assert
name|partName
operator|!=
literal|null
assert|;
name|csd
operator|.
name|setIsTblLevel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|csd
operator|.
name|setDbName
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|csd
operator|.
name|setTableName
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
name|csd
operator|.
name|setPartName
argument_list|(
name|partName
argument_list|)
expr_stmt|;
name|colStats
operator|.
name|setStatsDesc
argument_list|(
name|csd
argument_list|)
expr_stmt|;
block|}
name|ColumnStatisticsObj
name|cso
init|=
name|HBaseUtils
operator|.
name|deserializeStatsForOneColumn
argument_list|(
name|colStats
argument_list|,
name|serializedColStats
argument_list|)
decl_stmt|;
name|cso
operator|.
name|setColName
argument_list|(
name|colNames
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|colStats
operator|.
name|addToStatsObj
argument_list|(
name|cso
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|statsList
return|;
block|}
comment|/**    * Get a reference to the stats cache.    * @return the stats cache.    */
name|StatsCache
name|getStatsCache
parameter_list|()
block|{
return|return
name|statsCache
return|;
block|}
comment|/**    * Get aggregated stats.  Only intended for use by    * {@link org.apache.hadoop.hive.metastore.hbase.StatsCache}.  Others should not call directly    * but should call StatsCache.get instead.    * @param key The md5 hash associated with this partition set    * @return stats if hbase has them, else null    * @throws IOException    */
name|AggrStats
name|getAggregatedStats
parameter_list|(
name|byte
index|[]
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|serialized
init|=
name|read
argument_list|(
name|AGGR_STATS_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|AGGR_STATS_STATS_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|HBaseUtils
operator|.
name|deserializeAggrStats
argument_list|(
name|serialized
argument_list|)
return|;
block|}
comment|/**    * Put aggregated stats  Only intended for use by    * {@link org.apache.hadoop.hive.metastore.hbase.StatsCache}.  Others should not call directly    * but should call StatsCache.put instead.    * @param key The md5 hash associated with this partition set    * @param dbName Database these partitions are in    * @param tableName Table these partitions are in    * @param partNames Partition names    * @param colName Column stats are for    * @param stats Stats    * @throws IOException    */
name|void
name|putAggregatedStats
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|,
name|String
name|colName
parameter_list|,
name|AggrStats
name|stats
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Serialize the part names
name|List
argument_list|<
name|String
argument_list|>
name|protoNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|partNames
operator|.
name|size
argument_list|()
operator|+
literal|3
argument_list|)
decl_stmt|;
name|protoNames
operator|.
name|add
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|protoNames
operator|.
name|add
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|protoNames
operator|.
name|add
argument_list|(
name|colName
argument_list|)
expr_stmt|;
name|protoNames
operator|.
name|addAll
argument_list|(
name|partNames
argument_list|)
expr_stmt|;
comment|// Build a bloom Filter for these partitions
name|BloomFilter
name|bloom
init|=
operator|new
name|BloomFilter
argument_list|(
name|partNames
operator|.
name|size
argument_list|()
argument_list|,
name|STATS_BF_ERROR_RATE
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|partName
range|:
name|partNames
control|)
block|{
name|bloom
operator|.
name|add
argument_list|(
name|partName
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|serializedFilter
init|=
name|HBaseUtils
operator|.
name|serializeBloomFilter
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|bloom
argument_list|)
decl_stmt|;
name|byte
index|[]
name|serializedStats
init|=
name|HBaseUtils
operator|.
name|serializeAggrStats
argument_list|(
name|stats
argument_list|)
decl_stmt|;
name|store
argument_list|(
name|AGGR_STATS_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
operator|new
name|byte
index|[]
index|[]
block|{
name|AGGR_STATS_BLOOM_COL
block|,
name|AGGR_STATS_STATS_COL
block|}
argument_list|,
operator|new
name|byte
index|[]
index|[]
block|{
name|serializedFilter
block|,
name|serializedStats
block|}
argument_list|)
expr_stmt|;
block|}
comment|// TODO - We shouldn't remove an entry from the cache as soon as a single partition is deleted.
comment|// TODO - Instead we should keep track of how many partitions have been deleted and only remove
comment|// TODO - an entry once it passes a certain threshold, like 5%, of partitions have been removed.
comment|// TODO - That requires moving this from a filter to a co-processor.
comment|/**    * Invalidate stats associated with the listed partitions.  This method is intended for use    * only by {@link org.apache.hadoop.hive.metastore.hbase.StatsCache}.    * @param filter serialized version of the filter to pass    * @return List of md5 hash keys for the partition stat sets that were removed.    * @throws IOException    */
name|List
argument_list|<
name|StatsCache
operator|.
name|StatsCacheKey
argument_list|>
name|invalidateAggregatedStats
parameter_list|(
name|HbaseMetastoreProto
operator|.
name|AggrStatsInvalidatorFilter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|Iterator
argument_list|<
name|Result
argument_list|>
name|results
init|=
name|scan
argument_list|(
name|AGGR_STATS_TABLE
argument_list|,
operator|new
name|AggrStatsInvalidatorFilter
argument_list|(
name|filter
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|results
operator|.
name|hasNext
argument_list|()
condition|)
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
name|List
argument_list|<
name|Delete
argument_list|>
name|deletes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|StatsCache
operator|.
name|StatsCacheKey
argument_list|>
name|keys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|results
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Result
name|result
init|=
name|results
operator|.
name|next
argument_list|()
decl_stmt|;
name|deletes
operator|.
name|add
argument_list|(
operator|new
name|Delete
argument_list|(
name|result
operator|.
name|getRow
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|keys
operator|.
name|add
argument_list|(
operator|new
name|StatsCache
operator|.
name|StatsCacheKey
argument_list|(
name|result
operator|.
name|getRow
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|HTableInterface
name|htab
init|=
name|conn
operator|.
name|getHBaseTable
argument_list|(
name|AGGR_STATS_TABLE
argument_list|)
decl_stmt|;
name|htab
operator|.
name|delete
argument_list|(
name|deletes
argument_list|)
expr_stmt|;
return|return
name|keys
return|;
block|}
specifier|private
name|byte
index|[]
name|getStatisticsKey
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partVals
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|partVals
operator|==
literal|null
condition|?
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
else|:
name|HBaseUtils
operator|.
name|buildPartitionKey
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|HBaseUtils
operator|.
name|getPartitionKeyTypes
argument_list|(
name|getTable
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
operator|.
name|getPartitionKeys
argument_list|()
argument_list|)
argument_list|,
name|partVals
argument_list|)
return|;
block|}
specifier|private
name|String
name|getStatisticsTable
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|partVals
parameter_list|)
block|{
return|return
name|partVals
operator|==
literal|null
condition|?
name|TABLE_TABLE
else|:
name|PART_TABLE
return|;
block|}
comment|/**********************************************************************************************    * File metadata related methods    *********************************************************************************************/
comment|/**    * @param fileIds file ID list.    * @return Serialized file metadata.    */
name|ByteBuffer
index|[]
name|getFileMetadata
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|fileIds
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
index|[]
name|keys
init|=
operator|new
name|byte
index|[
name|fileIds
operator|.
name|size
argument_list|()
index|]
index|[]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileIds
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|keys
index|[
name|i
index|]
operator|=
name|HBaseUtils
operator|.
name|makeLongKey
argument_list|(
name|fileIds
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ByteBuffer
index|[]
name|result
init|=
operator|new
name|ByteBuffer
index|[
name|keys
operator|.
name|length
index|]
decl_stmt|;
name|multiRead
argument_list|(
name|FILE_METADATA_TABLE
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|keys
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * @param fileIds file ID list.    * @param metadata Serialized file metadata.    */
name|void
name|storeFileMetadata
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|fileIds
parameter_list|,
name|List
argument_list|<
name|ByteBuffer
argument_list|>
name|metadata
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|byte
index|[]
index|[]
name|keys
init|=
operator|new
name|byte
index|[
name|fileIds
operator|.
name|size
argument_list|()
index|]
index|[]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileIds
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|keys
index|[
name|i
index|]
operator|=
name|HBaseUtils
operator|.
name|makeLongKey
argument_list|(
name|fileIds
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|multiModify
argument_list|(
name|FILE_METADATA_TABLE
argument_list|,
name|keys
argument_list|,
name|CATALOG_CF
argument_list|,
name|CATALOG_COL
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
comment|/**********************************************************************************************    * Security related methods    *********************************************************************************************/
comment|/**    * Fetch a delegation token    * @param tokId identifier of the token to fetch    * @return the delegation token, or null if there is no such delegation token    * @throws IOException    */
name|String
name|getDelegationToken
parameter_list|(
name|String
name|tokId
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|tokId
argument_list|)
decl_stmt|;
name|byte
index|[]
name|serialized
init|=
name|read
argument_list|(
name|SECURITY_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|DELEGATION_TOKEN_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|HBaseUtils
operator|.
name|deserializeDelegationToken
argument_list|(
name|serialized
argument_list|)
return|;
block|}
comment|/**    * Get all delegation token ids    * @return list of all delegation token identifiers    * @throws IOException    */
name|List
argument_list|<
name|String
argument_list|>
name|scanDelegationTokenIdentifiers
parameter_list|()
throws|throws
name|IOException
block|{
name|Iterator
argument_list|<
name|Result
argument_list|>
name|iter
init|=
name|scan
argument_list|(
name|SECURITY_TABLE
argument_list|,
name|CATALOG_CF
argument_list|,
name|DELEGATION_TOKEN_COL
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|ids
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Result
name|result
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|byte
index|[]
name|serialized
init|=
name|result
operator|.
name|getValue
argument_list|(
name|CATALOG_CF
argument_list|,
name|DELEGATION_TOKEN_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|!=
literal|null
condition|)
block|{
comment|// Don't deserialize the value, as what we're after is the key.  We just had to check the
comment|// value wasn't null in order to check this is a record with a delegation token and not a
comment|// master key.
name|ids
operator|.
name|add
argument_list|(
operator|new
name|String
argument_list|(
name|result
operator|.
name|getRow
argument_list|()
argument_list|,
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ids
return|;
block|}
comment|/**    * Store a delegation token    * @param tokId token id    * @param token delegation token to store    * @throws IOException    */
name|void
name|putDelegationToken
parameter_list|(
name|String
name|tokId
parameter_list|,
name|String
name|token
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
index|[]
name|serialized
init|=
name|HBaseUtils
operator|.
name|serializeDelegationToken
argument_list|(
name|tokId
argument_list|,
name|token
argument_list|)
decl_stmt|;
name|store
argument_list|(
name|SECURITY_TABLE
argument_list|,
name|serialized
index|[
literal|0
index|]
argument_list|,
name|CATALOG_CF
argument_list|,
name|DELEGATION_TOKEN_COL
argument_list|,
name|serialized
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete a delegation token    * @param tokId identifier of token to drop    * @throws IOException    */
name|void
name|deleteDelegationToken
parameter_list|(
name|String
name|tokId
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|tokId
argument_list|)
decl_stmt|;
name|delete
argument_list|(
name|SECURITY_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|DELEGATION_TOKEN_COL
argument_list|)
expr_stmt|;
block|}
comment|/**    * Fetch a master key    * @param seqNo sequence number of the master key    * @return the master key, or null if there is no such master key    * @throws IOException    */
name|String
name|getMasterKey
parameter_list|(
name|Integer
name|seqNo
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|seqNo
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|byte
index|[]
name|serialized
init|=
name|read
argument_list|(
name|SECURITY_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|MASTER_KEY_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|HBaseUtils
operator|.
name|deserializeMasterKey
argument_list|(
name|serialized
argument_list|)
return|;
block|}
comment|/**    * Get all master keys    * @return list of all master keys    * @throws IOException    */
name|List
argument_list|<
name|String
argument_list|>
name|scanMasterKeys
parameter_list|()
throws|throws
name|IOException
block|{
name|Iterator
argument_list|<
name|Result
argument_list|>
name|iter
init|=
name|scan
argument_list|(
name|SECURITY_TABLE
argument_list|,
name|CATALOG_CF
argument_list|,
name|MASTER_KEY_COL
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|keys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Result
name|result
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|byte
index|[]
name|serialized
init|=
name|result
operator|.
name|getValue
argument_list|(
name|CATALOG_CF
argument_list|,
name|MASTER_KEY_COL
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialized
operator|!=
literal|null
condition|)
block|{
name|keys
operator|.
name|add
argument_list|(
name|HBaseUtils
operator|.
name|deserializeMasterKey
argument_list|(
name|serialized
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|keys
return|;
block|}
comment|/**    * Store a master key    * @param seqNo sequence number    * @param key master key to store    * @throws IOException    */
name|void
name|putMasterKey
parameter_list|(
name|Integer
name|seqNo
parameter_list|,
name|String
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
index|[]
name|serialized
init|=
name|HBaseUtils
operator|.
name|serializeMasterKey
argument_list|(
name|seqNo
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|store
argument_list|(
name|SECURITY_TABLE
argument_list|,
name|serialized
index|[
literal|0
index|]
argument_list|,
name|CATALOG_CF
argument_list|,
name|MASTER_KEY_COL
argument_list|,
name|serialized
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete a master key    * @param seqNo sequence number of master key to delete    * @throws IOException    */
name|void
name|deleteMasterKey
parameter_list|(
name|Integer
name|seqNo
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|HBaseUtils
operator|.
name|buildKey
argument_list|(
name|seqNo
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|delete
argument_list|(
name|SECURITY_TABLE
argument_list|,
name|key
argument_list|,
name|CATALOG_CF
argument_list|,
name|MASTER_KEY_COL
argument_list|)
expr_stmt|;
block|}
comment|/**********************************************************************************************    * Sequence methods    *********************************************************************************************/
name|long
name|getNextSequence
parameter_list|(
name|byte
index|[]
name|sequence
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|serialized
init|=
name|read
argument_list|(
name|SEQUENCES_TABLE
argument_list|,
name|SEQUENCES_KEY
argument_list|,
name|CATALOG_CF
argument_list|,
name|sequence
argument_list|)
decl_stmt|;
name|long
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|serialized
operator|!=
literal|null
condition|)
block|{
name|val
operator|=
name|Long
operator|.
name|valueOf
argument_list|(
operator|new
name|String
argument_list|(
name|serialized
argument_list|,
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|incrSerialized
init|=
operator|new
name|Long
argument_list|(
name|val
operator|+
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|HBaseUtils
operator|.
name|ENCODING
argument_list|)
decl_stmt|;
name|store
argument_list|(
name|SEQUENCES_TABLE
argument_list|,
name|SEQUENCES_KEY
argument_list|,
name|CATALOG_CF
argument_list|,
name|sequence
argument_list|,
name|incrSerialized
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
comment|/**********************************************************************************************    * Cache methods    *********************************************************************************************/
comment|/**    * This should be called whenever a new query is started.    */
name|void
name|flushCatalogCache
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
for|for
control|(
name|Counter
name|counter
range|:
name|counters
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|counter
operator|.
name|dump
argument_list|()
argument_list|)
expr_stmt|;
name|counter
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|statsCache
operator|.
name|dumpCounters
argument_list|()
expr_stmt|;
block|}
name|tableCache
operator|.
name|flush
argument_list|()
expr_stmt|;
name|sdCache
operator|.
name|flush
argument_list|()
expr_stmt|;
name|partCache
operator|.
name|flush
argument_list|()
expr_stmt|;
name|flushRoleCache
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|flushRoleCache
parameter_list|()
block|{
name|roleCache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|entireRoleTableInCache
operator|=
literal|false
expr_stmt|;
block|}
comment|/**********************************************************************************************    * General access methods    *********************************************************************************************/
specifier|private
name|void
name|store
parameter_list|(
name|String
name|table
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|byte
index|[]
name|colFam
parameter_list|,
name|byte
index|[]
name|colName
parameter_list|,
name|byte
index|[]
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableInterface
name|htab
init|=
name|conn
operator|.
name|getHBaseTable
argument_list|(
name|table
argument_list|)
decl_stmt|;
name|Put
name|p
init|=
operator|new
name|Put
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|p
operator|.
name|add
argument_list|(
name|colFam
argument_list|,
name|colName
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|htab
operator|.
name|put
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|conn
operator|.
name|flush
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|store
parameter_list|(
name|String
name|table
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|byte
index|[]
name|colFam
parameter_list|,
name|byte
index|[]
index|[]
name|colName
parameter_list|,
name|byte
index|[]
index|[]
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableInterface
name|htab
init|=
name|conn
operator|.
name|getHBaseTable
argument_list|(
name|table
argument_list|)
decl_stmt|;
name|Put
name|p
init|=
operator|new
name|Put
argument_list|(
name|key
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|colName
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|.
name|add
argument_list|(
name|colFam
argument_list|,
name|colName
index|[
name|i
index|]
argument_list|,
name|obj
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|htab
operator|.
name|put
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|conn
operator|.
name|flush
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
specifier|private
name|byte
index|[]
name|read
parameter_list|(
name|String
name|table
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|byte
index|[]
name|colFam
parameter_list|,
name|byte
index|[]
name|colName
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableInterface
name|htab
init|=
name|conn
operator|.
name|getHBaseTable
argument_list|(
name|table
argument_list|)
decl_stmt|;
name|Get
name|g
init|=
operator|new
name|Get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|g
operator|.
name|addColumn
argument_list|(
name|colFam
argument_list|,
name|colName
argument_list|)
expr_stmt|;
name|Result
name|res
init|=
name|htab
operator|.
name|get
argument_list|(
name|g
argument_list|)
decl_stmt|;
return|return
name|res
operator|.
name|getValue
argument_list|(
name|colFam
argument_list|,
name|colName
argument_list|)
return|;
block|}
specifier|private
name|void
name|multiRead
parameter_list|(
name|String
name|table
parameter_list|,
name|byte
index|[]
name|colFam
parameter_list|,
name|byte
index|[]
name|colName
parameter_list|,
name|byte
index|[]
index|[]
name|keys
parameter_list|,
name|ByteBuffer
index|[]
name|resultDest
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|keys
operator|.
name|length
operator|==
name|resultDest
operator|.
name|length
assert|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
name|HTableInterface
name|htab
init|=
name|conn
operator|.
name|getHBaseTable
argument_list|(
name|table
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Get
argument_list|>
name|gets
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|keys
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|key
range|:
name|keys
control|)
block|{
name|Get
name|g
init|=
operator|new
name|Get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|g
operator|.
name|addColumn
argument_list|(
name|colFam
argument_list|,
name|colName
argument_list|)
expr_stmt|;
name|gets
operator|.
name|add
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
name|Result
index|[]
name|results
init|=
name|htab
operator|.
name|get
argument_list|(
name|gets
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|results
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|Result
name|r
init|=
name|results
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|resultDest
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|Cell
name|cell
init|=
name|r
operator|.
name|getColumnLatestCell
argument_list|(
name|colFam
argument_list|,
name|colName
argument_list|)
decl_stmt|;
name|resultDest
index|[
name|i
index|]
operator|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|cell
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|multiModify
parameter_list|(
name|String
name|table
parameter_list|,
name|byte
index|[]
index|[]
name|keys
parameter_list|,
name|byte
index|[]
name|colFam
parameter_list|,
name|byte
index|[]
name|colName
parameter_list|,
name|List
argument_list|<
name|ByteBuffer
argument_list|>
name|values
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
assert|assert
name|values
operator|==
literal|null
operator|||
name|keys
operator|.
name|length
operator|==
name|values
operator|.
name|size
argument_list|()
assert|;
comment|// HBase APIs are weird. To supply bytebuffer value, you have to also have bytebuffer
comment|// column name, but not column family. So there. Perhaps we should add these to constants too.
name|ByteBuffer
name|colNameBuf
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|colName
argument_list|)
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
name|HTableInterface
name|htab
init|=
name|conn
operator|.
name|getHBaseTable
argument_list|(
name|table
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Row
argument_list|>
name|actions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|keys
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keys
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|ByteBuffer
name|value
init|=
operator|(
name|values
operator|!=
literal|null
operator|)
condition|?
name|values
operator|.
name|get
argument_list|(
name|i
argument_list|)
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|actions
operator|.
name|add
argument_list|(
operator|new
name|Delete
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Put
name|p
init|=
operator|new
name|Put
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|p
operator|.
name|addColumn
argument_list|(
name|colFam
argument_list|,
name|colNameBuf
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|actions
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|Object
index|[]
name|results
init|=
operator|new
name|Object
index|[
name|keys
operator|.
name|length
index|]
decl_stmt|;
name|htab
operator|.
name|batch
argument_list|(
name|actions
argument_list|,
name|results
argument_list|)
expr_stmt|;
comment|// TODO: should we check results array? we don't care about partial results
name|conn
operator|.
name|flush
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Result
name|read
parameter_list|(
name|String
name|table
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|byte
index|[]
name|colFam
parameter_list|,
name|byte
index|[]
index|[]
name|colNames
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableInterface
name|htab
init|=
name|conn
operator|.
name|getHBaseTable
argument_list|(
name|table
argument_list|)
decl_stmt|;
name|Get
name|g
init|=
operator|new
name|Get
argument_list|(
name|key
argument_list|)
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|colName
range|:
name|colNames
control|)
name|g
operator|.
name|addColumn
argument_list|(
name|colFam
argument_list|,
name|colName
argument_list|)
expr_stmt|;
return|return
name|htab
operator|.
name|get
argument_list|(
name|g
argument_list|)
return|;
block|}
comment|// Delete a row.  If colFam and colName are not null, then only the named column will be
comment|// deleted.  If colName is null and colFam is not, only the named family will be deleted.  If
comment|// both are null the entire row will be deleted.
specifier|private
name|void
name|delete
parameter_list|(
name|String
name|table
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|byte
index|[]
name|colFam
parameter_list|,
name|byte
index|[]
name|colName
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableInterface
name|htab
init|=
name|conn
operator|.
name|getHBaseTable
argument_list|(
name|table
argument_list|)
decl_stmt|;
name|Delete
name|d
init|=
operator|new
name|Delete
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|colName
operator|!=
literal|null
condition|)
name|d
operator|.
name|deleteColumn
argument_list|(
name|colFam
argument_list|,
name|colName
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|colFam
operator|!=
literal|null
condition|)
name|d
operator|.
name|deleteFamily
argument_list|(
name|colFam
argument_list|)
expr_stmt|;
name|htab
operator|.
name|delete
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Iterator
argument_list|<
name|Result
argument_list|>
name|scan
parameter_list|(
name|String
name|table
parameter_list|,
name|byte
index|[]
name|colFam
parameter_list|,
name|byte
index|[]
name|colName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|scan
argument_list|(
name|table
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|colFam
argument_list|,
name|colName
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|private
name|Iterator
argument_list|<
name|Result
argument_list|>
name|scan
parameter_list|(
name|String
name|table
parameter_list|,
name|byte
index|[]
name|colFam
parameter_list|,
name|byte
index|[]
name|colName
parameter_list|,
name|Filter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|scan
argument_list|(
name|table
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|colFam
argument_list|,
name|colName
argument_list|,
name|filter
argument_list|)
return|;
block|}
specifier|private
name|Iterator
argument_list|<
name|Result
argument_list|>
name|scan
parameter_list|(
name|String
name|table
parameter_list|,
name|Filter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|scan
argument_list|(
name|table
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|filter
argument_list|)
return|;
block|}
specifier|private
name|Iterator
argument_list|<
name|Result
argument_list|>
name|scan
parameter_list|(
name|String
name|table
parameter_list|,
name|byte
index|[]
name|keyStart
parameter_list|,
name|byte
index|[]
name|keyEnd
parameter_list|,
name|byte
index|[]
name|colFam
parameter_list|,
name|byte
index|[]
name|colName
parameter_list|,
name|Filter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableInterface
name|htab
init|=
name|conn
operator|.
name|getHBaseTable
argument_list|(
name|table
argument_list|)
decl_stmt|;
name|Scan
name|s
init|=
operator|new
name|Scan
argument_list|()
decl_stmt|;
if|if
condition|(
name|keyStart
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|setStartRow
argument_list|(
name|keyStart
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keyEnd
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|setStopRow
argument_list|(
name|keyEnd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|colFam
operator|!=
literal|null
operator|&&
name|colName
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|addColumn
argument_list|(
name|colFam
argument_list|,
name|colName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|filter
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|setFilter
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
name|ResultScanner
name|scanner
init|=
name|htab
operator|.
name|getScanner
argument_list|(
name|s
argument_list|)
decl_stmt|;
return|return
name|scanner
operator|.
name|iterator
argument_list|()
return|;
block|}
comment|/**********************************************************************************************    * Testing methods and classes    *********************************************************************************************/
annotation|@
name|VisibleForTesting
name|int
name|countStorageDescriptor
parameter_list|()
throws|throws
name|IOException
block|{
name|ResultScanner
name|scanner
init|=
name|conn
operator|.
name|getHBaseTable
argument_list|(
name|SD_TABLE
argument_list|)
operator|.
name|getScanner
argument_list|(
operator|new
name|Scan
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|Result
name|r
decl_stmt|;
do|do
block|{
name|r
operator|=
name|scanner
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Saw record with hash "
operator|+
name|Base64
operator|.
name|encodeBase64String
argument_list|(
name|r
operator|.
name|getRow
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|r
operator|!=
literal|null
condition|)
do|;
return|return
name|cnt
return|;
block|}
comment|/**    * Use this for unit testing only, so that a mock connection object can be passed in.    * @param connection Mock connection objecct    */
annotation|@
name|VisibleForTesting
specifier|static
name|void
name|setTestConnection
parameter_list|(
name|HBaseConnection
name|connection
parameter_list|)
block|{
name|testConn
operator|=
name|connection
expr_stmt|;
block|}
comment|// For testing without the cache
specifier|private
specifier|static
class|class
name|BogusObjectCache
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ObjectCache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
specifier|static
name|Counter
name|bogus
init|=
operator|new
name|Counter
argument_list|(
literal|"bogus"
argument_list|)
decl_stmt|;
name|BogusObjectCache
parameter_list|()
block|{
name|super
argument_list|(
literal|1
argument_list|,
name|bogus
argument_list|,
name|bogus
argument_list|,
name|bogus
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|V
name|get
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|BogusPartitionCache
extends|extends
name|PartitionCache
block|{
specifier|static
name|Counter
name|bogus
init|=
operator|new
name|Counter
argument_list|(
literal|"bogus"
argument_list|)
decl_stmt|;
name|BogusPartitionCache
parameter_list|()
block|{
name|super
argument_list|(
literal|1
argument_list|,
name|bogus
argument_list|,
name|bogus
argument_list|,
name|bogus
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|Collection
argument_list|<
name|Partition
argument_list|>
name|getAllForTable
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
name|Partition
name|get
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partVals
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
end_class

end_unit

