begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|txn
package|;
end_package

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ValidTxnList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Extends the transaction handler with methods needed only by the compactor threads.  These  * methods are not available through the thrift interface.  */
end_comment

begin_class
specifier|public
class|class
name|CompactionTxnHandler
extends|extends
name|TxnHandler
block|{
specifier|static
specifier|final
specifier|private
name|String
name|CLASS_NAME
init|=
name|CompactionTxnHandler
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|CLASS_NAME
argument_list|)
decl_stmt|;
comment|// Always access COMPACTION_QUEUE before COMPLETED_TXN_COMPONENTS
comment|// See TxnHandler for notes on how to deal with deadlocks.  Follow those notes.
specifier|public
name|CompactionTxnHandler
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * This will look through the completed_txn_components table and look for partitions or tables    * that may be ready for compaction.  Also, look through txns and txn_components tables for    * aborted transactions that we should add to the list.    * @param maxAborted Maximum number of aborted queries to allow before marking this as a    *                   potential compaction.    * @return list of CompactionInfo structs.  These will not have id, type,    * or runAs set since these are only potential compactions not actual ones.    */
specifier|public
name|Set
argument_list|<
name|CompactionInfo
argument_list|>
name|findPotentialCompactions
parameter_list|(
name|int
name|maxAborted
parameter_list|)
throws|throws
name|MetaException
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Set
argument_list|<
name|CompactionInfo
argument_list|>
name|response
init|=
operator|new
name|HashSet
argument_list|<
name|CompactionInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
comment|// Check for completed transactions
name|String
name|s
init|=
literal|"select distinct ctc_database, ctc_table, "
operator|+
literal|"ctc_partition from COMPLETED_TXN_COMPONENTS"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|CompactionInfo
name|info
init|=
operator|new
name|CompactionInfo
argument_list|()
decl_stmt|;
name|info
operator|.
name|dbname
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|info
operator|.
name|tableName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|info
operator|.
name|partName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|response
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
name|rs
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Check for aborted txns
name|s
operator|=
literal|"select tc_database, tc_table, tc_partition "
operator|+
literal|"from TXNS, TXN_COMPONENTS "
operator|+
literal|"where txn_id = tc_txnid and txn_state = '"
operator|+
name|TXN_ABORTED
operator|+
literal|"' "
operator|+
literal|"group by tc_database, tc_table, tc_partition "
operator|+
literal|"having count(*)> "
operator|+
name|maxAborted
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|CompactionInfo
name|info
init|=
operator|new
name|CompactionInfo
argument_list|()
decl_stmt|;
name|info
operator|.
name|dbname
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|info
operator|.
name|tableName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|info
operator|.
name|partName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|info
operator|.
name|tooManyAborts
operator|=
literal|true
expr_stmt|;
name|response
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"findPotentialCompactions(maxAborted:"
operator|+
name|maxAborted
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
return|return
name|response
return|;
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|findPotentialCompactions
argument_list|(
name|maxAborted
argument_list|)
return|;
block|}
block|}
comment|/**    * Sets the user to run as.  This is for the case    * where the request was generated by the user and so the worker must set this value later.    * @param cq_id id of this entry in the queue    * @param user user to run the jobs as    */
specifier|public
name|void
name|setRunAs
parameter_list|(
name|long
name|cq_id
parameter_list|,
name|String
name|user
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"update COMPACTION_QUEUE set cq_run_as = '"
operator|+
name|user
operator|+
literal|"' where cq_id = "
operator|+
name|cq_id
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|updCnt
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|updCnt
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to set cq_run_as="
operator|+
name|user
operator|+
literal|" for compaction record with cq_id="
operator|+
name|cq_id
operator|+
literal|".  updCnt="
operator|+
name|updCnt
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to update compaction queue, "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"setRunAs(cq_id:"
operator|+
name|cq_id
operator|+
literal|",user:"
operator|+
name|user
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|setRunAs
argument_list|(
name|cq_id
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This will grab the next compaction request off of    * the queue, and assign it to the worker.    * @param workerId id of the worker calling this, will be recorded in the db    * @return an info element for this compaction request, or null if there is no work to do now.    */
specifier|public
name|CompactionInfo
name|findNextToCompact
parameter_list|(
name|String
name|workerId
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select cq_id, cq_database, cq_table, cq_partition, "
operator|+
literal|"cq_type from COMPACTION_QUEUE where cq_state = '"
operator|+
name|INITIATED_STATE
operator|+
literal|"'"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No compactions found ready to compact"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
do|do
block|{
name|CompactionInfo
name|info
init|=
operator|new
name|CompactionInfo
argument_list|()
decl_stmt|;
name|info
operator|.
name|id
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|info
operator|.
name|dbname
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|info
operator|.
name|tableName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|info
operator|.
name|partName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|MAJOR_TYPE
case|:
name|info
operator|.
name|type
operator|=
name|CompactionType
operator|.
name|MAJOR
expr_stmt|;
break|break;
case|case
name|MINOR_TYPE
case|:
name|info
operator|.
name|type
operator|=
name|CompactionType
operator|.
name|MINOR
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unexpected compaction type "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
argument_list|)
throw|;
block|}
comment|// Now, update this record as being worked on by this worker.
name|long
name|now
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|s
operator|=
literal|"update COMPACTION_QUEUE set cq_worker_id = '"
operator|+
name|workerId
operator|+
literal|"', "
operator|+
literal|"cq_start = "
operator|+
name|now
operator|+
literal|", cq_state = '"
operator|+
name|WORKING_STATE
operator|+
literal|"' where cq_id = "
operator|+
name|info
operator|.
name|id
operator|+
literal|" AND cq_state='"
operator|+
name|INITIATED_STATE
operator|+
literal|"'"
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|updCount
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|updCount
operator|==
literal|1
condition|)
block|{
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
name|info
return|;
block|}
if|if
condition|(
name|updCount
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Another Worker picked up "
operator|+
name|info
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to set to cq_state="
operator|+
name|WORKING_STATE
operator|+
literal|" for compaction record: "
operator|+
name|info
operator|+
literal|". updCnt="
operator|+
name|updCount
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
do|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
do|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to select next element for compaction, "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"findNextToCompact(workerId:"
operator|+
name|workerId
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|findNextToCompact
argument_list|(
name|workerId
argument_list|)
return|;
block|}
block|}
comment|/**    * This will mark an entry in the queue as compacted    * and put it in the ready to clean state.    * @param info info on the compaction entry to mark as compacted.    */
specifier|public
name|void
name|markCompacted
parameter_list|(
name|CompactionInfo
name|info
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"update COMPACTION_QUEUE set cq_state = '"
operator|+
name|READY_FOR_CLEANING
operator|+
literal|"', "
operator|+
literal|"cq_worker_id = null where cq_id = "
operator|+
name|info
operator|.
name|id
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|updCnt
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|updCnt
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to set cq_state="
operator|+
name|READY_FOR_CLEANING
operator|+
literal|" for compaction record: "
operator|+
name|info
operator|+
literal|". updCnt="
operator|+
name|updCnt
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to update compaction queue "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"markCompacted("
operator|+
name|info
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|markCompacted
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Find entries in the queue that are ready to    * be cleaned.    * @return information on the entry in the queue.    */
specifier|public
name|List
argument_list|<
name|CompactionInfo
argument_list|>
name|findReadyToClean
parameter_list|()
throws|throws
name|MetaException
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|CompactionInfo
argument_list|>
name|rc
init|=
operator|new
name|ArrayList
argument_list|<
name|CompactionInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select cq_id, cq_database, cq_table, cq_partition, "
operator|+
literal|"cq_type, cq_run_as from COMPACTION_QUEUE where cq_state = '"
operator|+
name|READY_FOR_CLEANING
operator|+
literal|"'"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|CompactionInfo
name|info
init|=
operator|new
name|CompactionInfo
argument_list|()
decl_stmt|;
name|info
operator|.
name|id
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|info
operator|.
name|dbname
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|info
operator|.
name|tableName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|info
operator|.
name|partName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|MAJOR_TYPE
case|:
name|info
operator|.
name|type
operator|=
name|CompactionType
operator|.
name|MAJOR
expr_stmt|;
break|break;
case|case
name|MINOR_TYPE
case|:
name|info
operator|.
name|type
operator|=
name|CompactionType
operator|.
name|MINOR
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unexpected compaction type "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
argument_list|)
throw|;
block|}
name|info
operator|.
name|runAs
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|rc
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
name|rc
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to select next element for cleaning, "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"findReadyToClean"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|findReadyToClean
argument_list|()
return|;
block|}
block|}
comment|/**    * This will remove an entry from the queue after    * it has been compacted.    *     * todo: Worker will start with DB in state X (wrt this partition).    * while it's working more txns will happen, against partition it's compacting.    * then this will delete state up to X and since then.  There may be new delta files created    * between compaction starting and cleaning.  These will not be compacted until more    * transactions happen.  So this ideally should only delete    * up to TXN_ID that was compacted (i.e. HWM in Worker?)  Then this can also run    * at READ_COMMITTED.  So this means we'd want to store HWM in COMPACTION_QUEUE when    * Worker picks up the job.    *     * Also, by using this method when Worker fails, we prevent future compactions from    * running until more data is written to table or compaction is invoked explicitly    * @param info info on the compaction entry to remove    */
specifier|public
name|void
name|markCleaned
parameter_list|(
name|CompactionInfo
name|info
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|//do we need serializable?  Once we have the HWM as above, no.  Before that
comment|//it's debatable, but problem described above applies either way
comment|//Thus can drop to RC
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_SERIALIZABLE
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"delete from COMPACTION_QUEUE where cq_id = "
operator|+
name|info
operator|.
name|id
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|updCount
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|updCount
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to delete compaction record: "
operator|+
name|info
operator|+
literal|".  Update count="
operator|+
name|updCount
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
comment|// Remove entries from completed_txn_components as well, so we don't start looking there
comment|// again.
name|s
operator|=
literal|"delete from COMPLETED_TXN_COMPONENTS where ctc_database = '"
operator|+
name|info
operator|.
name|dbname
operator|+
literal|"' and "
operator|+
literal|"ctc_table = '"
operator|+
name|info
operator|.
name|tableName
operator|+
literal|"'"
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|partName
operator|!=
literal|null
condition|)
block|{
name|s
operator|+=
literal|" and ctc_partition = '"
operator|+
name|info
operator|.
name|partName
operator|+
literal|"'"
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Expected to remove at least one row from completed_txn_components when "
operator|+
literal|"marking compaction entry as clean!"
argument_list|)
expr_stmt|;
block|}
comment|//todo: add distinct in query
name|s
operator|=
literal|"select txn_id from TXNS, TXN_COMPONENTS where txn_id = tc_txnid and txn_state = '"
operator|+
name|TXN_ABORTED
operator|+
literal|"' and tc_database = '"
operator|+
name|info
operator|.
name|dbname
operator|+
literal|"' and tc_table = '"
operator|+
name|info
operator|.
name|tableName
operator|+
literal|"'"
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|partName
operator|!=
literal|null
condition|)
name|s
operator|+=
literal|" and tc_partition = '"
operator|+
name|info
operator|.
name|partName
operator|+
literal|"'"
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Long
argument_list|>
name|txnids
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
name|txnids
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|txnids
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Remove entries from txn_components, as there may be aborted txn components
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|//todo: add a safeguard to make sure IN clause is not too large; break up by txn id
name|buf
operator|.
name|append
argument_list|(
literal|"delete from TXN_COMPONENTS where tc_txnid in ("
argument_list|)
expr_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|long
name|id
range|:
name|txnids
control|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|false
expr_stmt|;
else|else
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
comment|//because 1 txn may include different partitions/tables even in auto commit mode
name|buf
operator|.
name|append
argument_list|(
literal|") and tc_database = '"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|info
operator|.
name|dbname
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"' and tc_table = '"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|info
operator|.
name|tableName
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|partName
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|" and tc_partition = '"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|info
operator|.
name|partName
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|buf
operator|.
name|toString
argument_list|()
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removed "
operator|+
name|rc
operator|+
literal|" records from txn_components"
argument_list|)
expr_stmt|;
comment|// Don't bother cleaning from the txns table.  A separate call will do that.  We don't
comment|// know here which txns still have components from other tables or partitions in the
comment|// table, so we don't know which ones we can and cannot clean.
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to delete from compaction queue "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"markCleaned("
operator|+
name|info
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|markCleaned
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Clean up aborted transactions from txns that have no components in txn_components.    */
specifier|public
name|void
name|cleanEmptyAbortedTxns
parameter_list|()
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|//Aborted is a terminal state, so nothing about the txn can change
comment|//after that, so READ COMMITTED is sufficient.
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select txn_id from TXNS where "
operator|+
literal|"txn_id not in (select tc_txnid from TXN_COMPONENTS) and "
operator|+
literal|"txn_state = '"
operator|+
name|TXN_ABORTED
operator|+
literal|"'"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Long
argument_list|>
name|txnids
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
name|txnids
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|txnids
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"delete from TXNS where txn_id in ("
argument_list|)
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|long
name|tid
range|:
name|txnids
control|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|false
expr_stmt|;
else|else
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|tid
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|String
name|bufStr
init|=
name|buf
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|bufStr
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|bufStr
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Removed "
operator|+
name|rc
operator|+
literal|"  empty Aborted transactions: "
operator|+
name|txnids
operator|+
literal|" from TXNS"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to delete from txns table "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"cleanEmptyAbortedTxns"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|cleanEmptyAbortedTxns
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * This will take all entries assigned to workers    * on a host return them to INITIATED state.  The initiator should use this at start up to    * clean entries from any workers that were in the middle of compacting when the metastore    * shutdown.  It does not reset entries from worker threads on other hosts as those may still    * be working.    * @param hostname Name of this host.  It is assumed this prefixes the thread's worker id,    *                 so that like hostname% will match the worker id.    */
specifier|public
name|void
name|revokeFromLocalWorkers
parameter_list|(
name|String
name|hostname
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"update COMPACTION_QUEUE set cq_worker_id = null, cq_start = null, cq_state = '"
operator|+
name|INITIATED_STATE
operator|+
literal|"' where cq_state = '"
operator|+
name|WORKING_STATE
operator|+
literal|"' and cq_worker_id like '"
operator|+
name|hostname
operator|+
literal|"%'"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
comment|// It isn't an error if the following returns no rows, as the local workers could have died
comment|// with  nothing assigned to them.
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to change dead worker's records back to initiated state "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"revokeFromLocalWorkers(hostname:"
operator|+
name|hostname
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|revokeFromLocalWorkers
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This call will return all compaction queue    * entries assigned to a worker but over the timeout back to the initiated state.    * This should be called by the initiator on start up and occasionally when running to clean up    * after dead threads.  At start up {@link #revokeFromLocalWorkers(String)} should be called    * first.    * @param timeout number of milliseconds since start time that should elapse before a worker is    *                declared dead.    */
specifier|public
name|void
name|revokeTimedoutWorkers
parameter_list|(
name|long
name|timeout
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|long
name|latestValidStart
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
operator|-
name|timeout
decl_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"update COMPACTION_QUEUE set cq_worker_id = null, cq_start = null, cq_state = '"
operator|+
name|INITIATED_STATE
operator|+
literal|"' where cq_state = '"
operator|+
name|WORKING_STATE
operator|+
literal|"' and cq_start< "
operator|+
name|latestValidStart
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
comment|// It isn't an error if the following returns no rows, as the local workers could have died
comment|// with  nothing assigned to them.
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to change dead worker's records back to initiated state "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"revokeTimedoutWorkers(timeout:"
operator|+
name|timeout
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|revokeTimedoutWorkers
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Queries metastore DB directly to find columns in the table which have statistics information.    * If {@code ci} includes partition info then per partition stats info is examined, otherwise    * table level stats are examined.    * @throws MetaException    */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|findColumnsWithStats
parameter_list|(
name|CompactionInfo
name|ci
parameter_list|)
throws|throws
name|MetaException
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|String
name|quote
init|=
name|getIdentifierQuoteString
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|StringBuilder
name|bldr
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|bldr
operator|.
name|append
argument_list|(
literal|"SELECT "
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|"COLUMN_NAME"
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|" FROM "
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
operator|(
name|ci
operator|.
name|partName
operator|==
literal|null
condition|?
literal|"TAB_COL_STATS"
else|:
literal|"PART_COL_STATS"
operator|)
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|" WHERE "
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|"DB_NAME"
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|" = '"
argument_list|)
operator|.
name|append
argument_list|(
name|ci
operator|.
name|dbname
argument_list|)
operator|.
name|append
argument_list|(
literal|"' AND "
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|"TABLE_NAME"
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|" = '"
argument_list|)
operator|.
name|append
argument_list|(
name|ci
operator|.
name|tableName
argument_list|)
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|.
name|partName
operator|!=
literal|null
condition|)
block|{
name|bldr
operator|.
name|append
argument_list|(
literal|" AND "
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|"PARTITION_NAME"
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|" = '"
argument_list|)
operator|.
name|append
argument_list|(
name|ci
operator|.
name|partName
argument_list|)
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
block|}
name|String
name|s
init|=
name|bldr
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|/*String s = "SELECT COLUMN_NAME FROM " + (ci.partName == null ? "TAB_COL_STATS" :           "PART_COL_STATS")          + " WHERE DB_NAME='" + ci.dbname + "' AND TABLE_NAME='" + ci.tableName + "'"         + (ci.partName == null ? "" : " AND PARTITION_NAME='" + ci.partName + "'");*/
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|columns
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|columns
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found columns to update stats: "
operator|+
name|columns
operator|+
literal|" on "
operator|+
name|ci
operator|.
name|tableName
operator|+
operator|(
name|ci
operator|.
name|partName
operator|==
literal|null
condition|?
literal|""
else|:
literal|"/"
operator|+
name|ci
operator|.
name|partName
operator|)
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
name|columns
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"findColumnsWithStats("
operator|+
name|ci
operator|.
name|tableName
operator|+
operator|(
name|ci
operator|.
name|partName
operator|==
literal|null
condition|?
literal|""
else|:
literal|"/"
operator|+
name|ci
operator|.
name|partName
operator|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|ex
parameter_list|)
block|{
return|return
name|findColumnsWithStats
argument_list|(
name|ci
argument_list|)
return|;
block|}
block|}
comment|/**    * Transform a {@link org.apache.hadoop.hive.metastore.api.GetOpenTxnsInfoResponse} to a    * {@link org.apache.hadoop.hive.common.ValidTxnList}.  This assumes that the caller intends to    * compact the files, and thus treats only open transactions as invalid.    * @param txns txn list from the metastore    * @return a valid txn list.    */
specifier|public
specifier|static
name|ValidTxnList
name|createValidCompactTxnList
parameter_list|(
name|GetOpenTxnsInfoResponse
name|txns
parameter_list|)
block|{
name|long
name|highWater
init|=
name|txns
operator|.
name|getTxn_high_water_mark
argument_list|()
decl_stmt|;
name|long
name|minOpenTxn
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
name|long
index|[]
name|exceptions
init|=
operator|new
name|long
index|[
name|txns
operator|.
name|getOpen_txnsSize
argument_list|()
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|TxnInfo
name|txn
range|:
name|txns
operator|.
name|getOpen_txns
argument_list|()
control|)
block|{
if|if
condition|(
name|txn
operator|.
name|getState
argument_list|()
operator|==
name|TxnState
operator|.
name|OPEN
condition|)
name|minOpenTxn
operator|=
name|Math
operator|.
name|min
argument_list|(
name|minOpenTxn
argument_list|,
name|txn
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|exceptions
index|[
name|i
operator|++
index|]
operator|=
name|txn
operator|.
name|getId
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|ValidCompactorTxnList
argument_list|(
name|exceptions
argument_list|,
name|minOpenTxn
argument_list|,
name|highWater
argument_list|)
return|;
block|}
block|}
end_class

end_unit

