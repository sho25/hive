begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|txn
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|CompactionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|MetaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|PreparedStatement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * Extends the transaction handler with methods needed only by the compactor threads.  These  * methods are not available through the thrift interface.  */
end_comment

begin_class
class|class
name|CompactionTxnHandler
extends|extends
name|TxnHandler
block|{
specifier|static
specifier|final
specifier|private
name|String
name|CLASS_NAME
init|=
name|CompactionTxnHandler
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|CLASS_NAME
argument_list|)
decl_stmt|;
comment|// Always access COMPACTION_QUEUE before COMPLETED_TXN_COMPONENTS
comment|// See TxnHandler for notes on how to deal with deadlocks.  Follow those notes.
specifier|public
name|CompactionTxnHandler
parameter_list|()
block|{   }
comment|/**    * This will look through the completed_txn_components table and look for partitions or tables    * that may be ready for compaction.  Also, look through txns and txn_components tables for    * aborted transactions that we should add to the list.    * @param maxAborted Maximum number of aborted queries to allow before marking this as a    *                   potential compaction.    * @return list of CompactionInfo structs.  These will not have id, type,    * or runAs set since these are only potential compactions not actual ones.    */
specifier|public
name|Set
argument_list|<
name|CompactionInfo
argument_list|>
name|findPotentialCompactions
parameter_list|(
name|int
name|maxAborted
parameter_list|)
throws|throws
name|MetaException
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Set
argument_list|<
name|CompactionInfo
argument_list|>
name|response
init|=
operator|new
name|HashSet
argument_list|<
name|CompactionInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
comment|// Check for completed transactions
name|String
name|s
init|=
literal|"select distinct ctc_database, ctc_table, "
operator|+
literal|"ctc_partition from COMPLETED_TXN_COMPONENTS"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|CompactionInfo
name|info
init|=
operator|new
name|CompactionInfo
argument_list|()
decl_stmt|;
name|info
operator|.
name|dbname
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|info
operator|.
name|tableName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|info
operator|.
name|partName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|response
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
name|rs
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Check for aborted txns
name|s
operator|=
literal|"select tc_database, tc_table, tc_partition "
operator|+
literal|"from TXNS, TXN_COMPONENTS "
operator|+
literal|"where txn_id = tc_txnid and txn_state = '"
operator|+
name|TXN_ABORTED
operator|+
literal|"' "
operator|+
literal|"group by tc_database, tc_table, tc_partition "
operator|+
literal|"having count(*)> "
operator|+
name|maxAborted
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|CompactionInfo
name|info
init|=
operator|new
name|CompactionInfo
argument_list|()
decl_stmt|;
name|info
operator|.
name|dbname
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|info
operator|.
name|tableName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|info
operator|.
name|partName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|info
operator|.
name|tooManyAborts
operator|=
literal|true
expr_stmt|;
name|response
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"findPotentialCompactions(maxAborted:"
operator|+
name|maxAborted
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
return|return
name|response
return|;
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|findPotentialCompactions
argument_list|(
name|maxAborted
argument_list|)
return|;
block|}
block|}
comment|/**    * Sets the user to run as.  This is for the case    * where the request was generated by the user and so the worker must set this value later.    * @param cq_id id of this entry in the queue    * @param user user to run the jobs as    */
specifier|public
name|void
name|setRunAs
parameter_list|(
name|long
name|cq_id
parameter_list|,
name|String
name|user
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"update COMPACTION_QUEUE set cq_run_as = '"
operator|+
name|user
operator|+
literal|"' where cq_id = "
operator|+
name|cq_id
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|updCnt
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|updCnt
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to set cq_run_as="
operator|+
name|user
operator|+
literal|" for compaction record with cq_id="
operator|+
name|cq_id
operator|+
literal|".  updCnt="
operator|+
name|updCnt
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to update compaction queue, "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"setRunAs(cq_id:"
operator|+
name|cq_id
operator|+
literal|",user:"
operator|+
name|user
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|setRunAs
argument_list|(
name|cq_id
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This will grab the next compaction request off of    * the queue, and assign it to the worker.    * @param workerId id of the worker calling this, will be recorded in the db    * @return an info element for this compaction request, or null if there is no work to do now.    */
specifier|public
name|CompactionInfo
name|findNextToCompact
parameter_list|(
name|String
name|workerId
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select cq_id, cq_database, cq_table, cq_partition, "
operator|+
literal|"cq_type from COMPACTION_QUEUE where cq_state = '"
operator|+
name|INITIATED_STATE
operator|+
literal|"'"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No compactions found ready to compact"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
do|do
block|{
name|CompactionInfo
name|info
init|=
operator|new
name|CompactionInfo
argument_list|()
decl_stmt|;
name|info
operator|.
name|id
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|info
operator|.
name|dbname
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|info
operator|.
name|tableName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|info
operator|.
name|partName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|info
operator|.
name|type
operator|=
name|dbCompactionType2ThriftType
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Now, update this record as being worked on by this worker.
name|long
name|now
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|s
operator|=
literal|"update COMPACTION_QUEUE set cq_worker_id = '"
operator|+
name|workerId
operator|+
literal|"', "
operator|+
literal|"cq_start = "
operator|+
name|now
operator|+
literal|", cq_state = '"
operator|+
name|WORKING_STATE
operator|+
literal|"' where cq_id = "
operator|+
name|info
operator|.
name|id
operator|+
literal|" AND cq_state='"
operator|+
name|INITIATED_STATE
operator|+
literal|"'"
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|updCount
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|updCount
operator|==
literal|1
condition|)
block|{
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
name|info
return|;
block|}
if|if
condition|(
name|updCount
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Another Worker picked up "
operator|+
name|info
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to set to cq_state="
operator|+
name|WORKING_STATE
operator|+
literal|" for compaction record: "
operator|+
name|info
operator|+
literal|". updCnt="
operator|+
name|updCount
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
do|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
do|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to select next element for compaction, "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"findNextToCompact(workerId:"
operator|+
name|workerId
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|findNextToCompact
argument_list|(
name|workerId
argument_list|)
return|;
block|}
block|}
comment|/**    * This will mark an entry in the queue as compacted    * and put it in the ready to clean state.    * @param info info on the compaction entry to mark as compacted.    */
specifier|public
name|void
name|markCompacted
parameter_list|(
name|CompactionInfo
name|info
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"update COMPACTION_QUEUE set cq_state = '"
operator|+
name|READY_FOR_CLEANING
operator|+
literal|"', "
operator|+
literal|"cq_worker_id = null where cq_id = "
operator|+
name|info
operator|.
name|id
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|updCnt
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|updCnt
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to set cq_state="
operator|+
name|READY_FOR_CLEANING
operator|+
literal|" for compaction record: "
operator|+
name|info
operator|+
literal|". updCnt="
operator|+
name|updCnt
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to update compaction queue "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"markCompacted("
operator|+
name|info
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|markCompacted
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Find entries in the queue that are ready to    * be cleaned.    * @return information on the entry in the queue.    */
specifier|public
name|List
argument_list|<
name|CompactionInfo
argument_list|>
name|findReadyToClean
parameter_list|()
throws|throws
name|MetaException
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|CompactionInfo
argument_list|>
name|rc
init|=
operator|new
name|ArrayList
argument_list|<
name|CompactionInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select cq_id, cq_database, cq_table, cq_partition, "
operator|+
literal|"cq_type, cq_run_as, cq_highest_txn_id from COMPACTION_QUEUE where cq_state = '"
operator|+
name|READY_FOR_CLEANING
operator|+
literal|"'"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|CompactionInfo
name|info
init|=
operator|new
name|CompactionInfo
argument_list|()
decl_stmt|;
name|info
operator|.
name|id
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|info
operator|.
name|dbname
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|info
operator|.
name|tableName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|info
operator|.
name|partName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|MAJOR_TYPE
case|:
name|info
operator|.
name|type
operator|=
name|CompactionType
operator|.
name|MAJOR
expr_stmt|;
break|break;
case|case
name|MINOR_TYPE
case|:
name|info
operator|.
name|type
operator|=
name|CompactionType
operator|.
name|MINOR
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unexpected compaction type "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
argument_list|)
throw|;
block|}
name|info
operator|.
name|runAs
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|info
operator|.
name|highestTxnId
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|rc
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
name|rc
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to select next element for cleaning, "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"findReadyToClean"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|findReadyToClean
argument_list|()
return|;
block|}
block|}
comment|/**    * This will remove an entry from the queue after    * it has been compacted.    *     * @param info info on the compaction entry to remove    */
specifier|public
name|void
name|markCleaned
parameter_list|(
name|CompactionInfo
name|info
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|PreparedStatement
name|pStmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
literal|"select CQ_ID, CQ_DATABASE, CQ_TABLE, CQ_PARTITION, CQ_STATE, CQ_TYPE, CQ_WORKER_ID, CQ_START, CQ_RUN_AS, CQ_HIGHEST_TXN_ID, CQ_META_INFO, CQ_HADOOP_JOB_ID from COMPACTION_QUEUE WHERE CQ_ID = "
operator|+
name|info
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|info
operator|=
name|CompactionInfo
operator|.
name|loadFullFromCompactionQueue
argument_list|(
name|rs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"No record with CQ_ID="
operator|+
name|info
operator|.
name|id
operator|+
literal|" found in COMPACTION_QUEUE"
argument_list|)
throw|;
block|}
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|String
name|s
init|=
literal|"delete from COMPACTION_QUEUE where cq_id = "
operator|+
name|info
operator|.
name|id
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|updCount
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|updCount
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to delete compaction record: "
operator|+
name|info
operator|+
literal|".  Update count="
operator|+
name|updCount
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
name|pStmt
operator|=
name|dbConn
operator|.
name|prepareStatement
argument_list|(
literal|"insert into COMPLETED_COMPACTIONS(CC_ID, CC_DATABASE, CC_TABLE, CC_PARTITION, CC_STATE, CC_TYPE, CC_WORKER_ID, CC_START, CC_END, CC_RUN_AS, CC_HIGHEST_TXN_ID, CC_META_INFO, CC_HADOOP_JOB_ID) VALUES(?,?,?,?,?, ?,?,?,?,?, ?,?,?)"
argument_list|)
expr_stmt|;
name|info
operator|.
name|state
operator|=
name|SUCCEEDED_STATE
expr_stmt|;
name|CompactionInfo
operator|.
name|insertIntoCompletedCompactions
argument_list|(
name|pStmt
argument_list|,
name|info
argument_list|,
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
argument_list|)
expr_stmt|;
name|updCount
operator|=
name|pStmt
operator|.
name|executeUpdate
argument_list|()
expr_stmt|;
comment|// Remove entries from completed_txn_components as well, so we don't start looking there
comment|// again but only up to the highest txn ID include in this compaction job.
comment|//highestTxnId will be NULL in upgrade scenarios
name|s
operator|=
literal|"delete from COMPLETED_TXN_COMPONENTS where ctc_database = '"
operator|+
name|info
operator|.
name|dbname
operator|+
literal|"' and "
operator|+
literal|"ctc_table = '"
operator|+
name|info
operator|.
name|tableName
operator|+
literal|"'"
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|partName
operator|!=
literal|null
condition|)
block|{
name|s
operator|+=
literal|" and ctc_partition = '"
operator|+
name|info
operator|.
name|partName
operator|+
literal|"'"
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|.
name|highestTxnId
operator|!=
literal|0
condition|)
block|{
name|s
operator|+=
literal|" and ctc_txnid<= "
operator|+
name|info
operator|.
name|highestTxnId
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Expected to remove at least one row from completed_txn_components when "
operator|+
literal|"marking compaction entry as clean!"
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
literal|"select distinct txn_id from TXNS, TXN_COMPONENTS where txn_id = tc_txnid and txn_state = '"
operator|+
name|TXN_ABORTED
operator|+
literal|"' and tc_database = '"
operator|+
name|info
operator|.
name|dbname
operator|+
literal|"' and tc_table = '"
operator|+
name|info
operator|.
name|tableName
operator|+
literal|"'"
operator|+
operator|(
name|info
operator|.
name|highestTxnId
operator|==
literal|0
condition|?
literal|""
else|:
literal|" and txn_id<= "
operator|+
name|info
operator|.
name|highestTxnId
operator|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|partName
operator|!=
literal|null
condition|)
name|s
operator|+=
literal|" and tc_partition = '"
operator|+
name|info
operator|.
name|partName
operator|+
literal|"'"
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|txnids
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
name|txnids
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// Remove entries from txn_components, as there may be aborted txn components
if|if
condition|(
name|txnids
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|queries
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// Prepare prefix and suffix
name|StringBuilder
name|prefix
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|StringBuilder
name|suffix
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|prefix
operator|.
name|append
argument_list|(
literal|"delete from TXN_COMPONENTS where "
argument_list|)
expr_stmt|;
comment|//because 1 txn may include different partitions/tables even in auto commit mode
name|suffix
operator|.
name|append
argument_list|(
literal|" and tc_database = "
argument_list|)
expr_stmt|;
name|suffix
operator|.
name|append
argument_list|(
name|quoteString
argument_list|(
name|info
operator|.
name|dbname
argument_list|)
argument_list|)
expr_stmt|;
name|suffix
operator|.
name|append
argument_list|(
literal|" and tc_table = "
argument_list|)
expr_stmt|;
name|suffix
operator|.
name|append
argument_list|(
name|quoteString
argument_list|(
name|info
operator|.
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|partName
operator|!=
literal|null
condition|)
block|{
name|suffix
operator|.
name|append
argument_list|(
literal|" and tc_partition = "
argument_list|)
expr_stmt|;
name|suffix
operator|.
name|append
argument_list|(
name|quoteString
argument_list|(
name|info
operator|.
name|partName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Populate the complete query with provided prefix and suffix
name|TxnUtils
operator|.
name|buildQueryWithINClause
argument_list|(
name|conf
argument_list|,
name|queries
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|,
name|txnids
argument_list|,
literal|"tc_txnid"
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|query
range|:
name|queries
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|query
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removed "
operator|+
name|rc
operator|+
literal|" records from txn_components"
argument_list|)
expr_stmt|;
comment|// Don't bother cleaning from the txns table.  A separate call will do that.  We don't
comment|// know here which txns still have components from other tables or partitions in the
comment|// table, so we don't know which ones we can and cannot clean.
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to delete from compaction queue "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"markCleaned("
operator|+
name|info
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|markCleaned
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Clean up aborted transactions from txns that have no components in txn_components.  The reson such    * txns exist can be that now work was done in this txn (e.g. Streaming opened TransactionBatch and    * abandoned it w/o doing any work) or due to {@link #markCleaned(CompactionInfo)} being called.    */
specifier|public
name|void
name|cleanEmptyAbortedTxns
parameter_list|()
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|//Aborted is a terminal state, so nothing about the txn can change
comment|//after that, so READ COMMITTED is sufficient.
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select txn_id from TXNS where "
operator|+
literal|"txn_id not in (select tc_txnid from TXN_COMPONENTS) and "
operator|+
literal|"txn_state = '"
operator|+
name|TXN_ABORTED
operator|+
literal|"'"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|txnids
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
name|txnids
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|txnids
operator|.
name|size
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|queries
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|prefix
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|StringBuilder
name|suffix
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|prefix
operator|.
name|append
argument_list|(
literal|"delete from TXNS where "
argument_list|)
expr_stmt|;
name|suffix
operator|.
name|append
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|TxnUtils
operator|.
name|buildQueryWithINClause
argument_list|(
name|conf
argument_list|,
name|queries
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|,
name|txnids
argument_list|,
literal|"txn_id"
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|query
range|:
name|queries
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|query
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Removed "
operator|+
name|rc
operator|+
literal|"  empty Aborted transactions from TXNS"
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Aborted transactions removed from TXNS: "
operator|+
name|txnids
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to delete from txns table "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"cleanEmptyAbortedTxns"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|cleanEmptyAbortedTxns
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * This will take all entries assigned to workers    * on a host return them to INITIATED state.  The initiator should use this at start up to    * clean entries from any workers that were in the middle of compacting when the metastore    * shutdown.  It does not reset entries from worker threads on other hosts as those may still    * be working.    * @param hostname Name of this host.  It is assumed this prefixes the thread's worker id,    *                 so that like hostname% will match the worker id.    */
specifier|public
name|void
name|revokeFromLocalWorkers
parameter_list|(
name|String
name|hostname
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"update COMPACTION_QUEUE set cq_worker_id = null, cq_start = null, cq_state = '"
operator|+
name|INITIATED_STATE
operator|+
literal|"' where cq_state = '"
operator|+
name|WORKING_STATE
operator|+
literal|"' and cq_worker_id like '"
operator|+
name|hostname
operator|+
literal|"%'"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
comment|// It isn't an error if the following returns no rows, as the local workers could have died
comment|// with  nothing assigned to them.
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to change dead worker's records back to initiated state "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"revokeFromLocalWorkers(hostname:"
operator|+
name|hostname
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|revokeFromLocalWorkers
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This call will return all compaction queue    * entries assigned to a worker but over the timeout back to the initiated state.    * This should be called by the initiator on start up and occasionally when running to clean up    * after dead threads.  At start up {@link #revokeFromLocalWorkers(String)} should be called    * first.    * @param timeout number of milliseconds since start time that should elapse before a worker is    *                declared dead.    */
specifier|public
name|void
name|revokeTimedoutWorkers
parameter_list|(
name|long
name|timeout
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|long
name|latestValidStart
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
operator|-
name|timeout
decl_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"update COMPACTION_QUEUE set cq_worker_id = null, cq_start = null, cq_state = '"
operator|+
name|INITIATED_STATE
operator|+
literal|"' where cq_state = '"
operator|+
name|WORKING_STATE
operator|+
literal|"' and cq_start< "
operator|+
name|latestValidStart
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
comment|// It isn't an error if the following returns no rows, as the local workers could have died
comment|// with  nothing assigned to them.
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to change dead worker's records back to initiated state "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"revokeTimedoutWorkers(timeout:"
operator|+
name|timeout
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|revokeTimedoutWorkers
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Queries metastore DB directly to find columns in the table which have statistics information.    * If {@code ci} includes partition info then per partition stats info is examined, otherwise    * table level stats are examined.    * @throws MetaException    */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|findColumnsWithStats
parameter_list|(
name|CompactionInfo
name|ci
parameter_list|)
throws|throws
name|MetaException
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|String
name|quote
init|=
name|getIdentifierQuoteString
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|StringBuilder
name|bldr
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|bldr
operator|.
name|append
argument_list|(
literal|"SELECT "
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|"COLUMN_NAME"
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|" FROM "
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
operator|(
name|ci
operator|.
name|partName
operator|==
literal|null
condition|?
literal|"TAB_COL_STATS"
else|:
literal|"PART_COL_STATS"
operator|)
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|" WHERE "
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|"DB_NAME"
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|" = '"
argument_list|)
operator|.
name|append
argument_list|(
name|ci
operator|.
name|dbname
argument_list|)
operator|.
name|append
argument_list|(
literal|"' AND "
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|"TABLE_NAME"
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|" = '"
argument_list|)
operator|.
name|append
argument_list|(
name|ci
operator|.
name|tableName
argument_list|)
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|.
name|partName
operator|!=
literal|null
condition|)
block|{
name|bldr
operator|.
name|append
argument_list|(
literal|" AND "
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|"PARTITION_NAME"
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|" = '"
argument_list|)
operator|.
name|append
argument_list|(
name|ci
operator|.
name|partName
argument_list|)
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
block|}
name|String
name|s
init|=
name|bldr
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|/*String s = "SELECT COLUMN_NAME FROM " + (ci.partName == null ? "TAB_COL_STATS" :           "PART_COL_STATS")          + " WHERE DB_NAME='" + ci.dbname + "' AND TABLE_NAME='" + ci.tableName + "'"         + (ci.partName == null ? "" : " AND PARTITION_NAME='" + ci.partName + "'");*/
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|columns
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|columns
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found columns to update stats: "
operator|+
name|columns
operator|+
literal|" on "
operator|+
name|ci
operator|.
name|tableName
operator|+
operator|(
name|ci
operator|.
name|partName
operator|==
literal|null
condition|?
literal|""
else|:
literal|"/"
operator|+
name|ci
operator|.
name|partName
operator|)
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
name|columns
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"findColumnsWithStats("
operator|+
name|ci
operator|.
name|tableName
operator|+
operator|(
name|ci
operator|.
name|partName
operator|==
literal|null
condition|?
literal|""
else|:
literal|"/"
operator|+
name|ci
operator|.
name|partName
operator|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|ex
parameter_list|)
block|{
return|return
name|findColumnsWithStats
argument_list|(
name|ci
argument_list|)
return|;
block|}
block|}
comment|/**    * Record the highest txn id that the {@code ci} compaction job will pay attention to.    */
specifier|public
name|void
name|setCompactionHighestTxnId
parameter_list|(
name|CompactionInfo
name|ci
parameter_list|,
name|long
name|highestTxnId
parameter_list|)
throws|throws
name|MetaException
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|int
name|updCount
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
literal|"UPDATE COMPACTION_QUEUE SET CQ_HIGHEST_TXN_ID = "
operator|+
name|highestTxnId
operator|+
literal|" WHERE CQ_ID = "
operator|+
name|ci
operator|.
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|updCount
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Could not find record in COMPACTION_QUEUE for "
operator|+
name|ci
argument_list|)
throw|;
block|}
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"setCompactionHighestTxnId("
operator|+
name|ci
operator|+
literal|","
operator|+
name|highestTxnId
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
literal|null
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|ex
parameter_list|)
block|{
name|setCompactionHighestTxnId
argument_list|(
name|ci
argument_list|,
name|highestTxnId
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
class|class
name|RetentionCounters
block|{
name|int
name|attemptedRetention
init|=
literal|0
decl_stmt|;
name|int
name|failedRetention
init|=
literal|0
decl_stmt|;
name|int
name|succeededRetention
init|=
literal|0
decl_stmt|;
name|RetentionCounters
parameter_list|(
name|int
name|attemptedRetention
parameter_list|,
name|int
name|failedRetention
parameter_list|,
name|int
name|succeededRetention
parameter_list|)
block|{
name|this
operator|.
name|attemptedRetention
operator|=
name|attemptedRetention
expr_stmt|;
name|this
operator|.
name|failedRetention
operator|=
name|failedRetention
expr_stmt|;
name|this
operator|.
name|succeededRetention
operator|=
name|succeededRetention
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkForDeletion
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|deleteSet
parameter_list|,
name|CompactionInfo
name|ci
parameter_list|,
name|RetentionCounters
name|rc
parameter_list|)
block|{
switch|switch
condition|(
name|ci
operator|.
name|state
condition|)
block|{
case|case
name|ATTEMPTED_STATE
case|:
if|if
condition|(
operator|--
name|rc
operator|.
name|attemptedRetention
operator|<
literal|0
condition|)
block|{
name|deleteSet
operator|.
name|add
argument_list|(
name|ci
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FAILED_STATE
case|:
if|if
condition|(
operator|--
name|rc
operator|.
name|failedRetention
operator|<
literal|0
condition|)
block|{
name|deleteSet
operator|.
name|add
argument_list|(
name|ci
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SUCCEEDED_STATE
case|:
if|if
condition|(
operator|--
name|rc
operator|.
name|succeededRetention
operator|<
literal|0
condition|)
block|{
name|deleteSet
operator|.
name|add
argument_list|(
name|ci
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|//do nothing to hanlde future RU/D where we may want to add new state types
block|}
block|}
comment|/**    * For any given compactable entity (partition, table if not partitioned) the history of compactions    * may look like "sssfffaaasffss", for example.  The idea is to retain the tail (most recent) of the    * history such that a configurable number of each type of state is present.  Any other entries    * can be purged.  This scheme has advantage of always retaining the last failure/success even if    * it's not recent.    * @throws MetaException    */
specifier|public
name|void
name|purgeCompactionHistory
parameter_list|()
throws|throws
name|MetaException
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|deleteSet
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|RetentionCounters
name|rc
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
comment|/*cc_id is monotonically increasing so for any entity sorts in order of compaction history,         thus this query groups by entity and withing group sorts most recent first*/
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
literal|"select cc_id, cc_database, cc_table, cc_partition, cc_state from "
operator|+
literal|"COMPLETED_COMPACTIONS order by cc_database, cc_table, cc_partition, cc_id desc"
argument_list|)
expr_stmt|;
name|String
name|lastCompactedEntity
init|=
literal|null
decl_stmt|;
comment|/*In each group, walk from most recent and count occurences of each state type.  Once you         * have counted enough (for each state) to satisfy retention policy, delete all other         * instances of this status.*/
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|CompactionInfo
name|ci
init|=
operator|new
name|CompactionInfo
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|,
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
argument_list|,
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
argument_list|,
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
argument_list|,
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ci
operator|.
name|getFullPartitionName
argument_list|()
operator|.
name|equals
argument_list|(
name|lastCompactedEntity
argument_list|)
condition|)
block|{
name|lastCompactedEntity
operator|=
name|ci
operator|.
name|getFullPartitionName
argument_list|()
expr_stmt|;
name|rc
operator|=
operator|new
name|RetentionCounters
argument_list|(
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_ATTEMPTED
argument_list|)
argument_list|,
name|getFailedCompactionRetention
argument_list|()
argument_list|,
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_SUCCEEDED
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|checkForDeletion
argument_list|(
name|deleteSet
argument_list|,
name|ci
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|queries
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|prefix
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|StringBuilder
name|suffix
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|prefix
operator|.
name|append
argument_list|(
literal|"delete from COMPLETED_COMPACTIONS where "
argument_list|)
expr_stmt|;
name|suffix
operator|.
name|append
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|TxnUtils
operator|.
name|buildQueryWithINClause
argument_list|(
name|conf
argument_list|,
name|queries
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|,
name|deleteSet
argument_list|,
literal|"cc_id"
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|query
range|:
name|queries
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|query
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|count
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removed "
operator|+
name|count
operator|+
literal|" records from COMPLETED_COMPACTIONS"
argument_list|)
expr_stmt|;
block|}
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"purgeCompactionHistory()"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|ex
parameter_list|)
block|{
name|purgeCompactionHistory
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * this ensures that the number of failed compaction entries retained is> than number of failed    * compaction threshold which prevents new compactions from being scheduled.    */
specifier|public
name|int
name|getFailedCompactionRetention
parameter_list|()
block|{
name|int
name|failedThreshold
init|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_INITIATOR_FAILED_THRESHOLD
argument_list|)
decl_stmt|;
name|int
name|failedRetention
init|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_FAILED
argument_list|)
decl_stmt|;
if|if
condition|(
name|failedRetention
operator|<
name|failedThreshold
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Invalid configuration "
operator|+
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_INITIATOR_FAILED_THRESHOLD
operator|.
name|varname
operator|+
literal|"="
operator|+
name|failedRetention
operator|+
literal|"< "
operator|+
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_FAILED
operator|+
literal|"="
operator|+
name|failedRetention
operator|+
literal|".  Will use "
operator|+
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_INITIATOR_FAILED_THRESHOLD
operator|.
name|varname
operator|+
literal|"="
operator|+
name|failedRetention
argument_list|)
expr_stmt|;
name|failedRetention
operator|=
name|failedThreshold
expr_stmt|;
block|}
return|return
name|failedRetention
return|;
block|}
comment|/**    * Returns {@code true} if there already exists sufficient number of consecutive failures for    * this table/partition so that no new automatic compactions will be scheduled.    * User initiated compactions don't do this check.    *    * Do we allow compacting whole table (when it's partitioned)?  No, though perhaps we should.    * That would be a meta operations, i.e. first find all partitions for this table (which have     * txn info) and schedule each compaction separately.  This avoids complications in this logic.    */
specifier|public
name|boolean
name|checkFailedCompactions
parameter_list|(
name|CompactionInfo
name|ci
parameter_list|)
throws|throws
name|MetaException
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
literal|"select CC_STATE from COMPLETED_COMPACTIONS where "
operator|+
literal|"CC_DATABASE = "
operator|+
name|quoteString
argument_list|(
name|ci
operator|.
name|dbname
argument_list|)
operator|+
literal|" and "
operator|+
literal|"CC_TABLE = "
operator|+
name|quoteString
argument_list|(
name|ci
operator|.
name|tableName
argument_list|)
operator|+
operator|(
name|ci
operator|.
name|partName
operator|!=
literal|null
condition|?
literal|"and CC_PARTITION = "
operator|+
name|quoteString
argument_list|(
name|ci
operator|.
name|partName
argument_list|)
else|:
literal|""
operator|)
operator|+
literal|" order by CC_ID desc"
argument_list|)
expr_stmt|;
name|int
name|numFailed
init|=
literal|0
decl_stmt|;
name|int
name|numTotal
init|=
literal|0
decl_stmt|;
name|int
name|failedThreshold
init|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_INITIATOR_FAILED_THRESHOLD
argument_list|)
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
operator|&&
operator|++
name|numTotal
operator|<=
name|failedThreshold
condition|)
block|{
if|if
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|FAILED_STATE
condition|)
block|{
name|numFailed
operator|++
expr_stmt|;
block|}
else|else
block|{
name|numFailed
operator|--
expr_stmt|;
block|}
block|}
return|return
name|numFailed
operator|==
name|failedThreshold
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to delete from compaction queue "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"checkFailedCompactions("
operator|+
name|ci
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
comment|//weren't able to check
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|checkFailedCompactions
argument_list|(
name|ci
argument_list|)
return|;
block|}
block|}
comment|/**    * If there is an entry in compaction_queue with ci.id, remove it    * Make entry in completed_compactions with status 'f'.    *    * but what abount markCleaned() which is called when table is had been deleted...    */
specifier|public
name|void
name|markFailed
parameter_list|(
name|CompactionInfo
name|ci
parameter_list|)
throws|throws
name|MetaException
block|{
comment|//todo: this should not throw
comment|//todo: this should take "comment" as parameter to set in CC_META_INFO to provide some context for the failure
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|PreparedStatement
name|pStmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
literal|"select CQ_ID, CQ_DATABASE, CQ_TABLE, CQ_PARTITION, CQ_STATE, CQ_TYPE, CQ_WORKER_ID, CQ_START, CQ_RUN_AS, CQ_HIGHEST_TXN_ID, CQ_META_INFO, CQ_HADOOP_JOB_ID from COMPACTION_QUEUE WHERE CQ_ID = "
operator|+
name|ci
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|ci
operator|=
name|CompactionInfo
operator|.
name|loadFullFromCompactionQueue
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|String
name|s
init|=
literal|"delete from COMPACTION_QUEUE where cq_id = "
operator|+
name|ci
operator|.
name|id
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|updCnt
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"No record with CQ_ID="
operator|+
name|ci
operator|.
name|id
operator|+
literal|" found in COMPACTION_QUEUE"
argument_list|)
throw|;
block|}
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|pStmt
operator|=
name|dbConn
operator|.
name|prepareStatement
argument_list|(
literal|"insert into COMPLETED_COMPACTIONS(CC_ID, CC_DATABASE, CC_TABLE, CC_PARTITION, CC_STATE, CC_TYPE, CC_WORKER_ID, CC_START, CC_END, CC_RUN_AS, CC_HIGHEST_TXN_ID, CC_META_INFO, CC_HADOOP_JOB_ID) VALUES(?,?,?,?,?, ?,?,?,?,?, ?,?,?)"
argument_list|)
expr_stmt|;
name|ci
operator|.
name|state
operator|=
name|FAILED_STATE
expr_stmt|;
name|CompactionInfo
operator|.
name|insertIntoCompletedCompactions
argument_list|(
name|pStmt
argument_list|,
name|ci
argument_list|,
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|updCount
init|=
name|pStmt
operator|.
name|executeUpdate
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to delete from compaction queue "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
try|try
block|{
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"markFailed("
operator|+
name|ci
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MetaException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|null
argument_list|,
name|pStmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|markFailed
argument_list|(
name|ci
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

