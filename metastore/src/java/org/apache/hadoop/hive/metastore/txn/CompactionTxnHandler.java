begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|txn
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Extends the transaction handler with methods needed only by the compactor threads.  These  * methods are not available through the thrift interface.  */
end_comment

begin_class
specifier|public
class|class
name|CompactionTxnHandler
extends|extends
name|TxnHandler
block|{
specifier|static
specifier|final
specifier|private
name|String
name|CLASS_NAME
init|=
name|CompactionTxnHandler
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|CLASS_NAME
argument_list|)
decl_stmt|;
comment|// Always access COMPACTION_QUEUE before COMPLETED_TXN_COMPONENTS
comment|// See TxnHandler for notes on how to deal with deadlocks.  Follow those notes.
specifier|public
name|CompactionTxnHandler
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * This will look through the completed_txn_components table and look for partitions or tables    * that may be ready for compaction.  Also, look through txns and txn_components tables for    * aborted transactions that we should add to the list.    * @param maxAborted Maximum number of aborted queries to allow before marking this as a    *                   potential compaction.    * @return list of CompactionInfo structs.  These will not have id, type,    * or runAs set since these are only potential compactions not actual ones.    */
specifier|public
name|Set
argument_list|<
name|CompactionInfo
argument_list|>
name|findPotentialCompactions
parameter_list|(
name|int
name|maxAborted
parameter_list|)
throws|throws
name|MetaException
block|{
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|CompactionInfo
argument_list|>
name|response
init|=
operator|new
name|HashSet
argument_list|<
name|CompactionInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
comment|// Check for completed transactions
name|String
name|s
init|=
literal|"select distinct ctc_database, ctc_table, "
operator|+
literal|"ctc_partition from COMPLETED_TXN_COMPONENTS"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|CompactionInfo
name|info
init|=
operator|new
name|CompactionInfo
argument_list|()
decl_stmt|;
name|info
operator|.
name|dbname
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|info
operator|.
name|tableName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|info
operator|.
name|partName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|response
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
comment|// Check for aborted txns
name|s
operator|=
literal|"select tc_database, tc_table, tc_partition "
operator|+
literal|"from TXNS, TXN_COMPONENTS "
operator|+
literal|"where txn_id = tc_txnid and txn_state = '"
operator|+
name|TXN_ABORTED
operator|+
literal|"' "
operator|+
literal|"group by tc_database, tc_table, tc_partition "
operator|+
literal|"having count(*)> "
operator|+
name|maxAborted
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|CompactionInfo
name|info
init|=
operator|new
name|CompactionInfo
argument_list|()
decl_stmt|;
name|info
operator|.
name|dbname
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|info
operator|.
name|tableName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|info
operator|.
name|partName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|info
operator|.
name|tooManyAborts
operator|=
literal|true
expr_stmt|;
name|response
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
return|return
name|response
return|;
block|}
comment|/**    * Sets the user to run as.  This is for the case    * where the request was generated by the user and so the worker must set this value later.    * @param cq_id id of this entry in the queue    * @param user user to run the jobs as    */
specifier|public
name|void
name|setRunAs
parameter_list|(
name|long
name|cq_id
parameter_list|,
name|String
name|user
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_SERIALIZABLE
argument_list|)
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"update COMPACTION_QUEUE set cq_run_as = '"
operator|+
name|user
operator|+
literal|"' where cq_id = "
operator|+
name|cq_id
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to update compaction record"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to update compaction queue, "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e1
parameter_list|)
block|{        }
name|detectDeadlock
argument_list|(
name|e
argument_list|,
literal|"setRunAs"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DeadlockException
name|e
parameter_list|)
block|{
name|setRunAs
argument_list|(
name|cq_id
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|deadlockCnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/**    * This will grab the next compaction request off of    * the queue, and assign it to the worker.    * @param workerId id of the worker calling this, will be recorded in the db    * @return an info element for this compaction request, or null if there is no work to do now.    */
specifier|public
name|CompactionInfo
name|findNextToCompact
parameter_list|(
name|String
name|workerId
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_SERIALIZABLE
argument_list|)
decl_stmt|;
name|CompactionInfo
name|info
init|=
operator|new
name|CompactionInfo
argument_list|()
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select cq_id, cq_database, cq_table, cq_partition, "
operator|+
literal|"cq_type from COMPACTION_QUEUE where cq_state = '"
operator|+
name|INITIATED_STATE
operator|+
literal|"'"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No compactions found ready to compact"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
name|info
operator|.
name|id
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|info
operator|.
name|dbname
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|info
operator|.
name|tableName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|info
operator|.
name|partName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|MAJOR_TYPE
case|:
name|info
operator|.
name|type
operator|=
name|CompactionType
operator|.
name|MAJOR
expr_stmt|;
break|break;
case|case
name|MINOR_TYPE
case|:
name|info
operator|.
name|type
operator|=
name|CompactionType
operator|.
name|MINOR
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unexpected compaction type "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
argument_list|)
throw|;
block|}
comment|// Now, update this record as being worked on by this worker.
name|long
name|now
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|s
operator|=
literal|"update COMPACTION_QUEUE set cq_worker_id = '"
operator|+
name|workerId
operator|+
literal|"', "
operator|+
literal|"cq_start = "
operator|+
name|now
operator|+
literal|", cq_state = '"
operator|+
name|WORKING_STATE
operator|+
literal|"' where cq_id = "
operator|+
name|info
operator|.
name|id
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to update compaction record"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
name|info
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to select next element for compaction, "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e1
parameter_list|)
block|{         }
name|detectDeadlock
argument_list|(
name|e
argument_list|,
literal|"findNextToCompact"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DeadlockException
name|e
parameter_list|)
block|{
return|return
name|findNextToCompact
argument_list|(
name|workerId
argument_list|)
return|;
block|}
finally|finally
block|{
name|deadlockCnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/**    * This will mark an entry in the queue as compacted    * and put it in the ready to clean state.    * @param info info on the compaciton entry to mark as compacted.    */
specifier|public
name|void
name|markCompacted
parameter_list|(
name|CompactionInfo
name|info
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_SERIALIZABLE
argument_list|)
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"update COMPACTION_QUEUE set cq_state = '"
operator|+
name|READY_FOR_CLEANING
operator|+
literal|"', "
operator|+
literal|"cq_worker_id = null where cq_id = "
operator|+
name|info
operator|.
name|id
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to update compaction record"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
try|try
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to update compaction queue "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e1
parameter_list|)
block|{         }
name|detectDeadlock
argument_list|(
name|e
argument_list|,
literal|"markCompacted"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DeadlockException
name|e
parameter_list|)
block|{
name|markCompacted
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|deadlockCnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/**    * Find entries in the queue that are ready to    * be cleaned.    * @return information on the entry in the queue.    */
specifier|public
name|List
argument_list|<
name|CompactionInfo
argument_list|>
name|findReadyToClean
parameter_list|()
throws|throws
name|MetaException
block|{
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|CompactionInfo
argument_list|>
name|rc
init|=
operator|new
name|ArrayList
argument_list|<
name|CompactionInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select cq_id, cq_database, cq_table, cq_partition, "
operator|+
literal|"cq_type, cq_run_as from COMPACTION_QUEUE where cq_state = '"
operator|+
name|READY_FOR_CLEANING
operator|+
literal|"'"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|CompactionInfo
name|info
init|=
operator|new
name|CompactionInfo
argument_list|()
decl_stmt|;
name|info
operator|.
name|id
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|info
operator|.
name|dbname
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|info
operator|.
name|tableName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|info
operator|.
name|partName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|MAJOR_TYPE
case|:
name|info
operator|.
name|type
operator|=
name|CompactionType
operator|.
name|MAJOR
expr_stmt|;
break|break;
case|case
name|MINOR_TYPE
case|:
name|info
operator|.
name|type
operator|=
name|CompactionType
operator|.
name|MINOR
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unexpected compaction type "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
argument_list|)
throw|;
block|}
name|info
operator|.
name|runAs
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|rc
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
name|rc
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to select next element for cleaning, "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e1
parameter_list|)
block|{       }
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This will remove an entry from the queue after    * it has been compacted.    * @param info info on the compaction entry to remove    */
specifier|public
name|void
name|markCleaned
parameter_list|(
name|CompactionInfo
name|info
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_SERIALIZABLE
argument_list|)
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"delete from COMPACTION_QUEUE where cq_id = "
operator|+
name|info
operator|.
name|id
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to delete compaction record"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
comment|// Remove entries from completed_txn_components as well, so we don't start looking there
comment|// again.
name|s
operator|=
literal|"delete from COMPLETED_TXN_COMPONENTS where ctc_database = '"
operator|+
name|info
operator|.
name|dbname
operator|+
literal|"' and "
operator|+
literal|"ctc_table = '"
operator|+
name|info
operator|.
name|tableName
operator|+
literal|"'"
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|partName
operator|!=
literal|null
condition|)
block|{
name|s
operator|+=
literal|" and ctc_partition = '"
operator|+
name|info
operator|.
name|partName
operator|+
literal|"'"
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Expected to remove at least one row from completed_txn_components when "
operator|+
literal|"marking compaction entry as clean!"
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
literal|"select txn_id from TXNS, TXN_COMPONENTS where txn_id = tc_txnid and txn_state = '"
operator|+
name|TXN_ABORTED
operator|+
literal|"' and tc_database = '"
operator|+
name|info
operator|.
name|dbname
operator|+
literal|"' and tc_table = '"
operator|+
name|info
operator|.
name|tableName
operator|+
literal|"'"
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|partName
operator|!=
literal|null
condition|)
name|s
operator|+=
literal|" and tc_partition = '"
operator|+
name|info
operator|.
name|partName
operator|+
literal|"'"
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Long
argument_list|>
name|txnids
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
name|txnids
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|txnids
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Remove entries from txn_components, as there may be aborted txn components
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"delete from TXN_COMPONENTS where tc_txnid in ("
argument_list|)
expr_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|long
name|id
range|:
name|txnids
control|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|false
expr_stmt|;
else|else
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|") and tc_database = '"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|info
operator|.
name|dbname
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"' and tc_table = '"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|info
operator|.
name|tableName
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|partName
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|" and tc_partition = '"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|info
operator|.
name|partName
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|buf
operator|.
name|toString
argument_list|()
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removed "
operator|+
name|rc
operator|+
literal|" records from txn_components"
argument_list|)
expr_stmt|;
comment|// Don't bother cleaning from the txns table.  A separate call will do that.  We don't
comment|// know here which txns still have components from other tables or partitions in the
comment|// table, so we don't know which ones we can and cannot clean.
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
try|try
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to delete from compaction queue "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e1
parameter_list|)
block|{         }
name|detectDeadlock
argument_list|(
name|e
argument_list|,
literal|"markCleaned"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DeadlockException
name|e
parameter_list|)
block|{
name|markCleaned
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|deadlockCnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/**    * Clean up aborted transactions from txns that have no components in txn_components.    */
specifier|public
name|void
name|cleanEmptyAbortedTxns
parameter_list|()
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_SERIALIZABLE
argument_list|)
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select txn_id from TXNS where "
operator|+
literal|"txn_id not in (select tc_txnid from TXN_COMPONENTS) and "
operator|+
literal|"txn_state = '"
operator|+
name|TXN_ABORTED
operator|+
literal|"'"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Long
argument_list|>
name|txnids
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
name|txnids
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|txnids
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|(
literal|"delete from TXNS where txn_id in ("
argument_list|)
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|long
name|tid
range|:
name|txnids
control|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|false
expr_stmt|;
else|else
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|tid
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|buf
operator|.
name|toString
argument_list|()
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removed "
operator|+
name|rc
operator|+
literal|" records from txns"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to delete from txns table "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
try|try
block|{
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e1
parameter_list|)
block|{         }
name|detectDeadlock
argument_list|(
name|e
argument_list|,
literal|"cleanEmptyAbortedTxns"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DeadlockException
name|e
parameter_list|)
block|{
name|cleanEmptyAbortedTxns
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|deadlockCnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/**    * This will take all entries assigned to workers    * on a host return them to INITIATED state.  The initiator should use this at start up to    * clean entries from any workers that were in the middle of compacting when the metastore    * shutdown.  It does not reset entries from worker threads on other hosts as those may still    * be working.    * @param hostname Name of this host.  It is assumed this prefixes the thread's worker id,    *                 so that like hostname% will match the worker id.    */
specifier|public
name|void
name|revokeFromLocalWorkers
parameter_list|(
name|String
name|hostname
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_SERIALIZABLE
argument_list|)
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"update COMPACTION_QUEUE set cq_worker_id = null, cq_start = null, cq_state = '"
operator|+
name|INITIATED_STATE
operator|+
literal|"' where cq_state = '"
operator|+
name|WORKING_STATE
operator|+
literal|"' and cq_worker_id like '"
operator|+
name|hostname
operator|+
literal|"%'"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
comment|// It isn't an error if the following returns no rows, as the local workers could have died
comment|// with  nothing assigned to them.
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
try|try
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to change dead worker's records back to initiated state "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e1
parameter_list|)
block|{         }
name|detectDeadlock
argument_list|(
name|e
argument_list|,
literal|"revokeFromLocalWorkers"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DeadlockException
name|e
parameter_list|)
block|{
name|revokeFromLocalWorkers
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|deadlockCnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/**    * This call will return all compaction queue    * entries assigned to a worker but over the timeout back to the initiated state.    * This should be called by the initiator on start up and occasionally when running to clean up    * after dead threads.  At start up {@link #revokeFromLocalWorkers(String)} should be called    * first.    * @param timeout number of milliseconds since start time that should elapse before a worker is    *                declared dead.    */
specifier|public
name|void
name|revokeTimedoutWorkers
parameter_list|(
name|long
name|timeout
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_SERIALIZABLE
argument_list|)
decl_stmt|;
name|long
name|latestValidStart
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
operator|-
name|timeout
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"update COMPACTION_QUEUE set cq_worker_id = null, cq_start = null, cq_state = '"
operator|+
name|INITIATED_STATE
operator|+
literal|"' where cq_state = '"
operator|+
name|WORKING_STATE
operator|+
literal|"' and cq_start< "
operator|+
name|latestValidStart
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
comment|// It isn't an error if the following returns no rows, as the local workers could have died
comment|// with  nothing assigned to them.
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
try|try
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to change dead worker's records back to initiated state "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e1
parameter_list|)
block|{         }
name|detectDeadlock
argument_list|(
name|e
argument_list|,
literal|"revokeTimedoutWorkers"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DeadlockException
name|e
parameter_list|)
block|{
name|revokeTimedoutWorkers
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|deadlockCnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/**    * Queries metastore DB directly to find columns in the table which have statistics information.    * If {@code ci} includes partition info then per partition stats info is examined, otherwise    * table level stats are examined.    * @throws MetaException    */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|findColumnsWithStats
parameter_list|(
name|CompactionInfo
name|ci
parameter_list|)
throws|throws
name|MetaException
block|{
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"SELECT COLUMN_NAME FROM "
operator|+
operator|(
name|ci
operator|.
name|partName
operator|==
literal|null
condition|?
literal|"TAB_COL_STATS"
else|:
literal|"PART_COL_STATS"
operator|)
operator|+
literal|" WHERE DB_NAME='"
operator|+
name|ci
operator|.
name|dbname
operator|+
literal|"' AND TABLE_NAME='"
operator|+
name|ci
operator|.
name|tableName
operator|+
literal|"'"
operator|+
operator|(
name|ci
operator|.
name|partName
operator|==
literal|null
condition|?
literal|""
else|:
literal|" AND PARTITION_NAME='"
operator|+
name|ci
operator|.
name|partName
operator|+
literal|"'"
operator|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|columns
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|columns
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found columns to update stats: "
operator|+
name|columns
operator|+
literal|" on "
operator|+
name|ci
operator|.
name|tableName
operator|+
operator|(
name|ci
operator|.
name|partName
operator|==
literal|null
condition|?
literal|""
else|:
literal|"/"
operator|+
name|ci
operator|.
name|partName
operator|)
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
name|columns
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
try|try
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to find columns to analyze stats on for "
operator|+
name|ci
operator|.
name|tableName
operator|+
operator|(
name|ci
operator|.
name|partName
operator|==
literal|null
condition|?
literal|""
else|:
literal|"/"
operator|+
name|ci
operator|.
name|partName
operator|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e1
parameter_list|)
block|{
comment|//nothing we can do here
block|}
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

