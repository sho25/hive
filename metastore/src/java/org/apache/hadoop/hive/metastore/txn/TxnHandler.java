begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|txn
package|;
end_package

begin_import
import|import
name|com
operator|.
name|jolbox
operator|.
name|bonecp
operator|.
name|BoneCP
import|;
end_import

begin_import
import|import
name|com
operator|.
name|jolbox
operator|.
name|bonecp
operator|.
name|BoneCPConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ValidTxnList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ValidTxnListImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * A handler to answer transaction related calls that come into the metastore  * server.  */
end_comment

begin_class
specifier|public
class|class
name|TxnHandler
block|{
comment|// Compactor states
specifier|static
specifier|final
specifier|public
name|String
name|INITIATED_RESPONSE
init|=
literal|"initiated"
decl_stmt|;
specifier|static
specifier|final
specifier|public
name|String
name|WORKING_RESPONSE
init|=
literal|"working"
decl_stmt|;
specifier|static
specifier|final
specifier|public
name|String
name|CLEANING_RESPONSE
init|=
literal|"ready for cleaning"
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|INITIATED_STATE
init|=
literal|'i'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|WORKING_STATE
init|=
literal|'w'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|READY_FOR_CLEANING
init|=
literal|'r'
decl_stmt|;
comment|// Compactor types
specifier|static
specifier|final
specifier|protected
name|char
name|MAJOR_TYPE
init|=
literal|'a'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|MINOR_TYPE
init|=
literal|'i'
decl_stmt|;
comment|// Transaction states
specifier|static
specifier|final
specifier|protected
name|char
name|TXN_ABORTED
init|=
literal|'a'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|TXN_OPEN
init|=
literal|'o'
decl_stmt|;
comment|// Lock states
specifier|static
specifier|final
specifier|private
name|char
name|LOCK_ACQUIRED
init|=
literal|'a'
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|char
name|LOCK_WAITING
init|=
literal|'w'
decl_stmt|;
comment|// Lock types
specifier|static
specifier|final
specifier|private
name|char
name|LOCK_EXCLUSIVE
init|=
literal|'e'
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|char
name|LOCK_SHARED
init|=
literal|'r'
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|char
name|LOCK_SEMI_SHARED
init|=
literal|'w'
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|int
name|ALLOWED_REPEATED_DEADLOCKS
init|=
literal|5
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TxnHandler
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|static
specifier|private
name|BoneCP
name|connPool
decl_stmt|;
specifier|private
specifier|static
name|Boolean
name|lockLock
init|=
operator|new
name|Boolean
argument_list|(
literal|"true"
argument_list|)
decl_stmt|;
comment|// Random object to lock on for the lock
comment|// method
comment|/**    * Number of consecutive deadlocks we have seen    */
specifier|protected
name|int
name|deadlockCnt
decl_stmt|;
specifier|protected
name|HiveConf
name|conf
decl_stmt|;
comment|// Transaction timeout, in milliseconds.
specifier|private
name|long
name|timeout
decl_stmt|;
comment|// DEADLOCK DETECTION AND HANDLING
comment|// A note to developers of this class.  ALWAYS access HIVE_LOCKS before TXNS to avoid deadlock
comment|// between simultaneous accesses.  ALWAYS access TXN_COMPONENTS before HIVE_LOCKS .
comment|//
comment|// Private methods should never catch SQLException and then throw MetaException.  The public
comment|// methods depend on SQLException coming back so they can detect and handle deadlocks.  Private
comment|// methods should only throw MetaException when they explicitly know there's a logic error and
comment|// they want to throw past the public methods.
comment|//
comment|// All public methods that write to the database have to check for deadlocks when a SQLException
comment|// comes back and handle it if they see one.  This has to be done with the connection pooling
comment|// in mind.  To do this they should call detectDeadlock AFTER rolling back the db transaction,
comment|// and then in an outer loop they should catch DeadlockException.  In the catch for this they
comment|// should increment the deadlock counter and recall themselves.  See commitTxn for an example.
comment|// the connection has been closed and returned to the pool.
specifier|public
name|TxnHandler
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|checkQFileTestHack
argument_list|()
expr_stmt|;
comment|// Set up the JDBC connection pool
try|try
block|{
name|setupJdbcConnectionPool
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"Unable to instantiate JDBC connection pooling, "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|timeout
operator|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_TXN_TIMEOUT
argument_list|)
operator|*
literal|1000
expr_stmt|;
name|deadlockCnt
operator|=
literal|0
expr_stmt|;
name|buildJumpTable
argument_list|()
expr_stmt|;
block|}
specifier|public
name|GetOpenTxnsInfoResponse
name|getOpenTxnsInfo
parameter_list|()
throws|throws
name|MetaException
block|{
comment|// We need to figure out the current transaction number and the list of
comment|// open transactions.  To avoid needing a transaction on the underlying
comment|// database we'll look at the current transaction number first.  If it
comment|// subsequently shows up in the open list that's ok.
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|()
decl_stmt|;
try|try
block|{
name|Statement
name|stmt
init|=
name|dbConn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<select ntxn_next - 1 from "
operator|+
literal|"NEXT_TXN_ID>"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
literal|"select ntxn_next - 1 from NEXT_TXN_ID"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly "
operator|+
literal|"initialized, no record found in next_txn_id"
argument_list|)
throw|;
block|}
name|long
name|hwm
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly "
operator|+
literal|"initialized, null record found in next_txn_id"
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|TxnInfo
argument_list|>
name|txnInfo
init|=
operator|new
name|ArrayList
argument_list|<
name|TxnInfo
argument_list|>
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<select txn_id, txn_state from TXNS>"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
literal|"select txn_id, txn_state, txn_user, txn_host from TXNS"
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|char
name|c
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|TxnState
name|state
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|TXN_ABORTED
case|:
name|state
operator|=
name|TxnState
operator|.
name|ABORTED
expr_stmt|;
break|break;
case|case
name|TXN_OPEN
case|:
name|state
operator|=
name|TxnState
operator|.
name|OPEN
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unexpected transaction state "
operator|+
name|c
operator|+
literal|" found in txns table"
argument_list|)
throw|;
block|}
name|txnInfo
operator|.
name|add
argument_list|(
operator|new
name|TxnInfo
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|,
name|state
argument_list|,
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
argument_list|,
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
operator|new
name|GetOpenTxnsInfoResponse
argument_list|(
name|hwm
argument_list|,
name|txnInfo
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e1
parameter_list|)
block|{       }
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database, "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|GetOpenTxnsResponse
name|getOpenTxns
parameter_list|()
throws|throws
name|MetaException
block|{
comment|// We need to figure out the current transaction number and the list of
comment|// open transactions.  To avoid needing a transaction on the underlying
comment|// database we'll look at the current transaction number first.  If it
comment|// subsequently shows up in the open list that's ok.
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|()
decl_stmt|;
try|try
block|{
name|Statement
name|stmt
init|=
name|dbConn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<select ntxn_next - 1 from "
operator|+
literal|"NEXT_TXN_ID>"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
literal|"select ntxn_next - 1 from NEXT_TXN_ID"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly "
operator|+
literal|"initialized, no record found in next_txn_id"
argument_list|)
throw|;
block|}
name|long
name|hwm
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly "
operator|+
literal|"initialized, null record found in next_txn_id"
argument_list|)
throw|;
block|}
name|Set
argument_list|<
name|Long
argument_list|>
name|openList
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<select txn_id from TXNS>"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
literal|"select txn_id from TXNS"
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|openList
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
operator|new
name|GetOpenTxnsResponse
argument_list|(
name|hwm
argument_list|,
name|openList
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e1
parameter_list|)
block|{       }
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database, "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|ValidTxnList
name|createValidTxnList
parameter_list|(
name|GetOpenTxnsResponse
name|txns
parameter_list|)
block|{
name|long
name|highWater
init|=
name|txns
operator|.
name|getTxn_high_water_mark
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Long
argument_list|>
name|open
init|=
name|txns
operator|.
name|getOpen_txns
argument_list|()
decl_stmt|;
name|long
index|[]
name|exceptions
init|=
operator|new
name|long
index|[
name|open
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|long
name|txn
range|:
name|open
control|)
block|{
name|exceptions
index|[
name|i
operator|++
index|]
operator|=
name|txn
expr_stmt|;
block|}
return|return
operator|new
name|ValidTxnListImpl
argument_list|(
name|exceptions
argument_list|,
name|highWater
argument_list|)
return|;
block|}
specifier|public
name|OpenTxnsResponse
name|openTxns
parameter_list|(
name|OpenTxnRequest
name|rqst
parameter_list|)
throws|throws
name|MetaException
block|{
name|int
name|numTxns
init|=
name|rqst
operator|.
name|getNum_txns
argument_list|()
decl_stmt|;
try|try
block|{
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|()
decl_stmt|;
try|try
block|{
comment|// Make sure the user has not requested an insane amount of txns.
name|int
name|maxTxns
init|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_TXN_MAX_OPEN_BATCH
argument_list|)
decl_stmt|;
if|if
condition|(
name|numTxns
operator|>
name|maxTxns
condition|)
name|numTxns
operator|=
name|maxTxns
expr_stmt|;
name|Statement
name|stmt
init|=
name|dbConn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<select ntxn_next from NEXT_TXN_ID "
operator|+
literal|" for update>"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
literal|"select ntxn_next from NEXT_TXN_ID for update"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction database not properly "
operator|+
literal|"configured, can't find next transaction id."
argument_list|)
throw|;
block|}
name|long
name|first
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|String
name|s
init|=
literal|"update NEXT_TXN_ID set ntxn_next = "
operator|+
operator|(
name|first
operator|+
name|numTxns
operator|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|s
operator|=
literal|"insert into TXNS (txn_id, txn_state, txn_started, "
operator|+
literal|"txn_last_heartbeat, txn_user, txn_host) values (?, 'o', "
operator|+
name|now
operator|+
literal|", "
operator|+
name|now
operator|+
literal|", '"
operator|+
name|rqst
operator|.
name|getUser
argument_list|()
operator|+
literal|"', '"
operator|+
name|rqst
operator|.
name|getHostname
argument_list|()
operator|+
literal|"')"
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to prepare statement<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|PreparedStatement
name|ps
init|=
name|dbConn
operator|.
name|prepareStatement
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|txnIds
init|=
operator|new
name|ArrayList
argument_list|<
name|Long
argument_list|>
argument_list|(
name|numTxns
argument_list|)
decl_stmt|;
for|for
control|(
name|long
name|i
init|=
name|first
init|;
name|i
operator|<
name|first
operator|+
name|numTxns
condition|;
name|i
operator|++
control|)
block|{
name|ps
operator|.
name|setLong
argument_list|(
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ps
operator|.
name|executeUpdate
argument_list|()
expr_stmt|;
name|txnIds
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
operator|new
name|OpenTxnsResponse
argument_list|(
name|txnIds
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e1
parameter_list|)
block|{         }
name|detectDeadlock
argument_list|(
name|e
argument_list|,
literal|"openTxns"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DeadlockException
name|e
parameter_list|)
block|{
return|return
name|openTxns
argument_list|(
name|rqst
argument_list|)
return|;
block|}
finally|finally
block|{
name|deadlockCnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|abortTxn
parameter_list|(
name|AbortTxnRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|MetaException
block|{
name|long
name|txnid
init|=
name|rqst
operator|.
name|getTxnid
argument_list|()
decl_stmt|;
try|try
block|{
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|()
decl_stmt|;
try|try
block|{
name|Statement
name|stmt
init|=
name|dbConn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
comment|// delete from HIVE_LOCKS first, we always access HIVE_LOCKS before TXNS
name|String
name|s
init|=
literal|"delete from HIVE_LOCKS where hl_txnid = "
operator|+
name|txnid
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
literal|"update TXNS set txn_state = '"
operator|+
name|TXN_ABORTED
operator|+
literal|"' where txn_id = "
operator|+
name|txnid
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|updateCnt
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|updateCnt
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|NoSuchTxnException
argument_list|(
literal|"No such transaction: "
operator|+
name|txnid
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e1
parameter_list|)
block|{         }
name|detectDeadlock
argument_list|(
name|e
argument_list|,
literal|"abortTxn"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DeadlockException
name|e
parameter_list|)
block|{
name|abortTxn
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|deadlockCnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|commitTxn
parameter_list|(
name|CommitTxnRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
name|long
name|txnid
init|=
name|rqst
operator|.
name|getTxnid
argument_list|()
decl_stmt|;
try|try
block|{
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|()
decl_stmt|;
try|try
block|{
name|Statement
name|stmt
init|=
name|dbConn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
comment|// Before we do the commit heartbeat the txn.  This is slightly odd in that we're going to
comment|// commit it, but it does two things.  One, it makes sure the transaction is still valid.
comment|// Two, it avoids the race condition where we time out between now and when we actually
comment|// commit the transaction below.  And it does this all in a dead-lock safe way by
comment|// committing the heartbeat back to the database.
name|heartbeatTxn
argument_list|(
name|dbConn
argument_list|,
name|txnid
argument_list|)
expr_stmt|;
comment|// Move the record from txn_components into completed_txn_components so that the compactor
comment|// knows where to look to compact.
name|String
name|s
init|=
literal|"insert into COMPLETED_TXN_COMPONENTS select tc_txnid, tc_database, tc_table, "
operator|+
literal|"tc_partition from TXN_COMPONENTS where tc_txnid = "
operator|+
name|txnid
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute insert<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Expected to move at least one record from txn_components to "
operator|+
literal|"completed_txn_components when committing txn!"
argument_list|)
expr_stmt|;
block|}
comment|// Always access TXN_COMPONENTS before HIVE_LOCKS;
name|s
operator|=
literal|"delete from TXN_COMPONENTS where tc_txnid = "
operator|+
name|txnid
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|// Always access HIVE_LOCKS before TXNS
name|s
operator|=
literal|"delete from HIVE_LOCKS where hl_txnid = "
operator|+
name|txnid
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
literal|"delete from TXNS where txn_id = "
operator|+
name|txnid
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e1
parameter_list|)
block|{         }
name|detectDeadlock
argument_list|(
name|e
argument_list|,
literal|"commitTxn"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DeadlockException
name|e
parameter_list|)
block|{
name|commitTxn
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|deadlockCnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
specifier|public
name|LockResponse
name|lock
parameter_list|(
name|LockRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|lock
argument_list|(
name|dbConn
argument_list|,
name|rqst
argument_list|,
literal|true
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e1
parameter_list|)
block|{         }
name|detectDeadlock
argument_list|(
name|e
argument_list|,
literal|"lock"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DeadlockException
name|e
parameter_list|)
block|{
return|return
name|lock
argument_list|(
name|rqst
argument_list|)
return|;
block|}
finally|finally
block|{
name|deadlockCnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
specifier|public
name|LockResponse
name|lockNoWait
parameter_list|(
name|LockRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|lock
argument_list|(
name|dbConn
argument_list|,
name|rqst
argument_list|,
literal|false
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e1
parameter_list|)
block|{         }
name|detectDeadlock
argument_list|(
name|e
argument_list|,
literal|"lockNoWait"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DeadlockException
name|e
parameter_list|)
block|{
return|return
name|lockNoWait
argument_list|(
name|rqst
argument_list|)
return|;
block|}
finally|finally
block|{
name|deadlockCnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
specifier|public
name|LockResponse
name|checkLock
parameter_list|(
name|CheckLockRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|NoSuchLockException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|()
decl_stmt|;
try|try
block|{
name|long
name|extLockId
init|=
name|rqst
operator|.
name|getLockid
argument_list|()
decl_stmt|;
comment|// Clean up timed out locks
name|timeOutLocks
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
comment|// Heartbeat on the lockid first, to assure that our lock is still valid.
comment|// Then look up the lock info (hopefully in the cache).  If these locks
comment|// are associated with a transaction then heartbeat on that as well.
name|heartbeatLock
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
expr_stmt|;
name|long
name|txnid
init|=
name|getTxnIdFromLockId
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|txnid
operator|>
literal|0
condition|)
name|heartbeatTxn
argument_list|(
name|dbConn
argument_list|,
name|txnid
argument_list|)
expr_stmt|;
return|return
name|checkLock
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|,
name|txnid
argument_list|,
literal|true
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e1
parameter_list|)
block|{         }
name|detectDeadlock
argument_list|(
name|e
argument_list|,
literal|"checkLock"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DeadlockException
name|e
parameter_list|)
block|{
return|return
name|checkLock
argument_list|(
name|rqst
argument_list|)
return|;
block|}
finally|finally
block|{
name|deadlockCnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|unlock
parameter_list|(
name|UnlockRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchLockException
throws|,
name|TxnOpenException
throws|,
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|()
decl_stmt|;
try|try
block|{
comment|// Odd as it seems, we need to heartbeat first because this touches the
comment|// lock table and assures that our locks our still valid.  If they are
comment|// not, this will throw an exception and the heartbeat will fail.
name|long
name|extLockId
init|=
name|rqst
operator|.
name|getLockid
argument_list|()
decl_stmt|;
name|heartbeatLock
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
expr_stmt|;
name|long
name|txnid
init|=
name|getTxnIdFromLockId
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
decl_stmt|;
comment|// If there is a valid txnid, throw an exception,
comment|// as locks associated with transactions should be unlocked only when the
comment|// transaction is committed or aborted.
if|if
condition|(
name|txnid
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
name|String
name|msg
init|=
literal|"Unlocking locks associated with transaction"
operator|+
literal|" not permitted.  Lockid "
operator|+
name|extLockId
operator|+
literal|" is associated with "
operator|+
literal|"transaction "
operator|+
name|txnid
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|TxnOpenException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
name|Statement
name|stmt
init|=
name|dbConn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|String
name|s
init|=
literal|"delete from HIVE_LOCKS where hl_lock_ext_id = "
operator|+
name|extLockId
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|NoSuchLockException
argument_list|(
literal|"No such lock: "
operator|+
name|extLockId
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e1
parameter_list|)
block|{         }
name|detectDeadlock
argument_list|(
name|e
argument_list|,
literal|"unlock"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DeadlockException
name|e
parameter_list|)
block|{
name|unlock
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|deadlockCnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
specifier|public
name|ShowLocksResponse
name|showLocks
parameter_list|(
name|ShowLocksRequest
name|rqst
parameter_list|)
throws|throws
name|MetaException
block|{
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|()
decl_stmt|;
name|ShowLocksResponse
name|rsp
init|=
operator|new
name|ShowLocksResponse
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ShowLocksResponseElement
argument_list|>
name|elems
init|=
operator|new
name|ArrayList
argument_list|<
name|ShowLocksResponseElement
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|Statement
name|stmt
init|=
name|dbConn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|String
name|s
init|=
literal|"select hl_lock_ext_id, hl_txnid, hl_db, hl_table, hl_partition, hl_lock_state, "
operator|+
literal|"hl_lock_type, hl_last_heartbeat, hl_acquired_at, hl_user, hl_host from HIVE_LOCKS"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Doing to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|ShowLocksResponseElement
name|e
init|=
operator|new
name|ShowLocksResponseElement
argument_list|()
decl_stmt|;
name|e
operator|.
name|setLockid
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|txnid
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
name|e
operator|.
name|setTxnid
argument_list|(
name|txnid
argument_list|)
expr_stmt|;
name|e
operator|.
name|setDbname
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setTablename
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|partition
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
name|partition
operator|!=
literal|null
condition|)
name|e
operator|.
name|setPartname
argument_list|(
name|partition
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|LOCK_ACQUIRED
case|:
name|e
operator|.
name|setState
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCK_WAITING
case|:
name|e
operator|.
name|setState
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unknown lock state "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|7
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|LOCK_SEMI_SHARED
case|:
name|e
operator|.
name|setType
argument_list|(
name|LockType
operator|.
name|SHARED_WRITE
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCK_EXCLUSIVE
case|:
name|e
operator|.
name|setType
argument_list|(
name|LockType
operator|.
name|EXCLUSIVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCK_SHARED
case|:
name|e
operator|.
name|setType
argument_list|(
name|LockType
operator|.
name|SHARED_READ
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unknown lock type "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
throw|;
block|}
name|e
operator|.
name|setLastheartbeat
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|acquiredAt
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|9
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
name|e
operator|.
name|setAcquiredat
argument_list|(
name|acquiredAt
argument_list|)
expr_stmt|;
name|e
operator|.
name|setUser
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setHostname
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|11
argument_list|)
argument_list|)
expr_stmt|;
name|elems
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
name|rsp
operator|.
name|setLocks
argument_list|(
name|elems
argument_list|)
expr_stmt|;
return|return
name|rsp
return|;
block|}
specifier|public
name|void
name|heartbeat
parameter_list|(
name|HeartbeatRequest
name|ids
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|NoSuchLockException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|()
decl_stmt|;
try|try
block|{
name|heartbeatLock
argument_list|(
name|dbConn
argument_list|,
name|ids
operator|.
name|getLockid
argument_list|()
argument_list|)
expr_stmt|;
name|heartbeatTxn
argument_list|(
name|dbConn
argument_list|,
name|ids
operator|.
name|getTxnid
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e1
parameter_list|)
block|{         }
name|detectDeadlock
argument_list|(
name|e
argument_list|,
literal|"heartbeat"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DeadlockException
name|e
parameter_list|)
block|{
name|heartbeat
argument_list|(
name|ids
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|deadlockCnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|compact
parameter_list|(
name|CompactionRequest
name|rqst
parameter_list|)
throws|throws
name|MetaException
block|{
comment|// Put a compaction request in the queue.
try|try
block|{
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|()
decl_stmt|;
try|try
block|{
name|Statement
name|stmt
init|=
name|dbConn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
comment|// Get the id for the next entry in the queue
name|String
name|s
init|=
literal|"select ncq_next from NEXT_COMPACTION_QUEUE_ID for update"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly initiated, "
operator|+
literal|"no record found in next_compaction_queue_id"
argument_list|)
throw|;
block|}
name|long
name|id
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|s
operator|=
literal|"update NEXT_COMPACTION_QUEUE_ID set ncq_next = "
operator|+
operator|(
name|id
operator|+
literal|1
operator|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"insert into COMPACTION_QUEUE (cq_id, cq_database, "
operator|+
literal|"cq_table, "
argument_list|)
decl_stmt|;
name|String
name|partName
init|=
name|rqst
operator|.
name|getPartitionname
argument_list|()
decl_stmt|;
if|if
condition|(
name|partName
operator|!=
literal|null
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|"cq_partition, "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"cq_state, cq_type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqst
operator|.
name|getRunas
argument_list|()
operator|!=
literal|null
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|", cq_run_as"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|") values ("
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|", '"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|rqst
operator|.
name|getDbname
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|rqst
operator|.
name|getTablename
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
if|if
condition|(
name|partName
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|partName
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|INITIATED_STATE
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rqst
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|MAJOR
case|:
name|buf
operator|.
name|append
argument_list|(
name|MAJOR_TYPE
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINOR
case|:
name|buf
operator|.
name|append
argument_list|(
name|MINOR_TYPE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unexpected compaction type "
operator|+
name|rqst
operator|.
name|getType
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|rqst
operator|.
name|getRunas
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|rqst
operator|.
name|getRunas
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"')"
argument_list|)
expr_stmt|;
name|s
operator|=
name|buf
operator|.
name|toString
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e1
parameter_list|)
block|{         }
name|detectDeadlock
argument_list|(
name|e
argument_list|,
literal|"compact"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DeadlockException
name|e
parameter_list|)
block|{
name|compact
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|deadlockCnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
specifier|public
name|ShowCompactResponse
name|showCompact
parameter_list|(
name|ShowCompactRequest
name|rqst
parameter_list|)
throws|throws
name|MetaException
block|{
name|ShowCompactResponse
name|response
init|=
operator|new
name|ShowCompactResponse
argument_list|()
decl_stmt|;
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|()
decl_stmt|;
try|try
block|{
name|Statement
name|stmt
init|=
name|dbConn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|String
name|s
init|=
literal|"select cq_database, cq_table, cq_partition, cq_state, cq_type, cq_worker_id, "
operator|+
literal|"cq_start, cq_run_as from COMPACTION_QUEUE"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|ShowCompactResponseElement
name|e
init|=
operator|new
name|ShowCompactResponseElement
argument_list|()
decl_stmt|;
name|e
operator|.
name|setDbname
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setTablename
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setPartitionname
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|INITIATED_STATE
case|:
name|e
operator|.
name|setState
argument_list|(
name|INITIATED_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|WORKING_STATE
case|:
name|e
operator|.
name|setState
argument_list|(
name|WORKING_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|READY_FOR_CLEANING
case|:
name|e
operator|.
name|setState
argument_list|(
name|CLEANING_RESPONSE
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unexpected compaction state "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|MAJOR_TYPE
case|:
name|e
operator|.
name|setType
argument_list|(
name|CompactionType
operator|.
name|MAJOR
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINOR_TYPE
case|:
name|e
operator|.
name|setType
argument_list|(
name|CompactionType
operator|.
name|MINOR
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unexpected compaction type "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
argument_list|)
throw|;
block|}
name|e
operator|.
name|setWorkerid
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setStart
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setRunAs
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|response
operator|.
name|addToCompacts
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
try|try
block|{
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e1
parameter_list|)
block|{       }
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
return|return
name|response
return|;
block|}
comment|/**    * For testing only, do not use.    */
name|int
name|numLocksInLockTable
parameter_list|()
throws|throws
name|SQLException
throws|,
name|MetaException
block|{
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|()
decl_stmt|;
try|try
block|{
name|Statement
name|stmt
init|=
name|dbConn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|String
name|s
init|=
literal|"select count(*) from HIVE_LOCKS"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|rs
operator|.
name|next
argument_list|()
expr_stmt|;
name|int
name|rc
init|=
name|rs
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// Necessary to clean up the transaction in the db.
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
name|rc
return|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * For testing only, do not use.    */
name|long
name|setTimeout
parameter_list|(
name|long
name|milliseconds
parameter_list|)
block|{
name|long
name|previous_timeout
init|=
name|timeout
decl_stmt|;
name|timeout
operator|=
name|milliseconds
expr_stmt|;
return|return
name|previous_timeout
return|;
block|}
specifier|protected
class|class
name|DeadlockException
extends|extends
name|Exception
block|{    }
specifier|protected
name|Connection
name|getDbConn
parameter_list|()
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
name|connPool
operator|.
name|getConnection
argument_list|()
decl_stmt|;
name|dbConn
operator|.
name|setAutoCommit
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|setTransactionIsolation
argument_list|(
name|Connection
operator|.
name|TRANSACTION_REPEATABLE_READ
argument_list|)
expr_stmt|;
return|return
name|dbConn
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"Unable to get jdbc connection from pool, "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|void
name|closeDbConn
parameter_list|(
name|Connection
name|dbConn
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|dbConn
operator|!=
literal|null
condition|)
name|dbConn
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to close db connection "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Determine if an exception was a deadlock.  Unfortunately there is no standard way to do    * this, so we have to inspect the error messages and catch the telltale signs for each    * different database.    * @param e exception that was thrown.    * @param caller name of the method calling this    * @throws org.apache.hadoop.hive.metastore.txn.TxnHandler.DeadlockException when deadlock    * detected and retry count has not been exceeded.    */
specifier|protected
name|void
name|detectDeadlock
parameter_list|(
name|SQLException
name|e
parameter_list|,
name|String
name|caller
parameter_list|)
throws|throws
name|DeadlockException
block|{
specifier|final
name|String
name|mysqlDeadlock
init|=
literal|"Deadlock found when trying to get lock; try restarting transaction"
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
name|mysqlDeadlock
argument_list|)
operator|||
name|e
operator|instanceof
name|SQLTransactionRollbackException
condition|)
block|{
if|if
condition|(
name|deadlockCnt
operator|++
operator|<
name|ALLOWED_REPEATED_DEADLOCKS
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Deadlock detected in "
operator|+
name|caller
operator|+
literal|", trying again."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DeadlockException
argument_list|()
throw|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Too many repeated deadlocks in "
operator|+
name|caller
operator|+
literal|", giving up."
argument_list|)
expr_stmt|;
name|deadlockCnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
class|class
name|LockInfo
block|{
name|long
name|extLockId
decl_stmt|;
name|long
name|intLockId
decl_stmt|;
name|long
name|txnId
decl_stmt|;
name|String
name|db
decl_stmt|;
name|String
name|table
decl_stmt|;
name|String
name|partition
decl_stmt|;
name|LockState
name|state
decl_stmt|;
name|LockType
name|type
decl_stmt|;
comment|// Assumes the result set is set to a valid row
name|LockInfo
parameter_list|(
name|ResultSet
name|rs
parameter_list|)
throws|throws
name|SQLException
block|{
name|extLockId
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|"hl_lock_ext_id"
argument_list|)
expr_stmt|;
comment|// can't be null
name|intLockId
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|"hl_lock_int_id"
argument_list|)
expr_stmt|;
comment|// can't be null
name|db
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_db"
argument_list|)
expr_stmt|;
comment|// can't be null
name|String
name|t
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_table"
argument_list|)
decl_stmt|;
name|table
operator|=
operator|(
name|rs
operator|.
name|wasNull
argument_list|()
condition|?
literal|null
else|:
name|t
operator|)
expr_stmt|;
name|String
name|p
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_partition"
argument_list|)
decl_stmt|;
name|partition
operator|=
operator|(
name|rs
operator|.
name|wasNull
argument_list|()
condition|?
literal|null
else|:
name|p
operator|)
expr_stmt|;
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_lock_state"
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|LOCK_WAITING
case|:
name|state
operator|=
name|LockState
operator|.
name|WAITING
expr_stmt|;
break|break;
case|case
name|LOCK_ACQUIRED
case|:
name|state
operator|=
name|LockState
operator|.
name|ACQUIRED
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_lock_type"
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|LOCK_EXCLUSIVE
case|:
name|type
operator|=
name|LockType
operator|.
name|EXCLUSIVE
expr_stmt|;
break|break;
case|case
name|LOCK_SHARED
case|:
name|type
operator|=
name|LockType
operator|.
name|SHARED_READ
expr_stmt|;
break|break;
case|case
name|LOCK_SEMI_SHARED
case|:
name|type
operator|=
name|LockType
operator|.
name|SHARED_WRITE
expr_stmt|;
break|break;
block|}
block|}
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|other
operator|instanceof
name|LockInfo
operator|)
condition|)
return|return
literal|false
return|;
name|LockInfo
name|o
init|=
operator|(
name|LockInfo
operator|)
name|other
decl_stmt|;
comment|// Lock ids are unique across the system.
return|return
name|extLockId
operator|==
name|o
operator|.
name|extLockId
operator|&&
name|intLockId
operator|==
name|o
operator|.
name|intLockId
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"extLockId:"
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|extLockId
argument_list|)
operator|+
literal|" intLockId:"
operator|+
name|intLockId
operator|+
literal|" txnId:"
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|txnId
argument_list|)
operator|+
literal|" db:"
operator|+
name|db
operator|+
literal|" table:"
operator|+
name|table
operator|+
literal|" partition:"
operator|+
name|partition
operator|+
literal|" state:"
operator|+
operator|(
name|state
operator|==
literal|null
condition|?
literal|"null"
else|:
name|state
operator|.
name|toString
argument_list|()
operator|)
operator|+
literal|" type:"
operator|+
operator|(
name|type
operator|==
literal|null
condition|?
literal|"null"
else|:
name|type
operator|.
name|toString
argument_list|()
operator|)
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|LockInfoComparator
implements|implements
name|Comparator
argument_list|<
name|LockInfo
argument_list|>
block|{
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
return|return
name|this
operator|==
name|other
return|;
block|}
specifier|public
name|int
name|compare
parameter_list|(
name|LockInfo
name|info1
parameter_list|,
name|LockInfo
name|info2
parameter_list|)
block|{
comment|// We sort by state (acquired vs waiting) and then by extLockId.
if|if
condition|(
name|info1
operator|.
name|state
operator|==
name|LockState
operator|.
name|ACQUIRED
operator|&&
name|info2
operator|.
name|state
operator|!=
name|LockState
operator|.
name|ACQUIRED
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|info1
operator|.
name|state
operator|!=
name|LockState
operator|.
name|ACQUIRED
operator|&&
name|info2
operator|.
name|state
operator|==
name|LockState
operator|.
name|ACQUIRED
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|info1
operator|.
name|extLockId
operator|<
name|info2
operator|.
name|extLockId
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|info1
operator|.
name|extLockId
operator|>
name|info2
operator|.
name|extLockId
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|info1
operator|.
name|intLockId
operator|<
name|info2
operator|.
name|intLockId
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|info1
operator|.
name|intLockId
operator|>
name|info2
operator|.
name|intLockId
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
specifier|private
enum|enum
name|LockAction
block|{
name|ACQUIRE
block|,
name|WAIT
block|,
name|KEEP_LOOKING
block|}
empty_stmt|;
comment|// A jump table to figure out whether to wait, acquire,
comment|// or keep looking .  Since
comment|// java doesn't have function pointers (grumble grumble) we store a
comment|// character that we'll use to determine which function to call.
comment|// The table maps the lock type of the lock we are looking to acquire to
comment|// the lock type of the lock we are checking to the lock state of the lock
comment|// we are checking to the desired action.
specifier|private
specifier|static
name|Map
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
argument_list|>
name|jumpTable
decl_stmt|;
specifier|private
name|void
name|checkQFileTestHack
parameter_list|()
block|{
name|boolean
name|hackOn
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_IN_TEST
argument_list|)
decl_stmt|;
if|if
condition|(
name|hackOn
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Hacking in canned values for transaction manager"
argument_list|)
expr_stmt|;
comment|// Set up the transaction/locking db in the derby metastore
name|TxnDbUtil
operator|.
name|setConfValues
argument_list|(
name|conf
argument_list|)
expr_stmt|;
try|try
block|{
name|TxnDbUtil
operator|.
name|prepDb
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// We may have already created the tables and thus don't need to redo it.
if|if
condition|(
operator|!
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"already exists"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unable to set up transaction database for"
operator|+
literal|" testing: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**    * Request a lock    * @param dbConn database connection    * @param rqst lock information    * @param wait whether to wait for this lock.  The function will return immediately one way or    *             another.  If true and the lock could not be acquired the response will have a    *             state of  WAITING.  The caller will then need to poll using    *             {@link #checkLock(org.apache.hadoop.hive.metastore.api.CheckLockRequest)}. If    *             false and the  lock could not be acquired, then the response will have a state    *             of NOT_ACQUIRED.  The caller will need to call    *             {@link #lockNoWait(org.apache.hadoop.hive.metastore.api.LockRequest)} again to    *             attempt another lock.    * @return informatino on whether the lock was acquired.    * @throws NoSuchTxnException    * @throws TxnAbortedException    */
specifier|private
name|LockResponse
name|lock
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|LockRequest
name|rqst
parameter_list|,
name|boolean
name|wait
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
throws|,
name|SQLException
block|{
comment|// We want to minimize the number of concurrent lock requests being issued.  If we do not we
comment|// get a large number of deadlocks in the database, since this method has to both clean
comment|// timedout locks and insert new locks.  This synchronization barrier will not eliminiate all
comment|// deadlocks, and the code is still resilient in the face of a database deadlock.  But it
comment|// will reduce the number.  This could have been done via a lock table command in the
comment|// underlying database, but was not for two reasons.  One, different databases have different
comment|// syntax for lock table, making it harder to use.  Two, that would lock the HIVE_LOCKS table
comment|// and prevent other operations (such as committing transactions, showing locks,
comment|// etc.) that should not interfere with this one.
synchronized|synchronized
init|(
name|lockLock
init|)
block|{
comment|// Clean up timed out locks before we attempt to acquire any.
name|timeOutLocks
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
try|try
block|{
name|Statement
name|stmt
init|=
name|dbConn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
comment|// Get the next lock id.  We have to do this as select for update so no
comment|// one else reads it and updates it under us.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<select nl_next from NEXT_LOCK_ID "
operator|+
literal|"for update>"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
literal|"select nl_next from NEXT_LOCK_ID "
operator|+
literal|"for update"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly "
operator|+
literal|"initialized, no record found in next_lock_id"
argument_list|)
throw|;
block|}
name|long
name|extLockId
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|String
name|s
init|=
literal|"update NEXT_LOCK_ID set nl_next = "
operator|+
operator|(
name|extLockId
operator|+
literal|1
operator|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit."
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
name|long
name|txnid
init|=
name|rqst
operator|.
name|getTxnid
argument_list|()
decl_stmt|;
if|if
condition|(
name|txnid
operator|>
literal|0
condition|)
block|{
comment|// Heartbeat the transaction so we know it is valid and we avoid it timing out while we
comment|// are locking.
name|heartbeatTxn
argument_list|(
name|dbConn
argument_list|,
name|txnid
argument_list|)
expr_stmt|;
comment|// For each component in this lock request,
comment|// add an entry to the txn_components table
comment|// This must be done before HIVE_LOCKS is accessed
for|for
control|(
name|LockComponent
name|lc
range|:
name|rqst
operator|.
name|getComponent
argument_list|()
control|)
block|{
name|String
name|dbName
init|=
name|lc
operator|.
name|getDbname
argument_list|()
decl_stmt|;
name|String
name|tblName
init|=
name|lc
operator|.
name|getTablename
argument_list|()
decl_stmt|;
name|String
name|partName
init|=
name|lc
operator|.
name|getPartitionname
argument_list|()
decl_stmt|;
name|s
operator|=
literal|"insert into TXN_COMPONENTS "
operator|+
literal|"(tc_txnid, tc_database, tc_table, tc_partition) "
operator|+
literal|"values ("
operator|+
name|txnid
operator|+
literal|", '"
operator|+
name|dbName
operator|+
literal|"', "
operator|+
operator|(
name|tblName
operator|==
literal|null
condition|?
literal|"null"
else|:
literal|"'"
operator|+
name|tblName
operator|+
literal|"'"
operator|)
operator|+
literal|", "
operator|+
operator|(
name|partName
operator|==
literal|null
condition|?
literal|"null"
else|:
literal|"'"
operator|+
name|partName
operator|+
literal|"'"
operator|)
operator|+
literal|")"
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|intLockId
init|=
literal|0
decl_stmt|;
for|for
control|(
name|LockComponent
name|lc
range|:
name|rqst
operator|.
name|getComponent
argument_list|()
control|)
block|{
name|intLockId
operator|++
expr_stmt|;
name|String
name|dbName
init|=
name|lc
operator|.
name|getDbname
argument_list|()
decl_stmt|;
name|String
name|tblName
init|=
name|lc
operator|.
name|getTablename
argument_list|()
decl_stmt|;
name|String
name|partName
init|=
name|lc
operator|.
name|getPartitionname
argument_list|()
decl_stmt|;
name|LockType
name|lockType
init|=
name|lc
operator|.
name|getType
argument_list|()
decl_stmt|;
name|char
name|lockChar
init|=
literal|'z'
decl_stmt|;
switch|switch
condition|(
name|lockType
condition|)
block|{
case|case
name|EXCLUSIVE
case|:
name|lockChar
operator|=
name|LOCK_EXCLUSIVE
expr_stmt|;
break|break;
case|case
name|SHARED_READ
case|:
name|lockChar
operator|=
name|LOCK_SHARED
expr_stmt|;
break|break;
case|case
name|SHARED_WRITE
case|:
name|lockChar
operator|=
name|LOCK_SEMI_SHARED
expr_stmt|;
break|break;
block|}
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|s
operator|=
literal|"insert into HIVE_LOCKS "
operator|+
literal|" (hl_lock_ext_id, hl_lock_int_id, hl_txnid, hl_db, hl_table, "
operator|+
literal|"hl_partition, hl_lock_state, hl_lock_type, hl_last_heartbeat, hl_user, hl_host)"
operator|+
literal|" values ("
operator|+
name|extLockId
operator|+
literal|", "
operator|+
operator|+
name|intLockId
operator|+
literal|","
operator|+
operator|(
name|txnid
operator|>=
literal|0
condition|?
name|txnid
else|:
literal|"null"
operator|)
operator|+
literal|", '"
operator|+
name|dbName
operator|+
literal|"', "
operator|+
operator|(
name|tblName
operator|==
literal|null
condition|?
literal|"null"
else|:
literal|"'"
operator|+
name|tblName
operator|+
literal|"'"
operator|)
operator|+
literal|", "
operator|+
operator|(
name|partName
operator|==
literal|null
condition|?
literal|"null"
else|:
literal|"'"
operator|+
name|partName
operator|+
literal|"'"
operator|)
operator|+
literal|", '"
operator|+
name|LOCK_WAITING
operator|+
literal|"', "
operator|+
literal|"'"
operator|+
name|lockChar
operator|+
literal|"', "
operator|+
name|now
operator|+
literal|", '"
operator|+
name|rqst
operator|.
name|getUser
argument_list|()
operator|+
literal|"', '"
operator|+
name|rqst
operator|.
name|getHostname
argument_list|()
operator|+
literal|"')"
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|LockResponse
name|rsp
init|=
name|checkLock
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|,
name|txnid
argument_list|,
name|wait
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|wait
operator|&&
name|rsp
operator|.
name|getState
argument_list|()
operator|!=
name|LockState
operator|.
name|ACQUIRED
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Lock not acquired, going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
name|rsp
operator|=
operator|new
name|LockResponse
argument_list|()
expr_stmt|;
name|rsp
operator|.
name|setState
argument_list|(
name|LockState
operator|.
name|NOT_ACQUIRED
argument_list|)
expr_stmt|;
block|}
return|return
name|rsp
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchLockException
name|e
parameter_list|)
block|{
comment|// This should never happen, as we just added the lock id
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Couldn't find a lock we just created!"
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|LockResponse
name|checkLock
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|extLockId
parameter_list|,
name|long
name|txnid
parameter_list|,
name|boolean
name|alwaysCommit
parameter_list|)
throws|throws
name|NoSuchLockException
throws|,
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
throws|,
name|SQLException
block|{
name|List
argument_list|<
name|LockInfo
argument_list|>
name|locksBeingChecked
init|=
name|getLockInfoFromLockId
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
decl_stmt|;
name|LockResponse
name|response
init|=
operator|new
name|LockResponse
argument_list|()
decl_stmt|;
name|response
operator|.
name|setLockid
argument_list|(
name|extLockId
argument_list|)
expr_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Setting savepoint"
argument_list|)
expr_stmt|;
name|Savepoint
name|save
init|=
name|dbConn
operator|.
name|setSavepoint
argument_list|()
decl_stmt|;
name|Statement
name|stmt
init|=
name|dbConn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|StringBuilder
name|query
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"select hl_lock_ext_id, "
operator|+
literal|"hl_lock_int_id, hl_db, hl_table, hl_partition, hl_lock_state, "
operator|+
literal|"hl_lock_type from HIVE_LOCKS where hl_db in ("
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|strings
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|locksBeingChecked
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|LockInfo
name|info
range|:
name|locksBeingChecked
control|)
block|{
name|strings
operator|.
name|add
argument_list|(
name|info
operator|.
name|db
argument_list|)
expr_stmt|;
block|}
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|strings
control|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|false
expr_stmt|;
else|else
name|query
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
name|query
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
comment|// If any of the table requests are null, then I need to pull all the
comment|// table locks for this db.
name|boolean
name|sawNull
init|=
literal|false
decl_stmt|;
name|strings
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|LockInfo
name|info
range|:
name|locksBeingChecked
control|)
block|{
if|if
condition|(
name|info
operator|.
name|table
operator|==
literal|null
condition|)
block|{
name|sawNull
operator|=
literal|true
expr_stmt|;
break|break;
block|}
else|else
block|{
name|strings
operator|.
name|add
argument_list|(
name|info
operator|.
name|table
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|sawNull
condition|)
block|{
name|query
operator|.
name|append
argument_list|(
literal|" and (hl_table is null or hl_table in("
argument_list|)
expr_stmt|;
name|first
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|strings
control|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|false
expr_stmt|;
else|else
name|query
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
name|query
operator|.
name|append
argument_list|(
literal|"))"
argument_list|)
expr_stmt|;
comment|// If any of the partition requests are null, then I need to pull all
comment|// partition locks for this table.
name|sawNull
operator|=
literal|false
expr_stmt|;
name|strings
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|LockInfo
name|info
range|:
name|locksBeingChecked
control|)
block|{
if|if
condition|(
name|info
operator|.
name|partition
operator|==
literal|null
condition|)
block|{
name|sawNull
operator|=
literal|true
expr_stmt|;
break|break;
block|}
else|else
block|{
name|strings
operator|.
name|add
argument_list|(
name|info
operator|.
name|partition
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|sawNull
condition|)
block|{
name|query
operator|.
name|append
argument_list|(
literal|" and (hl_partition is null or hl_partition in("
argument_list|)
expr_stmt|;
name|first
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|strings
control|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|false
expr_stmt|;
else|else
name|query
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
name|query
operator|.
name|append
argument_list|(
literal|"))"
argument_list|)
expr_stmt|;
block|}
block|}
name|query
operator|.
name|append
argument_list|(
literal|" for update"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|query
operator|.
name|toString
argument_list|()
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|query
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|SortedSet
name|lockSet
init|=
operator|new
name|TreeSet
argument_list|(
operator|new
name|LockInfoComparator
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|lockSet
operator|.
name|add
argument_list|(
operator|new
name|LockInfo
argument_list|(
name|rs
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Turn the tree set into an array so we can move back and forth easily
comment|// in it.
name|LockInfo
index|[]
name|locks
init|=
operator|(
name|LockInfo
index|[]
operator|)
name|lockSet
operator|.
name|toArray
argument_list|(
operator|new
name|LockInfo
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|LockInfo
name|info
range|:
name|locksBeingChecked
control|)
block|{
comment|// Find the lock record we're checking
name|int
name|index
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|locks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|locks
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|index
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|// If we didn't find the lock, then it must not be in the table
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"How did we get here, we heartbeated our lock before we started!"
argument_list|)
throw|;
block|}
comment|// If we've found it and it's already been marked acquired,
comment|// then just look at the other locks.
if|if
condition|(
name|locks
index|[
name|index
index|]
operator|.
name|state
operator|==
name|LockState
operator|.
name|ACQUIRED
condition|)
block|{
continue|continue;
block|}
comment|// Look at everything in front of this lock to see if it should block
comment|// it or not.
for|for
control|(
name|int
name|i
init|=
name|index
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|// Check if we're operating on the same database, if not, move on
if|if
condition|(
operator|!
name|locks
index|[
name|index
index|]
operator|.
name|db
operator|.
name|equals
argument_list|(
name|locks
index|[
name|i
index|]
operator|.
name|db
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// If table is null on either of these, then they are claiming to
comment|// lock the whole database and we need to check it.  Otherwise,
comment|// check if they are operating on the same table, if not, move on.
if|if
condition|(
name|locks
index|[
name|index
index|]
operator|.
name|table
operator|!=
literal|null
operator|&&
name|locks
index|[
name|i
index|]
operator|.
name|table
operator|!=
literal|null
operator|&&
operator|!
name|locks
index|[
name|index
index|]
operator|.
name|table
operator|.
name|equals
argument_list|(
name|locks
index|[
name|i
index|]
operator|.
name|table
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// If partition is null on either of these, then they are claiming to
comment|// lock the whole table and we need to check it.  Otherwise,
comment|// check if they are operating on the same partition, if not, move on.
if|if
condition|(
name|locks
index|[
name|index
index|]
operator|.
name|partition
operator|!=
literal|null
operator|&&
name|locks
index|[
name|i
index|]
operator|.
name|partition
operator|!=
literal|null
operator|&&
operator|!
name|locks
index|[
name|index
index|]
operator|.
name|partition
operator|.
name|equals
argument_list|(
name|locks
index|[
name|i
index|]
operator|.
name|partition
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// We've found something that matches what we're trying to lock,
comment|// so figure out if we can lock it too.
switch|switch
condition|(
name|jumpTable
operator|.
name|get
argument_list|(
name|locks
index|[
name|index
index|]
operator|.
name|type
argument_list|)
operator|.
name|get
argument_list|(
name|locks
index|[
name|i
index|]
operator|.
name|type
argument_list|)
operator|.
name|get
argument_list|(
name|locks
index|[
name|i
index|]
operator|.
name|state
argument_list|)
condition|)
block|{
case|case
name|ACQUIRE
case|:
name|acquire
argument_list|(
name|dbConn
argument_list|,
name|stmt
argument_list|,
name|extLockId
argument_list|,
name|info
operator|.
name|intLockId
argument_list|)
expr_stmt|;
break|break;
case|case
name|WAIT
case|:
name|wait
argument_list|(
name|dbConn
argument_list|,
name|save
argument_list|)
expr_stmt|;
if|if
condition|(
name|alwaysCommit
condition|)
block|{
comment|// In the case where lockNoWait has been called we don't want to commit because
comment|// it's going to roll everything back.  In every other case we want to commit here.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
name|response
operator|.
name|setState
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|)
expr_stmt|;
return|return
name|response
return|;
case|case
name|KEEP_LOOKING
case|:
continue|continue;
block|}
block|}
comment|// If we've arrived here it means there's nothing in the way of the
comment|// lock, so acquire the lock.
name|acquire
argument_list|(
name|dbConn
argument_list|,
name|stmt
argument_list|,
name|extLockId
argument_list|,
name|info
operator|.
name|intLockId
argument_list|)
expr_stmt|;
block|}
comment|// We acquired all of the locks, so commit and return acquired.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
name|response
operator|.
name|setState
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|)
expr_stmt|;
return|return
name|response
return|;
block|}
specifier|private
name|void
name|wait
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|Savepoint
name|save
parameter_list|)
throws|throws
name|SQLException
block|{
comment|// Need to rollback because we did a select for update but we didn't
comment|// actually update anything.  Also, we may have locked some locks as
comment|// acquired that we now want to not acquire.  It's ok to rollback because
comment|// once we see one wait, we're done, we won't look for more.
comment|// Only rollback to savepoint because we want to commit our heartbeat
comment|// changes.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback to savepoint"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|(
name|save
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|acquire
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|Statement
name|stmt
parameter_list|,
name|long
name|extLockId
parameter_list|,
name|long
name|intLockId
parameter_list|)
throws|throws
name|SQLException
throws|,
name|NoSuchLockException
block|{
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|String
name|s
init|=
literal|"update HIVE_LOCKS set hl_lock_state = '"
operator|+
name|LOCK_ACQUIRED
operator|+
literal|"', "
operator|+
literal|"hl_last_heartbeat = "
operator|+
name|now
operator|+
literal|", hl_acquired_at = "
operator|+
name|now
operator|+
literal|" where hl_lock_ext_id = "
operator|+
name|extLockId
operator|+
literal|" and hl_lock_int_id = "
operator|+
name|intLockId
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|NoSuchLockException
argument_list|(
literal|"No such lock: ("
operator|+
name|extLockId
operator|+
literal|","
operator|+
operator|+
name|intLockId
operator|+
literal|")"
argument_list|)
throw|;
block|}
comment|// We update the database, but we don't commit because there may be other
comment|// locks together with this, and we only want to acquire one if we can
comment|// acquire all.
block|}
comment|// Heartbeats on the lock table.  This commits, so do not enter it with any state
specifier|private
name|void
name|heartbeatLock
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|extLockId
parameter_list|)
throws|throws
name|NoSuchLockException
throws|,
name|SQLException
block|{
comment|// If the lock id is 0, then there are no locks in this heartbeat
if|if
condition|(
name|extLockId
operator|==
literal|0
condition|)
return|return;
name|Statement
name|stmt
init|=
name|dbConn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|String
name|s
init|=
literal|"update HIVE_LOCKS set hl_last_heartbeat = "
operator|+
name|now
operator|+
literal|" where hl_lock_ext_id = "
operator|+
name|extLockId
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|NoSuchLockException
argument_list|(
literal|"No such lock: "
operator|+
name|extLockId
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
comment|// Heartbeats on the txn table.  This commits, so do not enter it with any state
specifier|private
name|void
name|heartbeatTxn
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|txnid
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|SQLException
block|{
comment|// If the txnid is 0, then there are no transactions in this heartbeat
if|if
condition|(
name|txnid
operator|==
literal|0
condition|)
return|return;
name|Statement
name|stmt
init|=
name|dbConn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// We need to check whether this transaction is valid and open
name|String
name|s
init|=
literal|"select txn_state from TXNS where txn_id = "
operator|+
name|txnid
operator|+
literal|" for update"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|NoSuchTxnException
argument_list|(
literal|"No such transaction: "
operator|+
name|txnid
argument_list|)
throw|;
block|}
if|if
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|TXN_ABORTED
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|TxnAbortedException
argument_list|(
literal|"Transaction "
operator|+
name|txnid
operator|+
literal|" already aborted"
argument_list|)
throw|;
block|}
name|s
operator|=
literal|"update TXNS set txn_last_heartbeat = "
operator|+
name|now
operator|+
literal|" where txn_id = "
operator|+
name|txnid
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
comment|// NEVER call this function without first calling heartbeat(long, long)
specifier|private
name|long
name|getTxnIdFromLockId
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|extLockId
parameter_list|)
throws|throws
name|NoSuchLockException
throws|,
name|MetaException
throws|,
name|SQLException
block|{
name|Statement
name|stmt
init|=
name|dbConn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|String
name|s
init|=
literal|"select hl_txnid from HIVE_LOCKS where hl_lock_ext_id = "
operator|+
name|extLockId
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"This should never happen!  We already "
operator|+
literal|"checked the lock existed but now we can't find it!"
argument_list|)
throw|;
block|}
name|long
name|txnid
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Return txnid "
operator|+
operator|(
name|rs
operator|.
name|wasNull
argument_list|()
condition|?
operator|-
literal|1
else|:
name|txnid
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rs
operator|.
name|wasNull
argument_list|()
condition|?
operator|-
literal|1
else|:
name|txnid
operator|)
return|;
block|}
comment|// NEVER call this function without first calling heartbeat(long, long)
specifier|private
name|List
argument_list|<
name|LockInfo
argument_list|>
name|getLockInfoFromLockId
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|extLockId
parameter_list|)
throws|throws
name|NoSuchLockException
throws|,
name|MetaException
throws|,
name|SQLException
block|{
name|Statement
name|stmt
init|=
name|dbConn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|String
name|s
init|=
literal|"select hl_lock_ext_id, hl_lock_int_id, hl_db, hl_table, "
operator|+
literal|"hl_partition, hl_lock_state, hl_lock_type from HIVE_LOCKS where "
operator|+
literal|"hl_lock_ext_id = "
operator|+
name|extLockId
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|boolean
name|sawAtLeastOne
init|=
literal|false
decl_stmt|;
name|List
argument_list|<
name|LockInfo
argument_list|>
name|ourLockInfo
init|=
operator|new
name|ArrayList
argument_list|<
name|LockInfo
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|ourLockInfo
operator|.
name|add
argument_list|(
operator|new
name|LockInfo
argument_list|(
name|rs
argument_list|)
argument_list|)
expr_stmt|;
name|sawAtLeastOne
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sawAtLeastOne
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"This should never happen!  We already "
operator|+
literal|"checked the lock existed but now we can't find it!"
argument_list|)
throw|;
block|}
return|return
name|ourLockInfo
return|;
block|}
comment|// Clean time out locks from the database.  This does a commit,
comment|// and thus should be done before any calls to heartbeat that will leave
comment|// open transactions.
specifier|private
name|void
name|timeOutLocks
parameter_list|(
name|Connection
name|dbConn
parameter_list|)
throws|throws
name|SQLException
block|{
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|Statement
name|stmt
init|=
name|dbConn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
comment|// Remove any timed out locks from the table.
name|String
name|s
init|=
literal|"delete from HIVE_LOCKS where hl_last_heartbeat< "
operator|+
operator|(
name|now
operator|-
name|timeout
operator|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return;
block|}
specifier|private
specifier|static
specifier|synchronized
name|void
name|setupJdbcConnectionPool
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|SQLException
block|{
if|if
condition|(
name|connPool
operator|!=
literal|null
condition|)
return|return;
name|String
name|driverUrl
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTORECONNECTURLKEY
argument_list|)
decl_stmt|;
name|String
name|user
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTORE_CONNECTION_USER_NAME
argument_list|)
decl_stmt|;
name|String
name|passwd
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTOREPWD
argument_list|)
decl_stmt|;
name|BoneCPConfig
name|config
init|=
operator|new
name|BoneCPConfig
argument_list|()
decl_stmt|;
name|config
operator|.
name|setJdbcUrl
argument_list|(
name|driverUrl
argument_list|)
expr_stmt|;
name|config
operator|.
name|setMaxConnectionsPerPartition
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|config
operator|.
name|setPartitionCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|config
operator|.
name|setUser
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|config
operator|.
name|setPassword
argument_list|(
name|passwd
argument_list|)
expr_stmt|;
name|connPool
operator|=
operator|new
name|BoneCP
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
specifier|synchronized
name|void
name|buildJumpTable
parameter_list|()
block|{
if|if
condition|(
name|jumpTable
operator|!=
literal|null
condition|)
return|return;
name|jumpTable
operator|=
operator|new
name|HashMap
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
argument_list|>
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|// SR: Lock we are trying to acquire is shared read
name|Map
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
name|m
init|=
operator|new
name|HashMap
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|jumpTable
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_READ
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|// SR.SR: Lock we are examining is shared read
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
name|m2
init|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_READ
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// SR.SR.acquired Lock we are examining is acquired;  We can acquire
comment|// because two shared reads can acquire together and there must be
comment|// nothing in front of this one to prevent acquisition.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|ACQUIRE
argument_list|)
expr_stmt|;
comment|// SR.SR.wait Lock we are examining is waiting.  In this case we keep
comment|// looking, as it's possible that something in front is blocking it or
comment|// that the other locker hasn't checked yet and he could lock as well.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|KEEP_LOOKING
argument_list|)
expr_stmt|;
comment|// SR.SW: Lock we are examining is shared write
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_WRITE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// SR.SW.acquired Lock we are examining is acquired;  We can acquire
comment|// because a read can share with a write, and there must be
comment|// nothing in front of this one to prevent acquisition.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|ACQUIRE
argument_list|)
expr_stmt|;
comment|// SR.SW.wait Lock we are examining is waiting.  In this case we keep
comment|// looking, as it's possible that something in front is blocking it or
comment|// that the other locker hasn't checked yet and he could lock as well or
comment|// that something is blocking it that would not block a read.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|KEEP_LOOKING
argument_list|)
expr_stmt|;
comment|// SR.E: Lock we are examining is exclusive
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|EXCLUSIVE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// No matter whether it has acquired or not, we cannot pass an exclusive.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
comment|// SW: Lock we are trying to acquire is shared write
name|m
operator|=
operator|new
name|HashMap
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|jumpTable
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_WRITE
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|// SW.SR: Lock we are examining is shared read
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_READ
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// SW.SR.acquired Lock we are examining is acquired;  We need to keep
comment|// looking, because there may or may not be another shared write in front
comment|// that would block us.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|KEEP_LOOKING
argument_list|)
expr_stmt|;
comment|// SW.SR.wait Lock we are examining is waiting.  In this case we keep
comment|// looking, as it's possible that something in front is blocking it or
comment|// that the other locker hasn't checked yet and he could lock as well.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|KEEP_LOOKING
argument_list|)
expr_stmt|;
comment|// SW.SW: Lock we are examining is shared write
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_WRITE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// Regardless of acquired or waiting, one shared write cannot pass another.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
comment|// SW.E: Lock we are examining is exclusive
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|EXCLUSIVE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// No matter whether it has acquired or not, we cannot pass an exclusive.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
comment|// E: Lock we are trying to acquire is exclusive
name|m
operator|=
operator|new
name|HashMap
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|jumpTable
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|EXCLUSIVE
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|// E.SR: Lock we are examining is shared read
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_READ
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// Exclusives can never pass
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
comment|// E.SW: Lock we are examining is shared write
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_WRITE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// Exclusives can never pass
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
comment|// E.E: Lock we are examining is exclusive
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|EXCLUSIVE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// No matter whether it has acquired or not, we cannot pass an exclusive.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

