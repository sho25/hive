begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|txn
package|;
end_package

begin_import
import|import
name|com
operator|.
name|jolbox
operator|.
name|bonecp
operator|.
name|BoneCPConfig
import|;
end_import

begin_import
import|import
name|com
operator|.
name|jolbox
operator|.
name|bonecp
operator|.
name|BoneCPDataSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|dbcp
operator|.
name|ConnectionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|dbcp
operator|.
name|DriverManagerConnectionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|dbcp
operator|.
name|PoolableConnectionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tools
operator|.
name|ant
operator|.
name|taskdefs
operator|.
name|Java
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|dbcp
operator|.
name|PoolingDataSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|pool
operator|.
name|ObjectPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|pool
operator|.
name|impl
operator|.
name|GenericObjectPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|JavaUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ValidTxnList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ValidReadTxnList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|shims
operator|.
name|ShimLoader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|sql
operator|.
name|DataSource
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_comment
comment|/**  * A handler to answer transaction related calls that come into the metastore  * server.  *  * Note on log messages:  Please include txnid:X and lockid info using  * {@link org.apache.hadoop.hive.common.JavaUtils#txnIdToString(long)}  * and {@link org.apache.hadoop.hive.common.JavaUtils#lockIdToString(long)} in all messages.  * The txnid:X and lockid:Y matches how Thrift object toString() methods are generated,  * so keeping the format consistent makes grep'ing the logs much easier.  *  * Note on HIVE_LOCKS.hl_last_heartbeat.  * For locks that are part of transaction, we set this 0 (would rather set it to NULL but  * Currently the DB schema has this NOT NULL) and only update/read heartbeat from corresponding  * transaction in TXNS.  */
end_comment

begin_class
specifier|public
class|class
name|TxnHandler
block|{
comment|// Compactor states
specifier|static
specifier|final
specifier|public
name|String
name|INITIATED_RESPONSE
init|=
literal|"initiated"
decl_stmt|;
specifier|static
specifier|final
specifier|public
name|String
name|WORKING_RESPONSE
init|=
literal|"working"
decl_stmt|;
specifier|static
specifier|final
specifier|public
name|String
name|CLEANING_RESPONSE
init|=
literal|"ready for cleaning"
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|INITIATED_STATE
init|=
literal|'i'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|WORKING_STATE
init|=
literal|'w'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|READY_FOR_CLEANING
init|=
literal|'r'
decl_stmt|;
comment|// Compactor types
specifier|static
specifier|final
specifier|protected
name|char
name|MAJOR_TYPE
init|=
literal|'a'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|MINOR_TYPE
init|=
literal|'i'
decl_stmt|;
comment|// Transaction states
specifier|static
specifier|final
specifier|protected
name|char
name|TXN_ABORTED
init|=
literal|'a'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|TXN_OPEN
init|=
literal|'o'
decl_stmt|;
comment|// Lock states
specifier|static
specifier|final
specifier|protected
name|char
name|LOCK_ACQUIRED
init|=
literal|'a'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|LOCK_WAITING
init|=
literal|'w'
decl_stmt|;
comment|// Lock types
specifier|static
specifier|final
specifier|protected
name|char
name|LOCK_EXCLUSIVE
init|=
literal|'e'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|LOCK_SHARED
init|=
literal|'r'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|LOCK_SEMI_SHARED
init|=
literal|'w'
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|int
name|ALLOWED_REPEATED_DEADLOCKS
init|=
literal|10
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|int
name|TIMED_OUT_TXN_ABORT_BATCH_SIZE
init|=
literal|100
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TxnHandler
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|static
specifier|private
name|DataSource
name|connPool
decl_stmt|;
specifier|static
specifier|private
name|boolean
name|doRetryOnConnPool
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|Object
name|lockLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|// Random object to lock on for the lock
comment|// method
comment|/**    * Number of consecutive deadlocks we have seen    */
specifier|private
name|int
name|deadlockCnt
decl_stmt|;
specifier|private
specifier|final
name|long
name|deadlockRetryInterval
decl_stmt|;
specifier|protected
name|HiveConf
name|conf
decl_stmt|;
specifier|protected
name|DatabaseProduct
name|dbProduct
decl_stmt|;
comment|// (End user) Transaction timeout, in milliseconds.
specifier|private
name|long
name|timeout
decl_stmt|;
specifier|private
name|String
name|identifierQuoteString
decl_stmt|;
comment|// quotes to use for quoting tables, where necessary
specifier|private
specifier|final
name|long
name|retryInterval
decl_stmt|;
specifier|private
specifier|final
name|int
name|retryLimit
decl_stmt|;
specifier|private
name|int
name|retryNum
decl_stmt|;
comment|// DEADLOCK DETECTION AND HANDLING
comment|// A note to developers of this class.  ALWAYS access HIVE_LOCKS before TXNS to avoid deadlock
comment|// between simultaneous accesses.  ALWAYS access TXN_COMPONENTS before HIVE_LOCKS .
comment|//
comment|// Private methods should never catch SQLException and then throw MetaException.  The public
comment|// methods depend on SQLException coming back so they can detect and handle deadlocks.  Private
comment|// methods should only throw MetaException when they explicitly know there's a logic error and
comment|// they want to throw past the public methods.
comment|//
comment|// All public methods that write to the database have to check for deadlocks when a SQLException
comment|// comes back and handle it if they see one.  This has to be done with the connection pooling
comment|// in mind.  To do this they should call checkRetryable() AFTER rolling back the db transaction,
comment|// and then they should catch RetryException and call themselves recursively. See commitTxn for an example.
specifier|public
name|TxnHandler
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|checkQFileTestHack
argument_list|()
expr_stmt|;
comment|// Set up the JDBC connection pool
try|try
block|{
name|setupJdbcConnectionPool
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"Unable to instantiate JDBC connection pooling, "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|timeout
operator|=
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_TXN_TIMEOUT
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|buildJumpTable
argument_list|()
expr_stmt|;
name|retryInterval
operator|=
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HMSHANDLERINTERVAL
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|retryLimit
operator|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HMSHANDLERATTEMPTS
argument_list|)
expr_stmt|;
name|deadlockRetryInterval
operator|=
name|retryInterval
operator|/
literal|10
expr_stmt|;
block|}
specifier|public
name|GetOpenTxnsInfoResponse
name|getOpenTxnsInfo
parameter_list|()
throws|throws
name|MetaException
block|{
try|try
block|{
comment|// We need to figure out the current transaction number and the list of
comment|// open transactions.  To avoid needing a transaction on the underlying
comment|// database we'll look at the current transaction number first.  If it
comment|// subsequently shows up in the open list that's ok.
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|/**          * This method can run at READ_COMMITTED as long as long as          * {@link #openTxns(org.apache.hadoop.hive.metastore.api.OpenTxnRequest)} is atomic.          * More specifically, as long as advancing TransactionID in NEXT_TXN_ID is atomic with          * adding corresponding entries into TXNS.  The reason is that any txnid below HWM          * is either in TXNS and thus considered open (Open/Aborted) or it's considered Committed.          */
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select ntxn_next - 1 from NEXT_TXN_ID"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly "
operator|+
literal|"initialized, no record found in next_txn_id"
argument_list|)
throw|;
block|}
name|long
name|hwm
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly "
operator|+
literal|"initialized, null record found in next_txn_id"
argument_list|)
throw|;
block|}
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|TxnInfo
argument_list|>
name|txnInfo
init|=
operator|new
name|ArrayList
argument_list|<
name|TxnInfo
argument_list|>
argument_list|()
decl_stmt|;
comment|//need the WHERE clause below to ensure consistent results with READ_COMMITTED
name|s
operator|=
literal|"select txn_id, txn_state, txn_user, txn_host from TXNS where txn_id<= "
operator|+
name|hwm
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|char
name|c
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|TxnState
name|state
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|TXN_ABORTED
case|:
name|state
operator|=
name|TxnState
operator|.
name|ABORTED
expr_stmt|;
break|break;
case|case
name|TXN_OPEN
case|:
name|state
operator|=
name|TxnState
operator|.
name|OPEN
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unexpected transaction state "
operator|+
name|c
operator|+
literal|" found in txns table"
argument_list|)
throw|;
block|}
name|txnInfo
operator|.
name|add
argument_list|(
operator|new
name|TxnInfo
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|,
name|state
argument_list|,
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
argument_list|,
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
operator|new
name|GetOpenTxnsInfoResponse
argument_list|(
name|hwm
argument_list|,
name|txnInfo
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"getOpenTxnsInfo"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database: "
operator|+
name|getMessage
argument_list|(
name|e
argument_list|)
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|getOpenTxnsInfo
argument_list|()
return|;
block|}
block|}
specifier|public
name|GetOpenTxnsResponse
name|getOpenTxns
parameter_list|()
throws|throws
name|MetaException
block|{
try|try
block|{
comment|// We need to figure out the current transaction number and the list of
comment|// open transactions.  To avoid needing a transaction on the underlying
comment|// database we'll look at the current transaction number first.  If it
comment|// subsequently shows up in the open list that's ok.
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|/**          * This runs at READ_COMMITTED for exactly the same reason as {@link #getOpenTxnsInfo()} \         */
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select ntxn_next - 1 from NEXT_TXN_ID"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly "
operator|+
literal|"initialized, no record found in next_txn_id"
argument_list|)
throw|;
block|}
name|long
name|hwm
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly "
operator|+
literal|"initialized, null record found in next_txn_id"
argument_list|)
throw|;
block|}
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Long
argument_list|>
name|openList
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
comment|//need the WHERE clause below to ensure consistent results with READ_COMMITTED
name|s
operator|=
literal|"select txn_id from TXNS where txn_id<= "
operator|+
name|hwm
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|openList
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
operator|new
name|GetOpenTxnsResponse
argument_list|(
name|hwm
argument_list|,
name|openList
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"getOpenTxns"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database, "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|getOpenTxns
argument_list|()
return|;
block|}
block|}
comment|/**    * Transform a {@link org.apache.hadoop.hive.metastore.api.GetOpenTxnsResponse} to a    * {@link org.apache.hadoop.hive.common.ValidTxnList}.  This assumes that the caller intends to    * read the files, and thus treats both open and aborted transactions as invalid.    * @param txns txn list from the metastore    * @param currentTxn Current transaction that the user has open.  If this is greater than 0 it    *                   will be removed from the exceptions list so that the user sees his own    *                   transaction as valid.    * @return a valid txn list.    */
specifier|public
specifier|static
name|ValidTxnList
name|createValidReadTxnList
parameter_list|(
name|GetOpenTxnsResponse
name|txns
parameter_list|,
name|long
name|currentTxn
parameter_list|)
block|{
name|long
name|highWater
init|=
name|txns
operator|.
name|getTxn_high_water_mark
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Long
argument_list|>
name|open
init|=
name|txns
operator|.
name|getOpen_txns
argument_list|()
decl_stmt|;
name|long
index|[]
name|exceptions
init|=
operator|new
name|long
index|[
name|open
operator|.
name|size
argument_list|()
operator|-
operator|(
name|currentTxn
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|long
name|txn
range|:
name|open
control|)
block|{
if|if
condition|(
name|currentTxn
operator|>
literal|0
operator|&&
name|currentTxn
operator|==
name|txn
condition|)
continue|continue;
name|exceptions
index|[
name|i
operator|++
index|]
operator|=
name|txn
expr_stmt|;
block|}
return|return
operator|new
name|ValidReadTxnList
argument_list|(
name|exceptions
argument_list|,
name|highWater
argument_list|)
return|;
block|}
specifier|public
name|OpenTxnsResponse
name|openTxns
parameter_list|(
name|OpenTxnRequest
name|rqst
parameter_list|)
throws|throws
name|MetaException
block|{
name|int
name|numTxns
init|=
name|rqst
operator|.
name|getNum_txns
argument_list|()
decl_stmt|;
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|/**          * To make {@link #getOpenTxns()}/{@link #getOpenTxnsInfo()} work correctly, this operation must ensure          * that advancing the counter in NEXT_TXN_ID and adding appropriate entries to TXNS is atomic.          * Also, advancing the counter must work when multiple metastores are running, thus either          * SELECT ... FOR UPDATE is used or SERIALIZABLE isolation.  The former is preferred since it prevents          * concurrent DB transactions being rolled back due to Write-Write conflict on NEXT_TXN_ID.          *          * In the current design, there can be several metastore instances running in a given Warehouse.          * This makes ideas like reserving a range of IDs to save trips to DB impossible.  For example,          * a client may go to MS1 and start a transaction with ID 500 to update a particular row.          * Now the same client will start another transaction, except it ends up on MS2 and may get          * transaction ID 400 and update the same row.  Now the merge that happens to materialize the snapshot          * on read will thing the version of the row from transaction ID 500 is the latest one.          *          * Longer term we can consider running Active-Passive MS (at least wrt to ACID operations).  This          * set could support a write-through cache for added performance.          */
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|getRequiredIsolationLevel
argument_list|()
argument_list|)
expr_stmt|;
comment|// Make sure the user has not requested an insane amount of txns.
name|int
name|maxTxns
init|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_TXN_MAX_OPEN_BATCH
argument_list|)
decl_stmt|;
if|if
condition|(
name|numTxns
operator|>
name|maxTxns
condition|)
name|numTxns
operator|=
name|maxTxns
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
name|addForUpdateClause
argument_list|(
name|dbConn
argument_list|,
literal|"select ntxn_next from NEXT_TXN_ID"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction database not properly "
operator|+
literal|"configured, can't find next transaction id."
argument_list|)
throw|;
block|}
name|long
name|first
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|s
operator|=
literal|"update NEXT_TXN_ID set ntxn_next = "
operator|+
operator|(
name|first
operator|+
name|numTxns
operator|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|long
name|now
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|s
operator|=
literal|"insert into TXNS (txn_id, txn_state, txn_started, "
operator|+
literal|"txn_last_heartbeat, txn_user, txn_host) values (?, 'o', "
operator|+
name|now
operator|+
literal|", "
operator|+
name|now
operator|+
literal|", '"
operator|+
name|rqst
operator|.
name|getUser
argument_list|()
operator|+
literal|"', '"
operator|+
name|rqst
operator|.
name|getHostname
argument_list|()
operator|+
literal|"')"
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to prepare statement<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|PreparedStatement
name|ps
init|=
name|dbConn
operator|.
name|prepareStatement
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|txnIds
init|=
operator|new
name|ArrayList
argument_list|<
name|Long
argument_list|>
argument_list|(
name|numTxns
argument_list|)
decl_stmt|;
for|for
control|(
name|long
name|i
init|=
name|first
init|;
name|i
operator|<
name|first
operator|+
name|numTxns
condition|;
name|i
operator|++
control|)
block|{
name|ps
operator|.
name|setLong
argument_list|(
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|//todo: this would be more efficient with a single insert with multiple rows in values()
comment|//need add a safeguard to not exceed the DB capabilities.
name|ps
operator|.
name|executeUpdate
argument_list|()
expr_stmt|;
name|txnIds
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
operator|new
name|OpenTxnsResponse
argument_list|(
name|txnIds
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"openTxns("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|openTxns
argument_list|(
name|rqst
argument_list|)
return|;
block|}
block|}
specifier|public
name|void
name|abortTxn
parameter_list|(
name|AbortTxnRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|MetaException
block|{
name|long
name|txnid
init|=
name|rqst
operator|.
name|getTxnid
argument_list|()
decl_stmt|;
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_SERIALIZABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|abortTxns
argument_list|(
name|dbConn
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|txnid
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|NoSuchTxnException
argument_list|(
literal|"No such transaction "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"abortTxn("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|abortTxn
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|commitTxn
parameter_list|(
name|CommitTxnRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
name|long
name|txnid
init|=
name|rqst
operator|.
name|getTxnid
argument_list|()
decl_stmt|;
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|/**          * This has to run at SERIALIZABLE to make no concurrent attempt to acquire locks (insert into HIVE_LOCKS)          * can happen.  Otherwise we may end up with orphaned locks.  While lock() and commitTxn() should not          * normally run concurrently (for same txn) but could due to bugs in the client which could then          * (w/o SERIALIZABLE) corrupt internal transaction manager state.  Also competes with abortTxn()          *          * Sketch of an improvement:          * Introduce a new transaction state in TXNS, state 'c'.  This is a transient Committed state.          * commitTxn() would mark the txn 'c' in TXNS in an independent txn.  Other operation like          * lock(), heartbeat(), etc would raise errors for txn in 'c' state and getOpenTxns(), etc would          * treat 'c' txn as 'open'.  Then this method could run in READ COMMITTED since the          * entry for this txn in TXNS in 'c' acts like a monitor.          * Since the move to 'c' state is in one txn (to make it visible) and the rest of the          * operations in another (could even be made separate txns), there is a possibility of failure          * between the 2.  Thus the AcidHouseKeeper logic to timeout txns should apply 'c' state txns.          *          * Or perhaps Select * TXNS where txn_id = " + txnid; for update          */
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_SERIALIZABLE
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
comment|// Before we do the commit heartbeat the txn.  This is slightly odd in that we're going to
comment|// commit it, but it does two things.  One, it makes sure the transaction is still valid.
comment|// Two, it avoids the race condition where we time out between now and when we actually
comment|// commit the transaction below.  And it does this all in a dead-lock safe way by
comment|// committing the heartbeat back to the database.
name|heartbeatTxn
argument_list|(
name|dbConn
argument_list|,
name|txnid
argument_list|)
expr_stmt|;
comment|// Move the record from txn_components into completed_txn_components so that the compactor
comment|// knows where to look to compact.
name|String
name|s
init|=
literal|"insert into COMPLETED_TXN_COMPONENTS select tc_txnid, tc_database, tc_table, "
operator|+
literal|"tc_partition from TXN_COMPONENTS where tc_txnid = "
operator|+
name|txnid
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute insert<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
operator|<
literal|1
condition|)
block|{
comment|//this can be reasonable for an empty txn START/COMMIT
name|LOG
operator|.
name|info
argument_list|(
literal|"Expected to move at least one record from txn_components to "
operator|+
literal|"completed_txn_components when committing txn! "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Always access TXN_COMPONENTS before HIVE_LOCKS;
name|s
operator|=
literal|"delete from TXN_COMPONENTS where tc_txnid = "
operator|+
name|txnid
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|// Always access HIVE_LOCKS before TXNS
name|s
operator|=
literal|"delete from HIVE_LOCKS where hl_txnid = "
operator|+
name|txnid
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
literal|"delete from TXNS where txn_id = "
operator|+
name|txnid
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"commitTxn("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|commitTxn
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|LockResponse
name|lock
parameter_list|(
name|LockRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_SERIALIZABLE
argument_list|)
expr_stmt|;
return|return
name|lock
argument_list|(
name|dbConn
argument_list|,
name|rqst
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"lock("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|lock
argument_list|(
name|rqst
argument_list|)
return|;
block|}
block|}
comment|/**    * Why doesn't this get a txnid as parameter?  The caller should either know the txnid or know there isn't one.    * Either way getTxnIdFromLockId() will not be needed.  This would be a Thrift change.    *    * Also, when lock acquisition returns WAITING, it's retried every 15 seconds (best case, see DbLockManager.backoff(),    * in practice more often)    * which means this is heartbeating way more often than hive.txn.timeout and creating extra load on DB.    *    * The clients that operate in blocking mode, can't heartbeat a lock until the lock is acquired.    * We should make CheckLockRequest include timestamp or last request to skip unnecessary heartbeats. Thrift change.    *    * {@link #checkLock(java.sql.Connection, long)}  must run at SERIALIZABLE (make sure some lock we are checking    * against doesn't move from W to A in another txn) but this method can heartbeat in    * separate txn at READ_COMMITTED.    */
specifier|public
name|LockResponse
name|checkLock
parameter_list|(
name|CheckLockRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|NoSuchLockException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|long
name|extLockId
init|=
name|rqst
operator|.
name|getLockid
argument_list|()
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
comment|// Heartbeat on the lockid first, to assure that our lock is still valid.
comment|// Then look up the lock info (hopefully in the cache).  If these locks
comment|// are associated with a transaction then heartbeat on that as well.
name|Long
name|txnid
init|=
name|getTxnIdFromLockId
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|txnid
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchLockException
argument_list|(
literal|"No such lock "
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|txnid
operator|>
literal|0
condition|)
block|{
name|heartbeatTxn
argument_list|(
name|dbConn
argument_list|,
name|txnid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|heartbeatLock
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
expr_stmt|;
block|}
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_SERIALIZABLE
argument_list|)
expr_stmt|;
return|return
name|checkLock
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"checkLock("
operator|+
name|rqst
operator|+
literal|" )"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
operator|+
literal|" "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|checkLock
argument_list|(
name|rqst
argument_list|)
return|;
block|}
block|}
comment|/**    * This would have been made simpler if all locks were associated with a txn.  Then only txn needs to    * be heartbeated, committed, etc.  no need for client to track individual locks.    */
specifier|public
name|void
name|unlock
parameter_list|(
name|UnlockRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchLockException
throws|,
name|TxnOpenException
throws|,
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|long
name|extLockId
init|=
name|rqst
operator|.
name|getLockid
argument_list|()
decl_stmt|;
try|try
block|{
comment|/**          * This method is logically like commit for read-only auto commit queries.          * READ_COMMITTED since this only has 1 delete statement and no new entries with the          * same hl_lock_ext_id can be added, i.e. all rows with a given hl_lock_ext_id are          * created in a single atomic operation.          * Theoretically, this competes with {@link #lock(org.apache.hadoop.hive.metastore.api.LockRequest)}          * but hl_lock_ext_id is not known until that method returns.          * Also competes with {@link #checkLock(org.apache.hadoop.hive.metastore.api.CheckLockRequest)}          * but using SERIALIZABLE doesn't materially change the interaction.          * If "delete" stmt misses, additional logic is best effort to produce meaningful error msg.          */
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
comment|//hl_txnid<> 0 means it's associated with a transaction
name|String
name|s
init|=
literal|"delete from HIVE_LOCKS where hl_lock_ext_id = "
operator|+
name|extLockId
operator|+
literal|" AND hl_txnid = 0"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
name|Long
name|txnid
init|=
name|getTxnIdFromLockId
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|txnid
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"No lock found for unlock("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|NoSuchLockException
argument_list|(
literal|"No such lock "
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|txnid
operator|!=
literal|0
condition|)
block|{
name|String
name|msg
init|=
literal|"Unlocking locks associated with transaction"
operator|+
literal|" not permitted.  Lockid "
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
operator|+
literal|" is associated with "
operator|+
literal|"transaction "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|TxnOpenException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
if|if
condition|(
name|txnid
operator|==
literal|0
condition|)
block|{
comment|//we didn't see this lock when running DELETE stmt above but now it showed up
comment|//so should "should never happen" happened...
name|String
name|msg
init|=
literal|"Found lock "
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
operator|+
literal|" with "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"unlock("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
operator|+
literal|" "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|unlock
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * used to sort entries in {@link org.apache.hadoop.hive.metastore.api.ShowLocksResponse}    */
specifier|private
specifier|static
class|class
name|LockInfoExt
extends|extends
name|LockInfo
block|{
specifier|private
specifier|final
name|ShowLocksResponseElement
name|e
decl_stmt|;
name|LockInfoExt
parameter_list|(
name|ShowLocksResponseElement
name|e
parameter_list|,
name|long
name|intLockId
parameter_list|)
block|{
name|super
argument_list|(
name|e
argument_list|,
name|intLockId
argument_list|)
expr_stmt|;
name|this
operator|.
name|e
operator|=
name|e
expr_stmt|;
block|}
block|}
specifier|public
name|ShowLocksResponse
name|showLocks
parameter_list|(
name|ShowLocksRequest
name|rqst
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|ShowLocksResponse
name|rsp
init|=
operator|new
name|ShowLocksResponse
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ShowLocksResponseElement
argument_list|>
name|elems
init|=
operator|new
name|ArrayList
argument_list|<
name|ShowLocksResponseElement
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|LockInfoExt
argument_list|>
name|sortedList
init|=
operator|new
name|ArrayList
argument_list|<
name|LockInfoExt
argument_list|>
argument_list|()
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select hl_lock_ext_id, hl_txnid, hl_db, hl_table, hl_partition, hl_lock_state, "
operator|+
literal|"hl_lock_type, hl_last_heartbeat, hl_acquired_at, hl_user, hl_host, hl_lock_int_id from HIVE_LOCKS"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Doing to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|ShowLocksResponseElement
name|e
init|=
operator|new
name|ShowLocksResponseElement
argument_list|()
decl_stmt|;
name|e
operator|.
name|setLockid
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|txnid
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
name|e
operator|.
name|setTxnid
argument_list|(
name|txnid
argument_list|)
expr_stmt|;
name|e
operator|.
name|setDbname
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setTablename
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|partition
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
name|partition
operator|!=
literal|null
condition|)
name|e
operator|.
name|setPartname
argument_list|(
name|partition
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|LOCK_ACQUIRED
case|:
name|e
operator|.
name|setState
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCK_WAITING
case|:
name|e
operator|.
name|setState
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unknown lock state "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|7
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|LOCK_SEMI_SHARED
case|:
name|e
operator|.
name|setType
argument_list|(
name|LockType
operator|.
name|SHARED_WRITE
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCK_EXCLUSIVE
case|:
name|e
operator|.
name|setType
argument_list|(
name|LockType
operator|.
name|EXCLUSIVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCK_SHARED
case|:
name|e
operator|.
name|setType
argument_list|(
name|LockType
operator|.
name|SHARED_READ
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unknown lock type "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
throw|;
block|}
name|e
operator|.
name|setLastheartbeat
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|acquiredAt
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|9
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
name|e
operator|.
name|setAcquiredat
argument_list|(
name|acquiredAt
argument_list|)
expr_stmt|;
name|e
operator|.
name|setUser
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setHostname
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|11
argument_list|)
argument_list|)
expr_stmt|;
name|sortedList
operator|.
name|add
argument_list|(
operator|new
name|LockInfoExt
argument_list|(
name|e
argument_list|,
name|rs
operator|.
name|getLong
argument_list|(
literal|12
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"showLocks("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
comment|//this ensures that "SHOW LOCKS" prints the locks in the same order as they are examined
comment|//by checkLock() - makes diagnostics easier.
name|Collections
operator|.
name|sort
argument_list|(
name|sortedList
argument_list|,
operator|new
name|LockInfoComparator
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|LockInfoExt
name|lockInfoExt
range|:
name|sortedList
control|)
block|{
name|elems
operator|.
name|add
argument_list|(
name|lockInfoExt
operator|.
name|e
argument_list|)
expr_stmt|;
block|}
name|rsp
operator|.
name|setLocks
argument_list|(
name|elems
argument_list|)
expr_stmt|;
return|return
name|rsp
return|;
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|showLocks
argument_list|(
name|rqst
argument_list|)
return|;
block|}
block|}
comment|/**    * {@code ids} should only have txnid or lockid but not both, ideally.    * Currently DBTxnManager.heartbeat() enforces this.    */
specifier|public
name|void
name|heartbeat
parameter_list|(
name|HeartbeatRequest
name|ids
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|NoSuchLockException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|heartbeatLock
argument_list|(
name|dbConn
argument_list|,
name|ids
operator|.
name|getLockid
argument_list|()
argument_list|)
expr_stmt|;
name|heartbeatTxn
argument_list|(
name|dbConn
argument_list|,
name|ids
operator|.
name|getTxnid
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"heartbeat("
operator|+
name|ids
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|heartbeat
argument_list|(
name|ids
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|HeartbeatTxnRangeResponse
name|heartbeatTxnRange
parameter_list|(
name|HeartbeatTxnRangeRequest
name|rqst
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|HeartbeatTxnRangeResponse
name|rsp
init|=
operator|new
name|HeartbeatTxnRangeResponse
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Long
argument_list|>
name|nosuch
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Long
argument_list|>
name|aborted
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
name|rsp
operator|.
name|setNosuch
argument_list|(
name|nosuch
argument_list|)
expr_stmt|;
name|rsp
operator|.
name|setAborted
argument_list|(
name|aborted
argument_list|)
expr_stmt|;
try|try
block|{
comment|/**          * READ_COMMITTED is sufficient since {@link #heartbeatTxn(java.sql.Connection, long)}          * only has 1 update statement in it and          * we only update existing txns, i.e. nothing can add additional txns that this operation          * would care about (which would have required SERIALIZABLE)          */
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
for|for
control|(
name|long
name|txn
init|=
name|rqst
operator|.
name|getMin
argument_list|()
init|;
name|txn
operator|<=
name|rqst
operator|.
name|getMax
argument_list|()
condition|;
name|txn
operator|++
control|)
block|{
try|try
block|{
comment|//todo: this is expensive call: at least 2 update queries per txn
comment|//is this really worth it?
name|heartbeatTxn
argument_list|(
name|dbConn
argument_list|,
name|txn
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchTxnException
name|e
parameter_list|)
block|{
name|nosuch
operator|.
name|add
argument_list|(
name|txn
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TxnAbortedException
name|e
parameter_list|)
block|{
name|aborted
operator|.
name|add
argument_list|(
name|txn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|rsp
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"heartbeatTxnRange("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|heartbeatTxnRange
argument_list|(
name|rqst
argument_list|)
return|;
block|}
block|}
specifier|public
name|void
name|compact
parameter_list|(
name|CompactionRequest
name|rqst
parameter_list|)
throws|throws
name|MetaException
block|{
comment|// Put a compaction request in the queue.
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|getRequiredIsolationLevel
argument_list|()
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
comment|// Get the id for the next entry in the queue
name|String
name|s
init|=
name|addForUpdateClause
argument_list|(
name|dbConn
argument_list|,
literal|"select ncq_next from NEXT_COMPACTION_QUEUE_ID"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly initiated, "
operator|+
literal|"no record found in next_compaction_queue_id"
argument_list|)
throw|;
block|}
name|long
name|id
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|s
operator|=
literal|"update NEXT_COMPACTION_QUEUE_ID set ncq_next = "
operator|+
operator|(
name|id
operator|+
literal|1
operator|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"insert into COMPACTION_QUEUE (cq_id, cq_database, "
operator|+
literal|"cq_table, "
argument_list|)
decl_stmt|;
name|String
name|partName
init|=
name|rqst
operator|.
name|getPartitionname
argument_list|()
decl_stmt|;
if|if
condition|(
name|partName
operator|!=
literal|null
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|"cq_partition, "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"cq_state, cq_type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqst
operator|.
name|getRunas
argument_list|()
operator|!=
literal|null
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|", cq_run_as"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|") values ("
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|", '"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|rqst
operator|.
name|getDbname
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|rqst
operator|.
name|getTablename
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
if|if
condition|(
name|partName
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|partName
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|INITIATED_STATE
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rqst
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|MAJOR
case|:
name|buf
operator|.
name|append
argument_list|(
name|MAJOR_TYPE
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINOR
case|:
name|buf
operator|.
name|append
argument_list|(
name|MINOR_TYPE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unexpected compaction type "
operator|+
name|rqst
operator|.
name|getType
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|rqst
operator|.
name|getRunas
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|rqst
operator|.
name|getRunas
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"')"
argument_list|)
expr_stmt|;
name|s
operator|=
name|buf
operator|.
name|toString
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"compact("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|compact
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|ShowCompactResponse
name|showCompact
parameter_list|(
name|ShowCompactRequest
name|rqst
parameter_list|)
throws|throws
name|MetaException
block|{
name|ShowCompactResponse
name|response
init|=
operator|new
name|ShowCompactResponse
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ShowCompactResponseElement
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select cq_database, cq_table, cq_partition, cq_state, cq_type, cq_worker_id, "
operator|+
literal|"cq_start, cq_run_as from COMPACTION_QUEUE"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|ShowCompactResponseElement
name|e
init|=
operator|new
name|ShowCompactResponseElement
argument_list|()
decl_stmt|;
name|e
operator|.
name|setDbname
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setTablename
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setPartitionname
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|INITIATED_STATE
case|:
name|e
operator|.
name|setState
argument_list|(
name|INITIATED_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|WORKING_STATE
case|:
name|e
operator|.
name|setState
argument_list|(
name|WORKING_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|READY_FOR_CLEANING
case|:
name|e
operator|.
name|setState
argument_list|(
name|CLEANING_RESPONSE
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unexpected compaction state "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|MAJOR_TYPE
case|:
name|e
operator|.
name|setType
argument_list|(
name|CompactionType
operator|.
name|MAJOR
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINOR_TYPE
case|:
name|e
operator|.
name|setType
argument_list|(
name|CompactionType
operator|.
name|MINOR
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unexpected compaction type "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
argument_list|)
throw|;
block|}
name|e
operator|.
name|setWorkerid
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setStart
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setRunAs
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|response
operator|.
name|addToCompacts
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"showCompact("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
return|return
name|response
return|;
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|showCompact
argument_list|(
name|rqst
argument_list|)
return|;
block|}
block|}
specifier|public
name|void
name|addDynamicPartitions
parameter_list|(
name|AddDynamicPartitions
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
comment|// Heartbeat this first to make sure the transaction is still valid.
name|heartbeatTxn
argument_list|(
name|dbConn
argument_list|,
name|rqst
operator|.
name|getTxnid
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|partName
range|:
name|rqst
operator|.
name|getPartitionnames
argument_list|()
control|)
block|{
name|StringBuilder
name|buff
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"insert into TXN_COMPONENTS (tc_txnid, tc_database, tc_table, tc_partition) values ("
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|rqst
operator|.
name|getTxnid
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|", '"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|rqst
operator|.
name|getDbname
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|rqst
operator|.
name|getTablename
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|partName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"')"
argument_list|)
expr_stmt|;
name|String
name|s
init|=
name|buff
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"addDynamicPartitions("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to insert into from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|addDynamicPartitions
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * For testing only, do not use.    */
name|int
name|numLocksInLockTable
parameter_list|()
throws|throws
name|SQLException
throws|,
name|MetaException
block|{
name|Connection
name|dbConn
init|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select count(*) from HIVE_LOCKS"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|rs
operator|.
name|next
argument_list|()
expr_stmt|;
name|int
name|rc
init|=
name|rs
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// Necessary to clean up the transaction in the db.
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
name|rc
return|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * For testing only, do not use.    */
name|long
name|setTimeout
parameter_list|(
name|long
name|milliseconds
parameter_list|)
block|{
name|long
name|previous_timeout
init|=
name|timeout
decl_stmt|;
name|timeout
operator|=
name|milliseconds
expr_stmt|;
return|return
name|previous_timeout
return|;
block|}
specifier|protected
class|class
name|RetryException
extends|extends
name|Exception
block|{    }
specifier|protected
name|Connection
name|getDbConn
parameter_list|(
name|int
name|isolationLevel
parameter_list|)
throws|throws
name|SQLException
block|{
name|int
name|rc
init|=
name|doRetryOnConnPool
condition|?
literal|10
else|:
literal|1
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
name|connPool
operator|.
name|getConnection
argument_list|()
decl_stmt|;
name|dbConn
operator|.
name|setAutoCommit
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|setTransactionIsolation
argument_list|(
name|isolationLevel
argument_list|)
expr_stmt|;
return|return
name|dbConn
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|--
name|rc
operator|)
operator|<=
literal|0
condition|)
throw|throw
name|e
throw|;
name|LOG
operator|.
name|error
argument_list|(
literal|"There is a problem with a connection from the pool, retrying"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|void
name|rollbackDBConn
parameter_list|(
name|Connection
name|dbConn
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|dbConn
operator|!=
literal|null
operator|&&
operator|!
name|dbConn
operator|.
name|isClosed
argument_list|()
condition|)
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to rollback db connection "
operator|+
name|getMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|closeDbConn
parameter_list|(
name|Connection
name|dbConn
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|dbConn
operator|!=
literal|null
operator|&&
operator|!
name|dbConn
operator|.
name|isClosed
argument_list|()
condition|)
name|dbConn
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to close db connection "
operator|+
name|getMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Close statement instance.    * @param stmt statement instance.    */
specifier|protected
name|void
name|closeStmt
parameter_list|(
name|Statement
name|stmt
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|stmt
operator|!=
literal|null
operator|&&
operator|!
name|stmt
operator|.
name|isClosed
argument_list|()
condition|)
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to close statement "
operator|+
name|getMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Close the ResultSet.    * @param rs may be {@code null}    */
name|void
name|close
parameter_list|(
name|ResultSet
name|rs
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|rs
operator|!=
literal|null
operator|&&
operator|!
name|rs
operator|.
name|isClosed
argument_list|()
condition|)
block|{
name|rs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to close statement "
operator|+
name|getMessage
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Close all 3 JDBC artifacts in order: {@code rs stmt dbConn}    */
name|void
name|close
parameter_list|(
name|ResultSet
name|rs
parameter_list|,
name|Statement
name|stmt
parameter_list|,
name|Connection
name|dbConn
parameter_list|)
block|{
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
comment|/**    * Determine if an exception was such that it makes sense to retry.  Unfortunately there is no standard way to do    * this, so we have to inspect the error messages and catch the telltale signs for each    * different database.  This method will throw {@code RetryException}    * if the error is retry-able.    * @param conn database connection    * @param e exception that was thrown.    * @param caller name of the method calling this (and other info useful to log)    * @throws org.apache.hadoop.hive.metastore.txn.TxnHandler.RetryException when the operation should be retried    */
specifier|protected
name|void
name|checkRetryable
parameter_list|(
name|Connection
name|conn
parameter_list|,
name|SQLException
name|e
parameter_list|,
name|String
name|caller
parameter_list|)
throws|throws
name|RetryException
throws|,
name|MetaException
block|{
comment|// If you change this function, remove the @Ignore from TestTxnHandler.deadlockIsDetected()
comment|// to test these changes.
comment|// MySQL and MSSQL use 40001 as the state code for rollback.  Postgres uses 40001 and 40P01.
comment|// Oracle seems to return different SQLStates and messages each time,
comment|// so I've tried to capture the different error messages (there appear to be fewer different
comment|// error messages than SQL states).
comment|// Derby and newer MySQL driver use the new SQLTransactionRollbackException
name|boolean
name|sendRetrySignal
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|dbProduct
operator|==
literal|null
operator|&&
name|conn
operator|!=
literal|null
condition|)
block|{
name|determineDatabaseProduct
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|instanceof
name|SQLTransactionRollbackException
operator|||
operator|(
operator|(
name|dbProduct
operator|==
name|DatabaseProduct
operator|.
name|MYSQL
operator|||
name|dbProduct
operator|==
name|DatabaseProduct
operator|.
name|POSTGRES
operator|||
name|dbProduct
operator|==
name|DatabaseProduct
operator|.
name|SQLSERVER
operator|)
operator|&&
name|e
operator|.
name|getSQLState
argument_list|()
operator|.
name|equals
argument_list|(
literal|"40001"
argument_list|)
operator|)
operator|||
operator|(
name|dbProduct
operator|==
name|DatabaseProduct
operator|.
name|POSTGRES
operator|&&
name|e
operator|.
name|getSQLState
argument_list|()
operator|.
name|equals
argument_list|(
literal|"40P01"
argument_list|)
operator|)
operator|||
operator|(
name|dbProduct
operator|==
name|DatabaseProduct
operator|.
name|ORACLE
operator|&&
operator|(
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"deadlock detected"
argument_list|)
operator|||
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"can't serialize access for this transaction"
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|deadlockCnt
operator|++
operator|<
name|ALLOWED_REPEATED_DEADLOCKS
condition|)
block|{
name|long
name|waitInterval
init|=
name|deadlockRetryInterval
operator|*
name|deadlockCnt
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Deadlock detected in "
operator|+
name|caller
operator|+
literal|". Will wait "
operator|+
name|waitInterval
operator|+
literal|"ms try again up to "
operator|+
operator|(
name|ALLOWED_REPEATED_DEADLOCKS
operator|-
name|deadlockCnt
operator|+
literal|1
operator|)
operator|+
literal|" times."
argument_list|)
expr_stmt|;
comment|// Pause for a just a bit for retrying to avoid immediately jumping back into the deadlock.
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|waitInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// NOP
block|}
name|sendRetrySignal
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Too many repeated deadlocks in "
operator|+
name|caller
operator|+
literal|", giving up."
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isRetryable
argument_list|(
name|e
argument_list|)
condition|)
block|{
comment|//in MSSQL this means Communication Link Failure
if|if
condition|(
name|retryNum
operator|++
operator|<
name|retryLimit
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Retryable error detected in "
operator|+
name|caller
operator|+
literal|".  Will wait "
operator|+
name|retryInterval
operator|+
literal|"ms and retry up to "
operator|+
operator|(
name|retryLimit
operator|-
name|retryNum
operator|+
literal|1
operator|)
operator|+
literal|" times.  Error: "
operator|+
name|getMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|retryInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
comment|//
block|}
name|sendRetrySignal
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Fatal error. Retry limit ("
operator|+
name|retryLimit
operator|+
literal|") reached. Last error: "
operator|+
name|getMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
comment|/*if this method ends with anything except a retry signal, the caller should fail the operation       and propagate the error up to the its caller (Metastore client); thus must reset retry counters*/
if|if
condition|(
operator|!
name|sendRetrySignal
condition|)
block|{
name|deadlockCnt
operator|=
literal|0
expr_stmt|;
name|retryNum
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sendRetrySignal
condition|)
block|{
throw|throw
operator|new
name|RetryException
argument_list|()
throw|;
block|}
block|}
comment|/**    * Determine the current time, using the RDBMS as a source of truth    * @param conn database connection    * @return current time in milliseconds    * @throws org.apache.hadoop.hive.metastore.api.MetaException if the time cannot be determined    */
specifier|protected
name|long
name|getDbTime
parameter_list|(
name|Connection
name|conn
parameter_list|)
throws|throws
name|MetaException
block|{
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|conn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
decl_stmt|;
name|DatabaseProduct
name|prod
init|=
name|determineDatabaseProduct
argument_list|(
name|conn
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|prod
condition|)
block|{
case|case
name|DERBY
case|:
name|s
operator|=
literal|"values current_timestamp"
expr_stmt|;
break|break;
case|case
name|MYSQL
case|:
case|case
name|POSTGRES
case|:
case|case
name|SQLSERVER
case|:
name|s
operator|=
literal|"select current_timestamp"
expr_stmt|;
break|break;
case|case
name|ORACLE
case|:
name|s
operator|=
literal|"select current_timestamp from dual"
expr_stmt|;
break|break;
default|default:
name|String
name|msg
init|=
literal|"Unknown database product: "
operator|+
name|prod
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"No results from date query"
argument_list|)
throw|;
return|return
name|rs
operator|.
name|getTimestamp
argument_list|(
literal|1
argument_list|)
operator|.
name|getTime
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"Unable to determine current time: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Determine the String that should be used to quote identifiers.    * @param conn Active connection    * @return quotes    * @throws SQLException    */
specifier|protected
name|String
name|getIdentifierQuoteString
parameter_list|(
name|Connection
name|conn
parameter_list|)
throws|throws
name|SQLException
block|{
if|if
condition|(
name|identifierQuoteString
operator|==
literal|null
condition|)
block|{
name|identifierQuoteString
operator|=
name|conn
operator|.
name|getMetaData
argument_list|()
operator|.
name|getIdentifierQuoteString
argument_list|()
expr_stmt|;
block|}
return|return
name|identifierQuoteString
return|;
block|}
specifier|protected
enum|enum
name|DatabaseProduct
block|{
name|DERBY
block|,
name|MYSQL
block|,
name|POSTGRES
block|,
name|ORACLE
block|,
name|SQLSERVER
block|}
comment|/**    * Determine the database product type    * @param conn database connection    * @return database product type    * @throws MetaException if the type cannot be determined or is unknown    */
specifier|protected
name|DatabaseProduct
name|determineDatabaseProduct
parameter_list|(
name|Connection
name|conn
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|dbProduct
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|String
name|s
init|=
name|conn
operator|.
name|getMetaData
argument_list|()
operator|.
name|getDatabaseProductName
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
name|String
name|msg
init|=
literal|"getDatabaseProductName returns null, can't determine database product"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"Apache Derby"
argument_list|)
condition|)
block|{
name|dbProduct
operator|=
name|DatabaseProduct
operator|.
name|DERBY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"Microsoft SQL Server"
argument_list|)
condition|)
block|{
name|dbProduct
operator|=
name|DatabaseProduct
operator|.
name|SQLSERVER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"MySQL"
argument_list|)
condition|)
block|{
name|dbProduct
operator|=
name|DatabaseProduct
operator|.
name|MYSQL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"Oracle"
argument_list|)
condition|)
block|{
name|dbProduct
operator|=
name|DatabaseProduct
operator|.
name|ORACLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"PostgreSQL"
argument_list|)
condition|)
block|{
name|dbProduct
operator|=
name|DatabaseProduct
operator|.
name|POSTGRES
expr_stmt|;
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"Unrecognized database product name<"
operator|+
name|s
operator|+
literal|">"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"Unable to get database product name: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
return|return
name|dbProduct
return|;
block|}
specifier|private
specifier|static
class|class
name|LockInfo
block|{
specifier|private
specifier|final
name|long
name|extLockId
decl_stmt|;
specifier|private
specifier|final
name|long
name|intLockId
decl_stmt|;
comment|//0 means there is no transaction, i.e. it a select statement which is not part of
comment|//explicit transaction or a IUD statement that is not writing to ACID table
specifier|private
specifier|final
name|long
name|txnId
decl_stmt|;
specifier|private
specifier|final
name|String
name|db
decl_stmt|;
specifier|private
specifier|final
name|String
name|table
decl_stmt|;
specifier|private
specifier|final
name|String
name|partition
decl_stmt|;
specifier|private
specifier|final
name|LockState
name|state
decl_stmt|;
specifier|private
specifier|final
name|LockType
name|type
decl_stmt|;
comment|// Assumes the result set is set to a valid row
name|LockInfo
parameter_list|(
name|ResultSet
name|rs
parameter_list|)
throws|throws
name|SQLException
throws|,
name|MetaException
block|{
name|extLockId
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|"hl_lock_ext_id"
argument_list|)
expr_stmt|;
comment|// can't be null
name|intLockId
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|"hl_lock_int_id"
argument_list|)
expr_stmt|;
comment|// can't be null
name|db
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_db"
argument_list|)
expr_stmt|;
comment|// can't be null
name|String
name|t
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_table"
argument_list|)
decl_stmt|;
name|table
operator|=
operator|(
name|rs
operator|.
name|wasNull
argument_list|()
condition|?
literal|null
else|:
name|t
operator|)
expr_stmt|;
name|String
name|p
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_partition"
argument_list|)
decl_stmt|;
name|partition
operator|=
operator|(
name|rs
operator|.
name|wasNull
argument_list|()
condition|?
literal|null
else|:
name|p
operator|)
expr_stmt|;
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_lock_state"
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|LOCK_WAITING
case|:
name|state
operator|=
name|LockState
operator|.
name|WAITING
expr_stmt|;
break|break;
case|case
name|LOCK_ACQUIRED
case|:
name|state
operator|=
name|LockState
operator|.
name|ACQUIRED
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unknown lock state "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_lock_state"
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_lock_type"
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|LOCK_EXCLUSIVE
case|:
name|type
operator|=
name|LockType
operator|.
name|EXCLUSIVE
expr_stmt|;
break|break;
case|case
name|LOCK_SHARED
case|:
name|type
operator|=
name|LockType
operator|.
name|SHARED_READ
expr_stmt|;
break|break;
case|case
name|LOCK_SEMI_SHARED
case|:
name|type
operator|=
name|LockType
operator|.
name|SHARED_WRITE
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unknown lock type "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_lock_type"
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
throw|;
block|}
name|txnId
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|"hl_txnid"
argument_list|)
expr_stmt|;
comment|//returns 0 if value is NULL
block|}
name|LockInfo
parameter_list|(
name|ShowLocksResponseElement
name|e
parameter_list|,
name|long
name|intLockId
parameter_list|)
block|{
name|extLockId
operator|=
name|e
operator|.
name|getLockid
argument_list|()
expr_stmt|;
name|this
operator|.
name|intLockId
operator|=
name|intLockId
expr_stmt|;
name|db
operator|=
name|e
operator|.
name|getDbname
argument_list|()
expr_stmt|;
name|table
operator|=
name|e
operator|.
name|getTablename
argument_list|()
expr_stmt|;
name|partition
operator|=
name|e
operator|.
name|getPartname
argument_list|()
expr_stmt|;
name|state
operator|=
name|e
operator|.
name|getState
argument_list|()
expr_stmt|;
name|type
operator|=
name|e
operator|.
name|getType
argument_list|()
expr_stmt|;
name|txnId
operator|=
name|e
operator|.
name|getTxnid
argument_list|()
expr_stmt|;
block|}
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|other
operator|instanceof
name|LockInfo
operator|)
condition|)
return|return
literal|false
return|;
name|LockInfo
name|o
init|=
operator|(
name|LockInfo
operator|)
name|other
decl_stmt|;
comment|// Lock ids are unique across the system.
return|return
name|extLockId
operator|==
name|o
operator|.
name|extLockId
operator|&&
name|intLockId
operator|==
name|o
operator|.
name|intLockId
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
operator|+
literal|" intLockId:"
operator|+
name|intLockId
operator|+
literal|" "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnId
argument_list|)
operator|+
literal|" db:"
operator|+
name|db
operator|+
literal|" table:"
operator|+
name|table
operator|+
literal|" partition:"
operator|+
name|partition
operator|+
literal|" state:"
operator|+
operator|(
name|state
operator|==
literal|null
condition|?
literal|"null"
else|:
name|state
operator|.
name|toString
argument_list|()
operator|)
operator|+
literal|" type:"
operator|+
operator|(
name|type
operator|==
literal|null
condition|?
literal|"null"
else|:
name|type
operator|.
name|toString
argument_list|()
operator|)
return|;
block|}
specifier|private
name|boolean
name|isDbLock
parameter_list|()
block|{
return|return
name|db
operator|!=
literal|null
operator|&&
name|table
operator|==
literal|null
operator|&&
name|partition
operator|==
literal|null
return|;
block|}
specifier|private
name|boolean
name|isTableLock
parameter_list|()
block|{
return|return
name|db
operator|!=
literal|null
operator|&&
name|table
operator|!=
literal|null
operator|&&
name|partition
operator|==
literal|null
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|LockInfoComparator
implements|implements
name|Comparator
argument_list|<
name|LockInfo
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|LockTypeComparator
name|lockTypeComparator
init|=
operator|new
name|LockTypeComparator
argument_list|()
decl_stmt|;
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
return|return
name|this
operator|==
name|other
return|;
block|}
specifier|public
name|int
name|compare
parameter_list|(
name|LockInfo
name|info1
parameter_list|,
name|LockInfo
name|info2
parameter_list|)
block|{
comment|// We sort by state (acquired vs waiting) and then by LockType, they by id
if|if
condition|(
name|info1
operator|.
name|state
operator|==
name|LockState
operator|.
name|ACQUIRED
operator|&&
name|info2
operator|.
name|state
operator|!=
name|LockState
operator|.
name|ACQUIRED
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|info1
operator|.
name|state
operator|!=
name|LockState
operator|.
name|ACQUIRED
operator|&&
name|info2
operator|.
name|state
operator|==
name|LockState
operator|.
name|ACQUIRED
condition|)
block|{
return|return
literal|1
return|;
block|}
name|int
name|sortByType
init|=
name|lockTypeComparator
operator|.
name|compare
argument_list|(
name|info1
operator|.
name|type
argument_list|,
name|info2
operator|.
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|sortByType
operator|!=
literal|0
condition|)
block|{
return|return
name|sortByType
return|;
block|}
if|if
condition|(
name|info1
operator|.
name|extLockId
operator|<
name|info2
operator|.
name|extLockId
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|info1
operator|.
name|extLockId
operator|>
name|info2
operator|.
name|extLockId
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|info1
operator|.
name|intLockId
operator|<
name|info2
operator|.
name|intLockId
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|info1
operator|.
name|intLockId
operator|>
name|info2
operator|.
name|intLockId
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
comment|/**    * Sort more restrictive locks after less restrictive ones    */
specifier|private
specifier|final
specifier|static
class|class
name|LockTypeComparator
implements|implements
name|Comparator
argument_list|<
name|LockType
argument_list|>
block|{
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
return|return
name|this
operator|==
name|other
return|;
block|}
specifier|public
name|int
name|compare
parameter_list|(
name|LockType
name|t1
parameter_list|,
name|LockType
name|t2
parameter_list|)
block|{
switch|switch
condition|(
name|t1
condition|)
block|{
case|case
name|EXCLUSIVE
case|:
if|if
condition|(
name|t2
operator|==
name|LockType
operator|.
name|EXCLUSIVE
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
case|case
name|SHARED_WRITE
case|:
switch|switch
condition|(
name|t2
condition|)
block|{
case|case
name|EXCLUSIVE
case|:
return|return
operator|-
literal|1
return|;
case|case
name|SHARED_WRITE
case|:
return|return
literal|0
return|;
case|case
name|SHARED_READ
case|:
return|return
literal|1
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected LockType: "
operator|+
name|t2
argument_list|)
throw|;
block|}
case|case
name|SHARED_READ
case|:
if|if
condition|(
name|t2
operator|==
name|LockType
operator|.
name|SHARED_READ
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected LockType: "
operator|+
name|t1
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
enum|enum
name|LockAction
block|{
name|ACQUIRE
block|,
name|WAIT
block|,
name|KEEP_LOOKING
block|}
comment|// A jump table to figure out whether to wait, acquire,
comment|// or keep looking .  Since
comment|// java doesn't have function pointers (grumble grumble) we store a
comment|// character that we'll use to determine which function to call.
comment|// The table maps the lock type of the lock we are looking to acquire to
comment|// the lock type of the lock we are checking to the lock state of the lock
comment|// we are checking to the desired action.
specifier|private
specifier|static
name|Map
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
argument_list|>
name|jumpTable
decl_stmt|;
specifier|private
name|void
name|checkQFileTestHack
parameter_list|()
block|{
name|boolean
name|hackOn
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_IN_TEST
argument_list|)
operator|||
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_IN_TEZ_TEST
argument_list|)
decl_stmt|;
if|if
condition|(
name|hackOn
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Hacking in canned values for transaction manager"
argument_list|)
expr_stmt|;
comment|// Set up the transaction/locking db in the derby metastore
name|TxnDbUtil
operator|.
name|setConfValues
argument_list|(
name|conf
argument_list|)
expr_stmt|;
try|try
block|{
name|TxnDbUtil
operator|.
name|prepDb
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// We may have already created the tables and thus don't need to redo it.
if|if
condition|(
operator|!
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"already exists"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unable to set up transaction database for"
operator|+
literal|" testing: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
block|}
specifier|private
name|int
name|abortTxns
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|List
argument_list|<
name|Long
argument_list|>
name|txnids
parameter_list|)
throws|throws
name|SQLException
block|{
return|return
name|abortTxns
argument_list|(
name|dbConn
argument_list|,
name|txnids
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**    * TODO: expose this as an operation to client.  Useful for streaming API to abort all remaining    * trasnactions in a batch on IOExceptions.    * @param dbConn An active connection    * @param txnids list of transactions to abort    * @param max_heartbeat value used by {@link #performTimeOuts()} to ensure this doesn't Abort txn which were    *                      hearbetated after #performTimeOuts() select and this operation.    * @return Number of aborted transactions    * @throws SQLException    */
specifier|private
name|int
name|abortTxns
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|List
argument_list|<
name|Long
argument_list|>
name|txnids
parameter_list|,
name|long
name|max_heartbeat
parameter_list|)
throws|throws
name|SQLException
block|{
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|int
name|updateCnt
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|txnids
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|Connection
operator|.
name|TRANSACTION_SERIALIZABLE
operator|!=
name|dbConn
operator|.
name|getTransactionIsolation
argument_list|()
condition|)
block|{
comment|/** Running this at SERIALIZABLE prevents new locks being added for this txnid(s) concurrently         * which would cause them to become orphaned.         */
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Expected SERIALIZABLE isolation. Found "
operator|+
name|dbConn
operator|.
name|getTransactionIsolation
argument_list|()
argument_list|)
throw|;
block|}
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
comment|// delete from HIVE_LOCKS first, we always access HIVE_LOCKS before TXNS
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"delete from HIVE_LOCKS where hl_txnid in ("
argument_list|)
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Long
name|id
range|:
name|txnids
control|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|false
expr_stmt|;
else|else
name|buf
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|buf
operator|.
name|toString
argument_list|()
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|//todo: seems like we should do this first and if it misses, don't bother with
comment|//delete from HIVE_LOCKS since it will be rolled back
name|buf
operator|=
operator|new
name|StringBuilder
argument_list|(
literal|"update TXNS set txn_state = '"
operator|+
name|TXN_ABORTED
operator|+
literal|"' where txn_state = '"
operator|+
name|TXN_OPEN
operator|+
literal|"' and txn_id in ("
argument_list|)
expr_stmt|;
name|first
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|Long
name|id
range|:
name|txnids
control|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|false
expr_stmt|;
else|else
name|buf
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_heartbeat
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|" and txn_last_heartbeat< "
argument_list|)
operator|.
name|append
argument_list|(
name|max_heartbeat
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|buf
operator|.
name|toString
argument_list|()
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|updateCnt
operator|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
return|return
name|updateCnt
return|;
block|}
comment|/**    * Isolation Level Notes:    * Run at SERIALIZABLE to make sure no one is adding new locks while we are checking conflicts here.    *     * Ramblings:    * We could perhaps get away with writing to TXN_COMPONENTS + HIVE_LOCKS in 1 txn@RC    * since this is just in Wait state.    * (Then we'd need to ensure that in !wait case we don't rely on rollback and again in case of    * failure, the W locks will timeout if failure does not propagate to client in some way, or it    * will and client will Abort).    * Actually, whether we can do this depends on what happens when you try to get a lock and notice    * a conflicting locks in W mode do we wait in this case?  if so it's a problem because while you    * are checking new locks someone may insert new  W locks that you don't see...    * On the other hand, this attempts to be 'fair', i.e. process locks in order so could we assume    * that additional W locks will have higher IDs????    *    * We can use Select for Update to generate the next LockID.  In fact we can easily do this in a separate txn.    * This avoids contention on NEXT_LOCK_ID.  The rest of the logic will be still need to be done at Serializable, I think,    * but it will not be updating the same row from 2 DB.    *    * Request a lock    * @param dbConn database connection    * @param rqst lock information    * @return information on whether the lock was acquired.    * @throws NoSuchTxnException    * @throws TxnAbortedException    */
specifier|private
name|LockResponse
name|lock
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|LockRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
throws|,
name|SQLException
block|{
comment|// We want to minimize the number of concurrent lock requests being issued.  If we do not we
comment|// get a large number of deadlocks in the database, since this method has to both clean
comment|// timedout locks and insert new locks.  This synchronization barrier will not eliminate all
comment|// deadlocks, and the code is still resilient in the face of a database deadlock.  But it
comment|// will reduce the number.  This could have been done via a lock table command in the
comment|// underlying database, but was not for two reasons.  One, different databases have different
comment|// syntax for lock table, making it harder to use.  Two, that would lock the HIVE_LOCKS table
comment|// and prevent other operations (such as committing transactions, showing locks,
comment|// etc.) that should not interfere with this one.
synchronized|synchronized
init|(
name|lockLock
init|)
block|{
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|long
name|txnid
init|=
name|rqst
operator|.
name|getTxnid
argument_list|()
decl_stmt|;
if|if
condition|(
name|txnid
operator|>
literal|0
condition|)
block|{
comment|// Heartbeat the transaction so we know it is valid and we avoid it timing out while we
comment|// are locking.
name|heartbeatTxn
argument_list|(
name|dbConn
argument_list|,
name|txnid
argument_list|)
expr_stmt|;
block|}
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
comment|/** Get the next lock id.         * This has to be atomic with adding entries to HIVE_LOCK entries (1st add in W state) to prevent a race.         * Suppose ID gen is a separate txn and 2 concurrent lock() methods are running.  1st one generates nl_next=7,         * 2nd nl_next=8.  Then 8 goes first to insert into HIVE_LOCKS and aquires the locks.  Then 7 unblocks,         * and add it's W locks but it won't see locks from 8 since to be 'fair' {@link #checkLock(java.sql.Connection, long)}         * doesn't block on locks acquired later than one it's checking*/
name|String
name|s
init|=
name|addForUpdateClause
argument_list|(
name|dbConn
argument_list|,
literal|"select nl_next from NEXT_LOCK_ID"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly "
operator|+
literal|"initialized, no record found in next_lock_id"
argument_list|)
throw|;
block|}
name|long
name|extLockId
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|s
operator|=
literal|"update NEXT_LOCK_ID set nl_next = "
operator|+
operator|(
name|extLockId
operator|+
literal|1
operator|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|txnid
operator|>
literal|0
condition|)
block|{
comment|// For each component in this lock request,
comment|// add an entry to the txn_components table
comment|// This must be done before HIVE_LOCKS is accessed
comment|//Isolation note:
comment|//the !wait option is not actually used anywhere.  W/o that,
comment|// if we make CompactionTxnHandler.markCleaned() not delete anything above certain txn_id
comment|//then there is not reason why this insert into TXN_COMPONENTS needs to run at Serializable.
comment|//
comment|// Again, w/o the !wait option, insert into HIVE_LOCKS should be OK at READ_COMMITTED as long
comment|//as check lock is at serializable (or any other way to make sure it's exclusive)
for|for
control|(
name|LockComponent
name|lc
range|:
name|rqst
operator|.
name|getComponent
argument_list|()
control|)
block|{
name|String
name|dbName
init|=
name|lc
operator|.
name|getDbname
argument_list|()
decl_stmt|;
name|String
name|tblName
init|=
name|lc
operator|.
name|getTablename
argument_list|()
decl_stmt|;
name|String
name|partName
init|=
name|lc
operator|.
name|getPartitionname
argument_list|()
decl_stmt|;
name|s
operator|=
literal|"insert into TXN_COMPONENTS "
operator|+
literal|"(tc_txnid, tc_database, tc_table, tc_partition) "
operator|+
literal|"values ("
operator|+
name|txnid
operator|+
literal|", '"
operator|+
name|dbName
operator|+
literal|"', "
operator|+
operator|(
name|tblName
operator|==
literal|null
condition|?
literal|"null"
else|:
literal|"'"
operator|+
name|tblName
operator|+
literal|"'"
operator|)
operator|+
literal|", "
operator|+
operator|(
name|partName
operator|==
literal|null
condition|?
literal|"null"
else|:
literal|"'"
operator|+
name|partName
operator|+
literal|"'"
operator|)
operator|+
literal|")"
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|intLockId
init|=
literal|0
decl_stmt|;
for|for
control|(
name|LockComponent
name|lc
range|:
name|rqst
operator|.
name|getComponent
argument_list|()
control|)
block|{
name|intLockId
operator|++
expr_stmt|;
name|String
name|dbName
init|=
name|lc
operator|.
name|getDbname
argument_list|()
decl_stmt|;
name|String
name|tblName
init|=
name|lc
operator|.
name|getTablename
argument_list|()
decl_stmt|;
name|String
name|partName
init|=
name|lc
operator|.
name|getPartitionname
argument_list|()
decl_stmt|;
name|LockType
name|lockType
init|=
name|lc
operator|.
name|getType
argument_list|()
decl_stmt|;
name|char
name|lockChar
init|=
literal|'z'
decl_stmt|;
switch|switch
condition|(
name|lockType
condition|)
block|{
case|case
name|EXCLUSIVE
case|:
name|lockChar
operator|=
name|LOCK_EXCLUSIVE
expr_stmt|;
break|break;
case|case
name|SHARED_READ
case|:
name|lockChar
operator|=
name|LOCK_SHARED
expr_stmt|;
break|break;
case|case
name|SHARED_WRITE
case|:
name|lockChar
operator|=
name|LOCK_SEMI_SHARED
expr_stmt|;
break|break;
block|}
name|long
name|now
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|s
operator|=
literal|"insert into HIVE_LOCKS "
operator|+
literal|" (hl_lock_ext_id, hl_lock_int_id, hl_txnid, hl_db, hl_table, "
operator|+
literal|"hl_partition, hl_lock_state, hl_lock_type, hl_last_heartbeat, hl_user, hl_host)"
operator|+
literal|" values ("
operator|+
name|extLockId
operator|+
literal|", "
operator|+
operator|+
name|intLockId
operator|+
literal|","
operator|+
name|txnid
operator|+
literal|", '"
operator|+
name|dbName
operator|+
literal|"', "
operator|+
operator|(
name|tblName
operator|==
literal|null
condition|?
literal|"null"
else|:
literal|"'"
operator|+
name|tblName
operator|+
literal|"'"
operator|)
operator|+
literal|", "
operator|+
operator|(
name|partName
operator|==
literal|null
condition|?
literal|"null"
else|:
literal|"'"
operator|+
name|partName
operator|+
literal|"'"
operator|)
operator|+
literal|", '"
operator|+
name|LOCK_WAITING
operator|+
literal|"', "
operator|+
literal|"'"
operator|+
name|lockChar
operator|+
literal|"', "
operator|+
comment|//for locks associated with a txn, we always heartbeat txn and timeout based on that
operator|(
name|isValidTxn
argument_list|(
name|txnid
argument_list|)
condition|?
literal|0
else|:
name|now
operator|)
operator|+
literal|", '"
operator|+
name|rqst
operator|.
name|getUser
argument_list|()
operator|+
literal|"', '"
operator|+
name|rqst
operator|.
name|getHostname
argument_list|()
operator|+
literal|"')"
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/**to make txns shorter we could commit here and start a new txn for checkLock.  This would          * require moving checkRetryable() down into here.  Could we then run the part before this          * commit are READ_COMMITTED?*/
return|return
name|checkLock
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchLockException
name|e
parameter_list|)
block|{
comment|// This should never happen, as we just added the lock id
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Couldn't find a lock we just created!"
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
name|boolean
name|isValidTxn
parameter_list|(
name|long
name|txnId
parameter_list|)
block|{
return|return
name|txnId
operator|!=
literal|0
return|;
block|}
comment|/**    * Note: this calls acquire() for (extLockId,intLockId) but extLockId is the same and we either take    * all locks for given extLockId or none.  Would be more efficient to update state on all locks    * at once.  Semantics are the same since this is all part of the same txn@serializable.    *    * Lock acquisition is meant to be fair, so every lock can only block on some lock with smaller    * hl_lock_ext_id by only checking earlier locks.    */
specifier|private
name|LockResponse
name|checkLock
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|extLockId
parameter_list|)
throws|throws
name|NoSuchLockException
throws|,
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
throws|,
name|SQLException
block|{
name|List
argument_list|<
name|LockInfo
argument_list|>
name|locksBeingChecked
init|=
name|getLockInfoFromLockId
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
decl_stmt|;
comment|//being acquired now
name|LockResponse
name|response
init|=
operator|new
name|LockResponse
argument_list|()
decl_stmt|;
name|response
operator|.
name|setLockid
argument_list|(
name|extLockId
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"checkLock(): Setting savepoint. extLockId="
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
argument_list|)
expr_stmt|;
name|Savepoint
name|save
init|=
name|dbConn
operator|.
name|setSavepoint
argument_list|()
decl_stmt|;
name|StringBuilder
name|query
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"select hl_lock_ext_id, "
operator|+
literal|"hl_lock_int_id, hl_db, hl_table, hl_partition, hl_lock_state, "
operator|+
literal|"hl_lock_type, hl_txnid from HIVE_LOCKS where hl_db in ("
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|strings
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|locksBeingChecked
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|LockInfo
name|info
range|:
name|locksBeingChecked
control|)
block|{
name|strings
operator|.
name|add
argument_list|(
name|info
operator|.
name|db
argument_list|)
expr_stmt|;
block|}
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|strings
control|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|false
expr_stmt|;
else|else
name|query
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
name|query
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
comment|// If any of the table requests are null, then I need to pull all the
comment|// table locks for this db.
name|boolean
name|sawNull
init|=
literal|false
decl_stmt|;
name|strings
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|LockInfo
name|info
range|:
name|locksBeingChecked
control|)
block|{
if|if
condition|(
name|info
operator|.
name|table
operator|==
literal|null
condition|)
block|{
name|sawNull
operator|=
literal|true
expr_stmt|;
break|break;
block|}
else|else
block|{
name|strings
operator|.
name|add
argument_list|(
name|info
operator|.
name|table
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|sawNull
condition|)
block|{
name|query
operator|.
name|append
argument_list|(
literal|" and (hl_table is null or hl_table in("
argument_list|)
expr_stmt|;
name|first
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|strings
control|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|false
expr_stmt|;
else|else
name|query
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
name|query
operator|.
name|append
argument_list|(
literal|"))"
argument_list|)
expr_stmt|;
comment|// If any of the partition requests are null, then I need to pull all
comment|// partition locks for this table.
name|sawNull
operator|=
literal|false
expr_stmt|;
name|strings
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|LockInfo
name|info
range|:
name|locksBeingChecked
control|)
block|{
if|if
condition|(
name|info
operator|.
name|partition
operator|==
literal|null
condition|)
block|{
name|sawNull
operator|=
literal|true
expr_stmt|;
break|break;
block|}
else|else
block|{
name|strings
operator|.
name|add
argument_list|(
name|info
operator|.
name|partition
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|sawNull
condition|)
block|{
name|query
operator|.
name|append
argument_list|(
literal|" and (hl_partition is null or hl_partition in("
argument_list|)
expr_stmt|;
name|first
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|strings
control|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|false
expr_stmt|;
else|else
name|query
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
name|query
operator|.
name|append
argument_list|(
literal|"))"
argument_list|)
expr_stmt|;
block|}
block|}
name|query
operator|.
name|append
argument_list|(
literal|" and hl_lock_ext_id<= "
argument_list|)
operator|.
name|append
argument_list|(
name|extLockId
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|query
operator|.
name|toString
argument_list|()
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|query
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|SortedSet
argument_list|<
name|LockInfo
argument_list|>
name|lockSet
init|=
operator|new
name|TreeSet
argument_list|<
name|LockInfo
argument_list|>
argument_list|(
operator|new
name|LockInfoComparator
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|lockSet
operator|.
name|add
argument_list|(
operator|new
name|LockInfo
argument_list|(
name|rs
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Turn the tree set into an array so we can move back and forth easily
comment|// in it.
name|LockInfo
index|[]
name|locks
init|=
name|lockSet
operator|.
name|toArray
argument_list|(
operator|new
name|LockInfo
index|[
name|lockSet
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Locks to check(full): "
argument_list|)
expr_stmt|;
for|for
control|(
name|LockInfo
name|info
range|:
name|locks
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"  "
operator|+
name|info
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|LockInfo
name|info
range|:
name|locksBeingChecked
control|)
block|{
comment|// Find the lock record we're checking
name|int
name|index
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|locks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|locks
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|index
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|// If we didn't find the lock, then it must not be in the table
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"How did we get here, we heartbeated our lock before we started!"
argument_list|)
throw|;
block|}
comment|// If we've found it and it's already been marked acquired,
comment|// then just look at the other locks.
if|if
condition|(
name|locks
index|[
name|index
index|]
operator|.
name|state
operator|==
name|LockState
operator|.
name|ACQUIRED
condition|)
block|{
continue|continue;
block|}
comment|// Look at everything in front of this lock to see if it should block
comment|// it or not.
name|boolean
name|acquired
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|index
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|// Check if we're operating on the same database, if not, move on
if|if
condition|(
operator|!
name|locks
index|[
name|index
index|]
operator|.
name|db
operator|.
name|equals
argument_list|(
name|locks
index|[
name|i
index|]
operator|.
name|db
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// If table is null on either of these, then they are claiming to
comment|// lock the whole database and we need to check it.  Otherwise,
comment|// check if they are operating on the same table, if not, move on.
if|if
condition|(
name|locks
index|[
name|index
index|]
operator|.
name|table
operator|!=
literal|null
operator|&&
name|locks
index|[
name|i
index|]
operator|.
name|table
operator|!=
literal|null
operator|&&
operator|!
name|locks
index|[
name|index
index|]
operator|.
name|table
operator|.
name|equals
argument_list|(
name|locks
index|[
name|i
index|]
operator|.
name|table
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// If partition is null on either of these, then they are claiming to
comment|// lock the whole table and we need to check it.  Otherwise,
comment|// check if they are operating on the same partition, if not, move on.
if|if
condition|(
name|locks
index|[
name|index
index|]
operator|.
name|partition
operator|!=
literal|null
operator|&&
name|locks
index|[
name|i
index|]
operator|.
name|partition
operator|!=
literal|null
operator|&&
operator|!
name|locks
index|[
name|index
index|]
operator|.
name|partition
operator|.
name|equals
argument_list|(
name|locks
index|[
name|i
index|]
operator|.
name|partition
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// We've found something that matches what we're trying to lock,
comment|// so figure out if we can lock it too.
name|LockAction
name|lockAction
init|=
name|jumpTable
operator|.
name|get
argument_list|(
name|locks
index|[
name|index
index|]
operator|.
name|type
argument_list|)
operator|.
name|get
argument_list|(
name|locks
index|[
name|i
index|]
operator|.
name|type
argument_list|)
operator|.
name|get
argument_list|(
name|locks
index|[
name|i
index|]
operator|.
name|state
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"desired Lock: "
operator|+
name|info
operator|+
literal|" checked Lock: "
operator|+
name|locks
index|[
name|i
index|]
operator|+
literal|" action: "
operator|+
name|lockAction
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lockAction
condition|)
block|{
case|case
name|WAIT
case|:
if|if
condition|(
operator|!
name|ignoreConflict
argument_list|(
name|info
argument_list|,
name|locks
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|wait
argument_list|(
name|dbConn
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
name|response
operator|.
name|setState
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Lock("
operator|+
name|info
operator|+
literal|") waiting for Lock("
operator|+
name|locks
index|[
name|i
index|]
operator|+
literal|")"
argument_list|)
expr_stmt|;
return|return
name|response
return|;
block|}
comment|//fall through to ACQUIRE
case|case
name|ACQUIRE
case|:
name|acquire
argument_list|(
name|dbConn
argument_list|,
name|stmt
argument_list|,
name|extLockId
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|acquired
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|KEEP_LOOKING
case|:
continue|continue;
block|}
if|if
condition|(
name|acquired
condition|)
break|break;
comment|// We've acquired this lock component,
comment|// so get out of the loop and look at the next component.
block|}
comment|// If we've arrived here and we have not already acquired, it means there's nothing in the
comment|// way of the lock, so acquire the lock.
if|if
condition|(
operator|!
name|acquired
condition|)
name|acquire
argument_list|(
name|dbConn
argument_list|,
name|stmt
argument_list|,
name|extLockId
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
comment|// We acquired all of the locks, so commit and return acquired.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
name|response
operator|.
name|setState
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
return|return
name|response
return|;
block|}
comment|/**    * the {@link #jumpTable} only deals with LockState/LockType.  In some cases it's not    * sufficient.  For example, an EXCLUSIVE lock on partition should prevent SHARED_READ    * on the table, but there is no reason for EXCLUSIVE on a table to prevent SHARED_READ    * on a database.    */
specifier|private
name|boolean
name|ignoreConflict
parameter_list|(
name|LockInfo
name|desiredLock
parameter_list|,
name|LockInfo
name|existingLock
parameter_list|)
block|{
return|return
operator|(
operator|(
name|desiredLock
operator|.
name|isDbLock
argument_list|()
operator|&&
name|desiredLock
operator|.
name|type
operator|==
name|LockType
operator|.
name|SHARED_READ
operator|&&
name|existingLock
operator|.
name|isTableLock
argument_list|()
operator|&&
name|existingLock
operator|.
name|type
operator|==
name|LockType
operator|.
name|EXCLUSIVE
operator|)
operator|||
operator|(
name|existingLock
operator|.
name|isDbLock
argument_list|()
operator|&&
name|existingLock
operator|.
name|type
operator|==
name|LockType
operator|.
name|SHARED_READ
operator|&&
name|desiredLock
operator|.
name|isTableLock
argument_list|()
operator|&&
name|desiredLock
operator|.
name|type
operator|==
name|LockType
operator|.
name|EXCLUSIVE
operator|)
operator|)
operator|||
comment|//different locks from same txn should not conflict with each other
operator|(
name|desiredLock
operator|.
name|txnId
operator|!=
literal|0
operator|&&
name|desiredLock
operator|.
name|txnId
operator|==
name|existingLock
operator|.
name|txnId
operator|)
operator|||
comment|//txnId=0 means it's a select or IUD which does not write to ACID table, e.g
comment|//insert overwrite table T partition(p=1) select a,b from T and autoCommit=true
operator|(
name|desiredLock
operator|.
name|txnId
operator|==
literal|0
operator|&&
name|desiredLock
operator|.
name|extLockId
operator|==
name|existingLock
operator|.
name|extLockId
operator|)
return|;
block|}
specifier|private
name|void
name|wait
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|Savepoint
name|save
parameter_list|)
throws|throws
name|SQLException
block|{
comment|// Need to rollback because we did a select that acquired locks but we didn't
comment|// actually update anything.  Also, we may have locked some locks as
comment|// acquired that we now want to not acquire.  It's ok to rollback because
comment|// once we see one wait, we're done, we won't look for more.
comment|// Only rollback to savepoint because we want to commit our heartbeat
comment|// changes.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback to savepoint"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|(
name|save
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|acquire
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|Statement
name|stmt
parameter_list|,
name|long
name|extLockId
parameter_list|,
name|LockInfo
name|lockInfo
parameter_list|)
throws|throws
name|SQLException
throws|,
name|NoSuchLockException
throws|,
name|MetaException
block|{
name|long
name|now
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|String
name|s
init|=
literal|"update HIVE_LOCKS set hl_lock_state = '"
operator|+
name|LOCK_ACQUIRED
operator|+
literal|"', "
operator|+
comment|//if lock is part of txn, heartbeat info is in txn record
literal|"hl_last_heartbeat = "
operator|+
operator|(
name|isValidTxn
argument_list|(
name|lockInfo
operator|.
name|txnId
argument_list|)
condition|?
literal|0
else|:
name|now
operator|)
operator|+
literal|", hl_acquired_at = "
operator|+
name|now
operator|+
literal|" where hl_lock_ext_id = "
operator|+
name|extLockId
operator|+
literal|" and hl_lock_int_id = "
operator|+
name|lockInfo
operator|.
name|intLockId
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|NoSuchLockException
argument_list|(
literal|"No such lock: ("
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
operator|+
literal|","
operator|+
operator|+
name|lockInfo
operator|.
name|intLockId
operator|+
literal|") "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|lockInfo
operator|.
name|txnId
argument_list|)
argument_list|)
throw|;
block|}
comment|// We update the database, but we don't commit because there may be other
comment|// locks together with this, and we only want to acquire one if we can
comment|// acquire all.
block|}
comment|/**    * Heartbeats on the lock table.  This commits, so do not enter it with any state.    * Should not be called on a lock that belongs to transaction.    */
specifier|private
name|void
name|heartbeatLock
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|extLockId
parameter_list|)
throws|throws
name|NoSuchLockException
throws|,
name|SQLException
throws|,
name|MetaException
block|{
comment|// If the lock id is 0, then there are no locks in this heartbeat
if|if
condition|(
name|extLockId
operator|==
literal|0
condition|)
return|return;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|long
name|now
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|String
name|s
init|=
literal|"update HIVE_LOCKS set hl_last_heartbeat = "
operator|+
name|now
operator|+
literal|" where hl_lock_ext_id = "
operator|+
name|extLockId
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|NoSuchLockException
argument_list|(
literal|"No such lock: "
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Heartbeats on the txn table.  This commits, so do not enter it with any state
specifier|private
name|void
name|heartbeatTxn
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|txnid
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|SQLException
throws|,
name|MetaException
block|{
comment|// If the txnid is 0, then there are no transactions in this heartbeat
if|if
condition|(
name|txnid
operator|==
literal|0
condition|)
return|return;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|long
name|now
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|String
name|s
init|=
literal|"update TXNS set txn_last_heartbeat = "
operator|+
name|now
operator|+
literal|" where txn_id = "
operator|+
name|txnid
operator|+
literal|" and txn_state = '"
operator|+
name|TXN_OPEN
operator|+
literal|"'"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|<
literal|1
condition|)
block|{
name|ensureValidTxn
argument_list|(
name|dbConn
argument_list|,
name|txnid
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
comment|// This should now throw some useful exception.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Can neither heartbeat txn nor confirm it as invalid."
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|NoSuchTxnException
argument_list|(
literal|"No such txn: "
operator|+
name|txnid
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|ensureValidTxn
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|txnid
parameter_list|,
name|Statement
name|stmt
parameter_list|)
throws|throws
name|SQLException
throws|,
name|NoSuchTxnException
throws|,
name|TxnAbortedException
block|{
comment|// We need to check whether this transaction is valid and open
name|String
name|s
init|=
literal|"select txn_state from TXNS where txn_id = "
operator|+
name|txnid
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
comment|//todo: add LIMIT 1 instead of count - should be more efficient
name|s
operator|=
literal|"select count(*) from COMPLETED_TXN_COMPONENTS where CTC_TXNID = "
operator|+
name|txnid
expr_stmt|;
name|ResultSet
name|rs2
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|boolean
name|alreadyCommitted
init|=
name|rs2
operator|.
name|next
argument_list|()
operator|&&
name|rs2
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
operator|>
literal|0
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
if|if
condition|(
name|alreadyCommitted
condition|)
block|{
comment|//makes the message more informative - helps to find bugs in client code
throw|throw
operator|new
name|NoSuchTxnException
argument_list|(
literal|"Transaction "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
operator|+
literal|" is already committed."
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|NoSuchTxnException
argument_list|(
literal|"No such transaction "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|TXN_ABORTED
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|TxnAbortedException
argument_list|(
literal|"Transaction "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
operator|+
literal|" already aborted"
argument_list|)
throw|;
comment|//todo: add time of abort, which is not currently tracked.  Requires schema change
block|}
block|}
specifier|private
name|Long
name|getTxnIdFromLockId
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|extLockId
parameter_list|)
throws|throws
name|NoSuchLockException
throws|,
name|MetaException
throws|,
name|SQLException
block|{
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select hl_txnid from HIVE_LOCKS where hl_lock_ext_id = "
operator|+
name|extLockId
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|long
name|txnid
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"getTxnIdFromLockId("
operator|+
name|extLockId
operator|+
literal|") Return "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|txnid
return|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
comment|// NEVER call this function without first calling heartbeat(long, long)
specifier|private
name|List
argument_list|<
name|LockInfo
argument_list|>
name|getLockInfoFromLockId
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|extLockId
parameter_list|)
throws|throws
name|NoSuchLockException
throws|,
name|MetaException
throws|,
name|SQLException
block|{
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select hl_lock_ext_id, hl_lock_int_id, hl_db, hl_table, "
operator|+
literal|"hl_partition, hl_lock_state, hl_lock_type, hl_txnid from HIVE_LOCKS where "
operator|+
literal|"hl_lock_ext_id = "
operator|+
name|extLockId
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|boolean
name|sawAtLeastOne
init|=
literal|false
decl_stmt|;
name|List
argument_list|<
name|LockInfo
argument_list|>
name|ourLockInfo
init|=
operator|new
name|ArrayList
argument_list|<
name|LockInfo
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|ourLockInfo
operator|.
name|add
argument_list|(
operator|new
name|LockInfo
argument_list|(
name|rs
argument_list|)
argument_list|)
expr_stmt|;
name|sawAtLeastOne
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sawAtLeastOne
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"This should never happen!  We already "
operator|+
literal|"checked the lock existed but now we can't find it!"
argument_list|)
throw|;
block|}
return|return
name|ourLockInfo
return|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Clean time out locks from the database not associated with a transactions, i.e. locks
comment|// for read-only autoCommit=true statements.  This does a commit,
comment|// and thus should be done before any calls to heartbeat that will leave
comment|// open transactions.
specifier|private
name|void
name|timeOutLocks
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|now
parameter_list|)
block|{
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
comment|// Remove any timed out locks from the table.
name|String
name|s
init|=
literal|"delete from HIVE_LOCKS where hl_last_heartbeat< "
operator|+
operator|(
name|now
operator|-
name|timeout
operator|)
operator|+
literal|" and hl_txnid = 0"
decl_stmt|;
comment|//when txnid is> 0, the lock is
comment|//associated with a txn and is handled by performTimeOuts()
comment|//want to avoid expiring locks for a txn w/o expiring the txn itself
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|deletedLocks
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|deletedLocks
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleted "
operator|+
name|deletedLocks
operator|+
literal|" locks from HIVE_LOCKS due to timeout"
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to purge timedout locks due to: "
operator|+
name|getMessage
argument_list|(
name|ex
argument_list|)
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to purge timedout locks due to: "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Suppose you have a query "select a,b from T" and you want to limit the result set    * to the first 5 rows.  The mechanism to do that differs in different DB.    * Make {@code noSelectsqlQuery} to be "a,b from T" and this method will return the    * appropriately modified row limiting query.    */
specifier|private
name|String
name|addLimitClause
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|int
name|numRows
parameter_list|,
name|String
name|noSelectsqlQuery
parameter_list|)
throws|throws
name|MetaException
block|{
name|DatabaseProduct
name|prod
init|=
name|determineDatabaseProduct
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|prod
condition|)
block|{
case|case
name|DERBY
case|:
comment|//http://db.apache.org/derby/docs/10.7/ref/rrefsqljoffsetfetch.html
return|return
literal|"select "
operator|+
name|noSelectsqlQuery
operator|+
literal|" fetch first "
operator|+
name|numRows
operator|+
literal|" rows only"
return|;
case|case
name|MYSQL
case|:
comment|//http://www.postgresql.org/docs/7.3/static/queries-limit.html
case|case
name|POSTGRES
case|:
comment|//https://dev.mysql.com/doc/refman/5.0/en/select.html
return|return
literal|"select "
operator|+
name|noSelectsqlQuery
operator|+
literal|" limit "
operator|+
name|numRows
return|;
case|case
name|ORACLE
case|:
comment|//newer versions (12c and later) support OFFSET/FETCH
return|return
literal|"select * from (select "
operator|+
name|noSelectsqlQuery
operator|+
literal|") where rownum<= "
operator|+
name|numRows
return|;
case|case
name|SQLSERVER
case|:
comment|//newer versions (2012 and later) support OFFSET/FETCH
comment|//https://msdn.microsoft.com/en-us/library/ms189463.aspx
return|return
literal|"select TOP("
operator|+
name|numRows
operator|+
literal|") "
operator|+
name|noSelectsqlQuery
return|;
default|default:
name|String
name|msg
init|=
literal|"Unrecognized database product name<"
operator|+
name|prod
operator|+
literal|">"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
comment|/**    * Isolation Level Notes    * Plain: RC is OK    * This will find transactions that have timed out and abort them.    * Will also delete locks which are not associated with a transaction and have timed out    * Tries to keep transactions (against metastore db) small to reduce lock contention.    */
specifier|public
name|void
name|performTimeOuts
parameter_list|()
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
comment|//We currently commit after selecting the TXNS to abort.  So whether SERIALIZABLE
comment|//READ_COMMITTED, the effect is the same.  We could use FOR UPDATE on Select from TXNS
comment|//and do the whole performTimeOuts() in a single huge transaction, but the only benefit
comment|//would be to make sure someone cannot heartbeat one of these txns at the same time.
comment|//The attempt to heartbeat would block and fail immediately after it's unblocked.
comment|//With current (RC + multiple txns) implementation it is possible for someone to send
comment|//heartbeat at the very end of the expire interval, and just after the Select from TXNS
comment|//is made, in which case heartbeat will succeed but txn will still be Aborted.
comment|//Solving this corner case is not worth the perf penalty.  The client should heartbeat in a
comment|//timely way.
name|long
name|now
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|timeOutLocks
argument_list|(
name|dbConn
argument_list|,
name|now
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|" txn_id from TXNS where txn_state = '"
operator|+
name|TXN_OPEN
operator|+
literal|"' and txn_last_heartbeat<  "
operator|+
operator|(
name|now
operator|-
name|timeout
operator|)
decl_stmt|;
name|s
operator|=
name|addLimitClause
argument_list|(
name|dbConn
argument_list|,
literal|2500
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
return|return;
comment|//no more timedout txns
block|}
name|List
argument_list|<
name|List
argument_list|<
name|Long
argument_list|>
argument_list|>
name|timedOutTxns
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|currentBatch
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|TIMED_OUT_TXN_ABORT_BATCH_SIZE
argument_list|)
decl_stmt|;
name|timedOutTxns
operator|.
name|add
argument_list|(
name|currentBatch
argument_list|)
expr_stmt|;
do|do
block|{
name|currentBatch
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentBatch
operator|.
name|size
argument_list|()
operator|==
name|TIMED_OUT_TXN_ABORT_BATCH_SIZE
condition|)
block|{
name|currentBatch
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|TIMED_OUT_TXN_ABORT_BATCH_SIZE
argument_list|)
expr_stmt|;
name|timedOutTxns
operator|.
name|add
argument_list|(
name|currentBatch
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
do|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_SERIALIZABLE
argument_list|)
expr_stmt|;
name|int
name|numTxnsAborted
init|=
literal|0
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|Long
argument_list|>
name|batchToAbort
range|:
name|timedOutTxns
control|)
block|{
if|if
condition|(
name|abortTxns
argument_list|(
name|dbConn
argument_list|,
name|batchToAbort
argument_list|,
name|now
operator|-
name|timeout
argument_list|)
operator|==
name|batchToAbort
operator|.
name|size
argument_list|()
condition|)
block|{
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
name|numTxnsAborted
operator|+=
name|batchToAbort
operator|.
name|size
argument_list|()
expr_stmt|;
comment|//todo: add TXNS.COMMENT filed and set it to 'aborted by system due to timeout'
name|LOG
operator|.
name|info
argument_list|(
literal|"Aborted the following transactions due to timeout: "
operator|+
name|batchToAbort
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//could not abort all txns in this batch - this may happen because in parallel with this
comment|//operation there was activity on one of the txns in this batch (commit/abort/heartbeat)
comment|//This is not likely but may happen if client experiences long pause between heartbeats or
comment|//unusually long/extreme pauses between heartbeat() calls and other logic in checkLock(),
comment|//lock(), etc.
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Aborted "
operator|+
name|numTxnsAborted
operator|+
literal|" transactions due to timeout"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Aborting timedout transactions failed due to "
operator|+
name|getMessage
argument_list|(
name|ex
argument_list|)
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MetaException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Aborting timedout transactions failed due to "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
specifier|synchronized
name|void
name|setupJdbcConnectionPool
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|SQLException
block|{
if|if
condition|(
name|connPool
operator|!=
literal|null
condition|)
return|return;
name|String
name|driverUrl
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTORECONNECTURLKEY
argument_list|)
decl_stmt|;
name|String
name|user
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTORE_CONNECTION_USER_NAME
argument_list|)
decl_stmt|;
name|String
name|passwd
decl_stmt|;
try|try
block|{
name|passwd
operator|=
name|ShimLoader
operator|.
name|getHadoopShims
argument_list|()
operator|.
name|getPassword
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTOREPWD
operator|.
name|varname
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|err
parameter_list|)
block|{
throw|throw
operator|new
name|SQLException
argument_list|(
literal|"Error getting metastore password"
argument_list|,
name|err
argument_list|)
throw|;
block|}
name|String
name|connectionPooler
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTORE_CONNECTION_POOLING_TYPE
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
if|if
condition|(
literal|"bonecp"
operator|.
name|equals
argument_list|(
name|connectionPooler
argument_list|)
condition|)
block|{
name|BoneCPConfig
name|config
init|=
operator|new
name|BoneCPConfig
argument_list|()
decl_stmt|;
name|config
operator|.
name|setJdbcUrl
argument_list|(
name|driverUrl
argument_list|)
expr_stmt|;
name|config
operator|.
name|setMaxConnectionsPerPartition
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|config
operator|.
name|setPartitionCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|config
operator|.
name|setUser
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|config
operator|.
name|setPassword
argument_list|(
name|passwd
argument_list|)
expr_stmt|;
name|connPool
operator|=
operator|new
name|BoneCPDataSource
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|doRetryOnConnPool
operator|=
literal|true
expr_stmt|;
comment|// Enable retries to work around BONECP bug.
block|}
elseif|else
if|if
condition|(
literal|"dbcp"
operator|.
name|equals
argument_list|(
name|connectionPooler
argument_list|)
condition|)
block|{
name|ObjectPool
name|objectPool
init|=
operator|new
name|GenericObjectPool
argument_list|()
decl_stmt|;
name|ConnectionFactory
name|connFactory
init|=
operator|new
name|DriverManagerConnectionFactory
argument_list|(
name|driverUrl
argument_list|,
name|user
argument_list|,
name|passwd
argument_list|)
decl_stmt|;
comment|// This doesn't get used, but it's still necessary, see
comment|// http://svn.apache.org/viewvc/commons/proper/dbcp/branches/DBCP_1_4_x_BRANCH/doc/ManualPoolingDataSourceExample.java?view=markup
name|PoolableConnectionFactory
name|poolConnFactory
init|=
operator|new
name|PoolableConnectionFactory
argument_list|(
name|connFactory
argument_list|,
name|objectPool
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|connPool
operator|=
operator|new
name|PoolingDataSource
argument_list|(
name|objectPool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown JDBC connection pooling "
operator|+
name|connectionPooler
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
specifier|synchronized
name|void
name|buildJumpTable
parameter_list|()
block|{
if|if
condition|(
name|jumpTable
operator|!=
literal|null
condition|)
return|return;
name|jumpTable
operator|=
operator|new
name|HashMap
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
argument_list|>
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|// SR: Lock we are trying to acquire is shared read
name|Map
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
name|m
init|=
operator|new
name|HashMap
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|jumpTable
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_READ
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|// SR.SR: Lock we are examining is shared read
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
name|m2
init|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_READ
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// SR.SR.acquired Lock we are examining is acquired;  We can acquire
comment|// because two shared reads can acquire together and there must be
comment|// nothing in front of this one to prevent acquisition.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|ACQUIRE
argument_list|)
expr_stmt|;
comment|// SR.SR.wait Lock we are examining is waiting.  In this case we keep
comment|// looking, as it's possible that something in front is blocking it or
comment|// that the other locker hasn't checked yet and he could lock as well.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|KEEP_LOOKING
argument_list|)
expr_stmt|;
comment|// SR.SW: Lock we are examining is shared write
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_WRITE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// SR.SW.acquired Lock we are examining is acquired;  We can acquire
comment|// because a read can share with a write, and there must be
comment|// nothing in front of this one to prevent acquisition.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|ACQUIRE
argument_list|)
expr_stmt|;
comment|// SR.SW.wait Lock we are examining is waiting.  In this case we keep
comment|// looking, as it's possible that something in front is blocking it or
comment|// that the other locker hasn't checked yet and he could lock as well or
comment|// that something is blocking it that would not block a read.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|KEEP_LOOKING
argument_list|)
expr_stmt|;
comment|// SR.E: Lock we are examining is exclusive
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|EXCLUSIVE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// No matter whether it has acquired or not, we cannot pass an exclusive.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
comment|// SW: Lock we are trying to acquire is shared write
name|m
operator|=
operator|new
name|HashMap
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|jumpTable
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_WRITE
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|// SW.SR: Lock we are examining is shared read
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_READ
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// SW.SR.acquired Lock we are examining is acquired;  We need to keep
comment|// looking, because there may or may not be another shared write in front
comment|// that would block us.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|KEEP_LOOKING
argument_list|)
expr_stmt|;
comment|// SW.SR.wait Lock we are examining is waiting.  In this case we keep
comment|// looking, as it's possible that something in front is blocking it or
comment|// that the other locker hasn't checked yet and he could lock as well.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|KEEP_LOOKING
argument_list|)
expr_stmt|;
comment|// SW.SW: Lock we are examining is shared write
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_WRITE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// Regardless of acquired or waiting, one shared write cannot pass another.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
comment|// SW.E: Lock we are examining is exclusive
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|EXCLUSIVE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// No matter whether it has acquired or not, we cannot pass an exclusive.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
comment|// E: Lock we are trying to acquire is exclusive
name|m
operator|=
operator|new
name|HashMap
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|jumpTable
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|EXCLUSIVE
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|// E.SR: Lock we are examining is shared read
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_READ
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// Exclusives can never pass
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
comment|// E.SW: Lock we are examining is shared write
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_WRITE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// Exclusives can never pass
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
comment|// E.E: Lock we are examining is exclusive
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|EXCLUSIVE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// No matter whether it has acquired or not, we cannot pass an exclusive.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns true if {@code ex} should be retried    */
specifier|private
specifier|static
name|boolean
name|isRetryable
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ex
operator|instanceof
name|SQLException
condition|)
block|{
name|SQLException
name|sqlException
init|=
operator|(
name|SQLException
operator|)
name|ex
decl_stmt|;
if|if
condition|(
literal|"08S01"
operator|.
name|equalsIgnoreCase
argument_list|(
name|sqlException
operator|.
name|getSQLState
argument_list|()
argument_list|)
condition|)
block|{
comment|//in MSSQL this means Communication Link Failure
return|return
literal|true
return|;
block|}
comment|//see https://issues.apache.org/jira/browse/HIVE-9938
block|}
return|return
literal|false
return|;
block|}
specifier|private
specifier|static
name|String
name|getMessage
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
return|return
name|ex
operator|.
name|getMessage
argument_list|()
operator|+
literal|"(SQLState="
operator|+
name|ex
operator|.
name|getSQLState
argument_list|()
operator|+
literal|",ErrorCode="
operator|+
name|ex
operator|.
name|getErrorCode
argument_list|()
operator|+
literal|")"
return|;
block|}
comment|/**    * Returns one of {@link java.sql.Connection#TRANSACTION_SERIALIZABLE} TRANSACTION_READ_COMMITTED, etc.    * Different DBs support different concurrency management options.  This class relies on SELECT ... FOR UPDATE    * functionality.  Where that is not available, SERIALIZABLE isolation is used.    * This method must always agree with {@link #addForUpdateClause(java.sql.Connection, String)}, in that    * if FOR UPDATE is not available, must run operation at SERIALIZABLE.    */
specifier|private
name|int
name|getRequiredIsolationLevel
parameter_list|()
throws|throws
name|MetaException
throws|,
name|SQLException
block|{
if|if
condition|(
name|dbProduct
operator|==
literal|null
condition|)
block|{
name|Connection
name|tmp
init|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
decl_stmt|;
name|determineDatabaseProduct
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|dbProduct
condition|)
block|{
case|case
name|DERBY
case|:
return|return
name|Connection
operator|.
name|TRANSACTION_SERIALIZABLE
return|;
case|case
name|MYSQL
case|:
case|case
name|ORACLE
case|:
case|case
name|POSTGRES
case|:
case|case
name|SQLSERVER
case|:
return|return
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
return|;
default|default:
name|String
name|msg
init|=
literal|"Unrecognized database product name<"
operator|+
name|dbProduct
operator|+
literal|">"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
comment|/**    * Given a {@code selectStatement}, decorated it with FOR UPDATE or semantically equivalent    * construct.  If the DB doesn't support, return original select.  This method must always    * agree with {@link #getRequiredIsolationLevel()}    */
specifier|private
name|String
name|addForUpdateClause
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|String
name|selectStatement
parameter_list|)
throws|throws
name|MetaException
block|{
name|DatabaseProduct
name|prod
init|=
name|determineDatabaseProduct
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|prod
condition|)
block|{
case|case
name|DERBY
case|:
comment|//https://db.apache.org/derby/docs/10.1/ref/rrefsqlj31783.html
comment|//sadly in Derby, FOR UPDATE doesn't meant what it should
return|return
name|selectStatement
return|;
case|case
name|MYSQL
case|:
comment|//http://dev.mysql.com/doc/refman/5.7/en/select.html
case|case
name|ORACLE
case|:
comment|//https://docs.oracle.com/cd/E17952_01/refman-5.6-en/select.html
case|case
name|POSTGRES
case|:
comment|//http://www.postgresql.org/docs/9.0/static/sql-select.html
return|return
name|selectStatement
operator|+
literal|" for update"
return|;
case|case
name|SQLSERVER
case|:
comment|//https://msdn.microsoft.com/en-us/library/ms189499.aspx
comment|//https://msdn.microsoft.com/en-us/library/ms187373.aspx
return|return
name|selectStatement
operator|+
literal|" with(updlock)"
return|;
default|default:
name|String
name|msg
init|=
literal|"Unrecognized database product name<"
operator|+
name|prod
operator|+
literal|">"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
comment|/**    * the caller is expected to retry if this fails    *    * @return    * @throws SQLException    * @throws MetaException    */
specifier|private
name|long
name|generateNewExtLockId
parameter_list|()
throws|throws
name|SQLException
throws|,
name|MetaException
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|getRequiredIsolationLevel
argument_list|()
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
comment|// Get the next lock id.
name|String
name|s
init|=
name|addForUpdateClause
argument_list|(
name|dbConn
argument_list|,
literal|"select nl_next from NEXT_LOCK_ID"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly "
operator|+
literal|"initialized, no record found in next_lock_id"
argument_list|)
throw|;
block|}
name|long
name|extLockId
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|s
operator|=
literal|"update NEXT_LOCK_ID set nl_next = "
operator|+
operator|(
name|extLockId
operator|+
literal|1
operator|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit."
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
name|extLockId
return|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

