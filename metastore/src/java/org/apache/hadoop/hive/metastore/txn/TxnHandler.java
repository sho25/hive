begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|txn
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|jolbox
operator|.
name|bonecp
operator|.
name|BoneCPConfig
import|;
end_import

begin_import
import|import
name|com
operator|.
name|jolbox
operator|.
name|bonecp
operator|.
name|BoneCPDataSource
import|;
end_import

begin_import
import|import
name|com
operator|.
name|zaxxer
operator|.
name|hikari
operator|.
name|HikariConfig
import|;
end_import

begin_import
import|import
name|com
operator|.
name|zaxxer
operator|.
name|hikari
operator|.
name|HikariDataSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|dbcp
operator|.
name|ConnectionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|dbcp
operator|.
name|DriverManagerConnectionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|dbcp
operator|.
name|PoolableConnectionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|NotImplementedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ServerUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|classification
operator|.
name|RetrySemantics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|DatabaseProduct
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|HouseKeeperService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|Warehouse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|dbcp
operator|.
name|PoolingDataSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|pool
operator|.
name|ObjectPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|pool
operator|.
name|impl
operator|.
name|GenericObjectPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|JavaUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|StringableMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConfUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|shims
operator|.
name|ShimLoader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|sql
operator|.
name|DataSource
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Semaphore
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_comment
comment|/**  * A handler to answer transaction related calls that come into the metastore  * server.  *  * Note on log messages:  Please include txnid:X and lockid info using  * {@link org.apache.hadoop.hive.common.JavaUtils#txnIdToString(long)}  * and {@link org.apache.hadoop.hive.common.JavaUtils#lockIdToString(long)} in all messages.  * The txnid:X and lockid:Y matches how Thrift object toString() methods are generated,  * so keeping the format consistent makes grep'ing the logs much easier.  *  * Note on HIVE_LOCKS.hl_last_heartbeat.  * For locks that are part of transaction, we set this 0 (would rather set it to NULL but  * Currently the DB schema has this NOT NULL) and only update/read heartbeat from corresponding  * transaction in TXNS.  *  * In general there can be multiple metastores where this logic can execute, thus the DB is  * used to ensure proper mutexing of operations.  * Select ... For Update (or equivalent: either MsSql with(updlock) or actual Update stmt) is  * used to properly sequence operations.  Most notably:  * 1. various sequence IDs are generated with aid of this mutex  * 2. ensuring that each (Hive) Transaction state is transitioned atomically.  Transaction state  *  includes its actual state (Open, Aborted) as well as it's lock list/component list.  Thus all  *  per transaction ops, either start by update/delete of the relevant TXNS row or do S4U on that row.  *  This allows almost all operations to run at READ_COMMITTED and minimizes DB deadlocks.  * 3. checkLock() - this is mutexted entirely since we must ensure that while we check if some lock  *  can be granted, no other (strictly speaking "earlier") lock can change state.  *  * The exception to his is Derby which doesn't support proper S4U.  Derby is always running embedded  * (this is the only supported configuration for Derby)  * in the same JVM as HiveMetaStoreHandler thus we use JVM wide lock to properly sequnce the operations.  *  * {@link #derbyLock}   * If we ever decide to run remote Derby server, according to  * https://db.apache.org/derby/docs/10.0/manuals/develop/develop78.html all transactions will be  * seriazlied, so that would also work though has not been tested.  *  * General design note:  * It's imperative that any operation on a txn (e.g. commit), ensure (atomically) that this txn is  * still valid and active.  In the code this is usually achieved at the same time the txn record  * is locked for some operation.  *   * Note on retry logic:  * Metastore has retry logic in both {@link org.apache.hadoop.hive.metastore.RetryingMetaStoreClient}  * and {@link org.apache.hadoop.hive.metastore.RetryingHMSHandler}.  The retry logic there is very  * generic and is not aware whether the operations are idempotent or not.  (This is separate from  * retry logic here in TxnHander which can/does retry DB errors intelligently).  The worst case is  * when an op here issues a successful commit against the RDBMS but the calling stack doesn't  * receive the ack and retries.  (If an op fails before commit, it's trivially idempotent)  * Thus the ops here need to be made idempotent as much as possible or  * the metstore call stack should have logic not to retry.  There are {@link RetrySemantics}  * annotations to document the behavior.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|abstract
class|class
name|TxnHandler
implements|implements
name|TxnStore
implements|,
name|TxnStore
operator|.
name|MutexAPI
block|{
specifier|static
specifier|final
specifier|protected
name|char
name|INITIATED_STATE
init|=
literal|'i'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|WORKING_STATE
init|=
literal|'w'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|READY_FOR_CLEANING
init|=
literal|'r'
decl_stmt|;
specifier|static
specifier|final
name|char
name|FAILED_STATE
init|=
literal|'f'
decl_stmt|;
specifier|static
specifier|final
name|char
name|SUCCEEDED_STATE
init|=
literal|'s'
decl_stmt|;
specifier|static
specifier|final
name|char
name|ATTEMPTED_STATE
init|=
literal|'a'
decl_stmt|;
comment|// Compactor types
specifier|static
specifier|final
specifier|protected
name|char
name|MAJOR_TYPE
init|=
literal|'a'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|MINOR_TYPE
init|=
literal|'i'
decl_stmt|;
comment|// Transaction states
specifier|static
specifier|final
specifier|protected
name|char
name|TXN_ABORTED
init|=
literal|'a'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|TXN_OPEN
init|=
literal|'o'
decl_stmt|;
comment|//todo: make these like OperationType and remove above char constatns
enum|enum
name|TxnStatus
block|{
name|OPEN
block|,
name|ABORTED
block|,
name|COMMITTED
block|,
name|UNKNOWN
block|}
comment|// Lock states
specifier|static
specifier|final
specifier|protected
name|char
name|LOCK_ACQUIRED
init|=
literal|'a'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|LOCK_WAITING
init|=
literal|'w'
decl_stmt|;
comment|// Lock types
specifier|static
specifier|final
specifier|protected
name|char
name|LOCK_EXCLUSIVE
init|=
literal|'e'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|LOCK_SHARED
init|=
literal|'r'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|LOCK_SEMI_SHARED
init|=
literal|'w'
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|int
name|ALLOWED_REPEATED_DEADLOCKS
init|=
literal|10
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TxnHandler
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|static
specifier|private
name|DataSource
name|connPool
decl_stmt|;
specifier|static
specifier|private
name|boolean
name|doRetryOnConnPool
init|=
literal|false
decl_stmt|;
specifier|private
enum|enum
name|OpertaionType
block|{
name|SELECT
argument_list|(
literal|'s'
argument_list|)
block|,
name|INSERT
argument_list|(
literal|'i'
argument_list|)
block|,
name|UPDATE
argument_list|(
literal|'u'
argument_list|)
block|,
name|DELETE
argument_list|(
literal|'d'
argument_list|)
block|;
specifier|private
specifier|final
name|char
name|sqlConst
decl_stmt|;
name|OpertaionType
parameter_list|(
name|char
name|sqlConst
parameter_list|)
block|{
name|this
operator|.
name|sqlConst
operator|=
name|sqlConst
expr_stmt|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|Character
operator|.
name|toString
argument_list|(
name|sqlConst
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|OpertaionType
name|fromString
parameter_list|(
name|char
name|sqlConst
parameter_list|)
block|{
switch|switch
condition|(
name|sqlConst
condition|)
block|{
case|case
literal|'s'
case|:
return|return
name|SELECT
return|;
case|case
literal|'i'
case|:
return|return
name|INSERT
return|;
case|case
literal|'u'
case|:
return|return
name|UPDATE
return|;
case|case
literal|'d'
case|:
return|return
name|DELETE
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|quoteChar
argument_list|(
name|sqlConst
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|public
specifier|static
name|OpertaionType
name|fromDataOperationType
parameter_list|(
name|DataOperationType
name|dop
parameter_list|)
block|{
switch|switch
condition|(
name|dop
condition|)
block|{
case|case
name|SELECT
case|:
return|return
name|OpertaionType
operator|.
name|SELECT
return|;
case|case
name|INSERT
case|:
return|return
name|OpertaionType
operator|.
name|INSERT
return|;
case|case
name|UPDATE
case|:
return|return
name|OpertaionType
operator|.
name|UPDATE
return|;
case|case
name|DELETE
case|:
return|return
name|OpertaionType
operator|.
name|DELETE
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unexpected value: "
operator|+
name|dop
argument_list|)
throw|;
block|}
block|}
block|}
comment|// Maximum number of open transactions that's allowed
specifier|private
specifier|static
specifier|volatile
name|int
name|maxOpenTxns
init|=
literal|0
decl_stmt|;
comment|// Current number of open txns
specifier|private
specifier|static
specifier|volatile
name|long
name|numOpenTxns
init|=
literal|0
decl_stmt|;
comment|// Whether number of open transactions reaches the threshold
specifier|private
specifier|static
specifier|volatile
name|boolean
name|tooManyOpenTxns
init|=
literal|false
decl_stmt|;
comment|// The AcidHouseKeeperService for counting open transactions
specifier|private
specifier|static
specifier|volatile
name|HouseKeeperService
name|openTxnsCounter
init|=
literal|null
decl_stmt|;
comment|/**    * Number of consecutive deadlocks we have seen    */
specifier|private
name|int
name|deadlockCnt
decl_stmt|;
specifier|private
name|long
name|deadlockRetryInterval
decl_stmt|;
specifier|protected
name|HiveConf
name|conf
decl_stmt|;
specifier|protected
name|DatabaseProduct
name|dbProduct
decl_stmt|;
specifier|private
name|SQLGenerator
name|sqlGenerator
decl_stmt|;
comment|// (End user) Transaction timeout, in milliseconds.
specifier|private
name|long
name|timeout
decl_stmt|;
specifier|private
name|String
name|identifierQuoteString
decl_stmt|;
comment|// quotes to use for quoting tables, where necessary
specifier|private
name|long
name|retryInterval
decl_stmt|;
specifier|private
name|int
name|retryLimit
decl_stmt|;
specifier|private
name|int
name|retryNum
decl_stmt|;
comment|/**    * Derby specific concurrency control    */
specifier|private
specifier|static
specifier|final
name|ReentrantLock
name|derbyLock
init|=
operator|new
name|ReentrantLock
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|/**    * must be static since even in UT there may be> 1 instance of TxnHandler    * (e.g. via Compactor services)    */
specifier|private
specifier|final
specifier|static
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Semaphore
argument_list|>
name|derbyKey2Lock
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|hostname
init|=
name|ServerUtils
operator|.
name|hostname
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|volatile
name|boolean
name|dumpConfig
init|=
literal|true
decl_stmt|;
comment|// Private methods should never catch SQLException and then throw MetaException.  The public
comment|// methods depend on SQLException coming back so they can detect and handle deadlocks.  Private
comment|// methods should only throw MetaException when they explicitly know there's a logic error and
comment|// they want to throw past the public methods.
comment|//
comment|// All public methods that write to the database have to check for deadlocks when a SQLException
comment|// comes back and handle it if they see one.  This has to be done with the connection pooling
comment|// in mind.  To do this they should call checkRetryable() AFTER rolling back the db transaction,
comment|// and then they should catch RetryException and call themselves recursively. See commitTxn for an example.
specifier|public
name|TxnHandler
parameter_list|()
block|{   }
comment|/**    * This is logically part of c'tor and must be called prior to any other method.    * Not physically part of c'tor due to use of relfection    */
specifier|public
name|void
name|setConf
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|checkQFileTestHack
argument_list|()
expr_stmt|;
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
comment|// Set up the JDBC connection pool
try|try
block|{
name|setupJdbcConnectionPool
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|determineDatabaseProduct
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|sqlGenerator
operator|=
operator|new
name|SQLGenerator
argument_list|(
name|dbProduct
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"Unable to instantiate JDBC connection pooling, "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
name|timeout
operator|=
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_TXN_TIMEOUT
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|buildJumpTable
argument_list|()
expr_stmt|;
name|retryInterval
operator|=
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HMSHANDLERINTERVAL
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|retryLimit
operator|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HMSHANDLERATTEMPTS
argument_list|)
expr_stmt|;
name|deadlockRetryInterval
operator|=
name|retryInterval
operator|/
literal|10
expr_stmt|;
name|maxOpenTxns
operator|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_MAX_OPEN_TXNS
argument_list|)
expr_stmt|;
if|if
condition|(
name|dumpConfig
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|HiveConfUtil
operator|.
name|dumpConfig
argument_list|(
name|conf
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|//only do this once per JVM; useful for support
name|dumpConfig
operator|=
literal|false
expr_stmt|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|ReadOnly
specifier|public
name|GetOpenTxnsInfoResponse
name|getOpenTxnsInfo
parameter_list|()
throws|throws
name|MetaException
block|{
try|try
block|{
comment|// We need to figure out the current transaction number and the list of
comment|// open transactions.  To avoid needing a transaction on the underlying
comment|// database we'll look at the current transaction number first.  If it
comment|// subsequently shows up in the open list that's ok.
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|/**          * This method can run at READ_COMMITTED as long as long as          * {@link #openTxns(org.apache.hadoop.hive.metastore.api.OpenTxnRequest)} is atomic.          * More specifically, as long as advancing TransactionID in NEXT_TXN_ID is atomic with          * adding corresponding entries into TXNS.  The reason is that any txnid below HWM          * is either in TXNS and thus considered open (Open/Aborted) or it's considered Committed.          */
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select ntxn_next - 1 from NEXT_TXN_ID"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly "
operator|+
literal|"initialized, no record found in next_txn_id"
argument_list|)
throw|;
block|}
name|long
name|hwm
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly "
operator|+
literal|"initialized, null record found in next_txn_id"
argument_list|)
throw|;
block|}
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|TxnInfo
argument_list|>
name|txnInfos
init|=
operator|new
name|ArrayList
argument_list|<
name|TxnInfo
argument_list|>
argument_list|()
decl_stmt|;
comment|//need the WHERE clause below to ensure consistent results with READ_COMMITTED
name|s
operator|=
literal|"select txn_id, txn_state, txn_user, txn_host, txn_started, txn_last_heartbeat from "
operator|+
literal|"TXNS where txn_id<= "
operator|+
name|hwm
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|char
name|c
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|TxnState
name|state
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|TXN_ABORTED
case|:
name|state
operator|=
name|TxnState
operator|.
name|ABORTED
expr_stmt|;
break|break;
case|case
name|TXN_OPEN
case|:
name|state
operator|=
name|TxnState
operator|.
name|OPEN
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unexpected transaction state "
operator|+
name|c
operator|+
literal|" found in txns table"
argument_list|)
throw|;
block|}
name|TxnInfo
name|txnInfo
init|=
operator|new
name|TxnInfo
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|,
name|state
argument_list|,
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
argument_list|,
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
argument_list|)
decl_stmt|;
name|txnInfo
operator|.
name|setStartedTime
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|txnInfo
operator|.
name|setLastHeartbeatTime
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|txnInfos
operator|.
name|add
argument_list|(
name|txnInfo
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
operator|new
name|GetOpenTxnsInfoResponse
argument_list|(
name|hwm
argument_list|,
name|txnInfos
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"getOpenTxnsInfo"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database: "
operator|+
name|getMessage
argument_list|(
name|e
argument_list|)
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|getOpenTxnsInfo
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|ReadOnly
specifier|public
name|GetOpenTxnsResponse
name|getOpenTxns
parameter_list|()
throws|throws
name|MetaException
block|{
try|try
block|{
comment|// We need to figure out the current transaction number and the list of
comment|// open transactions.  To avoid needing a transaction on the underlying
comment|// database we'll look at the current transaction number first.  If it
comment|// subsequently shows up in the open list that's ok.
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|/**          * This runs at READ_COMMITTED for exactly the same reason as {@link #getOpenTxnsInfo()} \         */
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select ntxn_next - 1 from NEXT_TXN_ID"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly "
operator|+
literal|"initialized, no record found in next_txn_id"
argument_list|)
throw|;
block|}
name|long
name|hwm
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly "
operator|+
literal|"initialized, null record found in next_txn_id"
argument_list|)
throw|;
block|}
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Long
argument_list|>
name|openList
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
comment|//need the WHERE clause below to ensure consistent results with READ_COMMITTED
name|s
operator|=
literal|"select txn_id, txn_state from TXNS where txn_id<= "
operator|+
name|hwm
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|long
name|minOpenTxn
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|long
name|txnId
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|openList
operator|.
name|add
argument_list|(
name|txnId
argument_list|)
expr_stmt|;
name|char
name|c
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|TXN_OPEN
condition|)
block|{
name|minOpenTxn
operator|=
name|Math
operator|.
name|min
argument_list|(
name|minOpenTxn
argument_list|,
name|txnId
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
name|GetOpenTxnsResponse
name|otr
init|=
operator|new
name|GetOpenTxnsResponse
argument_list|(
name|hwm
argument_list|,
name|openList
argument_list|)
decl_stmt|;
if|if
condition|(
name|minOpenTxn
operator|<
name|Long
operator|.
name|MAX_VALUE
condition|)
block|{
name|otr
operator|.
name|setMin_open_txn
argument_list|(
name|minOpenTxn
argument_list|)
expr_stmt|;
block|}
return|return
name|otr
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"getOpenTxns"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database, "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|getOpenTxns
argument_list|()
return|;
block|}
block|}
specifier|private
specifier|static
name|void
name|startHouseKeeperService
parameter_list|(
name|HiveConf
name|conf
parameter_list|,
name|Class
name|c
parameter_list|)
block|{
try|try
block|{
name|openTxnsCounter
operator|=
operator|(
name|HouseKeeperService
operator|)
name|c
operator|.
name|newInstance
argument_list|()
expr_stmt|;
name|openTxnsCounter
operator|.
name|start
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to start {}"
argument_list|,
name|openTxnsCounter
operator|.
name|getClass
argument_list|()
operator|+
literal|".  The system will not handle {} "
argument_list|,
name|openTxnsCounter
operator|.
name|getServiceDescription
argument_list|()
argument_list|,
literal|".  Root Cause: "
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Retry-by-caller note:    * Worst case, it will leave an open txn which will timeout.    */
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|Idempotent
specifier|public
name|OpenTxnsResponse
name|openTxns
parameter_list|(
name|OpenTxnRequest
name|rqst
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|openTxnsCounter
operator|==
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|TxnHandler
operator|.
name|class
init|)
block|{
try|try
block|{
if|if
condition|(
name|openTxnsCounter
operator|==
literal|null
condition|)
block|{
name|startHouseKeeperService
argument_list|(
name|conf
argument_list|,
name|Class
operator|.
name|forName
argument_list|(
literal|"org.apache.hadoop.hive.ql.txn.AcidOpenTxnsCounterService"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|tooManyOpenTxns
operator|&&
name|numOpenTxns
operator|>=
name|maxOpenTxns
condition|)
block|{
name|tooManyOpenTxns
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|tooManyOpenTxns
condition|)
block|{
if|if
condition|(
name|numOpenTxns
operator|<
name|maxOpenTxns
operator|*
literal|0.9
condition|)
block|{
name|tooManyOpenTxns
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Maximum allowed number of open transactions ("
operator|+
name|maxOpenTxns
operator|+
literal|") has been "
operator|+
literal|"reached. Current number of open transactions: "
operator|+
name|numOpenTxns
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Maximum allowed number of open transactions has been reached. "
operator|+
literal|"See hive.max.open.txns."
argument_list|)
throw|;
block|}
block|}
name|int
name|numTxns
init|=
name|rqst
operator|.
name|getNum_txns
argument_list|()
decl_stmt|;
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lockInternal
argument_list|()
expr_stmt|;
comment|/**          * To make {@link #getOpenTxns()}/{@link #getOpenTxnsInfo()} work correctly, this operation must ensure          * that advancing the counter in NEXT_TXN_ID and adding appropriate entries to TXNS is atomic.          * Also, advancing the counter must work when multiple metastores are running.          * SELECT ... FOR UPDATE is used to prevent          * concurrent DB transactions being rolled back due to Write-Write conflict on NEXT_TXN_ID.          *          * In the current design, there can be several metastore instances running in a given Warehouse.          * This makes ideas like reserving a range of IDs to save trips to DB impossible.  For example,          * a client may go to MS1 and start a transaction with ID 500 to update a particular row.          * Now the same client will start another transaction, except it ends up on MS2 and may get          * transaction ID 400 and update the same row.  Now the merge that happens to materialize the snapshot          * on read will thing the version of the row from transaction ID 500 is the latest one.          *          * Longer term we can consider running Active-Passive MS (at least wrt to ACID operations).  This          * set could support a write-through cache for added performance.          */
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
comment|// Make sure the user has not requested an insane amount of txns.
name|int
name|maxTxns
init|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_TXN_MAX_OPEN_BATCH
argument_list|)
decl_stmt|;
if|if
condition|(
name|numTxns
operator|>
name|maxTxns
condition|)
name|numTxns
operator|=
name|maxTxns
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
name|sqlGenerator
operator|.
name|addForUpdateClause
argument_list|(
literal|"select ntxn_next from NEXT_TXN_ID"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction database not properly "
operator|+
literal|"configured, can't find next transaction id."
argument_list|)
throw|;
block|}
name|long
name|first
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|s
operator|=
literal|"update NEXT_TXN_ID set ntxn_next = "
operator|+
operator|(
name|first
operator|+
name|numTxns
operator|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|long
name|now
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|txnIds
init|=
operator|new
name|ArrayList
argument_list|<
name|Long
argument_list|>
argument_list|(
name|numTxns
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rows
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|long
name|i
init|=
name|first
init|;
name|i
operator|<
name|first
operator|+
name|numTxns
condition|;
name|i
operator|++
control|)
block|{
name|txnIds
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|rows
operator|.
name|add
argument_list|(
name|i
operator|+
literal|","
operator|+
name|quoteChar
argument_list|(
name|TXN_OPEN
argument_list|)
operator|+
literal|","
operator|+
name|now
operator|+
literal|","
operator|+
name|now
operator|+
literal|","
operator|+
name|quoteString
argument_list|(
name|rqst
operator|.
name|getUser
argument_list|()
argument_list|)
operator|+
literal|","
operator|+
name|quoteString
argument_list|(
name|rqst
operator|.
name|getHostname
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|queries
init|=
name|sqlGenerator
operator|.
name|createInsertValuesStmt
argument_list|(
literal|"TXNS (txn_id, txn_state, txn_started, txn_last_heartbeat, txn_user, txn_host)"
argument_list|,
name|rows
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|q
range|:
name|queries
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|q
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|execute
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
operator|new
name|OpenTxnsResponse
argument_list|(
name|txnIds
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"openTxns("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
name|unlockInternal
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|openTxns
argument_list|(
name|rqst
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|Idempotent
specifier|public
name|void
name|abortTxn
parameter_list|(
name|AbortTxnRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|MetaException
throws|,
name|TxnAbortedException
block|{
name|long
name|txnid
init|=
name|rqst
operator|.
name|getTxnid
argument_list|()
decl_stmt|;
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lockInternal
argument_list|()
expr_stmt|;
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|abortTxns
argument_list|(
name|dbConn
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|txnid
argument_list|)
argument_list|,
literal|true
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|TxnStatus
name|status
init|=
name|findTxnState
argument_list|(
name|txnid
argument_list|,
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|TxnStatus
operator|.
name|ABORTED
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"abortTxn("
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
operator|+
literal|") requested by it is already "
operator|+
name|TxnStatus
operator|.
name|ABORTED
argument_list|)
expr_stmt|;
return|return;
block|}
name|raiseTxnUnexpectedState
argument_list|(
name|status
argument_list|,
name|txnid
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"abortTxn("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
literal|null
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
name|unlockInternal
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|abortTxn
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|Idempotent
specifier|public
name|void
name|abortTxns
parameter_list|(
name|AbortTxnsRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|MetaException
block|{
name|List
argument_list|<
name|Long
argument_list|>
name|txnids
init|=
name|rqst
operator|.
name|getTxn_ids
argument_list|()
decl_stmt|;
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|int
name|numAborted
init|=
name|abortTxns
argument_list|(
name|dbConn
argument_list|,
name|txnids
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|numAborted
operator|!=
name|txnids
operator|.
name|size
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Abort Transactions command only aborted "
operator|+
name|numAborted
operator|+
literal|" out of "
operator|+
name|txnids
operator|.
name|size
argument_list|()
operator|+
literal|" transactions. It's possible that the other "
operator|+
operator|(
name|txnids
operator|.
name|size
argument_list|()
operator|-
name|numAborted
operator|)
operator|+
literal|" transactions have been aborted or committed, or the transaction ids are invalid."
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"abortTxns("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|abortTxns
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Concurrency/isolation notes:    * This is mutexed with {@link #openTxns(OpenTxnRequest)} and other {@link #commitTxn(CommitTxnRequest)}    * operations using select4update on NEXT_TXN_ID.  Also, mutexes on TXNX table for specific txnid:X    * see more notes below.    * In order to prevent lost updates, we need to determine if any 2 transactions overlap.  Each txn    * is viewed as an interval [M,N]. M is the txnid and N is taken from the same NEXT_TXN_ID sequence    * so that we can compare commit time of txn T with start time of txn S.  This sequence can be thought of    * as a logical time counter.  If S.commitTime< T.startTime, T and S do NOT overlap.    *    * Motivating example:    * Suppose we have multi-statment transactions T and S both of which are attempting x = x + 1    * In order to prevent lost update problem, the the non-overlapping txns must lock in the snapshot    * that they read appropriately.  In particular, if txns do not overlap, then one follows the other    * (assumig they write the same entity), and thus the 2nd must see changes of the 1st.  We ensure    * this by locking in snapshot after     * {@link #openTxns(OpenTxnRequest)} call is made (see {@link org.apache.hadoop.hive.ql.Driver#acquireLocksAndOpenTxn()})    * and mutexing openTxn() with commit().  In other words, once a S.commit() starts we must ensure    * that txn T which will be considered a later txn, locks in a snapshot that includes the result    * of S's commit (assuming no other txns).    * As a counter example, suppose we have S[3,3] and T[4,4] (commitId=txnid means no other transactions    * were running in parallel).  If T and S both locked in the same snapshot (for example commit of    * txnid:2, which is possible if commitTxn() and openTxnx() is not mutexed)    * 'x' would be updated to the same value by both, i.e. lost update.     */
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|Idempotent
argument_list|(
literal|"No-op if already committed"
argument_list|)
specifier|public
name|void
name|commitTxn
parameter_list|(
name|CommitTxnRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
name|long
name|txnid
init|=
name|rqst
operator|.
name|getTxnid
argument_list|()
decl_stmt|;
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|lockHandle
init|=
literal|null
decl_stmt|;
name|ResultSet
name|commitIdRs
init|=
literal|null
decl_stmt|,
name|rs
decl_stmt|;
try|try
block|{
name|lockInternal
argument_list|()
expr_stmt|;
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
comment|/**          * Runs at READ_COMMITTED with S4U on TXNS row for "txnid".  S4U ensures that no other          * operation can change this txn (such acquiring locks). While lock() and commitTxn()          * should not normally run concurrently (for same txn) but could due to bugs in the client          * which could then corrupt internal transaction manager state.  Also competes with abortTxn().          */
name|lockHandle
operator|=
name|lockTransactionRecord
argument_list|(
name|stmt
argument_list|,
name|txnid
argument_list|,
name|TXN_OPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockHandle
operator|==
literal|null
condition|)
block|{
comment|//if here, txn was not found (in expected state)
name|TxnStatus
name|actualTxnStatus
init|=
name|findTxnState
argument_list|(
name|txnid
argument_list|,
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|actualTxnStatus
operator|==
name|TxnStatus
operator|.
name|COMMITTED
condition|)
block|{
comment|/**              * This makes the operation idempotent              * (assume that this is most likely due to retry logic)              */
name|LOG
operator|.
name|info
argument_list|(
literal|"Nth commitTxn("
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
operator|+
literal|") msg"
argument_list|)
expr_stmt|;
return|return;
block|}
name|raiseTxnUnexpectedState
argument_list|(
name|actualTxnStatus
argument_list|,
name|txnid
argument_list|)
expr_stmt|;
name|shouldNeverHappen
argument_list|(
name|txnid
argument_list|)
expr_stmt|;
comment|//dbConn is rolled back in finally{}
block|}
name|String
name|conflictSQLSuffix
init|=
literal|"from TXN_COMPONENTS where tc_txnid="
operator|+
name|txnid
operator|+
literal|" and tc_operation_type IN("
operator|+
name|quoteChar
argument_list|(
name|OpertaionType
operator|.
name|UPDATE
operator|.
name|sqlConst
argument_list|)
operator|+
literal|","
operator|+
name|quoteChar
argument_list|(
name|OpertaionType
operator|.
name|DELETE
operator|.
name|sqlConst
argument_list|)
operator|+
literal|")"
decl_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|sqlGenerator
operator|.
name|addLimitClause
argument_list|(
literal|1
argument_list|,
literal|"tc_operation_type "
operator|+
name|conflictSQLSuffix
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
comment|//if here it means currently committing txn performed update/delete and we should check WW conflict
comment|/**            * This S4U will mutex with other commitTxn() and openTxns().             * -1 below makes txn intervals look like [3,3] [4,4] if all txns are serial            * Note: it's possible to have several txns have the same commit id.  Suppose 3 txns start            * at the same time and no new txns start until all 3 commit.            * We could've incremented the sequence for commitId is well but it doesn't add anything functionally.            */
name|commitIdRs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|sqlGenerator
operator|.
name|addForUpdateClause
argument_list|(
literal|"select ntxn_next - 1 from NEXT_TXN_ID"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commitIdRs
operator|.
name|next
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"No rows found in NEXT_TXN_ID"
argument_list|)
throw|;
block|}
name|long
name|commitId
init|=
name|commitIdRs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|Savepoint
name|undoWriteSetForCurrentTxn
init|=
name|dbConn
operator|.
name|setSavepoint
argument_list|()
decl_stmt|;
comment|/**            * "select distinct" is used below because            * 1. once we get to multi-statement txns, we only care to record that something was updated once            * 2. if {@link #addDynamicPartitions(AddDynamicPartitions)} is retried by caller it my create            *  duplicate entries in TXN_COMPONENTS            * but we want to add a PK on WRITE_SET which won't have unique rows w/o this distinct            * even if it includes all of it's columns            */
name|int
name|numCompsWritten
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
literal|"insert into WRITE_SET (ws_database, ws_table, ws_partition, ws_txnid, ws_commit_id, ws_operation_type)"
operator|+
literal|" select distinct tc_database, tc_table, tc_partition, tc_txnid, "
operator|+
name|commitId
operator|+
literal|", tc_operation_type "
operator|+
name|conflictSQLSuffix
argument_list|)
decl_stmt|;
comment|/**            * see if there are any overlapping txns wrote the same element, i.e. have a conflict            * Since entire commit operation is mutexed wrt other start/commit ops,            * committed.ws_commit_id<= current.ws_commit_id for all txns            * thus if committed.ws_commit_id< current.ws_txnid, transactions do NOT overlap            * For example, [17,20] is committed, [6,80] is being committed right now - these overlap            * [17,20] committed and [21,21] committing now - these do not overlap.            * [17,18] committed and [18,19] committing now - these overlap  (here 18 started while 17 was still running)            */
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|sqlGenerator
operator|.
name|addLimitClause
argument_list|(
literal|1
argument_list|,
literal|"committed.ws_txnid, committed.ws_commit_id, committed.ws_database,"
operator|+
literal|"committed.ws_table, committed.ws_partition, cur.ws_commit_id cur_ws_commit_id, "
operator|+
literal|"cur.ws_operation_type cur_op, committed.ws_operation_type committed_op "
operator|+
literal|"from WRITE_SET committed INNER JOIN WRITE_SET cur "
operator|+
literal|"ON committed.ws_database=cur.ws_database and committed.ws_table=cur.ws_table "
operator|+
comment|//For partitioned table we always track writes at partition level (never at table)
comment|//and for non partitioned - always at table level, thus the same table should never
comment|//have entries with partition key and w/o
literal|"and (committed.ws_partition=cur.ws_partition or (committed.ws_partition is null and cur.ws_partition is null)) "
operator|+
literal|"where cur.ws_txnid<= committed.ws_commit_id"
operator|+
comment|//txns overlap; could replace ws_txnid
comment|// with txnid, though any decent DB should infer this
literal|" and cur.ws_txnid="
operator|+
name|txnid
operator|+
comment|//make sure RHS of join only has rows we just inserted as
comment|// part of this commitTxn() op
literal|" and committed.ws_txnid<> "
operator|+
name|txnid
operator|+
comment|//and LHS only has committed txns
comment|//U+U and U+D is a conflict but D+D is not and we don't currently track I in WRITE_SET at all
literal|" and (committed.ws_operation_type="
operator|+
name|quoteChar
argument_list|(
name|OpertaionType
operator|.
name|UPDATE
operator|.
name|sqlConst
argument_list|)
operator|+
literal|" OR cur.ws_operation_type="
operator|+
name|quoteChar
argument_list|(
name|OpertaionType
operator|.
name|UPDATE
operator|.
name|sqlConst
argument_list|)
operator|+
literal|")"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
comment|//found a conflict
name|String
name|committedTxn
init|=
literal|"["
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|+
literal|","
operator|+
name|rs
operator|.
name|getLong
argument_list|(
literal|2
argument_list|)
operator|+
literal|"]"
decl_stmt|;
name|StringBuilder
name|resource
init|=
operator|new
name|StringBuilder
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"/"
argument_list|)
operator|.
name|append
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|partitionName
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
name|partitionName
operator|!=
literal|null
condition|)
block|{
name|resource
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
operator|.
name|append
argument_list|(
name|partitionName
argument_list|)
expr_stmt|;
block|}
name|String
name|msg
init|=
literal|"Aborting ["
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
operator|+
literal|","
operator|+
name|rs
operator|.
name|getLong
argument_list|(
literal|6
argument_list|)
operator|+
literal|"]"
operator|+
literal|" due to a write conflict on "
operator|+
name|resource
operator|+
literal|" committed by "
operator|+
name|committedTxn
operator|+
literal|" "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|7
argument_list|)
operator|+
literal|"/"
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
comment|//remove WRITE_SET info for current txn since it's about to abort
name|dbConn
operator|.
name|rollback
argument_list|(
name|undoWriteSetForCurrentTxn
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|msg
argument_list|)
expr_stmt|;
comment|//todo: should make abortTxns() write something into TXNS.TXN_META_INFO about this
if|if
condition|(
name|abortTxns
argument_list|(
name|dbConn
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|txnid
argument_list|)
argument_list|,
literal|true
argument_list|)
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|msg
operator|+
literal|" FAILED!"
argument_list|)
throw|;
block|}
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
name|close
argument_list|(
literal|null
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|TxnAbortedException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
else|else
block|{
comment|//no conflicting operations, proceed with the rest of commit sequence
block|}
block|}
else|else
block|{
comment|/**            * current txn didn't update/delete anything (may have inserted), so just proceed with commit            *            * We only care about commit id for write txns, so for RO (when supported) txns we don't            * have to mutex on NEXT_TXN_ID.            * Consider: if RO txn is after a W txn, then RO's openTxns() will be mutexed with W's            * commitTxn() because both do S4U on NEXT_TXN_ID and thus RO will see result of W txn.            * If RO< W, then there is no reads-from relationship.            */
block|}
comment|// Move the record from txn_components into completed_txn_components so that the compactor
comment|// knows where to look to compact.
name|String
name|s
init|=
literal|"insert into COMPLETED_TXN_COMPONENTS select tc_txnid, tc_database, tc_table, "
operator|+
literal|"tc_partition from TXN_COMPONENTS where tc_txnid = "
operator|+
name|txnid
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute insert<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|modCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|modCount
operator|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
operator|)
operator|<
literal|1
condition|)
block|{
comment|//this can be reasonable for an empty txn START/COMMIT or read-only txn
comment|//also an IUD with DP that didn't match any rows.
name|LOG
operator|.
name|info
argument_list|(
literal|"Expected to move at least one record from txn_components to "
operator|+
literal|"completed_txn_components when committing txn! "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
literal|"delete from TXN_COMPONENTS where tc_txnid = "
operator|+
name|txnid
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|modCount
operator|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
literal|"delete from HIVE_LOCKS where hl_txnid = "
operator|+
name|txnid
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|modCount
operator|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
literal|"delete from TXNS where txn_id = "
operator|+
name|txnid
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|modCount
operator|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"commitTxn("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|commitIdRs
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|lockHandle
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
name|unlockInternal
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|commitTxn
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|SafeToRetry
specifier|public
name|void
name|performWriteSetGC
parameter_list|()
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
literal|"select ntxn_next - 1 from NEXT_TXN_ID"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"NEXT_TXN_ID is empty: DB is corrupted"
argument_list|)
throw|;
block|}
name|long
name|highestAllocatedTxnId
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
literal|"select min(txn_id) from TXNS where txn_state="
operator|+
name|quoteChar
argument_list|(
name|TXN_OPEN
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Scalar query returned no rows?!?!!"
argument_list|)
throw|;
block|}
name|long
name|commitHighWaterMark
decl_stmt|;
comment|//all currently open txns (if any) have txnid>= than commitHighWaterMark
name|long
name|lowestOpenTxnId
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
block|{
comment|//if here then there are no Open txns and  highestAllocatedTxnId must be
comment|//resolved (i.e. committed or aborted), either way
comment|//there are no open txns with id<= highestAllocatedTxnId
comment|//the +1 is there because "delete ..." below has< (which is correct for the case when
comment|//there is an open txn
comment|//Concurrency: even if new txn starts (or starts + commits) it is still true that
comment|//there are no currently open txns that overlap with any committed txn with
comment|//commitId<= commitHighWaterMark (as set on next line).  So plain READ_COMMITTED is enough.
name|commitHighWaterMark
operator|=
name|highestAllocatedTxnId
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|commitHighWaterMark
operator|=
name|lowestOpenTxnId
expr_stmt|;
block|}
name|int
name|delCnt
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
literal|"delete from WRITE_SET where ws_commit_id< "
operator|+
name|commitHighWaterMark
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleted "
operator|+
name|delCnt
operator|+
literal|" obsolete rows from WRTIE_SET"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"WriteSet GC failed due to "
operator|+
name|getMessage
argument_list|(
name|ex
argument_list|)
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * As much as possible (i.e. in absence of retries) we want both operations to be done on the same    * connection (but separate transactions).  This avoid some flakiness in BONECP where if you    * perform an operation on 1 connection and immediately get another fron the pool, the 2nd one    * doesn't see results of the first.    *     * Retry-by-caller note: If the call to lock is from a transaction, then in the worst case    * there will be a duplicate set of locks but both sets will belong to the same txn so they     * will not conflict with each other.  For locks w/o txn context (i.e. read-only query), this    * may lead to deadlock (at least a long wait).  (e.g. 1st call creates locks in {@code LOCK_WAITING}    * mode and response gets lost.  Then {@link org.apache.hadoop.hive.metastore.RetryingMetaStoreClient}    * retries, and enqueues another set of locks in LOCK_WAITING.  The 2nd LockResponse is delivered    * to the DbLockManager, which will keep dong {@link #checkLock(CheckLockRequest)} until the 1st    * set of locks times out.    */
annotation|@
name|RetrySemantics
operator|.
name|CannotRetry
specifier|public
name|LockResponse
name|lock
parameter_list|(
name|LockRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
name|ConnectionLockIdPair
name|connAndLockId
init|=
name|enqueueLockWithRetry
argument_list|(
name|rqst
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|checkLockWithRetry
argument_list|(
name|connAndLockId
operator|.
name|dbConn
argument_list|,
name|connAndLockId
operator|.
name|extLockId
argument_list|,
name|rqst
operator|.
name|getTxnid
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchLockException
name|e
parameter_list|)
block|{
comment|// This should never happen, as we just added the lock id
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Couldn't find a lock we just created! "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
specifier|final
class|class
name|ConnectionLockIdPair
block|{
specifier|private
specifier|final
name|Connection
name|dbConn
decl_stmt|;
specifier|private
specifier|final
name|long
name|extLockId
decl_stmt|;
specifier|private
name|ConnectionLockIdPair
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|extLockId
parameter_list|)
block|{
name|this
operator|.
name|dbConn
operator|=
name|dbConn
expr_stmt|;
name|this
operator|.
name|extLockId
operator|=
name|extLockId
expr_stmt|;
block|}
block|}
comment|/**    * Note that by definition select for update is divorced from update, i.e. you executeQuery() to read    * and then executeUpdate().  One other alternative would be to actually update the row in TXNS but    * to the same value as before thus forcing db to acquire write lock for duration of the transaction.    *    * There is no real reason to return the ResultSet here other than to make sure the reference to it    * is retained for duration of intended lock scope and is not GC'd thus (unlikely) causing lock    * to be released.    * @param txnState the state this txn is expected to be in.  may be null    * @return null if no row was found    * @throws SQLException    * @throws MetaException    */
specifier|private
name|ResultSet
name|lockTransactionRecord
parameter_list|(
name|Statement
name|stmt
parameter_list|,
name|long
name|txnId
parameter_list|,
name|Character
name|txnState
parameter_list|)
throws|throws
name|SQLException
throws|,
name|MetaException
block|{
name|String
name|query
init|=
literal|"select TXN_STATE from TXNS where TXN_ID = "
operator|+
name|txnId
operator|+
operator|(
name|txnState
operator|!=
literal|null
condition|?
literal|" AND TXN_STATE="
operator|+
name|quoteChar
argument_list|(
name|txnState
argument_list|)
else|:
literal|""
operator|)
decl_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|sqlGenerator
operator|.
name|addForUpdateClause
argument_list|(
name|query
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
return|return
name|rs
return|;
block|}
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/**    * This enters locks into the queue in {@link #LOCK_WAITING} mode.    *    * Isolation Level Notes:    * 1. We use S4U (withe read_committed) to generate the next (ext) lock id.  This serializes    * any 2 {@code enqueueLockWithRetry()} calls.    * 2. We use S4U on the relevant TXNS row to block any concurrent abort/commit/etc operations    * @see #checkLockWithRetry(Connection, long, long)    */
specifier|private
name|ConnectionLockIdPair
name|enqueueLockWithRetry
parameter_list|(
name|LockRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
name|ResultSet
name|lockHandle
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lockInternal
argument_list|()
expr_stmt|;
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|long
name|txnid
init|=
name|rqst
operator|.
name|getTxnid
argument_list|()
decl_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
if|if
condition|(
name|isValidTxn
argument_list|(
name|txnid
argument_list|)
condition|)
block|{
comment|//this also ensures that txn is still there in expected state
name|lockHandle
operator|=
name|lockTransactionRecord
argument_list|(
name|stmt
argument_list|,
name|txnid
argument_list|,
name|TXN_OPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockHandle
operator|==
literal|null
condition|)
block|{
name|ensureValidTxn
argument_list|(
name|dbConn
argument_list|,
name|txnid
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|shouldNeverHappen
argument_list|(
name|txnid
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Get the next lock id.          * This has to be atomic with adding entries to HIVE_LOCK entries (1st add in W state) to prevent a race.          * Suppose ID gen is a separate txn and 2 concurrent lock() methods are running.  1st one generates nl_next=7,          * 2nd nl_next=8.  Then 8 goes first to insert into HIVE_LOCKS and acquires the locks.  Then 7 unblocks,          * and add it's W locks but it won't see locks from 8 since to be 'fair' {@link #checkLock(java.sql.Connection, long)}          * doesn't block on locks acquired later than one it's checking*/
name|String
name|s
init|=
name|sqlGenerator
operator|.
name|addForUpdateClause
argument_list|(
literal|"select nl_next from NEXT_LOCK_ID"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly "
operator|+
literal|"initialized, no record found in next_lock_id"
argument_list|)
throw|;
block|}
name|long
name|extLockId
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|s
operator|=
literal|"update NEXT_LOCK_ID set nl_next = "
operator|+
operator|(
name|extLockId
operator|+
literal|1
operator|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|txnid
operator|>
literal|0
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|rows
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// For each component in this lock request,
comment|// add an entry to the txn_components table
for|for
control|(
name|LockComponent
name|lc
range|:
name|rqst
operator|.
name|getComponent
argument_list|()
control|)
block|{
if|if
condition|(
name|lc
operator|.
name|isSetIsAcid
argument_list|()
operator|&&
operator|!
name|lc
operator|.
name|isIsAcid
argument_list|()
condition|)
block|{
comment|//we don't prevent using non-acid resources in a txn but we do lock them
continue|continue;
block|}
name|boolean
name|updateTxnComponents
decl_stmt|;
if|if
condition|(
operator|!
name|lc
operator|.
name|isSetOperationType
argument_list|()
condition|)
block|{
comment|//request came from old version of the client
name|updateTxnComponents
operator|=
literal|true
expr_stmt|;
comment|//this matches old behavior
block|}
else|else
block|{
switch|switch
condition|(
name|lc
operator|.
name|getOperationType
argument_list|()
condition|)
block|{
case|case
name|INSERT
case|:
case|case
name|UPDATE
case|:
case|case
name|DELETE
case|:
if|if
condition|(
operator|!
name|lc
operator|.
name|isSetIsDynamicPartitionWrite
argument_list|()
condition|)
block|{
comment|//must be old client talking, i.e. we don't know if it's DP so be conservative
name|updateTxnComponents
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|/**                      * we know this is part of DP operation and so we'll get                      * {@link #addDynamicPartitions(AddDynamicPartitions)} call with the list                      * of partitions actually chaged.                      */
name|updateTxnComponents
operator|=
operator|!
name|lc
operator|.
name|isIsDynamicPartitionWrite
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|SELECT
case|:
name|updateTxnComponents
operator|=
literal|false
expr_stmt|;
break|break;
default|default:
comment|//since we have an open transaction, only 4 values above are expected
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unexpected DataOperationType: "
operator|+
name|lc
operator|.
name|getOperationType
argument_list|()
operator|+
literal|" agentInfo="
operator|+
name|rqst
operator|.
name|getAgentInfo
argument_list|()
operator|+
literal|" "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|updateTxnComponents
condition|)
block|{
continue|continue;
block|}
name|String
name|dbName
init|=
name|lc
operator|.
name|getDbname
argument_list|()
decl_stmt|;
name|String
name|tblName
init|=
name|lc
operator|.
name|getTablename
argument_list|()
decl_stmt|;
name|String
name|partName
init|=
name|lc
operator|.
name|getPartitionname
argument_list|()
decl_stmt|;
name|rows
operator|.
name|add
argument_list|(
name|txnid
operator|+
literal|", '"
operator|+
name|dbName
operator|+
literal|"', "
operator|+
operator|(
name|tblName
operator|==
literal|null
condition|?
literal|"null"
else|:
literal|"'"
operator|+
name|tblName
operator|+
literal|"'"
operator|)
operator|+
literal|", "
operator|+
operator|(
name|partName
operator|==
literal|null
condition|?
literal|"null"
else|:
literal|"'"
operator|+
name|partName
operator|+
literal|"'"
operator|)
operator|+
literal|","
operator|+
name|quoteString
argument_list|(
name|OpertaionType
operator|.
name|fromDataOperationType
argument_list|(
name|lc
operator|.
name|getOperationType
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|queries
init|=
name|sqlGenerator
operator|.
name|createInsertValuesStmt
argument_list|(
literal|"TXN_COMPONENTS (tc_txnid, tc_database, tc_table, tc_partition, tc_operation_type)"
argument_list|,
name|rows
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|query
range|:
name|queries
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|query
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|modCount
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|query
argument_list|)
decl_stmt|;
block|}
block|}
name|List
argument_list|<
name|String
argument_list|>
name|rows
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|long
name|intLockId
init|=
literal|0
decl_stmt|;
for|for
control|(
name|LockComponent
name|lc
range|:
name|rqst
operator|.
name|getComponent
argument_list|()
control|)
block|{
if|if
condition|(
name|lc
operator|.
name|isSetOperationType
argument_list|()
operator|&&
name|lc
operator|.
name|getOperationType
argument_list|()
operator|==
name|DataOperationType
operator|.
name|UNSET
operator|&&
operator|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_IN_TEST
argument_list|)
operator|||
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_IN_TEZ_TEST
argument_list|)
operator|)
condition|)
block|{
comment|//old version of thrift client should have (lc.isSetOperationType() == false) but they do not
comment|//If you add a default value to a variable, isSet() for that variable is true regardless of the where the
comment|//message was created (for object variables.  It works correctly for boolean vars, e.g. LockComponent.isAcid).
comment|//in test mode, upgrades are not tested, so client version and server version of thrift always matches so
comment|//we see UNSET here it means something didn't set the appropriate value.
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Bug: operationType="
operator|+
name|lc
operator|.
name|getOperationType
argument_list|()
operator|+
literal|" for component "
operator|+
name|lc
operator|+
literal|" agentInfo="
operator|+
name|rqst
operator|.
name|getAgentInfo
argument_list|()
argument_list|)
throw|;
block|}
name|intLockId
operator|++
expr_stmt|;
name|String
name|dbName
init|=
name|lc
operator|.
name|getDbname
argument_list|()
decl_stmt|;
name|String
name|tblName
init|=
name|lc
operator|.
name|getTablename
argument_list|()
decl_stmt|;
name|String
name|partName
init|=
name|lc
operator|.
name|getPartitionname
argument_list|()
decl_stmt|;
name|LockType
name|lockType
init|=
name|lc
operator|.
name|getType
argument_list|()
decl_stmt|;
name|char
name|lockChar
init|=
literal|'z'
decl_stmt|;
switch|switch
condition|(
name|lockType
condition|)
block|{
case|case
name|EXCLUSIVE
case|:
name|lockChar
operator|=
name|LOCK_EXCLUSIVE
expr_stmt|;
break|break;
case|case
name|SHARED_READ
case|:
name|lockChar
operator|=
name|LOCK_SHARED
expr_stmt|;
break|break;
case|case
name|SHARED_WRITE
case|:
name|lockChar
operator|=
name|LOCK_SEMI_SHARED
expr_stmt|;
break|break;
block|}
name|long
name|now
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|rows
operator|.
name|add
argument_list|(
name|extLockId
operator|+
literal|", "
operator|+
name|intLockId
operator|+
literal|","
operator|+
name|txnid
operator|+
literal|", "
operator|+
name|quoteString
argument_list|(
name|dbName
argument_list|)
operator|+
literal|", "
operator|+
name|valueOrNullLiteral
argument_list|(
name|tblName
argument_list|)
operator|+
literal|", "
operator|+
name|valueOrNullLiteral
argument_list|(
name|partName
argument_list|)
operator|+
literal|", "
operator|+
name|quoteChar
argument_list|(
name|LOCK_WAITING
argument_list|)
operator|+
literal|", "
operator|+
name|quoteChar
argument_list|(
name|lockChar
argument_list|)
operator|+
literal|", "
operator|+
comment|//for locks associated with a txn, we always heartbeat txn and timeout based on that
operator|(
name|isValidTxn
argument_list|(
name|txnid
argument_list|)
condition|?
literal|0
else|:
name|now
operator|)
operator|+
literal|", "
operator|+
name|valueOrNullLiteral
argument_list|(
name|rqst
operator|.
name|getUser
argument_list|()
argument_list|)
operator|+
literal|", "
operator|+
name|valueOrNullLiteral
argument_list|(
name|rqst
operator|.
name|getHostname
argument_list|()
argument_list|)
operator|+
literal|", "
operator|+
name|valueOrNullLiteral
argument_list|(
name|rqst
operator|.
name|getAgentInfo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// + ")";
block|}
name|List
argument_list|<
name|String
argument_list|>
name|queries
init|=
name|sqlGenerator
operator|.
name|createInsertValuesStmt
argument_list|(
literal|"HIVE_LOCKS (hl_lock_ext_id, hl_lock_int_id, hl_txnid, hl_db, "
operator|+
literal|"hl_table, hl_partition,hl_lock_state, hl_lock_type, "
operator|+
literal|"hl_last_heartbeat, hl_user, hl_host, hl_agent_info)"
argument_list|,
name|rows
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|query
range|:
name|queries
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|query
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|modCount
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|query
argument_list|)
decl_stmt|;
block|}
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
return|return
operator|new
name|ConnectionLockIdPair
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"enqueueLockWithRetry("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|lockHandle
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|/* This needs to return a "live" connection to be used by operation that follows it.           Thus it only closes Connection on failure/retry. */
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
name|unlockInternal
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|enqueueLockWithRetry
argument_list|(
name|rqst
argument_list|)
return|;
block|}
block|}
specifier|private
name|LockResponse
name|checkLockWithRetry
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|extLockId
parameter_list|,
name|long
name|txnId
parameter_list|)
throws|throws
name|NoSuchLockException
throws|,
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
try|try
block|{
try|try
block|{
name|lockInternal
argument_list|()
expr_stmt|;
if|if
condition|(
name|dbConn
operator|.
name|isClosed
argument_list|()
condition|)
block|{
comment|//should only get here if retrying this op
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
block|}
return|return
name|checkLock
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"checkLockWithRetry("
operator|+
name|extLockId
operator|+
literal|","
operator|+
name|txnId
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|unlockInternal
argument_list|()
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|checkLockWithRetry
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|,
name|txnId
argument_list|)
return|;
block|}
block|}
comment|/**    * Why doesn't this get a txnid as parameter?  The caller should either know the txnid or know there isn't one.    * Either way getTxnIdFromLockId() will not be needed.  This would be a Thrift change.    *    * Also, when lock acquisition returns WAITING, it's retried every 15 seconds (best case, see DbLockManager.backoff(),    * in practice more often)    * which means this is heartbeating way more often than hive.txn.timeout and creating extra load on DB.    *    * The clients that operate in blocking mode, can't heartbeat a lock until the lock is acquired.    * We should make CheckLockRequest include timestamp or last request to skip unnecessary heartbeats. Thrift change.    *    * {@link #checkLock(java.sql.Connection, long)}  must run at SERIALIZABLE (make sure some lock we are checking    * against doesn't move from W to A in another txn) but this method can heartbeat in    * separate txn at READ_COMMITTED.    *     * Retry-by-caller note:    * Retryable because {@link #checkLock(Connection, long)} is    */
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|SafeToRetry
specifier|public
name|LockResponse
name|checkLock
parameter_list|(
name|CheckLockRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|NoSuchLockException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|long
name|extLockId
init|=
name|rqst
operator|.
name|getLockid
argument_list|()
decl_stmt|;
try|try
block|{
name|lockInternal
argument_list|()
expr_stmt|;
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
comment|// Heartbeat on the lockid first, to assure that our lock is still valid.
comment|// Then look up the lock info (hopefully in the cache).  If these locks
comment|// are associated with a transaction then heartbeat on that as well.
name|LockInfo
name|info
init|=
name|getTxnIdFromLockId
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchLockException
argument_list|(
literal|"No such lock "
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|info
operator|.
name|txnId
operator|>
literal|0
condition|)
block|{
name|heartbeatTxn
argument_list|(
name|dbConn
argument_list|,
name|info
operator|.
name|txnId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|heartbeatLock
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
expr_stmt|;
block|}
comment|//todo: strictly speaking there is a bug here.  heartbeat*() commits but both heartbeat and
comment|//checkLock() are in the same retry block, so if checkLock() throws, heartbeat is also retired
comment|//extra heartbeat is logically harmless, but ...
return|return
name|checkLock
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"checkLock("
operator|+
name|rqst
operator|+
literal|" )"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
operator|+
literal|" "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|unlockInternal
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|checkLock
argument_list|(
name|rqst
argument_list|)
return|;
block|}
block|}
comment|/**    * This would have been made simpler if all locks were associated with a txn.  Then only txn needs to    * be heartbeated, committed, etc.  no need for client to track individual locks.    * When removing locks not associated with txn this potentially conflicts with    * heartbeat/performTimeout which are update/delete of HIVE_LOCKS thus will be locked as needed by db.    * since this only removes from HIVE_LOCKS at worst some lock acquire is delayed    */
annotation|@
name|RetrySemantics
operator|.
name|Idempotent
specifier|public
name|void
name|unlock
parameter_list|(
name|UnlockRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchLockException
throws|,
name|TxnOpenException
throws|,
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|long
name|extLockId
init|=
name|rqst
operator|.
name|getLockid
argument_list|()
decl_stmt|;
try|try
block|{
comment|/**          * This method is logically like commit for read-only auto commit queries.          * READ_COMMITTED since this only has 1 delete statement and no new entries with the          * same hl_lock_ext_id can be added, i.e. all rows with a given hl_lock_ext_id are          * created in a single atomic operation.          * Theoretically, this competes with {@link #lock(org.apache.hadoop.hive.metastore.api.LockRequest)}          * but hl_lock_ext_id is not known until that method returns.          * Also competes with {@link #checkLock(org.apache.hadoop.hive.metastore.api.CheckLockRequest)}          * but using SERIALIZABLE doesn't materially change the interaction.          * If "delete" stmt misses, additional logic is best effort to produce meaningful error msg.          */
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
comment|//hl_txnid<> 0 means it's associated with a transaction
name|String
name|s
init|=
literal|"delete from HIVE_LOCKS where hl_lock_ext_id = "
operator|+
name|extLockId
operator|+
literal|" AND (hl_txnid = 0 OR"
operator|+
literal|" (hl_txnid<> 0 AND hl_lock_state = '"
operator|+
name|LOCK_WAITING
operator|+
literal|"'))"
decl_stmt|;
comment|//(hl_txnid<> 0 AND hl_lock_state = '" + LOCK_WAITING + "') is for multi-statement txns where
comment|//some query attempted to lock (thus LOCK_WAITING state) but is giving up due to timeout for example
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
name|LockInfo
name|info
init|=
name|getTxnIdFromLockId
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
comment|//didn't find any lock with extLockId but at ReadCommitted there is a possibility that
comment|//it existed when above delete ran but it didn't have the expected state.
name|LOG
operator|.
name|info
argument_list|(
literal|"No lock in "
operator|+
name|LOCK_WAITING
operator|+
literal|" mode found for unlock("
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|rqst
operator|.
name|getLockid
argument_list|()
argument_list|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|//bail here to make the operation idempotent
return|return;
block|}
if|if
condition|(
name|info
operator|.
name|txnId
operator|!=
literal|0
condition|)
block|{
name|String
name|msg
init|=
literal|"Unlocking locks associated with transaction not permitted.  "
operator|+
name|info
decl_stmt|;
comment|//if a lock is associated with a txn we can only "unlock" if if it's in WAITING state
comment|// which really means that the caller wants to give up waiting for the lock
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|TxnOpenException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
if|if
condition|(
name|info
operator|.
name|txnId
operator|==
literal|0
condition|)
block|{
comment|//we didn't see this lock when running DELETE stmt above but now it showed up
comment|//so should "should never happen" happened...
name|String
name|msg
init|=
literal|"Found lock in unexpected state "
operator|+
name|info
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"unlock("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
operator|+
literal|" "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|unlock
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * used to sort entries in {@link org.apache.hadoop.hive.metastore.api.ShowLocksResponse}    */
specifier|private
specifier|static
class|class
name|LockInfoExt
extends|extends
name|LockInfo
block|{
specifier|private
specifier|final
name|ShowLocksResponseElement
name|e
decl_stmt|;
name|LockInfoExt
parameter_list|(
name|ShowLocksResponseElement
name|e
parameter_list|)
block|{
name|super
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|this
operator|.
name|e
operator|=
name|e
expr_stmt|;
block|}
block|}
annotation|@
name|RetrySemantics
operator|.
name|ReadOnly
specifier|public
name|ShowLocksResponse
name|showLocks
parameter_list|(
name|ShowLocksRequest
name|rqst
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|ShowLocksResponse
name|rsp
init|=
operator|new
name|ShowLocksResponse
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ShowLocksResponseElement
argument_list|>
name|elems
init|=
operator|new
name|ArrayList
argument_list|<
name|ShowLocksResponseElement
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|LockInfoExt
argument_list|>
name|sortedList
init|=
operator|new
name|ArrayList
argument_list|<
name|LockInfoExt
argument_list|>
argument_list|()
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select hl_lock_ext_id, hl_txnid, hl_db, hl_table, hl_partition, hl_lock_state, "
operator|+
literal|"hl_lock_type, hl_last_heartbeat, hl_acquired_at, hl_user, hl_host, hl_lock_int_id,"
operator|+
literal|"hl_blockedby_ext_id, hl_blockedby_int_id, hl_agent_info from HIVE_LOCKS"
decl_stmt|;
comment|// Some filters may have been specified in the SHOW LOCKS statement. Add them to the query.
name|String
name|dbName
init|=
name|rqst
operator|.
name|getDbname
argument_list|()
decl_stmt|;
name|String
name|tableName
init|=
name|rqst
operator|.
name|getTablename
argument_list|()
decl_stmt|;
name|String
name|partName
init|=
name|rqst
operator|.
name|getPartname
argument_list|()
decl_stmt|;
name|StringBuilder
name|filter
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|dbName
operator|!=
literal|null
operator|&&
operator|!
name|dbName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|filter
operator|.
name|append
argument_list|(
literal|"hl_db="
argument_list|)
operator|.
name|append
argument_list|(
name|quoteString
argument_list|(
name|dbName
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tableName
operator|!=
literal|null
operator|&&
operator|!
name|tableName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|filter
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|filter
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
block|}
name|filter
operator|.
name|append
argument_list|(
literal|"hl_table="
argument_list|)
operator|.
name|append
argument_list|(
name|quoteString
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|partName
operator|!=
literal|null
operator|&&
operator|!
name|partName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|filter
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|filter
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
block|}
name|filter
operator|.
name|append
argument_list|(
literal|"hl_partition="
argument_list|)
operator|.
name|append
argument_list|(
name|quoteString
argument_list|(
name|partName
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|String
name|whereClause
init|=
name|filter
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|whereClause
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|s
operator|=
name|s
operator|+
literal|" where "
operator|+
name|whereClause
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Doing to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|ShowLocksResponseElement
name|e
init|=
operator|new
name|ShowLocksResponseElement
argument_list|()
decl_stmt|;
name|e
operator|.
name|setLockid
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|txnid
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
name|e
operator|.
name|setTxnid
argument_list|(
name|txnid
argument_list|)
expr_stmt|;
name|e
operator|.
name|setDbname
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setTablename
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|partition
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
name|partition
operator|!=
literal|null
condition|)
name|e
operator|.
name|setPartname
argument_list|(
name|partition
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|LOCK_ACQUIRED
case|:
name|e
operator|.
name|setState
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCK_WAITING
case|:
name|e
operator|.
name|setState
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unknown lock state "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|7
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|LOCK_SEMI_SHARED
case|:
name|e
operator|.
name|setType
argument_list|(
name|LockType
operator|.
name|SHARED_WRITE
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCK_EXCLUSIVE
case|:
name|e
operator|.
name|setType
argument_list|(
name|LockType
operator|.
name|EXCLUSIVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCK_SHARED
case|:
name|e
operator|.
name|setType
argument_list|(
name|LockType
operator|.
name|SHARED_READ
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unknown lock type "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
throw|;
block|}
name|e
operator|.
name|setLastheartbeat
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|acquiredAt
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|9
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
name|e
operator|.
name|setAcquiredat
argument_list|(
name|acquiredAt
argument_list|)
expr_stmt|;
name|e
operator|.
name|setUser
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setHostname
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|11
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setLockIdInternal
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|id
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|13
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
block|{
name|e
operator|.
name|setBlockedByExtId
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|id
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|14
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
block|{
name|e
operator|.
name|setBlockedByIntId
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|e
operator|.
name|setAgentInfo
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|15
argument_list|)
argument_list|)
expr_stmt|;
name|sortedList
operator|.
name|add
argument_list|(
operator|new
name|LockInfoExt
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"showLocks("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
comment|//this ensures that "SHOW LOCKS" prints the locks in the same order as they are examined
comment|//by checkLock() - makes diagnostics easier.
name|Collections
operator|.
name|sort
argument_list|(
name|sortedList
argument_list|,
operator|new
name|LockInfoComparator
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|LockInfoExt
name|lockInfoExt
range|:
name|sortedList
control|)
block|{
name|elems
operator|.
name|add
argument_list|(
name|lockInfoExt
operator|.
name|e
argument_list|)
expr_stmt|;
block|}
name|rsp
operator|.
name|setLocks
argument_list|(
name|elems
argument_list|)
expr_stmt|;
return|return
name|rsp
return|;
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|showLocks
argument_list|(
name|rqst
argument_list|)
return|;
block|}
block|}
comment|/**    * {@code ids} should only have txnid or lockid but not both, ideally.    * Currently DBTxnManager.heartbeat() enforces this.    */
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|SafeToRetry
specifier|public
name|void
name|heartbeat
parameter_list|(
name|HeartbeatRequest
name|ids
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|NoSuchLockException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|heartbeatLock
argument_list|(
name|dbConn
argument_list|,
name|ids
operator|.
name|getLockid
argument_list|()
argument_list|)
expr_stmt|;
name|heartbeatTxn
argument_list|(
name|dbConn
argument_list|,
name|ids
operator|.
name|getTxnid
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"heartbeat("
operator|+
name|ids
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|heartbeat
argument_list|(
name|ids
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|SafeToRetry
specifier|public
name|HeartbeatTxnRangeResponse
name|heartbeatTxnRange
parameter_list|(
name|HeartbeatTxnRangeRequest
name|rqst
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|HeartbeatTxnRangeResponse
name|rsp
init|=
operator|new
name|HeartbeatTxnRangeResponse
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Long
argument_list|>
name|nosuch
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Long
argument_list|>
name|aborted
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
name|rsp
operator|.
name|setNosuch
argument_list|(
name|nosuch
argument_list|)
expr_stmt|;
name|rsp
operator|.
name|setAborted
argument_list|(
name|aborted
argument_list|)
expr_stmt|;
try|try
block|{
comment|/**          * READ_COMMITTED is sufficient since {@link #heartbeatTxn(java.sql.Connection, long)}          * only has 1 update statement in it and          * we only update existing txns, i.e. nothing can add additional txns that this operation          * would care about (which would have required SERIALIZABLE)          */
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
comment|/*do fast path first (in 1 statement) if doesn't work, rollback and do the long version*/
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|queries
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|numTxnsToHeartbeat
init|=
call|(
name|int
call|)
argument_list|(
name|rqst
operator|.
name|getMax
argument_list|()
operator|-
name|rqst
operator|.
name|getMin
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|txnIds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|numTxnsToHeartbeat
argument_list|)
decl_stmt|;
for|for
control|(
name|long
name|txn
init|=
name|rqst
operator|.
name|getMin
argument_list|()
init|;
name|txn
operator|<=
name|rqst
operator|.
name|getMax
argument_list|()
condition|;
name|txn
operator|++
control|)
block|{
name|txnIds
operator|.
name|add
argument_list|(
name|txn
argument_list|)
expr_stmt|;
block|}
name|TxnUtils
operator|.
name|buildQueryWithINClause
argument_list|(
name|conf
argument_list|,
name|queries
argument_list|,
operator|new
name|StringBuilder
argument_list|(
literal|"update TXNS set txn_last_heartbeat = "
operator|+
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
operator|+
literal|" where txn_state = "
operator|+
name|quoteChar
argument_list|(
name|TXN_OPEN
argument_list|)
operator|+
literal|" and "
argument_list|)
argument_list|,
operator|new
name|StringBuilder
argument_list|(
literal|""
argument_list|)
argument_list|,
name|txnIds
argument_list|,
literal|"txn_id"
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|int
name|updateCnt
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|query
range|:
name|queries
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|query
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|updateCnt
operator|+=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|updateCnt
operator|==
name|numTxnsToHeartbeat
condition|)
block|{
comment|//fast pass worked, i.e. all txns we were asked to heartbeat were Open as expected
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
name|rsp
return|;
block|}
comment|//if here, do the slow path so that we can return info txns which were not in expected state
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
for|for
control|(
name|long
name|txn
init|=
name|rqst
operator|.
name|getMin
argument_list|()
init|;
name|txn
operator|<=
name|rqst
operator|.
name|getMax
argument_list|()
condition|;
name|txn
operator|++
control|)
block|{
try|try
block|{
name|heartbeatTxn
argument_list|(
name|dbConn
argument_list|,
name|txn
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchTxnException
name|e
parameter_list|)
block|{
name|nosuch
operator|.
name|add
argument_list|(
name|txn
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TxnAbortedException
name|e
parameter_list|)
block|{
name|aborted
operator|.
name|add
argument_list|(
name|txn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|rsp
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"heartbeatTxnRange("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
literal|null
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|heartbeatTxnRange
argument_list|(
name|rqst
argument_list|)
return|;
block|}
block|}
name|long
name|generateCompactionQueueId
parameter_list|(
name|Statement
name|stmt
parameter_list|)
throws|throws
name|SQLException
throws|,
name|MetaException
block|{
comment|// Get the id for the next entry in the queue
name|String
name|s
init|=
name|sqlGenerator
operator|.
name|addForUpdateClause
argument_list|(
literal|"select ncq_next from NEXT_COMPACTION_QUEUE_ID"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Transaction tables not properly initiated, "
operator|+
literal|"no record found in next_compaction_queue_id"
argument_list|)
throw|;
block|}
name|long
name|id
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|s
operator|=
literal|"update NEXT_COMPACTION_QUEUE_ID set ncq_next = "
operator|+
operator|(
name|id
operator|+
literal|1
operator|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|id
return|;
block|}
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|Idempotent
specifier|public
name|CompactionResponse
name|compact
parameter_list|(
name|CompactionRequest
name|rqst
parameter_list|)
throws|throws
name|MetaException
block|{
comment|// Put a compaction request in the queue.
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|TxnStore
operator|.
name|MutexAPI
operator|.
name|LockHandle
name|handle
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lockInternal
argument_list|()
expr_stmt|;
comment|/**          * MUTEX_KEY.CompactionScheduler lock ensures that there is only 1 entry in          * Initiated/Working state for any resource.  This ensures that we don't run concurrent          * compactions for any resource.          */
name|handle
operator|=
name|getMutexAPI
argument_list|()
operator|.
name|acquireLock
argument_list|(
name|MUTEX_KEY
operator|.
name|CompactionScheduler
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|long
name|id
init|=
name|generateCompactionQueueId
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"select cq_id, cq_state from COMPACTION_QUEUE where"
argument_list|)
operator|.
name|append
argument_list|(
literal|" cq_state IN("
argument_list|)
operator|.
name|append
argument_list|(
name|quoteChar
argument_list|(
name|INITIATED_STATE
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
operator|.
name|append
argument_list|(
name|quoteChar
argument_list|(
name|WORKING_STATE
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|") AND cq_database="
argument_list|)
operator|.
name|append
argument_list|(
name|quoteString
argument_list|(
name|rqst
operator|.
name|getDbname
argument_list|()
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|" AND cq_table="
argument_list|)
operator|.
name|append
argument_list|(
name|quoteString
argument_list|(
name|rqst
operator|.
name|getTablename
argument_list|()
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|" AND "
argument_list|)
decl_stmt|;
if|if
condition|(
name|rqst
operator|.
name|getPartitionname
argument_list|()
operator|==
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"cq_partition is null"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"cq_partition="
argument_list|)
operator|.
name|append
argument_list|(
name|quoteString
argument_list|(
name|rqst
operator|.
name|getPartitionname
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|sb
operator|.
name|toString
argument_list|()
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|long
name|enqueuedId
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|String
name|state
init|=
name|compactorStateToResponse
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignoring request to compact "
operator|+
name|rqst
operator|.
name|getDbname
argument_list|()
operator|+
literal|"/"
operator|+
name|rqst
operator|.
name|getTablename
argument_list|()
operator|+
literal|"/"
operator|+
name|rqst
operator|.
name|getPartitionname
argument_list|()
operator|+
literal|" since it is already "
operator|+
name|quoteString
argument_list|(
name|state
argument_list|)
operator|+
literal|" with id="
operator|+
name|enqueuedId
argument_list|)
expr_stmt|;
return|return
operator|new
name|CompactionResponse
argument_list|(
name|enqueuedId
argument_list|,
name|state
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"insert into COMPACTION_QUEUE (cq_id, cq_database, "
operator|+
literal|"cq_table, "
argument_list|)
decl_stmt|;
name|String
name|partName
init|=
name|rqst
operator|.
name|getPartitionname
argument_list|()
decl_stmt|;
if|if
condition|(
name|partName
operator|!=
literal|null
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|"cq_partition, "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"cq_state, cq_type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqst
operator|.
name|getProperties
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|", cq_tblproperties"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rqst
operator|.
name|getRunas
argument_list|()
operator|!=
literal|null
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|", cq_run_as"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|") values ("
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|", '"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|rqst
operator|.
name|getDbname
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|rqst
operator|.
name|getTablename
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
if|if
condition|(
name|partName
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|partName
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|INITIATED_STATE
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rqst
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|MAJOR
case|:
name|buf
operator|.
name|append
argument_list|(
name|MAJOR_TYPE
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINOR
case|:
name|buf
operator|.
name|append
argument_list|(
name|MINOR_TYPE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unexpected compaction type "
operator|+
name|rqst
operator|.
name|getType
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|rqst
operator|.
name|getProperties
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
operator|new
name|StringableMap
argument_list|(
name|rqst
operator|.
name|getProperties
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rqst
operator|.
name|getRunas
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|rqst
operator|.
name|getRunas
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"')"
argument_list|)
expr_stmt|;
name|String
name|s
init|=
name|buf
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
operator|new
name|CompactionResponse
argument_list|(
name|id
argument_list|,
name|INITIATED_RESPONSE
argument_list|,
literal|true
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"compact("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|!=
literal|null
condition|)
block|{
name|handle
operator|.
name|releaseLocks
argument_list|()
expr_stmt|;
block|}
name|unlockInternal
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|compact
argument_list|(
name|rqst
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
name|String
name|compactorStateToResponse
parameter_list|(
name|char
name|s
parameter_list|)
block|{
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|INITIATED_STATE
case|:
return|return
name|INITIATED_RESPONSE
return|;
case|case
name|WORKING_STATE
case|:
return|return
name|WORKING_RESPONSE
return|;
case|case
name|READY_FOR_CLEANING
case|:
return|return
name|CLEANING_RESPONSE
return|;
case|case
name|FAILED_STATE
case|:
return|return
name|FAILED_RESPONSE
return|;
case|case
name|SUCCEEDED_STATE
case|:
return|return
name|SUCCEEDED_RESPONSE
return|;
case|case
name|ATTEMPTED_STATE
case|:
return|return
name|ATTEMPTED_RESPONSE
return|;
default|default:
return|return
name|Character
operator|.
name|toString
argument_list|(
name|s
argument_list|)
return|;
block|}
block|}
annotation|@
name|RetrySemantics
operator|.
name|ReadOnly
specifier|public
name|ShowCompactResponse
name|showCompact
parameter_list|(
name|ShowCompactRequest
name|rqst
parameter_list|)
throws|throws
name|MetaException
block|{
name|ShowCompactResponse
name|response
init|=
operator|new
name|ShowCompactResponse
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ShowCompactResponseElement
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select cq_database, cq_table, cq_partition, cq_state, cq_type, cq_worker_id, "
operator|+
comment|//-1 because 'null' literal doesn't work for all DBs...
literal|"cq_start, -1 cc_end, cq_run_as, cq_hadoop_job_id, cq_id from COMPACTION_QUEUE union all "
operator|+
literal|"select cc_database, cc_table, cc_partition, cc_state, cc_type, cc_worker_id, "
operator|+
literal|"cc_start, cc_end, cc_run_as, cc_hadoop_job_id, cc_id from COMPLETED_COMPACTIONS"
decl_stmt|;
comment|//what I want is order by cc_end desc, cc_start asc (but derby has a bug https://issues.apache.org/jira/browse/DERBY-6013)
comment|//to sort so that currently running jobs are at the end of the list (bottom of screen)
comment|//and currently running ones are in sorted by start time
comment|//w/o order by likely currently running compactions will be first (LHS of Union)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|ShowCompactResponseElement
name|e
init|=
operator|new
name|ShowCompactResponseElement
argument_list|()
decl_stmt|;
name|e
operator|.
name|setDbname
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setTablename
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setPartitionname
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setState
argument_list|(
name|compactorStateToResponse
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|MAJOR_TYPE
case|:
name|e
operator|.
name|setType
argument_list|(
name|CompactionType
operator|.
name|MAJOR
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINOR_TYPE
case|:
name|e
operator|.
name|setType
argument_list|(
name|CompactionType
operator|.
name|MINOR
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|//do nothing to handle RU/D if we add another status
block|}
name|e
operator|.
name|setWorkerid
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|start
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|7
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
block|{
name|e
operator|.
name|setStart
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
name|long
name|endTime
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|8
argument_list|)
decl_stmt|;
if|if
condition|(
name|endTime
operator|!=
operator|-
literal|1
condition|)
block|{
name|e
operator|.
name|setEndTime
argument_list|(
name|endTime
argument_list|)
expr_stmt|;
block|}
name|e
operator|.
name|setRunAs
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setHadoopJobId
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setId
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|11
argument_list|)
argument_list|)
expr_stmt|;
name|response
operator|.
name|addToCompacts
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"showCompact("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
return|return
name|response
return|;
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|showCompact
argument_list|(
name|rqst
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
name|void
name|shouldNeverHappen
parameter_list|(
name|long
name|txnid
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"This should never happen: "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
argument_list|)
throw|;
block|}
specifier|private
specifier|static
name|void
name|shouldNeverHappen
parameter_list|(
name|long
name|txnid
parameter_list|,
name|long
name|extLockId
parameter_list|,
name|long
name|intLockId
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"This should never happen: "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
operator|+
literal|" "
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
operator|+
literal|" "
operator|+
name|intLockId
argument_list|)
throw|;
block|}
comment|/**    * Retry-by-caller note:    * This may be retried after dbConn.commit.  At worst, it will create duplicate entries in    * TXN_COMPONENTS which won't affect anything.  See more comments in {@link #commitTxn(CommitTxnRequest)}    */
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|SafeToRetry
specifier|public
name|void
name|addDynamicPartitions
parameter_list|(
name|AddDynamicPartitions
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|lockHandle
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|lockInternal
argument_list|()
expr_stmt|;
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|lockHandle
operator|=
name|lockTransactionRecord
argument_list|(
name|stmt
argument_list|,
name|rqst
operator|.
name|getTxnid
argument_list|()
argument_list|,
name|TXN_OPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockHandle
operator|==
literal|null
condition|)
block|{
comment|//ensures txn is still there and in expected state
name|ensureValidTxn
argument_list|(
name|dbConn
argument_list|,
name|rqst
operator|.
name|getTxnid
argument_list|()
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|shouldNeverHappen
argument_list|(
name|rqst
operator|.
name|getTxnid
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//for RU this may be null so we should default it to 'u' which is most restrictive
name|OpertaionType
name|ot
init|=
name|OpertaionType
operator|.
name|UPDATE
decl_stmt|;
if|if
condition|(
name|rqst
operator|.
name|isSetOperationType
argument_list|()
condition|)
block|{
name|ot
operator|=
name|OpertaionType
operator|.
name|fromDataOperationType
argument_list|(
name|rqst
operator|.
name|getOperationType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|rows
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|partName
range|:
name|rqst
operator|.
name|getPartitionnames
argument_list|()
control|)
block|{
name|rows
operator|.
name|add
argument_list|(
name|rqst
operator|.
name|getTxnid
argument_list|()
operator|+
literal|","
operator|+
name|quoteString
argument_list|(
name|rqst
operator|.
name|getDbname
argument_list|()
argument_list|)
operator|+
literal|","
operator|+
name|quoteString
argument_list|(
name|rqst
operator|.
name|getTablename
argument_list|()
argument_list|)
operator|+
literal|","
operator|+
name|quoteString
argument_list|(
name|partName
argument_list|)
operator|+
literal|","
operator|+
name|quoteChar
argument_list|(
name|ot
operator|.
name|sqlConst
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|modCount
init|=
literal|0
decl_stmt|;
comment|//record partitions that were written to
name|List
argument_list|<
name|String
argument_list|>
name|queries
init|=
name|sqlGenerator
operator|.
name|createInsertValuesStmt
argument_list|(
literal|"TXN_COMPONENTS (tc_txnid, tc_database, tc_table, tc_partition, tc_operation_type)"
argument_list|,
name|rows
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|query
range|:
name|queries
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|query
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|modCount
operator|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"addDynamicPartitions("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to insert into from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|lockHandle
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
name|unlockInternal
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|addDynamicPartitions
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Clean up corresponding records in metastore tables when corresponding object is dropped,    * specifically: TXN_COMPONENTS, COMPLETED_TXN_COMPONENTS, COMPACTION_QUEUE, COMPLETED_COMPACTIONS    * Retry-by-caller note: this is only idempotent assuming it's only called by dropTable/Db/etc    * operations.    */
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|Idempotent
specifier|public
name|void
name|cleanupRecords
parameter_list|(
name|HiveObjectType
name|type
parameter_list|,
name|Database
name|db
parameter_list|,
name|Table
name|table
parameter_list|,
name|Iterator
argument_list|<
name|Partition
argument_list|>
name|partitionIterator
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|String
name|dbName
decl_stmt|;
name|String
name|tblName
decl_stmt|;
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|queries
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|buff
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DATABASE
case|:
name|dbName
operator|=
name|db
operator|.
name|getName
argument_list|()
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from TXN_COMPONENTS where tc_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from COMPLETED_TXN_COMPONENTS where ctc_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from COMPACTION_QUEUE where cq_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from COMPLETED_COMPACTIONS where cc_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TABLE
case|:
name|dbName
operator|=
name|table
operator|.
name|getDbName
argument_list|()
expr_stmt|;
name|tblName
operator|=
name|table
operator|.
name|getTableName
argument_list|()
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from TXN_COMPONENTS where tc_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and tc_table='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from COMPLETED_TXN_COMPONENTS where ctc_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and ctc_table='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from COMPACTION_QUEUE where cq_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and cq_table='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from COMPLETED_COMPACTIONS where cc_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and cc_table='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARTITION
case|:
name|dbName
operator|=
name|table
operator|.
name|getDbName
argument_list|()
expr_stmt|;
name|tblName
operator|=
name|table
operator|.
name|getTableName
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|partCols
init|=
name|table
operator|.
name|getPartitionKeys
argument_list|()
decl_stmt|;
comment|// partition columns
name|List
argument_list|<
name|String
argument_list|>
name|partVals
decl_stmt|;
comment|// partition values
name|String
name|partName
decl_stmt|;
while|while
condition|(
name|partitionIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Partition
name|p
init|=
name|partitionIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|partVals
operator|=
name|p
operator|.
name|getValues
argument_list|()
expr_stmt|;
name|partName
operator|=
name|Warehouse
operator|.
name|makePartName
argument_list|(
name|partCols
argument_list|,
name|partVals
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from TXN_COMPONENTS where tc_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and tc_table='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and tc_partition='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|partName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from COMPLETED_TXN_COMPONENTS where ctc_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and ctc_table='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and ctc_partition='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|partName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from COMPACTION_QUEUE where cq_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and cq_table='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and cq_partition='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|partName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from COMPLETED_COMPACTIONS where cc_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and cc_table='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and cc_partition='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|partName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Invalid object type for cleanup: "
operator|+
name|type
argument_list|)
throw|;
block|}
for|for
control|(
name|String
name|query
range|:
name|queries
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|query
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"cleanupRecords"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"does not exist"
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot perform cleanup since metastore table does not exist"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to clean up "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|cleanupRecords
argument_list|(
name|type
argument_list|,
name|db
argument_list|,
name|table
argument_list|,
name|partitionIterator
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * For testing only, do not use.    */
annotation|@
name|VisibleForTesting
specifier|public
name|int
name|numLocksInLockTable
parameter_list|()
throws|throws
name|SQLException
throws|,
name|MetaException
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select count(*) from HIVE_LOCKS"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|rs
operator|.
name|next
argument_list|()
expr_stmt|;
name|int
name|rc
init|=
name|rs
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// Necessary to clean up the transaction in the db.
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
name|rc
return|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * For testing only, do not use.    */
specifier|public
name|long
name|setTimeout
parameter_list|(
name|long
name|milliseconds
parameter_list|)
block|{
name|long
name|previous_timeout
init|=
name|timeout
decl_stmt|;
name|timeout
operator|=
name|milliseconds
expr_stmt|;
return|return
name|previous_timeout
return|;
block|}
specifier|protected
class|class
name|RetryException
extends|extends
name|Exception
block|{    }
specifier|protected
name|Connection
name|getDbConn
parameter_list|(
name|int
name|isolationLevel
parameter_list|)
throws|throws
name|SQLException
block|{
name|int
name|rc
init|=
name|doRetryOnConnPool
condition|?
literal|10
else|:
literal|1
decl_stmt|;
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|dbConn
operator|=
name|connPool
operator|.
name|getConnection
argument_list|()
expr_stmt|;
name|dbConn
operator|.
name|setAutoCommit
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|setTransactionIsolation
argument_list|(
name|isolationLevel
argument_list|)
expr_stmt|;
return|return
name|dbConn
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|--
name|rc
operator|)
operator|<=
literal|0
condition|)
throw|throw
name|e
throw|;
name|LOG
operator|.
name|error
argument_list|(
literal|"There is a problem with a connection from the pool, retrying(rc="
operator|+
name|rc
operator|+
literal|"): "
operator|+
name|getMessage
argument_list|(
name|e
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|static
name|void
name|rollbackDBConn
parameter_list|(
name|Connection
name|dbConn
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|dbConn
operator|!=
literal|null
operator|&&
operator|!
name|dbConn
operator|.
name|isClosed
argument_list|()
condition|)
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to rollback db connection "
operator|+
name|getMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
specifier|static
name|void
name|closeDbConn
parameter_list|(
name|Connection
name|dbConn
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|dbConn
operator|!=
literal|null
operator|&&
operator|!
name|dbConn
operator|.
name|isClosed
argument_list|()
condition|)
block|{
name|dbConn
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to close db connection "
operator|+
name|getMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Close statement instance.    * @param stmt statement instance.    */
specifier|protected
specifier|static
name|void
name|closeStmt
parameter_list|(
name|Statement
name|stmt
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|stmt
operator|!=
literal|null
operator|&&
operator|!
name|stmt
operator|.
name|isClosed
argument_list|()
condition|)
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to close statement "
operator|+
name|getMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Close the ResultSet.    * @param rs may be {@code null}    */
specifier|static
name|void
name|close
parameter_list|(
name|ResultSet
name|rs
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|rs
operator|!=
literal|null
operator|&&
operator|!
name|rs
operator|.
name|isClosed
argument_list|()
condition|)
block|{
name|rs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to close statement "
operator|+
name|getMessage
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Close all 3 JDBC artifacts in order: {@code rs stmt dbConn}    */
specifier|static
name|void
name|close
parameter_list|(
name|ResultSet
name|rs
parameter_list|,
name|Statement
name|stmt
parameter_list|,
name|Connection
name|dbConn
parameter_list|)
block|{
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
comment|/**    * Determine if an exception was such that it makes sense to retry.  Unfortunately there is no standard way to do    * this, so we have to inspect the error messages and catch the telltale signs for each    * different database.  This method will throw {@code RetryException}    * if the error is retry-able.    * @param conn database connection    * @param e exception that was thrown.    * @param caller name of the method calling this (and other info useful to log)    * @throws org.apache.hadoop.hive.metastore.txn.TxnHandler.RetryException when the operation should be retried    */
specifier|protected
name|void
name|checkRetryable
parameter_list|(
name|Connection
name|conn
parameter_list|,
name|SQLException
name|e
parameter_list|,
name|String
name|caller
parameter_list|)
throws|throws
name|RetryException
throws|,
name|MetaException
block|{
comment|// If you change this function, remove the @Ignore from TestTxnHandler.deadlockIsDetected()
comment|// to test these changes.
comment|// MySQL and MSSQL use 40001 as the state code for rollback.  Postgres uses 40001 and 40P01.
comment|// Oracle seems to return different SQLStates and messages each time,
comment|// so I've tried to capture the different error messages (there appear to be fewer different
comment|// error messages than SQL states).
comment|// Derby and newer MySQL driver use the new SQLTransactionRollbackException
name|boolean
name|sendRetrySignal
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|dbProduct
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"DB Type not determined yet."
argument_list|)
throw|;
block|}
if|if
condition|(
name|DatabaseProduct
operator|.
name|isDeadlock
argument_list|(
name|dbProduct
argument_list|,
name|e
argument_list|)
condition|)
block|{
if|if
condition|(
name|deadlockCnt
operator|++
operator|<
name|ALLOWED_REPEATED_DEADLOCKS
condition|)
block|{
name|long
name|waitInterval
init|=
name|deadlockRetryInterval
operator|*
name|deadlockCnt
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Deadlock detected in "
operator|+
name|caller
operator|+
literal|". Will wait "
operator|+
name|waitInterval
operator|+
literal|"ms try again up to "
operator|+
operator|(
name|ALLOWED_REPEATED_DEADLOCKS
operator|-
name|deadlockCnt
operator|+
literal|1
operator|)
operator|+
literal|" times."
argument_list|)
expr_stmt|;
comment|// Pause for a just a bit for retrying to avoid immediately jumping back into the deadlock.
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|waitInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// NOP
block|}
name|sendRetrySignal
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Too many repeated deadlocks in "
operator|+
name|caller
operator|+
literal|", giving up."
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isRetryable
argument_list|(
name|conf
argument_list|,
name|e
argument_list|)
condition|)
block|{
comment|//in MSSQL this means Communication Link Failure
if|if
condition|(
name|retryNum
operator|++
operator|<
name|retryLimit
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Retryable error detected in "
operator|+
name|caller
operator|+
literal|".  Will wait "
operator|+
name|retryInterval
operator|+
literal|"ms and retry up to "
operator|+
operator|(
name|retryLimit
operator|-
name|retryNum
operator|+
literal|1
operator|)
operator|+
literal|" times.  Error: "
operator|+
name|getMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|retryInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
comment|//
block|}
name|sendRetrySignal
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Fatal error in "
operator|+
name|caller
operator|+
literal|". Retry limit ("
operator|+
name|retryLimit
operator|+
literal|") reached. Last error: "
operator|+
name|getMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//make sure we know we saw an error that we don't recognize
name|LOG
operator|.
name|info
argument_list|(
literal|"Non-retryable error in "
operator|+
name|caller
operator|+
literal|" : "
operator|+
name|getMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|/*if this method ends with anything except a retry signal, the caller should fail the operation       and propagate the error up to the its caller (Metastore client); thus must reset retry counters*/
if|if
condition|(
operator|!
name|sendRetrySignal
condition|)
block|{
name|deadlockCnt
operator|=
literal|0
expr_stmt|;
name|retryNum
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sendRetrySignal
condition|)
block|{
throw|throw
operator|new
name|RetryException
argument_list|()
throw|;
block|}
block|}
comment|/**    * Determine the current time, using the RDBMS as a source of truth    * @param conn database connection    * @return current time in milliseconds    * @throws org.apache.hadoop.hive.metastore.api.MetaException if the time cannot be determined    */
specifier|protected
name|long
name|getDbTime
parameter_list|(
name|Connection
name|conn
parameter_list|)
throws|throws
name|MetaException
block|{
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|conn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
decl_stmt|;
switch|switch
condition|(
name|dbProduct
condition|)
block|{
case|case
name|DERBY
case|:
name|s
operator|=
literal|"values current_timestamp"
expr_stmt|;
break|break;
case|case
name|MYSQL
case|:
case|case
name|POSTGRES
case|:
case|case
name|SQLSERVER
case|:
name|s
operator|=
literal|"select current_timestamp"
expr_stmt|;
break|break;
case|case
name|ORACLE
case|:
name|s
operator|=
literal|"select current_timestamp from dual"
expr_stmt|;
break|break;
default|default:
name|String
name|msg
init|=
literal|"Unknown database product: "
operator|+
name|dbProduct
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"No results from date query"
argument_list|)
throw|;
return|return
name|rs
operator|.
name|getTimestamp
argument_list|(
literal|1
argument_list|)
operator|.
name|getTime
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"Unable to determine current time: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Determine the String that should be used to quote identifiers.    * @param conn Active connection    * @return quotes    * @throws SQLException    */
specifier|protected
name|String
name|getIdentifierQuoteString
parameter_list|(
name|Connection
name|conn
parameter_list|)
throws|throws
name|SQLException
block|{
if|if
condition|(
name|identifierQuoteString
operator|==
literal|null
condition|)
block|{
name|identifierQuoteString
operator|=
name|conn
operator|.
name|getMetaData
argument_list|()
operator|.
name|getIdentifierQuoteString
argument_list|()
expr_stmt|;
block|}
return|return
name|identifierQuoteString
return|;
block|}
specifier|private
name|void
name|determineDatabaseProduct
parameter_list|(
name|Connection
name|conn
parameter_list|)
block|{
if|if
condition|(
name|dbProduct
operator|!=
literal|null
condition|)
return|return;
try|try
block|{
name|String
name|s
init|=
name|conn
operator|.
name|getMetaData
argument_list|()
operator|.
name|getDatabaseProductName
argument_list|()
decl_stmt|;
name|dbProduct
operator|=
name|DatabaseProduct
operator|.
name|determineDatabaseProduct
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbProduct
operator|==
name|DatabaseProduct
operator|.
name|OTHER
condition|)
block|{
name|String
name|msg
init|=
literal|"Unrecognized database product name<"
operator|+
name|s
operator|+
literal|">"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"Unable to get database product name"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
class|class
name|LockInfo
block|{
specifier|private
specifier|final
name|long
name|extLockId
decl_stmt|;
specifier|private
specifier|final
name|long
name|intLockId
decl_stmt|;
comment|//0 means there is no transaction, i.e. it a select statement which is not part of
comment|//explicit transaction or a IUD statement that is not writing to ACID table
specifier|private
specifier|final
name|long
name|txnId
decl_stmt|;
specifier|private
specifier|final
name|String
name|db
decl_stmt|;
specifier|private
specifier|final
name|String
name|table
decl_stmt|;
specifier|private
specifier|final
name|String
name|partition
decl_stmt|;
specifier|private
specifier|final
name|LockState
name|state
decl_stmt|;
specifier|private
specifier|final
name|LockType
name|type
decl_stmt|;
comment|// Assumes the result set is set to a valid row
name|LockInfo
parameter_list|(
name|ResultSet
name|rs
parameter_list|)
throws|throws
name|SQLException
throws|,
name|MetaException
block|{
name|extLockId
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|"hl_lock_ext_id"
argument_list|)
expr_stmt|;
comment|// can't be null
name|intLockId
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|"hl_lock_int_id"
argument_list|)
expr_stmt|;
comment|// can't be null
name|db
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_db"
argument_list|)
expr_stmt|;
comment|// can't be null
name|String
name|t
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_table"
argument_list|)
decl_stmt|;
name|table
operator|=
operator|(
name|rs
operator|.
name|wasNull
argument_list|()
condition|?
literal|null
else|:
name|t
operator|)
expr_stmt|;
name|String
name|p
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_partition"
argument_list|)
decl_stmt|;
name|partition
operator|=
operator|(
name|rs
operator|.
name|wasNull
argument_list|()
condition|?
literal|null
else|:
name|p
operator|)
expr_stmt|;
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_lock_state"
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|LOCK_WAITING
case|:
name|state
operator|=
name|LockState
operator|.
name|WAITING
expr_stmt|;
break|break;
case|case
name|LOCK_ACQUIRED
case|:
name|state
operator|=
name|LockState
operator|.
name|ACQUIRED
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unknown lock state "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_lock_state"
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_lock_type"
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|LOCK_EXCLUSIVE
case|:
name|type
operator|=
name|LockType
operator|.
name|EXCLUSIVE
expr_stmt|;
break|break;
case|case
name|LOCK_SHARED
case|:
name|type
operator|=
name|LockType
operator|.
name|SHARED_READ
expr_stmt|;
break|break;
case|case
name|LOCK_SEMI_SHARED
case|:
name|type
operator|=
name|LockType
operator|.
name|SHARED_WRITE
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unknown lock type "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_lock_type"
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
throw|;
block|}
name|txnId
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|"hl_txnid"
argument_list|)
expr_stmt|;
comment|//returns 0 if value is NULL
block|}
name|LockInfo
parameter_list|(
name|ShowLocksResponseElement
name|e
parameter_list|)
block|{
name|extLockId
operator|=
name|e
operator|.
name|getLockid
argument_list|()
expr_stmt|;
name|intLockId
operator|=
name|e
operator|.
name|getLockIdInternal
argument_list|()
expr_stmt|;
name|txnId
operator|=
name|e
operator|.
name|getTxnid
argument_list|()
expr_stmt|;
name|db
operator|=
name|e
operator|.
name|getDbname
argument_list|()
expr_stmt|;
name|table
operator|=
name|e
operator|.
name|getTablename
argument_list|()
expr_stmt|;
name|partition
operator|=
name|e
operator|.
name|getPartname
argument_list|()
expr_stmt|;
name|state
operator|=
name|e
operator|.
name|getState
argument_list|()
expr_stmt|;
name|type
operator|=
name|e
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|other
operator|instanceof
name|LockInfo
operator|)
condition|)
return|return
literal|false
return|;
name|LockInfo
name|o
init|=
operator|(
name|LockInfo
operator|)
name|other
decl_stmt|;
comment|// Lock ids are unique across the system.
return|return
name|extLockId
operator|==
name|o
operator|.
name|extLockId
operator|&&
name|intLockId
operator|==
name|o
operator|.
name|intLockId
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
operator|+
literal|" intLockId:"
operator|+
name|intLockId
operator|+
literal|" "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnId
argument_list|)
operator|+
literal|" db:"
operator|+
name|db
operator|+
literal|" table:"
operator|+
name|table
operator|+
literal|" partition:"
operator|+
name|partition
operator|+
literal|" state:"
operator|+
operator|(
name|state
operator|==
literal|null
condition|?
literal|"null"
else|:
name|state
operator|.
name|toString
argument_list|()
operator|)
operator|+
literal|" type:"
operator|+
operator|(
name|type
operator|==
literal|null
condition|?
literal|"null"
else|:
name|type
operator|.
name|toString
argument_list|()
operator|)
return|;
block|}
specifier|private
name|boolean
name|isDbLock
parameter_list|()
block|{
return|return
name|db
operator|!=
literal|null
operator|&&
name|table
operator|==
literal|null
operator|&&
name|partition
operator|==
literal|null
return|;
block|}
specifier|private
name|boolean
name|isTableLock
parameter_list|()
block|{
return|return
name|db
operator|!=
literal|null
operator|&&
name|table
operator|!=
literal|null
operator|&&
name|partition
operator|==
literal|null
return|;
block|}
specifier|private
name|boolean
name|isPartitionLock
parameter_list|()
block|{
return|return
operator|!
operator|(
name|isDbLock
argument_list|()
operator|||
name|isTableLock
argument_list|()
operator|)
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|LockInfoComparator
implements|implements
name|Comparator
argument_list|<
name|LockInfo
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|LockTypeComparator
name|lockTypeComparator
init|=
operator|new
name|LockTypeComparator
argument_list|()
decl_stmt|;
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
return|return
name|this
operator|==
name|other
return|;
block|}
specifier|public
name|int
name|compare
parameter_list|(
name|LockInfo
name|info1
parameter_list|,
name|LockInfo
name|info2
parameter_list|)
block|{
comment|// We sort by state (acquired vs waiting) and then by LockType, then by id
if|if
condition|(
name|info1
operator|.
name|state
operator|==
name|LockState
operator|.
name|ACQUIRED
operator|&&
name|info2
operator|.
name|state
operator|!=
name|LockState
operator|.
name|ACQUIRED
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|info1
operator|.
name|state
operator|!=
name|LockState
operator|.
name|ACQUIRED
operator|&&
name|info2
operator|.
name|state
operator|==
name|LockState
operator|.
name|ACQUIRED
condition|)
block|{
return|return
literal|1
return|;
block|}
name|int
name|sortByType
init|=
name|lockTypeComparator
operator|.
name|compare
argument_list|(
name|info1
operator|.
name|type
argument_list|,
name|info2
operator|.
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|sortByType
operator|!=
literal|0
condition|)
block|{
return|return
name|sortByType
return|;
block|}
if|if
condition|(
name|info1
operator|.
name|extLockId
operator|<
name|info2
operator|.
name|extLockId
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|info1
operator|.
name|extLockId
operator|>
name|info2
operator|.
name|extLockId
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|info1
operator|.
name|intLockId
operator|<
name|info2
operator|.
name|intLockId
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|info1
operator|.
name|intLockId
operator|>
name|info2
operator|.
name|intLockId
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
comment|/**    * Sort more restrictive locks after less restrictive ones    */
specifier|private
specifier|final
specifier|static
class|class
name|LockTypeComparator
implements|implements
name|Comparator
argument_list|<
name|LockType
argument_list|>
block|{
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
return|return
name|this
operator|==
name|other
return|;
block|}
specifier|public
name|int
name|compare
parameter_list|(
name|LockType
name|t1
parameter_list|,
name|LockType
name|t2
parameter_list|)
block|{
switch|switch
condition|(
name|t1
condition|)
block|{
case|case
name|EXCLUSIVE
case|:
if|if
condition|(
name|t2
operator|==
name|LockType
operator|.
name|EXCLUSIVE
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
case|case
name|SHARED_WRITE
case|:
switch|switch
condition|(
name|t2
condition|)
block|{
case|case
name|EXCLUSIVE
case|:
return|return
operator|-
literal|1
return|;
case|case
name|SHARED_WRITE
case|:
return|return
literal|0
return|;
case|case
name|SHARED_READ
case|:
return|return
literal|1
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected LockType: "
operator|+
name|t2
argument_list|)
throw|;
block|}
case|case
name|SHARED_READ
case|:
if|if
condition|(
name|t2
operator|==
name|LockType
operator|.
name|SHARED_READ
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected LockType: "
operator|+
name|t1
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
enum|enum
name|LockAction
block|{
name|ACQUIRE
block|,
name|WAIT
block|,
name|KEEP_LOOKING
block|}
comment|// A jump table to figure out whether to wait, acquire,
comment|// or keep looking .  Since
comment|// java doesn't have function pointers (grumble grumble) we store a
comment|// character that we'll use to determine which function to call.
comment|// The table maps the lock type of the lock we are looking to acquire to
comment|// the lock type of the lock we are checking to the lock state of the lock
comment|// we are checking to the desired action.
specifier|private
specifier|static
name|Map
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
argument_list|>
name|jumpTable
decl_stmt|;
specifier|private
name|void
name|checkQFileTestHack
parameter_list|()
block|{
name|boolean
name|hackOn
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_IN_TEST
argument_list|)
operator|||
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_IN_TEZ_TEST
argument_list|)
decl_stmt|;
if|if
condition|(
name|hackOn
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Hacking in canned values for transaction manager"
argument_list|)
expr_stmt|;
comment|// Set up the transaction/locking db in the derby metastore
name|TxnDbUtil
operator|.
name|setConfValues
argument_list|(
name|conf
argument_list|)
expr_stmt|;
try|try
block|{
name|TxnDbUtil
operator|.
name|prepDb
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// We may have already created the tables and thus don't need to redo it.
if|if
condition|(
name|e
operator|.
name|getMessage
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"already exists"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unable to set up transaction database for"
operator|+
literal|" testing: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
specifier|private
name|int
name|abortTxns
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|List
argument_list|<
name|Long
argument_list|>
name|txnids
parameter_list|,
name|boolean
name|isStrict
parameter_list|)
throws|throws
name|SQLException
block|{
return|return
name|abortTxns
argument_list|(
name|dbConn
argument_list|,
name|txnids
argument_list|,
operator|-
literal|1
argument_list|,
name|isStrict
argument_list|)
return|;
block|}
comment|/**    * TODO: expose this as an operation to client.  Useful for streaming API to abort all remaining    * trasnactions in a batch on IOExceptions.    * Caller must rollback the transaction if not all transactions were aborted since this will not    * attempt to delete associated locks in this case.    *    * @param dbConn An active connection    * @param txnids list of transactions to abort    * @param max_heartbeat value used by {@link #performTimeOuts()} to ensure this doesn't Abort txn which were    *                      hearbetated after #performTimeOuts() select and this operation.    * @param isStrict true for strict mode, false for best-effort mode.    *                 In strict mode, if all txns are not successfully aborted, then the count of    *                 updated ones will be returned and the caller will roll back.    *                 In best-effort mode, we will ignore that fact and continue deleting the locks.    * @return Number of aborted transactions    * @throws SQLException    */
specifier|private
name|int
name|abortTxns
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|List
argument_list|<
name|Long
argument_list|>
name|txnids
parameter_list|,
name|long
name|max_heartbeat
parameter_list|,
name|boolean
name|isStrict
parameter_list|)
throws|throws
name|SQLException
block|{
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|int
name|updateCnt
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|txnids
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
comment|//This is an update statement, thus at any Isolation level will take Write locks so will block
comment|//all other ops using S4U on TXNS row.
name|List
argument_list|<
name|String
argument_list|>
name|queries
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|prefix
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|StringBuilder
name|suffix
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|prefix
operator|.
name|append
argument_list|(
literal|"update TXNS set txn_state = "
operator|+
name|quoteChar
argument_list|(
name|TXN_ABORTED
argument_list|)
operator|+
literal|" where txn_state = "
operator|+
name|quoteChar
argument_list|(
name|TXN_OPEN
argument_list|)
operator|+
literal|" and "
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_heartbeat
operator|>
literal|0
condition|)
block|{
name|suffix
operator|.
name|append
argument_list|(
literal|" and txn_last_heartbeat< "
argument_list|)
operator|.
name|append
argument_list|(
name|max_heartbeat
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|suffix
operator|.
name|append
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|TxnUtils
operator|.
name|buildQueryWithINClause
argument_list|(
name|conf
argument_list|,
name|queries
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|,
name|txnids
argument_list|,
literal|"txn_id"
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|query
range|:
name|queries
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|query
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|updateCnt
operator|+=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|updateCnt
operator|<
name|txnids
operator|.
name|size
argument_list|()
operator|&&
name|isStrict
condition|)
block|{
comment|/**          * have to bail in this case since we don't know which transactions were not Aborted and          * thus don't know which locks to delete          * This may happen due to a race between {@link #heartbeat(HeartbeatRequest)}  operation and          * {@link #performTimeOuts()}          */
return|return
name|updateCnt
return|;
block|}
name|queries
operator|.
name|clear
argument_list|()
expr_stmt|;
name|prefix
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|suffix
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|prefix
operator|.
name|append
argument_list|(
literal|"delete from HIVE_LOCKS where "
argument_list|)
expr_stmt|;
name|suffix
operator|.
name|append
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|TxnUtils
operator|.
name|buildQueryWithINClause
argument_list|(
name|conf
argument_list|,
name|queries
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|,
name|txnids
argument_list|,
literal|"hl_txnid"
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|query
range|:
name|queries
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|query
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removed "
operator|+
name|rc
operator|+
literal|" records from HIVE_LOCKS"
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
return|return
name|updateCnt
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isValidTxn
parameter_list|(
name|long
name|txnId
parameter_list|)
block|{
return|return
name|txnId
operator|!=
literal|0
return|;
block|}
comment|/**    * Lock acquisition is meant to be fair, so every lock can only block on some lock with smaller    * hl_lock_ext_id by only checking earlier locks.    *    * For any given SQL statment all locks required by it are grouped under single extLockId and are    * granted all at once or all locks wait.    *    * This is expected to run at READ_COMMITTED.    *    * Note: this calls acquire() for (extLockId,intLockId) but extLockId is the same and we either take    * all locks for given extLockId or none.  Would be more efficient to update state on all locks    * at once.  Semantics are the same since this is all part of the same txn.    *    * If there is a concurrent commitTxn/rollbackTxn, those can only remove rows from HIVE_LOCKS.    * If they happen to be for the same txnid, there will be a WW conflict (in MS DB), if different txnid,    * checkLock() will in the worst case keep locks in Waiting state a little longer.    */
annotation|@
name|RetrySemantics
operator|.
name|SafeToRetry
argument_list|(
literal|"See @SafeToRetry"
argument_list|)
specifier|private
name|LockResponse
name|checkLock
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|extLockId
parameter_list|)
throws|throws
name|NoSuchLockException
throws|,
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
throws|,
name|SQLException
block|{
name|TxnStore
operator|.
name|MutexAPI
operator|.
name|LockHandle
name|handle
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
name|LockResponse
name|response
init|=
operator|new
name|LockResponse
argument_list|()
decl_stmt|;
comment|/**      * todo: Longer term we should pass this from client somehow - this would be an optimization;  once      * that is in place make sure to build and test "writeSet" below using OperationType not LockType      * With Static Partitions we assume that the query modifies exactly the partitions it locked.  (not entirely      * realistic since Update/Delete may have some predicate that filters out all records out of      * some partition(s), but plausible).  For DP, we acquire locks very wide (all known partitions),      * but for most queries only a fraction will actually be updated.  #addDynamicPartitions() tells      * us exactly which ones were written to.  Thus using this trick to kill a query early for      * DP queries may be too restrictive.      */
name|boolean
name|isPartOfDynamicPartitionInsert
init|=
literal|true
decl_stmt|;
try|try
block|{
comment|/**        * checkLock() must be mutexed against any other checkLock to make sure 2 conflicting locks        * are not granted by parallel checkLock() calls.        */
name|handle
operator|=
name|getMutexAPI
argument_list|()
operator|.
name|acquireLock
argument_list|(
name|MUTEX_KEY
operator|.
name|CheckLock
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LockInfo
argument_list|>
name|locksBeingChecked
init|=
name|getLockInfoFromLockId
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
decl_stmt|;
comment|//being acquired now
name|response
operator|.
name|setLockid
argument_list|(
name|extLockId
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"checkLock(): Setting savepoint. extLockId="
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
argument_list|)
expr_stmt|;
name|Savepoint
name|save
init|=
name|dbConn
operator|.
name|setSavepoint
argument_list|()
decl_stmt|;
comment|//todo: get rid of this
name|StringBuilder
name|query
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"select hl_lock_ext_id, "
operator|+
literal|"hl_lock_int_id, hl_db, hl_table, hl_partition, hl_lock_state, "
operator|+
literal|"hl_lock_type, hl_txnid from HIVE_LOCKS where hl_db in ("
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|strings
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|locksBeingChecked
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|//This the set of entities that the statement represnted by extLockId wants to update
name|List
argument_list|<
name|LockInfo
argument_list|>
name|writeSet
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|LockInfo
name|info
range|:
name|locksBeingChecked
control|)
block|{
name|strings
operator|.
name|add
argument_list|(
name|info
operator|.
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isPartOfDynamicPartitionInsert
operator|&&
name|info
operator|.
name|type
operator|==
name|LockType
operator|.
name|SHARED_WRITE
condition|)
block|{
name|writeSet
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|writeSet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|writeSet
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|txnId
operator|==
literal|0
condition|)
block|{
comment|//Write operation always start a txn
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Found Write lock for "
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
operator|+
literal|" but no txnid"
argument_list|)
throw|;
block|}
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|" ws_database, ws_table, ws_partition, "
operator|+
literal|"ws_txnid, ws_commit_id "
operator|+
literal|"from WRITE_SET where ws_commit_id>= "
operator|+
name|writeSet
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|txnId
operator|+
literal|" and ("
argument_list|)
decl_stmt|;
comment|//see commitTxn() for more info on this inequality
for|for
control|(
name|LockInfo
name|info
range|:
name|writeSet
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"(ws_database = "
argument_list|)
operator|.
name|append
argument_list|(
name|quoteString
argument_list|(
name|info
operator|.
name|db
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|" and ws_table = "
argument_list|)
operator|.
name|append
argument_list|(
name|quoteString
argument_list|(
name|info
operator|.
name|table
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|" and ws_partition "
argument_list|)
operator|.
name|append
argument_list|(
name|info
operator|.
name|partition
operator|==
literal|null
condition|?
literal|"is null"
else|:
literal|"= "
operator|+
name|quoteString
argument_list|(
name|info
operator|.
name|partition
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|") or "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|setLength
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|//nuke trailing " or "
name|sb
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
comment|//1 row is sufficient to know we have to kill the query
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|sqlGenerator
operator|.
name|addLimitClause
argument_list|(
literal|1
argument_list|,
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
comment|/**            * if here, it means we found an already committed txn which overlaps with the current one and            * it updated the same resource the current txn wants to update.  By First-committer-wins            * rule, current txn will not be allowed to commit so  may as well kill it now;  This is just an            * optimization to prevent wasting cluster resources to run a query which is known to be DOA.            * {@link #commitTxn(CommitTxnRequest)} has the primary responsibility to ensure this.            * checkLock() runs at READ_COMMITTED so you could have another (Hive) txn running commitTxn()            * in parallel and thus writing to WRITE_SET.  commitTxn() logic is properly mutexed to ensure            * that we don't "miss" any WW conflicts. We could've mutexed the checkLock() and commitTxn()            * as well but this reduces concurrency for very little gain.            * Note that update/delete (which runs as dynamic partition insert) acquires a lock on the table,            * but WRITE_SET has entries for actual partitions updated.  Thus this optimization will "miss"            * the WW conflict but it will be caught in commitTxn() where actual partitions written are known.            * This is OK since we want 2 concurrent updates that update different sets of partitions to both commit.            */
name|String
name|resourceName
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
operator|+
literal|'/'
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|String
name|partName
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
name|partName
operator|!=
literal|null
condition|)
block|{
name|resourceName
operator|+=
literal|'/'
operator|+
name|partName
expr_stmt|;
block|}
name|String
name|msg
init|=
literal|"Aborting "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|writeSet
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|txnId
argument_list|)
operator|+
literal|" since a concurrent committed transaction ["
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|4
argument_list|)
argument_list|)
operator|+
literal|","
operator|+
name|rs
operator|.
name|getLong
argument_list|(
literal|5
argument_list|)
operator|+
literal|"] has already updated resouce '"
operator|+
name|resourceName
operator|+
literal|"'"
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|abortTxns
argument_list|(
name|dbConn
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|writeSet
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|txnId
argument_list|)
argument_list|,
literal|true
argument_list|)
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|msg
operator|+
literal|" FAILED!"
argument_list|)
throw|;
block|}
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|TxnAbortedException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|strings
control|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|false
expr_stmt|;
else|else
name|query
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
name|query
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
comment|// If any of the table requests are null, then I need to pull all the
comment|// table locks for this db.
name|boolean
name|sawNull
init|=
literal|false
decl_stmt|;
name|strings
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|LockInfo
name|info
range|:
name|locksBeingChecked
control|)
block|{
if|if
condition|(
name|info
operator|.
name|table
operator|==
literal|null
condition|)
block|{
name|sawNull
operator|=
literal|true
expr_stmt|;
break|break;
block|}
else|else
block|{
name|strings
operator|.
name|add
argument_list|(
name|info
operator|.
name|table
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|sawNull
condition|)
block|{
name|query
operator|.
name|append
argument_list|(
literal|" and (hl_table is null or hl_table in("
argument_list|)
expr_stmt|;
name|first
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|strings
control|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|false
expr_stmt|;
else|else
name|query
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
name|query
operator|.
name|append
argument_list|(
literal|"))"
argument_list|)
expr_stmt|;
comment|// If any of the partition requests are null, then I need to pull all
comment|// partition locks for this table.
name|sawNull
operator|=
literal|false
expr_stmt|;
name|strings
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|LockInfo
name|info
range|:
name|locksBeingChecked
control|)
block|{
if|if
condition|(
name|info
operator|.
name|partition
operator|==
literal|null
condition|)
block|{
name|sawNull
operator|=
literal|true
expr_stmt|;
break|break;
block|}
else|else
block|{
name|strings
operator|.
name|add
argument_list|(
name|info
operator|.
name|partition
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|sawNull
condition|)
block|{
name|query
operator|.
name|append
argument_list|(
literal|" and (hl_partition is null or hl_partition in("
argument_list|)
expr_stmt|;
name|first
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|strings
control|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|false
expr_stmt|;
else|else
name|query
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
name|query
operator|.
name|append
argument_list|(
literal|"))"
argument_list|)
expr_stmt|;
block|}
block|}
name|query
operator|.
name|append
argument_list|(
literal|" and hl_lock_ext_id<= "
argument_list|)
operator|.
name|append
argument_list|(
name|extLockId
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|query
operator|.
name|toString
argument_list|()
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|query
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|SortedSet
argument_list|<
name|LockInfo
argument_list|>
name|lockSet
init|=
operator|new
name|TreeSet
argument_list|<
name|LockInfo
argument_list|>
argument_list|(
operator|new
name|LockInfoComparator
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|lockSet
operator|.
name|add
argument_list|(
operator|new
name|LockInfo
argument_list|(
name|rs
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Turn the tree set into an array so we can move back and forth easily
comment|// in it.
name|LockInfo
index|[]
name|locks
init|=
name|lockSet
operator|.
name|toArray
argument_list|(
operator|new
name|LockInfo
index|[
name|lockSet
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Locks to check(full): "
argument_list|)
expr_stmt|;
for|for
control|(
name|LockInfo
name|info
range|:
name|locks
control|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"  "
operator|+
name|info
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|LockInfo
name|info
range|:
name|locksBeingChecked
control|)
block|{
comment|// Find the lock record we're checking
name|int
name|index
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|locks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|locks
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|index
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|// If we didn't find the lock, then it must not be in the table
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"How did we get here, we heartbeated our lock before we started! ( "
operator|+
name|info
operator|+
literal|")"
argument_list|)
throw|;
block|}
comment|// If we've found it and it's already been marked acquired,
comment|// then just look at the other locks.
if|if
condition|(
name|locks
index|[
name|index
index|]
operator|.
name|state
operator|==
name|LockState
operator|.
name|ACQUIRED
condition|)
block|{
comment|/**this is what makes this method @SafeToRetry*/
continue|continue;
block|}
comment|// Look at everything in front of this lock to see if it should block
comment|// it or not.
name|boolean
name|acquired
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|index
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|// Check if we're operating on the same database, if not, move on
if|if
condition|(
operator|!
name|locks
index|[
name|index
index|]
operator|.
name|db
operator|.
name|equals
argument_list|(
name|locks
index|[
name|i
index|]
operator|.
name|db
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// If table is null on either of these, then they are claiming to
comment|// lock the whole database and we need to check it.  Otherwise,
comment|// check if they are operating on the same table, if not, move on.
if|if
condition|(
name|locks
index|[
name|index
index|]
operator|.
name|table
operator|!=
literal|null
operator|&&
name|locks
index|[
name|i
index|]
operator|.
name|table
operator|!=
literal|null
operator|&&
operator|!
name|locks
index|[
name|index
index|]
operator|.
name|table
operator|.
name|equals
argument_list|(
name|locks
index|[
name|i
index|]
operator|.
name|table
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// If partition is null on either of these, then they are claiming to
comment|// lock the whole table and we need to check it.  Otherwise,
comment|// check if they are operating on the same partition, if not, move on.
if|if
condition|(
name|locks
index|[
name|index
index|]
operator|.
name|partition
operator|!=
literal|null
operator|&&
name|locks
index|[
name|i
index|]
operator|.
name|partition
operator|!=
literal|null
operator|&&
operator|!
name|locks
index|[
name|index
index|]
operator|.
name|partition
operator|.
name|equals
argument_list|(
name|locks
index|[
name|i
index|]
operator|.
name|partition
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// We've found something that matches what we're trying to lock,
comment|// so figure out if we can lock it too.
name|LockAction
name|lockAction
init|=
name|jumpTable
operator|.
name|get
argument_list|(
name|locks
index|[
name|index
index|]
operator|.
name|type
argument_list|)
operator|.
name|get
argument_list|(
name|locks
index|[
name|i
index|]
operator|.
name|type
argument_list|)
operator|.
name|get
argument_list|(
name|locks
index|[
name|i
index|]
operator|.
name|state
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"desired Lock: "
operator|+
name|info
operator|+
literal|" checked Lock: "
operator|+
name|locks
index|[
name|i
index|]
operator|+
literal|" action: "
operator|+
name|lockAction
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lockAction
condition|)
block|{
case|case
name|WAIT
case|:
if|if
condition|(
operator|!
name|ignoreConflict
argument_list|(
name|info
argument_list|,
name|locks
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/*we acquire all locks for a given query atomically; if 1 blocks, all go into (remain) in                 * Waiting state.  wait() will undo any 'acquire()' which may have happened as part of                 * this (metastore db) transaction and then we record which lock blocked the lock                 * we were testing ('info').*/
name|wait
argument_list|(
name|dbConn
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|String
name|sqlText
init|=
literal|"update HIVE_LOCKS"
operator|+
literal|" set HL_BLOCKEDBY_EXT_ID="
operator|+
name|locks
index|[
name|i
index|]
operator|.
name|extLockId
operator|+
literal|", HL_BLOCKEDBY_INT_ID="
operator|+
name|locks
index|[
name|i
index|]
operator|.
name|intLockId
operator|+
literal|" where HL_LOCK_EXT_ID="
operator|+
name|info
operator|.
name|extLockId
operator|+
literal|" and HL_LOCK_INT_ID="
operator|+
name|info
operator|.
name|intLockId
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Executing sql: "
operator|+
name|sqlText
argument_list|)
expr_stmt|;
name|int
name|updCnt
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|sqlText
argument_list|)
decl_stmt|;
if|if
condition|(
name|updCnt
operator|!=
literal|1
condition|)
block|{
name|shouldNeverHappen
argument_list|(
name|info
operator|.
name|txnId
argument_list|,
name|info
operator|.
name|extLockId
argument_list|,
name|info
operator|.
name|intLockId
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
name|response
operator|.
name|setState
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Lock("
operator|+
name|info
operator|+
literal|") waiting for Lock("
operator|+
name|locks
index|[
name|i
index|]
operator|+
literal|")"
argument_list|)
expr_stmt|;
return|return
name|response
return|;
block|}
comment|//fall through to ACQUIRE
case|case
name|ACQUIRE
case|:
name|acquire
argument_list|(
name|dbConn
argument_list|,
name|stmt
argument_list|,
name|extLockId
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|acquired
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|KEEP_LOOKING
case|:
continue|continue;
block|}
if|if
condition|(
name|acquired
condition|)
break|break;
comment|// We've acquired this lock component,
comment|// so get out of the loop and look at the next component.
block|}
comment|// If we've arrived here and we have not already acquired, it means there's nothing in the
comment|// way of the lock, so acquire the lock.
if|if
condition|(
operator|!
name|acquired
condition|)
name|acquire
argument_list|(
name|dbConn
argument_list|,
name|stmt
argument_list|,
name|extLockId
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
comment|// We acquired all of the locks, so commit and return acquired.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
name|response
operator|.
name|setState
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|!=
literal|null
condition|)
block|{
name|handle
operator|.
name|releaseLocks
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|response
return|;
block|}
comment|/**    * the {@link #jumpTable} only deals with LockState/LockType.  In some cases it's not    * sufficient.  For example, an EXCLUSIVE lock on partition should prevent SHARED_READ    * on the table, but there is no reason for EXCLUSIVE on a table to prevent SHARED_READ    * on a database.  Similarly, EXCLUSIVE on a partition should not conflict with SHARED_READ on    * a database.  (SHARED_READ is usually acquired on a database to make sure it's not dropped    * while some operation is performed on that db (e.g. show tables, created table, etc)    * EXCLUSIVE on an object may mean it's being dropped or overwritten (for non-acid tables,    * an Insert uses EXCLUSIVE as well)).    */
specifier|private
name|boolean
name|ignoreConflict
parameter_list|(
name|LockInfo
name|desiredLock
parameter_list|,
name|LockInfo
name|existingLock
parameter_list|)
block|{
return|return
operator|(
operator|(
name|desiredLock
operator|.
name|isDbLock
argument_list|()
operator|&&
name|desiredLock
operator|.
name|type
operator|==
name|LockType
operator|.
name|SHARED_READ
operator|&&
name|existingLock
operator|.
name|isTableLock
argument_list|()
operator|&&
name|existingLock
operator|.
name|type
operator|==
name|LockType
operator|.
name|EXCLUSIVE
operator|)
operator|||
operator|(
name|existingLock
operator|.
name|isDbLock
argument_list|()
operator|&&
name|existingLock
operator|.
name|type
operator|==
name|LockType
operator|.
name|SHARED_READ
operator|&&
name|desiredLock
operator|.
name|isTableLock
argument_list|()
operator|&&
name|desiredLock
operator|.
name|type
operator|==
name|LockType
operator|.
name|EXCLUSIVE
operator|)
operator|||
operator|(
name|desiredLock
operator|.
name|isDbLock
argument_list|()
operator|&&
name|desiredLock
operator|.
name|type
operator|==
name|LockType
operator|.
name|SHARED_READ
operator|&&
name|existingLock
operator|.
name|isPartitionLock
argument_list|()
operator|&&
name|existingLock
operator|.
name|type
operator|==
name|LockType
operator|.
name|EXCLUSIVE
operator|)
operator|||
operator|(
name|existingLock
operator|.
name|isDbLock
argument_list|()
operator|&&
name|existingLock
operator|.
name|type
operator|==
name|LockType
operator|.
name|SHARED_READ
operator|&&
name|desiredLock
operator|.
name|isPartitionLock
argument_list|()
operator|&&
name|desiredLock
operator|.
name|type
operator|==
name|LockType
operator|.
name|EXCLUSIVE
operator|)
operator|)
operator|||
comment|//different locks from same txn should not conflict with each other
operator|(
name|desiredLock
operator|.
name|txnId
operator|!=
literal|0
operator|&&
name|desiredLock
operator|.
name|txnId
operator|==
name|existingLock
operator|.
name|txnId
operator|)
operator|||
comment|//txnId=0 means it's a select or IUD which does not write to ACID table, e.g
comment|//insert overwrite table T partition(p=1) select a,b from T and autoCommit=true
comment|// todo: fix comment as of HIVE-14988
operator|(
name|desiredLock
operator|.
name|txnId
operator|==
literal|0
operator|&&
name|desiredLock
operator|.
name|extLockId
operator|==
name|existingLock
operator|.
name|extLockId
operator|)
return|;
block|}
specifier|private
name|void
name|wait
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|Savepoint
name|save
parameter_list|)
throws|throws
name|SQLException
block|{
comment|// Need to rollback because we did a select that acquired locks but we didn't
comment|// actually update anything.  Also, we may have locked some locks as
comment|// acquired that we now want to not acquire.  It's ok to rollback because
comment|// once we see one wait, we're done, we won't look for more.
comment|// Only rollback to savepoint because we want to commit our heartbeat
comment|// changes.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback to savepoint"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|(
name|save
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|acquire
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|Statement
name|stmt
parameter_list|,
name|long
name|extLockId
parameter_list|,
name|LockInfo
name|lockInfo
parameter_list|)
throws|throws
name|SQLException
throws|,
name|NoSuchLockException
throws|,
name|MetaException
block|{
name|long
name|now
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|String
name|s
init|=
literal|"update HIVE_LOCKS set hl_lock_state = '"
operator|+
name|LOCK_ACQUIRED
operator|+
literal|"', "
operator|+
comment|//if lock is part of txn, heartbeat info is in txn record
literal|"hl_last_heartbeat = "
operator|+
operator|(
name|isValidTxn
argument_list|(
name|lockInfo
operator|.
name|txnId
argument_list|)
condition|?
literal|0
else|:
name|now
operator|)
operator|+
literal|", hl_acquired_at = "
operator|+
name|now
operator|+
literal|",HL_BLOCKEDBY_EXT_ID=NULL,HL_BLOCKEDBY_INT_ID=null"
operator|+
literal|" where hl_lock_ext_id = "
operator|+
name|extLockId
operator|+
literal|" and hl_lock_int_id = "
operator|+
name|lockInfo
operator|.
name|intLockId
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|NoSuchLockException
argument_list|(
literal|"No such lock: ("
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
operator|+
literal|","
operator|+
operator|+
name|lockInfo
operator|.
name|intLockId
operator|+
literal|") "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|lockInfo
operator|.
name|txnId
argument_list|)
argument_list|)
throw|;
block|}
comment|// We update the database, but we don't commit because there may be other
comment|// locks together with this, and we only want to acquire one if we can
comment|// acquire all.
block|}
comment|/**    * Heartbeats on the lock table.  This commits, so do not enter it with any state.    * Should not be called on a lock that belongs to transaction.    */
specifier|private
name|void
name|heartbeatLock
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|extLockId
parameter_list|)
throws|throws
name|NoSuchLockException
throws|,
name|SQLException
throws|,
name|MetaException
block|{
comment|// If the lock id is 0, then there are no locks in this heartbeat
if|if
condition|(
name|extLockId
operator|==
literal|0
condition|)
return|return;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|long
name|now
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|String
name|s
init|=
literal|"update HIVE_LOCKS set hl_last_heartbeat = "
operator|+
name|now
operator|+
literal|" where hl_lock_ext_id = "
operator|+
name|extLockId
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|NoSuchLockException
argument_list|(
literal|"No such lock: "
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Heartbeats on the txn table.  This commits, so do not enter it with any state
specifier|private
name|void
name|heartbeatTxn
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|txnid
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|SQLException
throws|,
name|MetaException
block|{
comment|// If the txnid is 0, then there are no transactions in this heartbeat
if|if
condition|(
name|txnid
operator|==
literal|0
condition|)
return|return;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|long
name|now
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|String
name|s
init|=
literal|"update TXNS set txn_last_heartbeat = "
operator|+
name|now
operator|+
literal|" where txn_id = "
operator|+
name|txnid
operator|+
literal|" and txn_state = '"
operator|+
name|TXN_OPEN
operator|+
literal|"'"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|<
literal|1
condition|)
block|{
name|ensureValidTxn
argument_list|(
name|dbConn
argument_list|,
name|txnid
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
comment|// This should now throw some useful exception.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Can neither heartbeat txn nor confirm it as invalid."
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|NoSuchTxnException
argument_list|(
literal|"No such txn: "
operator|+
name|txnid
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns the state of the transaction iff it's able to determine it.  Some cases where it cannot:    * 1. txnid was Aborted/Committed and then GC'd (compacted)    * 2. txnid was committed but it didn't modify anything (nothing in COMPLETED_TXN_COMPONENTS)    */
specifier|private
name|TxnStatus
name|findTxnState
parameter_list|(
name|long
name|txnid
parameter_list|,
name|Statement
name|stmt
parameter_list|)
throws|throws
name|SQLException
throws|,
name|MetaException
block|{
name|String
name|s
init|=
literal|"select txn_state from TXNS where txn_id = "
operator|+
name|txnid
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|s
operator|=
name|sqlGenerator
operator|.
name|addLimitClause
argument_list|(
literal|1
argument_list|,
literal|"1 from COMPLETED_TXN_COMPONENTS where CTC_TXNID = "
operator|+
name|txnid
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs2
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs2
operator|.
name|next
argument_list|()
condition|)
block|{
return|return
name|TxnStatus
operator|.
name|COMMITTED
return|;
block|}
comment|//could also check WRITE_SET but that seems overkill
return|return
name|TxnStatus
operator|.
name|UNKNOWN
return|;
block|}
name|char
name|txnState
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|txnState
operator|==
name|TXN_ABORTED
condition|)
block|{
return|return
name|TxnStatus
operator|.
name|ABORTED
return|;
block|}
assert|assert
name|txnState
operator|==
name|TXN_OPEN
operator|:
literal|"we found it in TXNS but it's not ABORTED, so must be OPEN"
assert|;
return|return
name|TxnStatus
operator|.
name|OPEN
return|;
block|}
comment|/**    * Used to raise an informative error when the caller expected a txn in a particular TxnStatus    * but found it in some other status    */
specifier|private
specifier|static
name|void
name|raiseTxnUnexpectedState
parameter_list|(
name|TxnStatus
name|actualStatus
parameter_list|,
name|long
name|txnid
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|TxnAbortedException
block|{
switch|switch
condition|(
name|actualStatus
condition|)
block|{
case|case
name|ABORTED
case|:
throw|throw
operator|new
name|TxnAbortedException
argument_list|(
literal|"Transaction "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
operator|+
literal|" already aborted"
argument_list|)
throw|;
case|case
name|COMMITTED
case|:
throw|throw
operator|new
name|NoSuchTxnException
argument_list|(
literal|"Transaction "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
operator|+
literal|" is already committed."
argument_list|)
throw|;
case|case
name|UNKNOWN
case|:
throw|throw
operator|new
name|NoSuchTxnException
argument_list|(
literal|"No such transaction "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
argument_list|)
throw|;
case|case
name|OPEN
case|:
throw|throw
operator|new
name|NoSuchTxnException
argument_list|(
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
operator|+
literal|" is "
operator|+
name|TxnStatus
operator|.
name|OPEN
argument_list|)
throw|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown TxnStatus "
operator|+
name|actualStatus
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns the state of the transaction with {@code txnid} or throws if {@code raiseError} is true.    */
specifier|private
specifier|static
name|void
name|ensureValidTxn
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|txnid
parameter_list|,
name|Statement
name|stmt
parameter_list|)
throws|throws
name|SQLException
throws|,
name|NoSuchTxnException
throws|,
name|TxnAbortedException
block|{
comment|// We need to check whether this transaction is valid and open
name|String
name|s
init|=
literal|"select txn_state from TXNS where txn_id = "
operator|+
name|txnid
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
comment|//todo: add LIMIT 1 instead of count - should be more efficient
name|s
operator|=
literal|"select count(*) from COMPLETED_TXN_COMPONENTS where CTC_TXNID = "
operator|+
name|txnid
expr_stmt|;
name|ResultSet
name|rs2
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
comment|//todo: strictly speaking you can commit an empty txn, thus 2nd conjunct is wrong but only
comment|//possible for for multi-stmt txns
name|boolean
name|alreadyCommitted
init|=
name|rs2
operator|.
name|next
argument_list|()
operator|&&
name|rs2
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
operator|>
literal|0
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
if|if
condition|(
name|alreadyCommitted
condition|)
block|{
comment|//makes the message more informative - helps to find bugs in client code
throw|throw
operator|new
name|NoSuchTxnException
argument_list|(
literal|"Transaction "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
operator|+
literal|" is already committed."
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|NoSuchTxnException
argument_list|(
literal|"No such transaction "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|TXN_ABORTED
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|TxnAbortedException
argument_list|(
literal|"Transaction "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
operator|+
literal|" already aborted"
argument_list|)
throw|;
comment|//todo: add time of abort, which is not currently tracked.  Requires schema change
block|}
block|}
specifier|private
name|LockInfo
name|getTxnIdFromLockId
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|extLockId
parameter_list|)
throws|throws
name|NoSuchLockException
throws|,
name|MetaException
throws|,
name|SQLException
block|{
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select hl_lock_ext_id, hl_lock_int_id, hl_db, hl_table, "
operator|+
literal|"hl_partition, hl_lock_state, hl_lock_type, hl_txnid from HIVE_LOCKS where "
operator|+
literal|"hl_lock_ext_id = "
operator|+
name|extLockId
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|LockInfo
name|info
init|=
operator|new
name|LockInfo
argument_list|(
name|rs
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"getTxnIdFromLockId("
operator|+
name|extLockId
operator|+
literal|") Return "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|info
operator|.
name|txnId
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|info
return|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
comment|// NEVER call this function without first calling heartbeat(long, long)
specifier|private
name|List
argument_list|<
name|LockInfo
argument_list|>
name|getLockInfoFromLockId
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|extLockId
parameter_list|)
throws|throws
name|NoSuchLockException
throws|,
name|MetaException
throws|,
name|SQLException
block|{
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select hl_lock_ext_id, hl_lock_int_id, hl_db, hl_table, "
operator|+
literal|"hl_partition, hl_lock_state, hl_lock_type, hl_txnid from HIVE_LOCKS where "
operator|+
literal|"hl_lock_ext_id = "
operator|+
name|extLockId
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|boolean
name|sawAtLeastOne
init|=
literal|false
decl_stmt|;
name|List
argument_list|<
name|LockInfo
argument_list|>
name|ourLockInfo
init|=
operator|new
name|ArrayList
argument_list|<
name|LockInfo
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|ourLockInfo
operator|.
name|add
argument_list|(
operator|new
name|LockInfo
argument_list|(
name|rs
argument_list|)
argument_list|)
expr_stmt|;
name|sawAtLeastOne
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sawAtLeastOne
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"This should never happen!  We already "
operator|+
literal|"checked the lock("
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
operator|+
literal|") existed but now we can't find it!"
argument_list|)
throw|;
block|}
return|return
name|ourLockInfo
return|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Clean time out locks from the database not associated with a transactions, i.e. locks
comment|// for read-only autoCommit=true statements.  This does a commit,
comment|// and thus should be done before any calls to heartbeat that will leave
comment|// open transactions.
specifier|private
name|void
name|timeOutLocks
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|now
parameter_list|)
block|{
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|long
name|maxHeartbeatTime
init|=
name|now
operator|-
name|timeout
decl_stmt|;
comment|//doing a SELECT first is less efficient but makes it easier to debug things
name|String
name|s
init|=
literal|"select distinct hl_lock_ext_id from HIVE_LOCKS where hl_last_heartbeat< "
operator|+
name|maxHeartbeatTime
operator|+
literal|" and hl_txnid = 0"
decl_stmt|;
comment|//when txnid is<> 0, the lock is
comment|//associated with a txn and is handled by performTimeOuts()
comment|//want to avoid expiring locks for a txn w/o expiring the txn itself
name|List
argument_list|<
name|Long
argument_list|>
name|extLockIDs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|extLockIDs
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rs
operator|.
name|close
argument_list|()
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
if|if
condition|(
name|extLockIDs
operator|.
name|size
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|queries
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|prefix
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|StringBuilder
name|suffix
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|//include same hl_last_heartbeat condition in case someone heartbeated since the select
name|prefix
operator|.
name|append
argument_list|(
literal|"delete from HIVE_LOCKS where hl_last_heartbeat< "
argument_list|)
expr_stmt|;
name|prefix
operator|.
name|append
argument_list|(
name|maxHeartbeatTime
argument_list|)
expr_stmt|;
name|prefix
operator|.
name|append
argument_list|(
literal|" and hl_txnid = 0 and "
argument_list|)
expr_stmt|;
name|suffix
operator|.
name|append
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|TxnUtils
operator|.
name|buildQueryWithINClause
argument_list|(
name|conf
argument_list|,
name|queries
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|,
name|extLockIDs
argument_list|,
literal|"hl_lock_ext_id"
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|int
name|deletedLocks
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|query
range|:
name|queries
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing expired locks via: "
operator|+
name|query
argument_list|)
expr_stmt|;
name|deletedLocks
operator|+=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deletedLocks
operator|>
literal|0
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|extLockIDs
argument_list|)
expr_stmt|;
comment|//easier to read logs
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleted "
operator|+
name|deletedLocks
operator|+
literal|" int locks from HIVE_LOCKS due to timeout ("
operator|+
literal|"HL_LOCK_EXT_ID list:  "
operator|+
name|extLockIDs
operator|+
literal|") maxHeartbeatTime="
operator|+
name|maxHeartbeatTime
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to purge timedout locks due to: "
operator|+
name|getMessage
argument_list|(
name|ex
argument_list|)
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to purge timedout locks due to: "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Isolation Level Notes    * Plain: RC is OK    * This will find transactions that have timed out and abort them.    * Will also delete locks which are not associated with a transaction and have timed out    * Tries to keep transactions (against metastore db) small to reduce lock contention.    */
annotation|@
name|RetrySemantics
operator|.
name|Idempotent
specifier|public
name|void
name|performTimeOuts
parameter_list|()
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
comment|//We currently commit after selecting the TXNS to abort.  So whether SERIALIZABLE
comment|//READ_COMMITTED, the effect is the same.  We could use FOR UPDATE on Select from TXNS
comment|//and do the whole performTimeOuts() in a single huge transaction, but the only benefit
comment|//would be to make sure someone cannot heartbeat one of these txns at the same time.
comment|//The attempt to heartbeat would block and fail immediately after it's unblocked.
comment|//With current (RC + multiple txns) implementation it is possible for someone to send
comment|//heartbeat at the very end of the expire interval, and just after the Select from TXNS
comment|//is made, in which case heartbeat will succeed but txn will still be Aborted.
comment|//Solving this corner case is not worth the perf penalty.  The client should heartbeat in a
comment|//timely way.
name|long
name|now
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|timeOutLocks
argument_list|(
name|dbConn
argument_list|,
name|now
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|" txn_id from TXNS where txn_state = '"
operator|+
name|TXN_OPEN
operator|+
literal|"' and txn_last_heartbeat<  "
operator|+
operator|(
name|now
operator|-
name|timeout
operator|)
decl_stmt|;
comment|//safety valve for extreme cases
name|s
operator|=
name|sqlGenerator
operator|.
name|addLimitClause
argument_list|(
literal|10
operator|*
name|TIMED_OUT_TXN_ABORT_BATCH_SIZE
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
return|return;
comment|//no more timedout txns
block|}
name|List
argument_list|<
name|List
argument_list|<
name|Long
argument_list|>
argument_list|>
name|timedOutTxns
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|currentBatch
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|TIMED_OUT_TXN_ABORT_BATCH_SIZE
argument_list|)
decl_stmt|;
name|timedOutTxns
operator|.
name|add
argument_list|(
name|currentBatch
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|currentBatch
operator|.
name|size
argument_list|()
operator|==
name|TIMED_OUT_TXN_ABORT_BATCH_SIZE
condition|)
block|{
name|currentBatch
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|TIMED_OUT_TXN_ABORT_BATCH_SIZE
argument_list|)
expr_stmt|;
name|timedOutTxns
operator|.
name|add
argument_list|(
name|currentBatch
argument_list|)
expr_stmt|;
block|}
name|currentBatch
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
do|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|int
name|numTxnsAborted
init|=
literal|0
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|Long
argument_list|>
name|batchToAbort
range|:
name|timedOutTxns
control|)
block|{
if|if
condition|(
name|abortTxns
argument_list|(
name|dbConn
argument_list|,
name|batchToAbort
argument_list|,
name|now
operator|-
name|timeout
argument_list|,
literal|true
argument_list|)
operator|==
name|batchToAbort
operator|.
name|size
argument_list|()
condition|)
block|{
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
name|numTxnsAborted
operator|+=
name|batchToAbort
operator|.
name|size
argument_list|()
expr_stmt|;
comment|//todo: add TXNS.COMMENT filed and set it to 'aborted by system due to timeout'
name|Collections
operator|.
name|sort
argument_list|(
name|batchToAbort
argument_list|)
expr_stmt|;
comment|//easier to read logs
name|LOG
operator|.
name|info
argument_list|(
literal|"Aborted the following transactions due to timeout: "
operator|+
name|batchToAbort
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//could not abort all txns in this batch - this may happen because in parallel with this
comment|//operation there was activity on one of the txns in this batch (commit/abort/heartbeat)
comment|//This is not likely but may happen if client experiences long pause between heartbeats or
comment|//unusually long/extreme pauses between heartbeat() calls and other logic in checkLock(),
comment|//lock(), etc.
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Aborted "
operator|+
name|numTxnsAborted
operator|+
literal|" transactions due to timeout"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Aborting timedout transactions failed due to "
operator|+
name|getMessage
argument_list|(
name|ex
argument_list|)
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MetaException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Aborting timedout transactions failed due to "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|ReadOnly
specifier|public
name|void
name|countOpenTxns
parameter_list|()
throws|throws
name|MetaException
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select count(*) from TXNS where txn_state = '"
operator|+
name|TXN_OPEN
operator|+
literal|"'"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Transaction database not properly configured, "
operator|+
literal|"can't find txn_state from TXNS."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|numOpenTxns
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to update number of open transactions"
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"countOpenTxns()"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|countOpenTxns
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
specifier|synchronized
name|void
name|setupJdbcConnectionPool
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|SQLException
block|{
if|if
condition|(
name|connPool
operator|!=
literal|null
condition|)
return|return;
name|String
name|driverUrl
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTORECONNECTURLKEY
argument_list|)
decl_stmt|;
name|String
name|user
init|=
name|getMetastoreJdbcUser
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|String
name|passwd
init|=
name|getMetastoreJdbcPasswd
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|String
name|connectionPooler
init|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTORE_CONNECTION_POOLING_TYPE
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
if|if
condition|(
literal|"bonecp"
operator|.
name|equals
argument_list|(
name|connectionPooler
argument_list|)
condition|)
block|{
name|BoneCPConfig
name|config
init|=
operator|new
name|BoneCPConfig
argument_list|()
decl_stmt|;
name|config
operator|.
name|setJdbcUrl
argument_list|(
name|driverUrl
argument_list|)
expr_stmt|;
comment|//if we are waiting for connection for 60s, something is really wrong
comment|//better raise an error than hang forever
name|config
operator|.
name|setConnectionTimeoutInMs
argument_list|(
literal|60000
argument_list|)
expr_stmt|;
name|config
operator|.
name|setMaxConnectionsPerPartition
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|config
operator|.
name|setPartitionCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|config
operator|.
name|setUser
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|config
operator|.
name|setPassword
argument_list|(
name|passwd
argument_list|)
expr_stmt|;
name|connPool
operator|=
operator|new
name|BoneCPDataSource
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|doRetryOnConnPool
operator|=
literal|true
expr_stmt|;
comment|// Enable retries to work around BONECP bug.
block|}
elseif|else
if|if
condition|(
literal|"dbcp"
operator|.
name|equals
argument_list|(
name|connectionPooler
argument_list|)
condition|)
block|{
name|ObjectPool
name|objectPool
init|=
operator|new
name|GenericObjectPool
argument_list|()
decl_stmt|;
name|ConnectionFactory
name|connFactory
init|=
operator|new
name|DriverManagerConnectionFactory
argument_list|(
name|driverUrl
argument_list|,
name|user
argument_list|,
name|passwd
argument_list|)
decl_stmt|;
comment|// This doesn't get used, but it's still necessary, see
comment|// http://svn.apache.org/viewvc/commons/proper/dbcp/branches/DBCP_1_4_x_BRANCH/doc/ManualPoolingDataSourceExample.java?view=markup
name|PoolableConnectionFactory
name|poolConnFactory
init|=
operator|new
name|PoolableConnectionFactory
argument_list|(
name|connFactory
argument_list|,
name|objectPool
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|connPool
operator|=
operator|new
name|PoolingDataSource
argument_list|(
name|objectPool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"hikaricp"
operator|.
name|equals
argument_list|(
name|connectionPooler
argument_list|)
condition|)
block|{
name|HikariConfig
name|config
init|=
operator|new
name|HikariConfig
argument_list|()
decl_stmt|;
name|config
operator|.
name|setJdbcUrl
argument_list|(
name|driverUrl
argument_list|)
expr_stmt|;
name|config
operator|.
name|setUsername
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|config
operator|.
name|setPassword
argument_list|(
name|passwd
argument_list|)
expr_stmt|;
name|connPool
operator|=
operator|new
name|HikariDataSource
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"none"
operator|.
name|equals
argument_list|(
name|connectionPooler
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Choosing not to pool JDBC connections"
argument_list|)
expr_stmt|;
name|connPool
operator|=
operator|new
name|NoPoolConnectionPool
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown JDBC connection pooling "
operator|+
name|connectionPooler
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
specifier|synchronized
name|void
name|buildJumpTable
parameter_list|()
block|{
if|if
condition|(
name|jumpTable
operator|!=
literal|null
condition|)
return|return;
name|jumpTable
operator|=
operator|new
name|HashMap
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
argument_list|>
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|// SR: Lock we are trying to acquire is shared read
name|Map
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
name|m
init|=
operator|new
name|HashMap
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|jumpTable
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_READ
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|// SR.SR: Lock we are examining is shared read
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
name|m2
init|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_READ
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// SR.SR.acquired Lock we are examining is acquired;  We can acquire
comment|// because two shared reads can acquire together and there must be
comment|// nothing in front of this one to prevent acquisition.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|ACQUIRE
argument_list|)
expr_stmt|;
comment|// SR.SR.wait Lock we are examining is waiting.  In this case we keep
comment|// looking, as it's possible that something in front is blocking it or
comment|// that the other locker hasn't checked yet and he could lock as well.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|KEEP_LOOKING
argument_list|)
expr_stmt|;
comment|// SR.SW: Lock we are examining is shared write
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_WRITE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// SR.SW.acquired Lock we are examining is acquired;  We can acquire
comment|// because a read can share with a write, and there must be
comment|// nothing in front of this one to prevent acquisition.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|ACQUIRE
argument_list|)
expr_stmt|;
comment|// SR.SW.wait Lock we are examining is waiting.  In this case we keep
comment|// looking, as it's possible that something in front is blocking it or
comment|// that the other locker hasn't checked yet and he could lock as well or
comment|// that something is blocking it that would not block a read.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|KEEP_LOOKING
argument_list|)
expr_stmt|;
comment|// SR.E: Lock we are examining is exclusive
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|EXCLUSIVE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// No matter whether it has acquired or not, we cannot pass an exclusive.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
comment|// SW: Lock we are trying to acquire is shared write
name|m
operator|=
operator|new
name|HashMap
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|jumpTable
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_WRITE
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|// SW.SR: Lock we are examining is shared read
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_READ
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// SW.SR.acquired Lock we are examining is acquired;  We need to keep
comment|// looking, because there may or may not be another shared write in front
comment|// that would block us.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|KEEP_LOOKING
argument_list|)
expr_stmt|;
comment|// SW.SR.wait Lock we are examining is waiting.  In this case we keep
comment|// looking, as it's possible that something in front is blocking it or
comment|// that the other locker hasn't checked yet and he could lock as well.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|KEEP_LOOKING
argument_list|)
expr_stmt|;
comment|// SW.SW: Lock we are examining is shared write
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_WRITE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// Regardless of acquired or waiting, one shared write cannot pass another.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
comment|// SW.E: Lock we are examining is exclusive
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|EXCLUSIVE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// No matter whether it has acquired or not, we cannot pass an exclusive.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
comment|// E: Lock we are trying to acquire is exclusive
name|m
operator|=
operator|new
name|HashMap
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|jumpTable
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|EXCLUSIVE
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|// E.SR: Lock we are examining is shared read
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_READ
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// Exclusives can never pass
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
comment|// E.SW: Lock we are examining is shared write
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_WRITE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// Exclusives can never pass
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
comment|// E.E: Lock we are examining is exclusive
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|EXCLUSIVE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// No matter whether it has acquired or not, we cannot pass an exclusive.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns true if {@code ex} should be retried    */
specifier|static
name|boolean
name|isRetryable
parameter_list|(
name|HiveConf
name|conf
parameter_list|,
name|Exception
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ex
operator|instanceof
name|SQLException
condition|)
block|{
name|SQLException
name|sqlException
init|=
operator|(
name|SQLException
operator|)
name|ex
decl_stmt|;
if|if
condition|(
literal|"08S01"
operator|.
name|equalsIgnoreCase
argument_list|(
name|sqlException
operator|.
name|getSQLState
argument_list|()
argument_list|)
condition|)
block|{
comment|//in MSSQL this means Communication Link Failure
return|return
literal|true
return|;
block|}
if|if
condition|(
literal|"ORA-08176"
operator|.
name|equalsIgnoreCase
argument_list|(
name|sqlException
operator|.
name|getSQLState
argument_list|()
argument_list|)
operator|||
name|sqlException
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"consistent read failure; rollback data not available"
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|String
name|regex
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_TXN_RETRYABLE_SQLEX_REGEX
argument_list|)
decl_stmt|;
if|if
condition|(
name|regex
operator|!=
literal|null
operator|&&
operator|!
name|regex
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
index|[]
name|patterns
init|=
name|regex
operator|.
name|split
argument_list|(
literal|",(?=\\S)"
argument_list|)
decl_stmt|;
name|String
name|message
init|=
name|getMessage
argument_list|(
operator|(
name|SQLException
operator|)
name|ex
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|p
range|:
name|patterns
control|)
block|{
if|if
condition|(
name|Pattern
operator|.
name|matches
argument_list|(
name|p
argument_list|,
name|message
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
comment|//see also https://issues.apache.org/jira/browse/HIVE-9938
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|isDuplicateKeyError
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
switch|switch
condition|(
name|dbProduct
condition|)
block|{
case|case
name|DERBY
case|:
if|if
condition|(
literal|"23505"
operator|.
name|equals
argument_list|(
name|ex
operator|.
name|getSQLState
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
break|break;
case|case
name|MYSQL
case|:
comment|//https://dev.mysql.com/doc/refman/5.5/en/error-messages-server.html
if|if
condition|(
operator|(
name|ex
operator|.
name|getErrorCode
argument_list|()
operator|==
literal|1022
operator|||
name|ex
operator|.
name|getErrorCode
argument_list|()
operator|==
literal|1062
operator|||
name|ex
operator|.
name|getErrorCode
argument_list|()
operator|==
literal|1586
operator|)
operator|&&
literal|"23000"
operator|.
name|equals
argument_list|(
name|ex
operator|.
name|getSQLState
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
break|break;
case|case
name|SQLSERVER
case|:
comment|//2627 is unique constaint violation incl PK, 2601 - unique key
if|if
condition|(
name|ex
operator|.
name|getErrorCode
argument_list|()
operator|==
literal|2627
operator|&&
literal|"23000"
operator|.
name|equals
argument_list|(
name|ex
operator|.
name|getSQLState
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
break|break;
case|case
name|ORACLE
case|:
if|if
condition|(
name|ex
operator|.
name|getErrorCode
argument_list|()
operator|==
literal|1
operator|&&
literal|"23000"
operator|.
name|equals
argument_list|(
name|ex
operator|.
name|getSQLState
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
break|break;
case|case
name|POSTGRES
case|:
comment|//http://www.postgresql.org/docs/8.1/static/errcodes-appendix.html
if|if
condition|(
literal|"23505"
operator|.
name|equals
argument_list|(
name|ex
operator|.
name|getSQLState
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unexpected DB type: "
operator|+
name|dbProduct
operator|+
literal|"; "
operator|+
name|getMessage
argument_list|(
name|ex
argument_list|)
argument_list|)
throw|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
specifier|static
name|String
name|getMessage
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
return|return
name|ex
operator|.
name|getMessage
argument_list|()
operator|+
literal|" (SQLState="
operator|+
name|ex
operator|.
name|getSQLState
argument_list|()
operator|+
literal|", ErrorCode="
operator|+
name|ex
operator|.
name|getErrorCode
argument_list|()
operator|+
literal|")"
return|;
block|}
comment|/**    * Useful for building SQL strings    * @param value may be {@code null}    */
specifier|private
specifier|static
name|String
name|valueOrNullLiteral
parameter_list|(
name|String
name|value
parameter_list|)
block|{
return|return
name|value
operator|==
literal|null
condition|?
literal|"null"
else|:
name|quoteString
argument_list|(
name|value
argument_list|)
return|;
block|}
specifier|static
name|String
name|quoteString
parameter_list|(
name|String
name|input
parameter_list|)
block|{
return|return
literal|"'"
operator|+
name|input
operator|+
literal|"'"
return|;
block|}
specifier|static
name|String
name|quoteChar
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
literal|"'"
operator|+
name|c
operator|+
literal|"'"
return|;
block|}
specifier|static
name|CompactionType
name|dbCompactionType2ThriftType
parameter_list|(
name|char
name|dbValue
parameter_list|)
block|{
switch|switch
condition|(
name|dbValue
condition|)
block|{
case|case
name|MAJOR_TYPE
case|:
return|return
name|CompactionType
operator|.
name|MAJOR
return|;
case|case
name|MINOR_TYPE
case|:
return|return
name|CompactionType
operator|.
name|MINOR
return|;
default|default:
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected compaction type "
operator|+
name|dbValue
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
specifier|static
name|Character
name|thriftCompactionType2DbType
parameter_list|(
name|CompactionType
name|ct
parameter_list|)
block|{
switch|switch
condition|(
name|ct
condition|)
block|{
case|case
name|MAJOR
case|:
return|return
name|MAJOR_TYPE
return|;
case|case
name|MINOR
case|:
return|return
name|MINOR_TYPE
return|;
default|default:
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected compaction type "
operator|+
name|ct
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * {@link #lockInternal()} and {@link #unlockInternal()} are used to serialize those operations that require    * Select ... For Update to sequence operations properly.  In practice that means when running    * with Derby database.  See more notes at class level.    */
specifier|private
name|void
name|lockInternal
parameter_list|()
block|{
if|if
condition|(
name|dbProduct
operator|==
name|DatabaseProduct
operator|.
name|DERBY
condition|)
block|{
name|derbyLock
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|unlockInternal
parameter_list|()
block|{
if|if
condition|(
name|dbProduct
operator|==
name|DatabaseProduct
operator|.
name|DERBY
condition|)
block|{
name|derbyLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|Idempotent
specifier|public
name|MutexAPI
name|getMutexAPI
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|LockHandle
name|acquireLock
parameter_list|(
name|String
name|key
parameter_list|)
throws|throws
name|MetaException
block|{
comment|/**      * The implementation here is a bit kludgey but done so that code exercised by unit tests      * (which run against Derby which has no support for select for update) is as similar to      * production code as possible.      * In particular, with Derby we always run in a single process with a single metastore and      * the absence of For Update is handled via a Semaphore.  The later would strictly speaking      * make the SQL statements below unnecessary (for Derby), but then they would not be tested.      */
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|String
name|sqlStmt
init|=
name|sqlGenerator
operator|.
name|addForUpdateClause
argument_list|(
literal|"select MT_COMMENT from AUX_TABLE where MT_KEY1="
operator|+
name|quoteString
argument_list|(
name|key
argument_list|)
operator|+
literal|" and MT_KEY2=0"
argument_list|)
decl_stmt|;
name|lockInternal
argument_list|()
expr_stmt|;
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"About to execute SQL: "
operator|+
name|sqlStmt
argument_list|)
expr_stmt|;
block|}
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|sqlStmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
try|try
block|{
name|stmt
operator|.
name|executeUpdate
argument_list|(
literal|"insert into AUX_TABLE(MT_KEY1,MT_KEY2) values("
operator|+
name|quoteString
argument_list|(
name|key
argument_list|)
operator|+
literal|", 0)"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isDuplicateKeyError
argument_list|(
name|ex
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unable to lock "
operator|+
name|quoteString
argument_list|(
name|key
argument_list|)
operator|+
literal|" due to: "
operator|+
name|getMessage
argument_list|(
name|ex
argument_list|)
argument_list|,
name|ex
argument_list|)
throw|;
block|}
comment|//if here, it means a concrurrent acquireLock() inserted the 'key'
comment|//rollback is done for the benefit of Postgres which throws (SQLState=25P02, ErrorCode=0) if
comment|//you attempt any stmt in a txn which had an error.
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|sqlStmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to lock "
operator|+
name|quoteString
argument_list|(
name|key
argument_list|)
operator|+
literal|".  Expected row in AUX_TABLE is missing."
argument_list|)
throw|;
block|}
block|}
name|Semaphore
name|derbySemaphore
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|dbProduct
operator|==
name|DatabaseProduct
operator|.
name|DERBY
condition|)
block|{
name|derbyKey2Lock
operator|.
name|putIfAbsent
argument_list|(
name|key
argument_list|,
operator|new
name|Semaphore
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|derbySemaphore
operator|=
name|derbyKey2Lock
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|derbySemaphore
operator|.
name|acquire
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
name|quoteString
argument_list|(
name|key
argument_list|)
operator|+
literal|" locked by "
operator|+
name|quoteString
argument_list|(
name|TxnHandler
operator|.
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
comment|//OK, so now we have a lock
return|return
operator|new
name|LockHandleImpl
argument_list|(
name|dbConn
argument_list|,
name|stmt
argument_list|,
name|rs
argument_list|,
name|key
argument_list|,
name|derbySemaphore
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|ex
argument_list|,
literal|"acquireLock("
operator|+
name|key
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to lock "
operator|+
name|quoteString
argument_list|(
name|key
argument_list|)
operator|+
literal|" due to: "
operator|+
name|getMessage
argument_list|(
name|ex
argument_list|)
operator|+
literal|"; "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ex
argument_list|)
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to lock "
operator|+
name|quoteString
argument_list|(
name|key
argument_list|)
operator|+
literal|" due to: "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ex
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|unlockInternal
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|ex
parameter_list|)
block|{
return|return
name|acquireLock
argument_list|(
name|key
argument_list|)
return|;
block|}
block|}
specifier|public
name|void
name|acquireLock
parameter_list|(
name|String
name|key
parameter_list|,
name|LockHandle
name|handle
parameter_list|)
block|{
comment|//the idea is that this will use LockHandle.dbConn
throw|throw
operator|new
name|NotImplementedException
argument_list|()
throw|;
block|}
specifier|private
specifier|static
specifier|final
class|class
name|LockHandleImpl
implements|implements
name|LockHandle
block|{
specifier|private
specifier|final
name|Connection
name|dbConn
decl_stmt|;
specifier|private
specifier|final
name|Statement
name|stmt
decl_stmt|;
specifier|private
specifier|final
name|ResultSet
name|rs
decl_stmt|;
specifier|private
specifier|final
name|Semaphore
name|derbySemaphore
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|keys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|LockHandleImpl
parameter_list|(
name|Connection
name|conn
parameter_list|,
name|Statement
name|stmt
parameter_list|,
name|ResultSet
name|rs
parameter_list|,
name|String
name|key
parameter_list|,
name|Semaphore
name|derbySemaphore
parameter_list|)
block|{
name|this
operator|.
name|dbConn
operator|=
name|conn
expr_stmt|;
name|this
operator|.
name|stmt
operator|=
name|stmt
expr_stmt|;
name|this
operator|.
name|rs
operator|=
name|rs
expr_stmt|;
name|this
operator|.
name|derbySemaphore
operator|=
name|derbySemaphore
expr_stmt|;
if|if
condition|(
name|derbySemaphore
operator|!=
literal|null
condition|)
block|{
comment|//oterwise it may later release permit acquired by someone else
assert|assert
name|derbySemaphore
operator|.
name|availablePermits
argument_list|()
operator|==
literal|0
operator|:
literal|"Expected locked Semaphore"
assert|;
block|}
name|keys
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
name|void
name|addKey
parameter_list|(
name|String
name|key
parameter_list|)
block|{
comment|//keys.add(key);
comment|//would need a list of (stmt,rs) pairs - 1 for each key
throw|throw
operator|new
name|NotImplementedException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|releaseLocks
parameter_list|()
block|{
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
if|if
condition|(
name|derbySemaphore
operator|!=
literal|null
condition|)
block|{
name|derbySemaphore
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|String
name|key
range|:
name|keys
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|quoteString
argument_list|(
name|key
argument_list|)
operator|+
literal|" unlocked by "
operator|+
name|quoteString
argument_list|(
name|TxnHandler
operator|.
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Helper class that generates SQL queries with syntax specific to target DB    * todo: why throw MetaException?    */
annotation|@
name|VisibleForTesting
specifier|static
specifier|final
class|class
name|SQLGenerator
block|{
specifier|private
specifier|final
name|DatabaseProduct
name|dbProduct
decl_stmt|;
specifier|private
specifier|final
name|HiveConf
name|conf
decl_stmt|;
name|SQLGenerator
parameter_list|(
name|DatabaseProduct
name|dbProduct
parameter_list|,
name|HiveConf
name|conf
parameter_list|)
block|{
name|this
operator|.
name|dbProduct
operator|=
name|dbProduct
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
block|}
comment|/**      * Genereates "Insert into T(a,b,c) values(1,2,'f'),(3,4,'c')" for appropriate DB      * @param tblColumns e.g. "T(a,b,c)"      * @param rows e.g. list of Strings like 3,4,'d'      * @return fully formed INSERT INTO ... statements      */
name|List
argument_list|<
name|String
argument_list|>
name|createInsertValuesStmt
parameter_list|(
name|String
name|tblColumns
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|rows
parameter_list|)
block|{
if|if
condition|(
name|rows
operator|==
literal|null
operator|||
name|rows
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|insertStmts
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|dbProduct
condition|)
block|{
case|case
name|ORACLE
case|:
if|if
condition|(
name|rows
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|//http://www.oratable.com/oracle-insert-all/
comment|//https://livesql.oracle.com/apex/livesql/file/content_BM1LJQ87M5CNIOKPOWPV6ZGR3.html
for|for
control|(
name|int
name|numRows
init|=
literal|0
init|;
name|numRows
operator|<
name|rows
operator|.
name|size
argument_list|()
condition|;
name|numRows
operator|++
control|)
block|{
if|if
condition|(
name|numRows
operator|%
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTORE_DIRECT_SQL_MAX_ELEMENTS_VALUES_CLAUSE
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|numRows
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" select * from dual"
argument_list|)
expr_stmt|;
name|insertStmts
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"insert all "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"into "
argument_list|)
operator|.
name|append
argument_list|(
name|tblColumns
argument_list|)
operator|.
name|append
argument_list|(
literal|" values("
argument_list|)
operator|.
name|append
argument_list|(
name|rows
operator|.
name|get
argument_list|(
name|numRows
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|") "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"select * from dual"
argument_list|)
expr_stmt|;
name|insertStmts
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|insertStmts
return|;
block|}
comment|//fall through
case|case
name|DERBY
case|:
case|case
name|MYSQL
case|:
case|case
name|POSTGRES
case|:
case|case
name|SQLSERVER
case|:
for|for
control|(
name|int
name|numRows
init|=
literal|0
init|;
name|numRows
operator|<
name|rows
operator|.
name|size
argument_list|()
condition|;
name|numRows
operator|++
control|)
block|{
if|if
condition|(
name|numRows
operator|%
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTORE_DIRECT_SQL_MAX_ELEMENTS_VALUES_CLAUSE
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|numRows
operator|>
literal|0
condition|)
block|{
name|insertStmts
operator|.
name|add
argument_list|(
name|sb
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|//exclude trailing comma
block|}
name|sb
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"insert into "
argument_list|)
operator|.
name|append
argument_list|(
name|tblColumns
argument_list|)
operator|.
name|append
argument_list|(
literal|" values"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|'('
argument_list|)
operator|.
name|append
argument_list|(
name|rows
operator|.
name|get
argument_list|(
name|numRows
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"),"
argument_list|)
expr_stmt|;
block|}
name|insertStmts
operator|.
name|add
argument_list|(
name|sb
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|//exclude trailing comma
return|return
name|insertStmts
return|;
default|default:
name|String
name|msg
init|=
literal|"Unrecognized database product name<"
operator|+
name|dbProduct
operator|+
literal|">"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
comment|/**      * Given a {@code selectStatement}, decorated it with FOR UPDATE or semantically equivalent      * construct.  If the DB doesn't support, return original select.      */
name|String
name|addForUpdateClause
parameter_list|(
name|String
name|selectStatement
parameter_list|)
throws|throws
name|MetaException
block|{
switch|switch
condition|(
name|dbProduct
condition|)
block|{
case|case
name|DERBY
case|:
comment|//https://db.apache.org/derby/docs/10.1/ref/rrefsqlj31783.html
comment|//sadly in Derby, FOR UPDATE doesn't meant what it should
return|return
name|selectStatement
return|;
case|case
name|MYSQL
case|:
comment|//http://dev.mysql.com/doc/refman/5.7/en/select.html
case|case
name|ORACLE
case|:
comment|//https://docs.oracle.com/cd/E17952_01/refman-5.6-en/select.html
case|case
name|POSTGRES
case|:
comment|//http://www.postgresql.org/docs/9.0/static/sql-select.html
return|return
name|selectStatement
operator|+
literal|" for update"
return|;
case|case
name|SQLSERVER
case|:
comment|//https://msdn.microsoft.com/en-us/library/ms189499.aspx
comment|//https://msdn.microsoft.com/en-us/library/ms187373.aspx
name|String
name|modifier
init|=
literal|" with (updlock)"
decl_stmt|;
name|int
name|wherePos
init|=
name|selectStatement
operator|.
name|toUpperCase
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|" WHERE "
argument_list|)
decl_stmt|;
if|if
condition|(
name|wherePos
operator|<
literal|0
condition|)
block|{
return|return
name|selectStatement
operator|+
name|modifier
return|;
block|}
return|return
name|selectStatement
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|wherePos
argument_list|)
operator|+
name|modifier
operator|+
name|selectStatement
operator|.
name|substring
argument_list|(
name|wherePos
argument_list|,
name|selectStatement
operator|.
name|length
argument_list|()
argument_list|)
return|;
default|default:
name|String
name|msg
init|=
literal|"Unrecognized database product name<"
operator|+
name|dbProduct
operator|+
literal|">"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
comment|/**      * Suppose you have a query "select a,b from T" and you want to limit the result set      * to the first 5 rows.  The mechanism to do that differs in different DBs.      * Make {@code noSelectsqlQuery} to be "a,b from T" and this method will return the      * appropriately modified row limiting query.      *      * Note that if {@code noSelectsqlQuery} contains a join, you must make sure that      * all columns are unique for Oracle.      */
specifier|private
name|String
name|addLimitClause
parameter_list|(
name|int
name|numRows
parameter_list|,
name|String
name|noSelectsqlQuery
parameter_list|)
throws|throws
name|MetaException
block|{
switch|switch
condition|(
name|dbProduct
condition|)
block|{
case|case
name|DERBY
case|:
comment|//http://db.apache.org/derby/docs/10.7/ref/rrefsqljoffsetfetch.html
return|return
literal|"select "
operator|+
name|noSelectsqlQuery
operator|+
literal|" fetch first "
operator|+
name|numRows
operator|+
literal|" rows only"
return|;
case|case
name|MYSQL
case|:
comment|//http://www.postgresql.org/docs/7.3/static/queries-limit.html
case|case
name|POSTGRES
case|:
comment|//https://dev.mysql.com/doc/refman/5.0/en/select.html
return|return
literal|"select "
operator|+
name|noSelectsqlQuery
operator|+
literal|" limit "
operator|+
name|numRows
return|;
case|case
name|ORACLE
case|:
comment|//newer versions (12c and later) support OFFSET/FETCH
return|return
literal|"select * from (select "
operator|+
name|noSelectsqlQuery
operator|+
literal|") where rownum<= "
operator|+
name|numRows
return|;
case|case
name|SQLSERVER
case|:
comment|//newer versions (2012 and later) support OFFSET/FETCH
comment|//https://msdn.microsoft.com/en-us/library/ms189463.aspx
return|return
literal|"select TOP("
operator|+
name|numRows
operator|+
literal|") "
operator|+
name|noSelectsqlQuery
return|;
default|default:
name|String
name|msg
init|=
literal|"Unrecognized database product name<"
operator|+
name|dbProduct
operator|+
literal|">"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
specifier|static
name|String
name|getMetastoreJdbcUser
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTORE_CONNECTION_USER_NAME
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|String
name|getMetastoreJdbcPasswd
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|SQLException
block|{
try|try
block|{
return|return
name|ShimLoader
operator|.
name|getHadoopShims
argument_list|()
operator|.
name|getPassword
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTOREPWD
operator|.
name|varname
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|err
parameter_list|)
block|{
throw|throw
operator|new
name|SQLException
argument_list|(
literal|"Error getting metastore password"
argument_list|,
name|err
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
class|class
name|NoPoolConnectionPool
implements|implements
name|DataSource
block|{
comment|// Note that this depends on the fact that no-one in this class calls anything but
comment|// getConnection.  If you want to use any of the Logger or wrap calls you'll have to
comment|// implement them.
specifier|private
specifier|final
name|HiveConf
name|conf
decl_stmt|;
specifier|private
name|Driver
name|driver
decl_stmt|;
specifier|private
name|String
name|connString
decl_stmt|;
specifier|private
name|String
name|user
decl_stmt|;
specifier|private
name|String
name|passwd
decl_stmt|;
specifier|public
name|NoPoolConnectionPool
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Connection
name|getConnection
parameter_list|()
throws|throws
name|SQLException
block|{
if|if
condition|(
name|user
operator|==
literal|null
condition|)
block|{
name|user
operator|=
name|getMetastoreJdbcUser
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|passwd
operator|=
name|getMetastoreJdbcPasswd
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
return|return
name|getConnection
argument_list|(
name|user
argument_list|,
name|passwd
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Connection
name|getConnection
parameter_list|(
name|String
name|username
parameter_list|,
name|String
name|password
parameter_list|)
throws|throws
name|SQLException
block|{
comment|// Find the JDBC driver
if|if
condition|(
name|driver
operator|==
literal|null
condition|)
block|{
name|String
name|driverName
init|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTORE_CONNECTION_DRIVER
argument_list|)
decl_stmt|;
if|if
condition|(
name|driverName
operator|==
literal|null
operator|||
name|driverName
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"JDBC driver for transaction db not set in configuration "
operator|+
literal|"file, need to set "
operator|+
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTORE_CONNECTION_DRIVER
operator|.
name|varname
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Going to load JDBC driver "
operator|+
name|driverName
argument_list|)
expr_stmt|;
name|driver
operator|=
operator|(
name|Driver
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|driverName
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InstantiationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unable to instantiate driver "
operator|+
name|driverName
operator|+
literal|", "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unable to access driver "
operator|+
name|driverName
operator|+
literal|", "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unable to find driver "
operator|+
name|driverName
operator|+
literal|", "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|connString
operator|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTORECONNECTURLKEY
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Connecting to transaction db with connection string "
operator|+
name|connString
argument_list|)
expr_stmt|;
name|Properties
name|connectionProps
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|connectionProps
operator|.
name|setProperty
argument_list|(
literal|"user"
argument_list|,
name|username
argument_list|)
expr_stmt|;
name|connectionProps
operator|.
name|setProperty
argument_list|(
literal|"password"
argument_list|,
name|password
argument_list|)
expr_stmt|;
name|Connection
name|conn
init|=
name|driver
operator|.
name|connect
argument_list|(
name|connString
argument_list|,
name|connectionProps
argument_list|)
decl_stmt|;
name|conn
operator|.
name|setAutoCommit
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
name|conn
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unable to connect to transaction manager using "
operator|+
name|connString
operator|+
literal|", "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|PrintWriter
name|getLogWriter
parameter_list|()
throws|throws
name|SQLException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setLogWriter
parameter_list|(
name|PrintWriter
name|out
parameter_list|)
throws|throws
name|SQLException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setLoginTimeout
parameter_list|(
name|int
name|seconds
parameter_list|)
throws|throws
name|SQLException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getLoginTimeout
parameter_list|()
throws|throws
name|SQLException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
name|getParentLogger
parameter_list|()
throws|throws
name|SQLFeatureNotSupportedException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|unwrap
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|iface
parameter_list|)
throws|throws
name|SQLException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isWrapperFor
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|iface
parameter_list|)
throws|throws
name|SQLException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
empty_stmt|;
block|}
end_class

end_unit

