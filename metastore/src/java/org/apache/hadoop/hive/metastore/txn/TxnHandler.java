begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|txn
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|jolbox
operator|.
name|bonecp
operator|.
name|BoneCPConfig
import|;
end_import

begin_import
import|import
name|com
operator|.
name|jolbox
operator|.
name|bonecp
operator|.
name|BoneCPDataSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|dbcp
operator|.
name|ConnectionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|dbcp
operator|.
name|DriverManagerConnectionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|dbcp
operator|.
name|PoolableConnectionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|NotImplementedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ServerUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|Warehouse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|dbcp
operator|.
name|PoolingDataSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|pool
operator|.
name|ObjectPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|pool
operator|.
name|impl
operator|.
name|GenericObjectPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|JavaUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|shims
operator|.
name|ShimLoader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|sql
operator|.
name|DataSource
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Semaphore
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_comment
comment|/**  * A handler to answer transaction related calls that come into the metastore  * server.  *  * Note on log messages:  Please include txnid:X and lockid info using  * {@link org.apache.hadoop.hive.common.JavaUtils#txnIdToString(long)}  * and {@link org.apache.hadoop.hive.common.JavaUtils#lockIdToString(long)} in all messages.  * The txnid:X and lockid:Y matches how Thrift object toString() methods are generated,  * so keeping the format consistent makes grep'ing the logs much easier.  *  * Note on HIVE_LOCKS.hl_last_heartbeat.  * For locks that are part of transaction, we set this 0 (would rather set it to NULL but  * Currently the DB schema has this NOT NULL) and only update/read heartbeat from corresponding  * transaction in TXNS.  *  * In general there can be multiple metastores where this logic can execute, thus the DB is  * used to ensure proper mutexing of operations.  * Select ... For Update (or equivalent: either MsSql with(updlock) or actual Update stmt) is  * used to properly sequence operations.  Most notably:  * 1. various sequence IDs are generated with aid of this mutex  * 2. ensuring that each (Hive) Transaction state is transitioned atomically.  Transaction state  *  includes it's actual state (Open, Aborted) as well as it's lock list/component list.  Thus all  *  per transaction ops, either start by update/delete of the relevant TXNS row or do S4U on that row.  *  This allows almost all operations to run at READ_COMMITTED and minimizes DB deadlocks.  * 3. checkLock() - this is mutexted entirely since we must ensure that while we check if some lock  *  can be granted, no other (strictly speaking "earlier") lock can change state.  *  * The exception to his is Derby which doesn't support proper S4U.  Derby is always running embedded  * (this is the only supported configuration for Derby)  * in the same JVM as HiveMetaStoreHandler thus we use JVM wide lock to properly sequnce the operations.  *  * {@link #derbyLock}   * If we ever decide to run remote Derby server, according to  * https://db.apache.org/derby/docs/10.0/manuals/develop/develop78.html all transactions will be  * seriazlied, so that would also work though has not been tested.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|abstract
class|class
name|TxnHandler
implements|implements
name|TxnStore
implements|,
name|TxnStore
operator|.
name|MutexAPI
block|{
specifier|static
specifier|final
specifier|protected
name|char
name|INITIATED_STATE
init|=
literal|'i'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|WORKING_STATE
init|=
literal|'w'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|READY_FOR_CLEANING
init|=
literal|'r'
decl_stmt|;
specifier|static
specifier|final
name|char
name|FAILED_STATE
init|=
literal|'f'
decl_stmt|;
specifier|static
specifier|final
name|char
name|SUCCEEDED_STATE
init|=
literal|'s'
decl_stmt|;
specifier|static
specifier|final
name|char
name|ATTEMPTED_STATE
init|=
literal|'a'
decl_stmt|;
comment|// Compactor types
specifier|static
specifier|final
specifier|protected
name|char
name|MAJOR_TYPE
init|=
literal|'a'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|MINOR_TYPE
init|=
literal|'i'
decl_stmt|;
comment|// Transaction states
specifier|static
specifier|final
specifier|protected
name|char
name|TXN_ABORTED
init|=
literal|'a'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|TXN_OPEN
init|=
literal|'o'
decl_stmt|;
comment|// Lock states
specifier|static
specifier|final
specifier|protected
name|char
name|LOCK_ACQUIRED
init|=
literal|'a'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|LOCK_WAITING
init|=
literal|'w'
decl_stmt|;
comment|// Lock types
specifier|static
specifier|final
specifier|protected
name|char
name|LOCK_EXCLUSIVE
init|=
literal|'e'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|LOCK_SHARED
init|=
literal|'r'
decl_stmt|;
specifier|static
specifier|final
specifier|protected
name|char
name|LOCK_SEMI_SHARED
init|=
literal|'w'
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|int
name|ALLOWED_REPEATED_DEADLOCKS
init|=
literal|10
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TxnHandler
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|static
specifier|private
name|DataSource
name|connPool
decl_stmt|;
specifier|static
specifier|private
name|boolean
name|doRetryOnConnPool
init|=
literal|false
decl_stmt|;
comment|/**    * Number of consecutive deadlocks we have seen    */
specifier|private
name|int
name|deadlockCnt
decl_stmt|;
specifier|private
name|long
name|deadlockRetryInterval
decl_stmt|;
specifier|protected
name|HiveConf
name|conf
decl_stmt|;
specifier|protected
name|DatabaseProduct
name|dbProduct
decl_stmt|;
comment|// (End user) Transaction timeout, in milliseconds.
specifier|private
name|long
name|timeout
decl_stmt|;
specifier|private
name|String
name|identifierQuoteString
decl_stmt|;
comment|// quotes to use for quoting tables, where necessary
specifier|private
name|long
name|retryInterval
decl_stmt|;
specifier|private
name|int
name|retryLimit
decl_stmt|;
specifier|private
name|int
name|retryNum
decl_stmt|;
comment|/**    * Derby specific concurrency control    */
specifier|private
specifier|static
specifier|final
name|ReentrantLock
name|derbyLock
init|=
operator|new
name|ReentrantLock
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|/**    * must be static since even in UT there may be> 1 instance of TxnHandler    * (e.g. via Compactor services)    */
specifier|private
specifier|final
specifier|static
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Semaphore
argument_list|>
name|derbyKey2Lock
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|hostname
init|=
name|ServerUtils
operator|.
name|hostname
argument_list|()
decl_stmt|;
comment|// Private methods should never catch SQLException and then throw MetaException.  The public
comment|// methods depend on SQLException coming back so they can detect and handle deadlocks.  Private
comment|// methods should only throw MetaException when they explicitly know there's a logic error and
comment|// they want to throw past the public methods.
comment|//
comment|// All public methods that write to the database have to check for deadlocks when a SQLException
comment|// comes back and handle it if they see one.  This has to be done with the connection pooling
comment|// in mind.  To do this they should call checkRetryable() AFTER rolling back the db transaction,
comment|// and then they should catch RetryException and call themselves recursively. See commitTxn for an example.
specifier|public
name|TxnHandler
parameter_list|()
block|{   }
comment|/**    * This is logically part of c'tor and must be called prior to any other method.    * Not physically part of c'tor due to use of relfection    */
specifier|public
name|void
name|setConf
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|checkQFileTestHack
argument_list|()
expr_stmt|;
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
comment|// Set up the JDBC connection pool
try|try
block|{
name|setupJdbcConnectionPool
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|determineDatabaseProduct
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"Unable to instantiate JDBC connection pooling, "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
name|timeout
operator|=
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_TXN_TIMEOUT
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|buildJumpTable
argument_list|()
expr_stmt|;
name|retryInterval
operator|=
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HMSHANDLERINTERVAL
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|retryLimit
operator|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HMSHANDLERATTEMPTS
argument_list|)
expr_stmt|;
name|deadlockRetryInterval
operator|=
name|retryInterval
operator|/
literal|10
expr_stmt|;
block|}
specifier|public
name|GetOpenTxnsInfoResponse
name|getOpenTxnsInfo
parameter_list|()
throws|throws
name|MetaException
block|{
try|try
block|{
comment|// We need to figure out the current transaction number and the list of
comment|// open transactions.  To avoid needing a transaction on the underlying
comment|// database we'll look at the current transaction number first.  If it
comment|// subsequently shows up in the open list that's ok.
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|/**          * This method can run at READ_COMMITTED as long as long as          * {@link #openTxns(org.apache.hadoop.hive.metastore.api.OpenTxnRequest)} is atomic.          * More specifically, as long as advancing TransactionID in NEXT_TXN_ID is atomic with          * adding corresponding entries into TXNS.  The reason is that any txnid below HWM          * is either in TXNS and thus considered open (Open/Aborted) or it's considered Committed.          */
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select ntxn_next - 1 from NEXT_TXN_ID"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly "
operator|+
literal|"initialized, no record found in next_txn_id"
argument_list|)
throw|;
block|}
name|long
name|hwm
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly "
operator|+
literal|"initialized, null record found in next_txn_id"
argument_list|)
throw|;
block|}
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|TxnInfo
argument_list|>
name|txnInfo
init|=
operator|new
name|ArrayList
argument_list|<
name|TxnInfo
argument_list|>
argument_list|()
decl_stmt|;
comment|//need the WHERE clause below to ensure consistent results with READ_COMMITTED
name|s
operator|=
literal|"select txn_id, txn_state, txn_user, txn_host from TXNS where txn_id<= "
operator|+
name|hwm
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|char
name|c
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|TxnState
name|state
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|TXN_ABORTED
case|:
name|state
operator|=
name|TxnState
operator|.
name|ABORTED
expr_stmt|;
break|break;
case|case
name|TXN_OPEN
case|:
name|state
operator|=
name|TxnState
operator|.
name|OPEN
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unexpected transaction state "
operator|+
name|c
operator|+
literal|" found in txns table"
argument_list|)
throw|;
block|}
name|txnInfo
operator|.
name|add
argument_list|(
operator|new
name|TxnInfo
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|,
name|state
argument_list|,
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
argument_list|,
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
operator|new
name|GetOpenTxnsInfoResponse
argument_list|(
name|hwm
argument_list|,
name|txnInfo
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"getOpenTxnsInfo"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database: "
operator|+
name|getMessage
argument_list|(
name|e
argument_list|)
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|getOpenTxnsInfo
argument_list|()
return|;
block|}
block|}
specifier|public
name|GetOpenTxnsResponse
name|getOpenTxns
parameter_list|()
throws|throws
name|MetaException
block|{
try|try
block|{
comment|// We need to figure out the current transaction number and the list of
comment|// open transactions.  To avoid needing a transaction on the underlying
comment|// database we'll look at the current transaction number first.  If it
comment|// subsequently shows up in the open list that's ok.
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|/**          * This runs at READ_COMMITTED for exactly the same reason as {@link #getOpenTxnsInfo()} \         */
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select ntxn_next - 1 from NEXT_TXN_ID"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly "
operator|+
literal|"initialized, no record found in next_txn_id"
argument_list|)
throw|;
block|}
name|long
name|hwm
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly "
operator|+
literal|"initialized, null record found in next_txn_id"
argument_list|)
throw|;
block|}
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Long
argument_list|>
name|openList
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
comment|//need the WHERE clause below to ensure consistent results with READ_COMMITTED
name|s
operator|=
literal|"select txn_id from TXNS where txn_id<= "
operator|+
name|hwm
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|openList
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
operator|new
name|GetOpenTxnsResponse
argument_list|(
name|hwm
argument_list|,
name|openList
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"getOpenTxns"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database, "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|getOpenTxns
argument_list|()
return|;
block|}
block|}
specifier|public
name|OpenTxnsResponse
name|openTxns
parameter_list|(
name|OpenTxnRequest
name|rqst
parameter_list|)
throws|throws
name|MetaException
block|{
name|int
name|numTxns
init|=
name|rqst
operator|.
name|getNum_txns
argument_list|()
decl_stmt|;
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lockInternal
argument_list|()
expr_stmt|;
comment|/**          * To make {@link #getOpenTxns()}/{@link #getOpenTxnsInfo()} work correctly, this operation must ensure          * that advancing the counter in NEXT_TXN_ID and adding appropriate entries to TXNS is atomic.          * Also, advancing the counter must work when multiple metastores are running.          * SELECT ... FOR UPDATE is used to prevent          * concurrent DB transactions being rolled back due to Write-Write conflict on NEXT_TXN_ID.          *          * In the current design, there can be several metastore instances running in a given Warehouse.          * This makes ideas like reserving a range of IDs to save trips to DB impossible.  For example,          * a client may go to MS1 and start a transaction with ID 500 to update a particular row.          * Now the same client will start another transaction, except it ends up on MS2 and may get          * transaction ID 400 and update the same row.  Now the merge that happens to materialize the snapshot          * on read will thing the version of the row from transaction ID 500 is the latest one.          *          * Longer term we can consider running Active-Passive MS (at least wrt to ACID operations).  This          * set could support a write-through cache for added performance.          */
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
comment|// Make sure the user has not requested an insane amount of txns.
name|int
name|maxTxns
init|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_TXN_MAX_OPEN_BATCH
argument_list|)
decl_stmt|;
if|if
condition|(
name|numTxns
operator|>
name|maxTxns
condition|)
name|numTxns
operator|=
name|maxTxns
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
name|addForUpdateClause
argument_list|(
literal|"select ntxn_next from NEXT_TXN_ID"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction database not properly "
operator|+
literal|"configured, can't find next transaction id."
argument_list|)
throw|;
block|}
name|long
name|first
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|s
operator|=
literal|"update NEXT_TXN_ID set ntxn_next = "
operator|+
operator|(
name|first
operator|+
name|numTxns
operator|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|long
name|now
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|txnIds
init|=
operator|new
name|ArrayList
argument_list|<
name|Long
argument_list|>
argument_list|(
name|numTxns
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|queries
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|query
decl_stmt|;
name|String
name|insertClause
init|=
literal|"insert into TXNS (txn_id, txn_state, txn_started, txn_last_heartbeat, txn_user, txn_host) values "
decl_stmt|;
name|StringBuilder
name|valuesClause
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|long
name|i
init|=
name|first
init|;
name|i
operator|<
name|first
operator|+
name|numTxns
condition|;
name|i
operator|++
control|)
block|{
name|txnIds
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|first
operator|&&
operator|(
name|i
operator|-
name|first
operator|)
operator|%
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTORE_DIRECT_SQL_MAX_ELEMENTS_VALUES_CLAUSE
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// wrap up the current query, and start a new one
name|query
operator|=
name|insertClause
operator|+
name|valuesClause
operator|.
name|toString
argument_list|()
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|valuesClause
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|valuesClause
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
operator|.
name|append
argument_list|(
name|i
argument_list|)
operator|.
name|append
argument_list|(
literal|", 'o', "
argument_list|)
operator|.
name|append
argument_list|(
name|now
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|now
argument_list|)
operator|.
name|append
argument_list|(
literal|", '"
argument_list|)
operator|.
name|append
argument_list|(
name|rqst
operator|.
name|getUser
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
operator|.
name|append
argument_list|(
name|rqst
operator|.
name|getHostname
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"')"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|i
operator|>
name|first
condition|)
block|{
name|valuesClause
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|valuesClause
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
operator|.
name|append
argument_list|(
name|i
argument_list|)
operator|.
name|append
argument_list|(
literal|", 'o', "
argument_list|)
operator|.
name|append
argument_list|(
name|now
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|now
argument_list|)
operator|.
name|append
argument_list|(
literal|", '"
argument_list|)
operator|.
name|append
argument_list|(
name|rqst
operator|.
name|getUser
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
operator|.
name|append
argument_list|(
name|rqst
operator|.
name|getHostname
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"')"
argument_list|)
expr_stmt|;
block|}
name|query
operator|=
name|insertClause
operator|+
name|valuesClause
operator|.
name|toString
argument_list|()
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|query
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|q
range|:
name|queries
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|q
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|execute
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
operator|new
name|OpenTxnsResponse
argument_list|(
name|txnIds
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"openTxns("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
name|unlockInternal
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|openTxns
argument_list|(
name|rqst
argument_list|)
return|;
block|}
block|}
specifier|public
name|void
name|abortTxn
parameter_list|(
name|AbortTxnRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|MetaException
block|{
name|long
name|txnid
init|=
name|rqst
operator|.
name|getTxnid
argument_list|()
decl_stmt|;
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lockInternal
argument_list|()
expr_stmt|;
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|abortTxns
argument_list|(
name|dbConn
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|txnid
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|NoSuchTxnException
argument_list|(
literal|"No such transaction "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"abortTxn("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|unlockInternal
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|abortTxn
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|commitTxn
parameter_list|(
name|CommitTxnRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
name|long
name|txnid
init|=
name|rqst
operator|.
name|getTxnid
argument_list|()
decl_stmt|;
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|lockHandle
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lockInternal
argument_list|()
expr_stmt|;
comment|/**          * Runs at READ_COMMITTED with S4U on TXNS row for "txnid".  S4U ensures that no other          * operation can change this txn (such acquiring locks). While lock() and commitTxn()          * should not normally run concurrently (for same txn) but could due to bugs in the client          * which could then corrupt internal transaction manager state.  Also competes with abortTxn().          */
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|lockHandle
operator|=
name|lockTransactionRecord
argument_list|(
name|stmt
argument_list|,
name|txnid
argument_list|,
name|TXN_OPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockHandle
operator|==
literal|null
condition|)
block|{
comment|//this also ensures that txn is still there and in expected state (hasn't been timed out)
name|ensureValidTxn
argument_list|(
name|dbConn
argument_list|,
name|txnid
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|shouldNeverHappen
argument_list|(
name|txnid
argument_list|)
expr_stmt|;
block|}
comment|// Move the record from txn_components into completed_txn_components so that the compactor
comment|// knows where to look to compact.
name|String
name|s
init|=
literal|"insert into COMPLETED_TXN_COMPONENTS select tc_txnid, tc_database, tc_table, "
operator|+
literal|"tc_partition from TXN_COMPONENTS where tc_txnid = "
operator|+
name|txnid
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute insert<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
operator|<
literal|1
condition|)
block|{
comment|//this can be reasonable for an empty txn START/COMMIT
name|LOG
operator|.
name|info
argument_list|(
literal|"Expected to move at least one record from txn_components to "
operator|+
literal|"completed_txn_components when committing txn! "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Always access TXN_COMPONENTS before HIVE_LOCKS;
name|s
operator|=
literal|"delete from TXN_COMPONENTS where tc_txnid = "
operator|+
name|txnid
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|// Always access HIVE_LOCKS before TXNS
name|s
operator|=
literal|"delete from HIVE_LOCKS where hl_txnid = "
operator|+
name|txnid
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
literal|"delete from TXNS where txn_id = "
operator|+
name|txnid
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"commitTxn("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|lockHandle
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
name|unlockInternal
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|commitTxn
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * As much as possible (i.e. in absence of retries) we want both operations to be done on the same    * connection (but separate transactions).  This avoid some flakiness in BONECP where if you    * perform an operation on 1 connection and immediately get another fron the pool, the 2nd one    * doesn't see results of the first.    */
specifier|public
name|LockResponse
name|lock
parameter_list|(
name|LockRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
name|ConnectionLockIdPair
name|connAndLockId
init|=
name|enqueueLockWithRetry
argument_list|(
name|rqst
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|checkLockWithRetry
argument_list|(
name|connAndLockId
operator|.
name|dbConn
argument_list|,
name|connAndLockId
operator|.
name|extLockId
argument_list|,
name|rqst
operator|.
name|getTxnid
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchLockException
name|e
parameter_list|)
block|{
comment|// This should never happen, as we just added the lock id
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Couldn't find a lock we just created! "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
specifier|final
class|class
name|ConnectionLockIdPair
block|{
specifier|private
specifier|final
name|Connection
name|dbConn
decl_stmt|;
specifier|private
specifier|final
name|long
name|extLockId
decl_stmt|;
specifier|private
name|ConnectionLockIdPair
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|extLockId
parameter_list|)
block|{
name|this
operator|.
name|dbConn
operator|=
name|dbConn
expr_stmt|;
name|this
operator|.
name|extLockId
operator|=
name|extLockId
expr_stmt|;
block|}
block|}
comment|/**    * Note that by definition select for update is divorced from update, i.e. you executeQuery() to read    * and then executeUpdate().  One other alternative would be to actually update the row in TXNX but    * to the same value as before thus forcing db to acquire write lock for duration of the transaction.    *    * There is no real reason to return the ResultSet here other than to make sure the reference to it    * is retained for duration of intended lock scope and is not GC'd thus (unlikely) causing lock    * to be released.    * @param txnState the state this txn is expected to be in.  may be null    * @return null if no row was found    * @throws SQLException    * @throws MetaException    */
specifier|private
name|ResultSet
name|lockTransactionRecord
parameter_list|(
name|Statement
name|stmt
parameter_list|,
name|long
name|txnId
parameter_list|,
name|Character
name|txnState
parameter_list|)
throws|throws
name|SQLException
throws|,
name|MetaException
block|{
name|String
name|query
init|=
literal|"select TXN_STATE from TXNS where TXN_ID = "
operator|+
name|txnId
operator|+
operator|(
name|txnState
operator|!=
literal|null
condition|?
literal|" AND TXN_STATE="
operator|+
name|quoteChar
argument_list|(
name|txnState
argument_list|)
else|:
literal|""
operator|)
decl_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|addForUpdateClause
argument_list|(
name|query
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
return|return
name|rs
return|;
block|}
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/**    * This enters locks into the queue in {@link #LOCK_WAITING} mode.    *    * Isolation Level Notes:    * 1. We use S4U (withe read_committed) to generate the next (ext) lock id.  This serializes    * any 2 {@code enqueueLockWithRetry()} calls.    * 2. We use S4U on the relevant TXNS row to block any concurrent abort/commit/etc operations    * @see #checkLockWithRetry(Connection, long, long)    */
specifier|private
name|ConnectionLockIdPair
name|enqueueLockWithRetry
parameter_list|(
name|LockRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
name|ResultSet
name|lockHandle
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lockInternal
argument_list|()
expr_stmt|;
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|long
name|txnid
init|=
name|rqst
operator|.
name|getTxnid
argument_list|()
decl_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
if|if
condition|(
name|isValidTxn
argument_list|(
name|txnid
argument_list|)
condition|)
block|{
comment|//this also ensures that txn is still there in expected state
name|lockHandle
operator|=
name|lockTransactionRecord
argument_list|(
name|stmt
argument_list|,
name|txnid
argument_list|,
name|TXN_OPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockHandle
operator|==
literal|null
condition|)
block|{
name|ensureValidTxn
argument_list|(
name|dbConn
argument_list|,
name|txnid
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|shouldNeverHappen
argument_list|(
name|txnid
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Get the next lock id.          * This has to be atomic with adding entries to HIVE_LOCK entries (1st add in W state) to prevent a race.          * Suppose ID gen is a separate txn and 2 concurrent lock() methods are running.  1st one generates nl_next=7,          * 2nd nl_next=8.  Then 8 goes first to insert into HIVE_LOCKS and aquires the locks.  Then 7 unblocks,          * and add it's W locks but it won't see locks from 8 since to be 'fair' {@link #checkLock(java.sql.Connection, long)}          * doesn't block on locks acquired later than one it's checking*/
name|String
name|s
init|=
name|addForUpdateClause
argument_list|(
literal|"select nl_next from NEXT_LOCK_ID"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly "
operator|+
literal|"initialized, no record found in next_lock_id"
argument_list|)
throw|;
block|}
name|long
name|extLockId
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|s
operator|=
literal|"update NEXT_LOCK_ID set nl_next = "
operator|+
operator|(
name|extLockId
operator|+
literal|1
operator|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|txnid
operator|>
literal|0
condition|)
block|{
comment|// For each component in this lock request,
comment|// add an entry to the txn_components table
comment|// This must be done before HIVE_LOCKS is accessed
for|for
control|(
name|LockComponent
name|lc
range|:
name|rqst
operator|.
name|getComponent
argument_list|()
control|)
block|{
name|String
name|dbName
init|=
name|lc
operator|.
name|getDbname
argument_list|()
decl_stmt|;
name|String
name|tblName
init|=
name|lc
operator|.
name|getTablename
argument_list|()
decl_stmt|;
name|String
name|partName
init|=
name|lc
operator|.
name|getPartitionname
argument_list|()
decl_stmt|;
name|s
operator|=
literal|"insert into TXN_COMPONENTS "
operator|+
literal|"(tc_txnid, tc_database, tc_table, tc_partition) "
operator|+
literal|"values ("
operator|+
name|txnid
operator|+
literal|", '"
operator|+
name|dbName
operator|+
literal|"', "
operator|+
operator|(
name|tblName
operator|==
literal|null
condition|?
literal|"null"
else|:
literal|"'"
operator|+
name|tblName
operator|+
literal|"'"
operator|)
operator|+
literal|", "
operator|+
operator|(
name|partName
operator|==
literal|null
condition|?
literal|"null"
else|:
literal|"'"
operator|+
name|partName
operator|+
literal|"'"
operator|)
operator|+
literal|")"
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|intLockId
init|=
literal|0
decl_stmt|;
for|for
control|(
name|LockComponent
name|lc
range|:
name|rqst
operator|.
name|getComponent
argument_list|()
control|)
block|{
name|intLockId
operator|++
expr_stmt|;
name|String
name|dbName
init|=
name|lc
operator|.
name|getDbname
argument_list|()
decl_stmt|;
name|String
name|tblName
init|=
name|lc
operator|.
name|getTablename
argument_list|()
decl_stmt|;
name|String
name|partName
init|=
name|lc
operator|.
name|getPartitionname
argument_list|()
decl_stmt|;
name|LockType
name|lockType
init|=
name|lc
operator|.
name|getType
argument_list|()
decl_stmt|;
name|char
name|lockChar
init|=
literal|'z'
decl_stmt|;
switch|switch
condition|(
name|lockType
condition|)
block|{
case|case
name|EXCLUSIVE
case|:
name|lockChar
operator|=
name|LOCK_EXCLUSIVE
expr_stmt|;
break|break;
case|case
name|SHARED_READ
case|:
name|lockChar
operator|=
name|LOCK_SHARED
expr_stmt|;
break|break;
case|case
name|SHARED_WRITE
case|:
name|lockChar
operator|=
name|LOCK_SEMI_SHARED
expr_stmt|;
break|break;
block|}
name|long
name|now
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|s
operator|=
literal|"insert into HIVE_LOCKS "
operator|+
literal|" (hl_lock_ext_id, hl_lock_int_id, hl_txnid, hl_db, hl_table, "
operator|+
literal|"hl_partition, hl_lock_state, hl_lock_type, hl_last_heartbeat, hl_user, hl_host)"
operator|+
literal|" values ("
operator|+
name|extLockId
operator|+
literal|", "
operator|+
operator|+
name|intLockId
operator|+
literal|","
operator|+
name|txnid
operator|+
literal|", '"
operator|+
name|dbName
operator|+
literal|"', "
operator|+
operator|(
name|tblName
operator|==
literal|null
condition|?
literal|"null"
else|:
literal|"'"
operator|+
name|tblName
operator|+
literal|"'"
operator|)
operator|+
literal|", "
operator|+
operator|(
name|partName
operator|==
literal|null
condition|?
literal|"null"
else|:
literal|"'"
operator|+
name|partName
operator|+
literal|"'"
operator|)
operator|+
literal|", '"
operator|+
name|LOCK_WAITING
operator|+
literal|"', "
operator|+
literal|"'"
operator|+
name|lockChar
operator|+
literal|"', "
operator|+
comment|//for locks associated with a txn, we always heartbeat txn and timeout based on that
operator|(
name|isValidTxn
argument_list|(
name|txnid
argument_list|)
condition|?
literal|0
else|:
name|now
operator|)
operator|+
literal|", '"
operator|+
name|rqst
operator|.
name|getUser
argument_list|()
operator|+
literal|"', '"
operator|+
name|rqst
operator|.
name|getHostname
argument_list|()
operator|+
literal|"')"
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
return|return
operator|new
name|ConnectionLockIdPair
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"enqueueLockWithRetry("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|lockHandle
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|/* This needs to return a "live" connection to be used by operation that follows it.           Thus it only closes Connection on failure/retry. */
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
name|unlockInternal
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|enqueueLockWithRetry
argument_list|(
name|rqst
argument_list|)
return|;
block|}
block|}
specifier|private
name|LockResponse
name|checkLockWithRetry
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|extLockId
parameter_list|,
name|long
name|txnId
parameter_list|)
throws|throws
name|NoSuchLockException
throws|,
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
try|try
block|{
try|try
block|{
name|lockInternal
argument_list|()
expr_stmt|;
if|if
condition|(
name|dbConn
operator|.
name|isClosed
argument_list|()
condition|)
block|{
comment|//should only get here if retrying this op
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_SERIALIZABLE
argument_list|)
expr_stmt|;
block|}
name|dbConn
operator|.
name|setTransactionIsolation
argument_list|(
name|Connection
operator|.
name|TRANSACTION_SERIALIZABLE
argument_list|)
expr_stmt|;
return|return
name|checkLock
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"checkLockWithRetry("
operator|+
name|extLockId
operator|+
literal|","
operator|+
name|txnId
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|unlockInternal
argument_list|()
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|checkLockWithRetry
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|,
name|txnId
argument_list|)
return|;
block|}
block|}
comment|/**    * Why doesn't this get a txnid as parameter?  The caller should either know the txnid or know there isn't one.    * Either way getTxnIdFromLockId() will not be needed.  This would be a Thrift change.    *    * Also, when lock acquisition returns WAITING, it's retried every 15 seconds (best case, see DbLockManager.backoff(),    * in practice more often)    * which means this is heartbeating way more often than hive.txn.timeout and creating extra load on DB.    *    * The clients that operate in blocking mode, can't heartbeat a lock until the lock is acquired.    * We should make CheckLockRequest include timestamp or last request to skip unnecessary heartbeats. Thrift change.    *    * {@link #checkLock(java.sql.Connection, long)}  must run at SERIALIZABLE (make sure some lock we are checking    * against doesn't move from W to A in another txn) but this method can heartbeat in    * separate txn at READ_COMMITTED.    */
specifier|public
name|LockResponse
name|checkLock
parameter_list|(
name|CheckLockRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|NoSuchLockException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|long
name|extLockId
init|=
name|rqst
operator|.
name|getLockid
argument_list|()
decl_stmt|;
try|try
block|{
name|lockInternal
argument_list|()
expr_stmt|;
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
comment|// Heartbeat on the lockid first, to assure that our lock is still valid.
comment|// Then look up the lock info (hopefully in the cache).  If these locks
comment|// are associated with a transaction then heartbeat on that as well.
name|LockInfo
name|info
init|=
name|getTxnIdFromLockId
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchLockException
argument_list|(
literal|"No such lock "
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|info
operator|.
name|txnId
operator|>
literal|0
condition|)
block|{
name|heartbeatTxn
argument_list|(
name|dbConn
argument_list|,
name|info
operator|.
name|txnId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|heartbeatLock
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
expr_stmt|;
block|}
comment|//todo: strictly speaking there is a bug here.  heartbeat*() commits but both heartbeat and
comment|//checkLock() are in the same retry block, so if checkLock() throws, heartbeat is also retired
comment|//extra heartbeat is logically harmless, but ...
name|dbConn
operator|.
name|setTransactionIsolation
argument_list|(
name|Connection
operator|.
name|TRANSACTION_SERIALIZABLE
argument_list|)
expr_stmt|;
return|return
name|checkLock
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"checkLock("
operator|+
name|rqst
operator|+
literal|" )"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
operator|+
literal|" "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|unlockInternal
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|checkLock
argument_list|(
name|rqst
argument_list|)
return|;
block|}
block|}
comment|/**    * This would have been made simpler if all locks were associated with a txn.  Then only txn needs to    * be heartbeated, committed, etc.  no need for client to track individual locks.    * When removing locks not associated with txn this potentially conflicts with    * heartbeat/performTimeout which are update/delete of HIVE_LOCKS thus will be locked as needed by db.    * since this only removes from HIVE_LOCKS at worst some lock acquire is delayed    */
specifier|public
name|void
name|unlock
parameter_list|(
name|UnlockRequest
name|rqst
parameter_list|)
throws|throws
name|NoSuchLockException
throws|,
name|TxnOpenException
throws|,
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|long
name|extLockId
init|=
name|rqst
operator|.
name|getLockid
argument_list|()
decl_stmt|;
try|try
block|{
comment|/**          * This method is logically like commit for read-only auto commit queries.          * READ_COMMITTED since this only has 1 delete statement and no new entries with the          * same hl_lock_ext_id can be added, i.e. all rows with a given hl_lock_ext_id are          * created in a single atomic operation.          * Theoretically, this competes with {@link #lock(org.apache.hadoop.hive.metastore.api.LockRequest)}          * but hl_lock_ext_id is not known until that method returns.          * Also competes with {@link #checkLock(org.apache.hadoop.hive.metastore.api.CheckLockRequest)}          * but using SERIALIZABLE doesn't materially change the interaction.          * If "delete" stmt misses, additional logic is best effort to produce meaningful error msg.          */
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
comment|//hl_txnid<> 0 means it's associated with a transaction
name|String
name|s
init|=
literal|"delete from HIVE_LOCKS where hl_lock_ext_id = "
operator|+
name|extLockId
operator|+
literal|" AND (hl_txnid = 0 OR"
operator|+
literal|" (hl_txnid<> 0 AND hl_lock_state = '"
operator|+
name|LOCK_WAITING
operator|+
literal|"'))"
decl_stmt|;
comment|//(hl_txnid<> 0 AND hl_lock_state = '" + LOCK_WAITING + "') is for multi-statement txns where
comment|//some query attempted to lock (thus LOCK_WAITING state) but is giving up due to timeout for example
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
name|LockInfo
name|info
init|=
name|getTxnIdFromLockId
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
comment|//didn't find any lock with extLockId but at ReadCommitted there is a possibility that
comment|//it existed when above delete ran but it didn't have the expected state.
name|LOG
operator|.
name|error
argument_list|(
literal|"No lock in "
operator|+
name|LOCK_WAITING
operator|+
literal|" mode found for unlock("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|NoSuchLockException
argument_list|(
literal|"No such lock "
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|info
operator|.
name|txnId
operator|!=
literal|0
condition|)
block|{
name|String
name|msg
init|=
literal|"Unlocking locks associated with transaction not permitted.  "
operator|+
name|info
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|TxnOpenException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
if|if
condition|(
name|info
operator|.
name|txnId
operator|==
literal|0
condition|)
block|{
comment|//we didn't see this lock when running DELETE stmt above but now it showed up
comment|//so should "should never happen" happened...
name|String
name|msg
init|=
literal|"Found lock in unexpected state "
operator|+
name|info
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"unlock("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to update transaction database "
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
operator|+
literal|" "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|unlock
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * used to sort entries in {@link org.apache.hadoop.hive.metastore.api.ShowLocksResponse}    */
specifier|private
specifier|static
class|class
name|LockInfoExt
extends|extends
name|LockInfo
block|{
specifier|private
specifier|final
name|ShowLocksResponseElement
name|e
decl_stmt|;
name|LockInfoExt
parameter_list|(
name|ShowLocksResponseElement
name|e
parameter_list|)
block|{
name|super
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|this
operator|.
name|e
operator|=
name|e
expr_stmt|;
block|}
block|}
specifier|public
name|ShowLocksResponse
name|showLocks
parameter_list|(
name|ShowLocksRequest
name|rqst
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|ShowLocksResponse
name|rsp
init|=
operator|new
name|ShowLocksResponse
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ShowLocksResponseElement
argument_list|>
name|elems
init|=
operator|new
name|ArrayList
argument_list|<
name|ShowLocksResponseElement
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|LockInfoExt
argument_list|>
name|sortedList
init|=
operator|new
name|ArrayList
argument_list|<
name|LockInfoExt
argument_list|>
argument_list|()
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select hl_lock_ext_id, hl_txnid, hl_db, hl_table, hl_partition, hl_lock_state, "
operator|+
literal|"hl_lock_type, hl_last_heartbeat, hl_acquired_at, hl_user, hl_host, hl_lock_int_id,"
operator|+
literal|"hl_blockedby_ext_id, hl_blockedby_int_id from HIVE_LOCKS"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Doing to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|ShowLocksResponseElement
name|e
init|=
operator|new
name|ShowLocksResponseElement
argument_list|()
decl_stmt|;
name|e
operator|.
name|setLockid
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|txnid
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
name|e
operator|.
name|setTxnid
argument_list|(
name|txnid
argument_list|)
expr_stmt|;
name|e
operator|.
name|setDbname
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setTablename
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|partition
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
name|partition
operator|!=
literal|null
condition|)
name|e
operator|.
name|setPartname
argument_list|(
name|partition
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|LOCK_ACQUIRED
case|:
name|e
operator|.
name|setState
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCK_WAITING
case|:
name|e
operator|.
name|setState
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unknown lock state "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|7
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|LOCK_SEMI_SHARED
case|:
name|e
operator|.
name|setType
argument_list|(
name|LockType
operator|.
name|SHARED_WRITE
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCK_EXCLUSIVE
case|:
name|e
operator|.
name|setType
argument_list|(
name|LockType
operator|.
name|EXCLUSIVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCK_SHARED
case|:
name|e
operator|.
name|setType
argument_list|(
name|LockType
operator|.
name|SHARED_READ
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unknown lock type "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
throw|;
block|}
name|e
operator|.
name|setLastheartbeat
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|acquiredAt
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|9
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
name|e
operator|.
name|setAcquiredat
argument_list|(
name|acquiredAt
argument_list|)
expr_stmt|;
name|e
operator|.
name|setUser
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setHostname
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|11
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setLockIdInternal
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|id
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|13
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
block|{
name|e
operator|.
name|setBlockedByExtId
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|id
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|14
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
block|{
name|e
operator|.
name|setBlockedByIntId
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|sortedList
operator|.
name|add
argument_list|(
operator|new
name|LockInfoExt
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"showLocks("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
comment|//this ensures that "SHOW LOCKS" prints the locks in the same order as they are examined
comment|//by checkLock() - makes diagnostics easier.
name|Collections
operator|.
name|sort
argument_list|(
name|sortedList
argument_list|,
operator|new
name|LockInfoComparator
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|LockInfoExt
name|lockInfoExt
range|:
name|sortedList
control|)
block|{
name|elems
operator|.
name|add
argument_list|(
name|lockInfoExt
operator|.
name|e
argument_list|)
expr_stmt|;
block|}
name|rsp
operator|.
name|setLocks
argument_list|(
name|elems
argument_list|)
expr_stmt|;
return|return
name|rsp
return|;
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|showLocks
argument_list|(
name|rqst
argument_list|)
return|;
block|}
block|}
comment|/**    * {@code ids} should only have txnid or lockid but not both, ideally.    * Currently DBTxnManager.heartbeat() enforces this.    */
specifier|public
name|void
name|heartbeat
parameter_list|(
name|HeartbeatRequest
name|ids
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|NoSuchLockException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|heartbeatLock
argument_list|(
name|dbConn
argument_list|,
name|ids
operator|.
name|getLockid
argument_list|()
argument_list|)
expr_stmt|;
name|heartbeatTxn
argument_list|(
name|dbConn
argument_list|,
name|ids
operator|.
name|getTxnid
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"heartbeat("
operator|+
name|ids
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|heartbeat
argument_list|(
name|ids
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|HeartbeatTxnRangeResponse
name|heartbeatTxnRange
parameter_list|(
name|HeartbeatTxnRangeRequest
name|rqst
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|HeartbeatTxnRangeResponse
name|rsp
init|=
operator|new
name|HeartbeatTxnRangeResponse
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Long
argument_list|>
name|nosuch
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Long
argument_list|>
name|aborted
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
name|rsp
operator|.
name|setNosuch
argument_list|(
name|nosuch
argument_list|)
expr_stmt|;
name|rsp
operator|.
name|setAborted
argument_list|(
name|aborted
argument_list|)
expr_stmt|;
try|try
block|{
comment|/**          * READ_COMMITTED is sufficient since {@link #heartbeatTxn(java.sql.Connection, long)}          * only has 1 update statement in it and          * we only update existing txns, i.e. nothing can add additional txns that this operation          * would care about (which would have required SERIALIZABLE)          */
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
for|for
control|(
name|long
name|txn
init|=
name|rqst
operator|.
name|getMin
argument_list|()
init|;
name|txn
operator|<=
name|rqst
operator|.
name|getMax
argument_list|()
condition|;
name|txn
operator|++
control|)
block|{
try|try
block|{
comment|//todo: do all updates in 1 SQL statement and check update count
comment|//if update count is less than was requested, go into more expensive checks
comment|//for each txn
name|heartbeatTxn
argument_list|(
name|dbConn
argument_list|,
name|txn
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchTxnException
name|e
parameter_list|)
block|{
name|nosuch
operator|.
name|add
argument_list|(
name|txn
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TxnAbortedException
name|e
parameter_list|)
block|{
name|aborted
operator|.
name|add
argument_list|(
name|txn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|rsp
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"heartbeatTxnRange("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|heartbeatTxnRange
argument_list|(
name|rqst
argument_list|)
return|;
block|}
block|}
specifier|public
name|long
name|compact
parameter_list|(
name|CompactionRequest
name|rqst
parameter_list|)
throws|throws
name|MetaException
block|{
comment|// Put a compaction request in the queue.
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lockInternal
argument_list|()
expr_stmt|;
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
comment|// Get the id for the next entry in the queue
name|String
name|s
init|=
name|addForUpdateClause
argument_list|(
literal|"select ncq_next from NEXT_COMPACTION_QUEUE_ID"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly initiated, "
operator|+
literal|"no record found in next_compaction_queue_id"
argument_list|)
throw|;
block|}
name|long
name|id
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|s
operator|=
literal|"update NEXT_COMPACTION_QUEUE_ID set ncq_next = "
operator|+
operator|(
name|id
operator|+
literal|1
operator|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"insert into COMPACTION_QUEUE (cq_id, cq_database, "
operator|+
literal|"cq_table, "
argument_list|)
decl_stmt|;
name|String
name|partName
init|=
name|rqst
operator|.
name|getPartitionname
argument_list|()
decl_stmt|;
if|if
condition|(
name|partName
operator|!=
literal|null
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|"cq_partition, "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"cq_state, cq_type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqst
operator|.
name|getRunas
argument_list|()
operator|!=
literal|null
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|", cq_run_as"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|") values ("
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|", '"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|rqst
operator|.
name|getDbname
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|rqst
operator|.
name|getTablename
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
if|if
condition|(
name|partName
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|partName
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|INITIATED_STATE
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rqst
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|MAJOR
case|:
name|buf
operator|.
name|append
argument_list|(
name|MAJOR_TYPE
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINOR
case|:
name|buf
operator|.
name|append
argument_list|(
name|MINOR_TYPE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unexpected compaction type "
operator|+
name|rqst
operator|.
name|getType
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|rqst
operator|.
name|getRunas
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|rqst
operator|.
name|getRunas
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"')"
argument_list|)
expr_stmt|;
name|s
operator|=
name|buf
operator|.
name|toString
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
name|id
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"compact("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|unlockInternal
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|compact
argument_list|(
name|rqst
argument_list|)
return|;
block|}
block|}
specifier|public
name|ShowCompactResponse
name|showCompact
parameter_list|(
name|ShowCompactRequest
name|rqst
parameter_list|)
throws|throws
name|MetaException
block|{
name|ShowCompactResponse
name|response
init|=
operator|new
name|ShowCompactResponse
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ShowCompactResponseElement
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select cq_database, cq_table, cq_partition, cq_state, cq_type, cq_worker_id, "
operator|+
literal|"cq_start, -1 cc_end, cq_run_as, cq_hadoop_job_id, cq_id from COMPACTION_QUEUE union all "
operator|+
literal|"select cc_database, cc_table, cc_partition, cc_state, cc_type, cc_worker_id, "
operator|+
literal|"cc_start, cc_end, cc_run_as, cc_hadoop_job_id, cc_id from COMPLETED_COMPACTIONS"
decl_stmt|;
comment|//what I want is order by cc_end desc, cc_start asc (but derby has a bug https://issues.apache.org/jira/browse/DERBY-6013)
comment|//to sort so that currently running jobs are at the end of the list (bottom of screen)
comment|//and currently running ones are in sorted by start time
comment|//w/o order by likely currently running compactions will be first (LHS of Union)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|ShowCompactResponseElement
name|e
init|=
operator|new
name|ShowCompactResponseElement
argument_list|()
decl_stmt|;
name|e
operator|.
name|setDbname
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setTablename
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setPartitionname
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|INITIATED_STATE
case|:
name|e
operator|.
name|setState
argument_list|(
name|INITIATED_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|WORKING_STATE
case|:
name|e
operator|.
name|setState
argument_list|(
name|WORKING_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|READY_FOR_CLEANING
case|:
name|e
operator|.
name|setState
argument_list|(
name|CLEANING_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|FAILED_STATE
case|:
name|e
operator|.
name|setState
argument_list|(
name|FAILED_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUCCEEDED_STATE
case|:
name|e
operator|.
name|setState
argument_list|(
name|SUCCEEDED_RESPONSE
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|//do nothing to handle RU/D if we add another status
block|}
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|MAJOR_TYPE
case|:
name|e
operator|.
name|setType
argument_list|(
name|CompactionType
operator|.
name|MAJOR
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINOR_TYPE
case|:
name|e
operator|.
name|setType
argument_list|(
name|CompactionType
operator|.
name|MINOR
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|//do nothing to handle RU/D if we add another status
block|}
name|e
operator|.
name|setWorkerid
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setStart
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|endTime
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|8
argument_list|)
decl_stmt|;
if|if
condition|(
name|endTime
operator|!=
operator|-
literal|1
condition|)
block|{
name|e
operator|.
name|setEndTime
argument_list|(
name|endTime
argument_list|)
expr_stmt|;
block|}
name|e
operator|.
name|setRunAs
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setHadoopJobId
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|id
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|11
argument_list|)
decl_stmt|;
comment|//for debugging
name|response
operator|.
name|addToCompacts
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"showCompact("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to select from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
return|return
name|response
return|;
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|showCompact
argument_list|(
name|rqst
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
name|void
name|shouldNeverHappen
parameter_list|(
name|long
name|txnid
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"This should never happen: "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
argument_list|)
throw|;
block|}
specifier|private
specifier|static
name|void
name|shouldNeverHappen
parameter_list|(
name|long
name|txnid
parameter_list|,
name|long
name|extLockId
parameter_list|,
name|long
name|intLockId
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"This should never happen: "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
operator|+
literal|" "
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
operator|+
literal|" "
operator|+
name|intLockId
argument_list|)
throw|;
block|}
specifier|public
name|void
name|addDynamicPartitions
parameter_list|(
name|AddDynamicPartitions
name|rqst
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|lockHandle
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|lockInternal
argument_list|()
expr_stmt|;
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|lockHandle
operator|=
name|lockTransactionRecord
argument_list|(
name|stmt
argument_list|,
name|rqst
operator|.
name|getTxnid
argument_list|()
argument_list|,
name|TXN_OPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockHandle
operator|==
literal|null
condition|)
block|{
comment|//ensures txn is still there and in expected state
name|ensureValidTxn
argument_list|(
name|dbConn
argument_list|,
name|rqst
operator|.
name|getTxnid
argument_list|()
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|shouldNeverHappen
argument_list|(
name|rqst
operator|.
name|getTxnid
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|partName
range|:
name|rqst
operator|.
name|getPartitionnames
argument_list|()
control|)
block|{
name|StringBuilder
name|buff
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"insert into TXN_COMPONENTS (tc_txnid, tc_database, tc_table, tc_partition) values ("
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|rqst
operator|.
name|getTxnid
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|", '"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|rqst
operator|.
name|getDbname
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|rqst
operator|.
name|getTablename
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"', '"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|partName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"')"
argument_list|)
expr_stmt|;
name|String
name|s
init|=
name|buff
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"addDynamicPartitions("
operator|+
name|rqst
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to insert into from transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|lockHandle
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
name|unlockInternal
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|addDynamicPartitions
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Clean up corresponding records in metastore tables, specifically:    * TXN_COMPONENTS, COMPLETED_TXN_COMPONENTS, COMPACTION_QUEUE, COMPLETED_COMPACTIONS    */
specifier|public
name|void
name|cleanupRecords
parameter_list|(
name|HiveObjectType
name|type
parameter_list|,
name|Database
name|db
parameter_list|,
name|Table
name|table
parameter_list|,
name|Iterator
argument_list|<
name|Partition
argument_list|>
name|partitionIterator
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|String
name|dbName
decl_stmt|;
name|String
name|tblName
decl_stmt|;
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|queries
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|buff
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DATABASE
case|:
name|dbName
operator|=
name|db
operator|.
name|getName
argument_list|()
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from TXN_COMPONENTS where tc_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from COMPLETED_TXN_COMPONENTS where ctc_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from COMPACTION_QUEUE where cq_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from COMPLETED_COMPACTIONS where cc_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TABLE
case|:
name|dbName
operator|=
name|table
operator|.
name|getDbName
argument_list|()
expr_stmt|;
name|tblName
operator|=
name|table
operator|.
name|getTableName
argument_list|()
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from TXN_COMPONENTS where tc_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and tc_table='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from COMPLETED_TXN_COMPONENTS where ctc_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and ctc_table='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from COMPACTION_QUEUE where cq_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and cq_table='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from COMPLETED_COMPACTIONS where cc_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and cc_table='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARTITION
case|:
name|dbName
operator|=
name|table
operator|.
name|getDbName
argument_list|()
expr_stmt|;
name|tblName
operator|=
name|table
operator|.
name|getTableName
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|partCols
init|=
name|table
operator|.
name|getPartitionKeys
argument_list|()
decl_stmt|;
comment|// partition columns
name|List
argument_list|<
name|String
argument_list|>
name|partVals
decl_stmt|;
comment|// partition values
name|String
name|partName
decl_stmt|;
while|while
condition|(
name|partitionIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Partition
name|p
init|=
name|partitionIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|partVals
operator|=
name|p
operator|.
name|getValues
argument_list|()
expr_stmt|;
name|partName
operator|=
name|Warehouse
operator|.
name|makePartName
argument_list|(
name|partCols
argument_list|,
name|partVals
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from TXN_COMPONENTS where tc_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and tc_table='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and tc_partition='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|partName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from COMPLETED_TXN_COMPONENTS where ctc_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and ctc_table='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and ctc_partition='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|partName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from COMPACTION_QUEUE where cq_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and cq_table='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and cq_partition='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|partName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"delete from COMPLETED_COMPACTIONS where cc_database='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and cc_table='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"' and cc_partition='"
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
name|partName
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|queries
operator|.
name|add
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Invalid object type for cleanup: "
operator|+
name|type
argument_list|)
throw|;
block|}
for|for
control|(
name|String
name|query
range|:
name|queries
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|query
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"cleanupRecords"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"does not exist"
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot perform cleanup since metastore table does not exist"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to clean up "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|cleanupRecords
argument_list|(
name|type
argument_list|,
name|db
argument_list|,
name|table
argument_list|,
name|partitionIterator
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * For testing only, do not use.    */
annotation|@
name|VisibleForTesting
specifier|public
name|int
name|numLocksInLockTable
parameter_list|()
throws|throws
name|SQLException
throws|,
name|MetaException
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select count(*) from HIVE_LOCKS"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|rs
operator|.
name|next
argument_list|()
expr_stmt|;
name|int
name|rc
init|=
name|rs
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// Necessary to clean up the transaction in the db.
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
name|rc
return|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * For testing only, do not use.    */
specifier|public
name|long
name|setTimeout
parameter_list|(
name|long
name|milliseconds
parameter_list|)
block|{
name|long
name|previous_timeout
init|=
name|timeout
decl_stmt|;
name|timeout
operator|=
name|milliseconds
expr_stmt|;
return|return
name|previous_timeout
return|;
block|}
specifier|protected
class|class
name|RetryException
extends|extends
name|Exception
block|{    }
specifier|protected
name|Connection
name|getDbConn
parameter_list|(
name|int
name|isolationLevel
parameter_list|)
throws|throws
name|SQLException
block|{
name|int
name|rc
init|=
name|doRetryOnConnPool
condition|?
literal|10
else|:
literal|1
decl_stmt|;
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|dbConn
operator|=
name|connPool
operator|.
name|getConnection
argument_list|()
expr_stmt|;
name|dbConn
operator|.
name|setAutoCommit
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|setTransactionIsolation
argument_list|(
name|isolationLevel
argument_list|)
expr_stmt|;
return|return
name|dbConn
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|--
name|rc
operator|)
operator|<=
literal|0
condition|)
throw|throw
name|e
throw|;
name|LOG
operator|.
name|error
argument_list|(
literal|"There is a problem with a connection from the pool, retrying(rc="
operator|+
name|rc
operator|+
literal|"): "
operator|+
name|getMessage
argument_list|(
name|e
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|static
name|void
name|rollbackDBConn
parameter_list|(
name|Connection
name|dbConn
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|dbConn
operator|!=
literal|null
operator|&&
operator|!
name|dbConn
operator|.
name|isClosed
argument_list|()
condition|)
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to rollback db connection "
operator|+
name|getMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
specifier|static
name|void
name|closeDbConn
parameter_list|(
name|Connection
name|dbConn
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|dbConn
operator|!=
literal|null
operator|&&
operator|!
name|dbConn
operator|.
name|isClosed
argument_list|()
condition|)
block|{
name|dbConn
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to close db connection "
operator|+
name|getMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Close statement instance.    * @param stmt statement instance.    */
specifier|protected
specifier|static
name|void
name|closeStmt
parameter_list|(
name|Statement
name|stmt
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|stmt
operator|!=
literal|null
operator|&&
operator|!
name|stmt
operator|.
name|isClosed
argument_list|()
condition|)
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to close statement "
operator|+
name|getMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Close the ResultSet.    * @param rs may be {@code null}    */
specifier|static
name|void
name|close
parameter_list|(
name|ResultSet
name|rs
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|rs
operator|!=
literal|null
operator|&&
operator|!
name|rs
operator|.
name|isClosed
argument_list|()
condition|)
block|{
name|rs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to close statement "
operator|+
name|getMessage
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Close all 3 JDBC artifacts in order: {@code rs stmt dbConn}    */
specifier|static
name|void
name|close
parameter_list|(
name|ResultSet
name|rs
parameter_list|,
name|Statement
name|stmt
parameter_list|,
name|Connection
name|dbConn
parameter_list|)
block|{
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
comment|/**    * Determine if an exception was such that it makes sense to retry.  Unfortunately there is no standard way to do    * this, so we have to inspect the error messages and catch the telltale signs for each    * different database.  This method will throw {@code RetryException}    * if the error is retry-able.    * @param conn database connection    * @param e exception that was thrown.    * @param caller name of the method calling this (and other info useful to log)    * @throws org.apache.hadoop.hive.metastore.txn.TxnHandler.RetryException when the operation should be retried    */
specifier|protected
name|void
name|checkRetryable
parameter_list|(
name|Connection
name|conn
parameter_list|,
name|SQLException
name|e
parameter_list|,
name|String
name|caller
parameter_list|)
throws|throws
name|RetryException
throws|,
name|MetaException
block|{
comment|// If you change this function, remove the @Ignore from TestTxnHandler.deadlockIsDetected()
comment|// to test these changes.
comment|// MySQL and MSSQL use 40001 as the state code for rollback.  Postgres uses 40001 and 40P01.
comment|// Oracle seems to return different SQLStates and messages each time,
comment|// so I've tried to capture the different error messages (there appear to be fewer different
comment|// error messages than SQL states).
comment|// Derby and newer MySQL driver use the new SQLTransactionRollbackException
name|boolean
name|sendRetrySignal
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|dbProduct
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"DB Type not determined yet."
argument_list|)
throw|;
block|}
if|if
condition|(
name|e
operator|instanceof
name|SQLTransactionRollbackException
operator|||
operator|(
operator|(
name|dbProduct
operator|==
name|DatabaseProduct
operator|.
name|MYSQL
operator|||
name|dbProduct
operator|==
name|DatabaseProduct
operator|.
name|POSTGRES
operator|||
name|dbProduct
operator|==
name|DatabaseProduct
operator|.
name|SQLSERVER
operator|)
operator|&&
name|e
operator|.
name|getSQLState
argument_list|()
operator|.
name|equals
argument_list|(
literal|"40001"
argument_list|)
operator|)
operator|||
operator|(
name|dbProduct
operator|==
name|DatabaseProduct
operator|.
name|POSTGRES
operator|&&
name|e
operator|.
name|getSQLState
argument_list|()
operator|.
name|equals
argument_list|(
literal|"40P01"
argument_list|)
operator|)
operator|||
operator|(
name|dbProduct
operator|==
name|DatabaseProduct
operator|.
name|ORACLE
operator|&&
operator|(
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"deadlock detected"
argument_list|)
operator|||
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"can't serialize access for this transaction"
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|deadlockCnt
operator|++
operator|<
name|ALLOWED_REPEATED_DEADLOCKS
condition|)
block|{
name|long
name|waitInterval
init|=
name|deadlockRetryInterval
operator|*
name|deadlockCnt
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Deadlock detected in "
operator|+
name|caller
operator|+
literal|". Will wait "
operator|+
name|waitInterval
operator|+
literal|"ms try again up to "
operator|+
operator|(
name|ALLOWED_REPEATED_DEADLOCKS
operator|-
name|deadlockCnt
operator|+
literal|1
operator|)
operator|+
literal|" times."
argument_list|)
expr_stmt|;
comment|// Pause for a just a bit for retrying to avoid immediately jumping back into the deadlock.
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|waitInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// NOP
block|}
name|sendRetrySignal
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Too many repeated deadlocks in "
operator|+
name|caller
operator|+
literal|", giving up."
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isRetryable
argument_list|(
name|conf
argument_list|,
name|e
argument_list|)
condition|)
block|{
comment|//in MSSQL this means Communication Link Failure
if|if
condition|(
name|retryNum
operator|++
operator|<
name|retryLimit
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Retryable error detected in "
operator|+
name|caller
operator|+
literal|".  Will wait "
operator|+
name|retryInterval
operator|+
literal|"ms and retry up to "
operator|+
operator|(
name|retryLimit
operator|-
name|retryNum
operator|+
literal|1
operator|)
operator|+
literal|" times.  Error: "
operator|+
name|getMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|retryInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
comment|//
block|}
name|sendRetrySignal
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Fatal error. Retry limit ("
operator|+
name|retryLimit
operator|+
literal|") reached. Last error: "
operator|+
name|getMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//make sure we know we saw an error that we don't recognize
name|LOG
operator|.
name|info
argument_list|(
literal|"Non-retryable error: "
operator|+
name|getMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|/*if this method ends with anything except a retry signal, the caller should fail the operation       and propagate the error up to the its caller (Metastore client); thus must reset retry counters*/
if|if
condition|(
operator|!
name|sendRetrySignal
condition|)
block|{
name|deadlockCnt
operator|=
literal|0
expr_stmt|;
name|retryNum
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sendRetrySignal
condition|)
block|{
throw|throw
operator|new
name|RetryException
argument_list|()
throw|;
block|}
block|}
comment|/**    * Determine the current time, using the RDBMS as a source of truth    * @param conn database connection    * @return current time in milliseconds    * @throws org.apache.hadoop.hive.metastore.api.MetaException if the time cannot be determined    */
specifier|protected
name|long
name|getDbTime
parameter_list|(
name|Connection
name|conn
parameter_list|)
throws|throws
name|MetaException
block|{
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|conn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
decl_stmt|;
switch|switch
condition|(
name|dbProduct
condition|)
block|{
case|case
name|DERBY
case|:
name|s
operator|=
literal|"values current_timestamp"
expr_stmt|;
break|break;
case|case
name|MYSQL
case|:
case|case
name|POSTGRES
case|:
case|case
name|SQLSERVER
case|:
name|s
operator|=
literal|"select current_timestamp"
expr_stmt|;
break|break;
case|case
name|ORACLE
case|:
name|s
operator|=
literal|"select current_timestamp from dual"
expr_stmt|;
break|break;
default|default:
name|String
name|msg
init|=
literal|"Unknown database product: "
operator|+
name|dbProduct
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"No results from date query"
argument_list|)
throw|;
return|return
name|rs
operator|.
name|getTimestamp
argument_list|(
literal|1
argument_list|)
operator|.
name|getTime
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"Unable to determine current time: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Determine the String that should be used to quote identifiers.    * @param conn Active connection    * @return quotes    * @throws SQLException    */
specifier|protected
name|String
name|getIdentifierQuoteString
parameter_list|(
name|Connection
name|conn
parameter_list|)
throws|throws
name|SQLException
block|{
if|if
condition|(
name|identifierQuoteString
operator|==
literal|null
condition|)
block|{
name|identifierQuoteString
operator|=
name|conn
operator|.
name|getMetaData
argument_list|()
operator|.
name|getIdentifierQuoteString
argument_list|()
expr_stmt|;
block|}
return|return
name|identifierQuoteString
return|;
block|}
specifier|protected
enum|enum
name|DatabaseProduct
block|{
name|DERBY
block|,
name|MYSQL
block|,
name|POSTGRES
block|,
name|ORACLE
block|,
name|SQLSERVER
block|}
comment|/**    * Determine the database product type    * @param conn database connection    * @return database product type    */
specifier|private
name|DatabaseProduct
name|determineDatabaseProduct
parameter_list|(
name|Connection
name|conn
parameter_list|)
block|{
if|if
condition|(
name|dbProduct
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|String
name|s
init|=
name|conn
operator|.
name|getMetaData
argument_list|()
operator|.
name|getDatabaseProductName
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
name|String
name|msg
init|=
literal|"getDatabaseProductName returns null, can't determine database product"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"Apache Derby"
argument_list|)
condition|)
block|{
name|dbProduct
operator|=
name|DatabaseProduct
operator|.
name|DERBY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"Microsoft SQL Server"
argument_list|)
condition|)
block|{
name|dbProduct
operator|=
name|DatabaseProduct
operator|.
name|SQLSERVER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"MySQL"
argument_list|)
condition|)
block|{
name|dbProduct
operator|=
name|DatabaseProduct
operator|.
name|MYSQL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"Oracle"
argument_list|)
condition|)
block|{
name|dbProduct
operator|=
name|DatabaseProduct
operator|.
name|ORACLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"PostgreSQL"
argument_list|)
condition|)
block|{
name|dbProduct
operator|=
name|DatabaseProduct
operator|.
name|POSTGRES
expr_stmt|;
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"Unrecognized database product name<"
operator|+
name|s
operator|+
literal|">"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"Unable to get database product name: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
return|return
name|dbProduct
return|;
block|}
specifier|private
specifier|static
class|class
name|LockInfo
block|{
specifier|private
specifier|final
name|long
name|extLockId
decl_stmt|;
specifier|private
specifier|final
name|long
name|intLockId
decl_stmt|;
comment|//0 means there is no transaction, i.e. it a select statement which is not part of
comment|//explicit transaction or a IUD statement that is not writing to ACID table
specifier|private
specifier|final
name|long
name|txnId
decl_stmt|;
specifier|private
specifier|final
name|String
name|db
decl_stmt|;
specifier|private
specifier|final
name|String
name|table
decl_stmt|;
specifier|private
specifier|final
name|String
name|partition
decl_stmt|;
specifier|private
specifier|final
name|LockState
name|state
decl_stmt|;
specifier|private
specifier|final
name|LockType
name|type
decl_stmt|;
comment|// Assumes the result set is set to a valid row
name|LockInfo
parameter_list|(
name|ResultSet
name|rs
parameter_list|)
throws|throws
name|SQLException
throws|,
name|MetaException
block|{
name|extLockId
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|"hl_lock_ext_id"
argument_list|)
expr_stmt|;
comment|// can't be null
name|intLockId
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|"hl_lock_int_id"
argument_list|)
expr_stmt|;
comment|// can't be null
name|db
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_db"
argument_list|)
expr_stmt|;
comment|// can't be null
name|String
name|t
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_table"
argument_list|)
decl_stmt|;
name|table
operator|=
operator|(
name|rs
operator|.
name|wasNull
argument_list|()
condition|?
literal|null
else|:
name|t
operator|)
expr_stmt|;
name|String
name|p
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_partition"
argument_list|)
decl_stmt|;
name|partition
operator|=
operator|(
name|rs
operator|.
name|wasNull
argument_list|()
condition|?
literal|null
else|:
name|p
operator|)
expr_stmt|;
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_lock_state"
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|LOCK_WAITING
case|:
name|state
operator|=
name|LockState
operator|.
name|WAITING
expr_stmt|;
break|break;
case|case
name|LOCK_ACQUIRED
case|:
name|state
operator|=
name|LockState
operator|.
name|ACQUIRED
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unknown lock state "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_lock_state"
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_lock_type"
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|LOCK_EXCLUSIVE
case|:
name|type
operator|=
name|LockType
operator|.
name|EXCLUSIVE
expr_stmt|;
break|break;
case|case
name|LOCK_SHARED
case|:
name|type
operator|=
name|LockType
operator|.
name|SHARED_READ
expr_stmt|;
break|break;
case|case
name|LOCK_SEMI_SHARED
case|:
name|type
operator|=
name|LockType
operator|.
name|SHARED_WRITE
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unknown lock type "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|"hl_lock_type"
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
throw|;
block|}
name|txnId
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|"hl_txnid"
argument_list|)
expr_stmt|;
comment|//returns 0 if value is NULL
block|}
name|LockInfo
parameter_list|(
name|ShowLocksResponseElement
name|e
parameter_list|)
block|{
name|extLockId
operator|=
name|e
operator|.
name|getLockid
argument_list|()
expr_stmt|;
name|intLockId
operator|=
name|e
operator|.
name|getLockIdInternal
argument_list|()
expr_stmt|;
name|txnId
operator|=
name|e
operator|.
name|getTxnid
argument_list|()
expr_stmt|;
name|db
operator|=
name|e
operator|.
name|getDbname
argument_list|()
expr_stmt|;
name|table
operator|=
name|e
operator|.
name|getTablename
argument_list|()
expr_stmt|;
name|partition
operator|=
name|e
operator|.
name|getPartname
argument_list|()
expr_stmt|;
name|state
operator|=
name|e
operator|.
name|getState
argument_list|()
expr_stmt|;
name|type
operator|=
name|e
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|other
operator|instanceof
name|LockInfo
operator|)
condition|)
return|return
literal|false
return|;
name|LockInfo
name|o
init|=
operator|(
name|LockInfo
operator|)
name|other
decl_stmt|;
comment|// Lock ids are unique across the system.
return|return
name|extLockId
operator|==
name|o
operator|.
name|extLockId
operator|&&
name|intLockId
operator|==
name|o
operator|.
name|intLockId
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
operator|+
literal|" intLockId:"
operator|+
name|intLockId
operator|+
literal|" "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnId
argument_list|)
operator|+
literal|" db:"
operator|+
name|db
operator|+
literal|" table:"
operator|+
name|table
operator|+
literal|" partition:"
operator|+
name|partition
operator|+
literal|" state:"
operator|+
operator|(
name|state
operator|==
literal|null
condition|?
literal|"null"
else|:
name|state
operator|.
name|toString
argument_list|()
operator|)
operator|+
literal|" type:"
operator|+
operator|(
name|type
operator|==
literal|null
condition|?
literal|"null"
else|:
name|type
operator|.
name|toString
argument_list|()
operator|)
return|;
block|}
specifier|private
name|boolean
name|isDbLock
parameter_list|()
block|{
return|return
name|db
operator|!=
literal|null
operator|&&
name|table
operator|==
literal|null
operator|&&
name|partition
operator|==
literal|null
return|;
block|}
specifier|private
name|boolean
name|isTableLock
parameter_list|()
block|{
return|return
name|db
operator|!=
literal|null
operator|&&
name|table
operator|!=
literal|null
operator|&&
name|partition
operator|==
literal|null
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|LockInfoComparator
implements|implements
name|Comparator
argument_list|<
name|LockInfo
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|LockTypeComparator
name|lockTypeComparator
init|=
operator|new
name|LockTypeComparator
argument_list|()
decl_stmt|;
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
return|return
name|this
operator|==
name|other
return|;
block|}
specifier|public
name|int
name|compare
parameter_list|(
name|LockInfo
name|info1
parameter_list|,
name|LockInfo
name|info2
parameter_list|)
block|{
comment|// We sort by state (acquired vs waiting) and then by LockType, they by id
if|if
condition|(
name|info1
operator|.
name|state
operator|==
name|LockState
operator|.
name|ACQUIRED
operator|&&
name|info2
operator|.
name|state
operator|!=
name|LockState
operator|.
name|ACQUIRED
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|info1
operator|.
name|state
operator|!=
name|LockState
operator|.
name|ACQUIRED
operator|&&
name|info2
operator|.
name|state
operator|==
name|LockState
operator|.
name|ACQUIRED
condition|)
block|{
return|return
literal|1
return|;
block|}
name|int
name|sortByType
init|=
name|lockTypeComparator
operator|.
name|compare
argument_list|(
name|info1
operator|.
name|type
argument_list|,
name|info2
operator|.
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|sortByType
operator|!=
literal|0
condition|)
block|{
return|return
name|sortByType
return|;
block|}
if|if
condition|(
name|info1
operator|.
name|extLockId
operator|<
name|info2
operator|.
name|extLockId
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|info1
operator|.
name|extLockId
operator|>
name|info2
operator|.
name|extLockId
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|info1
operator|.
name|intLockId
operator|<
name|info2
operator|.
name|intLockId
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|info1
operator|.
name|intLockId
operator|>
name|info2
operator|.
name|intLockId
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
comment|/**    * Sort more restrictive locks after less restrictive ones    */
specifier|private
specifier|final
specifier|static
class|class
name|LockTypeComparator
implements|implements
name|Comparator
argument_list|<
name|LockType
argument_list|>
block|{
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
return|return
name|this
operator|==
name|other
return|;
block|}
specifier|public
name|int
name|compare
parameter_list|(
name|LockType
name|t1
parameter_list|,
name|LockType
name|t2
parameter_list|)
block|{
switch|switch
condition|(
name|t1
condition|)
block|{
case|case
name|EXCLUSIVE
case|:
if|if
condition|(
name|t2
operator|==
name|LockType
operator|.
name|EXCLUSIVE
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
case|case
name|SHARED_WRITE
case|:
switch|switch
condition|(
name|t2
condition|)
block|{
case|case
name|EXCLUSIVE
case|:
return|return
operator|-
literal|1
return|;
case|case
name|SHARED_WRITE
case|:
return|return
literal|0
return|;
case|case
name|SHARED_READ
case|:
return|return
literal|1
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected LockType: "
operator|+
name|t2
argument_list|)
throw|;
block|}
case|case
name|SHARED_READ
case|:
if|if
condition|(
name|t2
operator|==
name|LockType
operator|.
name|SHARED_READ
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected LockType: "
operator|+
name|t1
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
enum|enum
name|LockAction
block|{
name|ACQUIRE
block|,
name|WAIT
block|,
name|KEEP_LOOKING
block|}
comment|// A jump table to figure out whether to wait, acquire,
comment|// or keep looking .  Since
comment|// java doesn't have function pointers (grumble grumble) we store a
comment|// character that we'll use to determine which function to call.
comment|// The table maps the lock type of the lock we are looking to acquire to
comment|// the lock type of the lock we are checking to the lock state of the lock
comment|// we are checking to the desired action.
specifier|private
specifier|static
name|Map
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
argument_list|>
name|jumpTable
decl_stmt|;
specifier|private
name|void
name|checkQFileTestHack
parameter_list|()
block|{
name|boolean
name|hackOn
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_IN_TEST
argument_list|)
operator|||
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_IN_TEZ_TEST
argument_list|)
decl_stmt|;
if|if
condition|(
name|hackOn
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Hacking in canned values for transaction manager"
argument_list|)
expr_stmt|;
comment|// Set up the transaction/locking db in the derby metastore
name|TxnDbUtil
operator|.
name|setConfValues
argument_list|(
name|conf
argument_list|)
expr_stmt|;
try|try
block|{
name|TxnDbUtil
operator|.
name|prepDb
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// We may have already created the tables and thus don't need to redo it.
if|if
condition|(
name|e
operator|.
name|getMessage
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"already exists"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unable to set up transaction database for"
operator|+
literal|" testing: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
specifier|private
name|int
name|abortTxns
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|List
argument_list|<
name|Long
argument_list|>
name|txnids
parameter_list|)
throws|throws
name|SQLException
block|{
return|return
name|abortTxns
argument_list|(
name|dbConn
argument_list|,
name|txnids
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**    * TODO: expose this as an operation to client.  Useful for streaming API to abort all remaining    * trasnactions in a batch on IOExceptions.    * Caller must rollback the transaction if not all transactions were aborted since this will not    * attempt to delete associated locks in this case.    *    * @param dbConn An active connection    * @param txnids list of transactions to abort    * @param max_heartbeat value used by {@link #performTimeOuts()} to ensure this doesn't Abort txn which were    *                      hearbetated after #performTimeOuts() select and this operation.    * @return Number of aborted transactions    * @throws SQLException    */
specifier|private
name|int
name|abortTxns
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|List
argument_list|<
name|Long
argument_list|>
name|txnids
parameter_list|,
name|long
name|max_heartbeat
parameter_list|)
throws|throws
name|SQLException
block|{
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|int
name|updateCnt
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|txnids
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
comment|//This is an update statement, thus at any Isolation level will take Write locks so will block
comment|//all other ops using S4U on TXNS row.
name|List
argument_list|<
name|String
argument_list|>
name|queries
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|prefix
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|StringBuilder
name|suffix
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|prefix
operator|.
name|append
argument_list|(
literal|"update TXNS set txn_state = "
operator|+
name|quoteChar
argument_list|(
name|TXN_ABORTED
argument_list|)
operator|+
literal|" where txn_state = "
operator|+
name|quoteChar
argument_list|(
name|TXN_OPEN
argument_list|)
operator|+
literal|" and "
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_heartbeat
operator|>
literal|0
condition|)
block|{
name|suffix
operator|.
name|append
argument_list|(
literal|" and txn_last_heartbeat< "
argument_list|)
operator|.
name|append
argument_list|(
name|max_heartbeat
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|suffix
operator|.
name|append
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|TxnUtils
operator|.
name|buildQueryWithINClause
argument_list|(
name|conf
argument_list|,
name|queries
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|,
name|txnids
argument_list|,
literal|"txn_id"
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|query
range|:
name|queries
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|query
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|updateCnt
operator|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|updateCnt
operator|<
name|txnids
operator|.
name|size
argument_list|()
condition|)
block|{
comment|/**            * have to bail in this case since we don't know which transactions were not Aborted and            * thus don't know which locks to delete            * This may happen due to a race between {@link #heartbeat(HeartbeatRequest)}  operation and            * {@link #performTimeOuts()}            */
return|return
name|updateCnt
return|;
block|}
block|}
name|queries
operator|.
name|clear
argument_list|()
expr_stmt|;
name|prefix
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|suffix
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|prefix
operator|.
name|append
argument_list|(
literal|"delete from HIVE_LOCKS where "
argument_list|)
expr_stmt|;
name|suffix
operator|.
name|append
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|TxnUtils
operator|.
name|buildQueryWithINClause
argument_list|(
name|conf
argument_list|,
name|queries
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|,
name|txnids
argument_list|,
literal|"hl_txnid"
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|query
range|:
name|queries
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|query
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removed "
operator|+
name|rc
operator|+
literal|" records from HIVE_LOCKS"
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
return|return
name|updateCnt
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isValidTxn
parameter_list|(
name|long
name|txnId
parameter_list|)
block|{
return|return
name|txnId
operator|!=
literal|0
return|;
block|}
comment|/**    * Note: this calls acquire() for (extLockId,intLockId) but extLockId is the same and we either take    * all locks for given extLockId or none.  Would be more efficient to update state on all locks    * at once.  Semantics are the same since this is all part of the same txn@serializable.    *    * Lock acquisition is meant to be fair, so every lock can only block on some lock with smaller    * hl_lock_ext_id by only checking earlier locks.    */
specifier|private
name|LockResponse
name|checkLock
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|extLockId
parameter_list|)
throws|throws
name|NoSuchLockException
throws|,
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|MetaException
throws|,
name|SQLException
block|{
if|if
condition|(
name|dbConn
operator|.
name|getTransactionIsolation
argument_list|()
operator|!=
name|Connection
operator|.
name|TRANSACTION_SERIALIZABLE
condition|)
block|{
comment|//longer term we should instead use AUX_TABLE/S4U to serialize all checkLock() operations
comment|//that would be less prone to deadlocks
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unexpected Isolation Level: "
operator|+
name|dbConn
operator|.
name|getTransactionIsolation
argument_list|()
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|LockInfo
argument_list|>
name|locksBeingChecked
init|=
name|getLockInfoFromLockId
argument_list|(
name|dbConn
argument_list|,
name|extLockId
argument_list|)
decl_stmt|;
comment|//being acquired now
name|LockResponse
name|response
init|=
operator|new
name|LockResponse
argument_list|()
decl_stmt|;
name|response
operator|.
name|setLockid
argument_list|(
name|extLockId
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"checkLock(): Setting savepoint. extLockId="
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
argument_list|)
expr_stmt|;
name|Savepoint
name|save
init|=
name|dbConn
operator|.
name|setSavepoint
argument_list|()
decl_stmt|;
comment|//todo: get rid of this
name|StringBuilder
name|query
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"select hl_lock_ext_id, "
operator|+
literal|"hl_lock_int_id, hl_db, hl_table, hl_partition, hl_lock_state, "
operator|+
literal|"hl_lock_type, hl_txnid from HIVE_LOCKS where hl_db in ("
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|strings
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|locksBeingChecked
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|LockInfo
name|info
range|:
name|locksBeingChecked
control|)
block|{
name|strings
operator|.
name|add
argument_list|(
name|info
operator|.
name|db
argument_list|)
expr_stmt|;
block|}
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|strings
control|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|false
expr_stmt|;
else|else
name|query
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
name|query
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
comment|// If any of the table requests are null, then I need to pull all the
comment|// table locks for this db.
name|boolean
name|sawNull
init|=
literal|false
decl_stmt|;
name|strings
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|LockInfo
name|info
range|:
name|locksBeingChecked
control|)
block|{
if|if
condition|(
name|info
operator|.
name|table
operator|==
literal|null
condition|)
block|{
name|sawNull
operator|=
literal|true
expr_stmt|;
break|break;
block|}
else|else
block|{
name|strings
operator|.
name|add
argument_list|(
name|info
operator|.
name|table
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|sawNull
condition|)
block|{
name|query
operator|.
name|append
argument_list|(
literal|" and (hl_table is null or hl_table in("
argument_list|)
expr_stmt|;
name|first
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|strings
control|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|false
expr_stmt|;
else|else
name|query
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
name|query
operator|.
name|append
argument_list|(
literal|"))"
argument_list|)
expr_stmt|;
comment|// If any of the partition requests are null, then I need to pull all
comment|// partition locks for this table.
name|sawNull
operator|=
literal|false
expr_stmt|;
name|strings
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|LockInfo
name|info
range|:
name|locksBeingChecked
control|)
block|{
if|if
condition|(
name|info
operator|.
name|partition
operator|==
literal|null
condition|)
block|{
name|sawNull
operator|=
literal|true
expr_stmt|;
break|break;
block|}
else|else
block|{
name|strings
operator|.
name|add
argument_list|(
name|info
operator|.
name|partition
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|sawNull
condition|)
block|{
name|query
operator|.
name|append
argument_list|(
literal|" and (hl_partition is null or hl_partition in("
argument_list|)
expr_stmt|;
name|first
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|strings
control|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|false
expr_stmt|;
else|else
name|query
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
name|query
operator|.
name|append
argument_list|(
literal|"))"
argument_list|)
expr_stmt|;
block|}
block|}
name|query
operator|.
name|append
argument_list|(
literal|" and hl_lock_ext_id<= "
argument_list|)
operator|.
name|append
argument_list|(
name|extLockId
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|query
operator|.
name|toString
argument_list|()
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|query
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|SortedSet
argument_list|<
name|LockInfo
argument_list|>
name|lockSet
init|=
operator|new
name|TreeSet
argument_list|<
name|LockInfo
argument_list|>
argument_list|(
operator|new
name|LockInfoComparator
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|lockSet
operator|.
name|add
argument_list|(
operator|new
name|LockInfo
argument_list|(
name|rs
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Turn the tree set into an array so we can move back and forth easily
comment|// in it.
name|LockInfo
index|[]
name|locks
init|=
name|lockSet
operator|.
name|toArray
argument_list|(
operator|new
name|LockInfo
index|[
name|lockSet
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Locks to check(full): "
argument_list|)
expr_stmt|;
for|for
control|(
name|LockInfo
name|info
range|:
name|locks
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"  "
operator|+
name|info
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|LockInfo
name|info
range|:
name|locksBeingChecked
control|)
block|{
comment|// Find the lock record we're checking
name|int
name|index
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|locks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|locks
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|index
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|// If we didn't find the lock, then it must not be in the table
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"How did we get here, we heartbeated our lock before we started! ( "
operator|+
name|info
operator|+
literal|")"
argument_list|)
throw|;
block|}
comment|// If we've found it and it's already been marked acquired,
comment|// then just look at the other locks.
if|if
condition|(
name|locks
index|[
name|index
index|]
operator|.
name|state
operator|==
name|LockState
operator|.
name|ACQUIRED
condition|)
block|{
continue|continue;
block|}
comment|// Look at everything in front of this lock to see if it should block
comment|// it or not.
name|boolean
name|acquired
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|index
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|// Check if we're operating on the same database, if not, move on
if|if
condition|(
operator|!
name|locks
index|[
name|index
index|]
operator|.
name|db
operator|.
name|equals
argument_list|(
name|locks
index|[
name|i
index|]
operator|.
name|db
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// If table is null on either of these, then they are claiming to
comment|// lock the whole database and we need to check it.  Otherwise,
comment|// check if they are operating on the same table, if not, move on.
if|if
condition|(
name|locks
index|[
name|index
index|]
operator|.
name|table
operator|!=
literal|null
operator|&&
name|locks
index|[
name|i
index|]
operator|.
name|table
operator|!=
literal|null
operator|&&
operator|!
name|locks
index|[
name|index
index|]
operator|.
name|table
operator|.
name|equals
argument_list|(
name|locks
index|[
name|i
index|]
operator|.
name|table
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// If partition is null on either of these, then they are claiming to
comment|// lock the whole table and we need to check it.  Otherwise,
comment|// check if they are operating on the same partition, if not, move on.
if|if
condition|(
name|locks
index|[
name|index
index|]
operator|.
name|partition
operator|!=
literal|null
operator|&&
name|locks
index|[
name|i
index|]
operator|.
name|partition
operator|!=
literal|null
operator|&&
operator|!
name|locks
index|[
name|index
index|]
operator|.
name|partition
operator|.
name|equals
argument_list|(
name|locks
index|[
name|i
index|]
operator|.
name|partition
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// We've found something that matches what we're trying to lock,
comment|// so figure out if we can lock it too.
name|LockAction
name|lockAction
init|=
name|jumpTable
operator|.
name|get
argument_list|(
name|locks
index|[
name|index
index|]
operator|.
name|type
argument_list|)
operator|.
name|get
argument_list|(
name|locks
index|[
name|i
index|]
operator|.
name|type
argument_list|)
operator|.
name|get
argument_list|(
name|locks
index|[
name|i
index|]
operator|.
name|state
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"desired Lock: "
operator|+
name|info
operator|+
literal|" checked Lock: "
operator|+
name|locks
index|[
name|i
index|]
operator|+
literal|" action: "
operator|+
name|lockAction
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lockAction
condition|)
block|{
case|case
name|WAIT
case|:
if|if
condition|(
operator|!
name|ignoreConflict
argument_list|(
name|info
argument_list|,
name|locks
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/*we acquire all locks for a given query atomically; if 1 blocks, all go into (remain) in                 * Waiting state.  wait() will undo any 'acquire()' which may have happened as part of                 * this (metastore db) transaction and then we record which lock blocked the lock                 * we were testing ('info').*/
name|wait
argument_list|(
name|dbConn
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|String
name|sqlText
init|=
literal|"update HIVE_LOCKS"
operator|+
literal|" set HL_BLOCKEDBY_EXT_ID="
operator|+
name|locks
index|[
name|i
index|]
operator|.
name|extLockId
operator|+
literal|", HL_BLOCKEDBY_INT_ID="
operator|+
name|locks
index|[
name|i
index|]
operator|.
name|intLockId
operator|+
literal|" where HL_LOCK_EXT_ID="
operator|+
name|info
operator|.
name|extLockId
operator|+
literal|" and HL_LOCK_INT_ID="
operator|+
name|info
operator|.
name|intLockId
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Executing sql: "
operator|+
name|sqlText
argument_list|)
expr_stmt|;
name|int
name|updCnt
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|sqlText
argument_list|)
decl_stmt|;
if|if
condition|(
name|updCnt
operator|!=
literal|1
condition|)
block|{
name|shouldNeverHappen
argument_list|(
name|info
operator|.
name|txnId
argument_list|,
name|info
operator|.
name|extLockId
argument_list|,
name|info
operator|.
name|intLockId
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
name|response
operator|.
name|setState
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Lock("
operator|+
name|info
operator|+
literal|") waiting for Lock("
operator|+
name|locks
index|[
name|i
index|]
operator|+
literal|")"
argument_list|)
expr_stmt|;
return|return
name|response
return|;
block|}
comment|//fall through to ACQUIRE
case|case
name|ACQUIRE
case|:
name|acquire
argument_list|(
name|dbConn
argument_list|,
name|stmt
argument_list|,
name|extLockId
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|acquired
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|KEEP_LOOKING
case|:
continue|continue;
block|}
if|if
condition|(
name|acquired
condition|)
break|break;
comment|// We've acquired this lock component,
comment|// so get out of the loop and look at the next component.
block|}
comment|// If we've arrived here and we have not already acquired, it means there's nothing in the
comment|// way of the lock, so acquire the lock.
if|if
condition|(
operator|!
name|acquired
condition|)
name|acquire
argument_list|(
name|dbConn
argument_list|,
name|stmt
argument_list|,
name|extLockId
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
comment|// We acquired all of the locks, so commit and return acquired.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
name|response
operator|.
name|setState
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|response
return|;
block|}
comment|/**    * the {@link #jumpTable} only deals with LockState/LockType.  In some cases it's not    * sufficient.  For example, an EXCLUSIVE lock on partition should prevent SHARED_READ    * on the table, but there is no reason for EXCLUSIVE on a table to prevent SHARED_READ    * on a database.    */
specifier|private
name|boolean
name|ignoreConflict
parameter_list|(
name|LockInfo
name|desiredLock
parameter_list|,
name|LockInfo
name|existingLock
parameter_list|)
block|{
return|return
operator|(
operator|(
name|desiredLock
operator|.
name|isDbLock
argument_list|()
operator|&&
name|desiredLock
operator|.
name|type
operator|==
name|LockType
operator|.
name|SHARED_READ
operator|&&
name|existingLock
operator|.
name|isTableLock
argument_list|()
operator|&&
name|existingLock
operator|.
name|type
operator|==
name|LockType
operator|.
name|EXCLUSIVE
operator|)
operator|||
operator|(
name|existingLock
operator|.
name|isDbLock
argument_list|()
operator|&&
name|existingLock
operator|.
name|type
operator|==
name|LockType
operator|.
name|SHARED_READ
operator|&&
name|desiredLock
operator|.
name|isTableLock
argument_list|()
operator|&&
name|desiredLock
operator|.
name|type
operator|==
name|LockType
operator|.
name|EXCLUSIVE
operator|)
operator|)
operator|||
comment|//different locks from same txn should not conflict with each other
operator|(
name|desiredLock
operator|.
name|txnId
operator|!=
literal|0
operator|&&
name|desiredLock
operator|.
name|txnId
operator|==
name|existingLock
operator|.
name|txnId
operator|)
operator|||
comment|//txnId=0 means it's a select or IUD which does not write to ACID table, e.g
comment|//insert overwrite table T partition(p=1) select a,b from T and autoCommit=true
operator|(
name|desiredLock
operator|.
name|txnId
operator|==
literal|0
operator|&&
name|desiredLock
operator|.
name|extLockId
operator|==
name|existingLock
operator|.
name|extLockId
operator|)
return|;
block|}
specifier|private
name|void
name|wait
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|Savepoint
name|save
parameter_list|)
throws|throws
name|SQLException
block|{
comment|// Need to rollback because we did a select that acquired locks but we didn't
comment|// actually update anything.  Also, we may have locked some locks as
comment|// acquired that we now want to not acquire.  It's ok to rollback because
comment|// once we see one wait, we're done, we won't look for more.
comment|// Only rollback to savepoint because we want to commit our heartbeat
comment|// changes.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback to savepoint"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|(
name|save
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|acquire
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|Statement
name|stmt
parameter_list|,
name|long
name|extLockId
parameter_list|,
name|LockInfo
name|lockInfo
parameter_list|)
throws|throws
name|SQLException
throws|,
name|NoSuchLockException
throws|,
name|MetaException
block|{
name|long
name|now
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|String
name|s
init|=
literal|"update HIVE_LOCKS set hl_lock_state = '"
operator|+
name|LOCK_ACQUIRED
operator|+
literal|"', "
operator|+
comment|//if lock is part of txn, heartbeat info is in txn record
literal|"hl_last_heartbeat = "
operator|+
operator|(
name|isValidTxn
argument_list|(
name|lockInfo
operator|.
name|txnId
argument_list|)
condition|?
literal|0
else|:
name|now
operator|)
operator|+
literal|", hl_acquired_at = "
operator|+
name|now
operator|+
literal|" where hl_lock_ext_id = "
operator|+
name|extLockId
operator|+
literal|" and hl_lock_int_id = "
operator|+
name|lockInfo
operator|.
name|intLockId
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|NoSuchLockException
argument_list|(
literal|"No such lock: ("
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
operator|+
literal|","
operator|+
operator|+
name|lockInfo
operator|.
name|intLockId
operator|+
literal|") "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|lockInfo
operator|.
name|txnId
argument_list|)
argument_list|)
throw|;
block|}
comment|// We update the database, but we don't commit because there may be other
comment|// locks together with this, and we only want to acquire one if we can
comment|// acquire all.
block|}
comment|/**    * Heartbeats on the lock table.  This commits, so do not enter it with any state.    * Should not be called on a lock that belongs to transaction.    */
specifier|private
name|void
name|heartbeatLock
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|extLockId
parameter_list|)
throws|throws
name|NoSuchLockException
throws|,
name|SQLException
throws|,
name|MetaException
block|{
comment|// If the lock id is 0, then there are no locks in this heartbeat
if|if
condition|(
name|extLockId
operator|==
literal|0
condition|)
return|return;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|long
name|now
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|String
name|s
init|=
literal|"update HIVE_LOCKS set hl_last_heartbeat = "
operator|+
name|now
operator|+
literal|" where hl_lock_ext_id = "
operator|+
name|extLockId
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|NoSuchLockException
argument_list|(
literal|"No such lock: "
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Heartbeats on the txn table.  This commits, so do not enter it with any state
specifier|private
name|void
name|heartbeatTxn
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|txnid
parameter_list|)
throws|throws
name|NoSuchTxnException
throws|,
name|TxnAbortedException
throws|,
name|SQLException
throws|,
name|MetaException
block|{
comment|// If the txnid is 0, then there are no transactions in this heartbeat
if|if
condition|(
name|txnid
operator|==
literal|0
condition|)
return|return;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|long
name|now
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|String
name|s
init|=
literal|"update TXNS set txn_last_heartbeat = "
operator|+
name|now
operator|+
literal|" where txn_id = "
operator|+
name|txnid
operator|+
literal|" and txn_state = '"
operator|+
name|TXN_OPEN
operator|+
literal|"'"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|<
literal|1
condition|)
block|{
name|ensureValidTxn
argument_list|(
name|dbConn
argument_list|,
name|txnid
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
comment|// This should now throw some useful exception.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Can neither heartbeat txn nor confirm it as invalid."
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|NoSuchTxnException
argument_list|(
literal|"No such txn: "
operator|+
name|txnid
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|ensureValidTxn
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|txnid
parameter_list|,
name|Statement
name|stmt
parameter_list|)
throws|throws
name|SQLException
throws|,
name|NoSuchTxnException
throws|,
name|TxnAbortedException
block|{
comment|// We need to check whether this transaction is valid and open
name|String
name|s
init|=
literal|"select txn_state from TXNS where txn_id = "
operator|+
name|txnid
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
comment|//todo: add LIMIT 1 instead of count - should be more efficient
name|s
operator|=
literal|"select count(*) from COMPLETED_TXN_COMPONENTS where CTC_TXNID = "
operator|+
name|txnid
expr_stmt|;
name|ResultSet
name|rs2
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|boolean
name|alreadyCommitted
init|=
name|rs2
operator|.
name|next
argument_list|()
operator|&&
name|rs2
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
operator|>
literal|0
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
if|if
condition|(
name|alreadyCommitted
condition|)
block|{
comment|//makes the message more informative - helps to find bugs in client code
throw|throw
operator|new
name|NoSuchTxnException
argument_list|(
literal|"Transaction "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
operator|+
literal|" is already committed."
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|NoSuchTxnException
argument_list|(
literal|"No such transaction "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|TXN_ABORTED
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|TxnAbortedException
argument_list|(
literal|"Transaction "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnid
argument_list|)
operator|+
literal|" already aborted"
argument_list|)
throw|;
comment|//todo: add time of abort, which is not currently tracked.  Requires schema change
block|}
block|}
specifier|private
name|LockInfo
name|getTxnIdFromLockId
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|extLockId
parameter_list|)
throws|throws
name|NoSuchLockException
throws|,
name|MetaException
throws|,
name|SQLException
block|{
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select hl_lock_ext_id, hl_lock_int_id, hl_db, hl_table, "
operator|+
literal|"hl_partition, hl_lock_state, hl_lock_type, hl_txnid from HIVE_LOCKS where "
operator|+
literal|"hl_lock_ext_id = "
operator|+
name|extLockId
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|LockInfo
name|info
init|=
operator|new
name|LockInfo
argument_list|(
name|rs
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"getTxnIdFromLockId("
operator|+
name|extLockId
operator|+
literal|") Return "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|info
operator|.
name|txnId
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|info
return|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
comment|// NEVER call this function without first calling heartbeat(long, long)
specifier|private
name|List
argument_list|<
name|LockInfo
argument_list|>
name|getLockInfoFromLockId
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|extLockId
parameter_list|)
throws|throws
name|NoSuchLockException
throws|,
name|MetaException
throws|,
name|SQLException
block|{
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"select hl_lock_ext_id, hl_lock_int_id, hl_db, hl_table, "
operator|+
literal|"hl_partition, hl_lock_state, hl_lock_type, hl_txnid from HIVE_LOCKS where "
operator|+
literal|"hl_lock_ext_id = "
operator|+
name|extLockId
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|boolean
name|sawAtLeastOne
init|=
literal|false
decl_stmt|;
name|List
argument_list|<
name|LockInfo
argument_list|>
name|ourLockInfo
init|=
operator|new
name|ArrayList
argument_list|<
name|LockInfo
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|ourLockInfo
operator|.
name|add
argument_list|(
operator|new
name|LockInfo
argument_list|(
name|rs
argument_list|)
argument_list|)
expr_stmt|;
name|sawAtLeastOne
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sawAtLeastOne
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"This should never happen!  We already "
operator|+
literal|"checked the lock("
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|extLockId
argument_list|)
operator|+
literal|") existed but now we can't find it!"
argument_list|)
throw|;
block|}
return|return
name|ourLockInfo
return|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Clean time out locks from the database not associated with a transactions, i.e. locks
comment|// for read-only autoCommit=true statements.  This does a commit,
comment|// and thus should be done before any calls to heartbeat that will leave
comment|// open transactions.
specifier|private
name|void
name|timeOutLocks
parameter_list|(
name|Connection
name|dbConn
parameter_list|,
name|long
name|now
parameter_list|)
block|{
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|long
name|maxHeartbeatTime
init|=
name|now
operator|-
name|timeout
decl_stmt|;
comment|//doing a SELECT first is less efficient but makes it easier to debug things
name|String
name|s
init|=
literal|"select distinct hl_lock_ext_id from HIVE_LOCKS where hl_last_heartbeat< "
operator|+
name|maxHeartbeatTime
operator|+
literal|" and hl_txnid = 0"
decl_stmt|;
comment|//when txnid is<> 0, the lock is
comment|//associated with a txn and is handled by performTimeOuts()
comment|//want to avoid expiring locks for a txn w/o expiring the txn itself
name|List
argument_list|<
name|Long
argument_list|>
name|extLockIDs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|extLockIDs
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rs
operator|.
name|close
argument_list|()
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
if|if
condition|(
name|extLockIDs
operator|.
name|size
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|queries
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|prefix
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|StringBuilder
name|suffix
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|//include same hl_last_heartbeat condition in case someone heartbeated since the select
name|prefix
operator|.
name|append
argument_list|(
literal|"delete from HIVE_LOCKS where hl_last_heartbeat< "
argument_list|)
expr_stmt|;
name|prefix
operator|.
name|append
argument_list|(
name|maxHeartbeatTime
argument_list|)
expr_stmt|;
name|prefix
operator|.
name|append
argument_list|(
literal|" and hl_txnid = 0 and "
argument_list|)
expr_stmt|;
name|suffix
operator|.
name|append
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|TxnUtils
operator|.
name|buildQueryWithINClause
argument_list|(
name|conf
argument_list|,
name|queries
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|,
name|extLockIDs
argument_list|,
literal|"hl_lock_ext_id"
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|int
name|deletedLocks
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|query
range|:
name|queries
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing expired locks via: "
operator|+
name|query
argument_list|)
expr_stmt|;
name|deletedLocks
operator|+=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deletedLocks
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleted "
operator|+
name|deletedLocks
operator|+
literal|" ext locks from HIVE_LOCKS due to timeout (vs. "
operator|+
name|extLockIDs
operator|.
name|size
argument_list|()
operator|+
literal|" found. List: "
operator|+
name|extLockIDs
operator|+
literal|") maxHeartbeatTime="
operator|+
name|maxHeartbeatTime
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to purge timedout locks due to: "
operator|+
name|getMessage
argument_list|(
name|ex
argument_list|)
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to purge timedout locks due to: "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Suppose you have a query "select a,b from T" and you want to limit the result set    * to the first 5 rows.  The mechanism to do that differs in different DB.    * Make {@code noSelectsqlQuery} to be "a,b from T" and this method will return the    * appropriately modified row limiting query.    */
specifier|private
name|String
name|addLimitClause
parameter_list|(
name|int
name|numRows
parameter_list|,
name|String
name|noSelectsqlQuery
parameter_list|)
throws|throws
name|MetaException
block|{
switch|switch
condition|(
name|dbProduct
condition|)
block|{
case|case
name|DERBY
case|:
comment|//http://db.apache.org/derby/docs/10.7/ref/rrefsqljoffsetfetch.html
return|return
literal|"select "
operator|+
name|noSelectsqlQuery
operator|+
literal|" fetch first "
operator|+
name|numRows
operator|+
literal|" rows only"
return|;
case|case
name|MYSQL
case|:
comment|//http://www.postgresql.org/docs/7.3/static/queries-limit.html
case|case
name|POSTGRES
case|:
comment|//https://dev.mysql.com/doc/refman/5.0/en/select.html
return|return
literal|"select "
operator|+
name|noSelectsqlQuery
operator|+
literal|" limit "
operator|+
name|numRows
return|;
case|case
name|ORACLE
case|:
comment|//newer versions (12c and later) support OFFSET/FETCH
return|return
literal|"select * from (select "
operator|+
name|noSelectsqlQuery
operator|+
literal|") where rownum<= "
operator|+
name|numRows
return|;
case|case
name|SQLSERVER
case|:
comment|//newer versions (2012 and later) support OFFSET/FETCH
comment|//https://msdn.microsoft.com/en-us/library/ms189463.aspx
return|return
literal|"select TOP("
operator|+
name|numRows
operator|+
literal|") "
operator|+
name|noSelectsqlQuery
return|;
default|default:
name|String
name|msg
init|=
literal|"Unrecognized database product name<"
operator|+
name|dbProduct
operator|+
literal|">"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
comment|/**    * Isolation Level Notes    * Plain: RC is OK    * This will find transactions that have timed out and abort them.    * Will also delete locks which are not associated with a transaction and have timed out    * Tries to keep transactions (against metastore db) small to reduce lock contention.    */
specifier|public
name|void
name|performTimeOuts
parameter_list|()
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
comment|//We currently commit after selecting the TXNS to abort.  So whether SERIALIZABLE
comment|//READ_COMMITTED, the effect is the same.  We could use FOR UPDATE on Select from TXNS
comment|//and do the whole performTimeOuts() in a single huge transaction, but the only benefit
comment|//would be to make sure someone cannot heartbeat one of these txns at the same time.
comment|//The attempt to heartbeat would block and fail immediately after it's unblocked.
comment|//With current (RC + multiple txns) implementation it is possible for someone to send
comment|//heartbeat at the very end of the expire interval, and just after the Select from TXNS
comment|//is made, in which case heartbeat will succeed but txn will still be Aborted.
comment|//Solving this corner case is not worth the perf penalty.  The client should heartbeat in a
comment|//timely way.
name|long
name|now
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|timeOutLocks
argument_list|(
name|dbConn
argument_list|,
name|now
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|" txn_id from TXNS where txn_state = '"
operator|+
name|TXN_OPEN
operator|+
literal|"' and txn_last_heartbeat<  "
operator|+
operator|(
name|now
operator|-
name|timeout
operator|)
decl_stmt|;
name|s
operator|=
name|addLimitClause
argument_list|(
literal|250
operator|*
name|TIMED_OUT_TXN_ABORT_BATCH_SIZE
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
return|return;
comment|//no more timedout txns
block|}
name|List
argument_list|<
name|List
argument_list|<
name|Long
argument_list|>
argument_list|>
name|timedOutTxns
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|currentBatch
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|TIMED_OUT_TXN_ABORT_BATCH_SIZE
argument_list|)
decl_stmt|;
name|timedOutTxns
operator|.
name|add
argument_list|(
name|currentBatch
argument_list|)
expr_stmt|;
do|do
block|{
name|currentBatch
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentBatch
operator|.
name|size
argument_list|()
operator|==
name|TIMED_OUT_TXN_ABORT_BATCH_SIZE
condition|)
block|{
name|currentBatch
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|TIMED_OUT_TXN_ABORT_BATCH_SIZE
argument_list|)
expr_stmt|;
name|timedOutTxns
operator|.
name|add
argument_list|(
name|currentBatch
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
do|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|int
name|numTxnsAborted
init|=
literal|0
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|Long
argument_list|>
name|batchToAbort
range|:
name|timedOutTxns
control|)
block|{
if|if
condition|(
name|abortTxns
argument_list|(
name|dbConn
argument_list|,
name|batchToAbort
argument_list|,
name|now
operator|-
name|timeout
argument_list|)
operator|==
name|batchToAbort
operator|.
name|size
argument_list|()
condition|)
block|{
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
name|numTxnsAborted
operator|+=
name|batchToAbort
operator|.
name|size
argument_list|()
expr_stmt|;
comment|//todo: add TXNS.COMMENT filed and set it to 'aborted by system due to timeout'
name|LOG
operator|.
name|info
argument_list|(
literal|"Aborted the following transactions due to timeout: "
operator|+
name|batchToAbort
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//could not abort all txns in this batch - this may happen because in parallel with this
comment|//operation there was activity on one of the txns in this batch (commit/abort/heartbeat)
comment|//This is not likely but may happen if client experiences long pause between heartbeats or
comment|//unusually long/extreme pauses between heartbeat() calls and other logic in checkLock(),
comment|//lock(), etc.
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Aborted "
operator|+
name|numTxnsAborted
operator|+
literal|" transactions due to timeout"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Aborting timedout transactions failed due to "
operator|+
name|getMessage
argument_list|(
name|ex
argument_list|)
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MetaException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Aborting timedout transactions failed due to "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
specifier|synchronized
name|void
name|setupJdbcConnectionPool
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|SQLException
block|{
if|if
condition|(
name|connPool
operator|!=
literal|null
condition|)
return|return;
name|String
name|driverUrl
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTORECONNECTURLKEY
argument_list|)
decl_stmt|;
name|String
name|user
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTORE_CONNECTION_USER_NAME
argument_list|)
decl_stmt|;
name|String
name|passwd
decl_stmt|;
try|try
block|{
name|passwd
operator|=
name|ShimLoader
operator|.
name|getHadoopShims
argument_list|()
operator|.
name|getPassword
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTOREPWD
operator|.
name|varname
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|err
parameter_list|)
block|{
throw|throw
operator|new
name|SQLException
argument_list|(
literal|"Error getting metastore password"
argument_list|,
name|err
argument_list|)
throw|;
block|}
name|String
name|connectionPooler
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTORE_CONNECTION_POOLING_TYPE
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
if|if
condition|(
literal|"bonecp"
operator|.
name|equals
argument_list|(
name|connectionPooler
argument_list|)
condition|)
block|{
name|BoneCPConfig
name|config
init|=
operator|new
name|BoneCPConfig
argument_list|()
decl_stmt|;
name|config
operator|.
name|setJdbcUrl
argument_list|(
name|driverUrl
argument_list|)
expr_stmt|;
comment|//if we are waiting for connection for 60s, something is really wrong
comment|//better raise an error than hang forever
name|config
operator|.
name|setConnectionTimeoutInMs
argument_list|(
literal|60000
argument_list|)
expr_stmt|;
name|config
operator|.
name|setMaxConnectionsPerPartition
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|config
operator|.
name|setPartitionCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|config
operator|.
name|setUser
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|config
operator|.
name|setPassword
argument_list|(
name|passwd
argument_list|)
expr_stmt|;
name|connPool
operator|=
operator|new
name|BoneCPDataSource
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|doRetryOnConnPool
operator|=
literal|true
expr_stmt|;
comment|// Enable retries to work around BONECP bug.
block|}
elseif|else
if|if
condition|(
literal|"dbcp"
operator|.
name|equals
argument_list|(
name|connectionPooler
argument_list|)
condition|)
block|{
name|ObjectPool
name|objectPool
init|=
operator|new
name|GenericObjectPool
argument_list|()
decl_stmt|;
name|ConnectionFactory
name|connFactory
init|=
operator|new
name|DriverManagerConnectionFactory
argument_list|(
name|driverUrl
argument_list|,
name|user
argument_list|,
name|passwd
argument_list|)
decl_stmt|;
comment|// This doesn't get used, but it's still necessary, see
comment|// http://svn.apache.org/viewvc/commons/proper/dbcp/branches/DBCP_1_4_x_BRANCH/doc/ManualPoolingDataSourceExample.java?view=markup
name|PoolableConnectionFactory
name|poolConnFactory
init|=
operator|new
name|PoolableConnectionFactory
argument_list|(
name|connFactory
argument_list|,
name|objectPool
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|connPool
operator|=
operator|new
name|PoolingDataSource
argument_list|(
name|objectPool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown JDBC connection pooling "
operator|+
name|connectionPooler
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
specifier|synchronized
name|void
name|buildJumpTable
parameter_list|()
block|{
if|if
condition|(
name|jumpTable
operator|!=
literal|null
condition|)
return|return;
name|jumpTable
operator|=
operator|new
name|HashMap
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
argument_list|>
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|// SR: Lock we are trying to acquire is shared read
name|Map
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
name|m
init|=
operator|new
name|HashMap
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|jumpTable
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_READ
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|// SR.SR: Lock we are examining is shared read
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
name|m2
init|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_READ
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// SR.SR.acquired Lock we are examining is acquired;  We can acquire
comment|// because two shared reads can acquire together and there must be
comment|// nothing in front of this one to prevent acquisition.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|ACQUIRE
argument_list|)
expr_stmt|;
comment|// SR.SR.wait Lock we are examining is waiting.  In this case we keep
comment|// looking, as it's possible that something in front is blocking it or
comment|// that the other locker hasn't checked yet and he could lock as well.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|KEEP_LOOKING
argument_list|)
expr_stmt|;
comment|// SR.SW: Lock we are examining is shared write
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_WRITE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// SR.SW.acquired Lock we are examining is acquired;  We can acquire
comment|// because a read can share with a write, and there must be
comment|// nothing in front of this one to prevent acquisition.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|ACQUIRE
argument_list|)
expr_stmt|;
comment|// SR.SW.wait Lock we are examining is waiting.  In this case we keep
comment|// looking, as it's possible that something in front is blocking it or
comment|// that the other locker hasn't checked yet and he could lock as well or
comment|// that something is blocking it that would not block a read.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|KEEP_LOOKING
argument_list|)
expr_stmt|;
comment|// SR.E: Lock we are examining is exclusive
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|EXCLUSIVE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// No matter whether it has acquired or not, we cannot pass an exclusive.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
comment|// SW: Lock we are trying to acquire is shared write
name|m
operator|=
operator|new
name|HashMap
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|jumpTable
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_WRITE
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|// SW.SR: Lock we are examining is shared read
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_READ
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// SW.SR.acquired Lock we are examining is acquired;  We need to keep
comment|// looking, because there may or may not be another shared write in front
comment|// that would block us.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|KEEP_LOOKING
argument_list|)
expr_stmt|;
comment|// SW.SR.wait Lock we are examining is waiting.  In this case we keep
comment|// looking, as it's possible that something in front is blocking it or
comment|// that the other locker hasn't checked yet and he could lock as well.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|KEEP_LOOKING
argument_list|)
expr_stmt|;
comment|// SW.SW: Lock we are examining is shared write
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_WRITE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// Regardless of acquired or waiting, one shared write cannot pass another.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
comment|// SW.E: Lock we are examining is exclusive
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|EXCLUSIVE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// No matter whether it has acquired or not, we cannot pass an exclusive.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
comment|// E: Lock we are trying to acquire is exclusive
name|m
operator|=
operator|new
name|HashMap
argument_list|<
name|LockType
argument_list|,
name|Map
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|>
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|jumpTable
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|EXCLUSIVE
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|// E.SR: Lock we are examining is shared read
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_READ
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// Exclusives can never pass
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
comment|// E.SW: Lock we are examining is shared write
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|SHARED_WRITE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// Exclusives can never pass
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
comment|// E.E: Lock we are examining is exclusive
name|m2
operator|=
operator|new
name|HashMap
argument_list|<
name|LockState
argument_list|,
name|LockAction
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|LockType
operator|.
name|EXCLUSIVE
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|// No matter whether it has acquired or not, we cannot pass an exclusive.
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|ACQUIRED
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
name|m2
operator|.
name|put
argument_list|(
name|LockState
operator|.
name|WAITING
argument_list|,
name|LockAction
operator|.
name|WAIT
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns true if {@code ex} should be retried    */
specifier|static
name|boolean
name|isRetryable
parameter_list|(
name|HiveConf
name|conf
parameter_list|,
name|Exception
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ex
operator|instanceof
name|SQLException
condition|)
block|{
name|SQLException
name|sqlException
init|=
operator|(
name|SQLException
operator|)
name|ex
decl_stmt|;
if|if
condition|(
literal|"08S01"
operator|.
name|equalsIgnoreCase
argument_list|(
name|sqlException
operator|.
name|getSQLState
argument_list|()
argument_list|)
condition|)
block|{
comment|//in MSSQL this means Communication Link Failure
return|return
literal|true
return|;
block|}
if|if
condition|(
literal|"ORA-08176"
operator|.
name|equalsIgnoreCase
argument_list|(
name|sqlException
operator|.
name|getSQLState
argument_list|()
argument_list|)
operator|||
name|sqlException
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"consistent read failure; rollback data not available"
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|String
name|regex
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_TXN_RETRYABLE_SQLEX_REGEX
argument_list|)
decl_stmt|;
if|if
condition|(
name|regex
operator|!=
literal|null
operator|&&
operator|!
name|regex
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
index|[]
name|patterns
init|=
name|regex
operator|.
name|split
argument_list|(
literal|",(?=\\S)"
argument_list|)
decl_stmt|;
name|String
name|message
init|=
name|getMessage
argument_list|(
operator|(
name|SQLException
operator|)
name|ex
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|p
range|:
name|patterns
control|)
block|{
if|if
condition|(
name|Pattern
operator|.
name|matches
argument_list|(
name|p
argument_list|,
name|message
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
comment|//see also https://issues.apache.org/jira/browse/HIVE-9938
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|isDuplicateKeyError
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
switch|switch
condition|(
name|dbProduct
condition|)
block|{
case|case
name|DERBY
case|:
if|if
condition|(
literal|"23505"
operator|.
name|equals
argument_list|(
name|ex
operator|.
name|getSQLState
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
break|break;
case|case
name|MYSQL
case|:
if|if
condition|(
name|ex
operator|.
name|getErrorCode
argument_list|()
operator|==
literal|1022
operator|&&
literal|"23000"
operator|.
name|equals
argument_list|(
name|ex
operator|.
name|getSQLState
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
break|break;
case|case
name|SQLSERVER
case|:
comment|//2627 is unique constaint violation incl PK, 2601 - unique key
if|if
condition|(
name|ex
operator|.
name|getErrorCode
argument_list|()
operator|==
literal|2627
operator|&&
literal|"23000"
operator|.
name|equals
argument_list|(
name|ex
operator|.
name|getSQLState
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
break|break;
case|case
name|ORACLE
case|:
if|if
condition|(
name|ex
operator|.
name|getErrorCode
argument_list|()
operator|==
literal|1
operator|&&
literal|"23000"
operator|.
name|equals
argument_list|(
name|ex
operator|.
name|getSQLState
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
break|break;
case|case
name|POSTGRES
case|:
comment|//http://www.postgresql.org/docs/8.1/static/errcodes-appendix.html
if|if
condition|(
literal|"23505"
operator|.
name|equals
argument_list|(
name|ex
operator|.
name|getSQLState
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unexpected DB type: "
operator|+
name|dbProduct
operator|+
literal|"; "
operator|+
name|getMessage
argument_list|(
name|ex
argument_list|)
argument_list|)
throw|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
specifier|static
name|String
name|getMessage
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
return|return
name|ex
operator|.
name|getMessage
argument_list|()
operator|+
literal|" (SQLState="
operator|+
name|ex
operator|.
name|getSQLState
argument_list|()
operator|+
literal|", ErrorCode="
operator|+
name|ex
operator|.
name|getErrorCode
argument_list|()
operator|+
literal|")"
return|;
block|}
comment|/**    * Given a {@code selectStatement}, decorated it with FOR UPDATE or semantically equivalent    * construct.  If the DB doesn't support, return original select.    */
specifier|private
name|String
name|addForUpdateClause
parameter_list|(
name|String
name|selectStatement
parameter_list|)
throws|throws
name|MetaException
block|{
switch|switch
condition|(
name|dbProduct
condition|)
block|{
case|case
name|DERBY
case|:
comment|//https://db.apache.org/derby/docs/10.1/ref/rrefsqlj31783.html
comment|//sadly in Derby, FOR UPDATE doesn't meant what it should
return|return
name|selectStatement
return|;
case|case
name|MYSQL
case|:
comment|//http://dev.mysql.com/doc/refman/5.7/en/select.html
case|case
name|ORACLE
case|:
comment|//https://docs.oracle.com/cd/E17952_01/refman-5.6-en/select.html
case|case
name|POSTGRES
case|:
comment|//http://www.postgresql.org/docs/9.0/static/sql-select.html
return|return
name|selectStatement
operator|+
literal|" for update"
return|;
case|case
name|SQLSERVER
case|:
comment|//https://msdn.microsoft.com/en-us/library/ms189499.aspx
comment|//https://msdn.microsoft.com/en-us/library/ms187373.aspx
return|return
name|selectStatement
operator|+
literal|" with(updlock)"
return|;
default|default:
name|String
name|msg
init|=
literal|"Unrecognized database product name<"
operator|+
name|dbProduct
operator|+
literal|">"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
specifier|static
name|String
name|quoteString
parameter_list|(
name|String
name|input
parameter_list|)
block|{
return|return
literal|"'"
operator|+
name|input
operator|+
literal|"'"
return|;
block|}
specifier|static
name|String
name|quoteChar
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
literal|"'"
operator|+
name|c
operator|+
literal|"'"
return|;
block|}
specifier|static
name|CompactionType
name|dbCompactionType2ThriftType
parameter_list|(
name|char
name|dbValue
parameter_list|)
block|{
switch|switch
condition|(
name|dbValue
condition|)
block|{
case|case
name|MAJOR_TYPE
case|:
return|return
name|CompactionType
operator|.
name|MAJOR
return|;
case|case
name|MINOR_TYPE
case|:
return|return
name|CompactionType
operator|.
name|MINOR
return|;
default|default:
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected compaction type "
operator|+
name|dbValue
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
specifier|static
name|Character
name|thriftCompactionType2DbType
parameter_list|(
name|CompactionType
name|ct
parameter_list|)
block|{
switch|switch
condition|(
name|ct
condition|)
block|{
case|case
name|MAJOR
case|:
return|return
name|MAJOR_TYPE
return|;
case|case
name|MINOR
case|:
return|return
name|MINOR_TYPE
return|;
default|default:
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected compaction type "
operator|+
name|ct
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * {@link #lockInternal()} and {@link #unlockInternal()} are used to serialize those operations that require    * Select ... For Update to sequence operations properly.  In practice that means when running    * with Derby database.  See more notes at class level.    */
specifier|private
name|void
name|lockInternal
parameter_list|()
block|{
if|if
condition|(
name|dbProduct
operator|==
name|DatabaseProduct
operator|.
name|DERBY
condition|)
block|{
name|derbyLock
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|unlockInternal
parameter_list|()
block|{
if|if
condition|(
name|dbProduct
operator|==
name|DatabaseProduct
operator|.
name|DERBY
condition|)
block|{
name|derbyLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|MutexAPI
name|getMutexAPI
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|LockHandle
name|acquireLock
parameter_list|(
name|String
name|key
parameter_list|)
throws|throws
name|MetaException
block|{
comment|/**      * The implementation here is a bit kludgey but done so that code exercised by unit tests      * (which run against Derby which has no support for select for update) is as similar to      * production code as possible.      * In particular, with Derby we always run in a single process with a single metastore and      * the absence of For Update is handled via a Semaphore.  The later would strictly speaking      * make the SQL statments below unnecessary (for Derby), but then they would not be tested.      */
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|String
name|sqlStmt
init|=
name|addForUpdateClause
argument_list|(
literal|"select MT_COMMENT from AUX_TABLE where MT_KEY1="
operator|+
name|quoteString
argument_list|(
name|key
argument_list|)
operator|+
literal|" and MT_KEY2=0"
argument_list|)
decl_stmt|;
name|lockInternal
argument_list|()
expr_stmt|;
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"About to execute SQL: "
operator|+
name|sqlStmt
argument_list|)
expr_stmt|;
block|}
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|sqlStmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
try|try
block|{
name|stmt
operator|.
name|executeUpdate
argument_list|(
literal|"insert into AUX_TABLE(MT_KEY1,MT_KEY2) values("
operator|+
name|quoteString
argument_list|(
name|key
argument_list|)
operator|+
literal|", 0)"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isDuplicateKeyError
argument_list|(
name|ex
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unable to lock "
operator|+
name|quoteString
argument_list|(
name|key
argument_list|)
operator|+
literal|" due to: "
operator|+
name|getMessage
argument_list|(
name|ex
argument_list|)
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|sqlStmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to lock "
operator|+
name|quoteString
argument_list|(
name|key
argument_list|)
operator|+
literal|".  Expected row in AUX_TABLE is missing."
argument_list|)
throw|;
block|}
block|}
name|Semaphore
name|derbySemaphore
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|dbProduct
operator|==
name|DatabaseProduct
operator|.
name|DERBY
condition|)
block|{
name|derbyKey2Lock
operator|.
name|putIfAbsent
argument_list|(
name|key
argument_list|,
operator|new
name|Semaphore
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|derbySemaphore
operator|=
name|derbyKey2Lock
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|derbySemaphore
operator|.
name|acquire
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|quoteString
argument_list|(
name|key
argument_list|)
operator|+
literal|" locked by "
operator|+
name|quoteString
argument_list|(
name|TxnHandler
operator|.
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
comment|//OK, so now we have a lock
return|return
operator|new
name|LockHandleImpl
argument_list|(
name|dbConn
argument_list|,
name|stmt
argument_list|,
name|rs
argument_list|,
name|key
argument_list|,
name|derbySemaphore
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|ex
argument_list|,
literal|"acquireLock("
operator|+
name|key
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to lock "
operator|+
name|quoteString
argument_list|(
name|key
argument_list|)
operator|+
literal|" due to: "
operator|+
name|getMessage
argument_list|(
name|ex
argument_list|)
operator|+
literal|"; "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ex
argument_list|)
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to lock "
operator|+
name|quoteString
argument_list|(
name|key
argument_list|)
operator|+
literal|" due to: "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ex
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|unlockInternal
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|ex
parameter_list|)
block|{
name|acquireLock
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"This can't happen because checkRetryable() has a retry limit"
argument_list|)
throw|;
block|}
specifier|public
name|void
name|acquireLock
parameter_list|(
name|String
name|key
parameter_list|,
name|LockHandle
name|handle
parameter_list|)
block|{
comment|//the idea is that this will use LockHandle.dbConn
throw|throw
operator|new
name|NotImplementedException
argument_list|()
throw|;
block|}
specifier|private
specifier|static
specifier|final
class|class
name|LockHandleImpl
implements|implements
name|LockHandle
block|{
specifier|private
specifier|final
name|Connection
name|dbConn
decl_stmt|;
specifier|private
specifier|final
name|Statement
name|stmt
decl_stmt|;
specifier|private
specifier|final
name|ResultSet
name|rs
decl_stmt|;
specifier|private
specifier|final
name|Semaphore
name|derbySemaphore
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|keys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|LockHandleImpl
parameter_list|(
name|Connection
name|conn
parameter_list|,
name|Statement
name|stmt
parameter_list|,
name|ResultSet
name|rs
parameter_list|,
name|String
name|key
parameter_list|,
name|Semaphore
name|derbySemaphore
parameter_list|)
block|{
name|this
operator|.
name|dbConn
operator|=
name|conn
expr_stmt|;
name|this
operator|.
name|stmt
operator|=
name|stmt
expr_stmt|;
name|this
operator|.
name|rs
operator|=
name|rs
expr_stmt|;
name|this
operator|.
name|derbySemaphore
operator|=
name|derbySemaphore
expr_stmt|;
if|if
condition|(
name|derbySemaphore
operator|!=
literal|null
condition|)
block|{
comment|//oterwise it may later release permit acquired by someone else
assert|assert
name|derbySemaphore
operator|.
name|availablePermits
argument_list|()
operator|==
literal|0
operator|:
literal|"Expected locked Semaphore"
assert|;
block|}
name|keys
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
name|void
name|addKey
parameter_list|(
name|String
name|key
parameter_list|)
block|{
comment|//keys.add(key);
comment|//would need a list of (stmt,rs) pairs - 1 for each key
throw|throw
operator|new
name|NotImplementedException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|releaseLocks
parameter_list|()
block|{
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
if|if
condition|(
name|derbySemaphore
operator|!=
literal|null
condition|)
block|{
name|derbySemaphore
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|String
name|key
range|:
name|keys
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|quoteString
argument_list|(
name|key
argument_list|)
operator|+
literal|" unlocked by "
operator|+
name|quoteString
argument_list|(
name|TxnHandler
operator|.
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

