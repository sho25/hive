#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import *
import fb303.FacebookService
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(fb303.FacebookService.Iface):
  def get_tables(self, pattern):
    pass

  def get_schema(self, table_name):
    pass

  def get_fields(self, table_name):
    pass

  def get_partition_cols(self, table_name):
    pass

  def save_table(self, table_name, schema, overwrite):
    pass

  def cat(self, table_name, high, partition):
    pass

  def drop(self, table_name, delete_data):
    pass

  def rename(self, current_table_name, new_table_name, move_data):
    pass

  def schema_exists(self, table_name):
    pass

  def exists(self, table_name):
    pass

  def alter_table(self, table_name, columns):
    pass

  def create_table(self, table_name, columns, partition_cols):
    pass

  def get_partitions(self, table_name):
    pass

  def write_log(self, table_name, logName, new_entry):
    pass

  def read_log(self, table_name, logName):
    pass

  def get_log_names(self, table_name):
    pass


class Client(fb303.FacebookService.Client, Iface):
  def __init__(self, iprot, oprot=None):
    fb303.FacebookService.Client.__init__(self, iprot, oprot)

  def get_tables(self, pattern):
    self.send_get_tables(pattern)
    return self.recv_get_tables()

  def send_get_tables(self, pattern):
    self._oprot.writeMessageBegin('get_tables', TMessageType.CALL, self._seqid)
    args = get_tables_args()
    args.pattern = pattern
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_tables(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_tables_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.ouch != None:
      raise result.ouch
    if result.ouch2 != None:
      raise result.ouch2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tables failed: unknown result");

  def get_schema(self, table_name):
    self.send_get_schema(table_name)
    return self.recv_get_schema()

  def send_get_schema(self, table_name):
    self._oprot.writeMessageBegin('get_schema', TMessageType.CALL, self._seqid)
    args = get_schema_args()
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_schema(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_schema_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.ouch != None:
      raise result.ouch
    if result.ouch2 != None:
      raise result.ouch2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schema failed: unknown result");

  def get_fields(self, table_name):
    self.send_get_fields(table_name)
    return self.recv_get_fields()

  def send_get_fields(self, table_name):
    self._oprot.writeMessageBegin('get_fields', TMessageType.CALL, self._seqid)
    args = get_fields_args()
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_fields(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_fields_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.ouch != None:
      raise result.ouch
    if result.out2 != None:
      raise result.out2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_fields failed: unknown result");

  def get_partition_cols(self, table_name):
    self.send_get_partition_cols(table_name)
    return self.recv_get_partition_cols()

  def send_get_partition_cols(self, table_name):
    self._oprot.writeMessageBegin('get_partition_cols', TMessageType.CALL, self._seqid)
    args = get_partition_cols_args()
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_cols(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partition_cols_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.ouch != None:
      raise result.ouch
    if result.out2 != None:
      raise result.out2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_cols failed: unknown result");

  def save_table(self, table_name, schema, overwrite):
    self.send_save_table(table_name, schema, overwrite)
    self.recv_save_table()

  def send_save_table(self, table_name, schema, overwrite):
    self._oprot.writeMessageBegin('save_table', TMessageType.CALL, self._seqid)
    args = save_table_args()
    args.table_name = table_name
    args.schema = schema
    args.overwrite = overwrite
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_save_table(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = save_table_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ouch != None:
      raise result.ouch
    return

  def cat(self, table_name, high, partition):
    self.send_cat(table_name, high, partition)
    return self.recv_cat()

  def send_cat(self, table_name, high, partition):
    self._oprot.writeMessageBegin('cat', TMessageType.CALL, self._seqid)
    args = cat_args()
    args.table_name = table_name
    args.high = high
    args.partition = partition
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cat(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = cat_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.ouch != None:
      raise result.ouch
    if result.ouch2 != None:
      raise result.ouch2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "cat failed: unknown result");

  def drop(self, table_name, delete_data):
    self.send_drop(table_name, delete_data)
    self.recv_drop()

  def send_drop(self, table_name, delete_data):
    self._oprot.writeMessageBegin('drop', TMessageType.CALL, self._seqid)
    args = drop_args()
    args.table_name = table_name
    args.delete_data = delete_data
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ouch != None:
      raise result.ouch
    if result.ouch2 != None:
      raise result.ouch2
    return

  def rename(self, current_table_name, new_table_name, move_data):
    self.send_rename(current_table_name, new_table_name, move_data)
    self.recv_rename()

  def send_rename(self, current_table_name, new_table_name, move_data):
    self._oprot.writeMessageBegin('rename', TMessageType.CALL, self._seqid)
    args = rename_args()
    args.current_table_name = current_table_name
    args.new_table_name = new_table_name
    args.move_data = move_data
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_rename(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = rename_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ouch != None:
      raise result.ouch
    if result.ouch2 != None:
      raise result.ouch2
    return

  def schema_exists(self, table_name):
    self.send_schema_exists(table_name)
    return self.recv_schema_exists()

  def send_schema_exists(self, table_name):
    self._oprot.writeMessageBegin('schema_exists', TMessageType.CALL, self._seqid)
    args = schema_exists_args()
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_schema_exists(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = schema_exists_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.ouch != None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "schema_exists failed: unknown result");

  def exists(self, table_name):
    self.send_exists(table_name)
    return self.recv_exists()

  def send_exists(self, table_name):
    self._oprot.writeMessageBegin('exists', TMessageType.CALL, self._seqid)
    args = exists_args()
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_exists(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = exists_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.ouch != None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "exists failed: unknown result");

  def alter_table(self, table_name, columns):
    self.send_alter_table(table_name, columns)
    self.recv_alter_table()

  def send_alter_table(self, table_name, columns):
    self._oprot.writeMessageBegin('alter_table', TMessageType.CALL, self._seqid)
    args = alter_table_args()
    args.table_name = table_name
    args.columns = columns
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_table(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = alter_table_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ouch != None:
      raise result.ouch
    if result.ouch2 != None:
      raise result.ouch2
    return

  def create_table(self, table_name, columns, partition_cols):
    self.send_create_table(table_name, columns, partition_cols)
    self.recv_create_table()

  def send_create_table(self, table_name, columns, partition_cols):
    self._oprot.writeMessageBegin('create_table', TMessageType.CALL, self._seqid)
    args = create_table_args()
    args.table_name = table_name
    args.columns = columns
    args.partition_cols = partition_cols
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_table(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = create_table_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ouch != None:
      raise result.ouch
    return

  def get_partitions(self, table_name):
    self.send_get_partitions(table_name)
    return self.recv_get_partitions()

  def send_get_partitions(self, table_name):
    self._oprot.writeMessageBegin('get_partitions', TMessageType.CALL, self._seqid)
    args = get_partitions_args()
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partitions_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.ouch != None:
      raise result.ouch
    if result.ouch2 != None:
      raise result.ouch2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions failed: unknown result");

  def write_log(self, table_name, logName, new_entry):
    self.send_write_log(table_name, logName, new_entry)
    self.recv_write_log()

  def send_write_log(self, table_name, logName, new_entry):
    self._oprot.writeMessageBegin('write_log', TMessageType.CALL, self._seqid)
    args = write_log_args()
    args.table_name = table_name
    args.logName = logName
    args.new_entry = new_entry
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_write_log(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = write_log_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ouch != None:
      raise result.ouch
    if result.ouch2 != None:
      raise result.ouch2
    return

  def read_log(self, table_name, logName):
    self.send_read_log(table_name, logName)
    return self.recv_read_log()

  def send_read_log(self, table_name, logName):
    self._oprot.writeMessageBegin('read_log', TMessageType.CALL, self._seqid)
    args = read_log_args()
    args.table_name = table_name
    args.logName = logName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_read_log(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = read_log_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.ouch != None:
      raise result.ouch
    if result.ouch2 != None:
      raise result.ouch2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "read_log failed: unknown result");

  def get_log_names(self, table_name):
    self.send_get_log_names(table_name)
    return self.recv_get_log_names()

  def send_get_log_names(self, table_name):
    self._oprot.writeMessageBegin('get_log_names', TMessageType.CALL, self._seqid)
    args = get_log_names_args()
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_log_names(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_log_names_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.ouch != None:
      raise result.ouch
    if result.ouch2 != None:
      raise result.ouch2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_log_names failed: unknown result");


class Processor(fb303.FacebookService.Processor, Iface, TProcessor):
  def __init__(self, handler):
    fb303.FacebookService.Processor.__init__(self, handler)
    self._processMap["get_tables"] = Processor.process_get_tables
    self._processMap["get_schema"] = Processor.process_get_schema
    self._processMap["get_fields"] = Processor.process_get_fields
    self._processMap["get_partition_cols"] = Processor.process_get_partition_cols
    self._processMap["save_table"] = Processor.process_save_table
    self._processMap["cat"] = Processor.process_cat
    self._processMap["drop"] = Processor.process_drop
    self._processMap["rename"] = Processor.process_rename
    self._processMap["schema_exists"] = Processor.process_schema_exists
    self._processMap["exists"] = Processor.process_exists
    self._processMap["alter_table"] = Processor.process_alter_table
    self._processMap["create_table"] = Processor.process_create_table
    self._processMap["get_partitions"] = Processor.process_get_partitions
    self._processMap["write_log"] = Processor.process_write_log
    self._processMap["read_log"] = Processor.process_read_log
    self._processMap["get_log_names"] = Processor.process_get_log_names

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_get_tables(self, seqid, iprot, oprot):
    args = get_tables_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_tables_result()
    try:
      result.success = self._handler.get_tables(args.pattern)
    except MetaException, ouch:
      result.ouch = ouch
    except UnknownTableException, ouch2:
      result.ouch2 = ouch2
    oprot.writeMessageBegin("get_tables", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_schema(self, seqid, iprot, oprot):
    args = get_schema_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_schema_result()
    try:
      result.success = self._handler.get_schema(args.table_name)
    except MetaException, ouch:
      result.ouch = ouch
    except UnknownTableException, ouch2:
      result.ouch2 = ouch2
    oprot.writeMessageBegin("get_schema", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_fields(self, seqid, iprot, oprot):
    args = get_fields_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_fields_result()
    try:
      result.success = self._handler.get_fields(args.table_name)
    except MetaException, ouch:
      result.ouch = ouch
    except UnknownTableException, out2:
      result.out2 = out2
    oprot.writeMessageBegin("get_fields", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_cols(self, seqid, iprot, oprot):
    args = get_partition_cols_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_cols_result()
    try:
      result.success = self._handler.get_partition_cols(args.table_name)
    except MetaException, ouch:
      result.ouch = ouch
    except UnknownTableException, out2:
      result.out2 = out2
    oprot.writeMessageBegin("get_partition_cols", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_save_table(self, seqid, iprot, oprot):
    args = save_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = save_table_result()
    try:
      self._handler.save_table(args.table_name, args.schema, args.overwrite)
    except MetaException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("save_table", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cat(self, seqid, iprot, oprot):
    args = cat_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cat_result()
    try:
      result.success = self._handler.cat(args.table_name, args.high, args.partition)
    except MetaException, ouch:
      result.ouch = ouch
    except UnknownTableException, ouch2:
      result.ouch2 = ouch2
    oprot.writeMessageBegin("cat", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop(self, seqid, iprot, oprot):
    args = drop_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_result()
    try:
      self._handler.drop(args.table_name, args.delete_data)
    except MetaException, ouch:
      result.ouch = ouch
    except UnknownTableException, ouch2:
      result.ouch2 = ouch2
    oprot.writeMessageBegin("drop", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_rename(self, seqid, iprot, oprot):
    args = rename_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = rename_result()
    try:
      self._handler.rename(args.current_table_name, args.new_table_name, args.move_data)
    except MetaException, ouch:
      result.ouch = ouch
    except UnknownTableException, ouch2:
      result.ouch2 = ouch2
    oprot.writeMessageBegin("rename", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_schema_exists(self, seqid, iprot, oprot):
    args = schema_exists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = schema_exists_result()
    try:
      result.success = self._handler.schema_exists(args.table_name)
    except MetaException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("schema_exists", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_exists(self, seqid, iprot, oprot):
    args = exists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = exists_result()
    try:
      result.success = self._handler.exists(args.table_name)
    except MetaException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("exists", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_table(self, seqid, iprot, oprot):
    args = alter_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_table_result()
    try:
      self._handler.alter_table(args.table_name, args.columns)
    except MetaException, ouch:
      result.ouch = ouch
    except UnknownTableException, ouch2:
      result.ouch2 = ouch2
    oprot.writeMessageBegin("alter_table", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_table(self, seqid, iprot, oprot):
    args = create_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_table_result()
    try:
      self._handler.create_table(args.table_name, args.columns, args.partition_cols)
    except MetaException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("create_table", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions(self, seqid, iprot, oprot):
    args = get_partitions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_result()
    try:
      result.success = self._handler.get_partitions(args.table_name)
    except MetaException, ouch:
      result.ouch = ouch
    except UnknownTableException, ouch2:
      result.ouch2 = ouch2
    oprot.writeMessageBegin("get_partitions", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_write_log(self, seqid, iprot, oprot):
    args = write_log_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = write_log_result()
    try:
      self._handler.write_log(args.table_name, args.logName, args.new_entry)
    except MetaException, ouch:
      result.ouch = ouch
    except UnknownTableException, ouch2:
      result.ouch2 = ouch2
    oprot.writeMessageBegin("write_log", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_read_log(self, seqid, iprot, oprot):
    args = read_log_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = read_log_result()
    try:
      result.success = self._handler.read_log(args.table_name, args.logName)
    except MetaException, ouch:
      result.ouch = ouch
    except UnknownTableException, ouch2:
      result.ouch2 = ouch2
    oprot.writeMessageBegin("read_log", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_log_names(self, seqid, iprot, oprot):
    args = get_log_names_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_log_names_result()
    try:
      result.success = self._handler.get_log_names(args.table_name)
    except MetaException, ouch:
      result.ouch = ouch
    except UnknownTableException, ouch2:
      result.ouch2 = ouch2
    oprot.writeMessageBegin("get_log_names", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class get_tables_args:

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pattern', None, None, ), # 1
  )

  def __init__(self, d=None):
    self.pattern = None
    if isinstance(d, dict):
      if 'pattern' in d:
        self.pattern = d['pattern']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_tables_args')
    if self.pattern != None:
      oprot.writeFieldBegin('pattern', TType.STRING, 1)
      oprot.writeString(self.pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_tables_result:

  thrift_spec = None
  def __init__(self, d=None):
    self.success = None
    self.ouch = None
    self.ouch2 = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'ouch' in d:
        self.ouch = d['ouch']
      if 'ouch2' in d:
        self.ouch2 = d['ouch2']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString();
            self.success.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = MetaException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -1:
        if ftype == TType.STRUCT:
          self.ouch2 = UnknownTableException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_tables_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter6 in self.success:
        oprot.writeString(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch != None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 != None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, -1)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_schema_args:

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table_name', None, None, ), # 1
  )

  def __init__(self, d=None):
    self.table_name = None
    if isinstance(d, dict):
      if 'table_name' in d:
        self.table_name = d['table_name']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_schema_args')
    if self.table_name != None:
      oprot.writeFieldBegin('table_name', TType.STRING, 1)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_schema_result:

  thrift_spec = None
  def __init__(self, d=None):
    self.success = None
    self.ouch = None
    self.ouch2 = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'ouch' in d:
        self.ouch = d['ouch']
      if 'ouch2' in d:
        self.ouch2 = d['ouch2']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype8, _vtype9, _size7 ) = iprot.readMapBegin() 
          for _i11 in xrange(_size7):
            _key12 = iprot.readString();
            _val13 = iprot.readString();
            self.success[_key12] = _val13
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = MetaException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -1:
        if ftype == TType.STRUCT:
          self.ouch2 = UnknownTableException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_schema_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter14,viter15 in self.success.items():
        oprot.writeString(kiter14)
        oprot.writeString(viter15)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ouch != None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 != None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, -1)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_fields_args:

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table_name', None, None, ), # 1
  )

  def __init__(self, d=None):
    self.table_name = None
    if isinstance(d, dict):
      if 'table_name' in d:
        self.table_name = d['table_name']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_fields_args')
    if self.table_name != None:
      oprot.writeFieldBegin('table_name', TType.STRING, 1)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_fields_result:

  thrift_spec = None
  def __init__(self, d=None):
    self.success = None
    self.ouch = None
    self.out2 = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'ouch' in d:
        self.ouch = d['ouch']
      if 'out2' in d:
        self.out2 = d['out2']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype19, _size16) = iprot.readListBegin()
          for _i20 in xrange(_size16):
            _elem21 = FieldSchema()
            _elem21.read(iprot)
            self.success.append(_elem21)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = MetaException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -1:
        if ftype == TType.STRUCT:
          self.out2 = UnknownTableException()
          self.out2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_fields_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter22 in self.success:
        iter22.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch != None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    if self.out2 != None:
      oprot.writeFieldBegin('out2', TType.STRUCT, -1)
      self.out2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_cols_args:

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table_name', None, None, ), # 1
  )

  def __init__(self, d=None):
    self.table_name = None
    if isinstance(d, dict):
      if 'table_name' in d:
        self.table_name = d['table_name']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_cols_args')
    if self.table_name != None:
      oprot.writeFieldBegin('table_name', TType.STRING, 1)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_cols_result:

  thrift_spec = None
  def __init__(self, d=None):
    self.success = None
    self.ouch = None
    self.out2 = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'ouch' in d:
        self.ouch = d['ouch']
      if 'out2' in d:
        self.out2 = d['out2']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype26, _size23) = iprot.readListBegin()
          for _i27 in xrange(_size23):
            _elem28 = iprot.readString();
            self.success.append(_elem28)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = MetaException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -1:
        if ftype == TType.STRUCT:
          self.out2 = UnknownTableException()
          self.out2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_cols_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter29 in self.success:
        oprot.writeString(iter29)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch != None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    if self.out2 != None:
      oprot.writeFieldBegin('out2', TType.STRUCT, -1)
      self.out2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class save_table_args:

  thrift_spec = None
  def __init__(self, d=None):
    self.table_name = None
    self.schema = None
    self.overwrite = None
    if isinstance(d, dict):
      if 'table_name' in d:
        self.table_name = d['table_name']
      if 'schema' in d:
        self.schema = d['schema']
      if 'overwrite' in d:
        self.overwrite = d['overwrite']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -1:
        if ftype == TType.MAP:
          self.schema = {}
          (_ktype31, _vtype32, _size30 ) = iprot.readMapBegin() 
          for _i34 in xrange(_size30):
            _key35 = iprot.readString();
            _val36 = iprot.readString();
            self.schema[_key35] = _val36
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.BOOL:
          self.overwrite = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('save_table_args')
    if self.table_name != None:
      oprot.writeFieldBegin('table_name', TType.STRING, 1)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.schema != None:
      oprot.writeFieldBegin('schema', TType.MAP, -1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.schema))
      for kiter37,viter38 in self.schema.items():
        oprot.writeString(kiter37)
        oprot.writeString(viter38)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.overwrite != None:
      oprot.writeFieldBegin('overwrite', TType.BOOL, -2)
      oprot.writeBool(self.overwrite)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class save_table_result:

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, d=None):
    self.ouch = None
    if isinstance(d, dict):
      if 'ouch' in d:
        self.ouch = d['ouch']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = MetaException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('save_table_result')
    if self.ouch != None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cat_args:

  thrift_spec = None
  def __init__(self, d=None):
    self.table_name = None
    self.high = None
    self.partition = None
    if isinstance(d, dict):
      if 'table_name' in d:
        self.table_name = d['table_name']
      if 'high' in d:
        self.high = d['high']
      if 'partition' in d:
        self.partition = d['partition']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -1:
        if ftype == TType.I32:
          self.high = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.STRING:
          self.partition = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cat_args')
    if self.table_name != None:
      oprot.writeFieldBegin('table_name', TType.STRING, 1)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.high != None:
      oprot.writeFieldBegin('high', TType.I32, -1)
      oprot.writeI32(self.high)
      oprot.writeFieldEnd()
    if self.partition != None:
      oprot.writeFieldBegin('partition', TType.STRING, -2)
      oprot.writeString(self.partition)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cat_result:

  thrift_spec = None
  def __init__(self, d=None):
    self.success = None
    self.ouch = None
    self.ouch2 = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'ouch' in d:
        self.ouch = d['ouch']
      if 'ouch2' in d:
        self.ouch2 = d['ouch2']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype42, _size39) = iprot.readListBegin()
          for _i43 in xrange(_size39):
            _elem44 = iprot.readString();
            self.success.append(_elem44)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = MetaException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.STRUCT:
          self.ouch2 = UnknownTableException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cat_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter45 in self.success:
        oprot.writeString(iter45)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch != None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 != None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, -3)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_args:

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table_name', None, None, ), # 1
    (2, TType.BOOL, 'delete_data', None, None, ), # 2
  )

  def __init__(self, d=None):
    self.table_name = None
    self.delete_data = None
    if isinstance(d, dict):
      if 'table_name' in d:
        self.table_name = d['table_name']
      if 'delete_data' in d:
        self.delete_data = d['delete_data']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.delete_data = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_args')
    if self.table_name != None:
      oprot.writeFieldBegin('table_name', TType.STRING, 1)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.delete_data != None:
      oprot.writeFieldBegin('delete_data', TType.BOOL, 2)
      oprot.writeBool(self.delete_data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_result:

  thrift_spec = None
  def __init__(self, d=None):
    self.ouch = None
    self.ouch2 = None
    if isinstance(d, dict):
      if 'ouch' in d:
        self.ouch = d['ouch']
      if 'ouch2' in d:
        self.ouch2 = d['ouch2']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = MetaException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -1:
        if ftype == TType.STRUCT:
          self.ouch2 = UnknownTableException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_result')
    if self.ouch != None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 != None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, -1)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class rename_args:

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'current_table_name', None, None, ), # 1
    (2, TType.STRING, 'new_table_name', None, None, ), # 2
    (3, TType.BOOL, 'move_data', None, None, ), # 3
  )

  def __init__(self, d=None):
    self.current_table_name = None
    self.new_table_name = None
    self.move_data = None
    if isinstance(d, dict):
      if 'current_table_name' in d:
        self.current_table_name = d['current_table_name']
      if 'new_table_name' in d:
        self.new_table_name = d['new_table_name']
      if 'move_data' in d:
        self.move_data = d['move_data']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.current_table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.new_table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.move_data = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('rename_args')
    if self.current_table_name != None:
      oprot.writeFieldBegin('current_table_name', TType.STRING, 1)
      oprot.writeString(self.current_table_name)
      oprot.writeFieldEnd()
    if self.new_table_name != None:
      oprot.writeFieldBegin('new_table_name', TType.STRING, 2)
      oprot.writeString(self.new_table_name)
      oprot.writeFieldEnd()
    if self.move_data != None:
      oprot.writeFieldBegin('move_data', TType.BOOL, 3)
      oprot.writeBool(self.move_data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class rename_result:

  thrift_spec = None
  def __init__(self, d=None):
    self.ouch = None
    self.ouch2 = None
    if isinstance(d, dict):
      if 'ouch' in d:
        self.ouch = d['ouch']
      if 'ouch2' in d:
        self.ouch2 = d['ouch2']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = MetaException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -1:
        if ftype == TType.STRUCT:
          self.ouch2 = UnknownTableException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('rename_result')
    if self.ouch != None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 != None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, -1)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class schema_exists_args:

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table_name', None, None, ), # 1
  )

  def __init__(self, d=None):
    self.table_name = None
    if isinstance(d, dict):
      if 'table_name' in d:
        self.table_name = d['table_name']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('schema_exists_args')
    if self.table_name != None:
      oprot.writeFieldBegin('table_name', TType.STRING, 1)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class schema_exists_result:

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, d=None):
    self.success = None
    self.ouch = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'ouch' in d:
        self.ouch = d['ouch']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = MetaException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('schema_exists_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ouch != None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class exists_args:

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table_name', None, None, ), # 1
  )

  def __init__(self, d=None):
    self.table_name = None
    if isinstance(d, dict):
      if 'table_name' in d:
        self.table_name = d['table_name']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('exists_args')
    if self.table_name != None:
      oprot.writeFieldBegin('table_name', TType.STRING, 1)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class exists_result:

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, d=None):
    self.success = None
    self.ouch = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'ouch' in d:
        self.ouch = d['ouch']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = MetaException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('exists_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ouch != None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_table_args:

  thrift_spec = None
  def __init__(self, d=None):
    self.table_name = None
    self.columns = None
    if isinstance(d, dict):
      if 'table_name' in d:
        self.table_name = d['table_name']
      if 'columns' in d:
        self.columns = d['columns']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.LIST:
          self.columns = []
          (_etype49, _size46) = iprot.readListBegin()
          for _i50 in xrange(_size46):
            _elem51 = iprot.readString();
            self.columns.append(_elem51)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_table_args')
    if self.table_name != None:
      oprot.writeFieldBegin('table_name', TType.STRING, -1)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.columns != None:
      oprot.writeFieldBegin('columns', TType.LIST, -2)
      oprot.writeListBegin(TType.STRING, len(self.columns))
      for iter52 in self.columns:
        oprot.writeString(iter52)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_table_result:

  thrift_spec = None
  def __init__(self, d=None):
    self.ouch = None
    self.ouch2 = None
    if isinstance(d, dict):
      if 'ouch' in d:
        self.ouch = d['ouch']
      if 'ouch2' in d:
        self.ouch2 = d['ouch2']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -3:
        if ftype == TType.STRUCT:
          self.ouch = MetaException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -4:
        if ftype == TType.STRUCT:
          self.ouch2 = UnknownTableException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_table_result')
    if self.ouch != None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, -3)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 != None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, -4)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_table_args:

  thrift_spec = None
  def __init__(self, d=None):
    self.table_name = None
    self.columns = None
    self.partition_cols = None
    if isinstance(d, dict):
      if 'table_name' in d:
        self.table_name = d['table_name']
      if 'columns' in d:
        self.columns = d['columns']
      if 'partition_cols' in d:
        self.partition_cols = d['partition_cols']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.LIST:
          self.columns = []
          (_etype56, _size53) = iprot.readListBegin()
          for _i57 in xrange(_size53):
            _elem58 = iprot.readString();
            self.columns.append(_elem58)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.LIST:
          self.partition_cols = []
          (_etype62, _size59) = iprot.readListBegin()
          for _i63 in xrange(_size59):
            _elem64 = iprot.readString();
            self.partition_cols.append(_elem64)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_table_args')
    if self.table_name != None:
      oprot.writeFieldBegin('table_name', TType.STRING, -1)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.columns != None:
      oprot.writeFieldBegin('columns', TType.LIST, -2)
      oprot.writeListBegin(TType.STRING, len(self.columns))
      for iter65 in self.columns:
        oprot.writeString(iter65)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.partition_cols != None:
      oprot.writeFieldBegin('partition_cols', TType.LIST, -3)
      oprot.writeListBegin(TType.STRING, len(self.partition_cols))
      for iter66 in self.partition_cols:
        oprot.writeString(iter66)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_table_result:

  thrift_spec = None
  def __init__(self, d=None):
    self.ouch = None
    if isinstance(d, dict):
      if 'ouch' in d:
        self.ouch = d['ouch']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -4:
        if ftype == TType.STRUCT:
          self.ouch = MetaException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_table_result')
    if self.ouch != None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, -4)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_args:

  thrift_spec = None
  def __init__(self, d=None):
    self.table_name = None
    if isinstance(d, dict):
      if 'table_name' in d:
        self.table_name = d['table_name']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_args')
    if self.table_name != None:
      oprot.writeFieldBegin('table_name', TType.STRING, -1)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_result:

  thrift_spec = None
  def __init__(self, d=None):
    self.success = None
    self.ouch = None
    self.ouch2 = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'ouch' in d:
        self.ouch = d['ouch']
      if 'ouch2' in d:
        self.ouch2 = d['ouch2']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype70, _size67) = iprot.readListBegin()
          for _i71 in xrange(_size67):
            _elem72 = iprot.readString();
            self.success.append(_elem72)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.STRUCT:
          self.ouch = MetaException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.STRUCT:
          self.ouch2 = UnknownTableException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter73 in self.success:
        oprot.writeString(iter73)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch != None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, -2)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 != None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, -3)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_log_args:

  thrift_spec = None
  def __init__(self, d=None):
    self.table_name = None
    self.logName = None
    self.new_entry = None
    if isinstance(d, dict):
      if 'table_name' in d:
        self.table_name = d['table_name']
      if 'logName' in d:
        self.logName = d['logName']
      if 'new_entry' in d:
        self.new_entry = d['new_entry']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.STRING:
          self.logName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.MAP:
          self.new_entry = {}
          (_ktype75, _vtype76, _size74 ) = iprot.readMapBegin() 
          for _i78 in xrange(_size74):
            _key79 = iprot.readString();
            _val80 = iprot.readString();
            self.new_entry[_key79] = _val80
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_log_args')
    if self.table_name != None:
      oprot.writeFieldBegin('table_name', TType.STRING, -1)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.logName != None:
      oprot.writeFieldBegin('logName', TType.STRING, -2)
      oprot.writeString(self.logName)
      oprot.writeFieldEnd()
    if self.new_entry != None:
      oprot.writeFieldBegin('new_entry', TType.MAP, -3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.new_entry))
      for kiter81,viter82 in self.new_entry.items():
        oprot.writeString(kiter81)
        oprot.writeString(viter82)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_log_result:

  thrift_spec = None
  def __init__(self, d=None):
    self.ouch = None
    self.ouch2 = None
    if isinstance(d, dict):
      if 'ouch' in d:
        self.ouch = d['ouch']
      if 'ouch2' in d:
        self.ouch2 = d['ouch2']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -4:
        if ftype == TType.STRUCT:
          self.ouch = MetaException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -5:
        if ftype == TType.STRUCT:
          self.ouch2 = UnknownTableException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_log_result')
    if self.ouch != None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, -4)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 != None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, -5)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_log_args:

  thrift_spec = None
  def __init__(self, d=None):
    self.table_name = None
    self.logName = None
    if isinstance(d, dict):
      if 'table_name' in d:
        self.table_name = d['table_name']
      if 'logName' in d:
        self.logName = d['logName']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.STRING:
          self.logName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_log_args')
    if self.table_name != None:
      oprot.writeFieldBegin('table_name', TType.STRING, -1)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.logName != None:
      oprot.writeFieldBegin('logName', TType.STRING, -2)
      oprot.writeString(self.logName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_log_result:

  thrift_spec = None
  def __init__(self, d=None):
    self.success = None
    self.ouch = None
    self.ouch2 = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'ouch' in d:
        self.ouch = d['ouch']
      if 'ouch2' in d:
        self.ouch2 = d['ouch2']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype86, _size83) = iprot.readListBegin()
          for _i87 in xrange(_size83):
            _elem88 = {}
            (_ktype90, _vtype91, _size89 ) = iprot.readMapBegin() 
            for _i93 in xrange(_size89):
              _key94 = iprot.readString();
              _val95 = iprot.readString();
              _elem88[_key94] = _val95
            iprot.readMapEnd()
            self.success.append(_elem88)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.STRUCT:
          self.ouch = MetaException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -4:
        if ftype == TType.STRUCT:
          self.ouch2 = UnknownTableException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_log_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.MAP, len(self.success))
      for iter96 in self.success:
        oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter96))
        for kiter97,viter98 in iter96.items():
          oprot.writeString(kiter97)
          oprot.writeString(viter98)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch != None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, -3)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 != None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, -4)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_log_names_args:

  thrift_spec = None
  def __init__(self, d=None):
    self.table_name = None
    if isinstance(d, dict):
      if 'table_name' in d:
        self.table_name = d['table_name']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_log_names_args')
    if self.table_name != None:
      oprot.writeFieldBegin('table_name', TType.STRING, -1)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_log_names_result:

  thrift_spec = None
  def __init__(self, d=None):
    self.success = None
    self.ouch = None
    self.ouch2 = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'ouch' in d:
        self.ouch = d['ouch']
      if 'ouch2' in d:
        self.ouch2 = d['ouch2']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype102, _size99) = iprot.readListBegin()
          for _i103 in xrange(_size99):
            _elem104 = iprot.readString();
            self.success.append(_elem104)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.STRUCT:
          self.ouch = MetaException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.STRUCT:
          self.ouch2 = UnknownTableException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_log_names_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter105 in self.success:
        oprot.writeString(iter105)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch != None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, -2)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 != None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, -3)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)


