begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|cache
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|io
operator|.
name|Allocator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|io
operator|.
name|DataCache
operator|.
name|BooleanRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|io
operator|.
name|DataCache
operator|.
name|DiskRangeListFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|io
operator|.
name|encoded
operator|.
name|MemoryBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|DebugUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|cache
operator|.
name|LowLevelCache
operator|.
name|Priority
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|io
operator|.
name|api
operator|.
name|impl
operator|.
name|LlapIoImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|metrics
operator|.
name|LlapDaemonCacheMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|common
operator|.
name|util
operator|.
name|Ref
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|OrcProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|OrcProto
operator|.
name|ColumnEncoding
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_class
specifier|public
class|class
name|SerDeLowLevelCacheImpl
implements|implements
name|BufferUsageManager
implements|,
name|LlapOomDebugDump
block|{
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_CLEANUP_INTERVAL
init|=
literal|600
decl_stmt|;
specifier|private
specifier|final
name|Allocator
name|allocator
decl_stmt|;
specifier|private
specifier|final
name|AtomicInteger
name|newEvictions
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
name|Thread
name|cleanupThread
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|ConcurrentHashMap
argument_list|<
name|Object
argument_list|,
name|FileCache
argument_list|<
name|FileData
argument_list|>
argument_list|>
name|cache
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|LowLevelCachePolicy
name|cachePolicy
decl_stmt|;
specifier|private
specifier|final
name|long
name|cleanupInterval
decl_stmt|;
specifier|private
specifier|final
name|LlapDaemonCacheMetrics
name|metrics
decl_stmt|;
specifier|private
specifier|static
specifier|final
class|class
name|StripeInfoComparator
implements|implements
name|Comparator
argument_list|<
name|StripeData
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|StripeData
name|o1
parameter_list|,
name|StripeData
name|o2
parameter_list|)
block|{
name|int
name|starts
init|=
name|Long
operator|.
name|compare
argument_list|(
name|o1
operator|.
name|knownTornStart
argument_list|,
name|o2
operator|.
name|knownTornStart
argument_list|)
decl_stmt|;
if|if
condition|(
name|starts
operator|!=
literal|0
condition|)
return|return
name|starts
return|;
name|starts
operator|=
name|Long
operator|.
name|compare
argument_list|(
name|o1
operator|.
name|firstStart
argument_list|,
name|o2
operator|.
name|firstStart
argument_list|)
expr_stmt|;
if|if
condition|(
name|starts
operator|!=
literal|0
condition|)
return|return
name|starts
return|;
assert|assert
operator|(
name|o1
operator|.
name|lastStart
operator|==
name|o2
operator|.
name|lastStart
operator|)
operator|==
operator|(
name|o1
operator|.
name|lastEnd
operator|==
name|o2
operator|.
name|lastEnd
operator|)
assert|;
return|return
name|Long
operator|.
name|compare
argument_list|(
name|o1
operator|.
name|lastStart
argument_list|,
name|o2
operator|.
name|lastStart
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|FileData
block|{
comment|/**      * RW lock ensures we have a consistent view of the file data, which is important given that      * we generate "stripe" boundaries arbitrarily. Reading buffer data itself doesn't require      * that this lock is held; however, everything else in stripes list does.      * TODO: make more granular? We only care that each one reader sees consistent boundaries.      *       So, we could shallow-copy the stripes list, then have individual locks inside each.      */
specifier|private
specifier|final
name|ReadWriteLock
name|rwLock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Object
name|fileKey
decl_stmt|;
specifier|private
specifier|final
name|int
name|colCount
decl_stmt|;
specifier|private
name|ArrayList
argument_list|<
name|StripeData
argument_list|>
name|stripes
decl_stmt|;
specifier|public
name|FileData
parameter_list|(
name|Object
name|fileKey
parameter_list|,
name|int
name|colCount
parameter_list|)
block|{
name|this
operator|.
name|fileKey
operator|=
name|fileKey
expr_stmt|;
name|this
operator|.
name|colCount
operator|=
name|colCount
expr_stmt|;
block|}
specifier|public
name|void
name|toString
parameter_list|(
name|StringBuilder
name|sb
parameter_list|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"File data for "
argument_list|)
operator|.
name|append
argument_list|(
name|fileKey
argument_list|)
operator|.
name|append
argument_list|(
literal|" with "
argument_list|)
operator|.
name|append
argument_list|(
name|colCount
argument_list|)
operator|.
name|append
argument_list|(
literal|" columns: "
argument_list|)
operator|.
name|append
argument_list|(
name|stripes
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|getColCount
parameter_list|()
block|{
return|return
name|colCount
return|;
block|}
specifier|public
name|ArrayList
argument_list|<
name|StripeData
argument_list|>
name|getData
parameter_list|()
block|{
return|return
name|stripes
return|;
block|}
specifier|public
name|void
name|addStripe
parameter_list|(
name|StripeData
name|sd
parameter_list|)
block|{
if|if
condition|(
name|stripes
operator|==
literal|null
condition|)
block|{
name|stripes
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|stripes
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"[fileKey="
operator|+
name|fileKey
operator|+
literal|", colCount="
operator|+
name|colCount
operator|+
literal|", stripes="
operator|+
name|stripes
operator|+
literal|"]"
return|;
block|}
block|}
specifier|public
specifier|static
specifier|final
class|class
name|StripeData
block|{
comment|// In LRR case, if we just store 2 boundaries (which could be split boundaries or reader
comment|// positions, we wouldn't be able to account for torn rows correctly because the semantics of
comment|// our "exact" reader positions, and inexact split boundaries, are different. We cannot even
comment|// tell LRR to use exact boundaries, as there can be a mismatch in an original mid-file split
comment|// wrt first row when caching - we may produce incorrect result if we adjust the split
comment|// boundary, and also if we don't adjust it, depending where it falls. At best, we'd end up
comment|// with spurious disk reads if we cache on row boundaries but splits include torn rows.
comment|// This structure implies that when reading a split, we skip the first torn row but fully
comment|// read the last torn row (as LineRecordReader does). If we want to support a different scheme,
comment|// we'd need to store more offsets and make logic account for that.
specifier|private
name|long
name|knownTornStart
decl_stmt|;
comment|// This can change based on new splits.
specifier|private
specifier|final
name|long
name|firstStart
decl_stmt|,
name|lastStart
decl_stmt|,
name|lastEnd
decl_stmt|;
comment|// TODO: we can actually consider storing ALL the delta encoded row offsets - not a lot of
comment|//       overhead compared to the data itself, and with row offsets, we could use columnar
comment|//       blocks for inconsistent splits. We are not optimizing for inconsistent splits for now.
specifier|private
specifier|final
name|long
name|rowCount
decl_stmt|;
specifier|private
specifier|final
name|OrcProto
operator|.
name|ColumnEncoding
index|[]
name|encodings
decl_stmt|;
specifier|private
name|LlapDataBuffer
index|[]
index|[]
index|[]
name|data
decl_stmt|;
comment|// column index, stream type, buffers
specifier|public
name|StripeData
parameter_list|(
name|long
name|knownTornStart
parameter_list|,
name|long
name|firstStart
parameter_list|,
name|long
name|lastStart
parameter_list|,
name|long
name|lastEnd
parameter_list|,
name|long
name|rowCount
parameter_list|,
name|ColumnEncoding
index|[]
name|encodings
parameter_list|)
block|{
name|this
operator|.
name|knownTornStart
operator|=
name|knownTornStart
expr_stmt|;
name|this
operator|.
name|firstStart
operator|=
name|firstStart
expr_stmt|;
name|this
operator|.
name|lastStart
operator|=
name|lastStart
expr_stmt|;
name|this
operator|.
name|lastEnd
operator|=
name|lastEnd
expr_stmt|;
name|this
operator|.
name|encodings
operator|=
name|encodings
expr_stmt|;
name|this
operator|.
name|rowCount
operator|=
name|rowCount
expr_stmt|;
name|this
operator|.
name|data
operator|=
name|encodings
operator|==
literal|null
condition|?
literal|null
else|:
operator|new
name|LlapDataBuffer
index|[
name|encodings
operator|.
name|length
index|]
index|[]
index|[]
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|toCoordinateString
argument_list|()
operator|+
literal|" with encodings ["
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|encodings
argument_list|)
operator|.
name|replace
argument_list|(
literal|'\n'
argument_list|,
literal|' '
argument_list|)
operator|+
literal|"] and data "
operator|+
name|SerDeLowLevelCacheImpl
operator|.
name|toString
argument_list|(
name|data
argument_list|)
return|;
block|}
specifier|public
name|long
name|getKnownTornStart
parameter_list|()
block|{
return|return
name|knownTornStart
return|;
block|}
specifier|public
name|long
name|getFirstStart
parameter_list|()
block|{
return|return
name|firstStart
return|;
block|}
specifier|public
name|long
name|getLastStart
parameter_list|()
block|{
return|return
name|lastStart
return|;
block|}
specifier|public
name|long
name|getLastEnd
parameter_list|()
block|{
return|return
name|lastEnd
return|;
block|}
specifier|public
name|long
name|getRowCount
parameter_list|()
block|{
return|return
name|rowCount
return|;
block|}
specifier|public
name|OrcProto
operator|.
name|ColumnEncoding
index|[]
name|getEncodings
parameter_list|()
block|{
return|return
name|encodings
return|;
block|}
specifier|public
name|LlapDataBuffer
index|[]
index|[]
index|[]
name|getData
parameter_list|()
block|{
return|return
name|data
return|;
block|}
specifier|public
name|String
name|toCoordinateString
parameter_list|()
block|{
return|return
literal|"stripe kts "
operator|+
name|knownTornStart
operator|+
literal|" from "
operator|+
name|firstStart
operator|+
literal|" to ["
operator|+
name|lastStart
operator|+
literal|", "
operator|+
name|lastEnd
operator|+
literal|")"
return|;
block|}
specifier|public
specifier|static
name|StripeData
name|duplicateForResults
parameter_list|(
name|StripeData
name|s
parameter_list|)
block|{
return|return
operator|new
name|StripeData
argument_list|(
name|s
operator|.
name|knownTornStart
argument_list|,
name|s
operator|.
name|firstStart
argument_list|,
name|s
operator|.
name|lastStart
argument_list|,
name|s
operator|.
name|lastEnd
argument_list|,
name|s
operator|.
name|rowCount
argument_list|,
operator|new
name|OrcProto
operator|.
name|ColumnEncoding
index|[
name|s
operator|.
name|encodings
operator|.
name|length
index|]
argument_list|)
return|;
block|}
specifier|public
name|void
name|setKnownTornStart
parameter_list|(
name|long
name|value
parameter_list|)
block|{
name|knownTornStart
operator|=
name|value
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|LlapDataBuffer
index|[]
index|[]
index|[]
name|data
parameter_list|)
block|{
if|if
condition|(
name|data
operator|==
literal|null
condition|)
return|return
literal|"null"
return|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"["
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|LlapDataBuffer
index|[]
index|[]
name|colData
init|=
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|colData
operator|==
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"null, "
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|colData
operator|.
name|length
condition|;
operator|++
name|j
control|)
block|{
name|LlapDataBuffer
index|[]
name|streamData
init|=
name|colData
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|streamData
operator|==
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"null, "
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|streamData
operator|.
name|length
condition|;
operator|++
name|k
control|)
block|{
name|LlapDataBuffer
name|s
init|=
name|streamData
index|[
name|k
index|]
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|LlapDataBuffer
operator|.
name|toDataString
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"], "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"], "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|LlapDataBuffer
index|[]
index|[]
name|data
parameter_list|)
block|{
if|if
condition|(
name|data
operator|==
literal|null
condition|)
return|return
literal|"null"
return|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"["
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|data
operator|.
name|length
condition|;
operator|++
name|j
control|)
block|{
name|LlapDataBuffer
index|[]
name|streamData
init|=
name|data
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|streamData
operator|==
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"null, "
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|streamData
operator|.
name|length
condition|;
operator|++
name|k
control|)
block|{
name|LlapDataBuffer
name|s
init|=
name|streamData
index|[
name|k
index|]
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|LlapDataBuffer
operator|.
name|toDataString
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"], "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
name|SerDeLowLevelCacheImpl
parameter_list|(
name|LlapDaemonCacheMetrics
name|metrics
parameter_list|,
name|LowLevelCachePolicy
name|cachePolicy
parameter_list|,
name|Allocator
name|allocator
parameter_list|)
block|{
name|this
operator|.
name|cachePolicy
operator|=
name|cachePolicy
expr_stmt|;
name|this
operator|.
name|allocator
operator|=
name|allocator
expr_stmt|;
name|this
operator|.
name|cleanupInterval
operator|=
name|DEFAULT_CLEANUP_INTERVAL
expr_stmt|;
name|this
operator|.
name|metrics
operator|=
name|metrics
expr_stmt|;
name|LlapIoImpl
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"SerDe low-level level cache; cleanup interval {} sec"
argument_list|,
name|cleanupInterval
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|startThreads
parameter_list|()
block|{
if|if
condition|(
name|cleanupInterval
operator|<
literal|0
condition|)
return|return;
name|cleanupThread
operator|=
operator|new
name|CleanupThread
argument_list|(
name|cache
argument_list|,
name|newEvictions
argument_list|,
name|cleanupInterval
argument_list|)
expr_stmt|;
name|cleanupThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
specifier|public
name|FileData
name|getFileData
parameter_list|(
name|Object
name|fileKey
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|boolean
index|[]
name|includes
parameter_list|,
name|DiskRangeListFactory
name|factory
parameter_list|,
name|LowLevelCacheCounters
name|qfCounters
parameter_list|,
name|BooleanRef
name|gotAllData
parameter_list|)
throws|throws
name|IOException
block|{
name|FileCache
argument_list|<
name|FileData
argument_list|>
name|subCache
init|=
name|cache
operator|.
name|get
argument_list|(
name|fileKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|subCache
operator|==
literal|null
operator|||
operator|!
name|subCache
operator|.
name|incRef
argument_list|()
condition|)
block|{
if|if
condition|(
name|LlapIoImpl
operator|.
name|CACHE_LOGGER
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LlapIoImpl
operator|.
name|CACHE_LOGGER
operator|.
name|trace
argument_list|(
literal|"Cannot find cache for "
operator|+
name|fileKey
operator|+
literal|" in "
operator|+
name|cache
argument_list|)
expr_stmt|;
block|}
name|markAllAsMissed
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|qfCounters
argument_list|,
name|gotAllData
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
try|try
block|{
name|FileData
name|cached
init|=
name|subCache
operator|.
name|getCache
argument_list|()
decl_stmt|;
name|cached
operator|.
name|rwLock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|LlapIoImpl
operator|.
name|CACHE_LOGGER
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LlapIoImpl
operator|.
name|CACHE_LOGGER
operator|.
name|trace
argument_list|(
literal|"Cache for "
operator|+
name|fileKey
operator|+
literal|" is "
operator|+
name|subCache
operator|.
name|getCache
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|cached
operator|.
name|stripes
operator|==
literal|null
condition|)
block|{
name|LlapIoImpl
operator|.
name|CACHE_LOGGER
operator|.
name|debug
argument_list|(
literal|"Cannot find any stripes for "
operator|+
name|fileKey
argument_list|)
expr_stmt|;
name|markAllAsMissed
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|qfCounters
argument_list|,
name|gotAllData
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|includes
operator|.
name|length
operator|>
name|cached
operator|.
name|colCount
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Includes "
operator|+
name|DebugUtils
operator|.
name|toString
argument_list|(
name|includes
argument_list|)
operator|+
literal|" for "
operator|+
name|cached
operator|.
name|colCount
operator|+
literal|" columns"
argument_list|)
throw|;
block|}
name|FileData
name|result
init|=
operator|new
name|FileData
argument_list|(
name|cached
operator|.
name|fileKey
argument_list|,
name|cached
operator|.
name|colCount
argument_list|)
decl_stmt|;
if|if
condition|(
name|gotAllData
operator|!=
literal|null
condition|)
block|{
name|gotAllData
operator|.
name|value
operator|=
literal|true
expr_stmt|;
block|}
comment|// We will adjust start and end so that we could record the metrics; save the originals.
name|long
name|origStart
init|=
name|start
decl_stmt|,
name|origEnd
init|=
name|end
decl_stmt|;
comment|// startIx is inclusive, endIx is exclusive.
name|int
name|startIx
init|=
name|Integer
operator|.
name|MIN_VALUE
decl_stmt|,
name|endIx
init|=
name|Integer
operator|.
name|MIN_VALUE
decl_stmt|;
name|LlapIoImpl
operator|.
name|CACHE_LOGGER
operator|.
name|debug
argument_list|(
literal|"Looking for data between "
operator|+
name|start
operator|+
literal|" and "
operator|+
name|end
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cached
operator|.
name|stripes
operator|.
name|size
argument_list|()
operator|&&
name|endIx
operator|==
name|Integer
operator|.
name|MIN_VALUE
condition|;
operator|++
name|i
control|)
block|{
name|StripeData
name|si
init|=
name|cached
operator|.
name|stripes
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|LlapIoImpl
operator|.
name|CACHE_LOGGER
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LlapIoImpl
operator|.
name|CACHE_LOGGER
operator|.
name|trace
argument_list|(
literal|"Looking at "
operator|+
name|si
operator|.
name|toCoordinateString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|startIx
operator|==
name|i
condition|)
block|{
comment|// The start of the split was in the middle of the previous slice.
name|start
operator|=
name|si
operator|.
name|knownTornStart
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|startIx
operator|==
name|Integer
operator|.
name|MIN_VALUE
condition|)
block|{
comment|// Determine if we need to read this slice for the split.
if|if
condition|(
name|si
operator|.
name|lastEnd
operator|<=
name|start
condition|)
continue|continue;
comment|// Slice before the start of the split.
comment|// Start of the split falls somewhere within or before this slice.
comment|// Note the ">=" - LineRecordReader will skip the first row even if we start
comment|// directly at its start, because it cannot know if it's the start or not.
comment|// Unless it's 0; note that we DO give 0 special treatment here, unlike the EOF below,
comment|// because zero is zero. Need to mention it in Javadoc.
if|if
condition|(
name|start
operator|==
literal|0
operator|&&
name|si
operator|.
name|firstStart
operator|==
literal|0
condition|)
block|{
name|startIx
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|start
operator|>=
name|si
operator|.
name|firstStart
condition|)
block|{
comment|// If the start of the split points into the middle of the cached slice, we cannot
comment|// use the cached block - it's encoded and columnar, so we cannot map the file
comment|// offset to some "offset" in "middle" of the slice (but see TODO for firstStart).
name|startIx
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|// continue;
block|}
else|else
block|{
comment|// Start of the split is before this slice.
name|startIx
operator|=
name|i
expr_stmt|;
comment|// Simple case - we will read cache from the split start offset.
name|start
operator|=
name|si
operator|.
name|knownTornStart
expr_stmt|;
block|}
block|}
comment|// Determine if this (or previous) is the last slice we need to read for this split.
if|if
condition|(
name|startIx
operator|!=
name|Integer
operator|.
name|MIN_VALUE
operator|&&
name|endIx
operator|==
name|Integer
operator|.
name|MIN_VALUE
condition|)
block|{
if|if
condition|(
name|si
operator|.
name|lastEnd
operator|<=
name|end
condition|)
block|{
comment|// The entire current slice is part of the split. Note that if split end EQUALS
comment|// lastEnd, the split would also read the next row, so we do need to look at the
comment|// next slice, if any (although we'd probably find we cannot use it).
comment|// Note also that we DO NOT treat end-of-file differently here, cause we do not know
comment|// of any such thing. The caller must handle lastEnd vs end of split vs end of file
comment|// match correctly in terms of how LRR handles them. See above for start-of-file.
if|if
condition|(
name|i
operator|+
literal|1
operator|!=
name|cached
operator|.
name|stripes
operator|.
name|size
argument_list|()
condition|)
continue|continue;
name|endIx
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|end
operator|=
name|si
operator|.
name|lastEnd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|si
operator|.
name|lastStart
operator|<=
name|end
condition|)
block|{
comment|// The split ends within (and would read) the last row of this slice. Exact match.
name|endIx
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|end
operator|=
name|si
operator|.
name|lastEnd
expr_stmt|;
block|}
else|else
block|{
comment|// Either the slice comes entirely after the end of split (following a gap in cached
comment|// data); or the split ends in the middle of the slice, so it's the same as in the
comment|// startIx logic w.r.t. the partial match; so, we either don't want to, or cannot,
comment|// use this. There's no need to distinguish these two cases for now.
name|endIx
operator|=
name|i
expr_stmt|;
name|end
operator|=
operator|(
name|endIx
operator|>
literal|0
operator|)
condition|?
name|cached
operator|.
name|stripes
operator|.
name|get
argument_list|(
name|endIx
operator|-
literal|1
argument_list|)
operator|.
name|lastEnd
else|:
name|start
expr_stmt|;
block|}
block|}
block|}
name|LlapIoImpl
operator|.
name|CACHE_LOGGER
operator|.
name|debug
argument_list|(
literal|"Determined stripe indexes "
operator|+
name|startIx
operator|+
literal|", "
operator|+
name|endIx
argument_list|)
expr_stmt|;
if|if
condition|(
name|endIx
operator|<=
name|startIx
condition|)
block|{
if|if
condition|(
name|gotAllData
operator|!=
literal|null
condition|)
block|{
name|gotAllData
operator|.
name|value
operator|=
literal|false
expr_stmt|;
block|}
return|return
literal|null
return|;
comment|// No data for the split, or it fits in the middle of one or two slices.
block|}
if|if
condition|(
name|start
operator|>
name|origStart
operator|||
name|end
operator|<
name|origEnd
condition|)
block|{
if|if
condition|(
name|gotAllData
operator|!=
literal|null
condition|)
block|{
name|gotAllData
operator|.
name|value
operator|=
literal|false
expr_stmt|;
block|}
name|long
name|totalMiss
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|origEnd
operator|-
name|end
argument_list|)
operator|+
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|start
operator|-
name|origStart
argument_list|)
decl_stmt|;
name|metrics
operator|.
name|incrCacheRequestedBytes
argument_list|(
name|totalMiss
argument_list|)
expr_stmt|;
if|if
condition|(
name|qfCounters
operator|!=
literal|null
condition|)
block|{
name|qfCounters
operator|.
name|recordCacheMiss
argument_list|(
name|totalMiss
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|.
name|stripes
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|endIx
operator|-
name|startIx
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|stripeIx
init|=
name|startIx
init|;
name|stripeIx
operator|<
name|endIx
condition|;
operator|++
name|stripeIx
control|)
block|{
name|getCacheDataForOneSlice
argument_list|(
name|stripeIx
argument_list|,
name|cached
argument_list|,
name|result
argument_list|,
name|gotAllData
argument_list|,
name|includes
argument_list|,
name|qfCounters
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
finally|finally
block|{
name|cached
operator|.
name|rwLock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|subCache
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|getCacheDataForOneSlice
parameter_list|(
name|int
name|stripeIx
parameter_list|,
name|FileData
name|cached
parameter_list|,
name|FileData
name|result
parameter_list|,
name|BooleanRef
name|gotAllData
parameter_list|,
name|boolean
index|[]
name|includes
parameter_list|,
name|LowLevelCacheCounters
name|qfCounters
parameter_list|)
block|{
name|StripeData
name|cStripe
init|=
name|cached
operator|.
name|stripes
operator|.
name|get
argument_list|(
name|stripeIx
argument_list|)
decl_stmt|;
if|if
condition|(
name|LlapIoImpl
operator|.
name|CACHE_LOGGER
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LlapIoImpl
operator|.
name|CACHE_LOGGER
operator|.
name|trace
argument_list|(
literal|"Got stripe in cache "
operator|+
name|cStripe
argument_list|)
expr_stmt|;
block|}
name|StripeData
name|stripe
init|=
name|StripeData
operator|.
name|duplicateForResults
argument_list|(
name|cStripe
argument_list|)
decl_stmt|;
name|result
operator|.
name|stripes
operator|.
name|add
argument_list|(
name|stripe
argument_list|)
expr_stmt|;
name|boolean
name|isMissed
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|colIx
init|=
literal|0
init|;
name|colIx
operator|<
name|cached
operator|.
name|colCount
condition|;
operator|++
name|colIx
control|)
block|{
if|if
condition|(
operator|!
name|includes
index|[
name|colIx
index|]
condition|)
continue|continue;
if|if
condition|(
name|cStripe
operator|.
name|encodings
index|[
name|colIx
index|]
operator|==
literal|null
operator|||
name|cStripe
operator|.
name|data
index|[
name|colIx
index|]
operator|==
literal|null
condition|)
block|{
assert|assert
name|cStripe
operator|.
name|data
index|[
name|colIx
index|]
operator|==
literal|null
assert|;
comment|// No encoding => must have no data.
name|isMissed
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|gotAllData
operator|!=
literal|null
condition|)
block|{
name|gotAllData
operator|.
name|value
operator|=
literal|false
expr_stmt|;
block|}
continue|continue;
block|}
name|stripe
operator|.
name|encodings
index|[
name|colIx
index|]
operator|=
name|cStripe
operator|.
name|encodings
index|[
name|colIx
index|]
expr_stmt|;
name|LlapDataBuffer
index|[]
index|[]
name|cColData
init|=
name|cStripe
operator|.
name|data
index|[
name|colIx
index|]
decl_stmt|;
assert|assert
name|cColData
operator|!=
literal|null
assert|;
for|for
control|(
name|int
name|streamIx
init|=
literal|0
init|;
name|cColData
operator|!=
literal|null
operator|&&
name|streamIx
operator|<
name|cColData
operator|.
name|length
condition|;
operator|++
name|streamIx
control|)
block|{
name|LlapDataBuffer
index|[]
name|streamData
init|=
name|cColData
index|[
name|streamIx
index|]
decl_stmt|;
comment|// Note: this relies on the fact that we always evict the entire column, so if
comment|//       we have the column data, we assume we have all the streams we need.
if|if
condition|(
name|streamData
operator|==
literal|null
condition|)
continue|continue;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|streamData
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
comment|// Finally, we are going to use "i"!
if|if
condition|(
operator|!
name|lockBuffer
argument_list|(
name|streamData
index|[
name|i
index|]
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|LlapIoImpl
operator|.
name|CACHE_LOGGER
operator|.
name|info
argument_list|(
literal|"Couldn't lock data for stripe at "
operator|+
name|stripeIx
operator|+
literal|", colIx "
operator|+
name|colIx
operator|+
literal|", stream type "
operator|+
name|streamIx
argument_list|)
expr_stmt|;
name|cColData
operator|=
literal|null
expr_stmt|;
name|isMissed
operator|=
literal|true
expr_stmt|;
name|handleRemovedColumnData
argument_list|(
name|cColData
argument_list|)
expr_stmt|;
if|if
condition|(
name|gotAllData
operator|!=
literal|null
condition|)
block|{
name|gotAllData
operator|.
name|value
operator|=
literal|false
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
comment|// At this point, we have arrived at the level where we need all the data, and the
comment|// arrays never change. So we will just do a shallow assignment here instead of copy.
name|stripe
operator|.
name|data
index|[
name|colIx
index|]
operator|=
name|cColData
expr_stmt|;
block|}
name|doMetricsStuffForOneSlice
argument_list|(
name|qfCounters
argument_list|,
name|stripe
argument_list|,
name|isMissed
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|doMetricsStuffForOneSlice
parameter_list|(
name|LowLevelCacheCounters
name|qfCounters
parameter_list|,
name|StripeData
name|stripe
parameter_list|,
name|boolean
name|isMissed
parameter_list|)
block|{
comment|// Slice boundaries may not match split boundaries due to torn rows in either direction,
comment|// so this counter may not be consistent with splits. This is also why we increment
comment|// requested bytes here, instead of based on the split - we don't want the metrics to be
comment|// inconsistent with each other. No matter what we determine here, at least we'll account
comment|// for both in the same manner.
name|long
name|bytes
init|=
name|stripe
operator|.
name|lastEnd
operator|-
name|stripe
operator|.
name|knownTornStart
decl_stmt|;
name|metrics
operator|.
name|incrCacheRequestedBytes
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isMissed
condition|)
block|{
name|metrics
operator|.
name|incrCacheHitBytes
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qfCounters
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|isMissed
condition|)
block|{
name|qfCounters
operator|.
name|recordCacheMiss
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qfCounters
operator|.
name|recordCacheHit
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|markAllAsMissed
parameter_list|(
name|long
name|from
parameter_list|,
name|long
name|to
parameter_list|,
name|LowLevelCacheCounters
name|qfCounters
parameter_list|,
name|BooleanRef
name|gotAllData
parameter_list|)
block|{
if|if
condition|(
name|qfCounters
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrCacheRequestedBytes
argument_list|(
name|to
operator|-
name|from
argument_list|)
expr_stmt|;
name|qfCounters
operator|.
name|recordCacheMiss
argument_list|(
name|to
operator|-
name|from
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gotAllData
operator|!=
literal|null
condition|)
block|{
name|gotAllData
operator|.
name|value
operator|=
literal|false
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|lockBuffer
parameter_list|(
name|LlapDataBuffer
name|buffer
parameter_list|,
name|boolean
name|doNotifyPolicy
parameter_list|)
block|{
name|int
name|rc
init|=
name|buffer
operator|.
name|incRef
argument_list|()
decl_stmt|;
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
block|{
name|metrics
operator|.
name|incrCacheNumLockedBuffers
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|doNotifyPolicy
operator|&&
name|rc
operator|==
literal|1
condition|)
block|{
comment|// We have just locked a buffer that wasn't previously locked.
name|cachePolicy
operator|.
name|notifyLock
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
operator|>
literal|0
return|;
block|}
specifier|public
name|void
name|putFileData
parameter_list|(
specifier|final
name|FileData
name|data
parameter_list|,
name|Priority
name|priority
parameter_list|,
name|LowLevelCacheCounters
name|qfCounters
parameter_list|)
block|{
comment|// TODO: buffers are accounted for at allocation time, but ideally we should report the memory
comment|//       overhead from the java objects to memory manager and remove it when discarding file.
if|if
condition|(
name|data
operator|.
name|stripes
operator|==
literal|null
operator|||
name|data
operator|.
name|stripes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LlapIoImpl
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Trying to cache FileData with no data for "
operator|+
name|data
operator|.
name|fileKey
argument_list|)
expr_stmt|;
return|return;
block|}
name|FileCache
argument_list|<
name|FileData
argument_list|>
name|subCache
init|=
literal|null
decl_stmt|;
name|FileData
name|cached
init|=
literal|null
decl_stmt|;
name|data
operator|.
name|rwLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|subCache
operator|=
name|FileCache
operator|.
name|getOrAddFileSubCache
argument_list|(
name|cache
argument_list|,
name|data
operator|.
name|fileKey
argument_list|,
operator|new
name|Function
argument_list|<
name|Void
argument_list|,
name|FileData
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileData
name|apply
parameter_list|(
name|Void
name|input
parameter_list|)
block|{
return|return
name|data
return|;
comment|// If we don't have a file cache, we will add this one as is.
block|}
block|}
argument_list|)
expr_stmt|;
name|cached
operator|=
name|subCache
operator|.
name|getCache
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|data
operator|!=
name|cached
condition|)
block|{
name|data
operator|.
name|rwLock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
try|try
block|{
if|if
condition|(
name|data
operator|!=
name|cached
condition|)
block|{
name|cached
operator|.
name|rwLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
try|try
block|{
for|for
control|(
name|StripeData
name|si
range|:
name|data
operator|.
name|stripes
control|)
block|{
name|lockAllBuffersForPut
argument_list|(
name|si
argument_list|,
name|priority
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|==
name|cached
condition|)
block|{
if|if
condition|(
name|LlapIoImpl
operator|.
name|CACHE_LOGGER
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LlapIoImpl
operator|.
name|CACHE_LOGGER
operator|.
name|trace
argument_list|(
literal|"Cached new data "
operator|+
name|data
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|LlapIoImpl
operator|.
name|CACHE_LOGGER
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LlapIoImpl
operator|.
name|CACHE_LOGGER
operator|.
name|trace
argument_list|(
literal|"Merging old "
operator|+
name|cached
operator|+
literal|" and new "
operator|+
name|data
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|StripeData
argument_list|>
name|combined
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|cached
operator|.
name|stripes
operator|.
name|size
argument_list|()
operator|+
name|data
operator|.
name|stripes
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|combined
operator|.
name|addAll
argument_list|(
name|cached
operator|.
name|stripes
argument_list|)
expr_stmt|;
name|combined
operator|.
name|addAll
argument_list|(
name|data
operator|.
name|stripes
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|combined
argument_list|,
operator|new
name|StripeInfoComparator
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|lastIx
init|=
name|combined
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|ix
init|=
literal|0
init|;
name|ix
operator|<
name|lastIx
condition|;
operator|++
name|ix
control|)
block|{
name|StripeData
name|cur
init|=
name|combined
operator|.
name|get
argument_list|(
name|ix
argument_list|)
decl_stmt|,
name|next
init|=
name|combined
operator|.
name|get
argument_list|(
name|ix
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur
operator|.
name|lastEnd
operator|<=
name|next
operator|.
name|firstStart
condition|)
continue|continue;
comment|// All good.
if|if
condition|(
name|cur
operator|.
name|firstStart
operator|==
name|next
operator|.
name|firstStart
operator|&&
name|cur
operator|.
name|lastEnd
operator|==
name|next
operator|.
name|lastEnd
condition|)
block|{
name|mergeStripeInfos
argument_list|(
name|cur
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|combined
operator|.
name|remove
argument_list|(
name|ix
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|--
name|lastIx
expr_stmt|;
comment|// Don't recheck with next, only 2 lists each w/o collisions.
continue|continue;
block|}
comment|// The original lists do not contain collisions, so only one is 'old'.
name|boolean
name|isCurOriginal
init|=
name|cached
operator|.
name|stripes
operator|.
name|contains
argument_list|(
name|cur
argument_list|)
decl_stmt|;
name|handleRemovedStripeInfo
argument_list|(
name|combined
operator|.
name|remove
argument_list|(
name|isCurOriginal
condition|?
name|ix
else|:
name|ix
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|ix
expr_stmt|;
operator|--
name|lastIx
expr_stmt|;
block|}
name|cached
operator|.
name|stripes
operator|=
name|combined
expr_stmt|;
if|if
condition|(
name|LlapIoImpl
operator|.
name|CACHE_LOGGER
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LlapIoImpl
operator|.
name|CACHE_LOGGER
operator|.
name|trace
argument_list|(
literal|"New cache data is "
operator|+
name|combined
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|cached
operator|.
name|rwLock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|subCache
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|lockAllBuffersForPut
parameter_list|(
name|StripeData
name|si
parameter_list|,
name|Priority
name|priority
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|si
operator|.
name|data
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|LlapDataBuffer
index|[]
index|[]
name|colData
init|=
name|si
operator|.
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|colData
operator|==
literal|null
condition|)
continue|continue;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|colData
operator|.
name|length
condition|;
operator|++
name|j
control|)
block|{
name|LlapDataBuffer
index|[]
name|streamData
init|=
name|colData
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|streamData
operator|==
literal|null
condition|)
continue|continue;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|streamData
operator|.
name|length
condition|;
operator|++
name|k
control|)
block|{
name|boolean
name|canLock
init|=
name|lockBuffer
argument_list|(
name|streamData
index|[
name|k
index|]
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// false - not in cache yet
assert|assert
name|canLock
assert|;
name|cachePolicy
operator|.
name|cache
argument_list|(
name|streamData
index|[
name|k
index|]
argument_list|,
name|priority
argument_list|)
expr_stmt|;
name|streamData
index|[
name|k
index|]
operator|.
name|declaredCachedLength
operator|=
name|streamData
index|[
name|k
index|]
operator|.
name|getByteBufferRaw
argument_list|()
operator|.
name|remaining
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|void
name|handleRemovedStripeInfo
parameter_list|(
name|StripeData
name|removed
parameter_list|)
block|{
for|for
control|(
name|LlapDataBuffer
index|[]
index|[]
name|colData
range|:
name|removed
operator|.
name|data
control|)
block|{
name|handleRemovedColumnData
argument_list|(
name|colData
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|handleRemovedColumnData
parameter_list|(
name|LlapDataBuffer
index|[]
index|[]
name|removed
parameter_list|)
block|{
comment|// TODO: could we tell the policy that we don't care about these and have them evicted? or we
comment|//       could just deallocate them when unlocked, and free memory + handle that in eviction.
comment|//       For now, just abandon the blocks - eventually, they'll get evicted.
block|}
specifier|private
name|void
name|mergeStripeInfos
parameter_list|(
name|StripeData
name|to
parameter_list|,
name|StripeData
name|from
parameter_list|)
block|{
if|if
condition|(
name|LlapIoImpl
operator|.
name|CACHE_LOGGER
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LlapIoImpl
operator|.
name|CACHE_LOGGER
operator|.
name|trace
argument_list|(
literal|"Merging slices data: old "
operator|+
name|to
operator|+
literal|" and new "
operator|+
name|from
argument_list|)
expr_stmt|;
block|}
name|to
operator|.
name|knownTornStart
operator|=
name|Math
operator|.
name|min
argument_list|(
name|to
operator|.
name|knownTornStart
argument_list|,
name|from
operator|.
name|knownTornStart
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|.
name|encodings
operator|.
name|length
operator|!=
name|to
operator|.
name|encodings
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Different encodings "
operator|+
name|from
operator|+
literal|"; "
operator|+
name|to
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|colIx
init|=
literal|0
init|;
name|colIx
operator|<
name|from
operator|.
name|encodings
operator|.
name|length
condition|;
operator|++
name|colIx
control|)
block|{
if|if
condition|(
name|to
operator|.
name|encodings
index|[
name|colIx
index|]
operator|==
literal|null
condition|)
block|{
name|to
operator|.
name|encodings
index|[
name|colIx
index|]
operator|=
name|from
operator|.
name|encodings
index|[
name|colIx
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from
operator|.
name|encodings
index|[
name|colIx
index|]
operator|!=
literal|null
operator|&&
operator|!
name|to
operator|.
name|encodings
index|[
name|colIx
index|]
operator|.
name|equals
argument_list|(
name|from
operator|.
name|encodings
index|[
name|colIx
index|]
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Different encodings at "
operator|+
name|colIx
operator|+
literal|": "
operator|+
name|from
operator|+
literal|"; "
operator|+
name|to
argument_list|)
throw|;
block|}
name|LlapDataBuffer
index|[]
index|[]
name|fromColData
init|=
name|from
operator|.
name|data
index|[
name|colIx
index|]
decl_stmt|;
if|if
condition|(
name|fromColData
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|to
operator|.
name|data
index|[
name|colIx
index|]
operator|!=
literal|null
condition|)
block|{
comment|// Note: we assume here that the data that was returned to the caller from cache will not
comment|// be passed back in via put. Right now it's safe since we don't do anything. But if we
comment|// evict proactively, we will have to compare objects all the way down.
name|handleRemovedColumnData
argument_list|(
name|to
operator|.
name|data
index|[
name|colIx
index|]
argument_list|)
expr_stmt|;
block|}
name|to
operator|.
name|data
index|[
name|colIx
index|]
operator|=
name|fromColData
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|decRefBuffer
parameter_list|(
name|MemoryBuffer
name|buffer
parameter_list|)
block|{
name|unlockBuffer
argument_list|(
operator|(
name|LlapDataBuffer
operator|)
name|buffer
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|decRefBuffers
parameter_list|(
name|List
argument_list|<
name|MemoryBuffer
argument_list|>
name|cacheBuffers
parameter_list|)
block|{
for|for
control|(
name|MemoryBuffer
name|b
range|:
name|cacheBuffers
control|)
block|{
name|unlockBuffer
argument_list|(
operator|(
name|LlapDataBuffer
operator|)
name|b
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|unlockBuffer
parameter_list|(
name|LlapDataBuffer
name|buffer
parameter_list|,
name|boolean
name|handleLastDecRef
parameter_list|)
block|{
name|boolean
name|isLastDecref
init|=
operator|(
name|buffer
operator|.
name|decRef
argument_list|()
operator|==
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|handleLastDecRef
operator|&&
name|isLastDecref
condition|)
block|{
comment|// This is kind of not pretty, but this is how we detect whether buffer was cached.
comment|// We would always set this for lookups at put time.
if|if
condition|(
name|buffer
operator|.
name|declaredCachedLength
operator|!=
name|LlapDataBuffer
operator|.
name|UNKNOWN_CACHED_LENGTH
condition|)
block|{
name|cachePolicy
operator|.
name|notifyUnlock
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LlapIoImpl
operator|.
name|CACHE_LOGGER
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LlapIoImpl
operator|.
name|CACHE_LOGGER
operator|.
name|trace
argument_list|(
literal|"Deallocating {} that was not cached"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
name|allocator
operator|.
name|deallocate
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
name|metrics
operator|.
name|decrCacheNumLockedBuffers
argument_list|()
expr_stmt|;
block|}
specifier|private
specifier|static
specifier|final
name|ByteBuffer
name|fakeBuf
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
operator|new
name|byte
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
specifier|public
specifier|static
name|LlapDataBuffer
name|allocateFake
parameter_list|()
block|{
name|LlapDataBuffer
name|fake
init|=
operator|new
name|LlapDataBuffer
argument_list|()
decl_stmt|;
name|fake
operator|.
name|initialize
argument_list|(
operator|-
literal|1
argument_list|,
name|fakeBuf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|fake
return|;
block|}
specifier|public
specifier|final
name|void
name|notifyEvicted
parameter_list|(
name|MemoryBuffer
name|buffer
parameter_list|)
block|{
name|newEvictions
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
specifier|private
specifier|final
class|class
name|CleanupThread
extends|extends
name|FileCacheCleanupThread
argument_list|<
name|FileData
argument_list|>
block|{
specifier|public
name|CleanupThread
parameter_list|(
name|ConcurrentHashMap
argument_list|<
name|Object
argument_list|,
name|FileCache
argument_list|<
name|FileData
argument_list|>
argument_list|>
name|fileMap
parameter_list|,
name|AtomicInteger
name|newEvictions
parameter_list|,
name|long
name|cleanupInterval
parameter_list|)
block|{
name|super
argument_list|(
literal|"Llap serde low level cache cleanup thread"
argument_list|,
name|fileMap
argument_list|,
name|newEvictions
argument_list|,
name|cleanupInterval
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|getCacheSize
parameter_list|(
name|FileCache
argument_list|<
name|FileData
argument_list|>
name|fc
parameter_list|)
block|{
return|return
literal|1
return|;
comment|// Each iteration cleans the file cache as a single unit (unlike the ORC cache).
block|}
annotation|@
name|Override
specifier|public
name|int
name|cleanUpOneFileCache
parameter_list|(
name|FileCache
argument_list|<
name|FileData
argument_list|>
name|fc
parameter_list|,
name|int
name|leftToCheck
parameter_list|,
name|long
name|endTime
parameter_list|,
name|Ref
argument_list|<
name|Boolean
argument_list|>
name|isPastEndTime
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|FileData
name|fd
init|=
name|fc
operator|.
name|getCache
argument_list|()
decl_stmt|;
name|fd
operator|.
name|rwLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|StripeData
name|sd
range|:
name|fd
operator|.
name|stripes
control|)
block|{
for|for
control|(
name|int
name|colIx
init|=
literal|0
init|;
name|colIx
operator|<
name|sd
operator|.
name|data
operator|.
name|length
condition|;
operator|++
name|colIx
control|)
block|{
name|LlapDataBuffer
index|[]
index|[]
name|colData
init|=
name|sd
operator|.
name|data
index|[
name|colIx
index|]
decl_stmt|;
if|if
condition|(
name|colData
operator|==
literal|null
condition|)
continue|continue;
name|boolean
name|hasAllData
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
operator|(
name|j
operator|<
name|colData
operator|.
name|length
operator|)
operator|&&
name|hasAllData
condition|;
operator|++
name|j
control|)
block|{
name|LlapDataBuffer
index|[]
name|streamData
init|=
name|colData
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|streamData
operator|==
literal|null
condition|)
continue|continue;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|streamData
operator|.
name|length
condition|;
operator|++
name|k
control|)
block|{
name|LlapDataBuffer
name|buf
init|=
name|streamData
index|[
name|k
index|]
decl_stmt|;
name|hasAllData
operator|=
name|hasAllData
operator|&&
name|lockBuffer
argument_list|(
name|buf
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hasAllData
condition|)
break|break;
name|unlockBuffer
argument_list|(
name|buf
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hasAllData
condition|)
block|{
name|handleRemovedColumnData
argument_list|(
name|colData
argument_list|)
expr_stmt|;
name|sd
operator|.
name|data
index|[
name|colIx
index|]
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|fd
operator|.
name|rwLock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|leftToCheck
operator|-
literal|1
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|incRefBuffer
parameter_list|(
name|MemoryBuffer
name|buffer
parameter_list|)
block|{
comment|// notifyReused implies that buffer is already locked; it's also called once for new
comment|// buffers that are not cached yet. Don't notify cache policy.
return|return
name|lockBuffer
argument_list|(
operator|(
operator|(
name|LlapDataBuffer
operator|)
name|buffer
operator|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Allocator
name|getAllocator
parameter_list|()
block|{
return|return
name|allocator
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|debugDumpForOom
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"File cache state "
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|FileCache
argument_list|<
name|FileData
argument_list|>
argument_list|>
name|e
range|:
name|cache
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|incRef
argument_list|()
condition|)
continue|continue;
try|try
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n  file "
operator|+
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n    ["
argument_list|)
expr_stmt|;
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getCache
argument_list|()
operator|.
name|toString
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

