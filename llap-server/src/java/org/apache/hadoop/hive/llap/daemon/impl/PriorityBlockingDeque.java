begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *<p/>  * http://www.apache.org/licenses/LICENSE-2.0  *<p/>  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|daemon
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_comment
comment|/**  * An optionally-bounded {@linkplain BlockingDeque blocking deque} based on  * a navigable set.  *<p/>  *<p> The optional capacity bound constructor argument serves as a  * way to prevent excessive expansion. The capacity, if unspecified,  * is equal to {@link Integer#MAX_VALUE}.  *<p/>  *<p>This class and its iterator implement all of the  *<em>optional</em> methods of the {@link Collection} and {@link  * Iterator} interfaces.  *<p/>  * This code is loosely based on the {@linkplain java.util.concurrent.LinkedBlockingDeque linked blocking deque} code.  */
end_comment

begin_class
specifier|public
class|class
name|PriorityBlockingDeque
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractQueue
argument_list|<
name|E
argument_list|>
implements|implements
name|BlockingDeque
argument_list|<
name|E
argument_list|>
implements|,
name|java
operator|.
name|io
operator|.
name|Serializable
block|{
comment|/*      * Implemented as a navigable set protected by a      * single lock and using conditions to manage blocking.      */
specifier|private
specifier|final
name|int
name|capacity
decl_stmt|;
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|E
argument_list|>
name|list
decl_stmt|;
comment|/**    * Main lock guarding all access    */
specifier|private
specifier|final
name|ReentrantLock
name|lock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
comment|/**    * Condition for waiting takes    */
specifier|private
specifier|final
name|Condition
name|notEmpty
init|=
name|lock
operator|.
name|newCondition
argument_list|()
decl_stmt|;
comment|/**    * Condition for waiting puts    */
specifier|private
specifier|final
name|Condition
name|notFull
init|=
name|lock
operator|.
name|newCondition
argument_list|()
decl_stmt|;
specifier|private
name|Comparator
argument_list|<
name|E
argument_list|>
name|comparator
decl_stmt|;
comment|/**    * Creates a<tt>PriorityBlockingDeque</tt> with a capacity of    * {@link Integer#MAX_VALUE}.    */
specifier|public
name|PriorityBlockingDeque
parameter_list|()
block|{
name|this
argument_list|(
literal|null
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a<tt>PriorityBlockingDeque</tt> with the given (fixed) capacity.    *    * @param capacity the capacity of this deque    * @throws IllegalArgumentException if<tt>capacity</tt> is less than 1    */
specifier|public
name|PriorityBlockingDeque
parameter_list|(
name|int
name|capacity
parameter_list|)
block|{
name|this
argument_list|(
literal|null
argument_list|,
name|capacity
argument_list|)
expr_stmt|;
block|}
specifier|public
name|PriorityBlockingDeque
parameter_list|(
name|Comparator
argument_list|<
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
name|this
argument_list|(
name|comparator
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
block|}
specifier|public
name|PriorityBlockingDeque
parameter_list|(
name|Comparator
argument_list|<
name|E
argument_list|>
name|comparator
parameter_list|,
name|int
name|capacity
parameter_list|)
block|{
if|if
condition|(
name|capacity
operator|<=
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
name|this
operator|.
name|capacity
operator|=
name|capacity
expr_stmt|;
name|this
operator|.
name|list
operator|=
operator|new
name|LinkedList
argument_list|<
name|E
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|comparator
operator|=
name|comparator
expr_stmt|;
block|}
comment|// Basic adding and removing operations, called only while holding lock
comment|/**    * Adds e or returns false if full.    *    * @param e The element to add.    * @return Whether adding was successful.    */
specifier|private
name|boolean
name|innerAdd
parameter_list|(
name|E
name|e
parameter_list|)
block|{
if|if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|>=
name|capacity
condition|)
return|return
literal|false
return|;
name|int
name|insertionPoint
init|=
name|Collections
operator|.
name|binarySearch
argument_list|(
name|list
argument_list|,
name|e
argument_list|,
name|comparator
argument_list|)
decl_stmt|;
if|if
condition|(
name|insertionPoint
operator|<
literal|0
condition|)
block|{
comment|// this means the key didn't exist, so the insertion point is negative minus 1.
name|insertionPoint
operator|=
operator|-
name|insertionPoint
operator|-
literal|1
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|insertionPoint
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// Inserted in sort order. Hence no explict sort.
name|notEmpty
operator|.
name|signal
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Removes and returns first element, or null if empty.    *    * @return The removed element.    */
specifier|private
name|E
name|innerRemoveFirst
parameter_list|()
block|{
name|E
name|f
init|=
name|list
operator|.
name|pollFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|f
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|notFull
operator|.
name|signal
argument_list|()
expr_stmt|;
return|return
name|f
return|;
block|}
comment|/**    * Removes and returns last element, or null if empty.    *    * @return The removed element.    */
specifier|private
name|E
name|innerRemoveLast
parameter_list|()
block|{
name|E
name|l
init|=
name|list
operator|.
name|pollLast
argument_list|()
decl_stmt|;
if|if
condition|(
name|l
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|notFull
operator|.
name|signal
argument_list|()
expr_stmt|;
return|return
name|l
return|;
block|}
comment|// BlockingDeque methods
comment|/**    * @throws IllegalStateException {@inheritDoc}    * @throws NullPointerException  {@inheritDoc}    */
specifier|public
name|void
name|addFirst
parameter_list|(
name|E
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|offerFirst
argument_list|(
name|e
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Deque full"
argument_list|)
throw|;
block|}
comment|/**    * @throws IllegalStateException {@inheritDoc}    * @throws NullPointerException  {@inheritDoc}    */
specifier|public
name|void
name|addLast
parameter_list|(
name|E
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|offerLast
argument_list|(
name|e
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Deque full"
argument_list|)
throw|;
block|}
comment|/**    * @throws NullPointerException {@inheritDoc}    */
specifier|public
name|boolean
name|offerFirst
parameter_list|(
name|E
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|innerAdd
argument_list|(
name|e
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @throws NullPointerException {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|boolean
name|offerLast
parameter_list|(
name|E
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|innerAdd
argument_list|(
name|e
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @throws NullPointerException {@inheritDoc}    * @throws InterruptedException {@inheritDoc}    */
specifier|public
name|void
name|putFirst
parameter_list|(
name|E
name|e
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|e
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
while|while
condition|(
operator|!
name|innerAdd
argument_list|(
name|e
argument_list|)
condition|)
name|notFull
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @throws NullPointerException {@inheritDoc}    * @throws InterruptedException {@inheritDoc}    */
specifier|public
name|void
name|putLast
parameter_list|(
name|E
name|e
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|e
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
while|while
condition|(
operator|!
name|innerAdd
argument_list|(
name|e
argument_list|)
condition|)
name|notFull
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @throws NullPointerException {@inheritDoc}    * @throws InterruptedException {@inheritDoc}    */
specifier|public
name|boolean
name|offerFirst
parameter_list|(
name|E
name|e
parameter_list|,
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|e
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|long
name|nanos
init|=
name|unit
operator|.
name|toNanos
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
name|lock
operator|.
name|lockInterruptibly
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|innerAdd
argument_list|(
name|e
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|nanos
operator|<=
literal|0
condition|)
return|return
literal|false
return|;
name|nanos
operator|=
name|notFull
operator|.
name|awaitNanos
argument_list|(
name|nanos
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @throws NullPointerException {@inheritDoc}    * @throws InterruptedException {@inheritDoc}    */
specifier|public
name|boolean
name|offerLast
parameter_list|(
name|E
name|e
parameter_list|,
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|e
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|long
name|nanos
init|=
name|unit
operator|.
name|toNanos
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
name|lock
operator|.
name|lockInterruptibly
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|innerAdd
argument_list|(
name|e
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|nanos
operator|<=
literal|0
condition|)
return|return
literal|false
return|;
name|nanos
operator|=
name|notFull
operator|.
name|awaitNanos
argument_list|(
name|nanos
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @throws NoSuchElementException {@inheritDoc}    */
specifier|public
name|E
name|removeFirst
parameter_list|()
block|{
name|E
name|x
init|=
name|pollFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
return|return
name|x
return|;
block|}
comment|/**    * @throws NoSuchElementException {@inheritDoc}    */
specifier|public
name|E
name|removeLast
parameter_list|()
block|{
name|E
name|x
init|=
name|pollLast
argument_list|()
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
return|return
name|x
return|;
block|}
specifier|public
name|E
name|pollFirst
parameter_list|()
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|innerRemoveFirst
argument_list|()
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|E
name|pollLast
parameter_list|()
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|innerRemoveLast
argument_list|()
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|E
name|takeFirst
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|E
name|x
decl_stmt|;
while|while
condition|(
operator|(
name|x
operator|=
name|innerRemoveFirst
argument_list|()
operator|)
operator|==
literal|null
condition|)
name|notEmpty
operator|.
name|await
argument_list|()
expr_stmt|;
return|return
name|x
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|E
name|takeLast
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|E
name|x
decl_stmt|;
while|while
condition|(
operator|(
name|x
operator|=
name|innerRemoveLast
argument_list|()
operator|)
operator|==
literal|null
condition|)
name|notEmpty
operator|.
name|await
argument_list|()
expr_stmt|;
return|return
name|x
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|E
name|pollFirst
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|long
name|nanos
init|=
name|unit
operator|.
name|toNanos
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
name|lock
operator|.
name|lockInterruptibly
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|E
name|x
init|=
name|innerRemoveFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|x
operator|!=
literal|null
condition|)
return|return
name|x
return|;
if|if
condition|(
name|nanos
operator|<=
literal|0
condition|)
return|return
literal|null
return|;
name|nanos
operator|=
name|notEmpty
operator|.
name|awaitNanos
argument_list|(
name|nanos
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|E
name|pollLast
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|long
name|nanos
init|=
name|unit
operator|.
name|toNanos
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
name|lock
operator|.
name|lockInterruptibly
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|E
name|x
init|=
name|innerRemoveLast
argument_list|()
decl_stmt|;
if|if
condition|(
name|x
operator|!=
literal|null
condition|)
return|return
name|x
return|;
if|if
condition|(
name|nanos
operator|<=
literal|0
condition|)
return|return
literal|null
return|;
name|nanos
operator|=
name|notEmpty
operator|.
name|awaitNanos
argument_list|(
name|nanos
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @throws NoSuchElementException {@inheritDoc}    */
specifier|public
name|E
name|getFirst
parameter_list|()
block|{
name|E
name|x
init|=
name|peekFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
return|return
name|x
return|;
block|}
comment|/**    * @throws NoSuchElementException {@inheritDoc}    */
specifier|public
name|E
name|getLast
parameter_list|()
block|{
name|E
name|x
init|=
name|peekLast
argument_list|()
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
return|return
name|x
return|;
block|}
specifier|public
name|E
name|peekFirst
parameter_list|()
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|list
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|?
literal|null
else|:
name|list
operator|.
name|peekFirst
argument_list|()
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|E
name|peekLast
parameter_list|()
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|list
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|?
literal|null
else|:
name|list
operator|.
name|peekLast
argument_list|()
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|removeFirstOccurrence
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|Iterator
argument_list|<
name|E
argument_list|>
name|it
init|=
name|list
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|E
name|e
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|o
operator|.
name|equals
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|removeLastOccurrence
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|Iterator
argument_list|<
name|E
argument_list|>
name|it
init|=
name|list
operator|.
name|descendingIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|E
name|e
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|o
operator|.
name|equals
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|// BlockingQueue methods
comment|/**    * Inserts the specified element to the deque unless it would    * violate capacity restrictions.  When using a capacity-restricted deque,    * it is generally preferable to use method {@link #offer(Object) offer}.    *<p/>    *<p>This method is equivalent to {@link #addLast}.    *    * @throws IllegalStateException if the element cannot be added at this    *                               time due to capacity restrictions    * @throws NullPointerException  if the specified element is null    */
annotation|@
name|Override
specifier|public
name|boolean
name|add
parameter_list|(
name|E
name|e
parameter_list|)
block|{
name|addLast
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * @throws NullPointerException if the specified element is null    */
annotation|@
name|Override
specifier|public
name|boolean
name|offer
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|offerLast
argument_list|(
name|e
argument_list|)
return|;
block|}
comment|/**    * @throws NullPointerException {@inheritDoc}    * @throws InterruptedException {@inheritDoc}    */
specifier|public
name|void
name|put
parameter_list|(
name|E
name|e
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|putLast
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|/**    * @throws NullPointerException {@inheritDoc}    * @throws InterruptedException {@inheritDoc}    */
specifier|public
name|boolean
name|offer
parameter_list|(
name|E
name|e
parameter_list|,
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
return|return
name|offerLast
argument_list|(
name|e
argument_list|,
name|timeout
argument_list|,
name|unit
argument_list|)
return|;
block|}
comment|/**    * Retrieves and removes the head of the queue represented by this deque.    * This method differs from {@link #poll poll} only in that it throws an    * exception if this deque is empty.    *<p/>    *<p>This method is equivalent to {@link #removeFirst() removeFirst}.    *    * @return the head of the queue represented by this deque    * @throws NoSuchElementException if this deque is empty    */
annotation|@
name|Override
specifier|public
name|E
name|remove
parameter_list|()
block|{
return|return
name|removeFirst
argument_list|()
return|;
block|}
specifier|public
name|E
name|poll
parameter_list|()
block|{
return|return
name|pollFirst
argument_list|()
return|;
block|}
specifier|public
name|E
name|take
parameter_list|()
throws|throws
name|InterruptedException
block|{
return|return
name|takeFirst
argument_list|()
return|;
block|}
specifier|public
name|E
name|poll
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
return|return
name|pollFirst
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
return|;
block|}
comment|/**    * Retrieves, but does not remove, the head of the queue represented by    * this deque.  This method differs from {@link #peek peek} only in that    * it throws an exception if this deque is empty.    *<p/>    *<p>This method is equivalent to {@link #getFirst() getFirst}.    *    * @return the head of the queue represented by this deque    * @throws NoSuchElementException if this deque is empty    */
annotation|@
name|Override
specifier|public
name|E
name|element
parameter_list|()
block|{
return|return
name|getFirst
argument_list|()
return|;
block|}
specifier|public
name|E
name|peek
parameter_list|()
block|{
return|return
name|peekFirst
argument_list|()
return|;
block|}
comment|/**    * Returns the number of additional elements that this deque can ideally    * (in the absence of memory or resource constraints) accept without    * blocking. This is always equal to the initial capacity of this deque    * less the current<tt>size</tt> of this deque.    *<p/>    *<p>Note that you<em>cannot</em> always tell if an attempt to insert    * an element will succeed by inspecting<tt>remainingCapacity</tt>    * because it may be the case that another thread is about to    * insert or remove an element.    */
specifier|public
name|int
name|remainingCapacity
parameter_list|()
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|capacity
operator|-
name|list
operator|.
name|size
argument_list|()
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @throws UnsupportedOperationException {@inheritDoc}    * @throws ClassCastException            {@inheritDoc}    * @throws NullPointerException          {@inheritDoc}    * @throws IllegalArgumentException      {@inheritDoc}    */
specifier|public
name|int
name|drainTo
parameter_list|(
name|Collection
argument_list|<
name|?
super|super
name|E
argument_list|>
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
if|if
condition|(
name|c
operator|==
name|this
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|E
name|e
range|:
name|list
control|)
block|{
name|c
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|int
name|n
init|=
name|list
operator|.
name|size
argument_list|()
decl_stmt|;
name|list
operator|.
name|clear
argument_list|()
expr_stmt|;
name|notFull
operator|.
name|signalAll
argument_list|()
expr_stmt|;
return|return
name|n
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @throws UnsupportedOperationException {@inheritDoc}    * @throws ClassCastException            {@inheritDoc}    * @throws NullPointerException          {@inheritDoc}    * @throws IllegalArgumentException      {@inheritDoc}    */
specifier|public
name|int
name|drainTo
parameter_list|(
name|Collection
argument_list|<
name|?
super|super
name|E
argument_list|>
name|c
parameter_list|,
name|int
name|maxElements
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
if|if
condition|(
name|c
operator|==
name|this
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|E
argument_list|>
name|it
init|=
name|list
operator|.
name|iterator
argument_list|()
init|;
name|n
operator|<
name|maxElements
operator|&&
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|E
name|e
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|c
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
name|notFull
operator|.
name|signalAll
argument_list|()
expr_stmt|;
return|return
name|n
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Stack methods
comment|/**    * @throws IllegalStateException {@inheritDoc}    * @throws NullPointerException  {@inheritDoc}    */
specifier|public
name|void
name|push
parameter_list|(
name|E
name|e
parameter_list|)
block|{
name|addFirst
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|/**    * @throws NoSuchElementException {@inheritDoc}    */
specifier|public
name|E
name|pop
parameter_list|()
block|{
return|return
name|removeFirst
argument_list|()
return|;
block|}
comment|// Collection methods
comment|/**    * Removes the first occurrence of the specified element from this deque.    * If the deque does not contain the element, it is unchanged.    * More formally, removes the first element<tt>e</tt> such that    *<tt>o.equals(e)</tt> (if such an element exists).    * Returns<tt>true</tt> if this deque contained the specified element    * (or equivalently, if this deque changed as a result of the call).    *<p/>    *<p>This method is equivalent to    * {@link #removeFirstOccurrence(Object) removeFirstOccurrence}.    *    * @param o element to be removed from this deque, if present    * @return<tt>true</tt> if this deque changed as a result of the call    */
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|removeFirstOccurrence
argument_list|(
name|o
argument_list|)
return|;
block|}
comment|/**    * Returns the number of elements in this deque.    *    * @return the number of elements in this deque    */
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|list
operator|.
name|size
argument_list|()
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns<tt>true</tt> if this deque contains the specified element.    * More formally, returns<tt>true</tt> if and only if this deque contains    * at least one element<tt>e</tt> such that<tt>o.equals(e)</tt>.    *    * @param o object to be checked for containment in this deque    * @return<tt>true</tt> if this deque contains the specified element    */
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|list
operator|.
name|contains
argument_list|(
name|o
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns an array containing all of the elements in this deque, in    * proper sequence (from first to last element).    *<p/>    *<p>The returned array will be "safe" in that no references to it are    * maintained by this deque.  (In other words, this method must allocate    * a new array).  The caller is thus free to modify the returned array.    *<p/>    *<p>This method acts as bridge between array-based and collection-based    * APIs.    *    * @return an array containing all of the elements in this deque    */
annotation|@
name|Override
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|list
operator|.
name|toArray
argument_list|()
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns an array containing all of the elements in this deque, in    * proper sequence; the runtime type of the returned array is that of    * the specified array.  If the deque fits in the specified array, it    * is returned therein.  Otherwise, a new array is allocated with the    * runtime type of the specified array and the size of this deque.    *<p/>    *<p>If this deque fits in the specified array with room to spare    * (i.e., the array has more elements than this deque), the element in    * the array immediately following the end of the deque is set to    *<tt>null</tt>.    *<p/>    *<p>Like the {@link #toArray()} method, this method acts as bridge between    * array-based and collection-based APIs.  Further, this method allows    * precise control over the runtime type of the output array, and may,    * under certain circumstances, be used to save allocation costs.    *<p/>    *<p>Suppose<tt>x</tt> is a deque known to contain only strings.    * The following code can be used to dump the deque into a newly    * allocated array of<tt>String</tt>:    *<p/>    *<pre>    *     String[] y = x.toArray(new String[0]);</pre>    *<p/>    * Note that<tt>toArray(new Object[0])</tt> is identical in function to    *<tt>toArray()</tt>.    *    * @param a the array into which the elements of the deque are to    *          be stored, if it is big enough; otherwise, a new array of the    *          same runtime type is allocated for this purpose    * @return an array containing all of the elements in this deque    * @throws ArrayStoreException  if the runtime type of the specified array    *                              is not a supertype of the runtime type of every element in    *                              this deque    * @throws NullPointerException if the specified array is null    */
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|a
parameter_list|)
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|list
operator|.
name|toArray
argument_list|(
name|a
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Atomically removes all of the elements from this deque.    * The deque will be empty after this call returns.    */
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|list
operator|.
name|clear
argument_list|()
expr_stmt|;
name|notFull
operator|.
name|signalAll
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|list
operator|.
name|iterator
argument_list|()
return|;
block|}
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|descendingIterator
parameter_list|()
block|{
return|return
name|list
operator|.
name|descendingIterator
argument_list|()
return|;
block|}
block|}
end_class

end_unit

