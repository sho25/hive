begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|cli
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DecimalFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|cli
operator|.
name|LlapStatusOptionsProcessor
operator|.
name|LlapStatusOptions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|cli
operator|.
name|status
operator|.
name|LlapStatusHelpers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|cli
operator|.
name|status
operator|.
name|LlapStatusHelpers
operator|.
name|AppStatusBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|cli
operator|.
name|status
operator|.
name|LlapStatusHelpers
operator|.
name|LlapInstance
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|cli
operator|.
name|status
operator|.
name|LlapStatusHelpers
operator|.
name|State
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|configuration
operator|.
name|LlapDaemonConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|registry
operator|.
name|LlapServiceInstance
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|registry
operator|.
name|impl
operator|.
name|LlapRegistryService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerExitStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|service
operator|.
name|api
operator|.
name|records
operator|.
name|Container
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|service
operator|.
name|api
operator|.
name|records
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|service
operator|.
name|api
operator|.
name|records
operator|.
name|ServiceState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|service
operator|.
name|client
operator|.
name|ServiceClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|Clock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|SystemClock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|map
operator|.
name|ObjectMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|map
operator|.
name|SerializationConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|map
operator|.
name|annotate
operator|.
name|JsonSerialize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
specifier|public
class|class
name|LlapStatusServiceDriver
block|{
specifier|private
specifier|static
specifier|final
name|EnumSet
argument_list|<
name|State
argument_list|>
name|NO_YARN_SERVICE_INFO_STATES
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|State
operator|.
name|APP_NOT_FOUND
argument_list|,
name|State
operator|.
name|COMPLETE
argument_list|,
name|State
operator|.
name|LAUNCHING
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|EnumSet
argument_list|<
name|State
argument_list|>
name|LAUNCHING_STATES
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|State
operator|.
name|LAUNCHING
argument_list|,
name|State
operator|.
name|RUNNING_PARTIAL
argument_list|,
name|State
operator|.
name|RUNNING_ALL
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|LlapStatusServiceDriver
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Logger
name|CONSOLE_LOGGER
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
literal|"LlapStatusServiceDriverConsole"
argument_list|)
decl_stmt|;
comment|// Defining a bunch of configs here instead of in HiveConf. These are experimental, and mainly
comment|// for use when retry handling is fixed in Yarn/Hadoop
specifier|private
specifier|static
specifier|final
name|String
name|CONF_PREFIX
init|=
literal|"hive.llapcli."
decl_stmt|;
comment|// The following two keys should ideally be used to control RM connect timeouts. However,
comment|// they don't seem to work. The IPC timeout needs to be set instead.
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|private
specifier|static
specifier|final
name|String
name|CONFIG_YARN_RM_TIMEOUT_MAX_WAIT_MS
init|=
name|CONF_PREFIX
operator|+
literal|"yarn.rm.connect.max-wait-ms"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|CONFIG_YARN_RM_TIMEOUT_MAX_WAIT_MS_DEFAULT
init|=
literal|10000l
decl_stmt|;
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|private
specifier|static
specifier|final
name|String
name|CONFIG_YARN_RM_RETRY_INTERVAL_MS
init|=
name|CONF_PREFIX
operator|+
literal|"yarn.rm.connect.retry-interval.ms"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|CONFIG_YARN_RM_RETRY_INTERVAL_MS_DEFAULT
init|=
literal|5000l
decl_stmt|;
comment|// As of Hadoop 2.7 - this is what controls the RM timeout.
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|private
specifier|static
specifier|final
name|String
name|CONFIG_IPC_CLIENT_CONNECT_MAX_RETRIES
init|=
name|CONF_PREFIX
operator|+
literal|"ipc.client.max-retries"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|CONFIG_IPC_CLIENT_CONNECT_MAX_RETRIES_DEFAULT
init|=
literal|2
decl_stmt|;
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|private
specifier|static
specifier|final
name|String
name|CONFIG_IPC_CLIENT_CONNECT_RETRY_INTERVAL_MS
init|=
name|CONF_PREFIX
operator|+
literal|"ipc.client.connect.retry-interval-ms"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|CONFIG_IPC_CLIENT_CONNECT_RETRY_INTERVAL_MS_DEFAULT
init|=
literal|1500l
decl_stmt|;
comment|// As of Hadoop 2.8 - this timeout spec behaves in a strnage manner. "2000,1" means 2000s with 1 retry.
comment|// However it does this - but does it thrice. Essentially - #retries+2 is the number of times the entire config
comment|// is retried. "2000,1" means 3 retries - each with 1 retry with a random 2000ms sleep.
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|private
specifier|static
specifier|final
name|String
name|CONFIG_TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETRY_POLICY_SPEC
init|=
name|CONF_PREFIX
operator|+
literal|"timeline.service.fs-store.retry.policy.spec"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|CONFIG_TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETRY_POLICY_SPEC_DEFAULT
init|=
literal|"2000, 1"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|CONFIG_LLAP_ZK_REGISTRY_TIMEOUT_MS
init|=
name|CONF_PREFIX
operator|+
literal|"zk-registry.timeout-ms"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|CONFIG_LLAP_ZK_REGISTRY_TIMEOUT_MS_DEFAULT
init|=
literal|20000l
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|LOG_SUMMARY_INTERVAL
init|=
literal|15000L
decl_stmt|;
comment|// Log summary every ~15 seconds.
specifier|private
specifier|static
specifier|final
name|String
name|LLAP_KEY
init|=
literal|"llap"
decl_stmt|;
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
specifier|private
specifier|final
name|Clock
name|clock
init|=
operator|new
name|SystemClock
argument_list|()
decl_stmt|;
specifier|private
name|String
name|appName
init|=
literal|null
decl_stmt|;
specifier|private
name|ServiceClient
name|serviceClient
init|=
literal|null
decl_stmt|;
specifier|private
name|Configuration
name|llapRegistryConf
init|=
literal|null
decl_stmt|;
specifier|private
name|LlapRegistryService
name|llapRegistry
init|=
literal|null
decl_stmt|;
annotation|@
name|VisibleForTesting
name|AppStatusBuilder
name|appStatusBuilder
decl_stmt|;
specifier|public
name|LlapStatusServiceDriver
parameter_list|()
block|{
name|SessionState
name|ss
init|=
name|SessionState
operator|.
name|get
argument_list|()
decl_stmt|;
name|conf
operator|=
operator|(
name|ss
operator|!=
literal|null
operator|)
condition|?
name|ss
operator|.
name|getConf
argument_list|()
else|:
operator|new
name|HiveConf
argument_list|(
name|SessionState
operator|.
name|class
argument_list|)
expr_stmt|;
name|setupConf
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|setupConf
parameter_list|()
block|{
for|for
control|(
name|String
name|f
range|:
name|LlapDaemonConfiguration
operator|.
name|DAEMON_CONFIGS
control|)
block|{
name|conf
operator|.
name|addResource
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|conf
operator|.
name|reloadConfiguration
argument_list|()
expr_stmt|;
comment|// Setup timeouts for various services.
comment|// Once we move to a Hadoop-2.8 dependency, the following paramteer can be used.
comment|// conf.set(YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETRY_POLICY_SPEC);
name|conf
operator|.
name|set
argument_list|(
literal|"yarn.timeline-service.entity-group-fs-store.retry-policy-spec"
argument_list|,
name|conf
operator|.
name|get
argument_list|(
name|CONFIG_TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETRY_POLICY_SPEC
argument_list|,
name|CONFIG_TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETRY_POLICY_SPEC_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setLong
argument_list|(
name|YarnConfiguration
operator|.
name|RESOURCEMANAGER_CONNECT_MAX_WAIT_MS
argument_list|,
name|conf
operator|.
name|getLong
argument_list|(
name|CONFIG_YARN_RM_TIMEOUT_MAX_WAIT_MS
argument_list|,
name|CONFIG_YARN_RM_TIMEOUT_MAX_WAIT_MS_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setLong
argument_list|(
name|YarnConfiguration
operator|.
name|RESOURCEMANAGER_CONNECT_RETRY_INTERVAL_MS
argument_list|,
name|conf
operator|.
name|getLong
argument_list|(
name|CONFIG_YARN_RM_RETRY_INTERVAL_MS
argument_list|,
name|CONFIG_YARN_RM_RETRY_INTERVAL_MS_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|IPC_CLIENT_CONNECT_MAX_RETRIES_KEY
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|CONFIG_IPC_CLIENT_CONNECT_MAX_RETRIES
argument_list|,
name|CONFIG_IPC_CLIENT_CONNECT_MAX_RETRIES_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setLong
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|IPC_CLIENT_CONNECT_RETRY_INTERVAL_KEY
argument_list|,
name|conf
operator|.
name|getLong
argument_list|(
name|CONFIG_IPC_CLIENT_CONNECT_RETRY_INTERVAL_MS
argument_list|,
name|CONFIG_IPC_CLIENT_CONNECT_RETRY_INTERVAL_MS_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|HiveConf
operator|.
name|setVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_ZOOKEEPER_SESSION_TIMEOUT
argument_list|,
operator|(
name|conf
operator|.
name|getLong
argument_list|(
name|CONFIG_LLAP_ZK_REGISTRY_TIMEOUT_MS
argument_list|,
name|CONFIG_LLAP_ZK_REGISTRY_TIMEOUT_MS_DEFAULT
argument_list|)
operator|+
literal|"ms"
operator|)
argument_list|)
expr_stmt|;
name|llapRegistryConf
operator|=
operator|new
name|Configuration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Parse command line options.    *    * @param args    * @return command line options.    */
specifier|public
name|LlapStatusOptions
name|parseOptions
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|LlapStatusCliException
block|{
name|LlapStatusOptionsProcessor
name|optionsProcessor
init|=
operator|new
name|LlapStatusOptionsProcessor
argument_list|()
decl_stmt|;
name|LlapStatusOptions
name|options
decl_stmt|;
try|try
block|{
name|options
operator|=
name|optionsProcessor
operator|.
name|processOptions
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|options
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to parse arguments"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|LlapStatusCliException
argument_list|(
name|ExitCode
operator|.
name|INCORRECT_USAGE
argument_list|,
literal|"Incorrect usage"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|int
name|run
parameter_list|(
name|LlapStatusOptions
name|options
parameter_list|,
name|long
name|watchTimeoutMs
parameter_list|)
block|{
name|appStatusBuilder
operator|=
operator|new
name|AppStatusBuilder
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|appName
operator|==
literal|null
condition|)
block|{
comment|// user provided configs
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|props
range|:
name|options
operator|.
name|getConf
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|conf
operator|.
name|set
argument_list|(
operator|(
name|String
operator|)
name|props
operator|.
name|getKey
argument_list|()
argument_list|,
operator|(
name|String
operator|)
name|props
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|appName
operator|=
name|options
operator|.
name|getName
argument_list|()
expr_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|appName
argument_list|)
condition|)
block|{
name|appName
operator|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|LLAP_DAEMON_SERVICE_HOSTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|appName
operator|.
name|startsWith
argument_list|(
literal|"@"
argument_list|)
operator|&&
name|appName
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// This is a valid YARN Service name. Parse it out.
name|appName
operator|=
name|appName
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Invalid app name. Checked later.
name|appName
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|appName
argument_list|)
condition|)
block|{
name|String
name|message
init|=
literal|"Invalid app name. This must be setup via config or passed in as a parameter."
operator|+
literal|" This tool works with clusters deployed by YARN Service"
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|message
argument_list|)
expr_stmt|;
return|return
name|ExitCode
operator|.
name|INCORRECT_USAGE
operator|.
name|getInt
argument_list|()
return|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using appName: {}"
argument_list|,
name|appName
argument_list|)
expr_stmt|;
block|}
name|llapRegistryConf
operator|.
name|set
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|LLAP_DAEMON_SERVICE_HOSTS
operator|.
name|varname
argument_list|,
literal|"@"
operator|+
name|appName
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|serviceClient
operator|==
literal|null
condition|)
block|{
name|serviceClient
operator|=
name|LlapSliderUtils
operator|.
name|createServiceClient
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LlapStatusCliException
name|le
init|=
operator|new
name|LlapStatusCliException
argument_list|(
name|LlapStatusServiceDriver
operator|.
name|ExitCode
operator|.
name|SERVICE_CLIENT_ERROR_CREATE_FAILED
argument_list|,
literal|"Failed to create service client"
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|logError
argument_list|(
name|le
argument_list|)
expr_stmt|;
return|return
name|le
operator|.
name|getExitCode
argument_list|()
operator|.
name|getInt
argument_list|()
return|;
block|}
comment|// Get the App report from YARN
name|ApplicationReport
name|appReport
decl_stmt|;
try|try
block|{
name|appReport
operator|=
name|LlapSliderUtils
operator|.
name|getAppReport
argument_list|(
name|appName
argument_list|,
name|serviceClient
argument_list|,
name|options
operator|.
name|getFindAppTimeoutMs
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LlapStatusCliException
name|e
parameter_list|)
block|{
name|logError
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|e
operator|.
name|getExitCode
argument_list|()
operator|.
name|getInt
argument_list|()
return|;
block|}
comment|// Process the report
name|ExitCode
name|ret
decl_stmt|;
try|try
block|{
name|ret
operator|=
name|processAppReport
argument_list|(
name|appReport
argument_list|,
name|appStatusBuilder
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LlapStatusCliException
name|e
parameter_list|)
block|{
name|logError
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|e
operator|.
name|getExitCode
argument_list|()
operator|.
name|getInt
argument_list|()
return|;
block|}
if|if
condition|(
name|ret
operator|!=
name|ExitCode
operator|.
name|SUCCESS
condition|)
block|{
return|return
name|ret
operator|.
name|getInt
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|NO_YARN_SERVICE_INFO_STATES
operator|.
name|contains
argument_list|(
name|appStatusBuilder
operator|.
name|getState
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|ExitCode
operator|.
name|SUCCESS
operator|.
name|getInt
argument_list|()
return|;
block|}
else|else
block|{
comment|// Get information from YARN Service
try|try
block|{
name|ret
operator|=
name|populateAppStatusFromServiceStatus
argument_list|(
name|appName
argument_list|,
name|serviceClient
argument_list|,
name|appStatusBuilder
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LlapStatusCliException
name|e
parameter_list|)
block|{
comment|// In case of failure, send back whatever is constructed so far -
comment|// which would be from the AppReport
name|logError
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|e
operator|.
name|getExitCode
argument_list|()
operator|.
name|getInt
argument_list|()
return|;
block|}
block|}
if|if
condition|(
name|ret
operator|!=
name|ExitCode
operator|.
name|SUCCESS
condition|)
block|{
return|return
name|ret
operator|.
name|getInt
argument_list|()
return|;
block|}
else|else
block|{
try|try
block|{
name|ret
operator|=
name|populateAppStatusFromLlapRegistry
argument_list|(
name|appStatusBuilder
argument_list|,
name|watchTimeoutMs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LlapStatusCliException
name|e
parameter_list|)
block|{
name|logError
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|e
operator|.
name|getExitCode
argument_list|()
operator|.
name|getInt
argument_list|()
return|;
block|}
block|}
return|return
name|ret
operator|.
name|getInt
argument_list|()
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Final AppState: "
operator|+
name|appStatusBuilder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|outputJson
parameter_list|(
name|PrintWriter
name|writer
parameter_list|)
throws|throws
name|LlapStatusCliException
block|{
name|ObjectMapper
name|mapper
init|=
operator|new
name|ObjectMapper
argument_list|()
decl_stmt|;
name|mapper
operator|.
name|configure
argument_list|(
name|SerializationConfig
operator|.
name|Feature
operator|.
name|FAIL_ON_EMPTY_BEANS
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|mapper
operator|.
name|setSerializationInclusion
argument_list|(
name|JsonSerialize
operator|.
name|Inclusion
operator|.
name|NON_NULL
argument_list|)
expr_stmt|;
name|mapper
operator|.
name|setSerializationInclusion
argument_list|(
name|JsonSerialize
operator|.
name|Inclusion
operator|.
name|NON_EMPTY
argument_list|)
expr_stmt|;
try|try
block|{
name|writer
operator|.
name|println
argument_list|(
name|mapper
operator|.
name|writerWithDefaultPrettyPrinter
argument_list|()
operator|.
name|writeValueAsString
argument_list|(
name|appStatusBuilder
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to create JSON"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|LlapStatusCliException
argument_list|(
name|ExitCode
operator|.
name|LLAP_JSON_GENERATION_ERROR
argument_list|,
literal|"Failed to create JSON"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Populates parts of the AppStatus    *    * @param appReport    * @param appStatusBuilder    * @return an ExitCode. An ExitCode other than ExitCode.SUCCESS implies future progress not possible    * @throws LlapStatusCliException    */
specifier|private
name|ExitCode
name|processAppReport
parameter_list|(
name|ApplicationReport
name|appReport
parameter_list|,
name|AppStatusBuilder
name|appStatusBuilder
parameter_list|)
throws|throws
name|LlapStatusCliException
block|{
if|if
condition|(
name|appReport
operator|==
literal|null
condition|)
block|{
name|appStatusBuilder
operator|.
name|setState
argument_list|(
name|State
operator|.
name|APP_NOT_FOUND
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"No Application Found"
argument_list|)
expr_stmt|;
return|return
name|ExitCode
operator|.
name|SUCCESS
return|;
block|}
comment|// TODO Maybe add the YARN URL for the app.
name|appStatusBuilder
operator|.
name|setAmInfo
argument_list|(
operator|new
name|LlapStatusHelpers
operator|.
name|AmInfo
argument_list|()
operator|.
name|setAppName
argument_list|(
name|appReport
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|setAppType
argument_list|(
name|appReport
operator|.
name|getApplicationType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|appStatusBuilder
operator|.
name|setAppStartTime
argument_list|(
name|appReport
operator|.
name|getStartTime
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|appReport
operator|.
name|getYarnApplicationState
argument_list|()
condition|)
block|{
case|case
name|NEW
case|:
case|case
name|NEW_SAVING
case|:
case|case
name|SUBMITTED
case|:
name|appStatusBuilder
operator|.
name|setState
argument_list|(
name|State
operator|.
name|LAUNCHING
argument_list|)
expr_stmt|;
return|return
name|ExitCode
operator|.
name|SUCCESS
return|;
case|case
name|ACCEPTED
case|:
name|appStatusBuilder
operator|.
name|maybeCreateAndGetAmInfo
argument_list|()
operator|.
name|setAppId
argument_list|(
name|appReport
operator|.
name|getApplicationId
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|appStatusBuilder
operator|.
name|setState
argument_list|(
name|State
operator|.
name|LAUNCHING
argument_list|)
expr_stmt|;
return|return
name|ExitCode
operator|.
name|SUCCESS
return|;
case|case
name|RUNNING
case|:
name|appStatusBuilder
operator|.
name|maybeCreateAndGetAmInfo
argument_list|()
operator|.
name|setAppId
argument_list|(
name|appReport
operator|.
name|getApplicationId
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// If the app state is running, get additional information from YARN Service
return|return
name|ExitCode
operator|.
name|SUCCESS
return|;
case|case
name|FINISHED
case|:
case|case
name|FAILED
case|:
case|case
name|KILLED
case|:
name|appStatusBuilder
operator|.
name|maybeCreateAndGetAmInfo
argument_list|()
operator|.
name|setAppId
argument_list|(
name|appReport
operator|.
name|getApplicationId
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|appStatusBuilder
operator|.
name|setAppFinishTime
argument_list|(
name|appReport
operator|.
name|getFinishTime
argument_list|()
argument_list|)
expr_stmt|;
name|appStatusBuilder
operator|.
name|setState
argument_list|(
name|State
operator|.
name|COMPLETE
argument_list|)
expr_stmt|;
comment|// add log links and other diagnostics from YARN Service
return|return
name|ExitCode
operator|.
name|SUCCESS
return|;
default|default:
throw|throw
operator|new
name|LlapStatusCliException
argument_list|(
name|ExitCode
operator|.
name|INTERNAL_ERROR
argument_list|,
literal|"Unknown Yarn Application State: "
operator|+
name|appReport
operator|.
name|getYarnApplicationState
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Populates information from YARN Service Status.    *    * @param appName    * @param serviceClient    * @param appStatusBuilder    * @return an ExitCode. An ExitCode other than ExitCode.SUCCESS implies future    *         progress not possible    * @throws LlapStatusCliException    */
specifier|private
name|ExitCode
name|populateAppStatusFromServiceStatus
parameter_list|(
name|String
name|appName
parameter_list|,
name|ServiceClient
name|serviceClient
parameter_list|,
name|AppStatusBuilder
name|appStatusBuilder
parameter_list|)
throws|throws
name|LlapStatusCliException
block|{
name|ExitCode
name|exitCode
init|=
name|ExitCode
operator|.
name|YARN_ERROR
decl_stmt|;
try|try
block|{
name|Service
name|service
init|=
name|serviceClient
operator|.
name|getStatus
argument_list|(
name|appName
argument_list|)
decl_stmt|;
if|if
condition|(
name|service
operator|!=
literal|null
condition|)
block|{
comment|// How to get config paths and AmInfo
name|ServiceState
name|state
init|=
name|service
operator|.
name|getState
argument_list|()
decl_stmt|;
name|appStatusBuilder
operator|.
name|setAppStartTime
argument_list|(
name|service
operator|.
name|getLaunchTime
argument_list|()
operator|==
literal|null
condition|?
literal|0
else|:
name|service
operator|.
name|getLaunchTime
argument_list|()
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
name|appStatusBuilder
operator|.
name|setDesiredInstances
argument_list|(
name|service
operator|.
name|getComponent
argument_list|(
name|LLAP_KEY
argument_list|)
operator|.
name|getNumberOfContainers
argument_list|()
operator|==
literal|null
condition|?
literal|0
else|:
name|service
operator|.
name|getComponent
argument_list|(
name|LLAP_KEY
argument_list|)
operator|.
name|getNumberOfContainers
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|appStatusBuilder
operator|.
name|setLiveInstances
argument_list|(
name|service
operator|.
name|getComponent
argument_list|(
name|LLAP_KEY
argument_list|)
operator|.
name|getContainers
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Container
name|cont
range|:
name|service
operator|.
name|getComponent
argument_list|(
name|LLAP_KEY
argument_list|)
operator|.
name|getContainers
argument_list|()
control|)
block|{
name|LlapInstance
name|llapInstance
init|=
operator|new
name|LlapInstance
argument_list|(
name|cont
operator|.
name|getHostname
argument_list|()
argument_list|,
name|cont
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|appStatusBuilder
operator|.
name|addNewRunningLlapInstance
argument_list|(
name|llapInstance
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|==
name|ServiceState
operator|.
name|STABLE
condition|)
block|{
name|exitCode
operator|=
name|ExitCode
operator|.
name|SUCCESS
expr_stmt|;
block|}
block|}
else|else
block|{
name|exitCode
operator|=
name|ExitCode
operator|.
name|SERVICE_CLIENT_ERROR_OTHER
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|YarnException
name|e
parameter_list|)
block|{
name|LlapStatusCliException
name|le
init|=
operator|new
name|LlapStatusCliException
argument_list|(
name|LlapStatusServiceDriver
operator|.
name|ExitCode
operator|.
name|SERVICE_CLIENT_ERROR_OTHER
argument_list|,
literal|"Failed to get service status"
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|logError
argument_list|(
name|le
argument_list|)
expr_stmt|;
name|exitCode
operator|=
name|le
operator|.
name|getExitCode
argument_list|()
expr_stmt|;
block|}
return|return
name|exitCode
return|;
block|}
comment|/**    * Populate additional information for containers from the LLAP registry. Must be invoked    * after YARN Service status and diagnostics.    * @param appStatusBuilder    * @return an ExitCode. An ExitCode other than ExitCode.SUCCESS implies future progress not possible    * @throws LlapStatusCliException    */
specifier|private
name|ExitCode
name|populateAppStatusFromLlapRegistry
parameter_list|(
name|AppStatusBuilder
name|appStatusBuilder
parameter_list|,
name|long
name|watchTimeoutMs
parameter_list|)
throws|throws
name|LlapStatusCliException
block|{
if|if
condition|(
name|llapRegistry
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|llapRegistry
operator|=
name|LlapRegistryService
operator|.
name|getClient
argument_list|(
name|llapRegistryConf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|LlapStatusCliException
argument_list|(
name|ExitCode
operator|.
name|LLAP_REGISTRY_ERROR
argument_list|,
literal|"Failed to create llap registry client"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|Collection
argument_list|<
name|LlapServiceInstance
argument_list|>
name|serviceInstances
decl_stmt|;
try|try
block|{
name|serviceInstances
operator|=
name|llapRegistry
operator|.
name|getInstances
argument_list|(
name|watchTimeoutMs
argument_list|)
operator|.
name|getAll
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|LlapStatusCliException
argument_list|(
name|ExitCode
operator|.
name|LLAP_REGISTRY_ERROR
argument_list|,
literal|"Failed to get instances from llap registry"
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|serviceInstances
operator|==
literal|null
operator|||
name|serviceInstances
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No information found in the LLAP registry"
argument_list|)
expr_stmt|;
block|}
name|appStatusBuilder
operator|.
name|setLiveInstances
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|appStatusBuilder
operator|.
name|setState
argument_list|(
name|State
operator|.
name|LAUNCHING
argument_list|)
expr_stmt|;
name|appStatusBuilder
operator|.
name|clearRunningLlapInstances
argument_list|()
expr_stmt|;
return|return
name|ExitCode
operator|.
name|SUCCESS
return|;
block|}
else|else
block|{
comment|// Tracks instances known by both YARN Service and llap.
name|List
argument_list|<
name|LlapInstance
argument_list|>
name|validatedInstances
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|llapExtraInstances
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|LlapServiceInstance
name|serviceInstance
range|:
name|serviceInstances
control|)
block|{
name|String
name|containerIdString
init|=
name|serviceInstance
operator|.
name|getProperties
argument_list|()
operator|.
name|get
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|LLAP_DAEMON_CONTAINER_ID
operator|.
name|varname
argument_list|)
decl_stmt|;
name|LlapInstance
name|llapInstance
init|=
name|appStatusBuilder
operator|.
name|removeAndGetRunningLlapInstanceForContainer
argument_list|(
name|containerIdString
argument_list|)
decl_stmt|;
if|if
condition|(
name|llapInstance
operator|!=
literal|null
condition|)
block|{
name|llapInstance
operator|.
name|setMgmtPort
argument_list|(
name|serviceInstance
operator|.
name|getManagementPort
argument_list|()
argument_list|)
expr_stmt|;
name|llapInstance
operator|.
name|setRpcPort
argument_list|(
name|serviceInstance
operator|.
name|getRpcPort
argument_list|()
argument_list|)
expr_stmt|;
name|llapInstance
operator|.
name|setShufflePort
argument_list|(
name|serviceInstance
operator|.
name|getShufflePort
argument_list|()
argument_list|)
expr_stmt|;
name|llapInstance
operator|.
name|setWebUrl
argument_list|(
name|serviceInstance
operator|.
name|getServicesAddress
argument_list|()
argument_list|)
expr_stmt|;
name|llapInstance
operator|.
name|setStatusUrl
argument_list|(
name|serviceInstance
operator|.
name|getServicesAddress
argument_list|()
operator|+
literal|"/status"
argument_list|)
expr_stmt|;
name|validatedInstances
operator|.
name|add
argument_list|(
name|llapInstance
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// This likely indicates that an instance has recently restarted
comment|// (the old instance has not been unregistered), and the new instances has not registered yet.
name|llapExtraInstances
operator|.
name|add
argument_list|(
name|containerIdString
argument_list|)
expr_stmt|;
comment|// This instance will not be added back, since it's services are not up yet.
block|}
block|}
name|appStatusBuilder
operator|.
name|setLiveInstances
argument_list|(
name|validatedInstances
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|appStatusBuilder
operator|.
name|setLaunchingInstances
argument_list|(
name|llapExtraInstances
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|appStatusBuilder
operator|.
name|getDesiredInstances
argument_list|()
operator|!=
literal|null
operator|&&
name|validatedInstances
operator|.
name|size
argument_list|()
operator|>=
name|appStatusBuilder
operator|.
name|getDesiredInstances
argument_list|()
condition|)
block|{
name|appStatusBuilder
operator|.
name|setState
argument_list|(
name|State
operator|.
name|RUNNING_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|validatedInstances
operator|.
name|size
argument_list|()
operator|>
name|appStatusBuilder
operator|.
name|getDesiredInstances
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Found more entries in LLAP registry, as compared to desired entries"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|validatedInstances
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|appStatusBuilder
operator|.
name|setState
argument_list|(
name|State
operator|.
name|RUNNING_PARTIAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|appStatusBuilder
operator|.
name|setState
argument_list|(
name|State
operator|.
name|LAUNCHING
argument_list|)
expr_stmt|;
block|}
block|}
comment|// At this point, everything that can be consumed from AppStatusBuilder has been consumed.
comment|// Debug only
if|if
condition|(
name|appStatusBuilder
operator|.
name|allRunningInstances
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Containers likely to come up soon.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Potential instances starting up: {}"
argument_list|,
name|appStatusBuilder
operator|.
name|allRunningInstances
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|llapExtraInstances
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Old containers which are likely shutting down, or new containers which
comment|// launched between YARN Service status/diagnostics. Skip for this iteration.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Instances likely to shutdown soon: {}"
argument_list|,
name|llapExtraInstances
argument_list|)
expr_stmt|;
block|}
name|appStatusBuilder
operator|.
name|clearAndAddPreviouslyKnownRunningInstances
argument_list|(
name|validatedInstances
argument_list|)
expr_stmt|;
block|}
return|return
name|ExitCode
operator|.
name|SUCCESS
return|;
block|}
specifier|private
specifier|static
name|String
name|constructCompletedContainerDiagnostics
parameter_list|(
name|List
argument_list|<
name|LlapInstance
argument_list|>
name|completedInstances
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|completedInstances
operator|==
literal|null
operator|||
name|completedInstances
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|""
return|;
block|}
else|else
block|{
comment|// TODO HIVE-15865 Ideally sort these by completion time, once that is available.
name|boolean
name|isFirst
init|=
literal|true
decl_stmt|;
for|for
control|(
name|LlapInstance
name|instance
range|:
name|completedInstances
control|)
block|{
if|if
condition|(
operator|!
name|isFirst
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isFirst
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|instance
operator|.
name|getYarnContainerExitStatus
argument_list|()
operator|==
name|ContainerExitStatus
operator|.
name|KILLED_EXCEEDED_PMEM
operator|||
name|instance
operator|.
name|getYarnContainerExitStatus
argument_list|()
operator|==
name|ContainerExitStatus
operator|.
name|KILLED_EXCEEDED_VMEM
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\tKILLED container (by YARN for exceeding memory limits): "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// TODO HIVE-15865 Handle additional reasons like OS launch failed
name|sb
operator|.
name|append
argument_list|(
literal|"\tFAILED container: "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
name|instance
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", Logs at: "
argument_list|)
operator|.
name|append
argument_list|(
name|instance
operator|.
name|getLogUrl
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Helper method to construct a diagnostic message from a complete    * AppStatusBuilder.    *    * @return    */
specifier|private
specifier|static
name|String
name|constructDiagnostics
parameter_list|(
name|AppStatusBuilder
name|appStatusBuilder
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|appStatusBuilder
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|APP_NOT_FOUND
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"LLAP status unknown. Awaiting app launch"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LAUNCHING
case|:
comment|// This is a catch all state - when containers have not started yet, or LLAP has not started yet.
if|if
condition|(
name|StringUtils
operator|.
name|isNotBlank
argument_list|(
name|appStatusBuilder
operator|.
name|getAmInfo
argument_list|()
operator|.
name|getAppId
argument_list|()
argument_list|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"LLAP Starting up with AppId="
argument_list|)
operator|.
name|append
argument_list|(
name|appStatusBuilder
operator|.
name|getAmInfo
argument_list|()
operator|.
name|getAppId
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|appStatusBuilder
operator|.
name|getDesiredInstances
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" Started 0/"
argument_list|)
operator|.
name|append
argument_list|(
name|appStatusBuilder
operator|.
name|getDesiredInstances
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" instances"
argument_list|)
expr_stmt|;
block|}
name|String
name|containerDiagnostics
init|=
name|constructCompletedContainerDiagnostics
argument_list|(
name|appStatusBuilder
operator|.
name|getCompletedInstances
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|isNotEmpty
argument_list|(
name|containerDiagnostics
argument_list|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
operator|.
name|append
argument_list|(
name|containerDiagnostics
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"Awaiting LLAP startup"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RUNNING_PARTIAL
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"LLAP Starting up with ApplicationId="
argument_list|)
operator|.
name|append
argument_list|(
name|appStatusBuilder
operator|.
name|getAmInfo
argument_list|()
operator|.
name|getAppId
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" Started"
argument_list|)
operator|.
name|append
argument_list|(
name|appStatusBuilder
operator|.
name|getLiveInstances
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"/"
argument_list|)
operator|.
name|append
argument_list|(
name|appStatusBuilder
operator|.
name|getDesiredInstances
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" instances"
argument_list|)
expr_stmt|;
name|String
name|containerDiagnostics
init|=
name|constructCompletedContainerDiagnostics
argument_list|(
name|appStatusBuilder
operator|.
name|getCompletedInstances
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|isNotEmpty
argument_list|(
name|containerDiagnostics
argument_list|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
operator|.
name|append
argument_list|(
name|containerDiagnostics
argument_list|)
expr_stmt|;
block|}
comment|// TODO HIVE-15865: Include information about pending requests, and last
comment|// allocation time once YARN Service provides this information.
break|break;
case|case
name|RUNNING_ALL
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"LLAP Application running with ApplicationId="
argument_list|)
operator|.
name|append
argument_list|(
name|appStatusBuilder
operator|.
name|getAmInfo
argument_list|()
operator|.
name|getAppId
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLETE
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"LLAP Application already complete. ApplicationId="
argument_list|)
operator|.
name|append
argument_list|(
name|appStatusBuilder
operator|.
name|getAmInfo
argument_list|()
operator|.
name|getAppId
argument_list|()
argument_list|)
expr_stmt|;
name|containerDiagnostics
operator|=
name|constructCompletedContainerDiagnostics
argument_list|(
name|appStatusBuilder
operator|.
name|getCompletedInstances
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|isNotEmpty
argument_list|(
name|containerDiagnostics
argument_list|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
operator|.
name|append
argument_list|(
name|containerDiagnostics
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UNKNOWN
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"LLAP status unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|StringUtils
operator|.
name|isNotBlank
argument_list|(
name|appStatusBuilder
operator|.
name|getDiagnostics
argument_list|()
argument_list|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
operator|.
name|append
argument_list|(
name|appStatusBuilder
operator|.
name|getDiagnostics
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
enum|enum
name|ExitCode
block|{
name|SUCCESS
argument_list|(
literal|0
argument_list|)
block|,
name|INCORRECT_USAGE
argument_list|(
literal|10
argument_list|)
block|,
name|YARN_ERROR
argument_list|(
literal|20
argument_list|)
block|,
name|SERVICE_CLIENT_ERROR_CREATE_FAILED
argument_list|(
literal|30
argument_list|)
block|,
name|SERVICE_CLIENT_ERROR_OTHER
argument_list|(
literal|31
argument_list|)
block|,
name|LLAP_REGISTRY_ERROR
argument_list|(
literal|40
argument_list|)
block|,
name|LLAP_JSON_GENERATION_ERROR
argument_list|(
literal|50
argument_list|)
block|,
comment|// Error in the script itself - likely caused by an incompatible change, or new functionality / states added.
name|INTERNAL_ERROR
argument_list|(
literal|100
argument_list|)
block|;
specifier|private
specifier|final
name|int
name|exitCode
decl_stmt|;
name|ExitCode
parameter_list|(
name|int
name|exitCode
parameter_list|)
block|{
name|this
operator|.
name|exitCode
operator|=
name|exitCode
expr_stmt|;
block|}
specifier|public
name|int
name|getInt
parameter_list|()
block|{
return|return
name|exitCode
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|LlapStatusCliException
extends|extends
name|Exception
block|{
specifier|final
name|LlapStatusServiceDriver
operator|.
name|ExitCode
name|exitCode
decl_stmt|;
specifier|public
name|LlapStatusCliException
parameter_list|(
name|LlapStatusServiceDriver
operator|.
name|ExitCode
name|exitCode
parameter_list|,
name|String
name|message
parameter_list|)
block|{
name|super
argument_list|(
name|exitCode
operator|.
name|getInt
argument_list|()
operator|+
literal|": "
operator|+
name|message
argument_list|)
expr_stmt|;
name|this
operator|.
name|exitCode
operator|=
name|exitCode
expr_stmt|;
block|}
specifier|public
name|LlapStatusCliException
parameter_list|(
name|LlapStatusServiceDriver
operator|.
name|ExitCode
name|exitCode
parameter_list|,
name|String
name|message
parameter_list|,
name|Throwable
name|cause
parameter_list|)
block|{
name|super
argument_list|(
name|message
argument_list|,
name|cause
argument_list|)
expr_stmt|;
name|this
operator|.
name|exitCode
operator|=
name|exitCode
expr_stmt|;
block|}
specifier|public
name|LlapStatusServiceDriver
operator|.
name|ExitCode
name|getExitCode
parameter_list|()
block|{
return|return
name|exitCode
return|;
block|}
block|}
specifier|private
specifier|static
name|void
name|logError
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"FAILED: "
operator|+
name|t
operator|.
name|getMessage
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"FAILED: "
operator|+
name|t
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"LLAP status invoked with arguments = {}"
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|ret
init|=
name|ExitCode
operator|.
name|SUCCESS
operator|.
name|getInt
argument_list|()
decl_stmt|;
name|Clock
name|clock
init|=
name|SystemClock
operator|.
name|getInstance
argument_list|()
decl_stmt|;
name|long
name|startTime
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|long
name|lastSummaryLogTime
init|=
operator|-
literal|1
decl_stmt|;
name|LlapStatusServiceDriver
name|statusServiceDriver
init|=
literal|null
decl_stmt|;
name|LlapStatusOptions
name|options
init|=
literal|null
decl_stmt|;
try|try
block|{
name|statusServiceDriver
operator|=
operator|new
name|LlapStatusServiceDriver
argument_list|()
expr_stmt|;
name|options
operator|=
name|statusServiceDriver
operator|.
name|parseOptions
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|statusServiceDriver
operator|.
name|close
argument_list|()
expr_stmt|;
name|logError
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|LlapStatusCliException
condition|)
block|{
name|LlapStatusCliException
name|ce
init|=
operator|(
name|LlapStatusCliException
operator|)
name|t
decl_stmt|;
name|ret
operator|=
name|ce
operator|.
name|getExitCode
argument_list|()
operator|.
name|getInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|ExitCode
operator|.
name|INTERNAL_ERROR
operator|.
name|getInt
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|!=
literal|0
operator|||
name|options
operator|==
literal|null
condition|)
block|{
comment|// Failure / help
if|if
condition|(
name|statusServiceDriver
operator|!=
literal|null
condition|)
block|{
name|statusServiceDriver
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|System
operator|.
name|exit
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
name|boolean
name|firstAttempt
init|=
literal|true
decl_stmt|;
specifier|final
name|long
name|refreshInterval
init|=
name|options
operator|.
name|getRefreshIntervalMs
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|watchMode
init|=
name|options
operator|.
name|isWatchMode
argument_list|()
decl_stmt|;
specifier|final
name|long
name|watchTimeout
init|=
name|options
operator|.
name|getWatchTimeoutMs
argument_list|()
decl_stmt|;
name|long
name|numAttempts
init|=
name|watchTimeout
operator|/
name|refreshInterval
decl_stmt|;
name|numAttempts
operator|=
name|watchMode
condition|?
name|numAttempts
else|:
literal|1
expr_stmt|;
comment|// Break out of the loop fast if watchMode is disabled.
name|LlapStatusHelpers
operator|.
name|State
name|launchingState
init|=
literal|null
decl_stmt|;
name|LlapStatusHelpers
operator|.
name|State
name|currentState
init|=
literal|null
decl_stmt|;
name|boolean
name|desiredStateAttained
init|=
literal|false
decl_stmt|;
specifier|final
name|float
name|runningNodesThreshold
init|=
name|options
operator|.
name|getRunningNodesThreshold
argument_list|()
decl_stmt|;
try|try
init|(
name|OutputStream
name|os
init|=
name|options
operator|.
name|getOutputFile
argument_list|()
operator|==
literal|null
condition|?
name|System
operator|.
name|out
else|:
operator|new
name|BufferedOutputStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|options
operator|.
name|getOutputFile
argument_list|()
argument_list|)
argument_list|)
init|;
name|PrintWriter
name|pw
operator|=
operator|new
name|PrintWriter
argument_list|(
name|os
argument_list|)
init|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Configured refresh interval: {}s. Watch timeout: {}s. Attempts remaining: {}."
operator|+
literal|" Watch mode: {}. Running nodes threshold: {}."
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
operator|.
name|convert
argument_list|(
name|refreshInterval
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
operator|.
name|convert
argument_list|(
name|watchTimeout
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
argument_list|,
name|numAttempts
argument_list|,
name|watchMode
argument_list|,
operator|new
name|DecimalFormat
argument_list|(
literal|"#.###"
argument_list|)
operator|.
name|format
argument_list|(
name|runningNodesThreshold
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|numAttempts
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|firstAttempt
condition|)
block|{
if|if
condition|(
name|watchMode
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|refreshInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
else|else
block|{
comment|// reported once, so break
break|break;
block|}
block|}
else|else
block|{
name|firstAttempt
operator|=
literal|false
expr_stmt|;
block|}
name|ret
operator|=
name|statusServiceDriver
operator|.
name|run
argument_list|(
name|options
argument_list|,
name|watchMode
condition|?
name|watchTimeout
else|:
literal|0
argument_list|)
expr_stmt|;
name|currentState
operator|=
name|statusServiceDriver
operator|.
name|appStatusBuilder
operator|.
name|getState
argument_list|()
expr_stmt|;
try|try
block|{
name|lastSummaryLogTime
operator|=
name|LlapStatusServiceDriver
operator|.
name|maybeLogSummary
argument_list|(
name|clock
argument_list|,
name|lastSummaryLogTime
argument_list|,
name|statusServiceDriver
argument_list|,
name|watchMode
argument_list|,
name|watchTimeout
argument_list|,
name|launchingState
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to log summary"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|ExitCode
operator|.
name|SUCCESS
operator|.
name|getInt
argument_list|()
condition|)
block|{
if|if
condition|(
name|watchMode
condition|)
block|{
comment|// YARN Service has started llap application, now if for some reason
comment|// state changes to COMPLETE then fail fast
if|if
condition|(
name|launchingState
operator|==
literal|null
operator|&&
name|LAUNCHING_STATES
operator|.
name|contains
argument_list|(
name|currentState
argument_list|)
condition|)
block|{
name|launchingState
operator|=
name|currentState
expr_stmt|;
block|}
if|if
condition|(
name|currentState
operator|.
name|equals
argument_list|(
name|State
operator|.
name|COMPLETE
argument_list|)
condition|)
block|{
if|if
condition|(
name|launchingState
operator|!=
literal|null
operator|||
name|options
operator|.
name|isLaunched
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"COMPLETE state reached while waiting for RUNNING state. Failing."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Final diagnostics: "
operator|+
name|statusServiceDriver
operator|.
name|appStatusBuilder
operator|.
name|getDiagnostics
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Found a stopped application; assuming it was a previous attempt "
operator|+
literal|"and waiting for the next one. Omit the -l flag to avoid this."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|currentState
operator|.
name|equals
argument_list|(
name|State
operator|.
name|RUNNING_PARTIAL
argument_list|)
operator|||
name|currentState
operator|.
name|equals
argument_list|(
name|State
operator|.
name|RUNNING_ALL
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Current state: {}. Desired state: {}. {}/{} instances."
argument_list|,
name|currentState
argument_list|,
name|runningNodesThreshold
operator|==
literal|1.0f
condition|?
name|State
operator|.
name|RUNNING_ALL
else|:
name|State
operator|.
name|RUNNING_PARTIAL
argument_list|,
name|statusServiceDriver
operator|.
name|appStatusBuilder
operator|.
name|getLiveInstances
argument_list|()
argument_list|,
name|statusServiceDriver
operator|.
name|appStatusBuilder
operator|.
name|getDesiredInstances
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|numAttempts
operator|--
expr_stmt|;
continue|continue;
block|}
comment|// we have reached RUNNING state, now check if running nodes threshold is met
specifier|final
name|int
name|liveInstances
init|=
name|statusServiceDriver
operator|.
name|appStatusBuilder
operator|.
name|getLiveInstances
argument_list|()
decl_stmt|;
specifier|final
name|int
name|desiredInstances
init|=
name|statusServiceDriver
operator|.
name|appStatusBuilder
operator|.
name|getDesiredInstances
argument_list|()
decl_stmt|;
if|if
condition|(
name|desiredInstances
operator|>
literal|0
condition|)
block|{
specifier|final
name|float
name|ratio
init|=
operator|(
name|float
operator|)
name|liveInstances
operator|/
operator|(
name|float
operator|)
name|desiredInstances
decl_stmt|;
if|if
condition|(
name|ratio
operator|<
name|runningNodesThreshold
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting until running nodes threshold is reached. Current: {} Desired: {}."
operator|+
literal|" {}/{} instances."
argument_list|,
operator|new
name|DecimalFormat
argument_list|(
literal|"#.###"
argument_list|)
operator|.
name|format
argument_list|(
name|ratio
argument_list|)
argument_list|,
operator|new
name|DecimalFormat
argument_list|(
literal|"#.###"
argument_list|)
operator|.
name|format
argument_list|(
name|runningNodesThreshold
argument_list|)
argument_list|,
name|statusServiceDriver
operator|.
name|appStatusBuilder
operator|.
name|getLiveInstances
argument_list|()
argument_list|,
name|statusServiceDriver
operator|.
name|appStatusBuilder
operator|.
name|getDesiredInstances
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|numAttempts
operator|--
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|desiredStateAttained
operator|=
literal|true
expr_stmt|;
name|statusServiceDriver
operator|.
name|appStatusBuilder
operator|.
name|setRunningThresholdAchieved
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|numAttempts
operator|--
expr_stmt|;
continue|continue;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
name|ExitCode
operator|.
name|YARN_ERROR
operator|.
name|getInt
argument_list|()
operator|&&
name|watchMode
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Watch mode enabled and got YARN error. Retrying.."
argument_list|)
expr_stmt|;
name|numAttempts
operator|--
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
name|ExitCode
operator|.
name|SERVICE_CLIENT_ERROR_CREATE_FAILED
operator|.
name|getInt
argument_list|()
operator|&&
name|watchMode
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Watch mode enabled and YARN Service client creation failed. Retrying.."
argument_list|)
expr_stmt|;
name|numAttempts
operator|--
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
name|ExitCode
operator|.
name|SERVICE_CLIENT_ERROR_OTHER
operator|.
name|getInt
argument_list|()
operator|&&
name|watchMode
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Watch mode enabled and got YARN Service client error. Retrying.."
argument_list|)
expr_stmt|;
name|numAttempts
operator|--
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
name|ExitCode
operator|.
name|LLAP_REGISTRY_ERROR
operator|.
name|getInt
argument_list|()
operator|&&
name|watchMode
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Watch mode enabled and got LLAP registry error. Retrying.."
argument_list|)
expr_stmt|;
name|numAttempts
operator|--
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
comment|// Log final state to CONSOLE_LOGGER
name|LlapStatusServiceDriver
operator|.
name|maybeLogSummary
argument_list|(
name|clock
argument_list|,
literal|0L
argument_list|,
name|statusServiceDriver
argument_list|,
name|watchMode
argument_list|,
name|watchTimeout
argument_list|,
name|launchingState
argument_list|)
expr_stmt|;
name|CONSOLE_LOGGER
operator|.
name|info
argument_list|(
literal|"\n\n\n"
argument_list|)
expr_stmt|;
comment|// print current state before exiting
name|statusServiceDriver
operator|.
name|outputJson
argument_list|(
name|pw
argument_list|)
expr_stmt|;
name|os
operator|.
name|flush
argument_list|()
expr_stmt|;
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|numAttempts
operator|==
literal|0
operator|&&
name|watchMode
operator|&&
operator|!
name|desiredStateAttained
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Watch timeout {}s exhausted before desired state RUNNING is attained."
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
operator|.
name|convert
argument_list|(
name|watchTimeout
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|logError
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|LlapStatusCliException
condition|)
block|{
name|LlapStatusCliException
name|ce
init|=
operator|(
name|LlapStatusCliException
operator|)
name|t
decl_stmt|;
name|ret
operator|=
name|ce
operator|.
name|getExitCode
argument_list|()
operator|.
name|getInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|ExitCode
operator|.
name|INTERNAL_ERROR
operator|.
name|getInt
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"LLAP status finished"
argument_list|)
expr_stmt|;
name|statusServiceDriver
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Completed processing - exiting with "
operator|+
name|ret
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|exit
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|long
name|maybeLogSummary
parameter_list|(
name|Clock
name|clock
parameter_list|,
name|long
name|lastSummaryLogTime
parameter_list|,
name|LlapStatusServiceDriver
name|statusServiceDriver
parameter_list|,
name|boolean
name|watchMode
parameter_list|,
name|long
name|watchTimeout
parameter_list|,
name|LlapStatusHelpers
operator|.
name|State
name|launchingState
parameter_list|)
block|{
name|long
name|currentTime
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastSummaryLogTime
operator|<
name|currentTime
operator|-
name|LOG_SUMMARY_INTERVAL
condition|)
block|{
name|String
name|diagString
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|launchingState
operator|==
literal|null
operator|&&
name|statusServiceDriver
operator|.
name|appStatusBuilder
operator|.
name|getState
argument_list|()
operator|==
name|State
operator|.
name|COMPLETE
operator|&&
name|watchMode
condition|)
block|{
comment|// First known state was COMPLETED. Wait for the app launch to start.
name|diagString
operator|=
literal|"Awaiting LLAP launch"
expr_stmt|;
comment|// Clear completed instances in this case. Don't want to provide information from the previous run.
name|statusServiceDriver
operator|.
name|appStatusBuilder
operator|.
name|clearCompletedLlapInstances
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|diagString
operator|=
name|constructDiagnostics
argument_list|(
name|statusServiceDriver
operator|.
name|appStatusBuilder
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lastSummaryLogTime
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|watchMode
condition|)
block|{
name|CONSOLE_LOGGER
operator|.
name|info
argument_list|(
literal|"\nLLAPSTATUS WatchMode with timeout={} s"
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
operator|.
name|convert
argument_list|(
name|watchTimeout
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CONSOLE_LOGGER
operator|.
name|info
argument_list|(
literal|"\nLLAPSTATUS"
argument_list|)
expr_stmt|;
block|}
name|CONSOLE_LOGGER
operator|.
name|info
argument_list|(
literal|"--------------------------------------------------------------------------------"
argument_list|)
expr_stmt|;
block|}
name|CONSOLE_LOGGER
operator|.
name|info
argument_list|(
name|diagString
argument_list|)
expr_stmt|;
name|CONSOLE_LOGGER
operator|.
name|info
argument_list|(
literal|"--------------------------------------------------------------------------------"
argument_list|)
expr_stmt|;
name|lastSummaryLogTime
operator|=
name|currentTime
expr_stmt|;
block|}
return|return
name|lastSummaryLogTime
return|;
block|}
specifier|private
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|serviceClient
operator|!=
literal|null
condition|)
block|{
name|serviceClient
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|llapRegistry
operator|!=
literal|null
condition|)
block|{
name|llapRegistry
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

