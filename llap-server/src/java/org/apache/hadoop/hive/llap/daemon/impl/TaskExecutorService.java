begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *<p/>  * http://www.apache.org/licenses/LICENSE-2.0  *<p/>  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|daemon
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|PriorityBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RejectedExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|SynchronousQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|exception
operator|.
name|ExceptionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|daemon
operator|.
name|FinishableStateUpdateHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|daemon
operator|.
name|rpc
operator|.
name|LlapDaemonProtocolProtos
operator|.
name|FragmentRuntimeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|daemon
operator|.
name|rpc
operator|.
name|LlapDaemonProtocolProtos
operator|.
name|FragmentSpecProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|AbstractService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|runtime
operator|.
name|task
operator|.
name|EndReason
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|runtime
operator|.
name|task
operator|.
name|TaskRunner2Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|FutureCallback
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ListenableFuture
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ListeningExecutorService
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|MoreExecutors
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_comment
comment|/**  * Task executor service provides method for scheduling tasks. Tasks submitted to executor service  * are submitted to wait queue for scheduling. Wait queue tasks are ordered based on the priority  * of the task. The internal wait queue scheduler moves tasks from wait queue when executor slots  * are available or when a higher priority task arrives and will schedule it for execution.  * When pre-emption is enabled, the tasks from wait queue can replace(pre-empt) a running task.  * The pre-empted task is reported back to the Application Master(AM) for it to be rescheduled.  *<p/>  * Because of the concurrent nature of task submission, the position of the task in wait queue is  * held as long the scheduling of the task from wait queue (with or without pre-emption) is complete.  * The order of pre-emption is based on the ordering in the pre-emption queue. All tasks that cannot  * run to completion immediately (canFinish = false) are added to pre-emption queue.  *<p/>  * When all the executor threads are occupied and wait queue is full, the task scheduler will  * throw RejectedExecutionException.  *<p/>  * Task executor service can be shut down which will terminated all running tasks and reject all  * new tasks. Shutting down of the task executor service can be done gracefully or immediately.  */
end_comment

begin_class
specifier|public
class|class
name|TaskExecutorService
extends|extends
name|AbstractService
implements|implements
name|Scheduler
argument_list|<
name|TaskRunnerCallable
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TaskExecutorService
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|boolean
name|isInfoEnabled
init|=
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|boolean
name|isDebugEnabled
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|TASK_EXECUTOR_THREAD_NAME_FORMAT
init|=
literal|"Task-Executor-%d"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|WAIT_QUEUE_SCHEDULER_THREAD_NAME_FORMAT
init|=
literal|"Wait-Queue-Scheduler-%d"
decl_stmt|;
specifier|private
specifier|final
name|AtomicBoolean
name|isShutdown
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|// Thread pool for actual execution of work.
specifier|private
specifier|final
name|ListeningExecutorService
name|executorService
decl_stmt|;
specifier|private
specifier|final
name|EvictingPriorityBlockingQueue
argument_list|<
name|TaskWrapper
argument_list|>
name|waitQueue
decl_stmt|;
comment|// Thread pool for taking entities off the wait queue.
specifier|private
specifier|final
name|ListeningExecutorService
name|waitQueueExecutorService
decl_stmt|;
comment|// Thread pool for callbacks on completion of execution of a work unit.
specifier|private
specifier|final
name|ListeningExecutorService
name|executionCompletionExecutorService
decl_stmt|;
specifier|private
specifier|final
name|BlockingQueue
argument_list|<
name|TaskWrapper
argument_list|>
name|preemptionQueue
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|enablePreemption
decl_stmt|;
specifier|private
specifier|final
name|ThreadPoolExecutor
name|threadPoolExecutor
decl_stmt|;
specifier|private
specifier|final
name|AtomicInteger
name|numSlotsAvailable
decl_stmt|;
annotation|@
name|VisibleForTesting
comment|// Tracks known tasks.
specifier|final
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|TaskWrapper
argument_list|>
name|knownTasks
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Object
name|lock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|public
name|TaskExecutorService
parameter_list|(
name|int
name|numExecutors
parameter_list|,
name|int
name|waitQueueSize
parameter_list|,
name|boolean
name|useFairOrdering
parameter_list|,
name|boolean
name|enablePreemption
parameter_list|)
block|{
name|super
argument_list|(
name|TaskExecutorService
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Comparator
argument_list|<
name|TaskWrapper
argument_list|>
name|waitQueueComparator
decl_stmt|;
if|if
condition|(
name|useFairOrdering
condition|)
block|{
name|waitQueueComparator
operator|=
operator|new
name|FirstInFirstOutComparator
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|waitQueueComparator
operator|=
operator|new
name|ShortestJobFirstComparator
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|waitQueue
operator|=
operator|new
name|EvictingPriorityBlockingQueue
argument_list|<>
argument_list|(
name|waitQueueComparator
argument_list|,
name|waitQueueSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|threadPoolExecutor
operator|=
operator|new
name|ThreadPoolExecutor
argument_list|(
name|numExecutors
argument_list|,
comment|// core pool size
name|numExecutors
argument_list|,
comment|// max pool size
literal|1
argument_list|,
name|TimeUnit
operator|.
name|MINUTES
argument_list|,
operator|new
name|SynchronousQueue
argument_list|<
name|Runnable
argument_list|>
argument_list|()
argument_list|,
comment|// direct hand-off
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
name|TASK_EXECUTOR_THREAD_NAME_FORMAT
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|=
name|MoreExecutors
operator|.
name|listeningDecorator
argument_list|(
name|threadPoolExecutor
argument_list|)
expr_stmt|;
name|this
operator|.
name|preemptionQueue
operator|=
operator|new
name|PriorityBlockingQueue
argument_list|<>
argument_list|(
name|numExecutors
argument_list|,
operator|new
name|PreemptionQueueComparator
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|enablePreemption
operator|=
name|enablePreemption
expr_stmt|;
name|this
operator|.
name|numSlotsAvailable
operator|=
operator|new
name|AtomicInteger
argument_list|(
name|numExecutors
argument_list|)
expr_stmt|;
comment|// single threaded scheduler for tasks from wait queue to executor threads
name|ExecutorService
name|wes
init|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
literal|1
argument_list|,
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
name|WAIT_QUEUE_SCHEDULER_THREAD_NAME_FORMAT
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|this
operator|.
name|waitQueueExecutorService
operator|=
name|MoreExecutors
operator|.
name|listeningDecorator
argument_list|(
name|wes
argument_list|)
expr_stmt|;
name|ExecutorService
name|executionCompletionExecutorServiceRaw
init|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
literal|1
argument_list|,
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
literal|"ExecutionCompletionThread #%d"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|executionCompletionExecutorService
operator|=
name|MoreExecutors
operator|.
name|listeningDecorator
argument_list|(
name|executionCompletionExecutorServiceRaw
argument_list|)
expr_stmt|;
name|ListenableFuture
argument_list|<
name|?
argument_list|>
name|future
init|=
name|waitQueueExecutorService
operator|.
name|submit
argument_list|(
operator|new
name|WaitQueueWorker
argument_list|()
argument_list|)
decl_stmt|;
name|Futures
operator|.
name|addCallback
argument_list|(
name|future
argument_list|,
operator|new
name|WaitQueueWorkerCallback
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"TaskExecutorService started with parameters: "
operator|+
literal|"numExecutors="
operator|+
name|numExecutors
operator|+
literal|", waitQueueSize="
operator|+
name|waitQueueSize
operator|+
literal|", enablePreemption="
operator|+
name|enablePreemption
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|serviceStop
parameter_list|()
block|{
name|shutDown
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|SimpleDateFormat
argument_list|>
name|sdf
init|=
operator|new
name|ThreadLocal
argument_list|<
name|SimpleDateFormat
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|SimpleDateFormat
name|initialValue
parameter_list|()
block|{
return|return
operator|new
name|SimpleDateFormat
argument_list|(
literal|"yyyy-MM-dd HH:mm:ss"
argument_list|)
return|;
block|}
block|}
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getExecutorsStatus
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|result
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|StringBuilder
name|value
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|TaskWrapper
argument_list|>
name|e
range|:
name|knownTasks
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|value
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|value
operator|.
name|append
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|TaskWrapper
name|task
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|boolean
name|isFirst
init|=
literal|true
decl_stmt|;
name|TaskRunnerCallable
name|c
init|=
name|task
operator|.
name|getTaskRunnerCallable
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
operator|&&
name|c
operator|.
name|getRequest
argument_list|()
operator|!=
literal|null
operator|&&
name|c
operator|.
name|getRequest
argument_list|()
operator|.
name|getFragmentSpec
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|FragmentSpecProto
name|fs
init|=
name|c
operator|.
name|getRequest
argument_list|()
operator|.
name|getFragmentSpec
argument_list|()
decl_stmt|;
name|value
operator|.
name|append
argument_list|(
name|isFirst
condition|?
literal|" ("
else|:
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|fs
operator|.
name|getDagName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"/"
argument_list|)
operator|.
name|append
argument_list|(
name|fs
operator|.
name|getVertexName
argument_list|()
argument_list|)
expr_stmt|;
name|isFirst
operator|=
literal|false
expr_stmt|;
block|}
name|value
operator|.
name|append
argument_list|(
name|isFirst
condition|?
literal|" ("
else|:
literal|", "
argument_list|)
expr_stmt|;
if|if
condition|(
name|task
operator|.
name|isInWaitQueue
argument_list|()
condition|)
block|{
name|value
operator|.
name|append
argument_list|(
literal|"in queue"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
name|long
name|startTime
init|=
name|c
operator|.
name|getStartTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|startTime
operator|!=
literal|0
condition|)
block|{
name|value
operator|.
name|append
argument_list|(
literal|"started at "
argument_list|)
operator|.
name|append
argument_list|(
name|sdf
operator|.
name|get
argument_list|()
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|(
name|startTime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|.
name|append
argument_list|(
literal|"not started"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|value
operator|.
name|append
argument_list|(
literal|"has no callable"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|task
operator|.
name|isInPreemptionQueue
argument_list|()
condition|)
block|{
name|value
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
literal|"preemptable"
argument_list|)
expr_stmt|;
block|}
name|value
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Worker that takes tasks from wait queue and schedule it for execution.    */
specifier|private
specifier|final
class|class
name|WaitQueueWorker
implements|implements
name|Runnable
block|{
name|TaskWrapper
name|task
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
while|while
condition|(
operator|!
name|isShutdown
operator|.
name|get
argument_list|()
condition|)
block|{
synchronized|synchronized
init|(
name|lock
init|)
block|{
comment|// Since schedule() can be called from multiple threads, we peek the wait queue,
comment|// try scheduling the task and then remove the task if scheduling is successful.
comment|// This will make sure the task's place in the wait queue is held until it gets scheduled.
name|task
operator|=
name|waitQueue
operator|.
name|peek
argument_list|()
expr_stmt|;
if|if
condition|(
name|task
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|isShutdown
operator|.
name|get
argument_list|()
condition|)
block|{
name|lock
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
continue|continue;
block|}
comment|// if the task cannot finish and if no slots are available then don't schedule it.
name|boolean
name|shouldWait
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|task
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|canFinish
argument_list|()
condition|)
block|{
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting to schedule task {}, canFinish={}. Current state: preemptionQueueSize={}, numSlotsAvailable={}, waitQueueSize={}"
argument_list|,
name|task
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|task
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|canFinish
argument_list|()
argument_list|,
name|preemptionQueue
operator|.
name|size
argument_list|()
argument_list|,
name|numSlotsAvailable
operator|.
name|get
argument_list|()
argument_list|,
name|waitQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numSlotsAvailable
operator|.
name|get
argument_list|()
operator|==
literal|0
operator|&&
name|preemptionQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|shouldWait
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|numSlotsAvailable
operator|.
name|get
argument_list|()
operator|==
literal|0
condition|)
block|{
name|shouldWait
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|shouldWait
condition|)
block|{
if|if
condition|(
operator|!
name|isShutdown
operator|.
name|get
argument_list|()
condition|)
block|{
name|lock
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
comment|// Another task at a higher priority may have come in during the wait. Lookup the
comment|// queue again to pick up the task at the highest priority.
continue|continue;
block|}
block|}
name|boolean
name|scheduled
init|=
name|trySchedule
argument_list|(
name|task
argument_list|)
decl_stmt|;
if|if
condition|(
name|scheduled
condition|)
block|{
comment|// wait queue could have been re-ordered in the mean time because of concurrent task
comment|// submission. So remove the specific task instead of the head task.
synchronized|synchronized
init|(
name|lock
init|)
block|{
name|waitQueue
operator|.
name|remove
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
block|}
synchronized|synchronized
init|(
name|lock
init|)
block|{
while|while
condition|(
name|waitQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|isShutdown
operator|.
name|get
argument_list|()
condition|)
block|{
name|lock
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isShutdown
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|WAIT_QUEUE_SCHEDULER_THREAD_NAME_FORMAT
operator|+
literal|" thread has been interrupted after shutdown."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|WAIT_QUEUE_SCHEDULER_THREAD_NAME_FORMAT
operator|+
literal|" interrupted without shutdown"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
specifier|private
class|class
name|WaitQueueWorkerCallback
implements|implements
name|FutureCallback
block|{
annotation|@
name|Override
specifier|public
name|void
name|onSuccess
parameter_list|(
name|Object
name|result
parameter_list|)
block|{
if|if
condition|(
name|isShutdown
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Wait queue scheduler worker exited with success!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Wait queue scheduler worker exited with success!"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|getDefaultUncaughtExceptionHandler
argument_list|()
operator|.
name|uncaughtException
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|,
operator|new
name|IllegalStateException
argument_list|(
literal|"WaitQueue worked exited before shutdown"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Wait queue scheduler worker exited with failure!"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|getDefaultUncaughtExceptionHandler
argument_list|()
operator|.
name|uncaughtException
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|schedule
parameter_list|(
name|TaskRunnerCallable
name|task
parameter_list|)
throws|throws
name|RejectedExecutionException
block|{
name|TaskWrapper
name|taskWrapper
init|=
operator|new
name|TaskWrapper
argument_list|(
name|task
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|TaskWrapper
name|evictedTask
decl_stmt|;
synchronized|synchronized
init|(
name|lock
init|)
block|{
comment|// If the queue does not have capacity, it does not throw a Rejection. Instead it will
comment|// return the task with the lowest priority, which could be the task which is currently being processed.
name|evictedTask
operator|=
name|waitQueue
operator|.
name|offer
argument_list|(
name|taskWrapper
argument_list|)
expr_stmt|;
if|if
condition|(
name|evictedTask
operator|!=
name|taskWrapper
condition|)
block|{
name|knownTasks
operator|.
name|put
argument_list|(
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|taskWrapper
argument_list|)
expr_stmt|;
name|taskWrapper
operator|.
name|setIsInWaitQueue
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInfoEnabled
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"{} added to wait queue. Current wait queue size={}"
argument_list|,
name|task
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|waitQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|isInfoEnabled
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"wait queue full, size={}. {} not added"
argument_list|,
name|waitQueue
operator|.
name|size
argument_list|()
argument_list|,
name|task
operator|.
name|getRequestId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|evictedTask
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|killTask
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|RejectedExecutionException
argument_list|(
literal|"Wait queue full"
argument_list|)
throw|;
block|}
block|}
comment|// At this point, the task has been added into the queue. It may have caused an eviction for
comment|// some other task.
comment|// This registration has to be done after knownTasks has been populated.
comment|// Register for state change notifications so that the waitQueue can be re-ordered correctly
comment|// if the fragment moves in or out of the finishable state.
name|boolean
name|canFinish
init|=
name|taskWrapper
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|canFinish
argument_list|()
decl_stmt|;
comment|// It's safe to register outside of the lock since the stateChangeTracker ensures that updates
comment|// and registrations are mutually exclusive.
name|taskWrapper
operator|.
name|maybeRegisterForFinishedStateNotifications
argument_list|(
name|canFinish
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Wait Queue: {}"
argument_list|,
name|waitQueue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|evictedTask
operator|!=
literal|null
condition|)
block|{
name|knownTasks
operator|.
name|remove
argument_list|(
name|evictedTask
operator|.
name|getRequestId
argument_list|()
argument_list|)
expr_stmt|;
name|evictedTask
operator|.
name|maybeUnregisterForFinishedStateNotifications
argument_list|()
expr_stmt|;
name|evictedTask
operator|.
name|setIsInWaitQueue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|evictedTask
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|killTask
argument_list|()
expr_stmt|;
if|if
condition|(
name|isInfoEnabled
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"{} evicted from wait queue in favor of {} because of lower priority"
argument_list|,
name|evictedTask
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|task
operator|.
name|getRequestId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
synchronized|synchronized
init|(
name|lock
init|)
block|{
name|lock
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|killFragment
parameter_list|(
name|String
name|fragmentId
parameter_list|)
block|{
synchronized|synchronized
init|(
name|lock
init|)
block|{
name|TaskWrapper
name|taskWrapper
init|=
name|knownTasks
operator|.
name|remove
argument_list|(
name|fragmentId
argument_list|)
decl_stmt|;
comment|// Can be null since the task may have completed meanwhile.
if|if
condition|(
name|taskWrapper
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|taskWrapper
operator|.
name|inWaitQueue
condition|)
block|{
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing {} from waitQueue"
argument_list|,
name|fragmentId
argument_list|)
expr_stmt|;
block|}
name|taskWrapper
operator|.
name|setIsInWaitQueue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|waitQueue
operator|.
name|remove
argument_list|(
name|taskWrapper
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|taskWrapper
operator|.
name|inPreemptionQueue
condition|)
block|{
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing {} from preemptionQueue"
argument_list|,
name|fragmentId
argument_list|)
expr_stmt|;
block|}
name|taskWrapper
operator|.
name|setIsInPreemptableQueue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|preemptionQueue
operator|.
name|remove
argument_list|(
name|taskWrapper
argument_list|)
expr_stmt|;
block|}
name|taskWrapper
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|killTask
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignoring killFragment request for {} since it isn't known"
argument_list|,
name|fragmentId
argument_list|)
expr_stmt|;
block|}
name|lock
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|trySchedule
parameter_list|(
specifier|final
name|TaskWrapper
name|taskWrapper
parameter_list|)
block|{
name|boolean
name|scheduled
init|=
literal|false
decl_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|lock
init|)
block|{
name|boolean
name|canFinish
init|=
name|taskWrapper
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|canFinish
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Attempting to execute {}"
argument_list|,
name|taskWrapper
argument_list|)
expr_stmt|;
name|ListenableFuture
argument_list|<
name|TaskRunner2Result
argument_list|>
name|future
init|=
name|executorService
operator|.
name|submit
argument_list|(
name|taskWrapper
operator|.
name|getTaskRunnerCallable
argument_list|()
argument_list|)
decl_stmt|;
name|taskWrapper
operator|.
name|setIsInWaitQueue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|FutureCallback
argument_list|<
name|TaskRunner2Result
argument_list|>
name|wrappedCallback
init|=
name|createInternalCompletionListener
argument_list|(
name|taskWrapper
argument_list|)
decl_stmt|;
comment|// Callback on a separate thread so that when a task completes, the thread in the main queue
comment|// is actually available for execution and will not potentially result in a RejectedExecution
name|Futures
operator|.
name|addCallback
argument_list|(
name|future
argument_list|,
name|wrappedCallback
argument_list|,
name|executionCompletionExecutorService
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInfoEnabled
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"{} scheduled for execution. canFinish={}"
argument_list|,
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|canFinish
argument_list|)
expr_stmt|;
block|}
comment|// only tasks that cannot finish immediately are pre-emptable. In other words, if all inputs
comment|// to the tasks are not ready yet, the task is eligible for pre-emptable.
if|if
condition|(
name|enablePreemption
condition|)
block|{
if|if
condition|(
operator|!
name|canFinish
condition|)
block|{
if|if
condition|(
name|isInfoEnabled
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"{} is not finishable. Adding it to pre-emption queue"
argument_list|,
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|addToPreemptionQueue
argument_list|(
name|taskWrapper
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|numSlotsAvailable
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
name|scheduled
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RejectedExecutionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|enablePreemption
operator|&&
name|taskWrapper
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|canFinish
argument_list|()
operator|&&
operator|!
name|preemptionQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Preemption Queue: "
operator|+
name|preemptionQueue
argument_list|)
expr_stmt|;
block|}
name|TaskWrapper
name|pRequest
init|=
name|removeAndGetFromPreemptionQueue
argument_list|()
decl_stmt|;
comment|// Avoid preempting tasks which are finishable - callback still to be processed.
if|if
condition|(
name|pRequest
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|pRequest
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|canFinish
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removed {} from preemption queue, but not preempting since it's now finishable"
argument_list|,
name|pRequest
operator|.
name|getRequestId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isInfoEnabled
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Invoking kill task for {} due to pre-emption to run {}"
argument_list|,
name|pRequest
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// The task will either be killed or is already in the process of completing, which will
comment|// trigger the next scheduling run, or result in available slots being higher than 0,
comment|// which will cause the scheduler loop to continue.
name|pRequest
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|killTask
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|scheduled
return|;
block|}
specifier|private
name|void
name|finishableStateUpdated
parameter_list|(
name|TaskWrapper
name|taskWrapper
parameter_list|,
name|boolean
name|newFinishableState
parameter_list|)
block|{
synchronized|synchronized
init|(
name|lock
init|)
block|{
if|if
condition|(
name|taskWrapper
operator|.
name|isInWaitQueue
argument_list|()
condition|)
block|{
comment|// Re-order the wait queue
name|LOG
operator|.
name|info
argument_list|(
literal|"DEBUG: Re-ordering the wait queue since {} finishable state moved to {}"
argument_list|,
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|newFinishableState
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitQueue
operator|.
name|remove
argument_list|(
name|taskWrapper
argument_list|)
condition|)
block|{
comment|// Put element back only if it existed.
name|waitQueue
operator|.
name|offer
argument_list|(
name|taskWrapper
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to remove {} from waitQueue"
argument_list|,
name|taskWrapper
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|getRequestId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newFinishableState
operator|==
literal|true
operator|&&
name|taskWrapper
operator|.
name|isInPreemptionQueue
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"DEBUG: Removing {} from preemption queue because it's state changed to {}"
argument_list|,
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|newFinishableState
argument_list|)
expr_stmt|;
name|preemptionQueue
operator|.
name|remove
argument_list|(
name|taskWrapper
operator|.
name|getTaskRunnerCallable
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newFinishableState
operator|==
literal|false
operator|&&
operator|!
name|taskWrapper
operator|.
name|isInPreemptionQueue
argument_list|()
operator|&&
operator|!
name|taskWrapper
operator|.
name|isInWaitQueue
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"DEBUG: Adding {} to preemption queue since finishable state changed to {}"
argument_list|,
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|newFinishableState
argument_list|)
expr_stmt|;
name|preemptionQueue
operator|.
name|offer
argument_list|(
name|taskWrapper
argument_list|)
expr_stmt|;
block|}
name|lock
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|addToPreemptionQueue
parameter_list|(
name|TaskWrapper
name|taskWrapper
parameter_list|)
block|{
synchronized|synchronized
init|(
name|lock
init|)
block|{
name|preemptionQueue
operator|.
name|add
argument_list|(
name|taskWrapper
argument_list|)
expr_stmt|;
name|taskWrapper
operator|.
name|setIsInPreemptableQueue
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|TaskWrapper
name|removeAndGetFromPreemptionQueue
parameter_list|()
block|{
name|TaskWrapper
name|taskWrapper
decl_stmt|;
synchronized|synchronized
init|(
name|lock
init|)
block|{
name|taskWrapper
operator|=
name|preemptionQueue
operator|.
name|remove
argument_list|()
expr_stmt|;
if|if
condition|(
name|taskWrapper
operator|!=
literal|null
condition|)
block|{
name|taskWrapper
operator|.
name|setIsInPreemptableQueue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|taskWrapper
return|;
block|}
annotation|@
name|VisibleForTesting
name|InternalCompletionListener
name|createInternalCompletionListener
parameter_list|(
name|TaskWrapper
name|taskWrapper
parameter_list|)
block|{
return|return
operator|new
name|InternalCompletionListener
argument_list|(
name|taskWrapper
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
class|class
name|InternalCompletionListener
implements|implements
name|FutureCallback
argument_list|<
name|TaskRunner2Result
argument_list|>
block|{
specifier|private
specifier|final
name|TaskWrapper
name|taskWrapper
decl_stmt|;
specifier|public
name|InternalCompletionListener
parameter_list|(
name|TaskWrapper
name|taskWrapper
parameter_list|)
block|{
name|this
operator|.
name|taskWrapper
operator|=
name|taskWrapper
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onSuccess
parameter_list|(
name|TaskRunner2Result
name|result
parameter_list|)
block|{
name|knownTasks
operator|.
name|remove
argument_list|(
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|)
expr_stmt|;
name|taskWrapper
operator|.
name|setIsInPreemptableQueue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|taskWrapper
operator|.
name|maybeUnregisterForFinishedStateNotifications
argument_list|()
expr_stmt|;
name|taskWrapper
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|getCallback
argument_list|()
operator|.
name|onSuccess
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|updatePreemptionListAndNotify
argument_list|(
name|result
operator|.
name|getEndReason
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|knownTasks
operator|.
name|remove
argument_list|(
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|)
expr_stmt|;
name|taskWrapper
operator|.
name|setIsInPreemptableQueue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|taskWrapper
operator|.
name|maybeUnregisterForFinishedStateNotifications
argument_list|()
expr_stmt|;
name|taskWrapper
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|getCallback
argument_list|()
operator|.
name|onFailure
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|updatePreemptionListAndNotify
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed notification received: Stacktrace: "
operator|+
name|ExceptionUtils
operator|.
name|getStackTrace
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|updatePreemptionListAndNotify
parameter_list|(
name|EndReason
name|reason
parameter_list|)
block|{
comment|// if this task was added to pre-emption list, remove it
if|if
condition|(
name|enablePreemption
condition|)
block|{
name|String
name|state
init|=
name|reason
operator|==
literal|null
condition|?
literal|"FAILED"
else|:
name|reason
operator|.
name|name
argument_list|()
decl_stmt|;
name|boolean
name|removed
init|=
name|preemptionQueue
operator|.
name|remove
argument_list|(
name|taskWrapper
argument_list|)
decl_stmt|;
if|if
condition|(
name|removed
operator|&&
name|isInfoEnabled
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|TaskRunnerCallable
operator|.
name|getTaskIdentifierString
argument_list|(
name|taskWrapper
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|getRequest
argument_list|()
argument_list|)
operator|+
literal|" request "
operator|+
name|state
operator|+
literal|"! Removed from preemption list."
argument_list|)
expr_stmt|;
block|}
block|}
name|numSlotsAvailable
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Task {} complete. WaitQueueSize={}, numSlotsAvailable={}, preemptionQueueSize={}"
argument_list|,
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|waitQueue
operator|.
name|size
argument_list|()
argument_list|,
name|numSlotsAvailable
operator|.
name|get
argument_list|()
argument_list|,
name|preemptionQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|lock
init|)
block|{
if|if
condition|(
operator|!
name|waitQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lock
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|public
name|void
name|shutDown
parameter_list|(
name|boolean
name|awaitTermination
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isShutdown
operator|.
name|getAndSet
argument_list|(
literal|true
argument_list|)
condition|)
block|{
if|if
condition|(
name|awaitTermination
condition|)
block|{
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"awaitTermination: "
operator|+
name|awaitTermination
operator|+
literal|" shutting down task executor"
operator|+
literal|" service gracefully"
argument_list|)
expr_stmt|;
block|}
name|shutdownExecutor
argument_list|(
name|waitQueueExecutorService
argument_list|)
expr_stmt|;
name|shutdownExecutor
argument_list|(
name|executorService
argument_list|)
expr_stmt|;
name|shutdownExecutor
argument_list|(
name|executionCompletionExecutorService
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"awaitTermination: "
operator|+
name|awaitTermination
operator|+
literal|" shutting down task executor"
operator|+
literal|" service immediately"
argument_list|)
expr_stmt|;
block|}
name|executorService
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|waitQueueExecutorService
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|executionCompletionExecutorService
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|shutdownExecutor
parameter_list|(
name|ExecutorService
name|executorService
parameter_list|)
block|{
name|executorService
operator|.
name|shutdown
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|executorService
operator|.
name|awaitTermination
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|MINUTES
argument_list|)
condition|)
block|{
name|executorService
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|executorService
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
block|}
comment|// if map tasks and reduce tasks are in finishable state then priority is given to the task
comment|// that has less number of pending tasks (shortest job)
annotation|@
name|VisibleForTesting
specifier|public
specifier|static
class|class
name|ShortestJobFirstComparator
implements|implements
name|Comparator
argument_list|<
name|TaskWrapper
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|TaskWrapper
name|t1
parameter_list|,
name|TaskWrapper
name|t2
parameter_list|)
block|{
name|TaskRunnerCallable
name|o1
init|=
name|t1
operator|.
name|getTaskRunnerCallable
argument_list|()
decl_stmt|;
name|TaskRunnerCallable
name|o2
init|=
name|t2
operator|.
name|getTaskRunnerCallable
argument_list|()
decl_stmt|;
name|boolean
name|o1CanFinish
init|=
name|o1
operator|.
name|canFinish
argument_list|()
decl_stmt|;
name|boolean
name|o2CanFinish
init|=
name|o2
operator|.
name|canFinish
argument_list|()
decl_stmt|;
if|if
condition|(
name|o1CanFinish
operator|==
literal|true
operator|&&
name|o2CanFinish
operator|==
literal|false
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|o1CanFinish
operator|==
literal|false
operator|&&
name|o2CanFinish
operator|==
literal|true
condition|)
block|{
return|return
literal|1
return|;
block|}
name|FragmentRuntimeInfo
name|fri1
init|=
name|o1
operator|.
name|getFragmentRuntimeInfo
argument_list|()
decl_stmt|;
name|FragmentRuntimeInfo
name|fri2
init|=
name|o2
operator|.
name|getFragmentRuntimeInfo
argument_list|()
decl_stmt|;
comment|// Check if these belong to the same task, and work with withinDagPriority
if|if
condition|(
name|o1
operator|.
name|getQueryId
argument_list|()
operator|.
name|equals
argument_list|(
name|o2
operator|.
name|getQueryId
argument_list|()
argument_list|)
condition|)
block|{
comment|// Same Query
comment|// Within dag priority - lower values indicate higher priority.
if|if
condition|(
name|fri1
operator|.
name|getWithinDagPriority
argument_list|()
operator|<
name|fri2
operator|.
name|getWithinDagPriority
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fri1
operator|.
name|getWithinDagPriority
argument_list|()
operator|>
name|fri2
operator|.
name|getWithinDagPriority
argument_list|()
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
comment|// Compute knownPending tasks. selfAndUpstream indicates task counts for current vertex and
comment|// it's parent hierarchy. selfAndUpstreamComplete indicates how many of these have completed.
name|int
name|knownPending1
init|=
name|fri1
operator|.
name|getNumSelfAndUpstreamTasks
argument_list|()
operator|-
name|fri1
operator|.
name|getNumSelfAndUpstreamCompletedTasks
argument_list|()
decl_stmt|;
name|int
name|knownPending2
init|=
name|fri2
operator|.
name|getNumSelfAndUpstreamTasks
argument_list|()
operator|-
name|fri2
operator|.
name|getNumSelfAndUpstreamCompletedTasks
argument_list|()
decl_stmt|;
if|if
condition|(
name|knownPending1
operator|<
name|knownPending2
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|knownPending1
operator|>
name|knownPending2
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fri1
operator|.
name|getFirstAttemptStartTime
argument_list|()
operator|<
name|fri2
operator|.
name|getFirstAttemptStartTime
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fri1
operator|.
name|getFirstAttemptStartTime
argument_list|()
operator|>
name|fri2
operator|.
name|getFirstAttemptStartTime
argument_list|()
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
comment|// if map tasks and reduce tasks are in finishable state then priority is given to the task in
comment|// the following order
comment|// 1) Dag start time
comment|// 2) Within dag priority
comment|// 3) Attempt start time
comment|// 4) Vertex parallelism
annotation|@
name|VisibleForTesting
specifier|public
specifier|static
class|class
name|FirstInFirstOutComparator
implements|implements
name|Comparator
argument_list|<
name|TaskWrapper
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|TaskWrapper
name|t1
parameter_list|,
name|TaskWrapper
name|t2
parameter_list|)
block|{
name|TaskRunnerCallable
name|o1
init|=
name|t1
operator|.
name|getTaskRunnerCallable
argument_list|()
decl_stmt|;
name|TaskRunnerCallable
name|o2
init|=
name|t2
operator|.
name|getTaskRunnerCallable
argument_list|()
decl_stmt|;
name|boolean
name|o1CanFinish
init|=
name|o1
operator|.
name|canFinish
argument_list|()
decl_stmt|;
name|boolean
name|o2CanFinish
init|=
name|o2
operator|.
name|canFinish
argument_list|()
decl_stmt|;
if|if
condition|(
name|o1CanFinish
operator|==
literal|true
operator|&&
name|o2CanFinish
operator|==
literal|false
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|o1CanFinish
operator|==
literal|false
operator|&&
name|o2CanFinish
operator|==
literal|true
condition|)
block|{
return|return
literal|1
return|;
block|}
name|FragmentRuntimeInfo
name|fri1
init|=
name|o1
operator|.
name|getFragmentRuntimeInfo
argument_list|()
decl_stmt|;
name|FragmentRuntimeInfo
name|fri2
init|=
name|o2
operator|.
name|getFragmentRuntimeInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|fri1
operator|.
name|getDagStartTime
argument_list|()
operator|<
name|fri2
operator|.
name|getDagStartTime
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fri1
operator|.
name|getDagStartTime
argument_list|()
operator|>
name|fri2
operator|.
name|getDagStartTime
argument_list|()
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|// Check if these belong to the same task, and work with withinDagPriority
if|if
condition|(
name|o1
operator|.
name|getQueryId
argument_list|()
operator|.
name|equals
argument_list|(
name|o2
operator|.
name|getQueryId
argument_list|()
argument_list|)
condition|)
block|{
comment|// Same Query
comment|// Within dag priority - lower values indicate higher priority.
if|if
condition|(
name|fri1
operator|.
name|getWithinDagPriority
argument_list|()
operator|<
name|fri2
operator|.
name|getWithinDagPriority
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fri1
operator|.
name|getWithinDagPriority
argument_list|()
operator|>
name|fri2
operator|.
name|getWithinDagPriority
argument_list|()
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|fri1
operator|.
name|getFirstAttemptStartTime
argument_list|()
operator|<
name|fri2
operator|.
name|getFirstAttemptStartTime
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fri1
operator|.
name|getFirstAttemptStartTime
argument_list|()
operator|>
name|fri2
operator|.
name|getFirstAttemptStartTime
argument_list|()
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|// Compute knownPending tasks. selfAndUpstream indicates task counts for current vertex and
comment|// it's parent hierarchy. selfAndUpstreamComplete indicates how many of these have completed.
name|int
name|knownPending1
init|=
name|fri1
operator|.
name|getNumSelfAndUpstreamTasks
argument_list|()
operator|-
name|fri1
operator|.
name|getNumSelfAndUpstreamCompletedTasks
argument_list|()
decl_stmt|;
name|int
name|knownPending2
init|=
name|fri2
operator|.
name|getNumSelfAndUpstreamTasks
argument_list|()
operator|-
name|fri2
operator|.
name|getNumSelfAndUpstreamCompletedTasks
argument_list|()
decl_stmt|;
if|if
condition|(
name|knownPending1
operator|<
name|knownPending2
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|knownPending1
operator|>
name|knownPending2
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|public
specifier|static
class|class
name|PreemptionQueueComparator
implements|implements
name|Comparator
argument_list|<
name|TaskWrapper
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|TaskWrapper
name|t1
parameter_list|,
name|TaskWrapper
name|t2
parameter_list|)
block|{
name|TaskRunnerCallable
name|o1
init|=
name|t1
operator|.
name|getTaskRunnerCallable
argument_list|()
decl_stmt|;
name|TaskRunnerCallable
name|o2
init|=
name|t2
operator|.
name|getTaskRunnerCallable
argument_list|()
decl_stmt|;
name|FragmentRuntimeInfo
name|fri1
init|=
name|o1
operator|.
name|getFragmentRuntimeInfo
argument_list|()
decl_stmt|;
name|FragmentRuntimeInfo
name|fri2
init|=
name|o2
operator|.
name|getFragmentRuntimeInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|fri1
operator|.
name|getNumSelfAndUpstreamTasks
argument_list|()
operator|>
name|fri2
operator|.
name|getNumSelfAndUpstreamTasks
argument_list|()
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fri1
operator|.
name|getNumSelfAndUpstreamTasks
argument_list|()
operator|<
name|fri2
operator|.
name|getNumSelfAndUpstreamTasks
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|TaskWrapper
implements|implements
name|FinishableStateUpdateHandler
block|{
specifier|private
specifier|final
name|TaskRunnerCallable
name|taskRunnerCallable
decl_stmt|;
specifier|private
name|boolean
name|inWaitQueue
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|inPreemptionQueue
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|registeredForNotifications
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|TaskExecutorService
name|taskExecutorService
decl_stmt|;
specifier|public
name|TaskWrapper
parameter_list|(
name|TaskRunnerCallable
name|taskRunnerCallable
parameter_list|,
name|TaskExecutorService
name|taskExecutorService
parameter_list|)
block|{
name|this
operator|.
name|taskRunnerCallable
operator|=
name|taskRunnerCallable
expr_stmt|;
name|this
operator|.
name|taskExecutorService
operator|=
name|taskExecutorService
expr_stmt|;
block|}
comment|// Methods are synchronized primarily for visibility.
comment|/**      *      * @param currentFinishableState      * @return true if the current state is the same as the currentFinishableState. false if the state has already changed.      */
comment|// Synchronized to avoid register / unregister clobbering each other.
comment|// Don't invoke from within a scheduler lock
specifier|public
specifier|synchronized
name|boolean
name|maybeRegisterForFinishedStateNotifications
parameter_list|(
name|boolean
name|currentFinishableState
parameter_list|)
block|{
if|if
condition|(
operator|!
name|registeredForNotifications
condition|)
block|{
name|registeredForNotifications
operator|=
literal|true
expr_stmt|;
return|return
name|taskRunnerCallable
operator|.
name|getFragmentInfo
argument_list|()
operator|.
name|registerForFinishableStateUpdates
argument_list|(
name|this
argument_list|,
name|currentFinishableState
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
comment|// Synchronized to avoid register / unregister clobbering each other.
comment|// Don't invoke from within a scheduler lock
specifier|public
specifier|synchronized
name|void
name|maybeUnregisterForFinishedStateNotifications
parameter_list|()
block|{
if|if
condition|(
name|registeredForNotifications
condition|)
block|{
name|registeredForNotifications
operator|=
literal|false
expr_stmt|;
name|taskRunnerCallable
operator|.
name|getFragmentInfo
argument_list|()
operator|.
name|unregisterForFinishableStateUpdates
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|TaskRunnerCallable
name|getTaskRunnerCallable
parameter_list|()
block|{
return|return
name|taskRunnerCallable
return|;
block|}
specifier|public
specifier|synchronized
name|boolean
name|isInWaitQueue
parameter_list|()
block|{
return|return
name|inWaitQueue
return|;
block|}
specifier|public
specifier|synchronized
name|boolean
name|isInPreemptionQueue
parameter_list|()
block|{
return|return
name|inPreemptionQueue
return|;
block|}
specifier|public
specifier|synchronized
name|void
name|setIsInWaitQueue
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
name|this
operator|.
name|inWaitQueue
operator|=
name|value
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|void
name|setIsInPreemptableQueue
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
name|this
operator|.
name|inPreemptionQueue
operator|=
name|value
expr_stmt|;
block|}
specifier|public
name|String
name|getRequestId
parameter_list|()
block|{
return|return
name|taskRunnerCallable
operator|.
name|getRequestId
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"TaskWrapper{"
operator|+
literal|"task="
operator|+
name|taskRunnerCallable
operator|.
name|getRequestId
argument_list|()
operator|+
literal|", inWaitQueue="
operator|+
name|inWaitQueue
operator|+
literal|", inPreemptionQueue="
operator|+
name|inPreemptionQueue
operator|+
literal|", registeredForNotifications="
operator|+
name|registeredForNotifications
operator|+
literal|", canFinish="
operator|+
name|taskRunnerCallable
operator|.
name|canFinish
argument_list|()
operator|+
literal|", firstAttemptStartTime="
operator|+
name|taskRunnerCallable
operator|.
name|getFragmentRuntimeInfo
argument_list|()
operator|.
name|getFirstAttemptStartTime
argument_list|()
operator|+
literal|", dagStartTime="
operator|+
name|taskRunnerCallable
operator|.
name|getFragmentRuntimeInfo
argument_list|()
operator|.
name|getDagStartTime
argument_list|()
operator|+
literal|", withinDagPriority="
operator|+
name|taskRunnerCallable
operator|.
name|getFragmentRuntimeInfo
argument_list|()
operator|.
name|getWithinDagPriority
argument_list|()
operator|+
literal|", vertexParallelism= "
operator|+
name|taskRunnerCallable
operator|.
name|getFragmentSpec
argument_list|()
operator|.
name|getVertexParallelism
argument_list|()
operator|+
literal|", selfAndUpstreamParallelism= "
operator|+
name|taskRunnerCallable
operator|.
name|getFragmentRuntimeInfo
argument_list|()
operator|.
name|getNumSelfAndUpstreamTasks
argument_list|()
operator|+
literal|", selfAndUpstreamComplete= "
operator|+
name|taskRunnerCallable
operator|.
name|getFragmentRuntimeInfo
argument_list|()
operator|.
name|getNumSelfAndUpstreamCompletedTasks
argument_list|()
operator|+
literal|'}'
return|;
block|}
comment|// No task lock. But acquires lock on the scheduler
annotation|@
name|Override
specifier|public
name|void
name|finishableStateUpdated
parameter_list|(
name|boolean
name|finishableState
parameter_list|)
block|{
comment|// This method should not by synchronized. Can lead to deadlocks since it calls a sync method.
comment|// Meanwhile the scheduler could try updating states via a synchronized method.
name|LOG
operator|.
name|info
argument_list|(
literal|"DEBUG: Received finishable state update for {}, state={}"
argument_list|,
name|taskRunnerCallable
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|finishableState
argument_list|)
expr_stmt|;
name|taskExecutorService
operator|.
name|finishableStateUpdated
argument_list|(
name|this
argument_list|,
name|finishableState
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

