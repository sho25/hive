begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *<p/>  * http://www.apache.org/licenses/LICENSE-2.0  *<p/>  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|daemon
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|PriorityBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RejectedExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|SynchronousQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|exception
operator|.
name|ExceptionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|daemon
operator|.
name|FinishableStateUpdateHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|daemon
operator|.
name|SchedulerFragmentCompletingListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|daemon
operator|.
name|rpc
operator|.
name|LlapDaemonProtocolProtos
operator|.
name|FragmentRuntimeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|daemon
operator|.
name|rpc
operator|.
name|LlapDaemonProtocolProtos
operator|.
name|SignableVertexSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|metrics
operator|.
name|LlapDaemonExecutorMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|tezplugins
operator|.
name|helpers
operator|.
name|MonotonicClock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|AbstractService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|Clock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|runtime
operator|.
name|task
operator|.
name|EndReason
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|runtime
operator|.
name|task
operator|.
name|TaskRunner2Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|FutureCallback
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ListenableFuture
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ListeningExecutorService
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|MoreExecutors
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_comment
comment|/**  * Task executor service provides method for scheduling tasks. Tasks submitted to executor service  * are submitted to wait queue for scheduling. Wait queue tasks are ordered based on the priority  * of the task. The internal wait queue scheduler moves tasks from wait queue when executor slots  * are available or when a higher priority task arrives and will schedule it for execution.  * When pre-emption is enabled, the tasks from wait queue can replace(pre-empt) a running task.  * The pre-empted task is reported back to the Application Master(AM) for it to be rescheduled.  *<p/>  * Because of the concurrent nature of task submission, the position of the task in wait queue is  * held as long the scheduling of the task from wait queue (with or without pre-emption) is complete.  * The order of pre-emption is based on the ordering in the pre-emption queue. All tasks that cannot  * run to completion immediately (canFinish = false) are added to pre-emption queue.  *<p/>  * When all the executor threads are occupied and wait queue is full, the task scheduler will  * return SubmissionState.REJECTED response  *<p/>  * Task executor service can be shut down which will terminated all running tasks and reject all  * new tasks. Shutting down of the task executor service can be done gracefully or immediately.  */
end_comment

begin_class
specifier|public
class|class
name|TaskExecutorService
extends|extends
name|AbstractService
implements|implements
name|Scheduler
argument_list|<
name|TaskRunnerCallable
argument_list|>
implements|,
name|SchedulerFragmentCompletingListener
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TaskExecutorService
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|TASK_EXECUTOR_THREAD_NAME_FORMAT
init|=
literal|"Task-Executor-%d"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|WAIT_QUEUE_SCHEDULER_THREAD_NAME_FORMAT
init|=
literal|"Wait-Queue-Scheduler-%d"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|PREEMPTION_KILL_GRACE_MS
init|=
literal|500
decl_stmt|;
comment|// 500ms
specifier|private
specifier|static
specifier|final
name|int
name|PREEMPTION_KILL_GRACE_SLEEP_MS
init|=
literal|50
decl_stmt|;
comment|// 50ms
specifier|private
specifier|final
name|AtomicBoolean
name|isShutdown
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|// Thread pool for actual execution of work.
specifier|private
specifier|final
name|ListeningExecutorService
name|executorService
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
name|EvictingPriorityBlockingQueue
argument_list|<
name|TaskWrapper
argument_list|>
name|waitQueue
decl_stmt|;
comment|// Thread pool for taking entities off the wait queue.
specifier|private
specifier|final
name|ListeningExecutorService
name|waitQueueExecutorService
decl_stmt|;
comment|// Thread pool for callbacks on completion of execution of a work unit.
specifier|private
specifier|final
name|ListeningExecutorService
name|executionCompletionExecutorService
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
name|BlockingQueue
argument_list|<
name|TaskWrapper
argument_list|>
name|preemptionQueue
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|enablePreemption
decl_stmt|;
specifier|private
specifier|final
name|ThreadPoolExecutor
name|threadPoolExecutor
decl_stmt|;
specifier|private
specifier|final
name|AtomicInteger
name|numSlotsAvailable
decl_stmt|;
specifier|private
specifier|final
name|int
name|maxParallelExecutors
decl_stmt|;
specifier|private
specifier|final
name|Clock
name|clock
decl_stmt|;
comment|// Tracks running fragments, and completing fragments.
comment|// Completing since we have a race in the AM being notified and the task actually
comment|// falling off, and the executor service being ready to schedule a new task.
specifier|private
specifier|final
name|AtomicInteger
name|runningFragmentCount
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
annotation|@
name|VisibleForTesting
comment|// Tracks known tasks.
specifier|final
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|TaskWrapper
argument_list|>
name|knownTasks
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Object
name|lock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|LlapDaemonExecutorMetrics
name|metrics
decl_stmt|;
specifier|public
name|TaskExecutorService
parameter_list|(
name|int
name|numExecutors
parameter_list|,
name|int
name|waitQueueSize
parameter_list|,
name|String
name|waitQueueComparatorClassName
parameter_list|,
name|boolean
name|enablePreemption
parameter_list|,
name|ClassLoader
name|classLoader
parameter_list|,
specifier|final
name|LlapDaemonExecutorMetrics
name|metrics
parameter_list|,
name|Clock
name|clock
parameter_list|)
block|{
name|super
argument_list|(
name|TaskExecutorService
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"TaskExecutorService is being setup with parameters: "
operator|+
literal|"numExecutors="
operator|+
name|numExecutors
operator|+
literal|", waitQueueSize="
operator|+
name|waitQueueSize
operator|+
literal|", waitQueueComparatorClassName="
operator|+
name|waitQueueComparatorClassName
operator|+
literal|", enablePreemption="
operator|+
name|enablePreemption
argument_list|)
expr_stmt|;
specifier|final
name|Comparator
argument_list|<
name|TaskWrapper
argument_list|>
name|waitQueueComparator
init|=
name|createComparator
argument_list|(
name|waitQueueComparatorClassName
argument_list|)
decl_stmt|;
name|this
operator|.
name|maxParallelExecutors
operator|=
name|numExecutors
expr_stmt|;
name|this
operator|.
name|waitQueue
operator|=
operator|new
name|EvictingPriorityBlockingQueue
argument_list|<>
argument_list|(
name|waitQueueComparator
argument_list|,
name|waitQueueSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|clock
operator|=
name|clock
operator|==
literal|null
condition|?
operator|new
name|MonotonicClock
argument_list|()
else|:
name|clock
expr_stmt|;
name|this
operator|.
name|threadPoolExecutor
operator|=
operator|new
name|ThreadPoolExecutor
argument_list|(
name|numExecutors
argument_list|,
comment|// core pool size
name|numExecutors
argument_list|,
comment|// max pool size
literal|1
argument_list|,
name|TimeUnit
operator|.
name|MINUTES
argument_list|,
operator|new
name|SynchronousQueue
argument_list|<
name|Runnable
argument_list|>
argument_list|()
argument_list|,
comment|// direct hand-off
operator|new
name|ExecutorThreadFactory
argument_list|(
name|classLoader
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|=
name|MoreExecutors
operator|.
name|listeningDecorator
argument_list|(
name|threadPoolExecutor
argument_list|)
expr_stmt|;
name|this
operator|.
name|preemptionQueue
operator|=
operator|new
name|PriorityBlockingQueue
argument_list|<>
argument_list|(
name|numExecutors
argument_list|,
operator|new
name|PreemptionQueueComparator
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|enablePreemption
operator|=
name|enablePreemption
expr_stmt|;
name|this
operator|.
name|numSlotsAvailable
operator|=
operator|new
name|AtomicInteger
argument_list|(
name|numExecutors
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|=
name|metrics
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setNumExecutorsAvailable
argument_list|(
name|numSlotsAvailable
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// single threaded scheduler for tasks from wait queue to executor threads
name|ExecutorService
name|wes
init|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
literal|1
argument_list|,
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
name|WAIT_QUEUE_SCHEDULER_THREAD_NAME_FORMAT
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|this
operator|.
name|waitQueueExecutorService
operator|=
name|MoreExecutors
operator|.
name|listeningDecorator
argument_list|(
name|wes
argument_list|)
expr_stmt|;
name|ExecutorService
name|executionCompletionExecutorServiceRaw
init|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
literal|1
argument_list|,
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
literal|"ExecutionCompletionThread #%d"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|executionCompletionExecutorService
operator|=
name|MoreExecutors
operator|.
name|listeningDecorator
argument_list|(
name|executionCompletionExecutorServiceRaw
argument_list|)
expr_stmt|;
name|ListenableFuture
argument_list|<
name|?
argument_list|>
name|future
init|=
name|waitQueueExecutorService
operator|.
name|submit
argument_list|(
operator|new
name|WaitQueueWorker
argument_list|()
argument_list|)
decl_stmt|;
name|Futures
operator|.
name|addCallback
argument_list|(
name|future
argument_list|,
operator|new
name|WaitQueueWorkerCallback
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Comparator
argument_list|<
name|TaskWrapper
argument_list|>
name|createComparator
parameter_list|(
name|String
name|waitQueueComparatorClassName
parameter_list|)
block|{
specifier|final
name|Comparator
argument_list|<
name|TaskWrapper
argument_list|>
name|waitQueueComparator
decl_stmt|;
try|try
block|{
name|Class
argument_list|<
name|?
extends|extends
name|Comparator
argument_list|>
name|waitQueueComparatorClazz
init|=
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|Comparator
argument_list|>
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|waitQueueComparatorClassName
argument_list|)
decl_stmt|;
name|Constructor
argument_list|<
name|?
extends|extends
name|Comparator
argument_list|>
name|ctor
init|=
name|waitQueueComparatorClazz
operator|.
name|getConstructor
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|waitQueueComparator
operator|=
name|ctor
operator|.
name|newInstance
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed to load wait queue comparator, class="
operator|+
name|waitQueueComparatorClassName
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed to find constructor for wait queue comparator, class="
operator|+
name|waitQueueComparatorClassName
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
decl||
name|InstantiationException
decl||
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed to find instantiate wait queue comparator, class="
operator|+
name|waitQueueComparatorClassName
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|waitQueueComparator
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|serviceStop
parameter_list|()
block|{
name|shutDown
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|SimpleDateFormat
argument_list|>
name|sdf
init|=
operator|new
name|ThreadLocal
argument_list|<
name|SimpleDateFormat
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|SimpleDateFormat
name|initialValue
parameter_list|()
block|{
return|return
operator|new
name|SimpleDateFormat
argument_list|(
literal|"yyyy-MM-dd HH:mm:ss"
argument_list|)
return|;
block|}
block|}
decl_stmt|;
annotation|@
name|Override
specifier|public
name|int
name|getNumActive
parameter_list|()
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|TaskWrapper
argument_list|>
name|e
range|:
name|knownTasks
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|TaskWrapper
name|task
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|task
operator|.
name|isInWaitQueue
argument_list|()
condition|)
continue|continue;
name|TaskRunnerCallable
name|c
init|=
name|task
operator|.
name|getTaskRunnerCallable
argument_list|()
decl_stmt|;
comment|// Count the tasks in intermediate state as waiting.
if|if
condition|(
name|c
operator|==
literal|null
operator|||
name|c
operator|.
name|getStartTime
argument_list|()
operator|==
literal|0
condition|)
continue|continue;
operator|++
name|result
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getExecutorsStatus
parameter_list|()
block|{
comment|// TODO Change this method to make the output easier to parse (parse programmatically)
name|Set
argument_list|<
name|String
argument_list|>
name|result
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|running
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|waiting
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|StringBuilder
name|value
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|TaskWrapper
argument_list|>
name|queueState
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Note: we don't take the scheduling lock here, although the call to queue is still
comment|//       synchronized. Best-effort to display the queue in order.
name|waitQueue
operator|.
name|apply
argument_list|(
operator|new
name|Function
argument_list|<
name|TaskWrapper
argument_list|,
name|Boolean
argument_list|>
argument_list|()
block|{
specifier|public
name|Boolean
name|apply
parameter_list|(
name|TaskWrapper
name|input
parameter_list|)
block|{
name|queueState
operator|.
name|add
argument_list|(
name|input
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|HashSet
argument_list|<
name|TaskWrapper
argument_list|>
name|queueHs
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|TaskWrapper
name|task
range|:
name|queueState
control|)
block|{
name|describeTask
argument_list|(
name|value
argument_list|,
name|task
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|task
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|waiting
operator|.
name|add
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|queueHs
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|TaskWrapper
argument_list|>
name|e
range|:
name|knownTasks
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|attemptId
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|TaskWrapper
name|task
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|queueHs
operator|.
name|contains
argument_list|(
name|task
argument_list|)
condition|)
block|{
comment|// Even if the state has changed, don't log it twice.
continue|continue;
block|}
name|boolean
name|isWaiting
init|=
name|describeTask
argument_list|(
name|value
argument_list|,
name|attemptId
argument_list|,
name|task
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|isWaiting
condition|)
block|{
name|waiting
operator|.
name|add
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|running
operator|.
name|add
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|.
name|addAll
argument_list|(
name|waiting
argument_list|)
expr_stmt|;
name|result
operator|.
name|addAll
argument_list|(
name|running
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
name|boolean
name|describeTask
parameter_list|(
name|StringBuilder
name|value
parameter_list|,
name|String
name|attemptId
parameter_list|,
name|TaskWrapper
name|task
parameter_list|,
name|boolean
name|fromQueue
parameter_list|)
block|{
name|value
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|boolean
name|isFirst
init|=
literal|true
decl_stmt|;
name|TaskRunnerCallable
name|c
init|=
name|task
operator|.
name|getTaskRunnerCallable
argument_list|()
decl_stmt|;
name|value
operator|.
name|append
argument_list|(
name|attemptId
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
operator|&&
name|c
operator|.
name|getVertexSpec
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|SignableVertexSpec
name|fs
init|=
name|c
operator|.
name|getVertexSpec
argument_list|()
decl_stmt|;
name|value
operator|.
name|append
argument_list|(
name|isFirst
condition|?
literal|" ("
else|:
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|c
operator|.
name|getQueryId
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"/"
argument_list|)
operator|.
name|append
argument_list|(
name|fs
operator|.
name|getVertexName
argument_list|()
argument_list|)
expr_stmt|;
name|isFirst
operator|=
literal|false
expr_stmt|;
block|}
name|value
operator|.
name|append
argument_list|(
name|isFirst
condition|?
literal|" ("
else|:
literal|", "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromQueue
condition|)
block|{
name|value
operator|.
name|append
argument_list|(
literal|"in queue (in order)"
argument_list|)
expr_stmt|;
block|}
name|boolean
name|isWaiting
decl_stmt|;
if|if
condition|(
name|task
operator|.
name|isInWaitQueue
argument_list|()
condition|)
block|{
name|isWaiting
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|fromQueue
condition|)
block|{
name|value
operator|.
name|append
argument_list|(
literal|"in queue (not in order)"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
name|long
name|startTime
init|=
name|c
operator|.
name|getStartTime
argument_list|()
decl_stmt|;
name|isWaiting
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|startTime
operator|!=
literal|0
condition|)
block|{
name|value
operator|.
name|append
argument_list|(
literal|"started at "
argument_list|)
operator|.
name|append
argument_list|(
name|sdf
operator|.
name|get
argument_list|()
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|(
name|startTime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|.
name|append
argument_list|(
literal|"not started"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|isWaiting
operator|=
literal|true
expr_stmt|;
name|value
operator|.
name|append
argument_list|(
literal|"has no callable"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|task
operator|.
name|isInPreemptionQueue
argument_list|()
condition|)
block|{
name|value
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
literal|"in preemption queue"
argument_list|)
expr_stmt|;
block|}
name|boolean
name|canFinish
init|=
name|c
operator|.
name|canFinish
argument_list|()
decl_stmt|;
name|value
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|canFinish
condition|?
literal|"can"
else|:
literal|"cannot"
argument_list|)
operator|.
name|append
argument_list|(
literal|" finish"
argument_list|)
expr_stmt|;
if|if
condition|(
name|canFinish
operator|!=
name|c
operator|.
name|canFinishForPriority
argument_list|()
condition|)
block|{
name|value
operator|.
name|append
argument_list|(
literal|" (not updated in queue)"
argument_list|)
expr_stmt|;
block|}
name|value
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return
name|isWaiting
return|;
block|}
comment|/**    * Worker that takes tasks from wait queue and schedule it for execution.    */
specifier|private
specifier|final
class|class
name|WaitQueueWorker
implements|implements
name|Runnable
block|{
specifier|private
specifier|static
specifier|final
name|long
name|SANITY_CHECK_TIMEOUT_MS
init|=
literal|1000
decl_stmt|;
specifier|private
name|TaskWrapper
name|task
decl_stmt|;
specifier|private
name|Long
name|nextSanityCheck
init|=
literal|null
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|Long
name|lastKillTimeMs
init|=
literal|null
decl_stmt|;
name|SanityChecker
name|sc
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|!
name|isShutdown
operator|.
name|get
argument_list|()
condition|)
block|{
name|RejectedExecutionException
name|rejectedException
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|nextSanityCheck
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|nextSanityCheck
operator|-
name|System
operator|.
name|nanoTime
argument_list|()
operator|)
operator|<=
literal|0
operator|)
condition|)
block|{
name|sc
operator|=
name|sanityCheckQueue
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|nextSanityCheck
operator|=
literal|null
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|lock
init|)
block|{
comment|// Since schedule() can be called from multiple threads, we peek the wait queue, try
comment|// scheduling the task and then remove the task if scheduling is successful. This
comment|// will make sure the task's place in the wait queue is held until it gets scheduled.
name|task
operator|=
name|waitQueue
operator|.
name|peek
argument_list|()
expr_stmt|;
if|if
condition|(
name|task
operator|==
literal|null
condition|)
block|{
name|waitOnLock
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|// If the task cannot finish and if no slots are available then don't schedule it.
comment|// Also don't wait if we have a task and we just killed something to schedule it.
comment|// (numSlotsAvailable can go negative, if the callback after the thread completes is delayed)
name|boolean
name|shouldWait
init|=
name|numSlotsAvailable
operator|.
name|get
argument_list|()
operator|<=
literal|0
operator|&&
name|lastKillTimeMs
operator|==
literal|null
decl_stmt|;
if|if
condition|(
name|task
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|canFinish
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting to schedule task {}, canFinish={}. Current state: "
operator|+
literal|"preemptionQueueSize={}, numSlotsAvailable={}, waitQueueSize={}"
argument_list|,
name|task
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|task
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|canFinish
argument_list|()
argument_list|,
name|preemptionQueue
operator|.
name|size
argument_list|()
argument_list|,
name|numSlotsAvailable
operator|.
name|get
argument_list|()
argument_list|,
name|waitQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|shouldWait
operator|=
name|shouldWait
operator|&&
operator|(
name|enablePreemption
operator|==
literal|false
operator|||
name|preemptionQueue
operator|.
name|isEmpty
argument_list|()
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|shouldWait
condition|)
block|{
name|waitOnLock
argument_list|()
expr_stmt|;
comment|// Another task at a higher priority may have come in during the wait. Lookup the
comment|// queue again to pick up the task at the highest priority.
continue|continue;
block|}
name|nextSanityCheck
operator|=
literal|null
expr_stmt|;
comment|// We are going to do something useful now.
try|try
block|{
name|tryScheduleUnderLock
argument_list|(
name|task
argument_list|)
expr_stmt|;
comment|// Wait queue could have been re-ordered in the mean time because of concurrent task
comment|// submission. So remove the specific task instead of the head task.
if|if
condition|(
name|waitQueue
operator|.
name|remove
argument_list|(
name|task
argument_list|)
condition|)
block|{
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setExecutorNumQueuedRequests
argument_list|(
name|waitQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|lastKillTimeMs
operator|=
literal|null
expr_stmt|;
comment|// We have filled the spot we may have killed for (if any).
block|}
catch|catch
parameter_list|(
name|RejectedExecutionException
name|e
parameter_list|)
block|{
name|rejectedException
operator|=
name|e
expr_stmt|;
block|}
block|}
comment|// synchronized (lock)
comment|// Handle the rejection outside of the lock
if|if
condition|(
name|rejectedException
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|lastKillTimeMs
operator|!=
literal|null
operator|&&
operator|(
name|clock
operator|.
name|getTime
argument_list|()
operator|-
name|lastKillTimeMs
operator|)
operator|<
name|PREEMPTION_KILL_GRACE_MS
condition|)
block|{
comment|// We killed something, but still got rejected. Wait a bit to give a chance to our
comment|// previous victim to actually die.
synchronized|synchronized
init|(
name|lock
init|)
block|{
name|lock
operator|.
name|wait
argument_list|(
name|PREEMPTION_KILL_GRACE_SLEEP_MS
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
name|lastKillTimeMs
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Grace period ended for the previous kill; preemtping more tasks"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|handleScheduleAttemptedRejection
argument_list|(
name|task
argument_list|)
condition|)
block|{
name|lastKillTimeMs
operator|=
name|clock
operator|.
name|getTime
argument_list|()
expr_stmt|;
comment|// We killed something.
block|}
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isShutdown
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|WAIT_QUEUE_SCHEDULER_THREAD_NAME_FORMAT
operator|+
literal|" thread has been interrupted after shutdown."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|WAIT_QUEUE_SCHEDULER_THREAD_NAME_FORMAT
operator|+
literal|" interrupted without shutdown"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|void
name|waitOnLock
parameter_list|()
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|isShutdown
operator|.
name|get
argument_list|()
condition|)
return|return;
name|nextSanityCheck
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
name|SANITY_CHECK_TIMEOUT_MS
operator|*
literal|1000000L
expr_stmt|;
name|lock
operator|.
name|wait
argument_list|(
name|SANITY_CHECK_TIMEOUT_MS
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
class|class
name|WaitQueueWorkerCallback
implements|implements
name|FutureCallback
block|{
annotation|@
name|Override
specifier|public
name|void
name|onSuccess
parameter_list|(
name|Object
name|result
parameter_list|)
block|{
if|if
condition|(
name|isShutdown
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Wait queue scheduler worker exited with success!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Wait queue scheduler worker exited with success!"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|getDefaultUncaughtExceptionHandler
argument_list|()
operator|.
name|uncaughtException
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|,
operator|new
name|IllegalStateException
argument_list|(
literal|"WaitQueue worked exited before shutdown"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Wait queue scheduler worker exited with failure!"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|getDefaultUncaughtExceptionHandler
argument_list|()
operator|.
name|uncaughtException
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|SubmissionState
name|schedule
parameter_list|(
name|TaskRunnerCallable
name|task
parameter_list|)
block|{
name|TaskWrapper
name|taskWrapper
init|=
operator|new
name|TaskWrapper
argument_list|(
name|task
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|SubmissionState
name|result
decl_stmt|;
name|TaskWrapper
name|evictedTask
decl_stmt|;
name|boolean
name|canFinish
decl_stmt|;
synchronized|synchronized
init|(
name|lock
init|)
block|{
comment|// If the queue does not have capacity, it does not throw a Rejection. Instead it will
comment|// return the task with the lowest priority, which could be the task which is currently being processed.
comment|// TODO HIVE-11687 It's possible for a bunch of tasks to come in around the same time, without the
comment|// actual executor threads picking up any work. This will lead to unnecessary rejection of tasks.
comment|// The wait queue should be able to fit at least (waitQueue + currentFreeExecutor slots)
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Offering to wait queue with: waitQueueSize={}, numSlotsAvailable={}, runningFragmentCount={} "
argument_list|,
name|waitQueue
operator|.
name|size
argument_list|()
argument_list|,
name|numSlotsAvailable
operator|.
name|get
argument_list|()
argument_list|,
name|runningFragmentCount
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|canFinish
operator|=
name|taskWrapper
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|canFinish
argument_list|()
expr_stmt|;
name|taskWrapper
operator|.
name|updateCanFinishForPriority
argument_list|(
name|canFinish
argument_list|)
expr_stmt|;
comment|// Update the property before offering.
name|evictedTask
operator|=
name|waitQueue
operator|.
name|offer
argument_list|(
name|taskWrapper
argument_list|,
name|maxParallelExecutors
operator|-
name|runningFragmentCount
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
comment|// Finishable state is checked on the task, via an explicit query to the TaskRunnerCallable
comment|// null evicted task means offer accepted
comment|// evictedTask is not equal taskWrapper means current task is accepted and it evicted
comment|// some other task
if|if
condition|(
name|evictedTask
operator|==
literal|null
operator|||
operator|!
name|evictedTask
operator|.
name|equals
argument_list|(
name|taskWrapper
argument_list|)
condition|)
block|{
name|knownTasks
operator|.
name|put
argument_list|(
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|taskWrapper
argument_list|)
expr_stmt|;
name|taskWrapper
operator|.
name|setIsInWaitQueue
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{} added to wait queue. Current wait queue size={}"
argument_list|,
name|task
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|waitQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|evictedTask
operator|==
literal|null
condition|?
name|SubmissionState
operator|.
name|ACCEPTED
else|:
name|SubmissionState
operator|.
name|EVICTED_OTHER
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
name|evictedTask
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Eviction: {} {} {}"
argument_list|,
name|taskWrapper
argument_list|,
name|result
argument_list|,
name|evictedTask
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"wait queue full, size={}. numSlotsAvailable={}, runningFragmentCount={}. {} not added"
argument_list|,
name|waitQueue
operator|.
name|size
argument_list|()
argument_list|,
name|numSlotsAvailable
operator|.
name|get
argument_list|()
argument_list|,
name|runningFragmentCount
operator|.
name|get
argument_list|()
argument_list|,
name|task
operator|.
name|getRequestId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|evictedTask
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|killTask
argument_list|()
expr_stmt|;
name|result
operator|=
name|SubmissionState
operator|.
name|REJECTED
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{} is {} as wait queue is full"
argument_list|,
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrTotalRejectedRequests
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|// Register for notifications inside the lock. Should avoid races with unregisterForNotifications
comment|// happens in a different Submission thread. i.e. Avoid register running for this task
comment|// after some other submission has evicted it.
name|boolean
name|stateChanged
init|=
operator|!
name|taskWrapper
operator|.
name|maybeRegisterForFinishedStateNotifications
argument_list|(
name|canFinish
argument_list|)
decl_stmt|;
if|if
condition|(
name|stateChanged
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Finishable state of {} updated to {} during registration for state updates"
argument_list|,
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|,
operator|!
name|canFinish
argument_list|)
expr_stmt|;
block|}
name|finishableStateUpdated
argument_list|(
name|taskWrapper
argument_list|,
operator|!
name|canFinish
argument_list|)
expr_stmt|;
block|}
block|}
comment|// At this point, the task has been added into the queue. It may have caused an eviction for
comment|// some other task.
comment|// This registration has to be done after knownTasks has been populated.
comment|// Register for state change notifications so that the waitQueue can be re-ordered correctly
comment|// if the fragment moves in or out of the finishable state.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Wait Queue: {}"
argument_list|,
name|waitQueue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|evictedTask
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"{} evicted from wait queue in favor of {} because of lower priority"
argument_list|,
name|evictedTask
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|task
operator|.
name|getRequestId
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|knownTasks
operator|.
name|remove
argument_list|(
name|evictedTask
operator|.
name|getRequestId
argument_list|()
argument_list|)
expr_stmt|;
name|evictedTask
operator|.
name|maybeUnregisterForFinishedStateNotifications
argument_list|()
expr_stmt|;
name|evictedTask
operator|.
name|setIsInWaitQueue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// This is dealing with tasks from a different submission, and cause the kill
comment|// to go out before the previous submissions has completed. Handled in the AM
name|evictedTask
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|killTask
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrTotalEvictedFromWaitQueue
argument_list|()
expr_stmt|;
block|}
block|}
synchronized|synchronized
init|(
name|lock
init|)
block|{
name|lock
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setExecutorNumQueuedRequests
argument_list|(
name|waitQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|QueryIdentifier
name|findQueryByFragment
parameter_list|(
name|String
name|fragmentId
parameter_list|)
block|{
synchronized|synchronized
init|(
name|lock
init|)
block|{
name|TaskWrapper
name|taskWrapper
init|=
name|knownTasks
operator|.
name|get
argument_list|(
name|fragmentId
argument_list|)
decl_stmt|;
return|return
name|taskWrapper
operator|==
literal|null
condition|?
literal|null
else|:
name|taskWrapper
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|getFragmentInfo
argument_list|()
operator|.
name|getQueryInfo
argument_list|()
operator|.
name|getQueryIdentifier
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|killFragment
parameter_list|(
name|String
name|fragmentId
parameter_list|)
block|{
synchronized|synchronized
init|(
name|lock
init|)
block|{
name|TaskWrapper
name|taskWrapper
init|=
name|knownTasks
operator|.
name|remove
argument_list|(
name|fragmentId
argument_list|)
decl_stmt|;
comment|// Can be null since the task may have completed meanwhile.
if|if
condition|(
name|taskWrapper
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|taskWrapper
operator|.
name|isInWaitQueue
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing {} from waitQueue"
argument_list|,
name|fragmentId
argument_list|)
expr_stmt|;
block|}
name|taskWrapper
operator|.
name|setIsInWaitQueue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitQueue
operator|.
name|remove
argument_list|(
name|taskWrapper
argument_list|)
condition|)
block|{
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setExecutorNumQueuedRequests
argument_list|(
name|waitQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|taskWrapper
operator|.
name|isInPreemptionQueue
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing {} from preemptionQueue"
argument_list|,
name|fragmentId
argument_list|)
expr_stmt|;
block|}
name|removeFromPreemptionQueue
argument_list|(
name|taskWrapper
argument_list|)
expr_stmt|;
block|}
name|taskWrapper
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|killTask
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignoring killFragment request for {} since it isn't known"
argument_list|,
name|fragmentId
argument_list|)
expr_stmt|;
block|}
name|lock
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
specifier|final
class|class
name|FragmentCompletion
block|{
specifier|public
name|FragmentCompletion
parameter_list|(
name|State
name|state
parameter_list|,
name|long
name|completingTime
parameter_list|)
block|{
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|this
operator|.
name|completingTime
operator|=
name|completingTime
expr_stmt|;
block|}
name|State
name|state
decl_stmt|;
name|long
name|completingTime
decl_stmt|;
block|}
annotation|@
name|VisibleForTesting
specifier|final
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|FragmentCompletion
argument_list|>
name|completingFragmentMap
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|fragmentCompleting
parameter_list|(
name|String
name|fragmentId
parameter_list|,
name|State
name|state
parameter_list|)
block|{
name|int
name|count
init|=
name|runningFragmentCount
operator|.
name|decrementAndGet
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"RunningFragmentCount went negative. Multiple calls for the same completion. Resetting to 0"
argument_list|)
expr_stmt|;
name|runningFragmentCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|completingFragmentMap
operator|.
name|put
argument_list|(
name|fragmentId
argument_list|,
operator|new
name|FragmentCompletion
argument_list|(
name|state
argument_list|,
name|clock
operator|.
name|getTime
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
comment|/** Assumes the epic lock is already taken. */
name|void
name|tryScheduleUnderLock
parameter_list|(
specifier|final
name|TaskWrapper
name|taskWrapper
parameter_list|)
throws|throws
name|RejectedExecutionException
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Attempting to execute {}"
argument_list|,
name|taskWrapper
argument_list|)
expr_stmt|;
block|}
name|ListenableFuture
argument_list|<
name|TaskRunner2Result
argument_list|>
name|future
init|=
name|executorService
operator|.
name|submit
argument_list|(
name|taskWrapper
operator|.
name|getTaskRunnerCallable
argument_list|()
argument_list|)
decl_stmt|;
name|runningFragmentCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|taskWrapper
operator|.
name|setIsInWaitQueue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|FutureCallback
argument_list|<
name|TaskRunner2Result
argument_list|>
name|wrappedCallback
init|=
name|createInternalCompletionListener
argument_list|(
name|taskWrapper
argument_list|)
decl_stmt|;
comment|// Callback on a separate thread so that when a task completes, the thread in the main queue
comment|// is actually available for execution and will not potentially result in a RejectedExecution
name|Futures
operator|.
name|addCallback
argument_list|(
name|future
argument_list|,
name|wrappedCallback
argument_list|,
name|executionCompletionExecutorService
argument_list|)
expr_stmt|;
name|boolean
name|canFinish
init|=
name|taskWrapper
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|canFinish
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{} scheduled for execution. canFinish={}"
argument_list|,
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|canFinish
argument_list|)
expr_stmt|;
block|}
comment|// only tasks that cannot finish immediately are pre-emptable. In other words, if all inputs
comment|// to the tasks are not ready yet, the task is eligible for pre-emptable.
if|if
condition|(
name|enablePreemption
condition|)
block|{
if|if
condition|(
operator|!
name|canFinish
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"{} is not finishable. Adding it to pre-emption queue"
argument_list|,
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|addToPreemptionQueue
argument_list|(
name|taskWrapper
argument_list|)
expr_stmt|;
block|}
block|}
name|numSlotsAvailable
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setNumExecutorsAvailable
argument_list|(
name|numSlotsAvailable
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|handleScheduleAttemptedRejection
parameter_list|(
name|TaskWrapper
name|taskWrapper
parameter_list|)
block|{
if|if
condition|(
name|enablePreemption
operator|&&
name|taskWrapper
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|canFinish
argument_list|()
operator|&&
operator|!
name|preemptionQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Preemption Queue: "
operator|+
name|preemptionQueue
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|true
condition|)
block|{
comment|// Try to preempt until we have something.
name|TaskWrapper
name|pRequest
init|=
name|removeAndGetNextFromPreemptionQueue
argument_list|()
decl_stmt|;
if|if
condition|(
name|pRequest
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
comment|// Woe us.
block|}
if|if
condition|(
name|pRequest
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|canFinish
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removed {} from preemption queue, but not preempting since it's now finishable"
argument_list|,
name|pRequest
operator|.
name|getRequestId
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
comment|// Try something else.
block|}
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Invoking kill task for {} due to pre-emption to run {}"
argument_list|,
name|pRequest
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// The task will either be killed or is already in the process of completing, which will
comment|// trigger the next scheduling run, or result in available slots being higher than 0,
comment|// which will cause the scheduler loop to continue.
name|pRequest
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|killTask
argument_list|()
expr_stmt|;
comment|// We've killed something and may want to wait for it to die.
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
specifier|static
class|class
name|SanityChecker
implements|implements
name|Function
argument_list|<
name|TaskWrapper
argument_list|,
name|Boolean
argument_list|>
block|{
specifier|private
name|TaskWrapper
name|firstCannotFinish
init|=
literal|null
decl_stmt|;
specifier|private
name|TaskWrapper
name|firstProblematic
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|EvictingPriorityBlockingQueue
argument_list|<
name|TaskWrapper
argument_list|>
name|queue
decl_stmt|;
specifier|public
name|SanityChecker
parameter_list|(
name|EvictingPriorityBlockingQueue
argument_list|<
name|TaskWrapper
argument_list|>
name|queue
parameter_list|)
block|{
name|this
operator|.
name|queue
operator|=
name|queue
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|apply
parameter_list|(
name|TaskWrapper
name|input
parameter_list|)
block|{
if|if
condition|(
name|input
operator|==
literal|null
condition|)
return|return
literal|true
return|;
name|boolean
name|canFinish
init|=
name|input
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|canFinishForPriority
argument_list|()
decl_stmt|;
if|if
condition|(
name|firstCannotFinish
operator|==
literal|null
operator|&&
operator|!
name|canFinish
condition|)
block|{
name|firstCannotFinish
operator|=
name|input
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|firstCannotFinish
operator|!=
literal|null
operator|&&
name|canFinish
condition|)
block|{
name|firstProblematic
operator|=
name|input
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
name|void
name|run
parameter_list|()
block|{
name|queue
operator|.
name|apply
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstProblematic
operator|!=
literal|null
condition|)
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"Found finishable task behind non-finishable in the queue: "
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|firstProblematic
argument_list|)
operator|.
name|append
argument_list|(
literal|" was after "
argument_list|)
operator|.
name|append
argument_list|(
name|firstCannotFinish
argument_list|)
operator|.
name|append
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
name|queue
operator|.
name|apply
argument_list|(
operator|new
name|Function
argument_list|<
name|TaskExecutorService
operator|.
name|TaskWrapper
argument_list|,
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|apply
parameter_list|(
name|TaskWrapper
name|input
parameter_list|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|input
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|firstCannotFinish
operator|=
name|firstProblematic
operator|=
literal|null
expr_stmt|;
block|}
block|}
specifier|private
name|SanityChecker
name|sanityCheckQueue
parameter_list|(
name|SanityChecker
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|==
literal|null
condition|)
block|{
name|sc
operator|=
operator|new
name|SanityChecker
argument_list|(
name|waitQueue
argument_list|)
expr_stmt|;
block|}
name|sc
operator|.
name|run
argument_list|()
expr_stmt|;
return|return
name|sc
return|;
block|}
specifier|private
name|void
name|finishableStateUpdated
parameter_list|(
name|TaskWrapper
name|taskWrapper
parameter_list|,
name|boolean
name|newFinishableState
parameter_list|)
block|{
synchronized|synchronized
init|(
name|lock
init|)
block|{
if|if
condition|(
name|taskWrapper
operator|.
name|isInWaitQueue
argument_list|()
condition|)
block|{
comment|// Re-order the wait queue. Note: we assume that noone will take our capacity based
comment|// on the fact that we are doing this under the epic lock. If the epic lock is removed,
comment|// we'd need to do the steps under the queue lock; we could pass in a f() to update state.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Re-ordering the wait queue since {} finishable state moved to {}"
argument_list|,
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|newFinishableState
argument_list|)
expr_stmt|;
name|boolean
name|isRemoved
init|=
name|waitQueue
operator|.
name|remove
argument_list|(
name|taskWrapper
argument_list|)
decl_stmt|;
name|taskWrapper
operator|.
name|updateCanFinishForPriority
argument_list|(
name|newFinishableState
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isRemoved
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to remove {} from waitQueue"
argument_list|,
name|taskWrapper
operator|.
name|getTaskRunnerCallable
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|waitQueue
operator|.
name|forceOffer
argument_list|(
name|taskWrapper
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newFinishableState
operator|==
literal|true
operator|&&
name|taskWrapper
operator|.
name|isInPreemptionQueue
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing {} from preemption queue because it's state changed to {}"
argument_list|,
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|newFinishableState
argument_list|)
expr_stmt|;
name|removeFromPreemptionQueue
argument_list|(
name|taskWrapper
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newFinishableState
operator|==
literal|false
operator|&&
operator|!
name|taskWrapper
operator|.
name|isInPreemptionQueue
argument_list|()
operator|&&
operator|!
name|taskWrapper
operator|.
name|isInWaitQueue
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding {} to preemption queue since finishable state changed to {}"
argument_list|,
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|newFinishableState
argument_list|)
expr_stmt|;
name|addToPreemptionQueue
argument_list|(
name|taskWrapper
argument_list|)
expr_stmt|;
block|}
name|lock
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|addToPreemptionQueue
parameter_list|(
name|TaskWrapper
name|taskWrapper
parameter_list|)
block|{
synchronized|synchronized
init|(
name|lock
init|)
block|{
name|boolean
name|added
init|=
name|preemptionQueue
operator|.
name|offer
argument_list|(
name|taskWrapper
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|added
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to add element {} to preemption queue. Terminating"
argument_list|,
name|taskWrapper
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|getDefaultUncaughtExceptionHandler
argument_list|()
operator|.
name|uncaughtException
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|,
operator|new
name|IllegalStateException
argument_list|(
literal|"Preemption queue full. Cannot proceed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|taskWrapper
operator|.
name|setIsInPreemptableQueue
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setExecutorNumPreemptableRequests
argument_list|(
name|preemptionQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Remove the specified taskWrapper from the preemption queue    * @param taskWrapper the taskWrapper to be removed    * @return true if the element existed in the queue and wasa removed, false otherwise    */
specifier|private
name|boolean
name|removeFromPreemptionQueue
parameter_list|(
name|TaskWrapper
name|taskWrapper
parameter_list|)
block|{
synchronized|synchronized
init|(
name|lock
init|)
block|{
return|return
name|removeFromPreemptionQueueUnlocked
argument_list|(
name|taskWrapper
argument_list|)
return|;
block|}
block|}
specifier|private
name|boolean
name|removeFromPreemptionQueueUnlocked
parameter_list|(
name|TaskWrapper
name|taskWrapper
parameter_list|)
block|{
name|boolean
name|removed
init|=
name|preemptionQueue
operator|.
name|remove
argument_list|(
name|taskWrapper
argument_list|)
decl_stmt|;
name|taskWrapper
operator|.
name|setIsInPreemptableQueue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setExecutorNumPreemptableRequests
argument_list|(
name|preemptionQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|removed
return|;
block|}
specifier|private
name|TaskWrapper
name|removeAndGetNextFromPreemptionQueue
parameter_list|()
block|{
name|TaskWrapper
name|taskWrapper
decl_stmt|;
synchronized|synchronized
init|(
name|lock
init|)
block|{
name|taskWrapper
operator|=
name|preemptionQueue
operator|.
name|poll
argument_list|()
expr_stmt|;
if|if
condition|(
name|taskWrapper
operator|!=
literal|null
condition|)
block|{
name|taskWrapper
operator|.
name|setIsInPreemptableQueue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setExecutorNumPreemptableRequests
argument_list|(
name|preemptionQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|taskWrapper
return|;
block|}
annotation|@
name|VisibleForTesting
name|InternalCompletionListener
name|createInternalCompletionListener
parameter_list|(
name|TaskWrapper
name|taskWrapper
parameter_list|)
block|{
return|return
operator|new
name|InternalCompletionListener
argument_list|(
name|taskWrapper
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
class|class
name|InternalCompletionListener
implements|implements
name|FutureCallback
argument_list|<
name|TaskRunner2Result
argument_list|>
block|{
specifier|private
specifier|final
name|TaskWrapper
name|taskWrapper
decl_stmt|;
specifier|public
name|InternalCompletionListener
parameter_list|(
name|TaskWrapper
name|taskWrapper
parameter_list|)
block|{
name|this
operator|.
name|taskWrapper
operator|=
name|taskWrapper
expr_stmt|;
block|}
comment|// By the time either success / failed are called, the task itself knows that it has terminated,
comment|// and will ignore subsequent kill requests if they go out.
comment|// There's a race between removing the current task from the preemption queue and the actual scheduler
comment|// attempting to take an element from the preemption queue to make space for another task.
comment|// If the current element is removed to make space - that is OK, since the current task is completing and
comment|// will end up making space for execution. Any kill message sent out by the scheduler to the task will
comment|// be ignored, since the task knows it has completed (otherwise it would not be in this callback).
comment|//
comment|// If the task is removed from the queue as a result of this callback, and the scheduler happens to
comment|// be in the section where it's looking for a preemptible task - the scheuler may end up pulling the
comment|// next pre-emptible task and killing it (an extra preemption).
comment|// TODO: This potential extra preemption can be avoided by synchronizing the entire tryScheduling block.\
comment|// This would essentially synchronize all operations - it would be better to see if there's an
comment|// approach where multiple locks could be used to avoid single threaded operation.
comment|// - It checks available and preempts (which could be this task)
comment|// - Or this task completes making space, and removing the need for preemption
annotation|@
name|Override
specifier|public
name|void
name|onSuccess
parameter_list|(
name|TaskRunner2Result
name|result
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Received successful completion for: {}"
argument_list|,
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|updateFallOffStats
argument_list|(
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|)
expr_stmt|;
name|knownTasks
operator|.
name|remove
argument_list|(
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|)
expr_stmt|;
name|taskWrapper
operator|.
name|setIsInPreemptableQueue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|taskWrapper
operator|.
name|maybeUnregisterForFinishedStateNotifications
argument_list|()
expr_stmt|;
name|updatePreemptionListAndNotify
argument_list|(
name|result
operator|.
name|getEndReason
argument_list|()
argument_list|)
expr_stmt|;
name|taskWrapper
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|getCallback
argument_list|()
operator|.
name|onSuccess
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Received failed completion for: {}"
argument_list|,
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|updateFallOffStats
argument_list|(
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|)
expr_stmt|;
name|knownTasks
operator|.
name|remove
argument_list|(
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|)
expr_stmt|;
name|taskWrapper
operator|.
name|setIsInPreemptableQueue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|taskWrapper
operator|.
name|maybeUnregisterForFinishedStateNotifications
argument_list|()
expr_stmt|;
name|updatePreemptionListAndNotify
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|taskWrapper
operator|.
name|getTaskRunnerCallable
argument_list|()
operator|.
name|getCallback
argument_list|()
operator|.
name|onFailure
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed notification received: Stacktrace: "
operator|+
name|ExceptionUtils
operator|.
name|getStackTrace
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|updatePreemptionListAndNotify
parameter_list|(
name|EndReason
name|reason
parameter_list|)
block|{
comment|// if this task was added to pre-emption list, remove it
if|if
condition|(
name|enablePreemption
condition|)
block|{
name|String
name|state
init|=
name|reason
operator|==
literal|null
condition|?
literal|"FAILED"
else|:
name|reason
operator|.
name|name
argument_list|()
decl_stmt|;
name|boolean
name|removed
init|=
name|removeFromPreemptionQueueUnlocked
argument_list|(
name|taskWrapper
argument_list|)
decl_stmt|;
if|if
condition|(
name|removed
operator|&&
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|TaskRunnerCallable
name|trc
init|=
name|taskWrapper
operator|.
name|getTaskRunnerCallable
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|TaskRunnerCallable
operator|.
name|getTaskIdentifierString
argument_list|(
name|trc
operator|.
name|getRequest
argument_list|()
argument_list|,
name|trc
operator|.
name|getVertexSpec
argument_list|()
argument_list|,
name|trc
operator|.
name|getQueryId
argument_list|()
argument_list|)
operator|+
literal|" request "
operator|+
name|state
operator|+
literal|"! Removed from preemption list."
argument_list|)
expr_stmt|;
block|}
block|}
name|numSlotsAvailable
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setNumExecutorsAvailable
argument_list|(
name|numSlotsAvailable
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Task {} complete. WaitQueueSize={}, numSlotsAvailable={}, preemptionQueueSize={}"
argument_list|,
name|taskWrapper
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|waitQueue
operator|.
name|size
argument_list|()
argument_list|,
name|numSlotsAvailable
operator|.
name|get
argument_list|()
argument_list|,
name|preemptionQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|lock
init|)
block|{
if|if
condition|(
operator|!
name|waitQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lock
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|updateFallOffStats
parameter_list|(
name|String
name|requestId
parameter_list|)
block|{
name|long
name|now
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|FragmentCompletion
name|fragmentCompletion
init|=
name|completingFragmentMap
operator|.
name|remove
argument_list|(
name|requestId
argument_list|)
decl_stmt|;
if|if
condition|(
name|fragmentCompletion
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received onSuccess/onFailure for a fragment for which a completing message was not received: {}"
argument_list|,
name|requestId
argument_list|)
expr_stmt|;
comment|// Happens due to AM side pre-emption, or the AM asking for a task to die.
comment|// There's no hooks at the moment to get information over.
comment|// For now - decrement the count to avoid accounting errors.
name|runningFragmentCount
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
comment|// TODO: Extend TaskRunner2 or see if an API with callbacks will work
block|}
else|else
block|{
name|long
name|timeTaken
init|=
name|now
operator|-
name|fragmentCompletion
operator|.
name|completingTime
decl_stmt|;
switch|switch
condition|(
name|fragmentCompletion
operator|.
name|state
condition|)
block|{
case|case
name|SUCCESS
case|:
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|addMetricsFallOffSuccessTimeLost
argument_list|(
name|timeTaken
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FAILED
case|:
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|addMetricsFallOffFailedTimeLost
argument_list|(
name|timeTaken
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|KILLED
case|:
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|addMetricsFallOffKilledTimeLost
argument_list|(
name|timeTaken
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
specifier|public
name|void
name|shutDown
parameter_list|(
name|boolean
name|awaitTermination
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isShutdown
operator|.
name|getAndSet
argument_list|(
literal|true
argument_list|)
condition|)
block|{
if|if
condition|(
name|awaitTermination
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"awaitTermination: "
operator|+
name|awaitTermination
operator|+
literal|" shutting down task executor"
operator|+
literal|" service gracefully"
argument_list|)
expr_stmt|;
block|}
name|shutdownExecutor
argument_list|(
name|waitQueueExecutorService
argument_list|)
expr_stmt|;
name|shutdownExecutor
argument_list|(
name|executorService
argument_list|)
expr_stmt|;
name|shutdownExecutor
argument_list|(
name|executionCompletionExecutorService
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"awaitTermination: "
operator|+
name|awaitTermination
operator|+
literal|" shutting down task executor"
operator|+
literal|" service immediately"
argument_list|)
expr_stmt|;
block|}
name|executorService
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|waitQueueExecutorService
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|executionCompletionExecutorService
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|shutdownExecutor
parameter_list|(
name|ExecutorService
name|executorService
parameter_list|)
block|{
name|executorService
operator|.
name|shutdown
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|executorService
operator|.
name|awaitTermination
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|MINUTES
argument_list|)
condition|)
block|{
name|executorService
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|executorService
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|public
specifier|static
class|class
name|PreemptionQueueComparator
implements|implements
name|Comparator
argument_list|<
name|TaskWrapper
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|TaskWrapper
name|t1
parameter_list|,
name|TaskWrapper
name|t2
parameter_list|)
block|{
name|TaskRunnerCallable
name|o1
init|=
name|t1
operator|.
name|getTaskRunnerCallable
argument_list|()
decl_stmt|;
name|TaskRunnerCallable
name|o2
init|=
name|t2
operator|.
name|getTaskRunnerCallable
argument_list|()
decl_stmt|;
name|FragmentRuntimeInfo
name|fri1
init|=
name|o1
operator|.
name|getFragmentRuntimeInfo
argument_list|()
decl_stmt|;
name|FragmentRuntimeInfo
name|fri2
init|=
name|o2
operator|.
name|getFragmentRuntimeInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|fri1
operator|.
name|getNumSelfAndUpstreamTasks
argument_list|()
operator|>
name|fri2
operator|.
name|getNumSelfAndUpstreamTasks
argument_list|()
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fri1
operator|.
name|getNumSelfAndUpstreamTasks
argument_list|()
operator|<
name|fri2
operator|.
name|getNumSelfAndUpstreamTasks
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|TaskWrapper
implements|implements
name|FinishableStateUpdateHandler
block|{
specifier|private
specifier|final
name|TaskRunnerCallable
name|taskRunnerCallable
decl_stmt|;
specifier|private
specifier|final
name|AtomicBoolean
name|inWaitQueue
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|AtomicBoolean
name|inPreemptionQueue
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|AtomicBoolean
name|registeredForNotifications
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|TaskExecutorService
name|taskExecutorService
decl_stmt|;
specifier|public
name|TaskWrapper
parameter_list|(
name|TaskRunnerCallable
name|taskRunnerCallable
parameter_list|,
name|TaskExecutorService
name|taskExecutorService
parameter_list|)
block|{
name|this
operator|.
name|taskRunnerCallable
operator|=
name|taskRunnerCallable
expr_stmt|;
name|this
operator|.
name|taskExecutorService
operator|=
name|taskExecutorService
expr_stmt|;
block|}
specifier|public
name|void
name|updateCanFinishForPriority
parameter_list|(
name|boolean
name|newFinishableState
parameter_list|)
block|{
name|taskRunnerCallable
operator|.
name|updateCanFinishForPriority
argument_list|(
name|newFinishableState
argument_list|)
expr_stmt|;
block|}
comment|// Don't invoke from within a scheduler lock
comment|/**      *      * @param currentFinishableState      * @return true if the state has not changed from currentFinishableState, false otherwise      */
specifier|public
name|boolean
name|maybeRegisterForFinishedStateNotifications
parameter_list|(
name|boolean
name|currentFinishableState
parameter_list|)
block|{
if|if
condition|(
operator|!
name|registeredForNotifications
operator|.
name|getAndSet
argument_list|(
literal|true
argument_list|)
condition|)
block|{
return|return
name|taskRunnerCallable
operator|.
name|getFragmentInfo
argument_list|()
operator|.
name|registerForFinishableStateUpdates
argument_list|(
name|this
argument_list|,
name|currentFinishableState
argument_list|)
return|;
block|}
else|else
block|{
comment|// State has not changed / already registered for notifications.
return|return
literal|true
return|;
block|}
block|}
comment|// Don't invoke from within a scheduler lock
specifier|public
name|void
name|maybeUnregisterForFinishedStateNotifications
parameter_list|()
block|{
if|if
condition|(
name|registeredForNotifications
operator|.
name|getAndSet
argument_list|(
literal|false
argument_list|)
condition|)
block|{
name|taskRunnerCallable
operator|.
name|getFragmentInfo
argument_list|()
operator|.
name|unregisterForFinishableStateUpdates
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|TaskRunnerCallable
name|getTaskRunnerCallable
parameter_list|()
block|{
return|return
name|taskRunnerCallable
return|;
block|}
specifier|public
name|boolean
name|isInWaitQueue
parameter_list|()
block|{
return|return
name|inWaitQueue
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isInPreemptionQueue
parameter_list|()
block|{
return|return
name|inPreemptionQueue
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
name|void
name|setIsInWaitQueue
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
name|this
operator|.
name|inWaitQueue
operator|.
name|set
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setIsInPreemptableQueue
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
name|this
operator|.
name|inPreemptionQueue
operator|.
name|set
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
specifier|public
name|String
name|getRequestId
parameter_list|()
block|{
return|return
name|taskRunnerCallable
operator|.
name|getRequestId
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"TaskWrapper{"
operator|+
literal|"task="
operator|+
name|taskRunnerCallable
operator|.
name|getRequestId
argument_list|()
operator|+
literal|", inWaitQueue="
operator|+
name|inWaitQueue
operator|.
name|get
argument_list|()
operator|+
literal|", inPreemptionQueue="
operator|+
name|inPreemptionQueue
operator|.
name|get
argument_list|()
operator|+
literal|", registeredForNotifications="
operator|+
name|registeredForNotifications
operator|.
name|get
argument_list|()
operator|+
literal|", canFinish="
operator|+
name|taskRunnerCallable
operator|.
name|canFinish
argument_list|()
operator|+
literal|", canFinish(in queue)="
operator|+
name|taskRunnerCallable
operator|.
name|canFinishForPriority
argument_list|()
operator|+
literal|", firstAttemptStartTime="
operator|+
name|taskRunnerCallable
operator|.
name|getFragmentRuntimeInfo
argument_list|()
operator|.
name|getFirstAttemptStartTime
argument_list|()
operator|+
literal|", dagStartTime="
operator|+
name|taskRunnerCallable
operator|.
name|getFragmentRuntimeInfo
argument_list|()
operator|.
name|getDagStartTime
argument_list|()
operator|+
literal|", withinDagPriority="
operator|+
name|taskRunnerCallable
operator|.
name|getFragmentRuntimeInfo
argument_list|()
operator|.
name|getWithinDagPriority
argument_list|()
operator|+
literal|", vertexParallelism= "
operator|+
name|taskRunnerCallable
operator|.
name|getVertexSpec
argument_list|()
operator|.
name|getVertexParallelism
argument_list|()
operator|+
literal|", selfAndUpstreamParallelism= "
operator|+
name|taskRunnerCallable
operator|.
name|getFragmentRuntimeInfo
argument_list|()
operator|.
name|getNumSelfAndUpstreamTasks
argument_list|()
operator|+
literal|", selfAndUpstreamComplete= "
operator|+
name|taskRunnerCallable
operator|.
name|getFragmentRuntimeInfo
argument_list|()
operator|.
name|getNumSelfAndUpstreamCompletedTasks
argument_list|()
operator|+
literal|'}'
return|;
block|}
comment|// No task lock. But acquires lock on the scheduler
annotation|@
name|Override
specifier|public
name|void
name|finishableStateUpdated
parameter_list|(
name|boolean
name|finishableState
parameter_list|)
block|{
comment|// This method should not by synchronized. Can lead to deadlocks since it calls a sync method.
comment|// Meanwhile the scheduler could try updating states via a synchronized method.
name|LOG
operator|.
name|info
argument_list|(
literal|"Received finishable state update for {}, state={}"
argument_list|,
name|taskRunnerCallable
operator|.
name|getRequestId
argument_list|()
argument_list|,
name|finishableState
argument_list|)
expr_stmt|;
name|taskExecutorService
operator|.
name|finishableStateUpdated
argument_list|(
name|this
argument_list|,
name|finishableState
argument_list|)
expr_stmt|;
block|}
comment|// TaskWrapper is used in structures, as well as for ordering using Comparators
comment|// in the waitQueue. Avoid Object comparison.
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|TaskWrapper
name|that
init|=
operator|(
name|TaskWrapper
operator|)
name|o
decl_stmt|;
return|return
name|taskRunnerCallable
operator|.
name|getRequestId
argument_list|()
operator|.
name|equals
argument_list|(
name|that
operator|.
name|taskRunnerCallable
operator|.
name|getRequestId
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|taskRunnerCallable
operator|.
name|getRequestId
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|ExecutorThreadFactory
implements|implements
name|ThreadFactory
block|{
specifier|private
specifier|final
name|ClassLoader
name|classLoader
decl_stmt|;
specifier|private
specifier|final
name|ThreadFactory
name|defaultFactory
decl_stmt|;
specifier|private
specifier|final
name|AtomicLong
name|count
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|public
name|ExecutorThreadFactory
parameter_list|(
name|ClassLoader
name|classLoader
parameter_list|)
block|{
name|this
operator|.
name|classLoader
operator|=
name|classLoader
expr_stmt|;
name|this
operator|.
name|defaultFactory
operator|=
name|Executors
operator|.
name|defaultThreadFactory
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Thread
name|newThread
parameter_list|(
name|Runnable
name|r
parameter_list|)
block|{
name|Thread
name|thread
init|=
name|defaultFactory
operator|.
name|newThread
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|thread
operator|.
name|setName
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|TASK_EXECUTOR_THREAD_NAME_FORMAT
argument_list|,
name|count
operator|.
name|getAndIncrement
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|thread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|thread
operator|.
name|setContextClassLoader
argument_list|(
name|classLoader
argument_list|)
expr_stmt|;
return|return
name|thread
return|;
block|}
block|}
block|}
end_class

end_unit

