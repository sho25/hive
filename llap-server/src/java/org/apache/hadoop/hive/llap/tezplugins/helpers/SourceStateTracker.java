begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed under the Apache License, Version 2.0 (the "License");  *  you may not use this file except in compliance with the License.  *  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|tezplugins
operator|.
name|helpers
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|mutable
operator|.
name|MutableInt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|daemon
operator|.
name|impl
operator|.
name|QueryIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|daemon
operator|.
name|rpc
operator|.
name|LlapDaemonProtocolProtos
operator|.
name|QueryIdentifierProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|LlapNodeId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|daemon
operator|.
name|rpc
operator|.
name|LlapDaemonProtocolProtos
operator|.
name|FragmentRuntimeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|daemon
operator|.
name|rpc
operator|.
name|LlapDaemonProtocolProtos
operator|.
name|SourceStateUpdatedRequestProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|tezplugins
operator|.
name|Converters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|tezplugins
operator|.
name|LlapTaskCommunicator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|dag
operator|.
name|api
operator|.
name|TaskCommunicatorContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|dag
operator|.
name|api
operator|.
name|event
operator|.
name|VertexState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|mapreduce
operator|.
name|input
operator|.
name|MRInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|mapreduce
operator|.
name|input
operator|.
name|MRInputLegacy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|mapreduce
operator|.
name|input
operator|.
name|MultiMRInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|runtime
operator|.
name|api
operator|.
name|impl
operator|.
name|InputSpec
import|;
end_import

begin_class
specifier|public
class|class
name|SourceStateTracker
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SourceStateTracker
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|TaskCommunicatorContext
name|taskCommunicatorContext
decl_stmt|;
specifier|private
specifier|final
name|LlapTaskCommunicator
name|taskCommunicator
decl_stmt|;
specifier|private
specifier|final
name|QueryIdentifierProto
name|BASE_QUERY_IDENTIFIER
decl_stmt|;
comment|// Tracks vertices for which notifications have been registered
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|notificationRegisteredVertices
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|SourceInfo
argument_list|>
name|sourceInfoMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|LlapNodeId
argument_list|,
name|NodeInfo
argument_list|>
name|nodeInfoMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|volatile
name|QueryIdentifierProto
name|currentQueryIdentifier
decl_stmt|;
specifier|public
name|SourceStateTracker
parameter_list|(
name|TaskCommunicatorContext
name|taskCommunicatorContext
parameter_list|,
name|LlapTaskCommunicator
name|taskCommunicator
parameter_list|)
block|{
name|this
operator|.
name|taskCommunicatorContext
operator|=
name|taskCommunicatorContext
expr_stmt|;
name|this
operator|.
name|taskCommunicator
operator|=
name|taskCommunicator
expr_stmt|;
name|BASE_QUERY_IDENTIFIER
operator|=
name|QueryIdentifierProto
operator|.
name|newBuilder
argument_list|()
operator|.
name|setAppIdentifier
argument_list|(
name|taskCommunicatorContext
operator|.
name|getCurrentAppIdentifier
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
comment|/**    * To be invoked after each DAG completes.    */
specifier|public
specifier|synchronized
name|void
name|resetState
parameter_list|(
name|int
name|newDagId
parameter_list|)
block|{
name|sourceInfoMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|nodeInfoMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|notificationRegisteredVertices
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|currentQueryIdentifier
operator|=
name|QueryIdentifierProto
operator|.
name|newBuilder
argument_list|(
name|BASE_QUERY_IDENTIFIER
argument_list|)
operator|.
name|setDagIdentifier
argument_list|(
name|newDagId
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
comment|/**    * Used to register a task for state updates. Effectively registers for state updates to go to the specific node.    * @param host    * @param port    * @param inputSpecList    */
specifier|public
specifier|synchronized
name|void
name|registerTaskForStateUpdates
parameter_list|(
name|String
name|host
parameter_list|,
name|int
name|port
parameter_list|,
name|List
argument_list|<
name|InputSpec
argument_list|>
name|inputSpecList
parameter_list|)
block|{
comment|// Add tracking information. Check if source state already known and send out an update if it is.
name|List
argument_list|<
name|String
argument_list|>
name|sourcesOfInterest
init|=
name|getSourceInterestList
argument_list|(
name|inputSpecList
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourcesOfInterest
operator|!=
literal|null
operator|&&
operator|!
name|sourcesOfInterest
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LlapNodeId
name|nodeId
init|=
name|LlapNodeId
operator|.
name|getInstance
argument_list|(
name|host
argument_list|,
name|port
argument_list|)
decl_stmt|;
name|NodeInfo
name|nodeInfo
init|=
name|getNodeInfo
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
comment|// Set up the data structures, before any notifications come in.
for|for
control|(
name|String
name|src
range|:
name|sourcesOfInterest
control|)
block|{
name|VertexState
name|oldStateForNode
init|=
name|nodeInfo
operator|.
name|getLastKnownStateForSource
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldStateForNode
operator|==
literal|null
condition|)
block|{
comment|// Not registered for this node.
comment|// Register and send state if it is successful.
name|SourceInfo
name|srcInfo
init|=
name|getSourceInfo
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|srcInfo
operator|.
name|addNode
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
name|nodeInfo
operator|.
name|addSource
argument_list|(
name|src
argument_list|,
name|srcInfo
operator|.
name|lastKnownState
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcInfo
operator|.
name|lastKnownState
operator|==
name|VertexState
operator|.
name|SUCCEEDED
condition|)
block|{
name|sendStateUpdateToNode
argument_list|(
name|nodeId
argument_list|,
name|src
argument_list|,
name|srcInfo
operator|.
name|lastKnownState
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Already registered to send updates to this node for the specific source.
comment|// Nothing to do for now, unless tracking tasks at a later point.
block|}
comment|// Setup for actual notifications, if not already done for a previous task.
name|maybeRegisterForVertexUpdates
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Don't need to track anything for this task. No new notifications, etc.
block|}
block|}
comment|/**    * Handled notifications on state updates for sources    * @param sourceName    * @param sourceState    */
specifier|public
specifier|synchronized
name|void
name|sourceStateUpdated
parameter_list|(
name|String
name|sourceName
parameter_list|,
name|VertexState
name|sourceState
parameter_list|)
block|{
name|SourceInfo
name|sourceInfo
init|=
name|getSourceInfo
argument_list|(
name|sourceName
argument_list|)
decl_stmt|;
comment|// Update source info if the state is SUCCEEDED
if|if
condition|(
name|sourceState
operator|==
name|VertexState
operator|.
name|SUCCEEDED
condition|)
block|{
name|sourceInfo
operator|.
name|numCompletedTasks
operator|=
name|taskCommunicatorContext
operator|.
name|getVertexCompletedTaskCount
argument_list|(
name|sourceName
argument_list|)
expr_stmt|;
name|sourceInfo
operator|.
name|numTasks
operator|=
name|taskCommunicatorContext
operator|.
name|getVertexTotalTaskCount
argument_list|(
name|sourceName
argument_list|)
expr_stmt|;
block|}
name|sourceInfo
operator|.
name|lastKnownState
operator|=
name|sourceState
expr_stmt|;
comment|// Checking state per node for future failure handling scenarios, where an update
comment|// to a single node may fail.
for|for
control|(
name|LlapNodeId
name|nodeId
range|:
name|sourceInfo
operator|.
name|getInterestedNodes
argument_list|()
control|)
block|{
name|NodeInfo
name|nodeInfo
init|=
name|nodeInfoMap
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
name|VertexState
name|lastStateForNode
init|=
name|nodeInfo
operator|.
name|getLastKnownStateForSource
argument_list|(
name|sourceName
argument_list|)
decl_stmt|;
comment|// Send only if the state has changed.
if|if
condition|(
name|lastStateForNode
operator|!=
name|sourceState
condition|)
block|{
name|nodeInfo
operator|.
name|setLastKnownStateForSource
argument_list|(
name|sourceName
argument_list|,
name|sourceState
argument_list|)
expr_stmt|;
name|sendStateUpdateToNode
argument_list|(
name|nodeId
argument_list|,
name|sourceName
argument_list|,
name|sourceState
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Assumes serialized DAGs within an AM, and a reset of structures after each DAG completes.
comment|/**    * Constructs FragmentRuntimeInfo for scheduling within LLAP daemons.    * Also caches state based on state updates.    * @param vertexName    * @param fragmentNumber    * @param priority    * @return    */
specifier|public
specifier|synchronized
name|FragmentRuntimeInfo
name|getFragmentRuntimeInfo
parameter_list|(
name|String
name|vertexName
parameter_list|,
name|int
name|fragmentNumber
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
name|FragmentRuntimeInfo
operator|.
name|Builder
name|builder
init|=
name|FragmentRuntimeInfo
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|maybeRegisterForVertexUpdates
argument_list|(
name|vertexName
argument_list|)
expr_stmt|;
name|MutableInt
name|totalTaskCount
init|=
operator|new
name|MutableInt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|MutableInt
name|completedTaskCount
init|=
operator|new
name|MutableInt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|computeUpstreamTaskCounts
argument_list|(
name|completedTaskCount
argument_list|,
name|totalTaskCount
argument_list|,
name|vertexName
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setNumSelfAndUpstreamCompletedTasks
argument_list|(
name|completedTaskCount
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setNumSelfAndUpstreamTasks
argument_list|(
name|totalTaskCount
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setDagStartTime
argument_list|(
name|taskCommunicatorContext
operator|.
name|getDagStartTime
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setWithinDagPriority
argument_list|(
name|priority
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setFirstAttemptStartTime
argument_list|(
name|taskCommunicatorContext
operator|.
name|getFirstAttemptStartTime
argument_list|(
name|vertexName
argument_list|,
name|fragmentNumber
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setCurrentAttemptStartTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
specifier|private
name|void
name|computeUpstreamTaskCounts
parameter_list|(
name|MutableInt
name|completedTaskCount
parameter_list|,
name|MutableInt
name|totalTaskCount
parameter_list|,
name|String
name|sourceName
parameter_list|)
block|{
name|SourceInfo
name|sourceInfo
init|=
name|getSourceInfo
argument_list|(
name|sourceName
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceInfo
operator|.
name|lastKnownState
operator|==
name|VertexState
operator|.
name|SUCCEEDED
condition|)
block|{
comment|// Some of the information in the source is complete. Don't need to fetch it from the context.
name|completedTaskCount
operator|.
name|add
argument_list|(
name|sourceInfo
operator|.
name|numCompletedTasks
argument_list|)
expr_stmt|;
name|totalTaskCount
operator|.
name|add
argument_list|(
name|sourceInfo
operator|.
name|numTasks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|completedTaskCount
operator|.
name|add
argument_list|(
name|taskCommunicatorContext
operator|.
name|getVertexCompletedTaskCount
argument_list|(
name|sourceName
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|totalCount
init|=
name|taskCommunicatorContext
operator|.
name|getVertexTotalTaskCount
argument_list|(
name|sourceName
argument_list|)
decl_stmt|;
comment|// Uninitialized vertices will report count as 0.
name|totalCount
operator|=
name|totalCount
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
name|totalCount
expr_stmt|;
name|totalTaskCount
operator|.
name|add
argument_list|(
name|totalCount
argument_list|)
expr_stmt|;
block|}
comment|// Walk through all the source vertices
for|for
control|(
name|String
name|up
range|:
name|taskCommunicatorContext
operator|.
name|getInputVertexNames
argument_list|(
name|sourceName
argument_list|)
control|)
block|{
name|computeUpstreamTaskCounts
argument_list|(
name|completedTaskCount
argument_list|,
name|totalTaskCount
argument_list|,
name|up
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
class|class
name|SourceInfo
block|{
comment|// Always start in the running state. Requests for state updates will be sent out after registration.
specifier|private
name|VertexState
name|lastKnownState
init|=
name|VertexState
operator|.
name|RUNNING
decl_stmt|;
comment|// Used for sending notifications about a vertex completed. For canFinish
comment|// Can be converted to a Tez event, if this is sufficient to decide on pre-emption
specifier|private
specifier|final
name|List
argument_list|<
name|LlapNodeId
argument_list|>
name|interestedNodes
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Used for sending information for scheduling priority.
specifier|private
name|int
name|numTasks
decl_stmt|;
specifier|private
name|int
name|numCompletedTasks
decl_stmt|;
name|void
name|addNode
parameter_list|(
name|LlapNodeId
name|nodeId
parameter_list|)
block|{
name|interestedNodes
operator|.
name|add
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|LlapNodeId
argument_list|>
name|getInterestedNodes
parameter_list|()
block|{
return|return
name|this
operator|.
name|interestedNodes
return|;
block|}
block|}
specifier|private
specifier|synchronized
name|SourceInfo
name|getSourceInfo
parameter_list|(
name|String
name|srcName
parameter_list|)
block|{
name|SourceInfo
name|sourceInfo
init|=
name|sourceInfoMap
operator|.
name|get
argument_list|(
name|srcName
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceInfo
operator|==
literal|null
condition|)
block|{
name|sourceInfo
operator|=
operator|new
name|SourceInfo
argument_list|()
expr_stmt|;
name|sourceInfoMap
operator|.
name|put
argument_list|(
name|srcName
argument_list|,
name|sourceInfo
argument_list|)
expr_stmt|;
block|}
return|return
name|sourceInfo
return|;
block|}
specifier|private
specifier|static
class|class
name|NodeInfo
block|{
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|VertexState
argument_list|>
name|sourcesOfInterest
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|void
name|addSource
parameter_list|(
name|String
name|srcName
parameter_list|,
name|VertexState
name|sourceState
parameter_list|)
block|{
name|sourcesOfInterest
operator|.
name|put
argument_list|(
name|srcName
argument_list|,
name|sourceState
argument_list|)
expr_stmt|;
block|}
name|VertexState
name|getLastKnownStateForSource
parameter_list|(
name|String
name|src
parameter_list|)
block|{
return|return
name|sourcesOfInterest
operator|.
name|get
argument_list|(
name|src
argument_list|)
return|;
block|}
name|void
name|setLastKnownStateForSource
parameter_list|(
name|String
name|src
parameter_list|,
name|VertexState
name|state
parameter_list|)
block|{
name|sourcesOfInterest
operator|.
name|put
argument_list|(
name|src
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|synchronized
name|NodeInfo
name|getNodeInfo
parameter_list|(
name|LlapNodeId
name|llapNodeId
parameter_list|)
block|{
name|NodeInfo
name|nodeInfo
init|=
name|nodeInfoMap
operator|.
name|get
argument_list|(
name|llapNodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeInfo
operator|==
literal|null
condition|)
block|{
name|nodeInfo
operator|=
operator|new
name|NodeInfo
argument_list|()
expr_stmt|;
name|nodeInfoMap
operator|.
name|put
argument_list|(
name|llapNodeId
argument_list|,
name|nodeInfo
argument_list|)
expr_stmt|;
block|}
return|return
name|nodeInfo
return|;
block|}
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getSourceInterestList
parameter_list|(
name|List
argument_list|<
name|InputSpec
argument_list|>
name|inputSpecList
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|sourcesOfInterest
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
if|if
condition|(
name|inputSpecList
operator|!=
literal|null
condition|)
block|{
name|boolean
name|alreadyFound
init|=
literal|false
decl_stmt|;
for|for
control|(
name|InputSpec
name|inputSpec
range|:
name|inputSpecList
control|)
block|{
if|if
condition|(
name|isSourceOfInterest
argument_list|(
name|inputSpec
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|alreadyFound
condition|)
block|{
name|alreadyFound
operator|=
literal|true
expr_stmt|;
name|sourcesOfInterest
operator|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|sourcesOfInterest
operator|.
name|add
argument_list|(
name|inputSpec
operator|.
name|getSourceVertexName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|sourcesOfInterest
return|;
block|}
specifier|private
name|void
name|maybeRegisterForVertexUpdates
parameter_list|(
name|String
name|sourceName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|notificationRegisteredVertices
operator|.
name|contains
argument_list|(
name|sourceName
argument_list|)
condition|)
block|{
name|notificationRegisteredVertices
operator|.
name|add
argument_list|(
name|sourceName
argument_list|)
expr_stmt|;
name|taskCommunicatorContext
operator|.
name|registerForVertexStateUpdates
argument_list|(
name|sourceName
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|VertexState
operator|.
name|RUNNING
argument_list|,
name|VertexState
operator|.
name|SUCCEEDED
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|isSourceOfInterest
parameter_list|(
name|InputSpec
name|inputSpec
parameter_list|)
block|{
name|String
name|inputClassName
init|=
name|inputSpec
operator|.
name|getInputDescriptor
argument_list|()
operator|.
name|getClassName
argument_list|()
decl_stmt|;
comment|// MRInput is not of interest since it'll always be ready.
return|return
operator|!
operator|(
name|inputClassName
operator|.
name|equals
argument_list|(
name|MRInputLegacy
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
operator|||
name|inputClassName
operator|.
name|equals
argument_list|(
name|MultiMRInput
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
operator|||
name|inputClassName
operator|.
name|equals
argument_list|(
name|MRInput
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
operator|)
return|;
block|}
name|void
name|sendStateUpdateToNode
parameter_list|(
name|LlapNodeId
name|nodeId
parameter_list|,
name|String
name|sourceName
parameter_list|,
name|VertexState
name|state
parameter_list|)
block|{
name|taskCommunicator
operator|.
name|sendStateUpdate
argument_list|(
name|nodeId
operator|.
name|getHostname
argument_list|()
argument_list|,
name|nodeId
operator|.
name|getPort
argument_list|()
argument_list|,
name|SourceStateUpdatedRequestProto
operator|.
name|newBuilder
argument_list|()
operator|.
name|setQueryIdentifier
argument_list|(
name|currentQueryIdentifier
argument_list|)
operator|.
name|setSrcName
argument_list|(
name|sourceName
argument_list|)
operator|.
name|setState
argument_list|(
name|Converters
operator|.
name|fromVertexState
argument_list|(
name|state
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

