begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|AccessibleObject
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|ParameterizedType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|cache
operator|.
name|LlapCacheableBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|io
operator|.
name|api
operator|.
name|impl
operator|.
name|LlapIoImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|util
operator|.
name|JavaDataModel
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|UnknownFieldSet
import|;
end_import

begin_comment
comment|/**  * Creates size estimators for java objects. The estimators attempt to do most of the reflection  * work at initialization time, and also take some shortcuts, to minimize the amount of work done  * during the actual estimation. TODO: clean up  */
end_comment

begin_class
specifier|public
class|class
name|IncrementalObjectSizeEstimator
block|{
specifier|private
specifier|static
specifier|final
name|JavaDataModel
name|memoryModel
init|=
name|JavaDataModel
operator|.
name|get
argument_list|()
decl_stmt|;
specifier|private
enum|enum
name|FieldType
block|{
name|PRIMITIVE_ARRAY
block|,
name|OBJECT_ARRAY
block|,
name|COLLECTION
block|,
name|MAP
block|,
name|OTHER
block|}
empty_stmt|;
specifier|public
specifier|static
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|ObjectEstimator
argument_list|>
name|createEstimators
parameter_list|(
name|Object
name|rootObj
parameter_list|)
block|{
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|ObjectEstimator
argument_list|>
name|byType
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|addHardcodedEstimators
argument_list|(
name|byType
argument_list|)
expr_stmt|;
name|createEstimators
argument_list|(
name|rootObj
argument_list|,
name|byType
argument_list|)
expr_stmt|;
return|return
name|byType
return|;
block|}
specifier|public
specifier|static
name|void
name|createEstimators
parameter_list|(
name|Object
name|rootObj
parameter_list|,
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|ObjectEstimator
argument_list|>
name|byType
parameter_list|)
block|{
comment|// Code initially inspired by Google ObjectExplorer.
comment|// TODO: roll in the direct-only estimators from fields. Various other optimizations possible.
name|Deque
argument_list|<
name|Object
argument_list|>
name|stack
init|=
name|createWorkStack
argument_list|(
name|rootObj
argument_list|,
name|byType
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Object
name|obj
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
decl_stmt|;
if|if
condition|(
name|obj
operator|instanceof
name|Class
argument_list|<
name|?
argument_list|>
condition|)
block|{
name|clazz
operator|=
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|obj
expr_stmt|;
name|obj
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|clazz
operator|=
name|obj
operator|.
name|getClass
argument_list|()
expr_stmt|;
block|}
name|ObjectEstimator
name|estimator
init|=
name|byType
operator|.
name|get
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
assert|assert
name|estimator
operator|!=
literal|null
assert|;
if|if
condition|(
operator|!
name|estimator
operator|.
name|isFromClass
operator|&&
name|obj
operator|==
literal|null
condition|)
block|{
comment|// The object was added later for the same class; see addToProcessing.
continue|continue;
block|}
if|if
condition|(
name|estimator
operator|.
name|isProcessed
argument_list|()
condition|)
continue|continue;
name|estimator
operator|.
name|init
argument_list|()
expr_stmt|;
for|for
control|(
name|Field
name|field
range|:
name|getAllFields
argument_list|(
name|clazz
argument_list|,
name|LlapCacheableBuffer
operator|.
name|class
argument_list|)
control|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|fieldClass
init|=
name|field
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|Modifier
operator|.
name|isStatic
argument_list|(
name|field
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|Class
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|fieldClass
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|fieldClass
operator|.
name|isPrimitive
argument_list|()
condition|)
block|{
name|estimator
operator|.
name|addPrimitive
argument_list|(
name|fieldClass
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|Enum
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|fieldClass
argument_list|)
condition|)
block|{
name|estimator
operator|.
name|addEnum
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|boolean
name|isArray
init|=
name|fieldClass
operator|.
name|isArray
argument_list|()
decl_stmt|;
if|if
condition|(
name|isArray
operator|&&
name|fieldClass
operator|.
name|getComponentType
argument_list|()
operator|.
name|isPrimitive
argument_list|()
condition|)
block|{
name|estimator
operator|.
name|addField
argument_list|(
name|FieldType
operator|.
name|PRIMITIVE_ARRAY
argument_list|,
name|field
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Object
name|fieldObj
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|obj
operator|!=
literal|null
condition|)
block|{
name|fieldObj
operator|=
name|extractFieldObj
argument_list|(
name|obj
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|fieldClass
operator|=
name|determineRealClass
argument_list|(
name|byType
argument_list|,
name|stack
argument_list|,
name|field
argument_list|,
name|fieldClass
argument_list|,
name|fieldObj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isArray
condition|)
block|{
name|estimator
operator|.
name|addField
argument_list|(
name|FieldType
operator|.
name|OBJECT_ARRAY
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|addArrayEstimator
argument_list|(
name|byType
argument_list|,
name|stack
argument_list|,
name|field
argument_list|,
name|fieldObj
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Collection
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|fieldClass
argument_list|)
condition|)
block|{
name|estimator
operator|.
name|addField
argument_list|(
name|FieldType
operator|.
name|COLLECTION
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|addCollectionEstimator
argument_list|(
name|byType
argument_list|,
name|stack
argument_list|,
name|field
argument_list|,
name|fieldClass
argument_list|,
name|fieldObj
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Map
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|fieldClass
argument_list|)
condition|)
block|{
name|estimator
operator|.
name|addField
argument_list|(
name|FieldType
operator|.
name|MAP
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|addMapEstimator
argument_list|(
name|byType
argument_list|,
name|stack
argument_list|,
name|field
argument_list|,
name|fieldClass
argument_list|,
name|fieldObj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|estimator
operator|.
name|addField
argument_list|(
name|FieldType
operator|.
name|OTHER
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|addToProcessing
argument_list|(
name|byType
argument_list|,
name|stack
argument_list|,
name|fieldObj
argument_list|,
name|fieldClass
argument_list|)
expr_stmt|;
block|}
block|}
name|estimator
operator|.
name|directSize
operator|=
name|JavaDataModel
operator|.
name|alignUp
argument_list|(
name|estimator
operator|.
name|directSize
argument_list|,
name|memoryModel
operator|.
name|memoryAlign
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|Deque
argument_list|<
name|Object
argument_list|>
name|createWorkStack
parameter_list|(
name|Object
name|rootObj
parameter_list|,
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|ObjectEstimator
argument_list|>
name|byType
parameter_list|)
block|{
name|Deque
argument_list|<
name|Object
argument_list|>
name|stack
init|=
operator|new
name|ArrayDeque
argument_list|<
name|Object
argument_list|>
argument_list|(
literal|32
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|rootClass
init|=
name|rootObj
operator|.
name|getClass
argument_list|()
decl_stmt|;
if|if
condition|(
name|Class
operator|.
name|class
operator|.
name|equals
argument_list|(
name|rootClass
argument_list|)
condition|)
block|{
name|rootClass
operator|=
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|rootObj
expr_stmt|;
name|rootObj
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
comment|// If root object is an array, map or collection, add estimators as for fields
if|if
condition|(
name|rootClass
operator|.
name|isArray
argument_list|()
operator|&&
operator|!
name|rootClass
operator|.
name|getComponentType
argument_list|()
operator|.
name|isPrimitive
argument_list|()
condition|)
block|{
name|addArrayEstimator
argument_list|(
name|byType
argument_list|,
name|stack
argument_list|,
literal|null
argument_list|,
name|rootObj
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Collection
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|rootClass
argument_list|)
condition|)
block|{
name|addCollectionEstimator
argument_list|(
name|byType
argument_list|,
name|stack
argument_list|,
literal|null
argument_list|,
name|rootClass
argument_list|,
name|rootObj
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Map
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|rootClass
argument_list|)
condition|)
block|{
name|addMapEstimator
argument_list|(
name|byType
argument_list|,
name|stack
argument_list|,
literal|null
argument_list|,
name|rootClass
argument_list|,
name|rootObj
argument_list|)
expr_stmt|;
block|}
block|}
name|addToProcessing
argument_list|(
name|byType
argument_list|,
name|stack
argument_list|,
name|rootObj
argument_list|,
name|rootClass
argument_list|)
expr_stmt|;
return|return
name|stack
return|;
block|}
specifier|private
specifier|static
name|void
name|addHardcodedEstimators
parameter_list|(
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|ObjectEstimator
argument_list|>
name|byType
parameter_list|)
block|{
comment|// Add hacks for well-known collections and maps to avoid estimating them.
name|byType
operator|.
name|put
argument_list|(
name|ArrayList
operator|.
name|class
argument_list|,
operator|new
name|CollectionEstimator
argument_list|(
name|memoryModel
operator|.
name|arrayList
argument_list|()
argument_list|,
name|memoryModel
operator|.
name|ref
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|byType
operator|.
name|put
argument_list|(
name|LinkedList
operator|.
name|class
argument_list|,
operator|new
name|CollectionEstimator
argument_list|(
name|memoryModel
operator|.
name|linkedListBase
argument_list|()
argument_list|,
name|memoryModel
operator|.
name|linkedListEntry
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|byType
operator|.
name|put
argument_list|(
name|HashSet
operator|.
name|class
argument_list|,
operator|new
name|CollectionEstimator
argument_list|(
name|memoryModel
operator|.
name|hashSetBase
argument_list|()
argument_list|,
name|memoryModel
operator|.
name|hashSetEntry
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|byType
operator|.
name|put
argument_list|(
name|HashMap
operator|.
name|class
argument_list|,
operator|new
name|CollectionEstimator
argument_list|(
name|memoryModel
operator|.
name|hashMapBase
argument_list|()
argument_list|,
name|memoryModel
operator|.
name|hashMapEntry
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Add a hack for UnknownFieldSet because we assume it will never have anything (TODO: clear?)
name|ObjectEstimator
name|ufsEstimator
init|=
operator|new
name|ObjectEstimator
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|ufsEstimator
operator|.
name|directSize
operator|=
name|memoryModel
operator|.
name|object
argument_list|()
operator|*
literal|2
operator|+
name|memoryModel
operator|.
name|ref
argument_list|()
expr_stmt|;
name|byType
operator|.
name|put
argument_list|(
name|UnknownFieldSet
operator|.
name|class
argument_list|,
name|ufsEstimator
argument_list|)
expr_stmt|;
comment|// TODO: 1-field hack for UnmodifiableCollection for protobuf too
block|}
specifier|private
specifier|static
name|Object
name|extractFieldObj
parameter_list|(
name|Object
name|obj
parameter_list|,
name|Field
name|field
parameter_list|)
block|{
try|try
block|{
return|return
name|field
operator|.
name|get
argument_list|(
name|obj
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"IAE: "
operator|+
name|field
operator|+
literal|"; "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
name|determineRealClass
parameter_list|(
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|ObjectEstimator
argument_list|>
name|byType
parameter_list|,
name|Deque
argument_list|<
name|Object
argument_list|>
name|stack
parameter_list|,
name|Field
name|field
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|fieldClass
parameter_list|,
name|Object
name|fieldObj
parameter_list|)
block|{
if|if
condition|(
name|fieldObj
operator|==
literal|null
condition|)
return|return
name|fieldClass
return|;
name|Class
argument_list|<
name|?
argument_list|>
name|realFieldClass
init|=
name|fieldObj
operator|.
name|getClass
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fieldClass
operator|.
name|equals
argument_list|(
name|realFieldClass
argument_list|)
condition|)
block|{
name|addToProcessing
argument_list|(
name|byType
argument_list|,
name|stack
argument_list|,
literal|null
argument_list|,
name|fieldClass
argument_list|)
expr_stmt|;
return|return
name|realFieldClass
return|;
block|}
return|return
name|fieldClass
return|;
block|}
specifier|private
specifier|static
name|void
name|addCollectionEstimator
parameter_list|(
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|ObjectEstimator
argument_list|>
name|byType
parameter_list|,
name|Deque
argument_list|<
name|Object
argument_list|>
name|stack
parameter_list|,
name|Field
name|field
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|fieldClass
parameter_list|,
name|Object
name|fieldObj
parameter_list|)
block|{
name|Collection
argument_list|<
name|?
argument_list|>
name|fieldCol
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|fieldObj
operator|!=
literal|null
condition|)
block|{
name|fieldCol
operator|=
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|fieldObj
expr_stmt|;
if|if
condition|(
name|fieldCol
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|fieldCol
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LlapIoImpl
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Empty collection "
operator|+
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|fieldCol
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Object
name|element
range|:
name|fieldCol
control|)
block|{
if|if
condition|(
name|element
operator|!=
literal|null
condition|)
block|{
name|addToProcessing
argument_list|(
name|byType
argument_list|,
name|stack
argument_list|,
name|element
argument_list|,
name|element
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|field
operator|!=
literal|null
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|collectionArg
init|=
name|getCollectionArg
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|collectionArg
operator|!=
literal|null
condition|)
block|{
name|addToProcessing
argument_list|(
name|byType
argument_list|,
name|stack
argument_list|,
literal|null
argument_list|,
name|collectionArg
argument_list|)
expr_stmt|;
block|}
comment|// TODO: there was code here to create guess-estimate for collection wrt how usage changes
comment|//       when removing elements. However it's too error-prone for anything involving
comment|//       pre-allocated capacity, so it was discarded.
comment|// We will estimate collection as an object (only if it's a field).
name|addToProcessing
argument_list|(
name|byType
argument_list|,
name|stack
argument_list|,
name|fieldObj
argument_list|,
name|fieldClass
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|addMapEstimator
parameter_list|(
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|ObjectEstimator
argument_list|>
name|byType
parameter_list|,
name|Deque
argument_list|<
name|Object
argument_list|>
name|stack
parameter_list|,
name|Field
name|field
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|fieldClass
parameter_list|,
name|Object
name|fieldObj
parameter_list|)
block|{
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|fieldCol
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|fieldObj
operator|!=
literal|null
condition|)
block|{
name|fieldCol
operator|=
operator|(
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|fieldObj
expr_stmt|;
if|if
condition|(
name|fieldCol
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|fieldCol
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LlapIoImpl
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Empty map "
operator|+
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|fieldCol
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|element
range|:
name|fieldCol
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Object
name|k
init|=
name|element
operator|.
name|getKey
argument_list|()
decl_stmt|,
name|v
init|=
name|element
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|k
operator|!=
literal|null
condition|)
block|{
name|addToProcessing
argument_list|(
name|byType
argument_list|,
name|stack
argument_list|,
name|k
argument_list|,
name|k
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|!=
literal|null
condition|)
block|{
name|addToProcessing
argument_list|(
name|byType
argument_list|,
name|stack
argument_list|,
name|v
argument_list|,
name|v
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|field
operator|!=
literal|null
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|mapArgs
init|=
name|getMapArgs
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|mapArgs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|mapArg
range|:
name|mapArgs
control|)
block|{
name|addToProcessing
argument_list|(
name|byType
argument_list|,
name|stack
argument_list|,
literal|null
argument_list|,
name|mapArg
argument_list|)
expr_stmt|;
block|}
block|}
comment|// We will estimate map as an object (only if it's a field).
name|addToProcessing
argument_list|(
name|byType
argument_list|,
name|stack
argument_list|,
name|fieldObj
argument_list|,
name|fieldClass
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|getMapArgs
parameter_list|(
name|Field
name|field
parameter_list|)
block|{
comment|// TODO: this makes many assumptions, e.g. on how generic args are done
name|Type
name|genericType
init|=
name|field
operator|.
name|getGenericType
argument_list|()
decl_stmt|;
if|if
condition|(
name|genericType
operator|instanceof
name|ParameterizedType
condition|)
block|{
name|Type
index|[]
name|types
init|=
operator|(
operator|(
name|ParameterizedType
operator|)
name|genericType
operator|)
operator|.
name|getActualTypeArguments
argument_list|()
decl_stmt|;
if|if
condition|(
name|types
operator|.
name|length
operator|==
literal|2
operator|&&
name|types
index|[
literal|0
index|]
operator|instanceof
name|Class
argument_list|<
name|?
argument_list|>
operator|&&
name|types
index|[
literal|1
index|]
operator|instanceof
name|Class
argument_list|<
name|?
argument_list|>
condition|)
block|{
return|return
operator|new
name|Class
argument_list|<
name|?
argument_list|>
index|[]
block|{
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|types
index|[
literal|0
index|]
operator|,
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|types
index|[
literal|1
index|]
block|}
empty_stmt|;
block|}
else|else
block|{
comment|// TODO: we could try to get the declaring object and infer argument... stupid Java.
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LlapIoImpl
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Cannot determine map type: "
operator|+
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// TODO: we could try to get superclass or generic interfaces.
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LlapIoImpl
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Non-parametrized map type: "
operator|+
name|field
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
name|getCollectionArg
parameter_list|(
name|Field
name|field
parameter_list|)
block|{
comment|// TODO: this makes many assumptions, e.g. on how generic args are done
name|Type
name|genericType
init|=
name|field
operator|.
name|getGenericType
argument_list|()
decl_stmt|;
if|if
condition|(
name|genericType
operator|instanceof
name|ParameterizedType
condition|)
block|{
name|Type
name|type
init|=
operator|(
operator|(
name|ParameterizedType
operator|)
name|genericType
operator|)
operator|.
name|getActualTypeArguments
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|type
operator|instanceof
name|Class
argument_list|<
name|?
argument_list|>
condition|)
block|{
return|return
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|type
return|;
block|}
else|else
block|{
comment|// TODO: we could try to get the declaring object and infer argument... stupid Java.
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LlapIoImpl
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Cannot determine collection type: "
operator|+
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// TODO: we could try to get superclass or generic interfaces.
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LlapIoImpl
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Non-parametrized collection type: "
operator|+
name|field
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
specifier|static
name|void
name|addArrayEstimator
parameter_list|(
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|ObjectEstimator
argument_list|>
name|byType
parameter_list|,
name|Deque
argument_list|<
name|Object
argument_list|>
name|stack
parameter_list|,
name|Field
name|field
parameter_list|,
name|Object
name|fieldObj
parameter_list|)
block|{
name|int
name|arrayLen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fieldObj
operator|!=
literal|null
condition|)
block|{
name|arrayLen
operator|=
name|Array
operator|.
name|getLength
argument_list|(
name|fieldObj
argument_list|)
expr_stmt|;
if|if
condition|(
name|arrayLen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LlapIoImpl
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Empty array "
operator|+
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arrayLen
condition|;
operator|++
name|i
control|)
block|{
name|Object
name|element
init|=
name|Array
operator|.
name|get
argument_list|(
name|fieldObj
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|element
operator|!=
literal|null
condition|)
block|{
name|addToProcessing
argument_list|(
name|byType
argument_list|,
name|stack
argument_list|,
name|element
argument_list|,
name|element
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|Class
argument_list|<
name|?
argument_list|>
name|elementClass
init|=
name|fieldObj
operator|.
name|getClass
argument_list|()
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
name|addToProcessing
argument_list|(
name|byType
argument_list|,
name|stack
argument_list|,
literal|null
argument_list|,
name|elementClass
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|addToProcessing
parameter_list|(
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|ObjectEstimator
argument_list|>
name|byType
parameter_list|,
name|Deque
argument_list|<
name|Object
argument_list|>
name|stack
parameter_list|,
name|Object
name|element
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|elementClass
parameter_list|)
block|{
name|ObjectEstimator
name|existing
init|=
name|byType
operator|.
name|get
argument_list|(
name|elementClass
argument_list|)
decl_stmt|;
if|if
condition|(
name|existing
operator|!=
literal|null
operator|&&
operator|(
operator|!
name|existing
operator|.
name|isFromClass
operator|||
operator|(
name|element
operator|==
literal|null
operator|)
operator|)
condition|)
return|return;
if|if
condition|(
name|elementClass
operator|.
name|isInterface
argument_list|()
condition|)
block|{
if|if
condition|(
name|element
operator|==
literal|null
condition|)
return|return;
name|elementClass
operator|=
name|element
operator|.
name|getClass
argument_list|()
expr_stmt|;
block|}
name|byType
operator|.
name|put
argument_list|(
name|elementClass
argument_list|,
operator|new
name|ObjectEstimator
argument_list|(
name|element
operator|==
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|element
operator|==
literal|null
condition|?
name|elementClass
else|:
name|element
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|int
name|getPrimitiveSize
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|fieldClass
parameter_list|)
block|{
if|if
condition|(
name|fieldClass
operator|==
name|long
operator|.
name|class
operator|||
name|fieldClass
operator|==
name|double
operator|.
name|class
condition|)
return|return
literal|8
return|;
if|if
condition|(
name|fieldClass
operator|==
name|int
operator|.
name|class
operator|||
name|fieldClass
operator|==
name|float
operator|.
name|class
condition|)
return|return
literal|4
return|;
if|if
condition|(
name|fieldClass
operator|==
name|short
operator|.
name|class
operator|||
name|fieldClass
operator|==
name|char
operator|.
name|class
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|fieldClass
operator|==
name|byte
operator|.
name|class
operator|||
name|fieldClass
operator|==
name|boolean
operator|.
name|class
condition|)
return|return
literal|1
return|;
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unrecognized primitive "
operator|+
name|fieldClass
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
specifier|private
specifier|static
name|Iterable
argument_list|<
name|Field
argument_list|>
name|getAllFields
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|topClass
parameter_list|)
block|{
name|List
argument_list|<
name|Field
argument_list|>
name|fields
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
literal|8
argument_list|)
decl_stmt|;
while|while
condition|(
name|clazz
operator|!=
literal|null
condition|)
block|{
name|fields
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|clazz
operator|.
name|getDeclaredFields
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|clazz
operator|=
name|clazz
operator|.
name|getSuperclass
argument_list|()
expr_stmt|;
if|if
condition|(
name|clazz
operator|==
name|topClass
condition|)
break|break;
block|}
comment|//all together so there is only one security check
name|AccessibleObject
operator|.
name|setAccessible
argument_list|(
name|fields
operator|.
name|toArray
argument_list|(
operator|new
name|AccessibleObject
index|[
name|fields
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|fields
return|;
block|}
specifier|private
specifier|static
class|class
name|FieldAndType
block|{
specifier|public
name|FieldAndType
parameter_list|(
name|Field
name|field
parameter_list|,
name|FieldType
name|type
parameter_list|)
block|{
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
specifier|public
name|Field
name|field
decl_stmt|;
specifier|public
name|FieldType
name|type
decl_stmt|;
block|}
specifier|public
specifier|static
class|class
name|ObjectEstimator
block|{
specifier|private
name|List
argument_list|<
name|FieldAndType
argument_list|>
name|fields
decl_stmt|;
specifier|protected
name|int
name|directSize
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|boolean
name|isFromClass
decl_stmt|;
specifier|public
name|ObjectEstimator
parameter_list|(
name|boolean
name|isFromClass
parameter_list|)
block|{
name|this
operator|.
name|isFromClass
operator|=
name|isFromClass
expr_stmt|;
block|}
name|boolean
name|isProcessed
parameter_list|()
block|{
return|return
name|directSize
operator|>=
literal|0
return|;
block|}
specifier|private
name|void
name|init
parameter_list|()
block|{
assert|assert
name|directSize
operator|==
operator|-
literal|1
assert|;
name|directSize
operator|=
name|memoryModel
operator|.
name|object
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|addPrimitive
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|)
block|{
name|directSize
operator|+=
name|getPrimitiveSize
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addEnum
parameter_list|()
block|{
name|directSize
operator|+=
name|memoryModel
operator|.
name|ref
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|addField
parameter_list|(
name|FieldType
name|type
parameter_list|,
name|Field
name|field
parameter_list|)
block|{
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
name|fields
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|directSize
operator|+=
name|memoryModel
operator|.
name|ref
argument_list|()
expr_stmt|;
name|fields
operator|.
name|add
argument_list|(
operator|new
name|FieldAndType
argument_list|(
name|field
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|estimate
parameter_list|(
name|Object
name|obj
parameter_list|,
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|ObjectEstimator
argument_list|>
name|parent
parameter_list|)
block|{
name|HashSet
argument_list|<
name|Object
argument_list|>
name|uniqueObjects
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|uniqueObjects
operator|.
name|add
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
name|estimate
argument_list|(
name|obj
argument_list|,
name|parent
argument_list|,
name|uniqueObjects
argument_list|)
return|;
block|}
specifier|protected
name|int
name|estimate
parameter_list|(
name|Object
name|obj
parameter_list|,
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|ObjectEstimator
argument_list|>
name|parent
parameter_list|,
name|HashSet
argument_list|<
name|Object
argument_list|>
name|uniqueObjects
parameter_list|)
block|{
comment|// TODO: maybe use stack of est+obj pairs instead of recursion.
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
return|return
name|directSize
return|;
name|int
name|referencedSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FieldAndType
name|e
range|:
name|fields
control|)
block|{
name|Object
name|fieldObj
decl_stmt|;
try|try
block|{
name|fieldObj
operator|=
name|e
operator|.
name|field
operator|.
name|get
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"IAE: "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
comment|// reference is already accounted for in the directSize.
if|if
condition|(
name|fieldObj
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
operator|!
name|uniqueObjects
operator|.
name|add
argument_list|(
name|fieldObj
argument_list|)
condition|)
continue|continue;
switch|switch
condition|(
name|e
operator|.
name|type
condition|)
block|{
case|case
name|COLLECTION
case|:
block|{
name|Collection
argument_list|<
name|?
argument_list|>
name|c
init|=
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|fieldObj
decl_stmt|;
name|ObjectEstimator
name|collEstimator
init|=
name|parent
operator|.
name|get
argument_list|(
name|fieldObj
operator|.
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|collEstimator
operator|==
literal|null
condition|)
block|{
comment|// We have no estimator for this type... assume low overhead and hope for the best.
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LlapIoImpl
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Approximate estimation for collection "
operator|+
name|fieldObj
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" from "
operator|+
name|e
operator|.
name|field
argument_list|)
expr_stmt|;
block|}
name|referencedSize
operator|+=
name|memoryModel
operator|.
name|object
argument_list|()
expr_stmt|;
name|referencedSize
operator|+=
name|estimateCollectionElements
argument_list|(
name|parent
argument_list|,
name|c
argument_list|,
name|e
operator|.
name|field
argument_list|,
name|uniqueObjects
argument_list|)
expr_stmt|;
name|referencedSize
operator|+=
name|memoryModel
operator|.
name|array
argument_list|()
operator|+
name|c
operator|.
name|size
argument_list|()
operator|*
name|memoryModel
operator|.
name|ref
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|collEstimator
operator|instanceof
name|CollectionEstimator
condition|)
block|{
name|referencedSize
operator|+=
name|memoryModel
operator|.
name|object
argument_list|()
expr_stmt|;
name|referencedSize
operator|+=
name|estimateCollectionElements
argument_list|(
name|parent
argument_list|,
name|c
argument_list|,
name|e
operator|.
name|field
argument_list|,
name|uniqueObjects
argument_list|)
expr_stmt|;
name|referencedSize
operator|+=
operator|(
operator|(
name|CollectionEstimator
operator|)
name|collEstimator
operator|)
operator|.
name|estimateOverhead
argument_list|(
name|c
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We decided to treat this collection as regular object.
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LlapIoImpl
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Verbose estimation for collection "
operator|+
name|fieldObj
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" from "
operator|+
name|e
operator|.
name|field
argument_list|)
expr_stmt|;
block|}
name|referencedSize
operator|+=
name|collEstimator
operator|.
name|estimate
argument_list|(
name|c
argument_list|,
name|parent
argument_list|,
name|uniqueObjects
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MAP
case|:
block|{
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|m
init|=
operator|(
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|fieldObj
decl_stmt|;
name|ObjectEstimator
name|collEstimator
init|=
name|parent
operator|.
name|get
argument_list|(
name|fieldObj
operator|.
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|collEstimator
operator|==
literal|null
condition|)
block|{
comment|// We have no estimator for this type... assume low overhead and hope for the best.
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LlapIoImpl
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Approximate estimation for map "
operator|+
name|fieldObj
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" from "
operator|+
name|e
operator|.
name|field
argument_list|)
expr_stmt|;
block|}
name|referencedSize
operator|+=
name|memoryModel
operator|.
name|object
argument_list|()
expr_stmt|;
name|referencedSize
operator|+=
name|estimateMapElements
argument_list|(
name|parent
argument_list|,
name|m
argument_list|,
name|e
operator|.
name|field
argument_list|,
name|uniqueObjects
argument_list|)
expr_stmt|;
name|referencedSize
operator|+=
name|memoryModel
operator|.
name|array
argument_list|()
operator|+
name|m
operator|.
name|size
argument_list|()
operator|*
operator|(
name|memoryModel
operator|.
name|ref
argument_list|()
operator|*
literal|2
operator|+
name|memoryModel
operator|.
name|object
argument_list|()
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|collEstimator
operator|instanceof
name|CollectionEstimator
condition|)
block|{
name|referencedSize
operator|+=
name|memoryModel
operator|.
name|object
argument_list|()
expr_stmt|;
name|referencedSize
operator|+=
name|estimateMapElements
argument_list|(
name|parent
argument_list|,
name|m
argument_list|,
name|e
operator|.
name|field
argument_list|,
name|uniqueObjects
argument_list|)
expr_stmt|;
name|referencedSize
operator|+=
operator|(
operator|(
name|CollectionEstimator
operator|)
name|collEstimator
operator|)
operator|.
name|estimateOverhead
argument_list|(
name|m
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We decided to treat this map as regular object.
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LlapIoImpl
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Verbose estimation for map "
operator|+
name|fieldObj
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" from "
operator|+
name|e
operator|.
name|field
argument_list|)
expr_stmt|;
block|}
name|referencedSize
operator|+=
name|collEstimator
operator|.
name|estimate
argument_list|(
name|m
argument_list|,
name|parent
argument_list|,
name|uniqueObjects
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|OBJECT_ARRAY
case|:
block|{
name|int
name|len
init|=
name|Array
operator|.
name|getLength
argument_list|(
name|fieldObj
argument_list|)
decl_stmt|;
name|referencedSize
operator|+=
name|JavaDataModel
operator|.
name|alignUp
argument_list|(
name|memoryModel
operator|.
name|array
argument_list|()
operator|+
name|len
operator|*
name|memoryModel
operator|.
name|ref
argument_list|()
argument_list|,
name|memoryModel
operator|.
name|memoryAlign
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
continue|continue;
name|referencedSize
operator|+=
name|estimateArrayElements
argument_list|(
name|parent
argument_list|,
name|e
argument_list|,
name|fieldObj
argument_list|,
name|len
argument_list|,
name|uniqueObjects
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PRIMITIVE_ARRAY
case|:
block|{
name|int
name|arraySize
init|=
name|memoryModel
operator|.
name|array
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|Array
operator|.
name|getLength
argument_list|(
name|fieldObj
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|int
name|elementSize
init|=
name|getPrimitiveSize
argument_list|(
name|e
operator|.
name|field
operator|.
name|getType
argument_list|()
operator|.
name|getComponentType
argument_list|()
argument_list|)
decl_stmt|;
name|arraySize
operator|+=
name|elementSize
operator|*
name|len
expr_stmt|;
name|arraySize
operator|=
name|JavaDataModel
operator|.
name|alignUp
argument_list|(
name|arraySize
argument_list|,
name|memoryModel
operator|.
name|memoryAlign
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|referencedSize
operator|+=
name|arraySize
expr_stmt|;
break|break;
block|}
case|case
name|OTHER
case|:
block|{
name|ObjectEstimator
name|fieldEstimator
init|=
name|parent
operator|.
name|get
argument_list|(
name|fieldObj
operator|.
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldEstimator
operator|==
literal|null
condition|)
block|{
comment|// TODO: use reflection?
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Don't know how to measure "
operator|+
name|fieldObj
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" from "
operator|+
name|e
operator|.
name|field
argument_list|)
throw|;
block|}
name|referencedSize
operator|+=
name|fieldEstimator
operator|.
name|estimate
argument_list|(
name|fieldObj
argument_list|,
name|parent
argument_list|,
name|uniqueObjects
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unknown type "
operator|+
name|e
operator|.
name|type
argument_list|)
throw|;
block|}
block|}
return|return
name|directSize
operator|+
name|referencedSize
return|;
block|}
specifier|private
name|int
name|estimateArrayElements
parameter_list|(
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|ObjectEstimator
argument_list|>
name|parent
parameter_list|,
name|FieldAndType
name|e
parameter_list|,
name|Object
name|fieldObj
parameter_list|,
name|int
name|len
parameter_list|,
name|HashSet
argument_list|<
name|Object
argument_list|>
name|uniqueObjects
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|lastClass
init|=
name|e
operator|.
name|field
operator|.
name|getType
argument_list|()
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
name|ObjectEstimator
name|lastEstimator
init|=
name|parent
operator|.
name|get
argument_list|(
name|lastClass
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|Object
name|element
init|=
name|Array
operator|.
name|get
argument_list|(
name|fieldObj
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|element
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
operator|!
name|uniqueObjects
operator|.
name|add
argument_list|(
name|element
argument_list|)
condition|)
continue|continue;
name|Class
argument_list|<
name|?
argument_list|>
name|elementClass
init|=
name|element
operator|.
name|getClass
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastClass
operator|!=
name|elementClass
condition|)
block|{
name|lastClass
operator|=
name|elementClass
expr_stmt|;
name|lastEstimator
operator|=
name|parent
operator|.
name|get
argument_list|(
name|lastClass
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastEstimator
operator|==
literal|null
condition|)
block|{
comment|// TODO: use reflection?
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Don't know how to measure element "
operator|+
name|lastClass
operator|.
name|getName
argument_list|()
operator|+
literal|" from "
operator|+
name|e
operator|.
name|field
argument_list|)
throw|;
block|}
block|}
name|result
operator|+=
name|lastEstimator
operator|.
name|estimate
argument_list|(
name|element
argument_list|,
name|parent
argument_list|,
name|uniqueObjects
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|protected
name|int
name|estimateCollectionElements
parameter_list|(
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|ObjectEstimator
argument_list|>
name|parent
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|,
name|Field
name|field
parameter_list|,
name|HashSet
argument_list|<
name|Object
argument_list|>
name|uniqueObjects
parameter_list|)
block|{
name|ObjectEstimator
name|lastEstimator
init|=
literal|null
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|lastClass
init|=
literal|null
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Object
name|element
range|:
name|c
control|)
block|{
if|if
condition|(
name|element
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
operator|!
name|uniqueObjects
operator|.
name|add
argument_list|(
name|element
argument_list|)
condition|)
continue|continue;
name|Class
argument_list|<
name|?
argument_list|>
name|elementClass
init|=
name|element
operator|.
name|getClass
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastClass
operator|!=
name|elementClass
condition|)
block|{
name|lastClass
operator|=
name|elementClass
expr_stmt|;
name|lastEstimator
operator|=
name|parent
operator|.
name|get
argument_list|(
name|lastClass
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastEstimator
operator|==
literal|null
condition|)
block|{
comment|// TODO: use reflection?
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Don't know how to measure element "
operator|+
name|lastClass
operator|.
name|getName
argument_list|()
operator|+
literal|" from "
operator|+
name|field
argument_list|)
throw|;
block|}
block|}
name|result
operator|+=
name|lastEstimator
operator|.
name|estimate
argument_list|(
name|element
argument_list|,
name|parent
argument_list|,
name|uniqueObjects
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|protected
name|int
name|estimateMapElements
parameter_list|(
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|ObjectEstimator
argument_list|>
name|parent
parameter_list|,
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|m
parameter_list|,
name|Field
name|field
parameter_list|,
name|HashSet
argument_list|<
name|Object
argument_list|>
name|uniqueObjects
parameter_list|)
block|{
name|ObjectEstimator
name|keyEstimator
init|=
literal|null
decl_stmt|,
name|valueEstimator
init|=
literal|null
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|lastKeyClass
init|=
literal|null
decl_stmt|,
name|lastValueClass
init|=
literal|null
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|element
range|:
name|m
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Object
name|key
init|=
name|element
operator|.
name|getKey
argument_list|()
decl_stmt|,
name|value
init|=
name|element
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|uniqueObjects
operator|.
name|add
argument_list|(
name|key
argument_list|)
condition|)
continue|continue;
name|Class
argument_list|<
name|?
argument_list|>
name|keyClass
init|=
name|key
operator|.
name|getClass
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastKeyClass
operator|!=
name|keyClass
condition|)
block|{
name|lastKeyClass
operator|=
name|keyClass
expr_stmt|;
name|keyEstimator
operator|=
name|parent
operator|.
name|get
argument_list|(
name|lastKeyClass
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyEstimator
operator|==
literal|null
condition|)
block|{
comment|// TODO: use reflection?
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Don't know how to measure key "
operator|+
name|lastKeyClass
operator|.
name|getName
argument_list|()
operator|+
literal|" from "
operator|+
name|field
argument_list|)
throw|;
block|}
block|}
name|result
operator|+=
name|keyEstimator
operator|.
name|estimate
argument_list|(
name|element
argument_list|,
name|parent
argument_list|,
name|uniqueObjects
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
operator|!
name|uniqueObjects
operator|.
name|add
argument_list|(
name|value
argument_list|)
condition|)
continue|continue;
name|Class
argument_list|<
name|?
argument_list|>
name|valueClass
init|=
name|value
operator|.
name|getClass
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastValueClass
operator|!=
name|valueClass
condition|)
block|{
name|lastValueClass
operator|=
name|valueClass
expr_stmt|;
name|valueEstimator
operator|=
name|parent
operator|.
name|get
argument_list|(
name|lastValueClass
argument_list|)
expr_stmt|;
if|if
condition|(
name|valueEstimator
operator|==
literal|null
condition|)
block|{
comment|// TODO: use reflection?
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Don't know how to measure value "
operator|+
name|lastValueClass
operator|.
name|getName
argument_list|()
operator|+
literal|" from "
operator|+
name|field
argument_list|)
throw|;
block|}
block|}
name|result
operator|+=
name|valueEstimator
operator|.
name|estimate
argument_list|(
name|element
argument_list|,
name|parent
argument_list|,
name|uniqueObjects
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|CollectionEstimator
extends|extends
name|ObjectEstimator
block|{
specifier|private
name|int
name|perEntryOverhead
decl_stmt|;
specifier|public
name|CollectionEstimator
parameter_list|(
name|int
name|base
parameter_list|,
name|int
name|perElement
parameter_list|)
block|{
name|super
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|directSize
operator|=
name|base
expr_stmt|;
name|perEntryOverhead
operator|=
name|perElement
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|estimate
parameter_list|(
name|Object
name|obj
parameter_list|,
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|ObjectEstimator
argument_list|>
name|parent
parameter_list|,
name|HashSet
argument_list|<
name|Object
argument_list|>
name|uniqueObjects
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|Collection
argument_list|<
name|?
argument_list|>
condition|)
block|{
name|Collection
argument_list|<
name|?
argument_list|>
name|c
init|=
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|obj
decl_stmt|;
name|int
name|overhead
init|=
name|estimateOverhead
argument_list|(
name|c
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|,
name|elements
init|=
name|estimateCollectionElements
argument_list|(
name|parent
argument_list|,
name|c
argument_list|,
literal|null
argument_list|,
name|uniqueObjects
argument_list|)
decl_stmt|;
return|return
name|overhead
operator|+
name|elements
operator|+
name|memoryModel
operator|.
name|object
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
condition|)
block|{
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|m
init|=
operator|(
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|obj
decl_stmt|;
name|int
name|overhead
init|=
name|estimateOverhead
argument_list|(
name|m
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|,
name|elements
init|=
name|estimateMapElements
argument_list|(
name|parent
argument_list|,
name|m
argument_list|,
literal|null
argument_list|,
name|uniqueObjects
argument_list|)
decl_stmt|;
return|return
name|overhead
operator|+
name|elements
operator|+
name|memoryModel
operator|.
name|object
argument_list|()
return|;
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
name|obj
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
name|int
name|estimateOverhead
parameter_list|(
name|int
name|size
parameter_list|)
block|{
return|return
name|directSize
operator|+
name|perEntryOverhead
operator|*
name|size
return|;
block|}
block|}
specifier|public
specifier|static
name|void
name|addEstimator
parameter_list|(
name|String
name|className
parameter_list|,
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|ObjectEstimator
argument_list|>
name|sizeEstimators
parameter_list|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
literal|null
decl_stmt|;
try|try
block|{
name|clazz
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|className
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// Ignore and hope for the best.
name|LlapIoImpl
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot find "
operator|+
name|className
argument_list|)
expr_stmt|;
block|}
name|IncrementalObjectSizeEstimator
operator|.
name|createEstimators
argument_list|(
name|clazz
argument_list|,
name|sizeEstimators
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

