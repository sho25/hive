begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|dag
operator|.
name|app
operator|.
name|rm
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|DelayQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Delayed
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|FutureCallback
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|configuration
operator|.
name|LlapConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|daemon
operator|.
name|registry
operator|.
name|ServiceInstance
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|daemon
operator|.
name|registry
operator|.
name|ServiceInstanceSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|daemon
operator|.
name|registry
operator|.
name|impl
operator|.
name|LlapRegistryService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Container
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|NodeId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Priority
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|Clock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|dag
operator|.
name|app
operator|.
name|AppContext
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ListenableFuture
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ListeningExecutorService
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|MoreExecutors
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|serviceplugins
operator|.
name|api
operator|.
name|TaskAttemptEndReason
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
specifier|public
class|class
name|LlapTaskSchedulerService
extends|extends
name|TaskSchedulerService
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|LlapTaskSchedulerService
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|ExecutorService
name|appCallbackExecutor
decl_stmt|;
specifier|private
specifier|final
name|TaskSchedulerAppCallback
name|appClientDelegate
decl_stmt|;
comment|// interface into the registry service
specifier|private
name|ServiceInstanceSet
name|activeInstances
decl_stmt|;
comment|// Tracks all instances, including ones which have been disabled in the past.
comment|// LinkedHashMap to provide the same iteration order when selecting a random host.
annotation|@
name|VisibleForTesting
specifier|final
name|Map
argument_list|<
name|ServiceInstance
argument_list|,
name|NodeInfo
argument_list|>
name|instanceToNodeMap
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// TODO Ideally, remove elements from this once it's known that no tasks are linked to the instance (all deallocated)
comment|// Tracks tasks which could not be allocated immediately.
annotation|@
name|VisibleForTesting
specifier|final
name|TreeMap
argument_list|<
name|Priority
argument_list|,
name|List
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|pendingTasks
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
operator|new
name|Comparator
argument_list|<
name|Priority
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Priority
name|o1
parameter_list|,
name|Priority
name|o2
parameter_list|)
block|{
return|return
name|o1
operator|.
name|getPriority
argument_list|()
operator|-
name|o2
operator|.
name|getPriority
argument_list|()
return|;
block|}
block|}
argument_list|)
decl_stmt|;
comment|// Tracks running and queued tasks. Cleared after a task completes.
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|Object
argument_list|,
name|TaskInfo
argument_list|>
name|knownTasks
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|runningTasks
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|TaskStartComparator
name|TASK_INFO_COMPARATOR
init|=
operator|new
name|TaskStartComparator
argument_list|()
decl_stmt|;
comment|// Queue for disabled nodes. Nodes make it out of this queue when their expiration timeout is hit.
annotation|@
name|VisibleForTesting
specifier|final
name|DelayQueue
argument_list|<
name|NodeInfo
argument_list|>
name|disabledNodesQueue
init|=
operator|new
name|DelayQueue
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ContainerFactory
name|containerFactory
decl_stmt|;
specifier|private
specifier|final
name|Random
name|random
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Clock
name|clock
decl_stmt|;
specifier|private
specifier|final
name|ListeningExecutorService
name|nodeEnabledExecutor
decl_stmt|;
specifier|private
specifier|final
name|NodeEnablerCallable
name|nodeEnablerCallable
init|=
operator|new
name|NodeEnablerCallable
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ReentrantReadWriteLock
name|lock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ReentrantReadWriteLock
operator|.
name|ReadLock
name|readLock
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ReentrantReadWriteLock
operator|.
name|WriteLock
name|writeLock
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Lock
name|scheduleLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Condition
name|scheduleCondition
init|=
name|scheduleLock
operator|.
name|newCondition
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ListeningExecutorService
name|schedulerExecutor
decl_stmt|;
specifier|private
specifier|final
name|SchedulerCallable
name|schedulerCallable
init|=
operator|new
name|SchedulerCallable
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|AtomicBoolean
name|isStopped
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|AtomicInteger
name|pendingPreemptions
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|NodeBlacklistConf
name|nodeBlacklistConf
decl_stmt|;
comment|// Per daemon
specifier|private
specifier|final
name|int
name|memoryPerInstance
decl_stmt|;
specifier|private
specifier|final
name|int
name|coresPerInstance
decl_stmt|;
specifier|private
specifier|final
name|int
name|executorsPerInstance
decl_stmt|;
specifier|private
specifier|final
name|int
name|numSchedulableTasksPerNode
decl_stmt|;
comment|// Per Executor Thread
specifier|private
specifier|final
name|Resource
name|resourcePerExecutor
decl_stmt|;
specifier|private
specifier|final
name|LlapRegistryService
name|registry
init|=
operator|new
name|LlapRegistryService
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
specifier|volatile
name|ListenableFuture
argument_list|<
name|Void
argument_list|>
name|nodeEnablerFuture
decl_stmt|;
specifier|private
specifier|volatile
name|ListenableFuture
argument_list|<
name|Void
argument_list|>
name|schedulerFuture
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|private
specifier|final
name|AtomicInteger
name|dagCounter
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// Statistics to track allocations
comment|// All of stats variables are visible for testing.
annotation|@
name|VisibleForTesting
name|StatsPerDag
name|dagStats
init|=
operator|new
name|StatsPerDag
argument_list|()
decl_stmt|;
specifier|public
name|LlapTaskSchedulerService
parameter_list|(
name|TaskSchedulerAppCallback
name|appClient
parameter_list|,
name|AppContext
name|appContext
parameter_list|,
name|String
name|clientHostname
parameter_list|,
name|int
name|clientPort
parameter_list|,
name|String
name|trackingUrl
parameter_list|,
name|long
name|customAppIdIdentifier
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
comment|// Accepting configuration here to allow setting up fields as final
name|super
argument_list|(
name|LlapTaskSchedulerService
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|appCallbackExecutor
operator|=
name|createAppCallbackExecutorService
argument_list|()
expr_stmt|;
name|this
operator|.
name|appClientDelegate
operator|=
name|createAppCallbackDelegate
argument_list|(
name|appClient
argument_list|)
expr_stmt|;
name|this
operator|.
name|clock
operator|=
name|appContext
operator|.
name|getClock
argument_list|()
expr_stmt|;
name|this
operator|.
name|containerFactory
operator|=
operator|new
name|ContainerFactory
argument_list|(
name|appContext
argument_list|,
name|customAppIdIdentifier
argument_list|)
expr_stmt|;
name|this
operator|.
name|memoryPerInstance
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|LlapConfiguration
operator|.
name|LLAP_DAEMON_MEMORY_PER_INSTANCE_MB
argument_list|,
name|LlapConfiguration
operator|.
name|LLAP_DAEMON_MEMORY_PER_INSTANCE_MB_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|coresPerInstance
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|LlapConfiguration
operator|.
name|LLAP_DAEMON_VCPUS_PER_INSTANCE
argument_list|,
name|LlapConfiguration
operator|.
name|LLAP_DAEMON_VCPUS_PER_INSTANCE_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorsPerInstance
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|LlapConfiguration
operator|.
name|LLAP_DAEMON_NUM_EXECUTORS
argument_list|,
name|LlapConfiguration
operator|.
name|LLAP_DAEMON_NUM_EXECUTORS_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|nodeBlacklistConf
operator|=
operator|new
name|NodeBlacklistConf
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
name|LlapConfiguration
operator|.
name|LLAP_TASK_SCHEDULER_NODE_REENABLE_MIN_TIMEOUT_MILLIS
argument_list|,
name|LlapConfiguration
operator|.
name|LLAP_TASK_SCHEDULER_NODE_REENABLE_MIN_TIMEOUT_MILLIS_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getLong
argument_list|(
name|LlapConfiguration
operator|.
name|LLAP_TASK_SCHEDULER_NODE_REENABLE_MAX_TIMEOUT_MILLIS
argument_list|,
name|LlapConfiguration
operator|.
name|LLAP_TASK_SCHEDULER_NODE_REENABLE_MAX_TIMEOUT_MILLIS_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getFloat
argument_list|(
name|LlapConfiguration
operator|.
name|LLAP_TASK_SCHEDULER_NODE_DISABLE_BACK_OFF_FACTOR
argument_list|,
name|LlapConfiguration
operator|.
name|LLAP_TASK_SCHEDULER_NODE_DISABLE_BACK_OFF_FACTOR_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|numSchedulableTasksPerNode
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|LlapConfiguration
operator|.
name|LLAP_TASK_SCHEDULER_NUM_SCHEDULABLE_TASKS_PER_NODE
argument_list|,
name|LlapConfiguration
operator|.
name|LLAP_TASK_SCHEDULER_NUM_SCHEDULABLE_TASKS_PER_NODE_DEFAULT
argument_list|)
expr_stmt|;
name|int
name|memoryPerExecutor
init|=
call|(
name|int
call|)
argument_list|(
name|memoryPerInstance
operator|/
operator|(
name|float
operator|)
name|executorsPerInstance
argument_list|)
decl_stmt|;
name|int
name|coresPerExecutor
init|=
call|(
name|int
call|)
argument_list|(
name|coresPerInstance
operator|/
operator|(
name|float
operator|)
name|executorsPerInstance
argument_list|)
decl_stmt|;
name|this
operator|.
name|resourcePerExecutor
operator|=
name|Resource
operator|.
name|newInstance
argument_list|(
name|memoryPerExecutor
argument_list|,
name|coresPerExecutor
argument_list|)
expr_stmt|;
name|String
name|instanceId
init|=
name|conf
operator|.
name|getTrimmed
argument_list|(
name|LlapConfiguration
operator|.
name|LLAP_DAEMON_SERVICE_HOSTS
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|instanceId
argument_list|,
name|LlapConfiguration
operator|.
name|LLAP_DAEMON_SERVICE_HOSTS
operator|+
literal|" must be defined"
argument_list|)
expr_stmt|;
name|ExecutorService
name|executorServiceRaw
init|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
literal|1
argument_list|,
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
literal|"LlapSchedulerNodeEnabler"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|nodeEnabledExecutor
operator|=
name|MoreExecutors
operator|.
name|listeningDecorator
argument_list|(
name|executorServiceRaw
argument_list|)
expr_stmt|;
name|ExecutorService
name|schedulerExecutorServiceRaw
init|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
literal|1
argument_list|,
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
literal|"LlapScheduler"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|schedulerExecutor
operator|=
name|MoreExecutors
operator|.
name|listeningDecorator
argument_list|(
name|schedulerExecutorServiceRaw
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Running with configuration: "
operator|+
literal|"memoryPerInstance="
operator|+
name|memoryPerInstance
operator|+
literal|", vCoresPerInstance="
operator|+
name|coresPerInstance
operator|+
literal|", executorsPerInstance="
operator|+
name|executorsPerInstance
operator|+
literal|", resourcePerInstanceInferred="
operator|+
name|resourcePerExecutor
operator|+
literal|", nodeBlacklistConf="
operator|+
name|nodeBlacklistConf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|serviceInit
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|registry
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|serviceStart
parameter_list|()
throws|throws
name|IOException
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|nodeEnablerFuture
operator|=
name|nodeEnabledExecutor
operator|.
name|submit
argument_list|(
name|nodeEnablerCallable
argument_list|)
expr_stmt|;
name|Futures
operator|.
name|addCallback
argument_list|(
name|nodeEnablerFuture
argument_list|,
operator|new
name|FutureCallback
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onSuccess
parameter_list|(
name|Void
name|result
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"NodeEnabledThread exited"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"NodeEnabledThread exited with error"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|schedulerFuture
operator|=
name|schedulerExecutor
operator|.
name|submit
argument_list|(
name|schedulerCallable
argument_list|)
expr_stmt|;
name|Futures
operator|.
name|addCallback
argument_list|(
name|schedulerFuture
argument_list|,
operator|new
name|FutureCallback
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onSuccess
parameter_list|(
name|Void
name|result
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"SchedulerThread exited"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"SchedulerThread exited with error"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|registry
operator|.
name|start
argument_list|()
expr_stmt|;
name|activeInstances
operator|=
name|registry
operator|.
name|getInstances
argument_list|()
expr_stmt|;
for|for
control|(
name|ServiceInstance
name|inst
range|:
name|activeInstances
operator|.
name|getAll
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|addNode
argument_list|(
name|inst
argument_list|,
operator|new
name|NodeInfo
argument_list|(
name|inst
argument_list|,
name|nodeBlacklistConf
argument_list|,
name|clock
argument_list|,
name|numSchedulableTasksPerNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|serviceStop
parameter_list|()
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|isStopped
operator|.
name|getAndSet
argument_list|(
literal|true
argument_list|)
condition|)
block|{
name|nodeEnablerCallable
operator|.
name|shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
name|nodeEnablerFuture
operator|!=
literal|null
condition|)
block|{
name|nodeEnablerFuture
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|nodeEnabledExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|schedulerCallable
operator|.
name|shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
name|schedulerFuture
operator|!=
literal|null
condition|)
block|{
name|schedulerFuture
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|schedulerExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
if|if
condition|(
name|registry
operator|!=
literal|null
condition|)
block|{
name|registry
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
name|appCallbackExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Resource
name|getTotalResources
parameter_list|()
block|{
name|int
name|memory
init|=
literal|0
decl_stmt|;
name|int
name|vcores
init|=
literal|0
decl_stmt|;
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|ServiceInstance
name|inst
range|:
name|activeInstances
operator|.
name|getAll
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|inst
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|Resource
name|r
init|=
name|inst
operator|.
name|getResource
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Found instance "
operator|+
name|inst
argument_list|)
expr_stmt|;
name|memory
operator|+=
name|r
operator|.
name|getMemory
argument_list|()
expr_stmt|;
name|vcores
operator|+=
name|r
operator|.
name|getVirtualCores
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignoring dead instance "
operator|+
name|inst
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|Resource
operator|.
name|newInstance
argument_list|(
name|memory
argument_list|,
name|vcores
argument_list|)
return|;
block|}
comment|/**    * The difference between this and getTotalResources() is that this only gives currently free    * resource instances, while the other lists all the instances that may become available in a    * while.    */
annotation|@
name|Override
specifier|public
name|Resource
name|getAvailableResources
parameter_list|()
block|{
comment|// need a state store eventually for current state& measure backoffs
name|int
name|memory
init|=
literal|0
decl_stmt|;
name|int
name|vcores
init|=
literal|0
decl_stmt|;
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|Entry
argument_list|<
name|ServiceInstance
argument_list|,
name|NodeInfo
argument_list|>
name|entry
range|:
name|instanceToNodeMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|isAlive
argument_list|()
operator|&&
operator|!
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|isDisabled
argument_list|()
condition|)
block|{
name|Resource
name|r
init|=
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getResource
argument_list|()
decl_stmt|;
name|memory
operator|+=
name|r
operator|.
name|getMemory
argument_list|()
expr_stmt|;
name|vcores
operator|+=
name|r
operator|.
name|getVirtualCores
argument_list|()
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|Resource
operator|.
name|newInstance
argument_list|(
name|memory
argument_list|,
name|vcores
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getClusterNodeCount
parameter_list|()
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ServiceInstance
name|inst
range|:
name|activeInstances
operator|.
name|getAll
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|inst
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|n
operator|++
expr_stmt|;
block|}
block|}
return|return
name|n
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|dagComplete
parameter_list|()
block|{
comment|// This is effectively DAG completed, and can be used to reset statistics being tracked.
name|LOG
operator|.
name|info
argument_list|(
literal|"DAG: "
operator|+
name|dagCounter
operator|.
name|get
argument_list|()
operator|+
literal|" completed. Scheduling stats: "
operator|+
name|dagStats
argument_list|)
expr_stmt|;
name|dagCounter
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|dagStats
operator|=
operator|new
name|StatsPerDag
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|blacklistNode
parameter_list|(
name|NodeId
name|nodeId
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"DEBUG: BlacklistNode not supported"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|unblacklistNode
parameter_list|(
name|NodeId
name|nodeId
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"DEBUG: unBlacklistNode not supported"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|allocateTask
parameter_list|(
name|Object
name|task
parameter_list|,
name|Resource
name|capability
parameter_list|,
name|String
index|[]
name|hosts
parameter_list|,
name|String
index|[]
name|racks
parameter_list|,
name|Priority
name|priority
parameter_list|,
name|Object
name|containerSignature
parameter_list|,
name|Object
name|clientCookie
parameter_list|)
block|{
name|TaskInfo
name|taskInfo
init|=
operator|new
name|TaskInfo
argument_list|(
name|task
argument_list|,
name|clientCookie
argument_list|,
name|priority
argument_list|,
name|capability
argument_list|,
name|hosts
argument_list|,
name|racks
argument_list|,
name|clock
operator|.
name|getTime
argument_list|()
argument_list|)
decl_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|dagStats
operator|.
name|registerTaskRequest
argument_list|(
name|hosts
argument_list|,
name|racks
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|addPendingTask
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
name|trySchedulingPendingTasks
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|allocateTask
parameter_list|(
name|Object
name|task
parameter_list|,
name|Resource
name|capability
parameter_list|,
name|ContainerId
name|containerId
parameter_list|,
name|Priority
name|priority
parameter_list|,
name|Object
name|containerSignature
parameter_list|,
name|Object
name|clientCookie
parameter_list|)
block|{
comment|// Container affinity can be implemented as Host affinity for LLAP. Not required until
comment|// 1:1 edges are used in Hive.
name|TaskInfo
name|taskInfo
init|=
operator|new
name|TaskInfo
argument_list|(
name|task
argument_list|,
name|clientCookie
argument_list|,
name|priority
argument_list|,
name|capability
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|clock
operator|.
name|getTime
argument_list|()
argument_list|)
decl_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|dagStats
operator|.
name|registerTaskRequest
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|addPendingTask
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
name|trySchedulingPendingTasks
argument_list|()
expr_stmt|;
block|}
comment|// This may be invoked before a container is ever assigned to a task. allocateTask... app decides
comment|// the task is no longer required, and asks for a de-allocation.
annotation|@
name|Override
specifier|public
name|boolean
name|deallocateTask
parameter_list|(
name|Object
name|task
parameter_list|,
name|boolean
name|taskSucceeded
parameter_list|,
name|TaskAttemptEndReason
name|endReason
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// Updating several local structures
name|TaskInfo
name|taskInfo
decl_stmt|;
try|try
block|{
name|taskInfo
operator|=
name|unregisterTask
argument_list|(
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|taskInfo
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not determine ContainerId for task: "
operator|+
name|task
operator|+
literal|" . Could have hit a race condition. Ignoring."
operator|+
literal|" The query may hang since this \"unknown\" container is now taking up a slot permanently"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|taskInfo
operator|.
name|containerId
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|taskInfo
operator|.
name|assigned
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Task: "
operator|+
name|task
operator|+
literal|" assigned, but could not find the corresponding containerId."
operator|+
literal|" The query may hang since this \"unknown\" container is now taking up a slot permanently"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignoring deallocate request for task "
operator|+
name|task
operator|+
literal|" which hasn't been assigned to a container"
argument_list|)
expr_stmt|;
name|removePendingTask
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
name|ServiceInstance
name|assignedInstance
init|=
name|taskInfo
operator|.
name|assignedInstance
decl_stmt|;
assert|assert
name|assignedInstance
operator|!=
literal|null
assert|;
name|NodeInfo
name|nodeInfo
init|=
name|instanceToNodeMap
operator|.
name|get
argument_list|(
name|assignedInstance
argument_list|)
decl_stmt|;
assert|assert
name|nodeInfo
operator|!=
literal|null
assert|;
comment|// Re-enable the node if preempted
if|if
condition|(
name|taskInfo
operator|.
name|preempted
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing deallocateTask for {} which was preempted, EndReason={}"
argument_list|,
name|task
argument_list|,
name|endReason
argument_list|)
expr_stmt|;
name|pendingPreemptions
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
name|nodeInfo
operator|.
name|registerUnsuccessfulTaskEnd
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodeInfo
operator|.
name|isDisabled
argument_list|()
condition|)
block|{
comment|// Re-enable the node. If a task succeeded, a slot may have become available.
comment|// Also reset commFailures since a task was able to communicate back and indicate success.
name|nodeInfo
operator|.
name|enableNode
argument_list|()
expr_stmt|;
comment|// Re-insert into the queue to force the poll thread to remove the element.
if|if
condition|(
name|disabledNodesQueue
operator|.
name|remove
argument_list|(
name|nodeInfo
argument_list|)
condition|)
block|{
name|disabledNodesQueue
operator|.
name|add
argument_list|(
name|nodeInfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|// In case of success, trigger a scheduling run for pending tasks.
name|trySchedulingPendingTasks
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|taskSucceeded
condition|)
block|{
comment|// The node may have been blacklisted at this point - which means it may not be in the
comment|// activeNodeList.
name|nodeInfo
operator|.
name|registerTaskSuccess
argument_list|()
expr_stmt|;
if|if
condition|(
name|nodeInfo
operator|.
name|isDisabled
argument_list|()
condition|)
block|{
comment|// Re-enable the node. If a task succeeded, a slot may have become available.
comment|// Also reset commFailures since a task was able to communicate back and indicate success.
name|nodeInfo
operator|.
name|enableNode
argument_list|()
expr_stmt|;
comment|// Re-insert into the queue to force the poll thread to remove the element.
if|if
condition|(
name|disabledNodesQueue
operator|.
name|remove
argument_list|(
name|nodeInfo
argument_list|)
condition|)
block|{
name|disabledNodesQueue
operator|.
name|add
argument_list|(
name|nodeInfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|// In case of success, trigger a scheduling run for pending tasks.
name|trySchedulingPendingTasks
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|taskSucceeded
condition|)
block|{
name|nodeInfo
operator|.
name|registerUnsuccessfulTaskEnd
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|endReason
operator|!=
literal|null
operator|&&
name|EnumSet
operator|.
name|of
argument_list|(
name|TaskAttemptEndReason
operator|.
name|SERVICE_BUSY
argument_list|,
name|TaskAttemptEndReason
operator|.
name|COMMUNICATION_ERROR
argument_list|)
operator|.
name|contains
argument_list|(
name|endReason
argument_list|)
condition|)
block|{
if|if
condition|(
name|endReason
operator|==
name|TaskAttemptEndReason
operator|.
name|COMMUNICATION_ERROR
condition|)
block|{
name|dagStats
operator|.
name|registerCommFailure
argument_list|(
name|taskInfo
operator|.
name|assignedInstance
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|endReason
operator|==
name|TaskAttemptEndReason
operator|.
name|SERVICE_BUSY
condition|)
block|{
name|dagStats
operator|.
name|registerTaskRejected
argument_list|(
name|taskInfo
operator|.
name|assignedInstance
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|boolean
name|commFailure
init|=
name|endReason
operator|!=
literal|null
operator|&&
name|endReason
operator|==
name|TaskAttemptEndReason
operator|.
name|COMMUNICATION_ERROR
decl_stmt|;
name|disableInstance
argument_list|(
name|assignedInstance
argument_list|,
name|commFailure
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|appClientDelegate
operator|.
name|containerBeingReleased
argument_list|(
name|taskInfo
operator|.
name|containerId
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|deallocateContainer
parameter_list|(
name|ContainerId
name|containerId
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"DEBUG: Ignoring deallocateContainer for containerId: "
operator|+
name|containerId
argument_list|)
expr_stmt|;
comment|// Containers are not being tracked for re-use.
comment|// This is safe to ignore since a deallocate task will come in.
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setShouldUnregister
parameter_list|()
block|{    }
annotation|@
name|Override
specifier|public
name|boolean
name|hasUnregistered
parameter_list|()
block|{
comment|// Nothing to do. No registration involved.
return|return
literal|true
return|;
block|}
specifier|private
name|ExecutorService
name|createAppCallbackExecutorService
parameter_list|()
block|{
return|return
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|(
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setNameFormat
argument_list|(
literal|"TaskSchedulerAppCaller #%d"
argument_list|)
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
name|TaskSchedulerAppCallback
name|createAppCallbackDelegate
parameter_list|(
name|TaskSchedulerAppCallback
name|realAppClient
parameter_list|)
block|{
return|return
operator|new
name|TaskSchedulerAppCallbackWrapper
argument_list|(
name|realAppClient
argument_list|,
name|appCallbackExecutor
argument_list|)
return|;
block|}
comment|/**    * @param request the list of preferred hosts. null implies any host    * @return    */
specifier|private
name|NodeServiceInstancePair
name|selectHost
parameter_list|(
name|TaskInfo
name|request
parameter_list|)
block|{
name|String
index|[]
name|requestedHosts
init|=
name|request
operator|.
name|requestedHosts
decl_stmt|;
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// Read-lock. Not updating any stats at the moment.
try|try
block|{
comment|// Check if any hosts are active.
if|if
condition|(
name|getAvailableResources
argument_list|()
operator|.
name|getMemory
argument_list|()
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Refreshing instances since total memory is 0"
argument_list|)
expr_stmt|;
block|}
name|refreshInstances
argument_list|()
expr_stmt|;
block|}
comment|// If there's no memory available, fail
if|if
condition|(
name|getTotalResources
argument_list|()
operator|.
name|getMemory
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|requestedHosts
operator|!=
literal|null
condition|)
block|{
name|int
name|prefHostCount
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|String
name|host
range|:
name|requestedHosts
control|)
block|{
name|prefHostCount
operator|++
expr_stmt|;
comment|// Pick the first host always. Weak attempt at cache affinity.
name|Set
argument_list|<
name|ServiceInstance
argument_list|>
name|instances
init|=
name|activeInstances
operator|.
name|getByHost
argument_list|(
name|host
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|instances
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|ServiceInstance
name|inst
range|:
name|instances
control|)
block|{
name|NodeInfo
name|nodeInfo
init|=
name|instanceToNodeMap
operator|.
name|get
argument_list|(
name|inst
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeInfo
operator|!=
literal|null
operator|&&
name|nodeInfo
operator|.
name|canAcceptTask
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Assigning "
operator|+
name|inst
operator|+
literal|" when looking for "
operator|+
name|host
operator|+
literal|"."
operator|+
literal|" FirstRequestedHost="
operator|+
operator|(
name|prefHostCount
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|NodeServiceInstancePair
argument_list|(
name|inst
argument_list|,
name|nodeInfo
argument_list|)
return|;
block|}
block|}
block|}
block|}
block|}
comment|/* fall through - miss in locality (random scheduling) */
name|Entry
argument_list|<
name|ServiceInstance
argument_list|,
name|NodeInfo
argument_list|>
index|[]
name|all
init|=
name|instanceToNodeMap
operator|.
name|entrySet
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|Entry
index|[
name|instanceToNodeMap
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
comment|// Check again
if|if
condition|(
name|all
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|int
name|n
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|all
operator|.
name|length
argument_list|)
decl_stmt|;
comment|// start at random offset and iterate whole list
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|all
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Entry
argument_list|<
name|ServiceInstance
argument_list|,
name|NodeInfo
argument_list|>
name|inst
init|=
name|all
index|[
operator|(
name|i
operator|+
name|n
operator|)
operator|%
name|all
operator|.
name|length
index|]
decl_stmt|;
if|if
condition|(
name|inst
operator|.
name|getValue
argument_list|()
operator|.
name|canAcceptTask
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Assigning "
operator|+
name|inst
operator|+
literal|" when looking for any host, from #hosts="
operator|+
name|all
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
operator|new
name|NodeServiceInstancePair
argument_list|(
name|inst
operator|.
name|getKey
argument_list|()
argument_list|,
name|inst
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|// TODO Each refresh operation should addNodes if they don't already exist.
comment|// Even better would be to get notifications from the service impl when a node gets added or removed.
comment|// Instead of having to walk through the entire list. The computation of a node getting added or
comment|// removed already exists in the DynamicRegistry implementation.
specifier|private
name|void
name|refreshInstances
parameter_list|()
block|{
try|try
block|{
name|activeInstances
operator|.
name|refresh
argument_list|()
expr_stmt|;
comment|// handles its own sync
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not refresh list of active instances"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|scanForNodeChanges
parameter_list|()
block|{
comment|/* check again whether nodes are disabled or just missing */
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|ServiceInstance
name|inst
range|:
name|activeInstances
operator|.
name|getAll
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|inst
operator|.
name|isAlive
argument_list|()
operator|&&
name|instanceToNodeMap
operator|.
name|containsKey
argument_list|(
name|inst
argument_list|)
operator|==
literal|false
condition|)
block|{
comment|/* that's a good node, not added to the allocations yet */
name|LOG
operator|.
name|info
argument_list|(
literal|"Found a new node: "
operator|+
name|inst
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|addNode
argument_list|(
name|inst
argument_list|,
operator|new
name|NodeInfo
argument_list|(
name|inst
argument_list|,
name|nodeBlacklistConf
argument_list|,
name|clock
argument_list|,
name|numSchedulableTasksPerNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|addNode
parameter_list|(
name|ServiceInstance
name|inst
parameter_list|,
name|NodeInfo
name|node
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding node: "
operator|+
name|inst
argument_list|)
expr_stmt|;
name|instanceToNodeMap
operator|.
name|put
argument_list|(
name|inst
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|// Trigger scheduling since a new node became available.
name|trySchedulingPendingTasks
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|reenableDisabledNode
parameter_list|(
name|NodeInfo
name|nodeInfo
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|nodeInfo
operator|.
name|hadCommFailure
argument_list|()
condition|)
block|{
comment|// If the node being re-enabled was not marked busy previously, then it was disabled due to
comment|// some other failure. Refresh the service list to see if it's been removed permanently.
name|refreshInstances
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Attempting to re-enable node: "
operator|+
name|nodeInfo
operator|.
name|getServiceInstance
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodeInfo
operator|.
name|getServiceInstance
argument_list|()
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|nodeInfo
operator|.
name|enableNode
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing dead node "
operator|+
name|nodeInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|disableInstance
parameter_list|(
name|ServiceInstance
name|instance
parameter_list|,
name|boolean
name|isCommFailure
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|NodeInfo
name|nodeInfo
init|=
name|instanceToNodeMap
operator|.
name|get
argument_list|(
name|instance
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeInfo
operator|==
literal|null
operator|||
name|nodeInfo
operator|.
name|isDisabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node: "
operator|+
name|instance
operator|+
literal|" already disabled, or invalid. Not doing anything."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|nodeInfo
operator|.
name|disableNode
argument_list|(
name|isCommFailure
argument_list|)
expr_stmt|;
comment|// TODO: handle task to container map events in case of hard failures
name|disabledNodesQueue
operator|.
name|add
argument_list|(
name|nodeInfo
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|addPendingTask
parameter_list|(
name|TaskInfo
name|taskInfo
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|tasksAtPriority
init|=
name|pendingTasks
operator|.
name|get
argument_list|(
name|taskInfo
operator|.
name|priority
argument_list|)
decl_stmt|;
if|if
condition|(
name|tasksAtPriority
operator|==
literal|null
condition|)
block|{
name|tasksAtPriority
operator|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
expr_stmt|;
name|pendingTasks
operator|.
name|put
argument_list|(
name|taskInfo
operator|.
name|priority
argument_list|,
name|tasksAtPriority
argument_list|)
expr_stmt|;
block|}
name|tasksAtPriority
operator|.
name|add
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
name|knownTasks
operator|.
name|putIfAbsent
argument_list|(
name|taskInfo
operator|.
name|task
argument_list|,
name|taskInfo
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Remove a task from the pending list */
specifier|private
name|void
name|removePendingTask
parameter_list|(
name|TaskInfo
name|taskInfo
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|Priority
name|priority
init|=
name|taskInfo
operator|.
name|priority
decl_stmt|;
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|taskInfoList
init|=
name|pendingTasks
operator|.
name|get
argument_list|(
name|priority
argument_list|)
decl_stmt|;
if|if
condition|(
name|taskInfoList
operator|==
literal|null
operator|||
name|taskInfoList
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|taskInfoList
operator|.
name|remove
argument_list|(
name|taskInfo
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not find task: "
operator|+
name|taskInfo
operator|.
name|task
operator|+
literal|" in pending list, at priority: "
operator|+
name|priority
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Register a running task into the runningTasks structure */
specifier|private
name|void
name|registerRunningTask
parameter_list|(
name|TaskInfo
name|taskInfo
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|priority
init|=
name|taskInfo
operator|.
name|priority
operator|.
name|getPriority
argument_list|()
decl_stmt|;
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
name|tasksAtpriority
init|=
name|runningTasks
operator|.
name|get
argument_list|(
name|priority
argument_list|)
decl_stmt|;
if|if
condition|(
name|tasksAtpriority
operator|==
literal|null
condition|)
block|{
name|tasksAtpriority
operator|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|TASK_INFO_COMPARATOR
argument_list|)
expr_stmt|;
name|runningTasks
operator|.
name|put
argument_list|(
name|priority
argument_list|,
name|tasksAtpriority
argument_list|)
expr_stmt|;
block|}
name|tasksAtpriority
operator|.
name|add
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Unregister a task from the known and running structures */
specifier|private
name|TaskInfo
name|unregisterTask
parameter_list|(
name|Object
name|task
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|TaskInfo
name|taskInfo
init|=
name|knownTasks
operator|.
name|remove
argument_list|(
name|task
argument_list|)
decl_stmt|;
if|if
condition|(
name|taskInfo
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|taskInfo
operator|.
name|assigned
condition|)
block|{
comment|// Remove from the running list.
name|int
name|priority
init|=
name|taskInfo
operator|.
name|priority
operator|.
name|getPriority
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|TaskInfo
argument_list|>
name|tasksAtPriority
init|=
name|runningTasks
operator|.
name|get
argument_list|(
name|priority
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|tasksAtPriority
operator|!=
literal|null
argument_list|,
literal|"runningTasks should contain an entry if the task was in running state. Caused by task: {}"
argument_list|,
name|task
argument_list|)
expr_stmt|;
name|tasksAtPriority
operator|.
name|remove
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|tasksAtPriority
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|runningTasks
operator|.
name|remove
argument_list|(
name|priority
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not find TaskInfo for task: {}. Not removing it from the running set"
argument_list|,
name|task
argument_list|)
expr_stmt|;
block|}
return|return
name|taskInfo
return|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|protected
name|void
name|schedulePendingTasks
parameter_list|()
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|Priority
argument_list|,
name|List
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
argument_list|>
name|pendingIterator
init|=
name|pendingTasks
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|pendingIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|Priority
argument_list|,
name|List
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|entry
init|=
name|pendingIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|taskListAtPriority
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|TaskInfo
argument_list|>
name|taskIter
init|=
name|taskListAtPriority
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|boolean
name|scheduledAllAtPriority
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|taskIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// TODO Optimization: Add a check to see if there's any capacity available. No point in
comment|// walking through all active nodes, if they don't have potential capacity.
name|TaskInfo
name|taskInfo
init|=
name|taskIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|taskInfo
operator|.
name|getNumPreviousAssignAttempts
argument_list|()
operator|==
literal|1
condition|)
block|{
name|dagStats
operator|.
name|registerDelayedAllocation
argument_list|()
expr_stmt|;
block|}
name|taskInfo
operator|.
name|triedAssigningTask
argument_list|()
expr_stmt|;
name|boolean
name|scheduled
init|=
name|scheduleTask
argument_list|(
name|taskInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|scheduled
condition|)
block|{
name|taskIter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Try pre-empting a task so that a higher priority task can take it's place.
comment|// Preempt only if there's not pending preemptions to avoid preempting twice for a task.
name|LOG
operator|.
name|info
argument_list|(
literal|"Attempting to preempt for {}, pendingPreemptions={}"
argument_list|,
name|taskInfo
operator|.
name|task
argument_list|,
name|pendingPreemptions
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pendingPreemptions
operator|.
name|get
argument_list|()
operator|==
literal|0
condition|)
block|{
name|preemptTasks
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getPriority
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|scheduledAllAtPriority
operator|=
literal|false
expr_stmt|;
comment|// Don't try assigning tasks at the next priority.
break|break;
block|}
block|}
if|if
condition|(
name|taskListAtPriority
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Remove the entry, if there's nothing left at the specific priority level
name|pendingIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|scheduledAllAtPriority
condition|)
block|{
comment|// Don't attempt scheduling for additional priorities
break|break;
block|}
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|scheduleTask
parameter_list|(
name|TaskInfo
name|taskInfo
parameter_list|)
block|{
name|NodeServiceInstancePair
name|nsPair
init|=
name|selectHost
argument_list|(
name|taskInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|nsPair
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
name|Container
name|container
init|=
name|containerFactory
operator|.
name|createContainer
argument_list|(
name|resourcePerExecutor
argument_list|,
name|taskInfo
operator|.
name|priority
argument_list|,
name|nsPair
operator|.
name|getServiceInstance
argument_list|()
operator|.
name|getHost
argument_list|()
argument_list|,
name|nsPair
operator|.
name|getServiceInstance
argument_list|()
operator|.
name|getRpcPort
argument_list|()
argument_list|)
decl_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// While updating local structures
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Assigned task {} to container {}"
argument_list|,
name|taskInfo
argument_list|,
name|container
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|dagStats
operator|.
name|registerTaskAllocated
argument_list|(
name|taskInfo
operator|.
name|requestedHosts
argument_list|,
name|taskInfo
operator|.
name|requestedRacks
argument_list|,
name|nsPair
operator|.
name|getServiceInstance
argument_list|()
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
name|taskInfo
operator|.
name|setAssignmentInfo
argument_list|(
name|nsPair
operator|.
name|getServiceInstance
argument_list|()
argument_list|,
name|container
operator|.
name|getId
argument_list|()
argument_list|,
name|clock
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
name|registerRunningTask
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
name|nsPair
operator|.
name|getNodeInfo
argument_list|()
operator|.
name|registerTaskScheduled
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|appClientDelegate
operator|.
name|taskAllocated
argument_list|(
name|taskInfo
operator|.
name|task
argument_list|,
name|taskInfo
operator|.
name|clientCookie
argument_list|,
name|container
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|// Removes tasks from the runningList and sends out a preempt request to the system.
comment|// Subsequent tasks will be scheduled again once the de-allocate request for the preempted
comment|// task is processed.
specifier|private
name|void
name|preemptTasks
parameter_list|(
name|int
name|forPriority
parameter_list|,
name|int
name|numTasksToPreempt
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|preemptedTaskList
init|=
literal|null
decl_stmt|;
try|try
block|{
name|NavigableMap
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|orderedMap
init|=
name|runningTasks
operator|.
name|descendingMap
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
argument_list|>
name|iterator
init|=
name|orderedMap
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|preemptedCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
operator|&&
name|preemptedCount
operator|<
name|numTasksToPreempt
condition|)
block|{
name|Entry
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|entryAtPriority
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryAtPriority
operator|.
name|getKey
argument_list|()
operator|>
name|forPriority
condition|)
block|{
name|Iterator
argument_list|<
name|TaskInfo
argument_list|>
name|taskInfoIterator
init|=
name|entryAtPriority
operator|.
name|getValue
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|taskInfoIterator
operator|.
name|hasNext
argument_list|()
operator|&&
name|preemptedCount
operator|<
name|numTasksToPreempt
condition|)
block|{
name|TaskInfo
name|taskInfo
init|=
name|taskInfoIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|preemptedCount
operator|++
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"preempting {} for task at priority {}"
argument_list|,
name|taskInfo
argument_list|,
name|forPriority
argument_list|)
expr_stmt|;
name|taskInfo
operator|.
name|setPreemptedInfo
argument_list|(
name|clock
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|preemptedTaskList
operator|==
literal|null
condition|)
block|{
name|preemptedTaskList
operator|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|dagStats
operator|.
name|registerTaskPreempted
argument_list|(
name|taskInfo
operator|.
name|assignedInstance
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
name|preemptedTaskList
operator|.
name|add
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
name|pendingPreemptions
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
comment|// Remove from the runningTaskList
name|taskInfoIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
comment|// Remove entire priority level if it's been emptied.
if|if
condition|(
name|entryAtPriority
operator|.
name|getValue
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// No tasks qualify as preemptable
name|LOG
operator|.
name|info
argument_list|(
literal|"DBG: No tasks qualify as killable to schedule tasks at priority {}"
argument_list|,
name|forPriority
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// Send out the preempted request outside of the lock.
if|if
condition|(
name|preemptedTaskList
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|TaskInfo
name|taskInfo
range|:
name|preemptedTaskList
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"DBG: Preempting task {}"
argument_list|,
name|taskInfo
argument_list|)
expr_stmt|;
name|appClientDelegate
operator|.
name|preemptContainer
argument_list|(
name|taskInfo
operator|.
name|containerId
argument_list|)
expr_stmt|;
block|}
block|}
comment|// The schedule loop will be triggered again when the deallocateTask request comes in for the
comment|// preempted task.
block|}
specifier|private
class|class
name|NodeEnablerCallable
implements|implements
name|Callable
argument_list|<
name|Void
argument_list|>
block|{
specifier|private
name|AtomicBoolean
name|isShutdown
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|REFRESH_INTERVAL
init|=
literal|10000l
decl_stmt|;
name|long
name|nextPollInterval
init|=
name|REFRESH_INTERVAL
decl_stmt|;
name|long
name|lastRefreshTime
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
block|{
name|lastRefreshTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|isShutdown
operator|.
name|get
argument_list|()
operator|&&
operator|!
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|NodeInfo
name|nodeInfo
init|=
name|disabledNodesQueue
operator|.
name|poll
argument_list|(
name|nextPollInterval
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeInfo
operator|!=
literal|null
condition|)
block|{
name|long
name|currentTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// A node became available. Enable the node and try scheduling.
name|reenableDisabledNode
argument_list|(
name|nodeInfo
argument_list|)
expr_stmt|;
name|trySchedulingPendingTasks
argument_list|()
expr_stmt|;
name|nextPollInterval
operator|-=
operator|(
name|currentTime
operator|-
name|lastRefreshTime
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|nextPollInterval
operator|<
literal|0
operator|||
name|nodeInfo
operator|==
literal|null
condition|)
block|{
comment|// timeout expired. Reset the poll interval and refresh nodes.
name|nextPollInterval
operator|=
name|REFRESH_INTERVAL
expr_stmt|;
name|lastRefreshTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
comment|// TODO Get rid of this polling once we have notificaitons from the registry sub-system
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Refreshing instances based on poll interval"
argument_list|)
expr_stmt|;
block|}
name|refreshInstances
argument_list|()
expr_stmt|;
name|scanForNodeChanges
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isShutdown
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"NodeEnabler thread interrupted after shutdown"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"NodeEnabler thread interrupted without being shutdown"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"NodeEnabler thread interrupted without being shutdown"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|// Call this first, then send in an interrupt to the thread.
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|isShutdown
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|trySchedulingPendingTasks
parameter_list|()
block|{
name|scheduleLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|scheduleCondition
operator|.
name|signal
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|scheduleLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
class|class
name|SchedulerCallable
implements|implements
name|Callable
argument_list|<
name|Void
argument_list|>
block|{
specifier|private
name|AtomicBoolean
name|isShutdown
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
block|{
while|while
condition|(
operator|!
name|isShutdown
operator|.
name|get
argument_list|()
operator|&&
operator|!
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
name|scheduleLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|scheduleCondition
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isShutdown
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Scheduler thread interrupted after shutdown"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Scheduler thread interrupted without being shutdown"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Scheduler thread interrupted without being shutdown"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|scheduleLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// Schedule outside of the scheduleLock - which should only be used to wait on the condition.
name|schedulePendingTasks
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|// Call this first, then send in an interrupt to the thread.
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|isShutdown
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|static
class|class
name|NodeInfo
implements|implements
name|Delayed
block|{
specifier|private
specifier|final
name|NodeBlacklistConf
name|blacklistConf
decl_stmt|;
specifier|final
name|ServiceInstance
name|serviceInstance
decl_stmt|;
specifier|private
specifier|final
name|Clock
name|clock
decl_stmt|;
name|long
name|expireTimeMillis
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|long
name|numSuccessfulTasks
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|numSuccessfulTasksAtLastBlacklist
init|=
operator|-
literal|1
decl_stmt|;
name|float
name|cumulativeBackoffFactor
init|=
literal|1.0f
decl_stmt|;
comment|// Indicates whether a node had a recent communication failure.
specifier|private
name|boolean
name|hadCommFailure
init|=
literal|false
decl_stmt|;
comment|// Indicates whether a node is disabled - for whatever reason - commFailure, busy, etc.
specifier|private
name|boolean
name|disabled
init|=
literal|false
decl_stmt|;
specifier|private
name|int
name|numPreemptedTasks
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|numScheduledTasks
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|int
name|numSchedulableTasks
decl_stmt|;
comment|/**      * Create a NodeInfo bound to a service instance      *      * @param serviceInstance         the associated serviceInstance      * @param blacklistConf           blacklist configuration      * @param clock                   clock to use to obtain timing information      * @param numSchedulableTasksConf number of schedulable tasks on the node. 0 represents auto      *                                detect based on the serviceInstance, -1 indicates indicates      *                                unlimited capacity      */
name|NodeInfo
parameter_list|(
name|ServiceInstance
name|serviceInstance
parameter_list|,
name|NodeBlacklistConf
name|blacklistConf
parameter_list|,
name|Clock
name|clock
parameter_list|,
name|int
name|numSchedulableTasksConf
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|numSchedulableTasksConf
operator|>=
operator|-
literal|1
argument_list|,
literal|"NumSchedulableTasks must be>=-1"
argument_list|)
expr_stmt|;
name|this
operator|.
name|serviceInstance
operator|=
name|serviceInstance
expr_stmt|;
name|this
operator|.
name|blacklistConf
operator|=
name|blacklistConf
expr_stmt|;
name|this
operator|.
name|clock
operator|=
name|clock
expr_stmt|;
if|if
condition|(
name|numSchedulableTasksConf
operator|==
literal|0
condition|)
block|{
name|int
name|pendingQueueuCapacity
init|=
literal|0
decl_stmt|;
name|String
name|pendingQueueCapacityString
init|=
name|serviceInstance
operator|.
name|getProperties
argument_list|()
operator|.
name|get
argument_list|(
name|LlapConfiguration
operator|.
name|LLAP_DAEMON_TASK_SCHEDULER_WAIT_QUEUE_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Setting up node: "
operator|+
name|serviceInstance
operator|+
literal|", with available capacity="
operator|+
name|serviceInstance
operator|.
name|getResource
argument_list|()
operator|.
name|getVirtualCores
argument_list|()
operator|+
literal|", pendingQueueCapacity="
operator|+
name|pendingQueueCapacityString
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pendingQueueCapacityString
operator|!=
literal|null
condition|)
block|{
name|pendingQueueuCapacity
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|pendingQueueCapacityString
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|numSchedulableTasks
operator|=
name|serviceInstance
operator|.
name|getResource
argument_list|()
operator|.
name|getVirtualCores
argument_list|()
operator|+
name|pendingQueueuCapacity
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|numSchedulableTasks
operator|=
name|numSchedulableTasksConf
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Setting up node: "
operator|+
name|serviceInstance
operator|+
literal|" with schedulableCapacity="
operator|+
name|this
operator|.
name|numSchedulableTasks
argument_list|)
expr_stmt|;
block|}
name|ServiceInstance
name|getServiceInstance
parameter_list|()
block|{
return|return
name|serviceInstance
return|;
block|}
name|void
name|enableNode
parameter_list|()
block|{
name|expireTimeMillis
operator|=
operator|-
literal|1
expr_stmt|;
name|disabled
operator|=
literal|false
expr_stmt|;
name|hadCommFailure
operator|=
literal|false
expr_stmt|;
block|}
name|void
name|disableNode
parameter_list|(
name|boolean
name|commFailure
parameter_list|)
block|{
name|long
name|duration
init|=
name|blacklistConf
operator|.
name|minDelay
decl_stmt|;
name|long
name|currentTime
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|this
operator|.
name|hadCommFailure
operator|=
name|commFailure
expr_stmt|;
name|disabled
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|numSuccessfulTasksAtLastBlacklist
operator|==
name|numSuccessfulTasks
condition|)
block|{
comment|// Relying on a task succeeding to reset the exponent.
comment|// There's no notifications on whether a task gets accepted or not. That would be ideal to
comment|// reset this.
name|cumulativeBackoffFactor
operator|=
name|cumulativeBackoffFactor
operator|*
name|blacklistConf
operator|.
name|backoffFactor
expr_stmt|;
block|}
else|else
block|{
comment|// Was able to execute something before the last blacklist. Reset the exponent.
name|cumulativeBackoffFactor
operator|=
literal|1.0f
expr_stmt|;
block|}
name|long
name|delayTime
init|=
call|(
name|long
call|)
argument_list|(
name|duration
operator|*
name|cumulativeBackoffFactor
argument_list|)
decl_stmt|;
if|if
condition|(
name|delayTime
operator|>
name|blacklistConf
operator|.
name|maxDelay
condition|)
block|{
name|delayTime
operator|=
name|blacklistConf
operator|.
name|maxDelay
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Disabling instance "
operator|+
name|serviceInstance
operator|+
literal|" for "
operator|+
name|delayTime
operator|+
literal|" milli-seconds"
argument_list|)
expr_stmt|;
block|}
name|expireTimeMillis
operator|=
name|currentTime
operator|+
name|delayTime
expr_stmt|;
name|numSuccessfulTasksAtLastBlacklist
operator|=
name|numSuccessfulTasks
expr_stmt|;
block|}
name|void
name|registerTaskScheduled
parameter_list|()
block|{
name|numScheduledTasks
operator|++
expr_stmt|;
block|}
name|void
name|registerTaskSuccess
parameter_list|()
block|{
name|numSuccessfulTasks
operator|++
expr_stmt|;
name|numScheduledTasks
operator|--
expr_stmt|;
block|}
name|void
name|registerUnsuccessfulTaskEnd
parameter_list|(
name|boolean
name|wasPreempted
parameter_list|)
block|{
name|numScheduledTasks
operator|--
expr_stmt|;
if|if
condition|(
name|wasPreempted
condition|)
block|{
name|numPreemptedTasks
operator|++
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|isDisabled
parameter_list|()
block|{
return|return
name|disabled
return|;
block|}
specifier|public
name|boolean
name|hadCommFailure
parameter_list|()
block|{
return|return
name|hadCommFailure
return|;
block|}
comment|/* Returning true does not guarantee that the task will run, considering other queries     may be running in the system. Also depends upon the capacity usage configuration      */
specifier|public
name|boolean
name|canAcceptTask
parameter_list|()
block|{
name|boolean
name|result
init|=
operator|!
name|hadCommFailure
operator|&&
operator|!
name|disabled
operator|&&
name|serviceInstance
operator|.
name|isAlive
argument_list|()
operator|&&
operator|(
name|numSchedulableTasks
operator|==
operator|-
literal|1
operator|||
operator|(
operator|(
name|numSchedulableTasks
operator|-
name|numScheduledTasks
operator|)
operator|>
literal|0
operator|)
operator|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"canAcceptTask={}, numScheduledTasks={}, numSchedulableTasks={}, hadCommFailure={}, disabled={}, serviceInstance.isAlive={}"
argument_list|,
name|result
argument_list|,
name|numScheduledTasks
argument_list|,
name|numSchedulableTasks
argument_list|,
name|hadCommFailure
argument_list|,
name|disabled
argument_list|,
name|serviceInstance
operator|.
name|isAlive
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getDelay
parameter_list|(
name|TimeUnit
name|unit
parameter_list|)
block|{
return|return
name|unit
operator|.
name|convert
argument_list|(
name|expireTimeMillis
operator|-
name|clock
operator|.
name|getTime
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
name|Delayed
name|o
parameter_list|)
block|{
name|NodeInfo
name|other
init|=
operator|(
name|NodeInfo
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|other
operator|.
name|expireTimeMillis
operator|>
name|this
operator|.
name|expireTimeMillis
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|other
operator|.
name|expireTimeMillis
operator|<
name|this
operator|.
name|expireTimeMillis
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"NodeInfo{"
operator|+
literal|"instance="
operator|+
name|serviceInstance
operator|+
literal|", expireTimeMillis="
operator|+
name|expireTimeMillis
operator|+
literal|", numSuccessfulTasks="
operator|+
name|numSuccessfulTasks
operator|+
literal|", numSuccessfulTasksAtLastBlacklist="
operator|+
name|numSuccessfulTasksAtLastBlacklist
operator|+
literal|", cumulativeBackoffFactor="
operator|+
name|cumulativeBackoffFactor
operator|+
literal|", numSchedulableTasks="
operator|+
name|numSchedulableTasks
operator|+
literal|", numScheduledTasks="
operator|+
name|numScheduledTasks
operator|+
literal|", disabled="
operator|+
name|disabled
operator|+
literal|", commFailures="
operator|+
name|hadCommFailure
operator|+
literal|'}'
return|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|static
class|class
name|StatsPerDag
block|{
name|int
name|numRequestedAllocations
init|=
literal|0
decl_stmt|;
name|int
name|numRequestsWithLocation
init|=
literal|0
decl_stmt|;
name|int
name|numRequestsWithoutLocation
init|=
literal|0
decl_stmt|;
name|int
name|numLocalAllocations
init|=
literal|0
decl_stmt|;
name|int
name|numNonLocalAllocations
init|=
literal|0
decl_stmt|;
name|int
name|numAllocationsNoLocalityRequest
init|=
literal|0
decl_stmt|;
name|int
name|numRejectedTasks
init|=
literal|0
decl_stmt|;
name|int
name|numCommFailures
init|=
literal|0
decl_stmt|;
name|int
name|numDelayedAllocations
init|=
literal|0
decl_stmt|;
name|int
name|numPreemptedTasks
init|=
literal|0
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
name|localityBasedNumAllocationsPerHost
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
name|numAllocationsPerHost
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumPreemptedTasks="
argument_list|)
operator|.
name|append
argument_list|(
name|numPreemptedTasks
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumRequestedAllocations="
argument_list|)
operator|.
name|append
argument_list|(
name|numRequestedAllocations
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumRequestsWithlocation="
argument_list|)
operator|.
name|append
argument_list|(
name|numRequestsWithLocation
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumLocalAllocations="
argument_list|)
operator|.
name|append
argument_list|(
name|numLocalAllocations
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumNonLocalAllocations="
argument_list|)
operator|.
name|append
argument_list|(
name|numNonLocalAllocations
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumRequestsWithoutLocation="
argument_list|)
operator|.
name|append
argument_list|(
name|numRequestsWithoutLocation
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumRejectedTasks="
argument_list|)
operator|.
name|append
argument_list|(
name|numRejectedTasks
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumCommFailures="
argument_list|)
operator|.
name|append
argument_list|(
name|numCommFailures
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumDelayedAllocations="
argument_list|)
operator|.
name|append
argument_list|(
name|numDelayedAllocations
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"LocalityBasedAllocationsPerHost="
argument_list|)
operator|.
name|append
argument_list|(
name|localityBasedNumAllocationsPerHost
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumAllocationsPerHost="
argument_list|)
operator|.
name|append
argument_list|(
name|numAllocationsPerHost
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
name|void
name|registerTaskRequest
parameter_list|(
name|String
index|[]
name|requestedHosts
parameter_list|,
name|String
index|[]
name|requestedRacks
parameter_list|)
block|{
name|numRequestedAllocations
operator|++
expr_stmt|;
comment|// TODO Change after HIVE-9987. For now, there's no rack matching.
if|if
condition|(
name|requestedHosts
operator|!=
literal|null
operator|&&
name|requestedHosts
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|numRequestsWithLocation
operator|++
expr_stmt|;
block|}
else|else
block|{
name|numRequestsWithoutLocation
operator|++
expr_stmt|;
block|}
block|}
name|void
name|registerTaskAllocated
parameter_list|(
name|String
index|[]
name|requestedHosts
parameter_list|,
name|String
index|[]
name|requestedRacks
parameter_list|,
name|String
name|allocatedHost
parameter_list|)
block|{
comment|// TODO Change after HIVE-9987. For now, there's no rack matching.
if|if
condition|(
name|requestedHosts
operator|!=
literal|null
operator|&&
name|requestedHosts
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|requestedHostSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|requestedHosts
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|requestedHostSet
operator|.
name|contains
argument_list|(
name|allocatedHost
argument_list|)
condition|)
block|{
name|numLocalAllocations
operator|++
expr_stmt|;
name|_registerAllocationInHostMap
argument_list|(
name|allocatedHost
argument_list|,
name|localityBasedNumAllocationsPerHost
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|numNonLocalAllocations
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|numAllocationsNoLocalityRequest
operator|++
expr_stmt|;
block|}
name|_registerAllocationInHostMap
argument_list|(
name|allocatedHost
argument_list|,
name|numAllocationsPerHost
argument_list|)
expr_stmt|;
block|}
name|void
name|registerTaskPreempted
parameter_list|(
name|String
name|host
parameter_list|)
block|{
name|numPreemptedTasks
operator|++
expr_stmt|;
block|}
name|void
name|registerCommFailure
parameter_list|(
name|String
name|host
parameter_list|)
block|{
name|numCommFailures
operator|++
expr_stmt|;
block|}
name|void
name|registerTaskRejected
parameter_list|(
name|String
name|host
parameter_list|)
block|{
name|numRejectedTasks
operator|++
expr_stmt|;
block|}
name|void
name|registerDelayedAllocation
parameter_list|()
block|{
name|numDelayedAllocations
operator|++
expr_stmt|;
block|}
specifier|private
name|void
name|_registerAllocationInHostMap
parameter_list|(
name|String
name|host
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
name|hostMap
parameter_list|)
block|{
name|AtomicInteger
name|val
init|=
name|hostMap
operator|.
name|get
argument_list|(
name|host
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
name|val
operator|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hostMap
operator|.
name|put
argument_list|(
name|host
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|val
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
class|class
name|TaskInfo
block|{
comment|// IDs used to ensure two TaskInfos are different without using the underlying task instance.
comment|// Required for insertion into a TreeMap
specifier|static
specifier|final
name|AtomicLong
name|ID_GEN
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|long
name|uniqueId
decl_stmt|;
specifier|final
name|Object
name|task
decl_stmt|;
specifier|final
name|Object
name|clientCookie
decl_stmt|;
specifier|final
name|Priority
name|priority
decl_stmt|;
specifier|final
name|Resource
name|capability
decl_stmt|;
specifier|final
name|String
index|[]
name|requestedHosts
decl_stmt|;
specifier|final
name|String
index|[]
name|requestedRacks
decl_stmt|;
specifier|final
name|long
name|requestTime
decl_stmt|;
name|long
name|startTime
decl_stmt|;
name|long
name|preemptTime
decl_stmt|;
name|ContainerId
name|containerId
decl_stmt|;
name|ServiceInstance
name|assignedInstance
decl_stmt|;
specifier|private
name|boolean
name|assigned
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|preempted
init|=
literal|false
decl_stmt|;
specifier|private
name|int
name|numAssignAttempts
init|=
literal|0
decl_stmt|;
comment|// TaskInfo instances for two different tasks will not be the same. Only a single instance should
comment|// ever be created for a taskAttempt
specifier|public
name|TaskInfo
parameter_list|(
name|Object
name|task
parameter_list|,
name|Object
name|clientCookie
parameter_list|,
name|Priority
name|priority
parameter_list|,
name|Resource
name|capability
parameter_list|,
name|String
index|[]
name|hosts
parameter_list|,
name|String
index|[]
name|racks
parameter_list|,
name|long
name|requestTime
parameter_list|)
block|{
name|this
operator|.
name|task
operator|=
name|task
expr_stmt|;
name|this
operator|.
name|clientCookie
operator|=
name|clientCookie
expr_stmt|;
name|this
operator|.
name|priority
operator|=
name|priority
expr_stmt|;
name|this
operator|.
name|capability
operator|=
name|capability
expr_stmt|;
name|this
operator|.
name|requestedHosts
operator|=
name|hosts
expr_stmt|;
name|this
operator|.
name|requestedRacks
operator|=
name|racks
expr_stmt|;
name|this
operator|.
name|requestTime
operator|=
name|requestTime
expr_stmt|;
name|this
operator|.
name|uniqueId
operator|=
name|ID_GEN
operator|.
name|getAndIncrement
argument_list|()
expr_stmt|;
block|}
name|void
name|setAssignmentInfo
parameter_list|(
name|ServiceInstance
name|instance
parameter_list|,
name|ContainerId
name|containerId
parameter_list|,
name|long
name|startTime
parameter_list|)
block|{
name|this
operator|.
name|assignedInstance
operator|=
name|instance
expr_stmt|;
name|this
operator|.
name|containerId
operator|=
name|containerId
expr_stmt|;
name|this
operator|.
name|startTime
operator|=
name|startTime
expr_stmt|;
name|assigned
operator|=
literal|true
expr_stmt|;
block|}
name|void
name|setPreemptedInfo
parameter_list|(
name|long
name|preemptTime
parameter_list|)
block|{
name|this
operator|.
name|preempted
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|assigned
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|preemptTime
operator|=
name|preemptTime
expr_stmt|;
block|}
name|void
name|triedAssigningTask
parameter_list|()
block|{
name|numAssignAttempts
operator|++
expr_stmt|;
block|}
name|int
name|getNumPreviousAssignAttempts
parameter_list|()
block|{
return|return
name|numAssignAttempts
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|TaskInfo
name|taskInfo
init|=
operator|(
name|TaskInfo
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|uniqueId
operator|!=
name|taskInfo
operator|.
name|uniqueId
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|task
operator|.
name|equals
argument_list|(
name|taskInfo
operator|.
name|task
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|result
init|=
call|(
name|int
call|)
argument_list|(
name|uniqueId
operator|^
operator|(
name|uniqueId
operator|>>>
literal|32
operator|)
argument_list|)
decl_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
name|task
operator|.
name|hashCode
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"TaskInfo{"
operator|+
literal|"task="
operator|+
name|task
operator|+
literal|", priority="
operator|+
name|priority
operator|+
literal|", startTime="
operator|+
name|startTime
operator|+
literal|", containerId="
operator|+
name|containerId
operator|+
literal|", assignedInstance="
operator|+
name|assignedInstance
operator|+
literal|", uniqueId="
operator|+
name|uniqueId
operator|+
literal|'}'
return|;
block|}
block|}
comment|// Newer tasks first.
specifier|private
specifier|static
class|class
name|TaskStartComparator
implements|implements
name|Comparator
argument_list|<
name|TaskInfo
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|TaskInfo
name|o1
parameter_list|,
name|TaskInfo
name|o2
parameter_list|)
block|{
if|if
condition|(
name|o1
operator|.
name|startTime
operator|>
name|o2
operator|.
name|startTime
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|o1
operator|.
name|startTime
operator|<
name|o2
operator|.
name|startTime
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
comment|// Comparing on time is not sufficient since two may be created at the same time,
comment|// in which case inserting into a TreeSet/Map would break
if|if
condition|(
name|o1
operator|.
name|uniqueId
operator|>
name|o2
operator|.
name|uniqueId
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|o1
operator|.
name|uniqueId
operator|<
name|o2
operator|.
name|uniqueId
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
specifier|private
specifier|static
class|class
name|NodeServiceInstancePair
block|{
specifier|final
name|NodeInfo
name|nodeInfo
decl_stmt|;
specifier|final
name|ServiceInstance
name|serviceInstance
decl_stmt|;
specifier|private
name|NodeServiceInstancePair
parameter_list|(
name|ServiceInstance
name|serviceInstance
parameter_list|,
name|NodeInfo
name|nodeInfo
parameter_list|)
block|{
name|this
operator|.
name|serviceInstance
operator|=
name|serviceInstance
expr_stmt|;
name|this
operator|.
name|nodeInfo
operator|=
name|nodeInfo
expr_stmt|;
block|}
specifier|public
name|ServiceInstance
name|getServiceInstance
parameter_list|()
block|{
return|return
name|serviceInstance
return|;
block|}
specifier|public
name|NodeInfo
name|getNodeInfo
parameter_list|()
block|{
return|return
name|nodeInfo
return|;
block|}
block|}
specifier|private
specifier|static
specifier|final
class|class
name|NodeBlacklistConf
block|{
specifier|private
specifier|final
name|long
name|minDelay
decl_stmt|;
specifier|private
specifier|final
name|long
name|maxDelay
decl_stmt|;
specifier|private
specifier|final
name|float
name|backoffFactor
decl_stmt|;
specifier|public
name|NodeBlacklistConf
parameter_list|(
name|long
name|minDelay
parameter_list|,
name|long
name|maxDelay
parameter_list|,
name|float
name|backoffFactor
parameter_list|)
block|{
name|this
operator|.
name|minDelay
operator|=
name|minDelay
expr_stmt|;
name|this
operator|.
name|maxDelay
operator|=
name|maxDelay
expr_stmt|;
name|this
operator|.
name|backoffFactor
operator|=
name|backoffFactor
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"NodeBlacklistConf{"
operator|+
literal|"minDelay="
operator|+
name|minDelay
operator|+
literal|", maxDelay="
operator|+
name|maxDelay
operator|+
literal|", backoffFactor="
operator|+
name|backoffFactor
operator|+
literal|'}'
return|;
block|}
block|}
block|}
end_class

end_unit

