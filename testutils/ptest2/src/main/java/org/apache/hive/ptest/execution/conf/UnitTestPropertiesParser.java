begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|ptest
operator|.
name|execution
operator|.
name|conf
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Splitter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_class
class|class
name|UnitTestPropertiesParser
block|{
specifier|private
specifier|static
specifier|final
name|Splitter
name|VALUE_SPLITTER
init|=
name|Splitter
operator|.
name|onPattern
argument_list|(
literal|"[, ]"
argument_list|)
operator|.
name|trimResults
argument_list|()
operator|.
name|omitEmptyStrings
argument_list|()
decl_stmt|;
comment|// Prefix for top level properties.
specifier|static
specifier|final
name|String
name|PROP_PREFIX_ROOT
init|=
literal|"unitTests"
decl_stmt|;
comment|// Prefix used to specify module specific properties. Mainly to avoid conflicts with older unitTests properties
specifier|static
specifier|final
name|String
name|PROP_PREFIX_MODULE
init|=
literal|"ut"
decl_stmt|;
specifier|static
specifier|final
name|String
name|PROP_DIRECTORIES
init|=
literal|"directories"
decl_stmt|;
specifier|static
specifier|final
name|String
name|PROP_INCLUDE
init|=
literal|"include"
decl_stmt|;
specifier|static
specifier|final
name|String
name|PROP_EXCLUDE
init|=
literal|"exclude"
decl_stmt|;
specifier|static
specifier|final
name|String
name|PROP_ISOLATE
init|=
literal|"isolate"
decl_stmt|;
specifier|static
specifier|final
name|String
name|PROP_SKIP_BATCHING
init|=
literal|"skipBatching"
decl_stmt|;
specifier|static
specifier|final
name|String
name|PROP_BATCH_SIZE
init|=
literal|"batchSize"
decl_stmt|;
specifier|static
specifier|final
name|String
name|PROP_SUBDIR_FOR_PREFIX
init|=
literal|"subdirForPrefix"
decl_stmt|;
specifier|static
specifier|final
name|String
name|PROP_ONE_MODULE
init|=
literal|"module"
decl_stmt|;
specifier|static
specifier|final
name|String
name|PROP_MODULE_LIST
init|=
literal|"modules"
decl_stmt|;
specifier|static
specifier|final
name|int
name|DEFAULT_PROP_BATCH_SIZE
init|=
literal|1
decl_stmt|;
specifier|static
specifier|final
name|int
name|DEFAULT_PROP_BATCH_SIZE_NOT_SPECIFIED
init|=
operator|-
literal|1
decl_stmt|;
specifier|static
specifier|final
name|int
name|DEFAULT_PROP_BATCH_SIZE_INCLUDE_ALL
init|=
literal|0
decl_stmt|;
specifier|static
specifier|final
name|String
name|DEFAULT_PROP_DIRECTORIES
init|=
literal|"."
decl_stmt|;
specifier|static
specifier|final
name|String
name|DEFAULT_PROP_SUBDIR_FOR_PREFIX
init|=
literal|"target"
decl_stmt|;
specifier|static
specifier|final
name|String
name|MODULE_NAME_TOP_LEVEL
init|=
literal|"_root_"
decl_stmt|;
comment|// Special module for tests in the rootDir.
specifier|static
specifier|final
name|String
name|PREFIX_TOP_LEVEL
init|=
literal|"."
decl_stmt|;
specifier|private
specifier|final
name|Context
name|unitRootContext
decl_stmt|;
comment|// Everything prefixed by ^unitTests.
specifier|private
specifier|final
name|Context
name|unitModuleContext
decl_stmt|;
comment|// Everything prefixed by ^ut.
specifier|private
specifier|final
name|String
name|testCasePropertyName
decl_stmt|;
specifier|private
specifier|final
name|Logger
name|logger
decl_stmt|;
specifier|private
specifier|final
name|File
name|sourceDirectory
decl_stmt|;
specifier|private
specifier|final
name|FileListProvider
name|fileListProvider
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|excludedProvided
decl_stmt|;
comment|// excludedProvidedBy Framework vs excludedConfigured
specifier|private
specifier|final
name|boolean
name|inTest
decl_stmt|;
annotation|@
name|VisibleForTesting
name|UnitTestPropertiesParser
parameter_list|(
name|Context
name|testContext
parameter_list|,
name|String
name|testCasePropertyName
parameter_list|,
name|File
name|sourceDirectory
parameter_list|,
name|Logger
name|logger
parameter_list|,
name|FileListProvider
name|fileListProvider
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|excludedProvided
parameter_list|,
name|boolean
name|inTest
parameter_list|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"{} created with sourceDirectory={}, testCasePropertyName={}, excludedProvide={}"
argument_list|,
literal|"fileListProvider={}, inTest={}"
argument_list|,
name|UnitTestPropertiesParser
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|sourceDirectory
argument_list|,
name|testCasePropertyName
argument_list|,
name|excludedProvided
argument_list|,
operator|(
name|fileListProvider
operator|==
literal|null
condition|?
literal|"null"
else|:
name|fileListProvider
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|)
argument_list|,
name|inTest
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|testContext
argument_list|,
literal|"testContext cannot be null"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|testCasePropertyName
argument_list|,
literal|"testCasePropertyName cannot be null"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|sourceDirectory
argument_list|,
literal|"sourceDirectory cannot be null"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|logger
argument_list|,
literal|"logger must be specified"
argument_list|)
expr_stmt|;
name|this
operator|.
name|unitRootContext
operator|=
operator|new
name|Context
argument_list|(
name|testContext
operator|.
name|getSubProperties
argument_list|(
name|Joiner
operator|.
name|on
argument_list|(
literal|"."
argument_list|)
operator|.
name|join
argument_list|(
name|PROP_PREFIX_ROOT
argument_list|,
literal|""
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|unitModuleContext
operator|=
operator|new
name|Context
argument_list|(
name|testContext
operator|.
name|getSubProperties
argument_list|(
name|Joiner
operator|.
name|on
argument_list|(
literal|"."
argument_list|)
operator|.
name|join
argument_list|(
name|PROP_PREFIX_MODULE
argument_list|,
literal|""
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|sourceDirectory
operator|=
name|sourceDirectory
expr_stmt|;
name|this
operator|.
name|testCasePropertyName
operator|=
name|testCasePropertyName
expr_stmt|;
name|this
operator|.
name|logger
operator|=
name|logger
expr_stmt|;
if|if
condition|(
name|excludedProvided
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|excludedProvided
operator|=
name|excludedProvided
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|excludedProvided
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fileListProvider
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|fileListProvider
operator|=
name|fileListProvider
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|fileListProvider
operator|=
operator|new
name|DefaultFileListProvider
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|inTest
operator|=
name|inTest
expr_stmt|;
block|}
name|UnitTestPropertiesParser
parameter_list|(
name|Context
name|testContext
parameter_list|,
name|String
name|testCasePropertyName
parameter_list|,
name|File
name|sourceDirectory
parameter_list|,
name|Logger
name|logger
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|excludedProvided
parameter_list|)
block|{
name|this
argument_list|(
name|testContext
argument_list|,
name|testCasePropertyName
argument_list|,
name|sourceDirectory
argument_list|,
name|logger
argument_list|,
literal|null
argument_list|,
name|excludedProvided
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|Collection
argument_list|<
name|TestBatch
argument_list|>
name|generateTestBatches
parameter_list|()
block|{
try|try
block|{
return|return
name|parse
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|Collection
argument_list|<
name|TestBatch
argument_list|>
name|parse
parameter_list|()
throws|throws
name|IOException
block|{
name|RootConfig
name|rootConfig
init|=
name|getRootConfig
argument_list|(
name|unitRootContext
argument_list|)
decl_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"RootConfig: "
operator|+
name|rootConfig
argument_list|)
expr_stmt|;
comment|// TODO: Set this up as a tree, instead of a flat list.
name|Map
argument_list|<
name|String
argument_list|,
name|ModuleConfig
argument_list|>
name|moduleConfigs
init|=
name|extractModuleConfigs
argument_list|()
decl_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"ModuleConfigs: {} "
argument_list|,
name|moduleConfigs
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|TestDir
argument_list|>
name|unitTestsDirs
init|=
name|processPropertyDirectories
argument_list|()
decl_stmt|;
name|validateConfigs
argument_list|(
name|rootConfig
argument_list|,
name|moduleConfigs
argument_list|,
name|unitTestsDirs
argument_list|)
expr_stmt|;
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|LinkedHashSet
argument_list|<
name|TestInfo
argument_list|>
argument_list|>
name|allTests
init|=
name|generateFullTestSet
argument_list|(
name|rootConfig
argument_list|,
name|moduleConfigs
argument_list|,
name|unitTestsDirs
argument_list|)
decl_stmt|;
return|return
name|createTestBatches
argument_list|(
name|allTests
argument_list|,
name|rootConfig
argument_list|,
name|moduleConfigs
argument_list|)
return|;
block|}
specifier|private
name|Collection
argument_list|<
name|TestBatch
argument_list|>
name|createTestBatches
parameter_list|(
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|LinkedHashSet
argument_list|<
name|TestInfo
argument_list|>
argument_list|>
name|allTests
parameter_list|,
name|RootConfig
name|rootConfig
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ModuleConfig
argument_list|>
name|moduleConfigs
parameter_list|)
block|{
name|List
argument_list|<
name|TestBatch
argument_list|>
name|testBatches
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|LinkedHashSet
argument_list|<
name|TestInfo
argument_list|>
argument_list|>
name|entry
range|:
name|allTests
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"Creating test batches for module={}, numTests={}"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|currentModule
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|currentPathPrefix
init|=
name|getPathPrefixFromModuleName
argument_list|(
name|currentModule
argument_list|)
decl_stmt|;
name|int
name|batchSize
init|=
name|rootConfig
operator|.
name|batchSize
decl_stmt|;
if|if
condition|(
name|moduleConfigs
operator|.
name|containsKey
argument_list|(
name|currentModule
argument_list|)
condition|)
block|{
name|ModuleConfig
name|moduleConfig
init|=
name|moduleConfigs
operator|.
name|get
argument_list|(
name|currentModule
argument_list|)
decl_stmt|;
name|int
name|batchSizeModule
init|=
name|moduleConfig
operator|.
name|batchSize
decl_stmt|;
if|if
condition|(
name|batchSizeModule
operator|!=
name|DEFAULT_PROP_BATCH_SIZE_NOT_SPECIFIED
condition|)
block|{
name|batchSize
operator|=
name|batchSizeModule
expr_stmt|;
block|}
block|}
if|if
condition|(
name|batchSize
operator|==
name|DEFAULT_PROP_BATCH_SIZE_INCLUDE_ALL
condition|)
block|{
name|batchSize
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
name|logger
operator|.
name|info
argument_list|(
literal|"batchSize determined to be {} for module={}"
argument_list|,
name|batchSize
argument_list|,
name|currentModule
argument_list|)
expr_stmt|;
comment|// TODO Even out the batch sizes (i.e. 20/20/1 should be replaced by 14/14/13)
name|List
argument_list|<
name|String
argument_list|>
name|currentList
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|TestInfo
name|testInfo
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
if|if
condition|(
name|testInfo
operator|.
name|isIsolated
operator|||
name|testInfo
operator|.
name|skipBatching
condition|)
block|{
name|UnitTestBatch
name|unitTestBatch
init|=
operator|new
name|UnitTestBatch
argument_list|(
name|testCasePropertyName
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|testInfo
operator|.
name|testName
argument_list|)
argument_list|,
name|currentPathPrefix
argument_list|,
operator|!
name|testInfo
operator|.
name|isIsolated
argument_list|)
decl_stmt|;
name|testBatches
operator|.
name|add
argument_list|(
name|unitTestBatch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|currentList
operator|.
name|add
argument_list|(
name|testInfo
operator|.
name|testName
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentList
operator|.
name|size
argument_list|()
operator|==
name|batchSize
condition|)
block|{
name|UnitTestBatch
name|unitTestBatch
init|=
operator|new
name|UnitTestBatch
argument_list|(
name|testCasePropertyName
argument_list|,
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|currentList
argument_list|)
argument_list|,
name|currentPathPrefix
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|testBatches
operator|.
name|add
argument_list|(
name|unitTestBatch
argument_list|)
expr_stmt|;
name|currentList
operator|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|currentList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|UnitTestBatch
name|unitTestBatch
init|=
operator|new
name|UnitTestBatch
argument_list|(
name|testCasePropertyName
argument_list|,
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|currentList
argument_list|)
argument_list|,
name|currentPathPrefix
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|testBatches
operator|.
name|add
argument_list|(
name|unitTestBatch
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|testBatches
return|;
block|}
specifier|private
name|RootConfig
name|getRootConfig
parameter_list|(
name|Context
name|context
parameter_list|)
block|{
name|ModuleConfig
name|moduleConfig
init|=
name|getModuleConfig
argument_list|(
name|context
argument_list|,
literal|"irrelevant"
argument_list|,
name|DEFAULT_PROP_BATCH_SIZE
argument_list|)
decl_stmt|;
name|String
name|subDirForPrefix
init|=
name|context
operator|.
name|getString
argument_list|(
name|PROP_SUBDIR_FOR_PREFIX
argument_list|,
name|DEFAULT_PROP_SUBDIR_FOR_PREFIX
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|StringUtils
operator|.
name|isNotBlank
argument_list|(
name|subDirForPrefix
argument_list|)
operator|&&
operator|!
name|subDirForPrefix
operator|.
name|contains
argument_list|(
literal|"/"
argument_list|)
argument_list|)
expr_stmt|;
name|Context
name|modulesContext
init|=
operator|new
name|Context
argument_list|(
name|context
operator|.
name|getSubProperties
argument_list|(
name|Joiner
operator|.
name|on
argument_list|(
literal|"."
argument_list|)
operator|.
name|join
argument_list|(
name|PROP_MODULE_LIST
argument_list|,
literal|""
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|includedModules
init|=
name|getProperty
argument_list|(
name|modulesContext
argument_list|,
name|PROP_INCLUDE
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|excludedModules
init|=
name|getProperty
argument_list|(
name|modulesContext
argument_list|,
name|PROP_EXCLUDE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|includedModules
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|excludedModules
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s and %s are mutually exclusive for property %s. Provided values: included=%s, excluded=%s"
argument_list|,
name|PROP_INCLUDE
argument_list|,
name|PROP_EXCLUDE
argument_list|,
name|PROP_MODULE_LIST
argument_list|,
name|includedModules
argument_list|,
name|excludedModules
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|new
name|RootConfig
argument_list|(
name|includedModules
argument_list|,
name|excludedModules
argument_list|,
name|moduleConfig
operator|.
name|include
argument_list|,
name|moduleConfig
operator|.
name|exclude
argument_list|,
name|moduleConfig
operator|.
name|skipBatching
argument_list|,
name|moduleConfig
operator|.
name|isolate
argument_list|,
name|moduleConfig
operator|.
name|batchSize
argument_list|,
name|subDirForPrefix
argument_list|)
return|;
block|}
specifier|private
name|ModuleConfig
name|getModuleConfig
parameter_list|(
name|Context
name|context
parameter_list|,
name|String
name|moduleName
parameter_list|,
name|int
name|defaultBatchSize
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|excluded
init|=
name|getProperty
argument_list|(
name|context
argument_list|,
name|PROP_EXCLUDE
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|isolated
init|=
name|getProperty
argument_list|(
name|context
argument_list|,
name|PROP_ISOLATE
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|included
init|=
name|getProperty
argument_list|(
name|context
argument_list|,
name|PROP_INCLUDE
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|skipBatching
init|=
name|getProperty
argument_list|(
name|context
argument_list|,
name|PROP_SKIP_BATCHING
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|included
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|excluded
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Included and excluded mutually exclusive."
operator|+
literal|" Included = %s, excluded = %s"
argument_list|,
name|included
operator|.
name|toString
argument_list|()
argument_list|,
name|excluded
operator|.
name|toString
argument_list|()
argument_list|)
operator|+
literal|" for module: "
operator|+
name|moduleName
argument_list|)
throw|;
block|}
name|int
name|batchSize
init|=
name|context
operator|.
name|getInteger
argument_list|(
name|PROP_BATCH_SIZE
argument_list|,
name|defaultBatchSize
argument_list|)
decl_stmt|;
name|String
name|pathPrefix
init|=
name|getPathPrefixFromModuleName
argument_list|(
name|moduleName
argument_list|)
decl_stmt|;
return|return
operator|new
name|ModuleConfig
argument_list|(
name|moduleName
argument_list|,
name|included
argument_list|,
name|excluded
argument_list|,
name|skipBatching
argument_list|,
name|isolated
argument_list|,
name|batchSize
argument_list|,
name|pathPrefix
argument_list|)
return|;
block|}
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|getProperty
parameter_list|(
name|Context
name|context
parameter_list|,
name|String
name|propertyName
parameter_list|)
block|{
return|return
name|Sets
operator|.
name|newHashSet
argument_list|(
name|VALUE_SPLITTER
operator|.
name|split
argument_list|(
name|context
operator|.
name|getString
argument_list|(
name|propertyName
argument_list|,
literal|""
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|String
name|getPathPrefixFromModuleName
parameter_list|(
name|String
name|moduleName
parameter_list|)
block|{
name|String
name|pathPrefix
decl_stmt|;
if|if
condition|(
name|moduleName
operator|.
name|equals
argument_list|(
name|MODULE_NAME_TOP_LEVEL
argument_list|)
condition|)
block|{
name|pathPrefix
operator|=
name|PREFIX_TOP_LEVEL
expr_stmt|;
block|}
else|else
block|{
name|pathPrefix
operator|=
name|moduleName
operator|.
name|replace
argument_list|(
literal|"."
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
return|return
name|pathPrefix
return|;
block|}
specifier|private
name|String
name|getModuleNameFromPathPrefix
parameter_list|(
name|String
name|pathPrefix
parameter_list|)
block|{
if|if
condition|(
name|pathPrefix
operator|.
name|equals
argument_list|(
name|PREFIX_TOP_LEVEL
argument_list|)
condition|)
block|{
return|return
name|MODULE_NAME_TOP_LEVEL
return|;
block|}
else|else
block|{
name|pathPrefix
operator|=
name|stripEndAndStart
argument_list|(
name|pathPrefix
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|pathPrefix
operator|=
name|pathPrefix
operator|.
name|replace
argument_list|(
literal|"/"
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
comment|// Example handling of dirs with a .
comment|// shims/hadoop-2.6
comment|//   -> moduleName=shims.hadoop-.2.6
return|return
name|pathPrefix
return|;
block|}
block|}
specifier|private
name|String
name|stripEndAndStart
parameter_list|(
name|String
name|srcString
parameter_list|,
name|String
name|stripChars
parameter_list|)
block|{
name|srcString
operator|=
name|StringUtils
operator|.
name|stripEnd
argument_list|(
name|srcString
argument_list|,
name|stripChars
argument_list|)
expr_stmt|;
name|srcString
operator|=
name|StringUtils
operator|.
name|stripStart
argument_list|(
name|srcString
argument_list|,
name|stripChars
argument_list|)
expr_stmt|;
return|return
name|srcString
return|;
block|}
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|ModuleConfig
argument_list|>
name|extractModuleConfigs
parameter_list|()
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|modules
init|=
name|extractConfiguredModules
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ModuleConfig
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|moduleName
range|:
name|modules
control|)
block|{
name|Context
name|moduleContext
init|=
operator|new
name|Context
argument_list|(
name|unitModuleContext
operator|.
name|getSubProperties
argument_list|(
name|Joiner
operator|.
name|on
argument_list|(
literal|"."
argument_list|)
operator|.
name|join
argument_list|(
name|moduleName
argument_list|,
literal|""
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|ModuleConfig
name|moduleConfig
init|=
name|getModuleConfig
argument_list|(
name|moduleContext
argument_list|,
name|moduleName
argument_list|,
name|DEFAULT_PROP_BATCH_SIZE_NOT_SPECIFIED
argument_list|)
decl_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"Adding moduleConfig={}"
argument_list|,
name|moduleConfig
argument_list|)
expr_stmt|;
name|result
operator|.
name|put
argument_list|(
name|moduleName
argument_list|,
name|moduleConfig
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|private
name|Collection
argument_list|<
name|String
argument_list|>
name|extractConfiguredModules
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|configuredModules
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|modulesMap
init|=
name|unitRootContext
operator|.
name|getSubProperties
argument_list|(
name|Joiner
operator|.
name|on
argument_list|(
literal|"."
argument_list|)
operator|.
name|join
argument_list|(
name|PROP_ONE_MODULE
argument_list|,
literal|""
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|module
range|:
name|modulesMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// This is an unnecessary check, and forced configuration in the property file. Maybe
comment|// replace with an enforced empty value string.
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|module
operator|.
name|getKey
argument_list|()
operator|.
name|equals
argument_list|(
name|module
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|moduleName
init|=
name|module
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|configuredModules
operator|.
name|add
argument_list|(
name|moduleName
argument_list|)
expr_stmt|;
block|}
return|return
name|configuredModules
return|;
block|}
specifier|private
name|List
argument_list|<
name|TestDir
argument_list|>
name|processPropertyDirectories
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|srcDirString
init|=
name|sourceDirectory
operator|.
name|getCanonicalPath
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|TestDir
argument_list|>
name|unitTestsDirs
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|String
name|propDirectoriies
init|=
name|unitRootContext
operator|.
name|getString
argument_list|(
name|PROP_DIRECTORIES
argument_list|,
name|DEFAULT_PROP_DIRECTORIES
argument_list|)
decl_stmt|;
name|Iterable
argument_list|<
name|String
argument_list|>
name|propDirectoriesIterable
init|=
name|VALUE_SPLITTER
operator|.
name|split
argument_list|(
name|propDirectoriies
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|unitTestDir
range|:
name|propDirectoriesIterable
control|)
block|{
name|File
name|unitTestParent
init|=
operator|new
name|File
argument_list|(
name|sourceDirectory
argument_list|,
name|unitTestDir
argument_list|)
decl_stmt|;
if|if
condition|(
name|unitTestParent
operator|.
name|isDirectory
argument_list|()
operator|||
name|inTest
condition|)
block|{
name|String
name|absUnitTestDir
init|=
name|unitTestParent
operator|.
name|getCanonicalPath
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|absUnitTestDir
operator|.
name|startsWith
argument_list|(
name|srcDirString
argument_list|)
argument_list|,
literal|"Unit test dir: "
operator|+
name|absUnitTestDir
operator|+
literal|" is not under provided src dir: "
operator|+
name|srcDirString
argument_list|)
expr_stmt|;
name|String
name|modulePath
init|=
name|absUnitTestDir
operator|.
name|substring
argument_list|(
name|srcDirString
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|modulePath
operator|=
name|stripEndAndStart
argument_list|(
name|modulePath
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|modulePath
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"Illegal module path: [%s]"
argument_list|,
name|modulePath
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|modulePath
argument_list|)
condition|)
block|{
name|modulePath
operator|=
name|PREFIX_TOP_LEVEL
expr_stmt|;
block|}
name|String
name|moduleName
init|=
name|getModuleNameFromPathPrefix
argument_list|(
name|modulePath
argument_list|)
decl_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"modulePath determined as {} for testdir={}, DerivedModuleName={}"
argument_list|,
name|modulePath
argument_list|,
name|absUnitTestDir
argument_list|,
name|moduleName
argument_list|)
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"Adding unitTests dir [{}],[{}]"
argument_list|,
name|unitTestParent
argument_list|,
name|moduleName
argument_list|)
expr_stmt|;
name|unitTestsDirs
operator|.
name|add
argument_list|(
operator|new
name|TestDir
argument_list|(
name|unitTestParent
argument_list|,
name|moduleName
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"Unit test directory "
operator|+
name|unitTestParent
operator|+
literal|" does not exist, or is a file."
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|unitTestsDirs
return|;
block|}
specifier|private
name|void
name|validateConfigs
parameter_list|(
name|RootConfig
name|rootConfig
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ModuleConfig
argument_list|>
name|moduleConfigs
parameter_list|,
name|List
argument_list|<
name|TestDir
argument_list|>
name|unitTestDir
parameter_list|)
block|{
if|if
condition|(
name|rootConfig
operator|.
name|include
operator|.
name|isEmpty
argument_list|()
operator|&
name|rootConfig
operator|.
name|exclude
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// No conflicts. Module configuration is what will be used.
comment|// We've already verified that includes and excludes are not present at the same time for
comment|// individual modules.
return|return;
block|}
comment|// Validate mainly for includes / excludes working as they should.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ModuleConfig
argument_list|>
name|entry
range|:
name|moduleConfigs
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|rootConfig
operator|.
name|excludedModules
operator|.
name|contains
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
comment|// Don't bother validating.
continue|continue;
block|}
if|if
condition|(
operator|!
name|rootConfig
operator|.
name|includedModules
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|rootConfig
operator|.
name|includedModules
operator|.
name|contains
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
comment|// Include specified, but this module is not in the set.
continue|continue;
block|}
comment|// If global contains includes, individual modules can only contain additional includes.
if|if
condition|(
operator|!
name|rootConfig
operator|.
name|include
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|exclude
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Global config specified includes, while module config for %s specified excludes"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|// If global contains excludes, individual modules can only contain additional excludes.
if|if
condition|(
operator|!
name|rootConfig
operator|.
name|exclude
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|include
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Global config specified excludes, while module config for %s specified includes"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|LinkedHashSet
argument_list|<
name|TestInfo
argument_list|>
argument_list|>
name|generateFullTestSet
parameter_list|(
name|RootConfig
name|rootConfig
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ModuleConfig
argument_list|>
name|moduleConfigs
parameter_list|,
name|List
argument_list|<
name|TestDir
argument_list|>
name|unitTestDirs
parameter_list|)
throws|throws
name|IOException
block|{
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|LinkedHashSet
argument_list|<
name|TestInfo
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|TestDir
name|unitTestDir
range|:
name|unitTestDirs
control|)
block|{
for|for
control|(
name|File
name|classFile
range|:
name|fileListProvider
operator|.
name|listFiles
argument_list|(
name|unitTestDir
operator|.
name|path
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"class"
block|}
argument_list|,
literal|true
argument_list|)
control|)
block|{
name|String
name|className
init|=
name|classFile
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|className
operator|.
name|startsWith
argument_list|(
literal|"Test"
argument_list|)
operator|&&
operator|!
name|className
operator|.
name|contains
argument_list|(
literal|"$"
argument_list|)
condition|)
block|{
name|String
name|testName
init|=
name|className
operator|.
name|replaceAll
argument_list|(
literal|"\\.class$"
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|String
name|pathPrefix
init|=
name|getPathPrefix
argument_list|(
name|classFile
argument_list|,
name|rootConfig
operator|.
name|subDirForPrefix
argument_list|)
decl_stmt|;
name|String
name|moduleName
init|=
name|getModuleNameFromPathPrefix
argument_list|(
name|pathPrefix
argument_list|)
decl_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"In {}, found class {} with pathPrefix={}, moduleName={}"
argument_list|,
name|unitTestDir
operator|.
name|path
argument_list|,
name|className
argument_list|,
name|pathPrefix
argument_list|,
name|moduleName
argument_list|)
expr_stmt|;
name|ModuleConfig
name|moduleConfig
init|=
name|moduleConfigs
operator|.
name|get
argument_list|(
name|moduleName
argument_list|)
decl_stmt|;
if|if
condition|(
name|moduleConfig
operator|==
literal|null
condition|)
block|{
name|moduleConfig
operator|=
name|FAKE_MODULE_CONFIG
expr_stmt|;
block|}
name|TestInfo
name|testInfo
init|=
name|checkAndGetTestInfo
argument_list|(
name|moduleName
argument_list|,
name|pathPrefix
argument_list|,
name|testName
argument_list|,
name|rootConfig
argument_list|,
name|moduleConfig
argument_list|)
decl_stmt|;
if|if
condition|(
name|testInfo
operator|!=
literal|null
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"Adding test: "
operator|+
name|testInfo
argument_list|)
expr_stmt|;
name|addTestToResult
argument_list|(
name|result
argument_list|,
name|testInfo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"In {}, found class {} with pathPrefix={}. Not a test"
argument_list|,
name|unitTestDir
operator|.
name|path
argument_list|,
name|className
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
specifier|private
name|void
name|addTestToResult
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|LinkedHashSet
argument_list|<
name|TestInfo
argument_list|>
argument_list|>
name|result
parameter_list|,
name|TestInfo
name|testInfo
parameter_list|)
block|{
name|LinkedHashSet
argument_list|<
name|TestInfo
argument_list|>
name|moduleSet
init|=
name|result
operator|.
name|get
argument_list|(
name|testInfo
operator|.
name|moduleName
argument_list|)
decl_stmt|;
if|if
condition|(
name|moduleSet
operator|==
literal|null
condition|)
block|{
name|moduleSet
operator|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
expr_stmt|;
name|result
operator|.
name|put
argument_list|(
name|testInfo
operator|.
name|moduleName
argument_list|,
name|moduleSet
argument_list|)
expr_stmt|;
block|}
name|moduleSet
operator|.
name|add
argument_list|(
name|testInfo
argument_list|)
expr_stmt|;
block|}
specifier|private
name|String
name|getPathPrefix
parameter_list|(
name|File
name|file
parameter_list|,
name|String
name|subDirPrefix
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|fname
init|=
name|file
operator|.
name|getCanonicalPath
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|fname
operator|.
name|startsWith
argument_list|(
name|sourceDirectory
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|fname
operator|=
name|fname
operator|.
name|substring
argument_list|(
name|sourceDirectory
operator|.
name|getCanonicalPath
argument_list|()
operator|.
name|length
argument_list|()
argument_list|,
name|fname
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|.
name|contains
argument_list|(
name|subDirPrefix
argument_list|)
condition|)
block|{
name|fname
operator|=
name|fname
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|fname
operator|.
name|indexOf
argument_list|(
name|subDirPrefix
argument_list|)
argument_list|)
expr_stmt|;
name|fname
operator|=
name|StringUtils
operator|.
name|stripStart
argument_list|(
name|fname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|fname
argument_list|)
condition|)
block|{
name|fname
operator|=
name|PREFIX_TOP_LEVEL
expr_stmt|;
block|}
return|return
name|fname
return|;
block|}
else|else
block|{
name|logger
operator|.
name|error
argument_list|(
literal|"Could not find subDirPrefix {} in path: {}"
argument_list|,
name|subDirPrefix
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
name|PREFIX_TOP_LEVEL
return|;
block|}
block|}
specifier|private
name|TestInfo
name|checkAndGetTestInfo
parameter_list|(
name|String
name|moduleName
parameter_list|,
name|String
name|moduleRelDir
parameter_list|,
name|String
name|testName
parameter_list|,
name|RootConfig
name|rootConfig
parameter_list|,
name|ModuleConfig
name|moduleConfig
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|moduleConfig
argument_list|)
expr_stmt|;
name|TestInfo
name|testInfo
decl_stmt|;
name|String
name|rejectReason
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|rootConfig
operator|.
name|excludedModules
operator|.
name|contains
argument_list|(
name|moduleName
argument_list|)
condition|)
block|{
name|rejectReason
operator|=
literal|"root level module exclude"
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|rootConfig
operator|.
name|includedModules
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|rootConfig
operator|.
name|includedModules
operator|.
name|contains
argument_list|(
name|moduleName
argument_list|)
condition|)
block|{
name|rejectReason
operator|=
literal|"root level include, but not for module"
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|rootConfig
operator|.
name|exclude
operator|.
name|contains
argument_list|(
name|testName
argument_list|)
condition|)
block|{
name|rejectReason
operator|=
literal|"root excludes test"
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|moduleConfig
operator|.
name|exclude
operator|.
name|contains
argument_list|(
name|testName
argument_list|)
condition|)
block|{
name|rejectReason
operator|=
literal|"module excludes test"
expr_stmt|;
return|return
literal|null
return|;
block|}
name|boolean
name|containsInclude
init|=
operator|!
name|rootConfig
operator|.
name|include
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|moduleConfig
operator|.
name|include
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
name|containsInclude
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|rootConfig
operator|.
name|include
operator|.
name|contains
argument_list|(
name|testName
argument_list|)
operator|||
name|moduleConfig
operator|.
name|include
operator|.
name|contains
argument_list|(
name|testName
argument_list|)
operator|)
condition|)
block|{
name|rejectReason
operator|=
literal|"test missing from include list"
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
if|if
condition|(
name|excludedProvided
operator|.
name|contains
argument_list|(
name|testName
argument_list|)
condition|)
block|{
comment|// All qfiles handled via this...
name|rejectReason
operator|=
literal|"test present in provided exclude list"
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Add the test.
name|testInfo
operator|=
operator|new
name|TestInfo
argument_list|(
name|moduleName
argument_list|,
name|moduleRelDir
argument_list|,
name|testName
argument_list|,
name|rootConfig
operator|.
name|skipBatching
operator|.
name|contains
argument_list|(
name|testName
argument_list|)
operator|||
name|moduleConfig
operator|.
name|skipBatching
operator|.
name|contains
argument_list|(
name|testName
argument_list|)
argument_list|,
name|rootConfig
operator|.
name|isolate
operator|.
name|contains
argument_list|(
name|testName
argument_list|)
operator|||
name|moduleConfig
operator|.
name|isolate
operator|.
name|contains
argument_list|(
name|testName
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|testInfo
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|rejectReason
operator|!=
literal|null
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"excluding {} due to {}"
argument_list|,
name|testName
argument_list|,
name|rejectReason
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
specifier|final
class|class
name|RootConfig
block|{
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|includedModules
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|excludedModules
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|include
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|exclude
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|skipBatching
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|isolate
decl_stmt|;
specifier|private
specifier|final
name|int
name|batchSize
decl_stmt|;
specifier|private
specifier|final
name|String
name|subDirForPrefix
decl_stmt|;
name|RootConfig
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|includedModules
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|excludedModules
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|include
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|exclude
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|skipBatching
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|isolate
parameter_list|,
name|int
name|batchSize
parameter_list|,
name|String
name|subDirForPrefix
parameter_list|)
block|{
name|this
operator|.
name|includedModules
operator|=
name|includedModules
expr_stmt|;
name|this
operator|.
name|excludedModules
operator|=
name|excludedModules
expr_stmt|;
name|this
operator|.
name|include
operator|=
name|include
expr_stmt|;
name|this
operator|.
name|exclude
operator|=
name|exclude
expr_stmt|;
name|this
operator|.
name|skipBatching
operator|=
name|skipBatching
expr_stmt|;
name|this
operator|.
name|isolate
operator|=
name|isolate
expr_stmt|;
name|this
operator|.
name|batchSize
operator|=
name|batchSize
expr_stmt|;
name|this
operator|.
name|subDirForPrefix
operator|=
name|subDirForPrefix
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"RootConfig{"
operator|+
literal|"includedModules="
operator|+
name|includedModules
operator|+
literal|", excludedModules="
operator|+
name|excludedModules
operator|+
literal|", include="
operator|+
name|include
operator|+
literal|", exclude="
operator|+
name|exclude
operator|+
literal|", skipBatching="
operator|+
name|skipBatching
operator|+
literal|", isolate="
operator|+
name|isolate
operator|+
literal|", batchSize="
operator|+
name|batchSize
operator|+
literal|", subDirForPrefix='"
operator|+
name|subDirForPrefix
operator|+
literal|'\''
operator|+
literal|'}'
return|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|ModuleConfig
name|FAKE_MODULE_CONFIG
init|=
operator|new
name|ModuleConfig
argument_list|(
literal|"_FAKE_"
argument_list|,
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|,
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|,
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|,
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|,
name|DEFAULT_PROP_BATCH_SIZE_NOT_SPECIFIED
argument_list|,
literal|"_fake_"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
class|class
name|ModuleConfig
block|{
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|include
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|exclude
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|skipBatching
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|isolate
decl_stmt|;
specifier|private
specifier|final
name|String
name|pathPrefix
decl_stmt|;
specifier|private
specifier|final
name|int
name|batchSize
decl_stmt|;
name|ModuleConfig
parameter_list|(
name|String
name|name
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|include
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|exclude
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|skipBatching
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|isolate
parameter_list|,
name|int
name|batchSize
parameter_list|,
name|String
name|pathPrefix
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|include
operator|=
name|include
expr_stmt|;
name|this
operator|.
name|exclude
operator|=
name|exclude
expr_stmt|;
name|this
operator|.
name|skipBatching
operator|=
name|skipBatching
expr_stmt|;
name|this
operator|.
name|isolate
operator|=
name|isolate
expr_stmt|;
name|this
operator|.
name|batchSize
operator|=
name|batchSize
expr_stmt|;
name|this
operator|.
name|pathPrefix
operator|=
name|pathPrefix
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ModuleConfig{"
operator|+
literal|"name='"
operator|+
name|name
operator|+
literal|'\''
operator|+
literal|", include="
operator|+
name|include
operator|+
literal|", exclude="
operator|+
name|exclude
operator|+
literal|", skipBatching="
operator|+
name|skipBatching
operator|+
literal|", isolate="
operator|+
name|isolate
operator|+
literal|", pathPrefix='"
operator|+
name|pathPrefix
operator|+
literal|'\''
operator|+
literal|", batchSize="
operator|+
name|batchSize
operator|+
literal|'}'
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|TestDir
block|{
specifier|final
name|File
name|path
decl_stmt|;
specifier|final
name|String
name|module
decl_stmt|;
name|TestDir
parameter_list|(
name|File
name|path
parameter_list|,
name|String
name|module
parameter_list|)
block|{
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|module
operator|=
name|module
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"TestDir{"
operator|+
literal|"path="
operator|+
name|path
operator|+
literal|", module='"
operator|+
name|module
operator|+
literal|'\''
operator|+
literal|'}'
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|TestInfo
block|{
specifier|final
name|String
name|moduleName
decl_stmt|;
specifier|final
name|String
name|moduleRelativeDir
decl_stmt|;
specifier|final
name|String
name|testName
decl_stmt|;
specifier|final
name|boolean
name|skipBatching
decl_stmt|;
specifier|final
name|boolean
name|isIsolated
decl_stmt|;
name|TestInfo
parameter_list|(
name|String
name|moduleName
parameter_list|,
name|String
name|moduleRelativeDir
parameter_list|,
name|String
name|testName
parameter_list|,
name|boolean
name|skipBatching
parameter_list|,
name|boolean
name|isIsolated
parameter_list|)
block|{
name|this
operator|.
name|moduleName
operator|=
name|moduleName
expr_stmt|;
name|this
operator|.
name|moduleRelativeDir
operator|=
name|moduleRelativeDir
expr_stmt|;
name|this
operator|.
name|testName
operator|=
name|testName
expr_stmt|;
name|this
operator|.
name|skipBatching
operator|=
name|skipBatching
expr_stmt|;
name|this
operator|.
name|isIsolated
operator|=
name|isIsolated
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"TestInfo{"
operator|+
literal|"moduleName='"
operator|+
name|moduleName
operator|+
literal|'\''
operator|+
literal|", moduleRelativeDir='"
operator|+
name|moduleRelativeDir
operator|+
literal|'\''
operator|+
literal|", testName='"
operator|+
name|testName
operator|+
literal|'\''
operator|+
literal|", skipBatching="
operator|+
name|skipBatching
operator|+
literal|", isIsolated="
operator|+
name|isIsolated
operator|+
literal|'}'
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|TestInfo
name|testInfo
init|=
operator|(
name|TestInfo
operator|)
name|o
decl_stmt|;
return|return
name|skipBatching
operator|==
name|testInfo
operator|.
name|skipBatching
operator|&&
name|isIsolated
operator|==
name|testInfo
operator|.
name|isIsolated
operator|&&
name|moduleName
operator|.
name|equals
argument_list|(
name|testInfo
operator|.
name|moduleName
argument_list|)
operator|&&
name|moduleRelativeDir
operator|.
name|equals
argument_list|(
name|testInfo
operator|.
name|moduleRelativeDir
argument_list|)
operator|&&
name|testName
operator|.
name|equals
argument_list|(
name|testInfo
operator|.
name|testName
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|result
init|=
name|moduleName
operator|.
name|hashCode
argument_list|()
decl_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
name|moduleRelativeDir
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
name|testName
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
operator|(
name|skipBatching
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
operator|(
name|isIsolated
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
specifier|private
specifier|static
specifier|final
class|class
name|DefaultFileListProvider
implements|implements
name|FileListProvider
block|{
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|File
argument_list|>
name|listFiles
parameter_list|(
name|File
name|directory
parameter_list|,
name|String
index|[]
name|extensions
parameter_list|,
name|boolean
name|recursive
parameter_list|)
block|{
return|return
name|FileUtils
operator|.
name|listFiles
argument_list|(
name|directory
argument_list|,
name|extensions
argument_list|,
name|recursive
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

