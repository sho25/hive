begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|hcatalog
operator|.
name|data
operator|.
name|schema
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|builder
operator|.
name|ToStringBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|PrimitiveObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|PrimitiveTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|hcatalog
operator|.
name|common
operator|.
name|HCatException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|hcatalog
operator|.
name|common
operator|.
name|HCatUtil
import|;
end_import

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|HCatFieldSchema
implements|implements
name|Serializable
block|{
comment|/*the implementation of HCatFieldSchema is a bit messy since with the addition of parametrized  types (e.g. char(7)) we need to represent something richer than an enum but for backwards  compatibility (and effort required to do full refactoring) this class has both 'type' and 'typeInfo'; similarly for mapKeyType/mapKeyTypeInfo */
specifier|public
enum|enum
name|Type
block|{
comment|/*this captures mapping of Hive type names to HCat type names; in the long run     * we should just use Hive types directly but that is a larger refactoring effort     * For HCat->Pig mapping see PigHCatUtil.getPigType(Type)     * For Pig->HCat mapping see HCatBaseStorer#validateSchema(...)*/
name|BOOLEAN
parameter_list|(
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
operator|.
name|BOOLEAN
parameter_list|)
operator|,
constructor|TINYINT(PrimitiveObjectInspector.PrimitiveCategory.BYTE
block|)
enum|,
name|SMALLINT
parameter_list|(
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
operator|.
name|SHORT
parameter_list|)
operator|,
constructor|INT(PrimitiveObjectInspector.PrimitiveCategory.INT
block|)
operator|,
name|BIGINT
argument_list|(
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
operator|.
name|LONG
argument_list|)
operator|,
name|FLOAT
argument_list|(
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
operator|.
name|FLOAT
argument_list|)
operator|,
name|DOUBLE
argument_list|(
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
operator|.
name|DOUBLE
argument_list|)
operator|,
name|DECIMAL
argument_list|(
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
operator|.
name|DECIMAL
argument_list|)
operator|,
name|STRING
argument_list|(
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
operator|.
name|STRING
argument_list|)
operator|,
name|CHAR
argument_list|(
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
operator|.
name|CHAR
argument_list|)
operator|,
name|VARCHAR
argument_list|(
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
operator|.
name|VARCHAR
argument_list|)
operator|,
name|BINARY
argument_list|(
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
operator|.
name|BINARY
argument_list|)
operator|,
name|DATE
argument_list|(
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
operator|.
name|DATE
argument_list|)
operator|,
name|TIMESTAMP
argument_list|(
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
operator|.
name|TIMESTAMP
argument_list|)
operator|,
name|ARRAY
argument_list|(
name|ObjectInspector
operator|.
name|Category
operator|.
name|LIST
argument_list|)
operator|,
name|MAP
argument_list|(
name|ObjectInspector
operator|.
name|Category
operator|.
name|MAP
argument_list|)
operator|,
name|STRUCT
argument_list|(
name|ObjectInspector
operator|.
name|Category
operator|.
name|STRUCT
argument_list|)
expr_stmt|;
end_class

begin_decl_stmt
specifier|private
specifier|final
name|ObjectInspector
operator|.
name|Category
name|category
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|private
specifier|final
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
name|primitiveCategory
decl_stmt|;
end_decl_stmt

begin_constructor
specifier|private
name|Type
parameter_list|(
name|ObjectInspector
operator|.
name|Category
name|cat
parameter_list|)
block|{
name|category
operator|=
name|cat
expr_stmt|;
name|primitiveCategory
operator|=
literal|null
expr_stmt|;
assert|assert
name|category
operator|!=
name|ObjectInspector
operator|.
name|Category
operator|.
name|PRIMITIVE
operator|:
literal|"This c'tor should be used for complex category types"
assert|;
block|}
end_constructor

begin_constructor
specifier|private
name|Type
parameter_list|(
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
name|primCat
parameter_list|)
block|{
name|category
operator|=
name|ObjectInspector
operator|.
name|Category
operator|.
name|PRIMITIVE
expr_stmt|;
name|primitiveCategory
operator|=
name|primCat
expr_stmt|;
block|}
end_constructor

begin_function
specifier|public
name|ObjectInspector
operator|.
name|Category
name|getCategory
parameter_list|()
block|{
return|return
name|category
return|;
block|}
end_function

begin_comment
comment|/**      * May return {@code null}      */
end_comment

begin_function
specifier|public
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
name|getPrimitiveCategory
parameter_list|()
block|{
return|return
name|primitiveCategory
return|;
block|}
end_function

begin_function
specifier|public
specifier|static
name|Type
name|getPrimitiveHType
parameter_list|(
name|PrimitiveTypeInfo
name|basePrimitiveTypeInfo
parameter_list|)
block|{
for|for
control|(
name|Type
name|t
range|:
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|t
operator|.
name|getPrimitiveCategory
argument_list|()
operator|==
name|basePrimitiveTypeInfo
operator|.
name|getPrimitiveCategory
argument_list|()
condition|)
block|{
return|return
name|t
return|;
block|}
block|}
throw|throw
operator|new
name|TypeNotPresentException
argument_list|(
name|basePrimitiveTypeInfo
operator|.
name|getTypeName
argument_list|()
argument_list|,
literal|null
argument_list|)
throw|;
block|}
end_function

begin_comment
comment|//aid in testing
end_comment

begin_function
specifier|public
specifier|static
name|int
name|numPrimitiveTypes
parameter_list|()
block|{
name|int
name|numPrimitives
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Type
name|t
range|:
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|t
operator|.
name|category
operator|==
name|ObjectInspector
operator|.
name|Category
operator|.
name|PRIMITIVE
condition|)
block|{
name|numPrimitives
operator|++
expr_stmt|;
block|}
block|}
return|return
name|numPrimitives
return|;
block|}
end_function

begin_enum
unit|}    public
enum|enum
name|Category
block|{
name|PRIMITIVE
block|,
name|ARRAY
block|,
name|MAP
block|,
name|STRUCT
block|;
specifier|public
specifier|static
name|Category
name|fromType
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
if|if
condition|(
name|Type
operator|.
name|ARRAY
operator|==
name|type
condition|)
block|{
return|return
name|ARRAY
return|;
block|}
elseif|else
if|if
condition|(
name|Type
operator|.
name|STRUCT
operator|==
name|type
condition|)
block|{
return|return
name|STRUCT
return|;
block|}
elseif|else
if|if
condition|(
name|Type
operator|.
name|MAP
operator|==
name|type
condition|)
block|{
return|return
name|MAP
return|;
block|}
else|else
block|{
return|return
name|PRIMITIVE
return|;
block|}
block|}
block|}
end_enum

begin_function
specifier|public
name|boolean
name|isComplex
parameter_list|()
block|{
return|return
name|category
operator|!=
name|Category
operator|.
name|PRIMITIVE
return|;
block|}
end_function

begin_comment
comment|/**    *    */
end_comment

begin_decl_stmt
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|String
name|fieldName
init|=
literal|null
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|String
name|comment
init|=
literal|null
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**    * @deprecated as of 0.13, slated for removal with 0.15    * use {@link #typeInfo} instead    */
end_comment

begin_decl_stmt
name|Type
name|type
init|=
literal|null
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Category
name|category
init|=
literal|null
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Populated if column is struct, array or map types.
end_comment

begin_comment
comment|// If struct type, contains schema of the struct.
end_comment

begin_comment
comment|// If array type, contains schema of one of the elements.
end_comment

begin_comment
comment|// If map type, contains schema of the value element.
end_comment

begin_decl_stmt
name|HCatSchema
name|subSchema
init|=
literal|null
decl_stmt|;
end_decl_stmt

begin_comment
comment|// populated if column is Map type
end_comment

begin_decl_stmt
annotation|@
name|Deprecated
comment|// @deprecated as of 0.13, slated for removal with 0.15
name|Type
name|mapKeyType
init|=
literal|null
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|private
name|String
name|typeString
init|=
literal|null
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**    * This is needed for parametrized types such as decimal(8,9), char(7), varchar(6)    */
end_comment

begin_decl_stmt
specifier|private
name|PrimitiveTypeInfo
name|typeInfo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**    * represents key type for a Map; currently Hive only supports primitive keys    */
end_comment

begin_decl_stmt
specifier|private
name|PrimitiveTypeInfo
name|mapKeyTypeInfo
decl_stmt|;
end_decl_stmt

begin_constructor
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|private
name|HCatFieldSchema
parameter_list|()
block|{
comment|// preventing empty ctor from being callable
block|}
end_constructor

begin_comment
comment|/**    * Returns type of the field    * @return type of the field    * @deprecated as of 0.13, slated for removal with 0.15    * use {@link #getTypeInfo()} instead    */
end_comment

begin_function
specifier|public
name|Type
name|getType
parameter_list|()
block|{
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/**    * Returns category of the field    * @return category of the field    */
end_comment

begin_function
specifier|public
name|Category
name|getCategory
parameter_list|()
block|{
return|return
name|category
return|;
block|}
end_function

begin_comment
comment|/**    * Returns name of the field    * @return name of the field    */
end_comment

begin_function
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|fieldName
return|;
block|}
end_function

begin_function
specifier|public
name|String
name|getComment
parameter_list|()
block|{
return|return
name|comment
return|;
block|}
end_function

begin_comment
comment|/**    * May return {@code null}    */
end_comment

begin_function
specifier|public
name|PrimitiveTypeInfo
name|getTypeInfo
parameter_list|()
block|{
return|return
name|typeInfo
return|;
block|}
end_function

begin_comment
comment|/**    * Constructor constructing a primitive datatype HCatFieldSchema    * @param fieldName Name of the primitive field    * @param type Type of the primitive field    * @throws HCatException if call made on non-primitive types    * @deprecated as of 0.13, slated for removal with 0.15    * use {@link #HCatFieldSchema(String, org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo, String)}    */
end_comment

begin_constructor
specifier|public
name|HCatFieldSchema
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Type
name|type
parameter_list|,
name|String
name|comment
parameter_list|)
throws|throws
name|HCatException
block|{
name|assertTypeInCategory
argument_list|(
name|type
argument_list|,
name|Category
operator|.
name|PRIMITIVE
argument_list|,
name|fieldName
argument_list|)
expr_stmt|;
name|this
operator|.
name|fieldName
operator|=
name|fieldName
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|this
operator|.
name|category
operator|=
name|Category
operator|.
name|PRIMITIVE
expr_stmt|;
name|this
operator|.
name|comment
operator|=
name|comment
expr_stmt|;
block|}
end_constructor

begin_constructor
specifier|public
name|HCatFieldSchema
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|PrimitiveTypeInfo
name|typeInfo
parameter_list|,
name|String
name|comment
parameter_list|)
throws|throws
name|HCatException
block|{
name|this
operator|.
name|fieldName
operator|=
name|fieldName
expr_stmt|;
name|this
operator|.
name|category
operator|=
name|Category
operator|.
name|PRIMITIVE
expr_stmt|;
name|this
operator|.
name|typeInfo
operator|=
name|typeInfo
expr_stmt|;
if|if
condition|(
name|typeInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"typeInfo cannot be null; fieldName="
operator|+
name|fieldName
argument_list|)
throw|;
block|}
name|type
operator|=
name|Type
operator|.
name|getPrimitiveHType
argument_list|(
name|typeInfo
argument_list|)
expr_stmt|;
name|this
operator|.
name|comment
operator|=
name|comment
expr_stmt|;
block|}
end_constructor

begin_comment
comment|/**    * Constructor for constructing a ARRAY type or STRUCT type HCatFieldSchema, passing type and subschema    * @param fieldName Name of the array or struct field    * @param type Type of the field - either Type.ARRAY or Type.STRUCT    * @param subSchema - subschema of the struct, or element schema of the elements in the array    * @throws HCatException if call made on Primitive or Map types    */
end_comment

begin_constructor
specifier|public
name|HCatFieldSchema
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Type
name|type
parameter_list|,
name|HCatSchema
name|subSchema
parameter_list|,
name|String
name|comment
parameter_list|)
throws|throws
name|HCatException
block|{
name|assertTypeNotInCategory
argument_list|(
name|type
argument_list|,
name|Category
operator|.
name|PRIMITIVE
argument_list|)
expr_stmt|;
name|assertTypeNotInCategory
argument_list|(
name|type
argument_list|,
name|Category
operator|.
name|MAP
argument_list|)
expr_stmt|;
name|this
operator|.
name|fieldName
operator|=
name|fieldName
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|this
operator|.
name|category
operator|=
name|Category
operator|.
name|fromType
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|this
operator|.
name|subSchema
operator|=
name|subSchema
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|Type
operator|.
name|ARRAY
condition|)
block|{
name|this
operator|.
name|subSchema
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|setName
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|comment
operator|=
name|comment
expr_stmt|;
block|}
end_constructor

begin_function
specifier|private
name|void
name|setName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|fieldName
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Constructor for constructing a MAP type HCatFieldSchema, passing type of key and value    * @param fieldName Name of the array or struct field    * @param type Type of the field - must be Type.MAP    * @param mapKeyType - key type of the Map    * @param mapValueSchema - subschema of the value of the Map    * @throws HCatException if call made on non-Map types    * @deprecated as of 0.13, slated for removal with 0.15    * use {@link #createMapTypeFieldSchema(String, org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo, HCatSchema, String)}    */
end_comment

begin_constructor
specifier|public
name|HCatFieldSchema
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Type
name|type
parameter_list|,
name|Type
name|mapKeyType
parameter_list|,
name|HCatSchema
name|mapValueSchema
parameter_list|,
name|String
name|comment
parameter_list|)
throws|throws
name|HCatException
block|{
name|assertTypeInCategory
argument_list|(
name|type
argument_list|,
name|Category
operator|.
name|MAP
argument_list|,
name|fieldName
argument_list|)
expr_stmt|;
comment|//Hive only supports primitive map keys:
comment|//https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Types#LanguageManualTypes-ComplexTypes
name|assertTypeInCategory
argument_list|(
name|mapKeyType
argument_list|,
name|Category
operator|.
name|PRIMITIVE
argument_list|,
name|fieldName
argument_list|)
expr_stmt|;
name|this
operator|.
name|fieldName
operator|=
name|fieldName
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|Type
operator|.
name|MAP
expr_stmt|;
name|this
operator|.
name|category
operator|=
name|Category
operator|.
name|MAP
expr_stmt|;
name|this
operator|.
name|mapKeyType
operator|=
name|mapKeyType
expr_stmt|;
name|this
operator|.
name|subSchema
operator|=
name|mapValueSchema
expr_stmt|;
name|this
operator|.
name|subSchema
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|setName
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|comment
operator|=
name|comment
expr_stmt|;
block|}
end_constructor

begin_function
specifier|public
specifier|static
name|HCatFieldSchema
name|createMapTypeFieldSchema
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|PrimitiveTypeInfo
name|mapKeyType
parameter_list|,
name|HCatSchema
name|mapValueSchema
parameter_list|,
name|String
name|comment
parameter_list|)
throws|throws
name|HCatException
block|{
name|HCatFieldSchema
name|mapSchema
init|=
operator|new
name|HCatFieldSchema
argument_list|(
name|fieldName
argument_list|,
name|Type
operator|.
name|MAP
argument_list|,
name|Type
operator|.
name|getPrimitiveHType
argument_list|(
name|mapKeyType
argument_list|)
argument_list|,
name|mapValueSchema
argument_list|,
name|comment
argument_list|)
decl_stmt|;
name|mapSchema
operator|.
name|mapKeyTypeInfo
operator|=
name|mapKeyType
expr_stmt|;
return|return
name|mapSchema
return|;
block|}
end_function

begin_function
specifier|public
name|HCatSchema
name|getStructSubSchema
parameter_list|()
throws|throws
name|HCatException
block|{
name|assertTypeInCategory
argument_list|(
name|this
operator|.
name|type
argument_list|,
name|Category
operator|.
name|STRUCT
argument_list|,
name|this
operator|.
name|fieldName
argument_list|)
expr_stmt|;
return|return
name|subSchema
return|;
block|}
end_function

begin_function
specifier|public
name|HCatSchema
name|getArrayElementSchema
parameter_list|()
throws|throws
name|HCatException
block|{
name|assertTypeInCategory
argument_list|(
name|this
operator|.
name|type
argument_list|,
name|Category
operator|.
name|ARRAY
argument_list|,
name|this
operator|.
name|fieldName
argument_list|)
expr_stmt|;
return|return
name|subSchema
return|;
block|}
end_function

begin_comment
comment|/**    * @deprecated as of 0.13, slated for removal with 0.15    * use {@link #getMapKeyTypeInfo()} instead    */
end_comment

begin_function
specifier|public
name|Type
name|getMapKeyType
parameter_list|()
throws|throws
name|HCatException
block|{
name|assertTypeInCategory
argument_list|(
name|this
operator|.
name|type
argument_list|,
name|Category
operator|.
name|MAP
argument_list|,
name|this
operator|.
name|fieldName
argument_list|)
expr_stmt|;
return|return
name|mapKeyType
return|;
block|}
end_function

begin_function
specifier|public
name|PrimitiveTypeInfo
name|getMapKeyTypeInfo
parameter_list|()
throws|throws
name|HCatException
block|{
name|assertTypeInCategory
argument_list|(
name|this
operator|.
name|type
argument_list|,
name|Category
operator|.
name|MAP
argument_list|,
name|this
operator|.
name|fieldName
argument_list|)
expr_stmt|;
return|return
name|mapKeyTypeInfo
return|;
block|}
end_function

begin_function
specifier|public
name|HCatSchema
name|getMapValueSchema
parameter_list|()
throws|throws
name|HCatException
block|{
name|assertTypeInCategory
argument_list|(
name|this
operator|.
name|type
argument_list|,
name|Category
operator|.
name|MAP
argument_list|,
name|this
operator|.
name|fieldName
argument_list|)
expr_stmt|;
return|return
name|subSchema
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|void
name|assertTypeInCategory
parameter_list|(
name|Type
name|type
parameter_list|,
name|Category
name|category
parameter_list|,
name|String
name|fieldName
parameter_list|)
throws|throws
name|HCatException
block|{
name|Category
name|typeCategory
init|=
name|Category
operator|.
name|fromType
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|typeCategory
operator|!=
name|category
condition|)
block|{
throw|throw
operator|new
name|HCatException
argument_list|(
literal|"Type category mismatch. Expected "
operator|+
name|category
operator|+
literal|" but type "
operator|+
name|type
operator|+
literal|" in category "
operator|+
name|typeCategory
operator|+
literal|" (field "
operator|+
name|fieldName
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
specifier|private
specifier|static
name|void
name|assertTypeNotInCategory
parameter_list|(
name|Type
name|type
parameter_list|,
name|Category
name|category
parameter_list|)
throws|throws
name|HCatException
block|{
name|Category
name|typeCategory
init|=
name|Category
operator|.
name|fromType
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|typeCategory
operator|==
name|category
condition|)
block|{
throw|throw
operator|new
name|HCatException
argument_list|(
literal|"Type category mismatch. Expected type "
operator|+
name|type
operator|+
literal|" not in category "
operator|+
name|category
operator|+
literal|" but was so."
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
operator|new
name|ToStringBuilder
argument_list|(
name|this
argument_list|)
operator|.
name|append
argument_list|(
literal|"fieldName"
argument_list|,
name|fieldName
argument_list|)
operator|.
name|append
argument_list|(
literal|"comment"
argument_list|,
name|comment
argument_list|)
operator|.
name|append
argument_list|(
literal|"type"
argument_list|,
name|getTypeString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"category"
argument_list|,
name|category
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
end_function

begin_function
specifier|public
name|String
name|getTypeString
parameter_list|()
block|{
if|if
condition|(
name|typeString
operator|!=
literal|null
condition|)
block|{
return|return
name|typeString
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isComplex
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|typeInfo
operator|==
literal|null
condition|?
name|type
else|:
name|typeInfo
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Category
operator|.
name|STRUCT
operator|==
name|category
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"struct<"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|subSchema
operator|.
name|getSchemaAsTypeString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Category
operator|.
name|ARRAY
operator|==
name|category
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"array<"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|subSchema
operator|.
name|getSchemaAsTypeString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Category
operator|.
name|MAP
operator|==
name|category
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"map<"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|mapKeyTypeInfo
operator|==
literal|null
condition|?
name|mapKeyType
else|:
name|mapKeyTypeInfo
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|subSchema
operator|.
name|getSchemaAsTypeString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|typeString
operator|=
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|HCatFieldSchema
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|HCatFieldSchema
name|other
init|=
operator|(
name|HCatFieldSchema
operator|)
name|obj
decl_stmt|;
if|if
condition|(
name|category
operator|!=
name|other
operator|.
name|category
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fieldName
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|other
operator|.
name|fieldName
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|fieldName
operator|.
name|equals
argument_list|(
name|other
operator|.
name|fieldName
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|this
operator|.
name|getTypeString
argument_list|()
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|other
operator|.
name|getTypeString
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|this
operator|.
name|getTypeString
argument_list|()
operator|.
name|equals
argument_list|(
name|other
operator|.
name|getTypeString
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|//result could be cached if this object were to be made immutable...
name|int
name|result
init|=
literal|17
decl_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
operator|(
name|category
operator|==
literal|null
condition|?
literal|0
else|:
name|category
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
operator|(
name|fieldName
operator|==
literal|null
condition|?
literal|0
else|:
name|fieldName
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
operator|(
name|getTypeString
argument_list|()
operator|==
literal|null
condition|?
literal|0
else|:
name|getTypeString
argument_list|()
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

unit|}
end_unit

