begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|beeline
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringBufferInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|DriverManager
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|exception
operator|.
name|ExceptionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|jdbc
operator|.
name|Utils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|jdbc
operator|.
name|miniHS2
operator|.
name|MiniHS2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|jdbc
operator|.
name|miniHS2
operator|.
name|MiniHS2
operator|.
name|MiniClusterType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|AfterClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_comment
comment|/**  * TestBeeLineWithArgs - executes tests of the command-line arguments to BeeLine  *  */
end_comment

begin_class
specifier|public
class|class
name|TestBeeLineWithArgs
block|{
specifier|private
enum|enum
name|OutStream
block|{
name|ERR
block|,
name|OUT
block|}
comment|// Default location of HiveServer2
specifier|private
specifier|static
specifier|final
name|String
name|tableName
init|=
literal|"TestBeelineTable1"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|tableComment
init|=
literal|"Test table comment"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|escapeCRLFTableName
init|=
literal|"TestBeelineEscapeCRLFTable"
decl_stmt|;
specifier|private
specifier|static
name|MiniHS2
name|miniHS2
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|userName
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"user.name"
argument_list|)
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getBaseArgs
parameter_list|(
name|String
name|jdbcUrl
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"-d"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
name|BeeLine
operator|.
name|BEELINE_DEFAULT_JDBC_DRIVER
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"-u"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
name|jdbcUrl
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"-n"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
name|userName
argument_list|)
expr_stmt|;
return|return
name|argList
return|;
block|}
comment|/**    * Start up a local Hive Server 2 for these tests    */
annotation|@
name|BeforeClass
specifier|public
specifier|static
name|void
name|preTests
parameter_list|()
throws|throws
name|Exception
block|{
name|HiveConf
name|hiveConf
init|=
operator|new
name|HiveConf
argument_list|()
decl_stmt|;
name|hiveConf
operator|.
name|setVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_LOCK_MANAGER
argument_list|,
literal|"org.apache.hadoop.hive.ql.lockmgr.EmbeddedLockManager"
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTIMIZEMETADATAQUERIES
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|set
argument_list|(
name|ConfVars
operator|.
name|HIVE_SERVER2_LOGGING_OPERATION_LEVEL
operator|.
name|varname
argument_list|,
literal|"verbose"
argument_list|)
expr_stmt|;
name|miniHS2
operator|=
operator|new
name|MiniHS2
argument_list|(
name|hiveConf
argument_list|,
name|MiniClusterType
operator|.
name|TEZ
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|confOverlay
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|miniHS2
operator|.
name|start
argument_list|(
name|confOverlay
argument_list|)
expr_stmt|;
name|createTable
argument_list|()
expr_stmt|;
block|}
comment|/**    * Create table for use by tests    * @throws ClassNotFoundException    * @throws SQLException    */
specifier|private
specifier|static
name|void
name|createTable
parameter_list|()
throws|throws
name|ClassNotFoundException
throws|,
name|SQLException
block|{
name|Class
operator|.
name|forName
argument_list|(
name|BeeLine
operator|.
name|BEELINE_DEFAULT_JDBC_DRIVER
argument_list|)
expr_stmt|;
name|Connection
name|con
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|,
name|userName
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Connection is null"
argument_list|,
name|con
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Connection should not be closed"
argument_list|,
name|con
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
name|Statement
name|stmt
init|=
name|con
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Statement is null"
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|execute
argument_list|(
literal|"set hive.support.concurrency = false"
argument_list|)
expr_stmt|;
name|HiveConf
name|conf
init|=
operator|new
name|HiveConf
argument_list|()
decl_stmt|;
name|String
name|dataFileDir
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"test.data.files"
argument_list|)
operator|.
name|replace
argument_list|(
literal|'\\'
argument_list|,
literal|'/'
argument_list|)
operator|.
name|replace
argument_list|(
literal|"c:"
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|Path
name|dataFilePath
init|=
operator|new
name|Path
argument_list|(
name|dataFileDir
argument_list|,
literal|"kv1.txt"
argument_list|)
decl_stmt|;
comment|// drop table. ignore error.
try|try
block|{
name|stmt
operator|.
name|execute
argument_list|(
literal|"drop table "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|fail
argument_list|(
name|ex
operator|.
name|toString
argument_list|()
operator|+
literal|" "
operator|+
name|ExceptionUtils
operator|.
name|getStackTrace
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// create table
name|stmt
operator|.
name|execute
argument_list|(
literal|"create table "
operator|+
name|tableName
operator|+
literal|" (under_col int comment 'the under column', value string) comment '"
operator|+
name|tableComment
operator|+
literal|"'"
argument_list|)
expr_stmt|;
comment|// load data
name|stmt
operator|.
name|execute
argument_list|(
literal|"load data local inpath '"
operator|+
name|dataFilePath
operator|.
name|toString
argument_list|()
operator|+
literal|"' into table "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
comment|/**    * Shut down a local Hive Server 2 for these tests    */
annotation|@
name|AfterClass
specifier|public
specifier|static
name|void
name|postTests
parameter_list|()
block|{
if|if
condition|(
name|miniHS2
operator|.
name|isStarted
argument_list|()
condition|)
block|{
name|miniHS2
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Execute a script with "beeline -f or -i"    * @param argList List of arguments for beeline    * @param inputStream input stream if any    * @param streamType if output from STDERR or STDOUT needs to be returned    * @return The stderr and stdout from running the script    * @throws Throwable    */
specifier|private
specifier|static
name|String
name|testCommandLineScript
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|argList
parameter_list|,
name|InputStream
name|inputStream
parameter_list|,
name|OutStream
name|streamType
parameter_list|)
throws|throws
name|Throwable
block|{
name|BeeLine
name|beeLine
init|=
operator|new
name|BeeLine
argument_list|()
decl_stmt|;
name|ByteArrayOutputStream
name|os
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|PrintStream
name|beelineOutputStream
init|=
operator|new
name|PrintStream
argument_list|(
name|os
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|streamType
condition|)
block|{
case|case
name|OUT
case|:
name|beeLine
operator|.
name|setOutputStream
argument_list|(
name|beelineOutputStream
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERR
case|:
name|beeLine
operator|.
name|setErrorStream
argument_list|(
name|beelineOutputStream
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected outstream type "
operator|+
name|streamType
argument_list|)
throw|;
block|}
name|String
index|[]
name|args
init|=
name|argList
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|argList
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
name|beeLine
operator|.
name|begin
argument_list|(
name|args
argument_list|,
name|inputStream
argument_list|)
expr_stmt|;
name|String
name|output
init|=
name|os
operator|.
name|toString
argument_list|(
literal|"UTF8"
argument_list|)
decl_stmt|;
name|beeLine
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|output
return|;
block|}
comment|/**    * Attempt to execute a simple script file with the -f and -i option to    * BeeLine to test for presence of an expected pattern in the output (stdout    * or stderr), fail if not found. Print PASSED or FAILED    *    * @param expectedRegex    *          Text to look for in command output (stdout)    * @param shouldMatch    *          true if the pattern should be found, false if it should not    * @throws Exception    *           on command execution error    */
specifier|private
name|void
name|testScriptFile
parameter_list|(
name|String
name|scriptText
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|argList
parameter_list|,
name|String
name|expectedRegex
parameter_list|,
name|boolean
name|shouldMatch
parameter_list|)
throws|throws
name|Throwable
block|{
name|testScriptFile
argument_list|(
name|scriptText
argument_list|,
name|argList
argument_list|,
name|OutStream
operator|.
name|OUT
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|expectedRegex
argument_list|,
name|shouldMatch
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Attempt to execute a simple script file with the -f and -i option to    * BeeLine to test for presence of an expected pattern in the output (stdout    * or stderr), fail if not found. Print PASSED or FAILED    *    * @param expectedRegex    *          Text to look for in command output (stdout)    * @param regExFlags    *          flags for Pattern.matcher    * @throws Exception    *           on command execution error    */
specifier|private
name|void
name|testScriptFile
parameter_list|(
name|String
name|scriptText
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|argList
parameter_list|,
name|String
name|expectedRegex
parameter_list|,
name|int
name|regExFlags
parameter_list|)
throws|throws
name|Throwable
block|{
name|testScriptFile
argument_list|(
name|scriptText
argument_list|,
name|argList
argument_list|,
name|OutStream
operator|.
name|OUT
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|expectedRegex
argument_list|,
literal|true
argument_list|)
argument_list|)
argument_list|,
name|regExFlags
argument_list|)
expr_stmt|;
block|}
comment|/**    * Attempt to execute a simple script file with the -f and -i option    * to BeeLine to test for presence of an expected pattern    * in the output (stdout or stderr), fail if not found.    * Print PASSED or FAILED    * @param argList arguments    * @param outType output stream type    * @param expectedRegex Text to look for in command output (stdout)    * @param shouldMatch true if the pattern should be found, false if it should not    * @throws Throwable    */
specifier|private
name|void
name|testScriptFile
parameter_list|(
name|String
name|scriptText
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|argList
parameter_list|,
name|OutStream
name|outType
parameter_list|,
name|String
name|expectedRegex
parameter_list|,
name|boolean
name|shouldMatch
parameter_list|)
throws|throws
name|Throwable
block|{
name|testScriptFile
argument_list|(
name|scriptText
argument_list|,
name|argList
argument_list|,
name|outType
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|expectedRegex
argument_list|,
name|shouldMatch
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|testScriptFile
parameter_list|(
name|String
name|scriptText
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|argList
parameter_list|,
name|OutStream
name|streamType
parameter_list|,
name|List
argument_list|<
name|Tuple
argument_list|<
name|String
argument_list|>
argument_list|>
name|expectedMatches
parameter_list|,
name|int
name|regExFlags
parameter_list|)
throws|throws
name|Throwable
block|{
name|testScriptFile
argument_list|(
name|scriptText
argument_list|,
name|argList
argument_list|,
name|streamType
argument_list|,
name|expectedMatches
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|Modes
operator|.
name|values
argument_list|()
argument_list|)
argument_list|,
name|regExFlags
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|testScriptFile
parameter_list|(
name|String
name|scriptText
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|argList
parameter_list|,
name|OutStream
name|streamType
parameter_list|,
name|List
argument_list|<
name|Tuple
argument_list|<
name|String
argument_list|>
argument_list|>
name|expectedMatches
parameter_list|)
throws|throws
name|Throwable
block|{
name|testScriptFile
argument_list|(
name|scriptText
argument_list|,
name|argList
argument_list|,
name|streamType
argument_list|,
name|expectedMatches
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|Modes
operator|.
name|values
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|testScriptFile
parameter_list|(
name|String
name|scriptText
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|argList
parameter_list|,
name|OutStream
name|streamType
parameter_list|,
name|List
argument_list|<
name|Tuple
argument_list|<
name|String
argument_list|>
argument_list|>
name|expectedMatches
parameter_list|,
name|List
argument_list|<
name|Modes
argument_list|>
name|modes
parameter_list|)
throws|throws
name|Throwable
block|{
name|testScriptFile
argument_list|(
name|scriptText
argument_list|,
name|argList
argument_list|,
name|streamType
argument_list|,
name|expectedMatches
argument_list|,
name|modes
argument_list|,
name|Pattern
operator|.
name|DOTALL
argument_list|)
expr_stmt|;
block|}
comment|/**    * Attempt to execute a simple script file with the -f or -i option    * to BeeLine (or both) to  test for presence of an expected pattern    * in the output (stdout or stderr), fail if not found.    * Print PASSED or FAILED    * @param scriptText script to test the output for    * @param argList arguments to be passed to the script file to execute and produce output    * @param streamType Whether match should be done against STDERR or STDOUT    * @param expectedMatches List of Tuple's defining the pattern to match and result of matching    * @param modes testing modes we have to run the script as    * @throws Exception on command execution error    */
specifier|private
name|void
name|testScriptFile
parameter_list|(
name|String
name|scriptText
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|argList
parameter_list|,
name|OutStream
name|streamType
parameter_list|,
name|List
argument_list|<
name|Tuple
argument_list|<
name|String
argument_list|>
argument_list|>
name|expectedMatches
parameter_list|,
name|List
argument_list|<
name|Modes
argument_list|>
name|modes
parameter_list|,
name|int
name|regExFlags
parameter_list|)
throws|throws
name|Throwable
block|{
comment|// Put the script content in a temp file
name|File
name|scriptFile
init|=
name|File
operator|.
name|createTempFile
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
literal|"temp"
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"script file is "
operator|+
name|scriptFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|scriptFile
operator|.
name|deleteOnExit
argument_list|()
expr_stmt|;
name|PrintStream
name|os
init|=
operator|new
name|PrintStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|scriptFile
argument_list|)
argument_list|)
decl_stmt|;
name|os
operator|.
name|print
argument_list|(
name|scriptText
argument_list|)
expr_stmt|;
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|regExFlags
operator|==
literal|0
condition|)
block|{
comment|// No patterns -- just match on equality.
for|for
control|(
name|Modes
name|mode
range|:
name|modes
control|)
block|{
name|String
name|output
init|=
name|mode
operator|.
name|output
argument_list|(
name|scriptFile
argument_list|,
name|argList
argument_list|,
name|streamType
argument_list|)
decl_stmt|;
for|for
control|(
name|Tuple
argument_list|<
name|String
argument_list|>
name|expectedMatch
range|:
name|expectedMatches
control|)
block|{
name|boolean
name|matches
init|=
name|output
operator|.
name|equals
argument_list|(
name|expectedMatch
operator|.
name|pattern
argument_list|)
decl_stmt|;
empty_stmt|;
if|if
condition|(
name|expectedMatch
operator|.
name|shouldMatch
operator|!=
name|matches
condition|)
block|{
comment|//failed
name|byte
index|[]
name|bytes
init|=
name|output
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|fail
argument_list|(
literal|"Output (length "
operator|+
name|output
operator|.
name|length
argument_list|()
operator|+
literal|")\n\""
operator|+
name|output
operator|+
literal|"\" "
operator|+
literal|"bytes \""
operator|+
name|displayBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
operator|+
literal|"\" "
operator|+
literal|"should"
operator|+
operator|(
name|expectedMatch
operator|.
name|shouldMatch
condition|?
literal|""
else|:
literal|" not"
operator|)
operator|+
literal|" equals \n"
operator|+
name|expectedMatch
operator|.
name|pattern
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|List
argument_list|<
name|Tuple
argument_list|<
name|Pattern
argument_list|>
argument_list|>
name|patternsToBeMatched
init|=
name|Lists
operator|.
name|transform
argument_list|(
name|expectedMatches
argument_list|,
operator|new
name|Function
argument_list|<
name|Tuple
argument_list|<
name|String
argument_list|>
argument_list|,
name|Tuple
argument_list|<
name|Pattern
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Tuple
argument_list|<
name|Pattern
argument_list|>
name|apply
parameter_list|(
name|Tuple
argument_list|<
name|String
argument_list|>
name|tuple
parameter_list|)
block|{
return|return
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|Pattern
operator|.
name|compile
argument_list|(
literal|".*"
operator|+
name|tuple
operator|.
name|pattern
operator|+
literal|".*"
argument_list|,
name|regExFlags
argument_list|)
argument_list|,
name|tuple
operator|.
name|shouldMatch
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
for|for
control|(
name|Modes
name|mode
range|:
name|modes
control|)
block|{
name|String
name|output
init|=
name|mode
operator|.
name|output
argument_list|(
name|scriptFile
argument_list|,
name|argList
argument_list|,
name|streamType
argument_list|)
decl_stmt|;
for|for
control|(
name|Tuple
argument_list|<
name|Pattern
argument_list|>
name|patternToMatch
range|:
name|patternsToBeMatched
control|)
block|{
name|Matcher
name|m
init|=
name|patternToMatch
operator|.
name|pattern
operator|.
name|matcher
argument_list|(
name|output
argument_list|)
decl_stmt|;
name|boolean
name|matches
init|=
name|m
operator|.
name|matches
argument_list|()
decl_stmt|;
if|if
condition|(
name|patternToMatch
operator|.
name|shouldMatch
operator|!=
name|matches
condition|)
block|{
comment|//failed
name|byte
index|[]
name|bytes
init|=
name|output
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|fail
argument_list|(
literal|"Output (length "
operator|+
name|output
operator|.
name|length
argument_list|()
operator|+
literal|")\n\""
operator|+
name|output
operator|+
literal|"\" "
operator|+
literal|"bytes \""
operator|+
name|displayBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
operator|+
literal|"\" "
operator|+
literal|"should"
operator|+
operator|(
name|patternToMatch
operator|.
name|shouldMatch
condition|?
literal|""
else|:
literal|" not"
operator|)
operator|+
literal|" contain\n"
operator|+
name|patternToMatch
operator|.
name|pattern
operator|.
name|pattern
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|scriptFile
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
specifier|public
specifier|static
name|String
name|displayBytes
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|start
operator|+
name|length
condition|;
name|i
operator|++
control|)
block|{
name|char
name|ch
init|=
operator|(
name|char
operator|)
name|bytes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ch
argument_list|<
literal|' '
operator|||
name|ch
argument_list|>
literal|'~'
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"\\%03d"
argument_list|,
name|bytes
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/*     We are testing for both type of modes always so not passing that as a parameter for now   */
enum|enum
name|Modes
block|{
name|INIT
block|{
annotation|@
name|Override
name|String
name|output
parameter_list|(
name|File
name|scriptFile
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|argList
parameter_list|,
name|OutStream
name|streamType
parameter_list|)
throws|throws
name|Throwable
block|{
name|List
argument_list|<
name|String
argument_list|>
name|copy
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|argList
argument_list|)
decl_stmt|;
name|copy
operator|.
name|add
argument_list|(
literal|"-i"
argument_list|)
expr_stmt|;
name|copy
operator|.
name|add
argument_list|(
name|scriptFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|testCommandLineScript
argument_list|(
name|copy
argument_list|,
operator|new
name|StringBufferInputStream
argument_list|(
literal|"!quit\n"
argument_list|)
argument_list|,
name|streamType
argument_list|)
return|;
block|}
block|}
block|,
name|SCRIPT
block|{
annotation|@
name|Override
name|String
name|output
parameter_list|(
name|File
name|scriptFile
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|argList
parameter_list|,
name|OutStream
name|streamType
parameter_list|)
throws|throws
name|Throwable
block|{
name|List
argument_list|<
name|String
argument_list|>
name|copy
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|argList
argument_list|)
decl_stmt|;
name|copy
operator|.
name|add
argument_list|(
literal|"-f"
argument_list|)
expr_stmt|;
name|copy
operator|.
name|add
argument_list|(
name|scriptFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|testCommandLineScript
argument_list|(
name|copy
argument_list|,
literal|null
argument_list|,
name|streamType
argument_list|)
return|;
block|}
block|}
block|;
specifier|abstract
name|String
name|output
parameter_list|(
name|File
name|scriptFile
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|argList
parameter_list|,
name|OutStream
name|streamType
parameter_list|)
throws|throws
name|Throwable
function_decl|;
block|}
comment|/**    * Attempt to execute the enclosed query with the -e option to BeeLine    * Test for presence of an expected pattern    * in the output (stdout or stderr), fail if not found    * Print PASSED or FAILED    * @param expectedPattern Text to look for in command output/error    * @param shouldMatch true if the pattern should be found, false if it should not    * @throws Exception on command execution error    */
specifier|private
name|void
name|testCommandEnclosedQuery
parameter_list|(
name|String
name|enclosedQuery
parameter_list|,
name|String
name|expectedPattern
parameter_list|,
name|boolean
name|shouldMatch
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|argList
parameter_list|,
name|OutStream
name|out
parameter_list|)
throws|throws
name|Throwable
block|{
name|List
argument_list|<
name|String
argument_list|>
name|copy
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|argList
argument_list|)
decl_stmt|;
name|copy
operator|.
name|add
argument_list|(
literal|"-e"
argument_list|)
expr_stmt|;
name|copy
operator|.
name|add
argument_list|(
name|enclosedQuery
argument_list|)
expr_stmt|;
name|String
name|output
init|=
name|testCommandLineScript
argument_list|(
name|copy
argument_list|,
literal|null
argument_list|,
name|out
argument_list|)
decl_stmt|;
name|boolean
name|matches
init|=
name|output
operator|.
name|contains
argument_list|(
name|expectedPattern
argument_list|)
decl_stmt|;
if|if
condition|(
name|shouldMatch
operator|!=
name|matches
condition|)
block|{
comment|//failed
name|fail
argument_list|(
literal|"Output"
operator|+
name|output
operator|+
literal|" should"
operator|+
operator|(
name|shouldMatch
condition|?
literal|""
else|:
literal|" not"
operator|)
operator|+
literal|" contain "
operator|+
name|expectedPattern
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Test that BeeLine will read comment lines that start with whitespace    * @throws Throwable    */
annotation|@
name|Test
specifier|public
name|void
name|testWhitespaceBeforeCommentScriptFile
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|" 	 	-- comment has spaces and tabs before it\n 	 	# comment has spaces and tabs before it\n"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"cannot recognize input near '<EOF>'"
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Attempt to execute a simple script file with the -f option to BeeLine    * Test for presence of an expected pattern    * in the output (stdout or stderr), fail if not found    * Print PASSED or FAILED    */
annotation|@
name|Test
specifier|public
name|void
name|testPositiveScriptFile
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"show databases;\n"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|" default "
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Fix to HIVE-10541: Beeline requires a newline at the end of each query in a file.    * Otherwise, the last line of cmd in the script will be ignored.    */
annotation|@
name|Test
specifier|public
name|void
name|testLastLineCmdInScriptFile
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"show databases;\nshow tables;"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|" testbeelinetable1 "
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test Beeline -hivevar option. User can specify --hivevar name=value on Beeline command line.    * In the script, user should be able to use it in the form of ${name}, which will be substituted with    * the value.    * @throws Throwable    */
annotation|@
name|Test
specifier|public
name|void
name|testBeelineHiveVariable
parameter_list|()
throws|throws
name|Throwable
block|{
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--hivevar"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"DUMMY_TBL=dummy"
argument_list|)
expr_stmt|;
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"create table ${DUMMY_TBL} (d int);\nshow tables;\n drop table  ${DUMMY_TBL};"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"dummy"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testBeelineHiveConfVariable
parameter_list|()
throws|throws
name|Throwable
block|{
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--hiveconf"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"test.hive.table.name=dummy"
argument_list|)
expr_stmt|;
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"create table ${hiveconf:test.hive.table.name} (d int);\nshow tables;\n"
operator|+
literal|" drop table ${hiveconf:test.hive.table.name};\n"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"dummy"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test Beeline -hivevar option. User can specify --hivevar name=value on Beeline command line.    * This test defines multiple variables using repeated --hivevar or --hiveconf flags.    * @throws Throwable    */
annotation|@
name|Test
specifier|public
name|void
name|testBeelineMultiHiveVariable
parameter_list|()
throws|throws
name|Throwable
block|{
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--hivevar"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"TABLE_NAME=dummy2"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--hiveconf"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"COLUMN_NAME=d"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--hivevar"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"COMMAND=create"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--hivevar"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"OBJECT=table"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--hiveconf"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"COLUMN_TYPE=int"
argument_list|)
expr_stmt|;
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"${COMMAND} ${OBJECT} ${TABLE_NAME} "
operator|+
literal|"(${hiveconf:COLUMN_NAME} ${hiveconf:COLUMN_TYPE});"
operator|+
literal|"\nshow tables;\n drop ${OBJECT} ${TABLE_NAME};\n"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"dummy2"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Attempt to execute a simple script file with the -f option to BeeLine    * The first command should fail and the second command should not execute    * Print PASSED or FAILED    */
annotation|@
name|Test
specifier|public
name|void
name|testBreakOnErrorScriptFile
parameter_list|()
throws|throws
name|Throwable
block|{
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"select * from abcdefg01;\nshow databases;\n"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|" default "
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTabInScriptFile
parameter_list|()
throws|throws
name|Throwable
block|{
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"CREATE\tTABLE IF NOT EXISTS testTabInScriptFile\n(id\tint);\nSHOW TABLES;"
operator|+
literal|"\ndrop table testTabInScriptFile"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"testTabInScriptFile"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|OutStream
operator|.
name|ERR
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|OutStream
operator|.
name|OUT
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testBeelineShellCommand
parameter_list|()
throws|throws
name|Throwable
block|{
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"!sh echo \"hello world.\"> hw.txt\n!sh cat hw.txt\n!rm hw.txt"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"hello world"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|OutStream
operator|.
name|OUT
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
argument_list|)
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|Modes
operator|.
name|SCRIPT
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Select null from table , check how null is printed    * Print PASSED or FAILED    */
annotation|@
name|Test
specifier|public
name|void
name|testNullDefault
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"set hive.support.concurrency = false;\n"
operator|+
literal|"select null from "
operator|+
name|tableName
operator|+
literal|" limit 1 ;\n"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"NULL"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Select null from table , check if default null is printed differently    * Print PASSED or FAILED    */
annotation|@
name|Test
specifier|public
name|void
name|testNullNonEmpty
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"set hive.support.concurrency = false;\n"
operator|+
literal|"!set nullemptystring false\n select null from "
operator|+
name|tableName
operator|+
literal|" limit 1 ;\n"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"NULL"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testGetVariableValue
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"set env:TERM;"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"env:TERM"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
argument_list|,
name|OutStream
operator|.
name|ERR
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Select null from table , check if setting null to empty string works.    * Original beeline/sqlline used to print nulls as empty strings.    * Also test csv2 output format    * Print PASSED or FAILED    */
annotation|@
name|Test
specifier|public
name|void
name|testNullEmpty
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"set hive.support.concurrency = false;\n"
operator|+
literal|"!set nullemptystring true\n select 'abc',null,'def' from "
operator|+
name|tableName
operator|+
literal|" limit 1 ;\n"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"abc,,def"
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--outputformat=csv2"
argument_list|)
expr_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test writing output using DSV format, with custom delimiter ";"    */
annotation|@
name|Test
specifier|public
name|void
name|testDSVOutput
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|SCRIPT_TEXT
init|=
name|getFormatTestQuery
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--outputformat=dsv"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--delimiterForDSV=;"
argument_list|)
expr_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"1;NULL;defg;ab\"c;1.0"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test writing output using TSV (new) format    */
annotation|@
name|Test
specifier|public
name|void
name|testTSV2Output
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|SCRIPT_TEXT
init|=
name|getFormatTestQuery
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--outputformat=tsv2"
argument_list|)
expr_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"1\tNULL\tdefg\tab\"c\t1.0"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test writing output using TSV deprecated format    */
annotation|@
name|Test
specifier|public
name|void
name|testTSVOutput
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|SCRIPT_TEXT
init|=
name|getFormatTestQuery
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--outputformat=tsv"
argument_list|)
expr_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"'1'\t'NULL'\t'defg'\t'ab\"c\'\t'1.0'"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test writing output using new TSV format    */
annotation|@
name|Test
specifier|public
name|void
name|testTSV2OutputWithDoubleQuotes
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|SCRIPT_TEXT
init|=
name|getFormatTestQueryForEableQuotes
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--outputformat=tsv2"
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
name|SeparatedValuesOutputFormat
operator|.
name|DISABLE_QUOTING_FOR_SV
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"1\tNULL\tdefg\t\"ab\"\"c\"\t\"\"\"aa\"\"\"\t1.0"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
name|SeparatedValuesOutputFormat
operator|.
name|DISABLE_QUOTING_FOR_SV
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test writing output using TSV deprecated format    */
annotation|@
name|Test
specifier|public
name|void
name|testTSVOutputWithDoubleQuotes
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|SCRIPT_TEXT
init|=
name|getFormatTestQueryForEableQuotes
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--outputformat=tsv"
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
name|SeparatedValuesOutputFormat
operator|.
name|DISABLE_QUOTING_FOR_SV
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"'1'\t'NULL'\t'defg'\t'ab\"c'\t'\"aa\"'\t'1.0'"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
name|SeparatedValuesOutputFormat
operator|.
name|DISABLE_QUOTING_FOR_SV
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test writing output using new CSV format    */
annotation|@
name|Test
specifier|public
name|void
name|testCSV2OutputWithDoubleQuotes
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|SCRIPT_TEXT
init|=
name|getFormatTestQueryForEableQuotes
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--outputformat=csv2"
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
name|SeparatedValuesOutputFormat
operator|.
name|DISABLE_QUOTING_FOR_SV
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"1,NULL,defg,\"ab\"\"c\",\"\"\"aa\"\"\",1.0"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
name|SeparatedValuesOutputFormat
operator|.
name|DISABLE_QUOTING_FOR_SV
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test writing output using CSV deprecated format    */
annotation|@
name|Test
specifier|public
name|void
name|testCSVOutputWithDoubleQuotes
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|SCRIPT_TEXT
init|=
name|getFormatTestQueryForEableQuotes
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--outputformat=csv"
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
name|SeparatedValuesOutputFormat
operator|.
name|DISABLE_QUOTING_FOR_SV
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"'1','NULL','defg','ab\"c','\"aa\"','1.0'"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
name|SeparatedValuesOutputFormat
operator|.
name|DISABLE_QUOTING_FOR_SV
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test writing output using DSV format, with custom delimiter ";"    */
annotation|@
name|Test
specifier|public
name|void
name|testDSVOutputWithDoubleQuotes
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|SCRIPT_TEXT
init|=
name|getFormatTestQueryForEableQuotes
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--outputformat=dsv"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--delimiterForDSV=;"
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
name|SeparatedValuesOutputFormat
operator|.
name|DISABLE_QUOTING_FOR_SV
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"1;NULL;defg;\"ab\"\"c\";\"\"\"aa\"\"\";1.0"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
name|SeparatedValuesOutputFormat
operator|.
name|DISABLE_QUOTING_FOR_SV
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test writing output using TSV deprecated format    * Check for deprecation message    */
annotation|@
name|Test
specifier|public
name|void
name|testTSVOutputDeprecation
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|SCRIPT_TEXT
init|=
name|getFormatTestQuery
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--outputformat=tsv"
argument_list|)
expr_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"Format tsv is deprecated, please use tsv2"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|OutStream
operator|.
name|ERR
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test writing output using CSV deprecated format    * Check for deprecation message    */
annotation|@
name|Test
specifier|public
name|void
name|testCSVOutputDeprecation
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|SCRIPT_TEXT
init|=
name|getFormatTestQuery
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--outputformat=csv"
argument_list|)
expr_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"Format csv is deprecated, please use csv2"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|OutStream
operator|.
name|ERR
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test writing output using CSV deprecated format    */
annotation|@
name|Test
specifier|public
name|void
name|testCSVOutput
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|SCRIPT_TEXT
init|=
name|getFormatTestQuery
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--outputformat=csv"
argument_list|)
expr_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"'1','NULL','defg','ab\"c\','1.0'"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
name|String
name|getFormatTestQuery
parameter_list|()
block|{
return|return
literal|"set hive.support.concurrency = false;\n"
operator|+
literal|"select 1, null, 'defg', 'ab\"c', 1.0D from "
operator|+
name|tableName
operator|+
literal|" limit 1 ;\n"
return|;
block|}
specifier|private
name|String
name|getFormatTestQueryForEableQuotes
parameter_list|()
block|{
return|return
literal|"set hive.support.concurrency = false;\n"
operator|+
literal|"select 1, null, 'defg', 'ab\"c', '\"aa\"', 1.0D from "
operator|+
name|tableName
operator|+
literal|" limit 1 ;\n"
return|;
block|}
comment|/**    * Test writing output using Escape CRLF (false), DSV format, with custom delimiter ";"    */
annotation|@
name|Test
specifier|public
name|void
name|testEscapeCRLFOffInDSVOutput
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|SCRIPT_TEXT
init|=
name|getFormatEscapeCRLFTestQuery
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--outputformat=dsv"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--delimiterForDSV=;"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--showHeader=false"
argument_list|)
expr_stmt|;
comment|// Don't specify "--escapeCRLF"
comment|// Use MULTILINE regex's beginning of line ^ anchor.
comment|// NOTE: trailing blanks get removed from the output...
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"^no cr lf;a cr\nand a lf\n"
operator|+
literal|"^word word end CRLF\n"
operator|+
literal|"^\n"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
name|Pattern
operator|.
name|MULTILINE
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test writing output using Escape CRLF, DSV format, with custom delimiter ";"    */
annotation|@
name|Test
specifier|public
name|void
name|testEscapeCRLFInDSVOutput
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|SCRIPT_TEXT
init|=
name|getFormatEscapeCRLFTestQuery
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--outputformat=dsv"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--delimiterForDSV=;"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--showHeader=false"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--escapeCRLF"
argument_list|)
expr_stmt|;
comment|// Just compare for equals and avoid Pattern regex issues.
specifier|final
name|String
name|EQUALS_STRING
init|=
literal|"no cr lf;a cr\\nand a lf\\nword word end CRLF\\n\n"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EQUALS_STRING
argument_list|,
comment|/* equals */
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test writing output using Escape CRLF, TSV (new) format    */
annotation|@
name|Test
specifier|public
name|void
name|testEscapeCRLFInTSV2Output
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|SCRIPT_TEXT
init|=
name|getFormatEscapeCRLFTestQuery
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--outputformat=tsv2"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--showHeader=false"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--escapeCRLF"
argument_list|)
expr_stmt|;
comment|// Just compare for equals and avoid Pattern regex issues.
specifier|final
name|String
name|EQUALS_STRING
init|=
literal|"no cr lf\ta cr\\nand a lf\\nword word end CRLF\\n\n"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EQUALS_STRING
argument_list|,
comment|/* equals */
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test writing output using Escape CRLF, CSV deprecated format    */
annotation|@
name|Test
specifier|public
name|void
name|testEscapeCRLFInCSVOutput
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|SCRIPT_TEXT
init|=
name|getFormatEscapeCRLFTestQuery
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--outputformat=csv"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--showHeader=false"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--escapeCRLF"
argument_list|)
expr_stmt|;
comment|// Just compare for equals and avoid Pattern regex issues.
specifier|final
name|String
name|EQUALS_STRING
init|=
literal|"'no cr lf','a cr\\nand a lf\\nword word end CRLF\\n'\n"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EQUALS_STRING
argument_list|,
comment|/* equals */
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|private
name|String
name|getFormatEscapeCRLFTestQuery
parameter_list|()
block|{
comment|// Drop/create table for escape CRLF testing, populate, and query.
name|String
name|queryString
init|=
literal|"set hive.support.concurrency = false;\n"
operator|+
literal|"drop table if exists "
operator|+
name|escapeCRLFTableName
operator|+
literal|";\n"
operator|+
literal|"create table "
operator|+
name|escapeCRLFTableName
operator|+
literal|"  (no_crlf string, has_crlf string) stored as sequencefile;\n"
operator|+
literal|"insert into table "
operator|+
name|escapeCRLFTableName
operator|+
literal|"  values(\"no cr lf\", \"a cr \r and a lf \n word word end CRLF \r\n\");\n"
operator|+
literal|"select * from "
operator|+
name|escapeCRLFTableName
operator|+
literal|" limit 1 ;\n"
decl_stmt|;
return|return
name|queryString
return|;
block|}
comment|/**    * Select null from table , check if setting null to empty string works - Using beeling cmd line    *  argument.    * Original beeline/sqlline used to print nulls as empty strings    * Print PASSED or FAILED    */
annotation|@
name|Test
specifier|public
name|void
name|testNullEmptyCmdArg
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"set hive.support.concurrency = false;\n"
operator|+
literal|"select 'abc',null,'def' from "
operator|+
name|tableName
operator|+
literal|" limit 1 ;\n"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"'abc','','def'"
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--nullemptystring=true"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--outputformat=csv"
argument_list|)
expr_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Attempt to execute a missing script file with the -f option to BeeLine    */
annotation|@
name|Test
specifier|public
name|void
name|testNegativeScriptFile
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|" default "
decl_stmt|;
comment|// Create and delete a temp file
name|File
name|scriptFile
init|=
name|File
operator|.
name|createTempFile
argument_list|(
literal|"beelinenegative"
argument_list|,
literal|"temp"
argument_list|)
decl_stmt|;
name|scriptFile
operator|.
name|delete
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"-f"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
name|scriptFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|String
name|output
init|=
name|testCommandLineScript
argument_list|(
name|argList
argument_list|,
literal|null
argument_list|,
name|OutStream
operator|.
name|OUT
argument_list|)
decl_stmt|;
if|if
condition|(
name|output
operator|.
name|contains
argument_list|(
name|EXPECTED_PATTERN
argument_list|)
condition|)
block|{
name|fail
argument_list|(
literal|"Output: "
operator|+
name|output
operator|+
literal|" Negative pattern: "
operator|+
name|EXPECTED_PATTERN
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * HIVE-4566    * @throws UnsupportedEncodingException    */
annotation|@
name|Test
specifier|public
name|void
name|testNPE
parameter_list|()
throws|throws
name|UnsupportedEncodingException
block|{
name|BeeLine
name|beeLine
init|=
operator|new
name|BeeLine
argument_list|()
decl_stmt|;
name|ByteArrayOutputStream
name|os
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|PrintStream
name|beelineOutputStream
init|=
operator|new
name|PrintStream
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|beeLine
operator|.
name|setOutputStream
argument_list|(
name|beelineOutputStream
argument_list|)
expr_stmt|;
name|beeLine
operator|.
name|setErrorStream
argument_list|(
name|beelineOutputStream
argument_list|)
expr_stmt|;
name|beeLine
operator|.
name|runCommands
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"!typeinfo"
block|}
argument_list|)
expr_stmt|;
name|String
name|output
init|=
name|os
operator|.
name|toString
argument_list|(
literal|"UTF8"
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
name|output
operator|.
name|contains
argument_list|(
literal|"java.lang.NullPointerException"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|output
operator|.
name|contains
argument_list|(
literal|"No current connection"
argument_list|)
argument_list|)
expr_stmt|;
name|beeLine
operator|.
name|runCommands
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"!nativesql"
block|}
argument_list|)
expr_stmt|;
name|output
operator|=
name|os
operator|.
name|toString
argument_list|(
literal|"UTF8"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
name|output
operator|.
name|contains
argument_list|(
literal|"java.lang.NullPointerException"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|output
operator|.
name|contains
argument_list|(
literal|"No current connection"
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|">>> PASSED "
operator|+
literal|"testNPE"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testHiveVarSubstitution
parameter_list|()
throws|throws
name|Throwable
block|{
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
operator|+
literal|"#D_TBL=dummy_t"
argument_list|)
decl_stmt|;
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"create table ${D_TBL} (d int);\nshow tables;\ndrop  table ${D_TBL};\n"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"dummy_t"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEmbeddedBeelineConnection
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|embeddedJdbcURL
init|=
name|Utils
operator|.
name|URL_PREFIX
operator|+
literal|"/Default"
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|embeddedJdbcURL
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--hivevar"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"DUMMY_TBL=embedded_table"
argument_list|)
expr_stmt|;
comment|// Set to non-zk lock manager to avoid trying to connect to zookeeper
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"set hive.lock.manager=org.apache.hadoop.hive.ql.lockmgr.EmbeddedLockManager;\n"
operator|+
literal|"create table ${DUMMY_TBL} (d int);\nshow tables;\n drop table ${DUMMY_TBL};\n"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"embedded_table"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test Beeline could show the query progress for time-consuming query.    * @throws Throwable    */
annotation|@
name|Test
specifier|public
name|void
name|testQueryProgress
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"set hive.support.concurrency = false;\n"
operator|+
literal|"set hive.server2.logging.operation.level=execution;\n"
operator|+
literal|"select count(*) from "
operator|+
name|tableName
operator|+
literal|";\n"
decl_stmt|;
comment|// Check for part of log message as well as part of progress information
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"ELAPSED TIME"
decl_stmt|;
specifier|final
name|String
name|UNEXPECTED_PATTERN
init|=
literal|"(?=Reducer 2\\:).*(?=Map 1\\:)"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
argument_list|,
name|OutStream
operator|.
name|ERR
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
argument_list|,
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|UNEXPECTED_PATTERN
argument_list|,
literal|false
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test Beeline could show the query progress for time-consuming query when hive.exec.parallel    * is true    *    * We have changed the pattern to not look of the progress bar as the test runs fine individually    * and also as part of the whole class, on CI however they are batched and that might have caused    * some issue, it needs more investigation for the same    *    * @throws Throwable    */
annotation|@
name|Test
specifier|public
name|void
name|testQueryProgressParallel
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"set hive.support.concurrency = false;\n"
operator|+
literal|"set hive.exec.parallel = true;\n"
operator|+
literal|"select count(*) from "
operator|+
name|tableName
operator|+
literal|";\n"
decl_stmt|;
comment|// Check for part of log message as well as part of progress information
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"Number of reducers determined to be."
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
argument_list|,
name|OutStream
operator|.
name|ERR
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test Beeline will hide the query progress when silent option is set.    * @throws Throwable    */
annotation|@
name|Test
specifier|public
name|void
name|testQueryProgressHidden
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"set hive.support.concurrency = false;\n"
operator|+
literal|"!set silent true\n"
operator|+
literal|"select count(*) from "
operator|+
name|tableName
operator|+
literal|";\n"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"Executing command"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
argument_list|,
name|OutStream
operator|.
name|ERR
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testQueryProgressWithHiveServer2ProgressBarDisabled
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"set hive.support.concurrency = false;\nset hive.server2.in.place.progress=false;\n"
operator|+
literal|"select count(*) from "
operator|+
name|tableName
operator|+
literal|";\n"
decl_stmt|;
comment|// Check for part of log message as well as part of progress information
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"(?=Reducer 2\\:).*(?=Map 1\\:)"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
argument_list|,
name|OutStream
operator|.
name|ERR
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
argument_list|,
operator|new
name|Tuple
argument_list|<>
argument_list|(
literal|"ELAPSED TIME"
argument_list|,
literal|false
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMultiCommandsInOneline
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"drop table if exists multiCmdTbl;create table multiCmdTbl "
operator|+
literal|"(key int);show tables; --multicommands in one line"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|" multicmdtbl "
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|String
name|SCRIPT_TEXT_DROP
init|=
literal|"drop table multiCmdTbl;show tables;"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT_DROP
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMultiCommandsInOneEnclosedQuery
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|QUERY_TEXT
init|=
literal|"drop table if exists multiCmdTbl;create table multiCmdTbl "
operator|+
literal|"(key int);show tables; --multicommands in one line"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|" multicmdtbl "
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|testCommandEnclosedQuery
argument_list|(
name|QUERY_TEXT
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|,
name|argList
argument_list|,
name|OutStream
operator|.
name|OUT
argument_list|)
expr_stmt|;
specifier|final
name|String
name|QUERY_TEXT_DROP
init|=
literal|"drop table multiCmdTbl;show tables;"
decl_stmt|;
name|testCommandEnclosedQuery
argument_list|(
name|QUERY_TEXT_DROP
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|false
argument_list|,
name|argList
argument_list|,
name|OutStream
operator|.
name|OUT
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOneCommandInMultiLines
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"drop table if exists multiCmdTbl;create table \nmultiCmdTbl "
operator|+
literal|"(key int);show tables; --one command in multiple lines"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|" multicmdtbl "
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|String
name|SCRIPT_TEXT_DROP
init|=
literal|"drop table\nmultiCmdTbl;show tables;"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT_DROP
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEscapeSemiColonInQueries
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"drop table if exists multiCmdTbl;create table multiCmdTbl "
operator|+
literal|"(key int, value string) ROW FORMAT DELIMITED FIELDS TERMINATED BY '\\;' LINES "
operator|+
literal|" TERMINATED BY '\\n';show tables; --one command in multiple lines"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|" multicmdtbl "
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|String
name|SCRIPT_TEXT_DROP
init|=
literal|"drop table\nmultiCmdTbl;show tables;"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT_DROP
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEscapeSemiColonInEnclosedQuery
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|QUERY_TEXT
init|=
literal|"drop table if exists multiCmdTbl;create table multiCmdTbl "
operator|+
literal|"(key int, value string) ROW FORMAT DELIMITED FIELDS TERMINATED BY '\\;' LINES "
operator|+
literal|" TERMINATED BY '\\n';show tables;"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|" multicmdtbl "
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|testCommandEnclosedQuery
argument_list|(
name|QUERY_TEXT
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|,
name|argList
argument_list|,
name|OutStream
operator|.
name|OUT
argument_list|)
expr_stmt|;
specifier|final
name|String
name|QUERY_TEXT_DROP
init|=
literal|"drop table multiCmdTbl;show tables;"
decl_stmt|;
name|testCommandEnclosedQuery
argument_list|(
name|QUERY_TEXT_DROP
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|false
argument_list|,
name|argList
argument_list|,
name|OutStream
operator|.
name|OUT
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEmbeddedBeelineOutputs
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|embeddedJdbcURL
init|=
name|Utils
operator|.
name|URL_PREFIX
operator|+
literal|"/Default"
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|embeddedJdbcURL
argument_list|)
decl_stmt|;
comment|// Set to non-zk lock manager to avoid trying to connect to zookeeper
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"set hive.lock.manager=org.apache.hadoop.hive.ql.lockmgr.EmbeddedLockManager;\n"
operator|+
literal|"set hive.compute.query.using.stats=false;\n"
operator|+
literal|"create table if not exists embeddedBeelineOutputs(d int);\n"
operator|+
literal|"set a=1;\nselect count(*) from embeddedBeelineOutputs;\n"
operator|+
literal|"drop table embeddedBeelineOutputs;\n"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"Stage-1 map ="
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|OutStream
operator|.
name|ERR
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testConnectionUrlWithSemiColon
parameter_list|()
throws|throws
name|Throwable
block|{
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getJdbcURL
argument_list|(
literal|"default"
argument_list|,
literal|"sess_var_list?var1=value1"
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"set var1"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"var1=value1"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test Beeline !connect with beeline saved vars    * @throws Throwable    */
annotation|@
name|Test
specifier|public
name|void
name|testBeelineConnectEnvVar
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|jdbcUrl
init|=
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"-u"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"blue"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"-d"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
name|BeeLine
operator|.
name|BEELINE_DEFAULT_JDBC_DRIVER
argument_list|)
expr_stmt|;
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"create table blueconnecttest (d int);\nshow tables;\ndrop table blueconnecttest;\n"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"blueconnecttest"
decl_stmt|;
comment|// We go through these hijinxes because java considers System.getEnv
comment|// to be read-only, and offers no way to set an env var from within
comment|// a process, only for processes that we sub-spawn.
specifier|final
name|BeeLineOpts
operator|.
name|Env
name|baseEnv
init|=
name|BeeLineOpts
operator|.
name|getEnv
argument_list|()
decl_stmt|;
name|BeeLineOpts
operator|.
name|Env
name|newEnv
init|=
operator|new
name|BeeLineOpts
operator|.
name|Env
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|get
parameter_list|(
name|String
name|envVar
parameter_list|)
block|{
if|if
condition|(
name|envVar
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"BEELINE_URL_BLUE"
argument_list|)
condition|)
block|{
return|return
name|jdbcUrl
return|;
block|}
else|else
block|{
return|return
name|baseEnv
operator|.
name|get
argument_list|(
name|envVar
argument_list|)
return|;
block|}
block|}
block|}
decl_stmt|;
name|BeeLineOpts
operator|.
name|setEnv
argument_list|(
name|newEnv
argument_list|)
expr_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|OutStream
operator|.
name|OUT
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
argument_list|)
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|Modes
operator|.
name|SCRIPT
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that if we !close, we can still !reconnect    * @throws Throwable    */
annotation|@
name|Test
specifier|public
name|void
name|testBeelineReconnect
parameter_list|()
throws|throws
name|Throwable
block|{
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"!close\n"
operator|+
literal|"!reconnect\n\n\n"
operator|+
literal|"create table reconnecttest (d int);\nshow tables;\ndrop table reconnecttest;\n"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"reconnecttest"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|OutStream
operator|.
name|OUT
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
argument_list|)
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|Modes
operator|.
name|SCRIPT
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Attempt to execute a simple script file with the usage of user& password variables in URL.    * Test for presence of an expected pattern    * in the output (stdout or stderr), fail if not found    * Print PASSED or FAILED    */
annotation|@
name|Test
specifier|public
name|void
name|testConnectionWithURLParams
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|" hivetest "
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"-d"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
name|BeeLine
operator|.
name|BEELINE_DEFAULT_JDBC_DRIVER
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"-u"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
operator|+
literal|";user=hivetest;password=hive"
argument_list|)
expr_stmt|;
name|String
name|SCRIPT_TEXT
init|=
literal|"select current_user();"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that Beeline queries don't treat semicolons inside quotations as query-ending characters.    */
annotation|@
name|Test
specifier|public
name|void
name|testQueryNonEscapedSemiColon
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|SCRIPT_TEXT
init|=
literal|"drop table if exists nonEscapedSemiColon;create table nonEscapedSemiColon "
operator|+
literal|"(key int, value int) ROW FORMAT DELIMITED FIELDS TERMINATED BY ';';show tables;"
decl_stmt|;
name|String
name|EXPECTED_PATTERN
init|=
literal|"nonescapedsemicolon"
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|//look for the " nonEscapedSemiColon " in the query text not the table name which comes
comment|//in the result
name|EXPECTED_PATTERN
operator|=
literal|" nonEscapedSemiColon "
expr_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|OutStream
operator|.
name|ERR
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|OutStream
operator|.
name|OUT
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSelectQueryWithNonEscapedSemiColon
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|SCRIPT_TEXT
init|=
literal|"select ';', \"';'\", '\";\"', '\\';', ';\\'', '\\\";', ';\\\"' from "
operator|+
name|tableName
operator|+
literal|";"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|";\t';'\t\";\"\t';\t;'\t\";\t;\""
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--outputformat=tsv2"
argument_list|)
expr_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Attempt to execute a simple script file with the usage of user& password variables in URL.    * Test for presence of an expected pattern    * in the output (stdout or stderr), fail if not found    * Print PASSED or FAILED    */
annotation|@
name|Test
specifier|public
name|void
name|testShowDbInPrompt
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|" \\(default\\)>"
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--showDbInPrompt"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"-u"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
operator|+
literal|";user=hivetest;password=hive"
argument_list|)
expr_stmt|;
name|String
name|SCRIPT_TEXT
init|=
literal|"select current_user();"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|OutStream
operator|.
name|ERR
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testBeelineShellCommandWithoutConn
parameter_list|()
throws|throws
name|Throwable
block|{
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"!sh echo hello world"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"hello world"
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|OutStream
operator|.
name|OUT
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
argument_list|)
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|Modes
operator|.
name|SCRIPT
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Attempt to execute Beeline with force option to continue running script even after errors.    * Test for presence of an expected pattern to match the output of a valid command at the end.    */
annotation|@
name|Test
specifier|public
name|void
name|testBeelineWithForce
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|SCRIPT_TEXT
init|=
literal|"drop table does_not_exist;\ncreate table incomplete_syntax(a, string, );\n "
operator|+
literal|"drop table if exists new_table;\n create table new_table(foo int, bar string);\n "
operator|+
literal|"desc new_table;\n"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"2 rows selected"
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--force"
argument_list|)
expr_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|OutStream
operator|.
name|ERR
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
class|class
name|Tuple
parameter_list|<
name|K
parameter_list|>
block|{
specifier|final
name|K
name|pattern
decl_stmt|;
specifier|final
name|boolean
name|shouldMatch
decl_stmt|;
name|Tuple
parameter_list|(
name|K
name|pattern
parameter_list|,
name|boolean
name|shouldMatch
parameter_list|)
block|{
name|this
operator|.
name|pattern
operator|=
name|pattern
expr_stmt|;
name|this
operator|.
name|shouldMatch
operator|=
name|shouldMatch
expr_stmt|;
block|}
block|}
comment|/**    * Test that Beeline can handle \\ characters within a string literal. Either at the beginning, middle, or end of the    * literal.    */
annotation|@
name|Test
specifier|public
name|void
name|testBackslashInLiteral
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|SCRIPT_TEXT
init|=
literal|"select 'hello\\\\', '\\\\hello', 'hel\\\\lo', '\\\\' as literal;"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"hello\\\\\t\\\\hello\thel\\\\lo\t\\\\"
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--outputformat=tsv2"
argument_list|)
expr_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCustomDelimiter
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|SCRIPT_TEXT
init|=
literal|"select 'hello', 'hello', 'hello'$"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"hello\thello\thello"
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--delimiter=$"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--outputformat=tsv2"
argument_list|)
expr_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCustomMultiCharDelimiter
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|SCRIPT_TEXT
init|=
literal|"select 'hello', 'hello', 'hello'$$"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"hello\thello\thello"
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--delimiter=$$"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--outputformat=tsv2"
argument_list|)
expr_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCustomDelimiterWithMultiQuery
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|SCRIPT_TEXT
init|=
literal|"select 'hello', 'hello', 'hello'$select 'world', 'world', 'world'$"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN1
init|=
literal|"hello\thello\thello"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN2
init|=
literal|"world\tworld\tworld"
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--delimiter=$"
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--outputformat=tsv2"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Tuple
argument_list|<
name|String
argument_list|>
argument_list|>
name|expectedMatches
init|=
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|EXPECTED_PATTERN1
argument_list|,
literal|true
argument_list|)
argument_list|,
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|EXPECTED_PATTERN2
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|OutStream
operator|.
name|OUT
argument_list|,
name|expectedMatches
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCustomDelimiterBeelineCmd
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|SCRIPT_TEXT
init|=
literal|"!delimiter $\n select 'hello', 'hello', 'hello'$"
decl_stmt|;
specifier|final
name|String
name|EXPECTED_PATTERN
init|=
literal|"hello\thello\thello"
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
literal|"--outputformat=tsv2"
argument_list|)
expr_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|EXPECTED_PATTERN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test 'describe extended' on tables that have special white space characters in the row format.    */
annotation|@
name|Test
specifier|public
name|void
name|testDescribeExtended
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|SCRIPT_TEXT
init|=
literal|"drop table if exists describeDelim;"
operator|+
literal|"create table describeDelim (orderid int, orderdate string, customerid int)"
operator|+
literal|" ROW FORMAT DELIMITED FIELDS terminated by '\\t' LINES terminated by '\\n';"
operator|+
literal|"describe extended describeDelim;"
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argList
init|=
name|getBaseArgs
argument_list|(
name|miniHS2
operator|.
name|getBaseJdbcURL
argument_list|()
argument_list|)
decl_stmt|;
name|testScriptFile
argument_list|(
name|SCRIPT_TEXT
argument_list|,
name|argList
argument_list|,
name|OutStream
operator|.
name|OUT
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|Tuple
argument_list|<>
argument_list|(
literal|"Detailed Table Information.*line.delim=\\\\n"
argument_list|,
literal|true
argument_list|)
argument_list|,
operator|new
name|Tuple
argument_list|<>
argument_list|(
literal|"Detailed Table Information.*field.delim=\\\\t"
argument_list|,
literal|true
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

