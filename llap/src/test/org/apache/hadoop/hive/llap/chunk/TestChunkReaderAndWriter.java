begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|chunk
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|api
operator|.
name|Vector
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|cache
operator|.
name|BufferPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|cache
operator|.
name|BufferPool
operator|.
name|WeakBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|chunk
operator|.
name|ChunkWriterImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|chunk
operator|.
name|ChunkWriter
operator|.
name|NullsState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|loader
operator|.
name|BufferInProgress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|loader
operator|.
name|ChunkPool
operator|.
name|Chunk
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|*
import|;
end_import

begin_class
specifier|public
class|class
name|TestChunkReaderAndWriter
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TestChunkReaderAndWriter
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|LARGE_BUFFER
init|=
literal|1024
operator|*
literal|1024
decl_stmt|;
annotation|@
name|Test
specifier|public
name|void
name|testSimpleValues
parameter_list|()
throws|throws
name|Exception
block|{
name|testValues
argument_list|(
literal|0.0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValuesWithNulls
parameter_list|()
throws|throws
name|Exception
block|{
name|testValues
argument_list|(
literal|0.02
argument_list|)
expr_stmt|;
name|testValues
argument_list|(
literal|0.5
argument_list|)
expr_stmt|;
name|testValues
argument_list|(
literal|0.98
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNullSegmentTransitions
parameter_list|()
throws|throws
name|Exception
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
literal|1234
argument_list|)
decl_stmt|;
name|ChunkWriterImpl
name|writer
init|=
operator|new
name|ChunkWriterImpl
argument_list|()
decl_stmt|;
name|BufferInProgress
name|buf
init|=
operator|new
name|BufferInProgress
argument_list|(
name|createBuffer
argument_list|(
name|LARGE_BUFFER
argument_list|)
argument_list|)
decl_stmt|;
name|writer
operator|.
name|prepare
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|int
name|ncount1
init|=
literal|1
decl_stmt|,
name|ncount2
init|=
literal|3
decl_stmt|,
name|ncount3
init|=
literal|60
decl_stmt|,
name|ncount4
init|=
literal|3
decl_stmt|;
name|Long
index|[]
name|src
init|=
operator|new
name|Long
index|[
name|ncount1
operator|+
name|ncount2
operator|+
name|ncount3
operator|+
name|ncount4
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|// Try various combinations of repeating and non-repeating segments.
name|offset
operator|=
name|writeNulls
argument_list|(
name|writer
argument_list|,
name|ncount1
argument_list|,
name|src
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|long
index|[]
name|tmp
init|=
operator|new
name|long
index|[
literal|1
index|]
decl_stmt|;
name|tmp
index|[
literal|0
index|]
operator|=
name|random
operator|.
name|nextLong
argument_list|()
expr_stmt|;
name|src
index|[
name|offset
index|]
operator|=
name|tmp
index|[
literal|0
index|]
expr_stmt|;
name|writer
operator|.
name|writeLongs
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|NullsState
operator|.
name|NEXT_NULL
argument_list|)
expr_stmt|;
operator|++
name|offset
expr_stmt|;
name|offset
operator|=
name|writeNulls
argument_list|(
name|writer
argument_list|,
name|ncount2
argument_list|,
name|src
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|writeNulls
argument_list|(
name|writer
argument_list|,
name|ncount3
argument_list|,
name|src
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|writeNulls
argument_list|(
name|writer
argument_list|,
name|ncount4
argument_list|,
name|src
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|writer
operator|.
name|finishCurrentSegment
argument_list|()
expr_stmt|;
name|verifyValues
argument_list|(
name|completeChunk
argument_list|(
name|writer
argument_list|,
name|buf
argument_list|)
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRepeatingSegmentTransitions
parameter_list|()
throws|throws
name|Exception
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
literal|1234
argument_list|)
decl_stmt|;
name|ChunkWriterImpl
name|writer
init|=
operator|new
name|ChunkWriterImpl
argument_list|()
decl_stmt|;
name|BufferInProgress
name|buf
init|=
operator|new
name|BufferInProgress
argument_list|(
name|createBuffer
argument_list|(
name|LARGE_BUFFER
argument_list|)
argument_list|)
decl_stmt|;
name|writer
operator|.
name|prepare
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|int
name|repeating1
init|=
literal|10
decl_stmt|,
name|rcount1
init|=
literal|5
decl_stmt|,
name|repeating2
init|=
operator|-
literal|10
decl_stmt|,
name|rcount2
init|=
literal|5
decl_stmt|,
name|repeating3
init|=
literal|4
decl_stmt|,
name|rcount3
init|=
literal|15
decl_stmt|;
name|int
name|nrcount1
init|=
literal|30
decl_stmt|,
name|nrcount2
init|=
literal|30
decl_stmt|,
name|nrcount3
init|=
literal|30
decl_stmt|;
name|long
index|[]
name|src
init|=
operator|new
name|long
index|[
name|rcount1
operator|+
name|rcount2
operator|+
name|rcount3
operator|+
name|nrcount1
operator|+
name|nrcount2
operator|+
name|nrcount3
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|// Try various combinations of repeating and non-repeating segments.
name|offset
operator|=
name|writeRepeatedValues
argument_list|(
name|writer
argument_list|,
name|repeating1
argument_list|,
name|rcount1
argument_list|,
name|src
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|writeLongs
argument_list|(
name|random
argument_list|,
name|writer
argument_list|,
name|nrcount1
argument_list|,
name|src
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|writeRepeatedValues
argument_list|(
name|writer
argument_list|,
name|repeating2
argument_list|,
name|rcount2
argument_list|,
name|src
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|writeLongs
argument_list|(
name|random
argument_list|,
name|writer
argument_list|,
name|nrcount2
argument_list|,
name|src
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|writeRepeatedValues
argument_list|(
name|writer
argument_list|,
name|repeating3
argument_list|,
name|rcount3
argument_list|,
name|src
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|writeLongs
argument_list|(
name|random
argument_list|,
name|writer
argument_list|,
name|nrcount3
argument_list|,
name|src
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|writer
operator|.
name|finishCurrentSegment
argument_list|()
expr_stmt|;
name|verifyValues
argument_list|(
name|completeChunk
argument_list|(
name|writer
argument_list|,
name|buf
argument_list|)
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testBufferBoundary
parameter_list|()
throws|throws
name|Exception
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
literal|1234
argument_list|)
decl_stmt|;
name|ChunkWriterImpl
name|writer
init|=
operator|new
name|ChunkWriterImpl
argument_list|()
decl_stmt|;
name|BufferInProgress
name|buf
init|=
operator|new
name|BufferInProgress
argument_list|(
name|createBuffer
argument_list|(
literal|128
operator|*
literal|8
argument_list|)
argument_list|)
decl_stmt|;
name|writer
operator|.
name|prepare
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|long
index|[]
name|tmp
init|=
operator|new
name|long
index|[
literal|122
index|]
decl_stmt|;
name|Long
index|[]
name|src
init|=
operator|new
name|Long
index|[
name|tmp
operator|.
name|length
operator|+
literal|2
index|]
decl_stmt|;
name|src
index|[
literal|0
index|]
operator|=
name|tmp
index|[
literal|0
index|]
operator|=
literal|3
expr_stmt|;
comment|// This should start a segment with bitmasks and use up 4 * 8 bytes total.
comment|// Plus, 8 bytes are already used up for the chunk header.
name|writer
operator|.
name|writeLongs
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|NullsState
operator|.
name|NEXT_NULL
argument_list|)
expr_stmt|;
name|src
index|[
literal|1
index|]
operator|=
literal|null
expr_stmt|;
name|writer
operator|.
name|writeNulls
argument_list|(
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Now we have 123 * 8 bytes; 122 values would not fit w/bitmask, but they will w/o one.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tmp
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|src
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|tmp
index|[
name|i
index|]
operator|=
name|random
operator|.
name|nextLong
argument_list|()
expr_stmt|;
block|}
name|writer
operator|.
name|writeLongs
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
name|tmp
operator|.
name|length
argument_list|,
name|NullsState
operator|.
name|NEXT_NULL
argument_list|)
expr_stmt|;
name|writer
operator|.
name|finishCurrentSegment
argument_list|()
expr_stmt|;
name|verifyValues
argument_list|(
name|completeChunk
argument_list|(
name|writer
argument_list|,
name|buf
argument_list|)
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testBoundaryValues
parameter_list|()
throws|throws
name|Exception
block|{
name|ChunkWriterImpl
name|writer
init|=
operator|new
name|ChunkWriterImpl
argument_list|()
decl_stmt|;
name|BufferInProgress
name|buf
init|=
operator|new
name|BufferInProgress
argument_list|(
name|createBuffer
argument_list|(
name|LARGE_BUFFER
argument_list|)
argument_list|)
decl_stmt|;
name|writer
operator|.
name|prepare
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|long
index|[]
name|src
init|=
operator|new
name|long
index|[
literal|9
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|src
argument_list|,
literal|0l
argument_list|)
expr_stmt|;
name|src
index|[
literal|2
index|]
operator|=
name|Long
operator|.
name|MIN_VALUE
expr_stmt|;
name|src
index|[
literal|6
index|]
operator|=
name|Long
operator|.
name|MAX_VALUE
expr_stmt|;
name|src
index|[
literal|8
index|]
operator|=
name|Integer
operator|.
name|MIN_VALUE
expr_stmt|;
name|writer
operator|.
name|writeLongs
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
name|src
operator|.
name|length
argument_list|,
name|NullsState
operator|.
name|NEXT_NULL
argument_list|)
expr_stmt|;
name|writer
operator|.
name|finishCurrentSegment
argument_list|()
expr_stmt|;
name|verifyValues
argument_list|(
name|completeChunk
argument_list|(
name|writer
argument_list|,
name|buf
argument_list|)
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
comment|/**    * A method for generic non-scenario tests.    * @param nullFraction Percentage of nulls in values.    */
specifier|private
name|void
name|testValues
parameter_list|(
name|double
name|nullFraction
parameter_list|)
throws|throws
name|Exception
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
literal|1234
argument_list|)
decl_stmt|;
name|ChunkWriterImpl
name|writer
init|=
operator|new
name|ChunkWriterImpl
argument_list|()
decl_stmt|;
name|WeakBuffer
name|wb
init|=
name|createBuffer
argument_list|(
name|LARGE_BUFFER
argument_list|)
decl_stmt|;
comment|// Value counts to test
name|int
index|[]
name|valueCounts
init|=
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|3
block|,
literal|11
block|,
literal|64
block|,
literal|65
block|,
literal|2048
block|}
decl_stmt|;
name|int
name|totalCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|valueCount
range|:
name|valueCounts
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Testing for value count "
operator|+
name|valueCount
argument_list|)
expr_stmt|;
name|BufferInProgress
name|buf
init|=
operator|new
name|BufferInProgress
argument_list|(
name|wb
argument_list|)
decl_stmt|;
name|writer
operator|.
name|prepare
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|totalCount
operator|+=
name|valueCount
expr_stmt|;
name|Long
index|[]
name|src
init|=
operator|new
name|Long
index|[
name|valueCount
index|]
decl_stmt|;
name|writeLongs
argument_list|(
name|writer
argument_list|,
name|random
argument_list|,
name|nullFraction
argument_list|,
name|valueCount
argument_list|,
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writer
operator|.
name|finishCurrentSegment
argument_list|()
expr_stmt|;
name|verifyValues
argument_list|(
name|completeChunk
argument_list|(
name|writer
argument_list|,
name|buf
argument_list|)
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
comment|// Then try all together
name|BufferInProgress
name|buf
init|=
operator|new
name|BufferInProgress
argument_list|(
name|wb
argument_list|)
decl_stmt|;
name|writer
operator|.
name|prepare
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|Long
index|[]
name|src
init|=
operator|new
name|Long
index|[
name|totalCount
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Testing for total count "
operator|+
name|totalCount
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|valueCount
range|:
name|valueCounts
control|)
block|{
name|writeLongs
argument_list|(
name|writer
argument_list|,
name|random
argument_list|,
name|nullFraction
argument_list|,
name|valueCount
argument_list|,
name|src
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|valueCount
expr_stmt|;
block|}
name|writer
operator|.
name|finishCurrentSegment
argument_list|()
expr_stmt|;
name|verifyValues
argument_list|(
name|completeChunk
argument_list|(
name|writer
argument_list|,
name|buf
argument_list|)
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|writeLongs
parameter_list|(
name|ChunkWriterImpl
name|writer
parameter_list|,
name|Random
name|rdm
parameter_list|,
name|double
name|nullFraction
parameter_list|,
name|int
name|count
parameter_list|,
name|Long
index|[]
name|src
parameter_list|,
name|int
name|srcOffset
parameter_list|)
block|{
name|NullsState
name|nullState
init|=
name|nullFraction
operator|==
literal|0
condition|?
name|NullsState
operator|.
name|NO_NULLS
else|:
name|NullsState
operator|.
name|NEXT_NULL
decl_stmt|;
name|long
index|[]
name|srcPart
init|=
operator|new
name|long
index|[
name|count
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|boolean
name|isFirst
init|=
literal|true
decl_stmt|,
name|isNull
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|offset
operator|<
name|count
condition|)
block|{
name|int
name|runLength
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|isFirst
condition|)
block|{
name|isNull
operator|=
operator|!
name|isNull
expr_stmt|;
if|if
condition|(
operator|!
name|isNull
condition|)
block|{
name|srcPart
index|[
literal|0
index|]
operator|=
name|rdm
operator|.
name|nextLong
argument_list|()
expr_stmt|;
block|}
name|src
index|[
name|srcOffset
operator|+
name|offset
index|]
operator|=
name|isNull
condition|?
literal|null
else|:
name|srcPart
index|[
literal|0
index|]
expr_stmt|;
name|runLength
operator|=
literal|1
expr_stmt|;
operator|++
name|offset
expr_stmt|;
block|}
while|while
condition|(
name|offset
operator|<
name|count
condition|)
block|{
name|boolean
name|curIsNull
init|=
operator|(
name|rdm
operator|.
name|nextDouble
argument_list|()
operator|<=
name|nullFraction
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|isFirst
operator|&&
name|curIsNull
operator|!=
name|isNull
condition|)
break|break;
name|isNull
operator|=
name|curIsNull
expr_stmt|;
if|if
condition|(
operator|!
name|isNull
condition|)
block|{
name|srcPart
index|[
name|runLength
index|]
operator|=
name|rdm
operator|.
name|nextLong
argument_list|()
expr_stmt|;
block|}
name|src
index|[
name|srcOffset
operator|+
name|offset
index|]
operator|=
name|isNull
condition|?
literal|null
else|:
name|srcPart
index|[
name|runLength
index|]
expr_stmt|;
operator|++
name|runLength
expr_stmt|;
operator|++
name|offset
expr_stmt|;
name|isFirst
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|isNull
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Writing "
operator|+
name|runLength
operator|+
literal|" nulls"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeNulls
argument_list|(
name|runLength
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Writing "
operator|+
name|runLength
operator|+
literal|" values"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeLongs
argument_list|(
name|srcPart
argument_list|,
literal|0
argument_list|,
name|runLength
argument_list|,
name|nullState
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
name|int
name|writeLongs
parameter_list|(
name|Random
name|random
parameter_list|,
name|ChunkWriterImpl
name|writer
parameter_list|,
name|int
name|count
parameter_list|,
name|long
index|[]
name|src
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|src
index|[
name|offset
operator|+
name|i
index|]
operator|=
name|random
operator|.
name|nextLong
argument_list|()
expr_stmt|;
block|}
name|writer
operator|.
name|writeLongs
argument_list|(
name|src
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|NullsState
operator|.
name|NO_NULLS
argument_list|)
expr_stmt|;
return|return
name|offset
operator|+
name|count
return|;
block|}
specifier|private
specifier|static
name|int
name|writeRepeatedValues
parameter_list|(
name|ChunkWriterImpl
name|writer
parameter_list|,
name|int
name|val
parameter_list|,
name|int
name|count
parameter_list|,
name|long
index|[]
name|src
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|src
index|[
name|offset
operator|+
name|i
index|]
operator|=
name|val
expr_stmt|;
block|}
name|writer
operator|.
name|writeRepeatedLongs
argument_list|(
name|val
argument_list|,
name|count
argument_list|,
name|NullsState
operator|.
name|NO_NULLS
argument_list|)
expr_stmt|;
return|return
name|offset
operator|+
name|count
return|;
block|}
specifier|private
specifier|static
name|int
name|writeNulls
parameter_list|(
name|ChunkWriterImpl
name|writer
parameter_list|,
name|int
name|count
parameter_list|,
name|Long
index|[]
name|src
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|src
index|[
name|offset
operator|+
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
name|writer
operator|.
name|writeNulls
argument_list|(
name|count
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|offset
operator|+
name|count
return|;
block|}
specifier|private
specifier|static
name|void
name|verifyValues
parameter_list|(
name|Chunk
name|chunk
parameter_list|,
name|Long
index|[]
name|src
parameter_list|)
throws|throws
name|Exception
block|{
name|verifyValues
argument_list|(
name|chunk
argument_list|,
name|src
argument_list|,
name|src
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|verifyValues
parameter_list|(
name|Chunk
name|chunk
parameter_list|,
name|long
index|[]
name|src
parameter_list|)
throws|throws
name|Exception
block|{
name|verifyValues
argument_list|(
name|chunk
argument_list|,
name|src
argument_list|,
name|src
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|verifyValues
parameter_list|(
name|Chunk
name|chunk
parameter_list|,
name|Object
name|src
parameter_list|,
name|int
name|srcLength
parameter_list|)
throws|throws
name|Exception
block|{
name|boolean
name|nullable
init|=
name|src
operator|instanceof
name|Long
index|[]
decl_stmt|;
name|Long
index|[]
name|src0
init|=
name|nullable
condition|?
operator|(
name|Long
index|[]
operator|)
name|src
else|:
literal|null
decl_stmt|;
name|long
index|[]
name|src1
init|=
name|nullable
condition|?
literal|null
else|:
operator|(
name|long
index|[]
operator|)
name|src
decl_stmt|;
name|int
index|[]
name|stepsToVerify
init|=
operator|new
name|int
index|[]
block|{
name|srcLength
block|,
name|srcLength
operator|/
literal|2
block|,
literal|63
block|,
literal|5
block|,
literal|1
block|}
decl_stmt|;
name|long
index|[]
name|dest
init|=
operator|new
name|long
index|[
name|srcLength
index|]
decl_stmt|;
name|boolean
index|[]
name|isNull
init|=
operator|new
name|boolean
index|[
name|srcLength
index|]
decl_stmt|;
name|int
name|lastStep
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|step
range|:
name|stepsToVerify
control|)
block|{
if|if
condition|(
name|step
operator|>
name|srcLength
operator|||
name|step
operator|==
name|lastStep
operator|||
name|step
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|srcLength
operator|/
name|step
operator|)
operator|>
literal|50
condition|)
continue|continue;
comment|// too slow
name|LOG
operator|.
name|info
argument_list|(
literal|"Verifying value count "
operator|+
name|srcLength
operator|+
literal|" w/step "
operator|+
name|step
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|dest
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|ChunkReader
name|reader
init|=
operator|new
name|ChunkReader
argument_list|(
name|Type
operator|.
name|LONG
argument_list|,
name|chunk
argument_list|)
decl_stmt|;
while|while
condition|(
name|offset
operator|<
name|srcLength
condition|)
block|{
name|int
name|adjStep
init|=
name|Math
operator|.
name|min
argument_list|(
name|srcLength
operator|-
name|offset
argument_list|,
name|step
argument_list|)
decl_stmt|;
try|try
block|{
name|reader
operator|.
name|next
argument_list|(
name|adjStep
argument_list|)
expr_stmt|;
name|reader
operator|.
name|copyLongs
argument_list|(
name|dest
argument_list|,
name|isNull
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"srcLength "
operator|+
name|srcLength
operator|+
literal|", step "
operator|+
name|adjStep
operator|+
literal|"/"
operator|+
name|step
operator|+
literal|" offset "
operator|+
name|offset
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|ex
throw|;
block|}
name|offset
operator|+=
name|adjStep
expr_stmt|;
block|}
if|if
condition|(
name|nullable
condition|)
block|{
name|verifyArrays
argument_list|(
name|src0
argument_list|,
name|dest
argument_list|,
name|isNull
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|verifyArrays
argument_list|(
name|src1
argument_list|,
name|dest
argument_list|,
name|isNull
argument_list|)
expr_stmt|;
block|}
name|lastStep
operator|=
name|step
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|verifyArrays
parameter_list|(
name|Long
index|[]
name|src
parameter_list|,
name|long
index|[]
name|dest
parameter_list|,
name|boolean
index|[]
name|isNull
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|src
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|boolean
name|curIsNull
init|=
operator|(
name|src
index|[
name|i
index|]
operator|==
literal|null
operator|)
decl_stmt|;
name|assertTrue
argument_list|(
name|i
operator|+
literal|": "
operator|+
name|src
index|[
name|i
index|]
operator|+
literal|" got "
operator|+
name|dest
index|[
name|i
index|]
operator|+
literal|"/"
operator|+
name|isNull
index|[
name|i
index|]
argument_list|,
name|curIsNull
operator|==
name|isNull
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|curIsNull
condition|)
block|{
name|assertEquals
argument_list|(
name|i
operator|+
literal|": "
operator|+
name|src
index|[
name|i
index|]
operator|+
literal|" got "
operator|+
name|dest
index|[
name|i
index|]
argument_list|,
name|src
index|[
name|i
index|]
operator|.
name|longValue
argument_list|()
argument_list|,
name|dest
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
name|void
name|verifyArrays
parameter_list|(
name|long
index|[]
name|src
parameter_list|,
name|long
index|[]
name|dest
parameter_list|,
name|boolean
index|[]
name|isNull
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|src
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|assertEquals
argument_list|(
name|i
operator|+
literal|": "
operator|+
name|src
index|[
name|i
index|]
operator|+
literal|" got "
operator|+
name|dest
index|[
name|i
index|]
argument_list|,
name|src
index|[
name|i
index|]
argument_list|,
name|dest
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|i
operator|+
literal|": unexpected null"
argument_list|,
name|isNull
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|Chunk
name|completeChunk
parameter_list|(
name|ChunkWriterImpl
name|writer
parameter_list|,
name|BufferInProgress
name|buf
parameter_list|)
block|{
name|int
name|rows
init|=
name|buf
operator|.
name|getChunkInProgressRows
argument_list|()
decl_stmt|;
name|Chunk
name|c
init|=
name|buf
operator|.
name|extractChunk
argument_list|()
decl_stmt|;
name|writer
operator|.
name|finishChunk
argument_list|(
name|c
argument_list|,
name|rows
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
specifier|private
specifier|static
name|WeakBuffer
name|createBuffer
parameter_list|(
name|int
name|bufferSize
parameter_list|)
block|{
name|HiveConf
name|hc
init|=
operator|new
name|HiveConf
argument_list|()
decl_stmt|;
name|hc
operator|.
name|setInt
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|LLAP_BUFFER_SIZE
operator|.
name|varname
argument_list|,
name|bufferSize
argument_list|)
expr_stmt|;
name|BufferPool
name|bp
init|=
operator|new
name|BufferPool
argument_list|(
name|hc
argument_list|,
literal|null
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|bp
operator|.
name|allocateBuffer
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

