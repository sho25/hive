begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|chunk
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|DoubleBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|LongBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|Decimal128
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|DebugUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|api
operator|.
name|Llap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|api
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|api
operator|.
name|Vector
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|chunk
operator|.
name|ChunkUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|loader
operator|.
name|ChunkPool
operator|.
name|Chunk
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|chunk
operator|.
name|ChunkUtils
operator|.
name|RleSegmentType
import|;
end_import

begin_comment
comment|/**  * Chunk reader; reads chained chunks (we might want to separate this later).  *  * Initial chunk format:  * [version byte][int number of rows][padding to 8 bytes](segments)(if string, [dictionary])  * Version is 0 for initial format. Segment format:  * [type byte][int number of rows][padding to 8 bytes](values).  * One value is stored for repeated segments, and none for null-repeated segments. For non-repeated  * segments, values and bitmasks are interspersed; N-byte bitmask followed is by N*8 values,  * repeated. Last bitmask may be smaller if there are less values, but it's still rounded to 8  * bytes. Values for nulls are still stored (we could save space by not storing them, like ORC).  *  * Values are stored with fixed-length and are 8 bytes for long and double; 8 bytes for strings  * (dictionary offset+length); TODO bytes for decimals. Values stored for NULLs are undefined.  */
end_comment

begin_class
specifier|public
class|class
name|ChunkReader
implements|implements
name|Vector
operator|.
name|ColumnReader
block|{
specifier|private
specifier|final
name|Type
name|type
decl_stmt|;
specifier|private
name|Chunk
name|chunk
decl_stmt|;
specifier|private
name|List
argument_list|<
name|ByteBuffer
argument_list|>
name|chunkBuffers
decl_stmt|;
specifier|private
name|List
argument_list|<
name|RleSegmentType
argument_list|>
name|segmentTypes
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|segmentOffsets
decl_stmt|,
name|segmentRowCounts
decl_stmt|;
specifier|private
name|int
name|rowOffsetInFirstSegment
decl_stmt|;
specifier|private
name|int
name|remainingRowsInLastChunk
init|=
literal|0
decl_stmt|,
name|rowOffsetInNextSegment
init|=
literal|0
decl_stmt|,
name|nextSegmentOffset
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|lastRowCountNeeded
init|=
literal|0
decl_stmt|;
specifier|public
name|ChunkReader
parameter_list|(
name|Type
name|type
parameter_list|,
name|Chunk
name|chunk
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|this
operator|.
name|chunk
operator|=
name|chunk
expr_stmt|;
comment|// Verify chunk version.
name|byte
name|firstByte
init|=
name|chunk
operator|.
name|buffer
operator|.
name|getContents
argument_list|()
operator|.
name|get
argument_list|(
name|chunk
operator|.
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstByte
operator|!=
name|ChunkUtils
operator|.
name|FORMAT_VERSION
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Chunk doesn't start as expected: "
operator|+
name|firstByte
argument_list|)
throw|;
block|}
if|if
condition|(
name|Integer
operator|.
name|bitCount
argument_list|(
name|ChunkUtils
operator|.
name|BITMASK_SIZE_BYTES
argument_list|)
operator|!=
literal|1
operator|||
operator|(
name|ChunkUtils
operator|.
name|BITMASK_SIZE_BYTES
operator|<
literal|8
operator|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Must be a power of two>= 8: "
operator|+
name|ChunkUtils
operator|.
name|BITMASK_SIZE_BYTES
argument_list|)
throw|;
block|}
block|}
specifier|public
name|int
name|getNumRowsRemaining
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|chunk
operator|==
literal|null
condition|)
return|return
literal|0
return|;
name|int
name|result
init|=
name|remainingRowsInLastChunk
decl_stmt|;
name|Chunk
name|chunk
init|=
name|this
operator|.
name|chunk
decl_stmt|;
if|if
condition|(
name|remainingRowsInLastChunk
operator|>
literal|0
condition|)
block|{
name|chunk
operator|=
name|chunk
operator|.
name|nextChunk
expr_stmt|;
comment|// remainingRowsInLastChunk accounts for current one
block|}
while|while
condition|(
name|chunk
operator|!=
literal|null
condition|)
block|{
name|ByteBuffer
name|bb
init|=
name|chunk
operator|.
name|buffer
operator|.
name|getContents
argument_list|()
decl_stmt|;
name|result
operator|+=
name|bb
operator|.
name|getInt
argument_list|(
name|chunk
operator|.
name|offset
operator|+
literal|1
argument_list|)
expr_stmt|;
name|chunk
operator|=
name|chunk
operator|.
name|nextChunk
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|public
name|void
name|next
parameter_list|(
name|int
name|rowCountNeeded
parameter_list|)
block|{
name|lastRowCountNeeded
operator|=
name|rowCountNeeded
expr_stmt|;
if|if
condition|(
name|rowCountNeeded
operator|==
literal|0
condition|)
return|return;
name|ByteBuffer
name|chunkBuffer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|chunkBuffers
operator|==
literal|null
condition|)
block|{
name|init
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|remainingRowsInLastChunk
operator|>
literal|0
condition|)
block|{
name|chunkBuffer
operator|=
name|chunkBuffers
operator|.
name|get
argument_list|(
name|chunkBuffers
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|reset
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|chunk
operator|!=
literal|null
operator|&&
name|rowCountNeeded
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|chunkBuffer
operator|==
literal|null
condition|)
block|{
name|chunkBuffer
operator|=
name|createChunkBuffer
argument_list|(
name|chunk
argument_list|)
expr_stmt|;
name|remainingRowsInLastChunk
operator|=
name|chunkBuffer
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// skip header byte
name|nextSegmentOffset
operator|=
literal|8
expr_stmt|;
block|}
while|while
condition|(
name|rowCountNeeded
operator|>
literal|0
operator|&&
name|remainingRowsInLastChunk
operator|>
literal|0
condition|)
block|{
name|int
name|segmentOffset
init|=
name|nextSegmentOffset
decl_stmt|;
assert|assert
operator|(
name|segmentOffset
operator|&
literal|7
operator|)
operator|==
literal|0
assert|;
comment|// must be 8-byte aligned
name|RleSegmentType
name|segmentType
init|=
name|RleSegmentType
operator|.
name|fromInt
argument_list|(
name|chunkBuffer
operator|.
name|get
argument_list|(
name|nextSegmentOffset
argument_list|)
argument_list|)
decl_stmt|;
operator|++
name|nextSegmentOffset
expr_stmt|;
name|int
name|segmentRowCount
init|=
name|chunkBuffer
operator|.
name|getInt
argument_list|(
name|nextSegmentOffset
argument_list|)
decl_stmt|;
name|int
name|segmentRowOffset
init|=
name|rowOffsetInNextSegment
decl_stmt|;
comment|// Only non-zero for the first segment.
name|nextSegmentOffset
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Segment type "
operator|+
name|segmentType
operator|+
literal|" with "
operator|+
name|segmentRowCount
operator|+
literal|" rows (skipping "
operator|+
name|segmentRowOffset
operator|+
literal|"); at "
operator|+
name|nextSegmentOffset
operator|+
literal|"; "
operator|+
name|remainingRowsInLastChunk
operator|+
literal|" more in this chunk including this segment"
argument_list|)
expr_stmt|;
block|}
name|int
name|dataLength
init|=
name|ChunkUtils
operator|.
name|getSegmentDataSize
argument_list|(
name|type
argument_list|,
name|segmentType
argument_list|,
name|segmentRowCount
argument_list|)
decl_stmt|;
name|int
name|segmentRowCountAvail
init|=
name|segmentRowCount
operator|-
name|segmentRowOffset
decl_stmt|;
if|if
condition|(
name|segmentRowCountAvail
operator|>
name|rowCountNeeded
condition|)
block|{
comment|// We have some rows remaining in the same segment.
name|nextSegmentOffset
operator|=
name|segmentOffset
expr_stmt|;
name|rowOffsetInNextSegment
operator|=
name|segmentRowOffset
operator|+
name|rowCountNeeded
expr_stmt|;
name|segmentRowCountAvail
operator|=
name|rowCountNeeded
expr_stmt|;
block|}
else|else
block|{
name|nextSegmentOffset
operator|+=
name|dataLength
expr_stmt|;
name|rowOffsetInNextSegment
operator|=
literal|0
expr_stmt|;
block|}
name|remainingRowsInLastChunk
operator|-=
name|segmentRowCountAvail
expr_stmt|;
name|rowCountNeeded
operator|-=
name|segmentRowCountAvail
expr_stmt|;
comment|// Finally, add segment to data.
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding segment with "
operator|+
name|segmentRowCountAvail
operator|+
literal|" rows in "
operator|+
name|chunk
operator|.
name|buffer
operator|+
literal|"; segment row offset "
operator|+
name|segmentRowOffset
argument_list|)
expr_stmt|;
block|}
name|chunkBuffers
operator|.
name|add
argument_list|(
name|chunkBuffer
argument_list|)
expr_stmt|;
name|segmentTypes
operator|.
name|add
argument_list|(
name|segmentType
argument_list|)
expr_stmt|;
name|segmentOffsets
operator|.
name|add
argument_list|(
name|segmentOffset
argument_list|)
expr_stmt|;
name|segmentRowCounts
operator|.
name|add
argument_list|(
name|segmentRowCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|rowOffsetInFirstSegment
operator|==
operator|-
literal|1
condition|)
block|{
name|rowOffsetInFirstSegment
operator|=
name|segmentRowOffset
expr_stmt|;
block|}
block|}
if|if
condition|(
name|remainingRowsInLastChunk
operator|==
literal|0
condition|)
block|{
comment|// We are done with current chunk.
name|chunk
operator|=
name|chunk
operator|.
name|nextChunk
expr_stmt|;
name|nextSegmentOffset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|rowCountNeeded
operator|==
literal|0
assert|;
block|}
name|chunkBuffer
operator|=
literal|null
expr_stmt|;
block|}
assert|assert
operator|!
name|chunkBuffers
operator|.
name|isEmpty
argument_list|()
operator|:
literal|"No rows found, expected "
operator|+
name|rowCountNeeded
assert|;
block|}
specifier|private
name|void
name|init
parameter_list|()
block|{
name|chunkBuffers
operator|=
operator|new
name|ArrayList
argument_list|<
name|ByteBuffer
argument_list|>
argument_list|()
expr_stmt|;
name|segmentTypes
operator|=
operator|new
name|ArrayList
argument_list|<
name|RleSegmentType
argument_list|>
argument_list|()
expr_stmt|;
name|segmentOffsets
operator|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
name|segmentRowCounts
operator|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
name|remainingRowsInLastChunk
operator|=
literal|0
expr_stmt|;
name|rowOffsetInFirstSegment
operator|=
operator|-
literal|1
expr_stmt|;
block|}
specifier|private
name|void
name|reset
parameter_list|()
block|{
name|chunkBuffers
operator|.
name|clear
argument_list|()
expr_stmt|;
name|segmentRowCounts
operator|.
name|clear
argument_list|()
expr_stmt|;
name|segmentTypes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|segmentOffsets
operator|.
name|clear
argument_list|()
expr_stmt|;
name|rowOffsetInFirstSegment
operator|=
operator|-
literal|1
expr_stmt|;
block|}
specifier|private
name|ByteBuffer
name|createChunkBuffer
parameter_list|(
name|Chunk
name|chunk
parameter_list|)
block|{
name|ByteBuffer
name|bb
init|=
name|chunk
operator|.
name|buffer
operator|.
name|getContents
argument_list|()
decl_stmt|;
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Chunk in "
operator|+
name|chunk
operator|.
name|buffer
operator|+
literal|" at "
operator|+
name|chunk
operator|.
name|offset
operator|+
literal|", length "
operator|+
name|chunk
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|bb
operator|.
name|position
argument_list|(
name|chunk
operator|.
name|offset
argument_list|)
expr_stmt|;
name|ByteBuffer
name|chunkBuffer
init|=
name|bb
operator|.
name|slice
argument_list|()
decl_stmt|;
name|chunkBuffer
operator|.
name|limit
argument_list|(
name|chunk
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|chunkBuffer
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isSameValue
parameter_list|()
block|{
comment|// Assume repeated values wouldn't be written as separate segments
if|if
condition|(
name|segmentTypes
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
return|return
literal|false
return|;
name|RleSegmentType
name|type
init|=
name|segmentTypes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
return|return
name|type
operator|==
name|RleSegmentType
operator|.
name|REPEATING_NULL
operator|||
name|type
operator|==
name|RleSegmentType
operator|.
name|REPEATING_VALUE
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNulls
parameter_list|()
block|{
for|for
control|(
name|RleSegmentType
name|type
range|:
name|segmentTypes
control|)
block|{
if|if
condition|(
name|type
operator|==
name|RleSegmentType
operator|.
name|REPEATING_NULL
operator|||
name|type
operator|==
name|RleSegmentType
operator|.
name|UNIQUE_NULL_BITMASK
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|// TODO: Ideally we want to get rid of this and process segments as we go (nextLongs ...);
comment|//       however, this may preclude us from predicting whether there are nulls, etc.
comment|//       Plus code will be even more complex. But might be worth it.
annotation|@
name|Override
specifier|public
name|void
name|copyLongs
parameter_list|(
name|long
index|[]
name|dest
parameter_list|,
name|boolean
index|[]
name|isNull
parameter_list|,
name|int
name|destOffset
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|segmentRowOffset
init|=
name|rowOffsetInFirstSegment
decl_stmt|;
for|for
control|(
name|int
name|segmentIx
init|=
literal|0
init|;
name|segmentIx
operator|<
name|segmentTypes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|segmentIx
control|)
block|{
name|int
name|segmentRowCount
init|=
name|segmentRowCounts
operator|.
name|get
argument_list|(
name|segmentIx
argument_list|)
decl_stmt|;
name|RleSegmentType
name|segmentType
init|=
name|segmentTypes
operator|.
name|get
argument_list|(
name|segmentIx
argument_list|)
decl_stmt|;
name|ByteBuffer
name|chunkBuffer
init|=
name|chunkBuffers
operator|.
name|get
argument_list|(
name|segmentIx
argument_list|)
decl_stmt|;
name|int
name|rowCountToRead
init|=
name|Math
operator|.
name|min
argument_list|(
name|segmentRowCount
operator|-
name|segmentRowOffset
argument_list|,
name|lastRowCountNeeded
argument_list|)
decl_stmt|;
name|lastRowCountNeeded
operator|-=
name|rowCountToRead
expr_stmt|;
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Copying "
operator|+
name|rowCountToRead
operator|+
literal|" rows from segment "
operator|+
name|segmentIx
operator|+
literal|" of type "
operator|+
name|segmentType
operator|+
literal|" segment at "
operator|+
name|segmentOffsets
operator|.
name|get
argument_list|(
name|segmentIx
argument_list|)
operator|+
literal|" using row offset "
operator|+
name|segmentRowOffset
operator|+
literal|" to result offset "
operator|+
name|destOffset
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|segmentType
condition|)
block|{
case|case
name|REPEATING_NULL
case|:
block|{
assert|assert
name|isNull
operator|!=
literal|null
assert|;
name|Arrays
operator|.
name|fill
argument_list|(
name|isNull
argument_list|,
name|destOffset
argument_list|,
name|destOffset
operator|+
name|rowCountToRead
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|destOffset
operator|+=
name|rowCountToRead
expr_stmt|;
break|break;
block|}
case|case
name|REPEATING_VALUE
case|:
block|{
name|long
name|value
init|=
name|chunkBuffer
operator|.
name|getLong
argument_list|(
name|segmentOffsets
operator|.
name|get
argument_list|(
name|segmentIx
argument_list|)
operator|+
literal|8
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|dest
argument_list|,
name|destOffset
argument_list|,
name|destOffset
operator|+
name|rowCountToRead
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|isNull
operator|!=
literal|null
condition|)
block|{
name|Arrays
operator|.
name|fill
argument_list|(
name|isNull
argument_list|,
name|destOffset
argument_list|,
name|destOffset
operator|+
name|rowCountToRead
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|destOffset
operator|+=
name|rowCountToRead
expr_stmt|;
break|break;
block|}
case|case
name|UNIQUE_NOT_NULL
case|:
block|{
name|int
name|dataOffset
init|=
name|segmentOffsets
operator|.
name|get
argument_list|(
name|segmentIx
argument_list|)
operator|+
literal|8
decl_stmt|;
assert|assert
operator|(
name|dataOffset
operator|&
literal|7
operator|)
operator|==
literal|0
assert|;
comment|// Must be 8-byte aligned.
name|copyLongValues
argument_list|(
name|chunkBuffer
argument_list|,
name|dataOffset
argument_list|,
name|segmentRowOffset
argument_list|,
name|dest
argument_list|,
name|destOffset
argument_list|,
name|rowCountToRead
argument_list|)
expr_stmt|;
if|if
condition|(
name|isNull
operator|!=
literal|null
condition|)
block|{
name|Arrays
operator|.
name|fill
argument_list|(
name|isNull
argument_list|,
name|destOffset
argument_list|,
name|destOffset
operator|+
name|rowCountToRead
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|destOffset
operator|+=
name|rowCountToRead
expr_stmt|;
break|break;
block|}
case|case
name|UNIQUE_NULL_BITMASK
case|:
block|{
name|longCopier
operator|.
name|initDest
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|destOffset
operator|=
name|copyValuesWithNulls
argument_list|(
name|chunkBuffer
argument_list|,
name|segmentOffsets
operator|.
name|get
argument_list|(
name|segmentIx
argument_list|)
argument_list|,
name|segmentRowOffset
argument_list|,
name|segmentRowCount
argument_list|,
name|longCopier
argument_list|,
name|isNull
argument_list|,
name|destOffset
argument_list|,
name|rowCountToRead
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unsupported segment type "
operator|+
name|segmentType
argument_list|)
throw|;
block|}
name|segmentRowOffset
operator|=
literal|0
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|copyLongValues
parameter_list|(
name|ByteBuffer
name|chunkBuffer
parameter_list|,
name|int
name|dataOffset
parameter_list|,
name|int
name|segmentRowOffset
parameter_list|,
name|long
index|[]
name|dest
parameter_list|,
name|int
name|destOffset
parameter_list|,
name|int
name|rowCountToRead
parameter_list|)
block|{
name|LongBuffer
name|longBuffer
init|=
name|chunkBuffer
operator|.
name|asLongBuffer
argument_list|()
decl_stmt|;
name|longBuffer
operator|.
name|position
argument_list|(
operator|(
name|dataOffset
operator|>>>
literal|3
operator|)
operator|+
name|segmentRowOffset
argument_list|)
expr_stmt|;
name|longBuffer
operator|.
name|get
argument_list|(
name|dest
argument_list|,
name|destOffset
argument_list|,
name|rowCountToRead
argument_list|)
expr_stmt|;
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceDataEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Copied "
operator|+
name|rowCountToRead
operator|+
literal|" rows from long offset "
operator|+
operator|(
operator|(
name|dataOffset
operator|>>>
literal|3
operator|)
operator|+
name|segmentRowOffset
operator|)
operator|+
literal|" ("
operator|+
name|dataOffset
operator|+
literal|", "
operator|+
name|segmentRowOffset
operator|+
literal|"): "
operator|+
name|DebugUtils
operator|.
name|toString
argument_list|(
name|dest
argument_list|,
name|destOffset
argument_list|,
name|rowCountToRead
argument_list|)
argument_list|)
expr_stmt|;
name|Llap
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"VRB vector now looks like "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|copyDoubles
parameter_list|(
name|double
index|[]
name|dest
parameter_list|,
name|boolean
index|[]
name|isNull
parameter_list|,
name|int
name|destOffset
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|segmentRowOffset
init|=
name|rowOffsetInFirstSegment
decl_stmt|;
for|for
control|(
name|int
name|segmentIx
init|=
literal|0
init|;
name|segmentIx
operator|<
name|segmentTypes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|segmentIx
control|)
block|{
name|int
name|segmentRowCount
init|=
name|segmentRowCounts
operator|.
name|get
argument_list|(
name|segmentIx
argument_list|)
decl_stmt|;
name|RleSegmentType
name|segmentType
init|=
name|segmentTypes
operator|.
name|get
argument_list|(
name|segmentIx
argument_list|)
decl_stmt|;
name|ByteBuffer
name|chunkBuffer
init|=
name|chunkBuffers
operator|.
name|get
argument_list|(
name|segmentIx
argument_list|)
decl_stmt|;
name|int
name|rowCountToRead
init|=
name|Math
operator|.
name|min
argument_list|(
name|segmentRowCount
operator|-
name|segmentRowOffset
argument_list|,
name|lastRowCountNeeded
argument_list|)
decl_stmt|;
name|lastRowCountNeeded
operator|-=
name|rowCountToRead
expr_stmt|;
switch|switch
condition|(
name|segmentType
condition|)
block|{
case|case
name|REPEATING_NULL
case|:
block|{
assert|assert
name|isNull
operator|!=
literal|null
assert|;
name|Arrays
operator|.
name|fill
argument_list|(
name|isNull
argument_list|,
name|destOffset
argument_list|,
name|destOffset
operator|+
name|rowCountToRead
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|destOffset
operator|+=
name|rowCountToRead
expr_stmt|;
break|break;
block|}
case|case
name|REPEATING_VALUE
case|:
block|{
name|long
name|value
init|=
name|chunkBuffer
operator|.
name|getLong
argument_list|(
name|segmentOffsets
operator|.
name|get
argument_list|(
name|segmentIx
argument_list|)
operator|+
literal|8
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|dest
argument_list|,
name|destOffset
argument_list|,
name|destOffset
operator|+
name|rowCountToRead
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|isNull
operator|!=
literal|null
condition|)
block|{
name|Arrays
operator|.
name|fill
argument_list|(
name|isNull
argument_list|,
name|destOffset
argument_list|,
name|destOffset
operator|+
name|rowCountToRead
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|destOffset
operator|+=
name|rowCountToRead
expr_stmt|;
break|break;
block|}
case|case
name|UNIQUE_NOT_NULL
case|:
block|{
name|int
name|dataOffset
init|=
name|segmentOffsets
operator|.
name|get
argument_list|(
name|segmentIx
argument_list|)
operator|+
literal|8
decl_stmt|;
assert|assert
operator|(
name|dataOffset
operator|&
literal|7
operator|)
operator|==
literal|0
assert|;
comment|// Must be 8-byte aligned.
name|copyDoubleValues
argument_list|(
name|chunkBuffer
argument_list|,
name|dataOffset
argument_list|,
name|segmentRowOffset
argument_list|,
name|dest
argument_list|,
name|destOffset
argument_list|,
name|rowCountToRead
argument_list|)
expr_stmt|;
if|if
condition|(
name|isNull
operator|!=
literal|null
condition|)
block|{
name|Arrays
operator|.
name|fill
argument_list|(
name|isNull
argument_list|,
name|destOffset
argument_list|,
name|destOffset
operator|+
name|rowCountToRead
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|destOffset
operator|+=
name|rowCountToRead
expr_stmt|;
break|break;
block|}
case|case
name|UNIQUE_NULL_BITMASK
case|:
block|{
name|doubleCopier
operator|.
name|initDest
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|destOffset
operator|=
name|copyValuesWithNulls
argument_list|(
name|chunkBuffer
argument_list|,
name|segmentOffsets
operator|.
name|get
argument_list|(
name|segmentIx
argument_list|)
argument_list|,
name|segmentRowOffset
argument_list|,
name|segmentRowCount
argument_list|,
name|doubleCopier
argument_list|,
name|isNull
argument_list|,
name|destOffset
argument_list|,
name|rowCountToRead
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unsupported segment type "
operator|+
name|segmentType
argument_list|)
throw|;
block|}
name|segmentRowOffset
operator|=
literal|0
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|copyDoubleValues
parameter_list|(
name|ByteBuffer
name|chunkBuffer
parameter_list|,
name|int
name|dataOffset
parameter_list|,
name|int
name|segmentRowOffset
parameter_list|,
name|double
index|[]
name|dest
parameter_list|,
name|int
name|destOffset
parameter_list|,
name|int
name|rowCountToRead
parameter_list|)
block|{
name|DoubleBuffer
name|doubleBuffer
init|=
name|chunkBuffer
operator|.
name|asDoubleBuffer
argument_list|()
decl_stmt|;
name|doubleBuffer
operator|.
name|position
argument_list|(
operator|(
name|dataOffset
operator|>>>
literal|3
operator|)
operator|+
name|segmentRowOffset
argument_list|)
expr_stmt|;
name|doubleBuffer
operator|.
name|get
argument_list|(
name|dest
argument_list|,
name|destOffset
argument_list|,
name|rowCountToRead
argument_list|)
expr_stmt|;
block|}
specifier|private
name|int
name|copyValuesWithNulls
parameter_list|(
name|ByteBuffer
name|chunkBuffer
parameter_list|,
name|int
name|segmentDataOffset
parameter_list|,
name|int
name|segmentRowOffset
parameter_list|,
name|int
name|segmentRowCount
parameter_list|,
name|ValueCopier
name|valueHelper
parameter_list|,
name|boolean
index|[]
name|isNull
parameter_list|,
name|int
name|destOffset
parameter_list|,
name|int
name|rowCountToRead
parameter_list|)
block|{
if|if
condition|(
name|rowCountToRead
operator|==
literal|0
condition|)
return|return
name|destOffset
return|;
name|int
name|valueSize
init|=
name|ChunkUtils
operator|.
name|TYPE_SIZES
index|[
name|type
operator|.
name|value
argument_list|()
index|]
decl_stmt|;
comment|// Prepare to read (or skip) the first bitmask.
name|int
name|bitmasksSkipped
init|=
literal|0
decl_stmt|;
name|int
name|currentBitmaskOffset
init|=
name|segmentDataOffset
operator|+
literal|8
decl_stmt|;
name|int
name|currentBitmaskSize
init|=
name|determineBitmaskSizeBytes
argument_list|(
name|bitmasksSkipped
argument_list|,
name|segmentRowCount
argument_list|)
decl_stmt|;
comment|// Size of bitmask and corresponding values in bytes, for a BITMASK_SIZE_BYTES-sized bitmask.
name|int
name|sizeOfBitmaskAndValues
init|=
name|ChunkUtils
operator|.
name|getFullBitmaskSize
argument_list|(
name|valueSize
argument_list|)
decl_stmt|;
name|valueHelper
operator|.
name|initSrc
argument_list|(
name|chunkBuffer
argument_list|)
expr_stmt|;
comment|// For the first segment, we might have to skip some rows. This is sadly most of this method.
if|if
condition|(
name|segmentRowOffset
operator|>
literal|0
condition|)
block|{
comment|// First, see how many full bitmasks we need to skip.
name|int
name|bitmasksToSkip
init|=
operator|(
name|segmentRowOffset
operator|/
name|ChunkUtils
operator|.
name|BITMASK_SIZE_BITS
operator|)
decl_stmt|;
assert|assert
name|bitmasksToSkip
operator|==
literal|0
operator|||
name|currentBitmaskSize
operator|==
name|ChunkUtils
operator|.
name|BITMASK_SIZE_BYTES
assert|;
name|bitmasksSkipped
operator|+=
name|bitmasksToSkip
expr_stmt|;
name|currentBitmaskOffset
operator|+=
operator|(
name|bitmasksToSkip
operator|*
name|sizeOfBitmaskAndValues
operator|)
expr_stmt|;
name|currentBitmaskSize
operator|=
name|determineBitmaskSizeBytes
argument_list|(
name|bitmasksSkipped
argument_list|,
name|segmentRowCount
argument_list|)
expr_stmt|;
name|segmentRowOffset
operator|=
name|segmentRowOffset
operator|%
name|ChunkUtils
operator|.
name|BITMASK_SIZE_BITS
expr_stmt|;
comment|// Remember how many values we are skipping in the current bitmask, for value copying.
name|int
name|valuesToSkip
init|=
name|segmentRowOffset
decl_stmt|;
comment|// Then, in the bitmask we are in, skip however many full bytes we need to skip.
name|int
name|currentOffsetInBitmask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|segmentRowOffset
operator|>=
literal|8
condition|)
block|{
name|int
name|bytesToSkip
init|=
name|segmentRowOffset
operator|>>>
literal|3
decl_stmt|;
name|currentOffsetInBitmask
operator|=
name|bytesToSkip
expr_stmt|;
name|segmentRowOffset
operator|=
name|segmentRowOffset
operator|&
literal|7
expr_stmt|;
block|}
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Skipping "
operator|+
name|bitmasksToSkip
operator|+
literal|" bitmasks and "
operator|+
name|currentOffsetInBitmask
operator|+
literal|" bytes; for a bitmask at "
operator|+
name|currentBitmaskOffset
operator|+
literal|" will skip "
operator|+
name|valuesToSkip
operator|+
literal|" values and "
operator|+
name|segmentRowOffset
operator|+
literal|" bits"
argument_list|)
expr_stmt|;
block|}
comment|// Finally, we may need to skip some bits in the first byte we are reading.
comment|// Read the partial byte of the bitmask (and corresponding long values).
if|if
condition|(
name|segmentRowOffset
operator|>
literal|0
condition|)
block|{
name|int
name|partialByteRowCount
init|=
name|Math
operator|.
name|min
argument_list|(
name|rowCountToRead
argument_list|,
literal|8
operator|-
name|segmentRowOffset
argument_list|)
decl_stmt|;
name|copyBitsFromByte
argument_list|(
name|chunkBuffer
operator|.
name|get
argument_list|(
name|currentBitmaskOffset
operator|+
name|currentOffsetInBitmask
argument_list|)
argument_list|,
name|isNull
argument_list|,
name|destOffset
argument_list|,
name|segmentRowOffset
argument_list|,
name|partialByteRowCount
argument_list|)
expr_stmt|;
name|valueHelper
operator|.
name|copyValues
argument_list|(
name|destOffset
argument_list|,
name|currentBitmaskOffset
operator|+
name|currentBitmaskSize
argument_list|,
name|valuesToSkip
argument_list|,
name|partialByteRowCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceDataEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"After partial first byte w/"
operator|+
name|partialByteRowCount
operator|+
literal|", byte was "
operator|+
name|chunkBuffer
operator|.
name|get
argument_list|(
name|currentBitmaskOffset
argument_list|)
argument_list|)
expr_stmt|;
name|Llap
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"After partial first byte w/"
operator|+
name|partialByteRowCount
operator|+
literal|", booleans are "
operator|+
name|DebugUtils
operator|.
name|toString
argument_list|(
name|isNull
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rowCountToRead
operator|-=
name|partialByteRowCount
expr_stmt|;
name|destOffset
operator|+=
name|partialByteRowCount
expr_stmt|;
operator|++
name|currentOffsetInBitmask
expr_stmt|;
if|if
condition|(
name|currentOffsetInBitmask
operator|==
name|ChunkUtils
operator|.
name|BITMASK_SIZE_BYTES
operator|&&
name|rowCountToRead
operator|>
literal|0
condition|)
block|{
comment|// We only needed part of the last byte from this bitmask, go to the next one.
operator|++
name|bitmasksSkipped
expr_stmt|;
name|currentBitmaskOffset
operator|+=
name|sizeOfBitmaskAndValues
expr_stmt|;
name|currentBitmaskSize
operator|=
name|determineBitmaskSizeBytes
argument_list|(
name|bitmasksSkipped
argument_list|,
name|segmentRowCount
argument_list|)
expr_stmt|;
name|currentOffsetInBitmask
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rowCountToRead
operator|==
literal|0
condition|)
return|return
name|destOffset
return|;
comment|// Then, if we have a partial bitmask, get to the boundary.
if|if
condition|(
name|currentOffsetInBitmask
operator|>
literal|0
condition|)
block|{
comment|// First, copy the bits, then the values at the same destOffset.
for|for
control|(
name|int
name|i
init|=
name|currentOffsetInBitmask
init|,
name|tmpToRead
init|=
name|rowCountToRead
init|,
name|tmpOffset
init|=
name|destOffset
init|;
operator|(
name|i
operator|<
name|currentBitmaskSize
operator|)
operator|&&
operator|(
name|tmpToRead
operator|>
literal|0
operator|)
condition|;
operator|++
name|i
control|)
block|{
name|int
name|bitsToRead
init|=
name|Math
operator|.
name|min
argument_list|(
name|tmpToRead
argument_list|,
literal|8
argument_list|)
decl_stmt|;
name|copyBitsFromByte
argument_list|(
name|chunkBuffer
operator|.
name|get
argument_list|(
name|currentBitmaskOffset
operator|+
name|i
argument_list|)
argument_list|,
name|isNull
argument_list|,
name|tmpOffset
argument_list|,
literal|0
argument_list|,
name|bitsToRead
argument_list|)
expr_stmt|;
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceDataEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"After copying "
operator|+
name|bitsToRead
operator|+
literal|" bits from byte at "
operator|+
operator|(
name|currentBitmaskOffset
operator|+
name|i
operator|)
operator|+
literal|" to "
operator|+
name|tmpOffset
operator|+
literal|", booleans are "
operator|+
name|DebugUtils
operator|.
name|toString
argument_list|(
name|isNull
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tmpOffset
operator|+=
name|bitsToRead
expr_stmt|;
name|tmpToRead
operator|-=
name|bitsToRead
expr_stmt|;
block|}
name|valuesToSkip
operator|=
name|currentOffsetInBitmask
operator|<<
literal|3
expr_stmt|;
name|int
name|valuesToRead
init|=
name|Math
operator|.
name|min
argument_list|(
operator|(
name|currentBitmaskSize
operator|<<
literal|3
operator|)
operator|-
name|valuesToSkip
argument_list|,
name|rowCountToRead
argument_list|)
decl_stmt|;
name|valueHelper
operator|.
name|copyValues
argument_list|(
name|destOffset
argument_list|,
name|currentBitmaskOffset
operator|+
name|currentBitmaskSize
argument_list|,
name|valuesToSkip
argument_list|,
name|valuesToRead
argument_list|)
expr_stmt|;
name|destOffset
operator|+=
name|valuesToRead
expr_stmt|;
name|rowCountToRead
operator|-=
name|valuesToRead
expr_stmt|;
if|if
condition|(
name|rowCountToRead
operator|==
literal|0
condition|)
return|return
name|destOffset
return|;
comment|// Go to next bitmask.
name|currentBitmaskOffset
operator|+=
name|sizeOfBitmaskAndValues
expr_stmt|;
operator|++
name|bitmasksSkipped
expr_stmt|;
name|currentBitmaskSize
operator|=
name|determineBitmaskSizeBytes
argument_list|(
name|bitmasksSkipped
argument_list|,
name|segmentRowCount
argument_list|)
expr_stmt|;
block|}
block|}
comment|// end of the epic "segmentRowOffset> 0" if
comment|// This is the main code path
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"After segment offset, reading "
operator|+
name|rowCountToRead
operator|+
literal|" rows from data at "
operator|+
name|currentBitmaskOffset
operator|+
literal|" with "
operator|+
name|segmentRowCount
operator|+
literal|" rows to offset "
operator|+
name|destOffset
operator|+
literal|"; bitmask size "
operator|+
name|currentBitmaskSize
argument_list|)
expr_stmt|;
block|}
comment|// Now we are finally done with all the crooked offsets (if any) so we can just read the data.
while|while
condition|(
literal|true
condition|)
block|{
comment|// Read one bitmask and corresponding values.
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|tmpCountToRead
init|=
name|rowCountToRead
init|,
name|tmpOffset
init|=
name|destOffset
init|;
name|i
argument_list|<
name|currentBitmaskSize
operator|&&
name|tmpCountToRead
argument_list|>
literal|0
condition|;
operator|++
name|i
control|)
block|{
name|byte
name|b
init|=
name|chunkBuffer
operator|.
name|get
argument_list|(
name|currentBitmaskOffset
operator|+
name|i
argument_list|)
decl_stmt|;
name|int
name|bitsToRead
init|=
name|Math
operator|.
name|min
argument_list|(
name|tmpCountToRead
argument_list|,
literal|8
argument_list|)
decl_stmt|;
name|copyBitsFromByte
argument_list|(
name|b
operator|&
literal|0xff
argument_list|,
name|isNull
argument_list|,
name|tmpOffset
argument_list|,
literal|0
argument_list|,
name|bitsToRead
argument_list|)
expr_stmt|;
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceDataEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Copied "
operator|+
name|bitsToRead
operator|+
literal|" bits from "
operator|+
name|b
operator|+
literal|" ("
operator|+
name|Integer
operator|.
name|toBinaryString
argument_list|(
name|b
operator|&
literal|0xff
argument_list|)
operator|+
literal|") at "
operator|+
operator|(
name|currentBitmaskOffset
operator|+
name|i
operator|)
operator|+
literal|" to "
operator|+
name|tmpOffset
operator|+
literal|"; current state is "
operator|+
name|DebugUtils
operator|.
name|toString
argument_list|(
name|isNull
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tmpOffset
operator|+=
name|bitsToRead
expr_stmt|;
name|tmpCountToRead
operator|-=
name|bitsToRead
expr_stmt|;
block|}
name|int
name|valuesToRead
init|=
name|Math
operator|.
name|min
argument_list|(
name|currentBitmaskSize
operator|<<
literal|3
argument_list|,
name|rowCountToRead
argument_list|)
decl_stmt|;
name|int
name|valuesOffset
init|=
name|currentBitmaskOffset
operator|+
name|currentBitmaskSize
decl_stmt|;
name|valueHelper
operator|.
name|copyValues
argument_list|(
name|destOffset
argument_list|,
name|valuesOffset
argument_list|,
literal|0
argument_list|,
name|valuesToRead
argument_list|)
expr_stmt|;
name|destOffset
operator|+=
name|valuesToRead
expr_stmt|;
name|rowCountToRead
operator|-=
name|valuesToRead
expr_stmt|;
if|if
condition|(
name|rowCountToRead
operator|==
literal|0
condition|)
break|break;
operator|++
name|bitmasksSkipped
expr_stmt|;
name|currentBitmaskOffset
operator|+=
name|sizeOfBitmaskAndValues
expr_stmt|;
name|currentBitmaskSize
operator|=
name|determineBitmaskSizeBytes
argument_list|(
name|bitmasksSkipped
argument_list|,
name|segmentRowCount
argument_list|)
expr_stmt|;
block|}
return|return
name|destOffset
return|;
block|}
comment|/** Helper interface to share the parts that deal with bitmasks, esp.    * the insane offset logic, between method copying various datatypes. */
specifier|private
interface|interface
name|ValueCopier
block|{
name|void
name|initSrc
parameter_list|(
name|ByteBuffer
name|chunkBuffer
parameter_list|)
function_decl|;
name|void
name|copyValues
parameter_list|(
name|int
name|destOffset
parameter_list|,
name|int
name|valuesOffsetBytes
parameter_list|,
name|int
name|valuesToSkip
parameter_list|,
name|int
name|valuesToCopy
parameter_list|)
function_decl|;
block|}
specifier|private
specifier|static
class|class
name|LongCopier
implements|implements
name|ValueCopier
block|{
name|LongBuffer
name|dataBuffer
init|=
literal|null
decl_stmt|;
name|long
index|[]
name|dest
decl_stmt|;
specifier|public
name|void
name|initDest
parameter_list|(
name|long
index|[]
name|dest
parameter_list|)
block|{
name|this
operator|.
name|dest
operator|=
name|dest
expr_stmt|;
block|}
specifier|public
name|void
name|initSrc
parameter_list|(
name|ByteBuffer
name|chunkBuffer
parameter_list|)
block|{
name|dataBuffer
operator|=
name|chunkBuffer
operator|.
name|asLongBuffer
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|copyValues
parameter_list|(
name|int
name|destOffset
parameter_list|,
name|int
name|valuesOffsetBytes
parameter_list|,
name|int
name|valuesToSkip
parameter_list|,
name|int
name|valuesToCopy
parameter_list|)
block|{
name|dataBuffer
operator|.
name|position
argument_list|(
operator|(
name|valuesOffsetBytes
operator|>>>
literal|3
operator|)
operator|+
name|valuesToSkip
argument_list|)
expr_stmt|;
name|dataBuffer
operator|.
name|get
argument_list|(
name|dest
argument_list|,
name|destOffset
argument_list|,
name|valuesToCopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceDataEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"After copying "
operator|+
name|valuesToCopy
operator|+
literal|" from "
operator|+
name|valuesOffsetBytes
operator|+
literal|" (skip "
operator|+
name|valuesToSkip
operator|+
literal|", long offset "
operator|+
operator|(
operator|(
name|valuesOffsetBytes
operator|>>>
literal|3
operator|)
operator|+
name|valuesToSkip
operator|)
operator|+
literal|") to "
operator|+
name|destOffset
operator|+
literal|", values are "
operator|+
name|DebugUtils
operator|.
name|toString
argument_list|(
name|dest
argument_list|,
name|destOffset
argument_list|,
name|valuesToCopy
argument_list|)
operator|+
literal|" and dest is "
operator|+
name|DebugUtils
operator|.
name|toString
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|dest
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
class|class
name|DoubleCopier
implements|implements
name|ValueCopier
block|{
name|DoubleBuffer
name|dataBuffer
init|=
literal|null
decl_stmt|;
name|double
index|[]
name|dest
decl_stmt|;
specifier|public
name|void
name|initDest
parameter_list|(
name|double
index|[]
name|dest
parameter_list|)
block|{
name|this
operator|.
name|dest
operator|=
name|dest
expr_stmt|;
block|}
specifier|public
name|void
name|initSrc
parameter_list|(
name|ByteBuffer
name|chunkBuffer
parameter_list|)
block|{
name|dataBuffer
operator|=
name|chunkBuffer
operator|.
name|asDoubleBuffer
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|copyValues
parameter_list|(
name|int
name|destOffset
parameter_list|,
name|int
name|valuesOffsetBytes
parameter_list|,
name|int
name|valuesToSkip
parameter_list|,
name|int
name|valuesToCopy
parameter_list|)
block|{
name|valuesOffsetBytes
operator|+=
operator|(
name|valuesToSkip
operator|<<
literal|3
operator|)
expr_stmt|;
name|dataBuffer
operator|.
name|position
argument_list|(
name|valuesOffsetBytes
operator|>>>
literal|3
argument_list|)
expr_stmt|;
name|dataBuffer
operator|.
name|get
argument_list|(
name|dest
argument_list|,
name|destOffset
argument_list|,
name|valuesToCopy
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|LongCopier
name|longCopier
init|=
operator|new
name|LongCopier
argument_list|()
decl_stmt|;
specifier|private
name|DoubleCopier
name|doubleCopier
init|=
operator|new
name|DoubleCopier
argument_list|()
decl_stmt|;
specifier|private
name|int
name|determineBitmaskSizeBytes
parameter_list|(
name|int
name|skipped
parameter_list|,
name|int
name|segmentRowCount
parameter_list|)
block|{
name|int
name|adjustedRowCount
init|=
name|segmentRowCount
operator|-
name|ChunkUtils
operator|.
name|BITMASK_SIZE_BITS
operator|*
name|skipped
decl_stmt|;
if|if
condition|(
name|adjustedRowCount
operator|>=
name|ChunkUtils
operator|.
name|BITMASK_SIZE_BITS
condition|)
return|return
name|ChunkUtils
operator|.
name|BITMASK_SIZE_BYTES
return|;
return|return
name|ChunkUtils
operator|.
name|align8
argument_list|(
operator|(
name|adjustedRowCount
operator|>>>
literal|3
operator|)
operator|+
operator|(
operator|(
operator|(
name|adjustedRowCount
operator|&
literal|7
operator|)
operator|!=
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getLong
parameter_list|()
block|{
return|return
name|chunkBuffers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getLong
argument_list|(
name|segmentOffsets
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|+
literal|8
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|double
name|getDouble
parameter_list|()
block|{
return|return
name|chunkBuffers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getDouble
argument_list|(
name|segmentOffsets
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|+
literal|8
argument_list|)
return|;
block|}
specifier|private
name|void
name|copyBitsFromByte
parameter_list|(
name|int
name|b
parameter_list|,
name|boolean
index|[]
name|dest
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|skipBits
parameter_list|,
name|int
name|bitCount
parameter_list|)
block|{
comment|// TODO: we could unroll the loop for full-byte copy.
name|int
name|shift
init|=
literal|7
operator|-
name|skipBits
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bitCount
condition|;
operator|++
name|i
operator|,
operator|--
name|shift
control|)
block|{
name|dest
index|[
name|offset
operator|++
index|]
operator|=
operator|(
name|b
operator|&
operator|(
literal|1
operator|<<
name|shift
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
block|}
block|}
comment|// TODO: add support for Decimal and Binary
annotation|@
name|Override
specifier|public
name|Decimal128
name|getDecimal
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Decimal not currently supported"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|copyDecimals
parameter_list|(
name|Decimal128
index|[]
name|dest
parameter_list|,
name|boolean
index|[]
name|isNull
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Decimal not currently supported"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getBytes
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Binary not currently supported"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|copyBytes
parameter_list|(
name|byte
index|[]
index|[]
name|dest
parameter_list|,
name|int
index|[]
name|destStarts
parameter_list|,
name|int
index|[]
name|destLengths
parameter_list|,
name|boolean
index|[]
name|isNull
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Binary not currently supported"
argument_list|)
throw|;
block|}
block|}
end_class

end_unit

