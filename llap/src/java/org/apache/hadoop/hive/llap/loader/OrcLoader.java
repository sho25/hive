begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|loader
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentLinkedQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|DebugUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|api
operator|.
name|Llap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|api
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|api
operator|.
name|impl
operator|.
name|RequestImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|api
operator|.
name|impl
operator|.
name|VectorImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|cache
operator|.
name|BufferPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|cache
operator|.
name|BufferPool
operator|.
name|WeakBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|cache
operator|.
name|MetadataCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|chunk
operator|.
name|ChunkWriterImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|loader
operator|.
name|ChunkPool
operator|.
name|Chunk
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|processor
operator|.
name|ChunkConsumer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|orc
operator|.
name|OrcFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|orc
operator|.
name|OrcInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|orc
operator|.
name|OrcProto
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|orc
operator|.
name|OrcProto
operator|.
name|Type
operator|.
name|Kind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|orc
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|orc
operator|.
name|RecordReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|orc
operator|.
name|StripeInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|FileSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|InputSplit
import|;
end_import

begin_class
specifier|public
class|class
name|OrcLoader
extends|extends
name|Loader
block|{
specifier|private
specifier|final
name|ChunkPool
argument_list|<
name|ChunkKey
argument_list|>
name|chunkPool
decl_stmt|;
specifier|private
name|FileSystem
name|cachedFs
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|MetadataCache
name|metadataCache
init|=
operator|new
name|MetadataCache
argument_list|()
decl_stmt|;
specifier|public
name|OrcLoader
parameter_list|(
name|BufferPool
name|bufferPool
parameter_list|,
name|ChunkPool
argument_list|<
name|ChunkKey
argument_list|>
name|chunkPool
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|bufferPool
argument_list|)
expr_stmt|;
name|this
operator|.
name|chunkPool
operator|=
name|chunkPool
expr_stmt|;
comment|// We assume all splits will come from the same FS.
name|this
operator|.
name|cachedFs
operator|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|loadInternal
parameter_list|(
name|RequestImpl
name|request
parameter_list|,
name|ChunkConsumer
name|consumer
parameter_list|,
name|LoadContext
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// TODO: decide on - LocalActorSystem.INSTANCE.enqueue(request, bufferPool, consumer);
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceMttEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"loadInternal called"
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|includedCols
init|=
name|request
operator|.
name|getColumns
argument_list|()
decl_stmt|;
if|if
condition|(
name|includedCols
operator|!=
literal|null
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|includedCols
argument_list|)
expr_stmt|;
block|}
name|FileSplit
name|fileSplit
init|=
operator|(
name|FileSplit
operator|)
name|request
operator|.
name|getSplit
argument_list|()
decl_stmt|;
name|String
name|internedFilePath
init|=
name|fileSplit
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|intern
argument_list|()
decl_stmt|;
name|Llap
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing split for "
operator|+
name|internedFilePath
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|.
name|isStopped
condition|)
return|return;
name|List
argument_list|<
name|StripeInformation
argument_list|>
name|stripes
init|=
name|metadataCache
operator|.
name|getStripes
argument_list|(
name|internedFilePath
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Type
argument_list|>
name|types
init|=
name|metadataCache
operator|.
name|getTypes
argument_list|(
name|internedFilePath
argument_list|)
decl_stmt|;
name|Reader
name|reader
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|stripes
operator|==
literal|null
operator|||
name|types
operator|==
literal|null
condition|)
block|{
name|reader
operator|=
name|createReader
argument_list|(
name|fileSplit
argument_list|)
expr_stmt|;
if|if
condition|(
name|stripes
operator|==
literal|null
condition|)
block|{
name|stripes
operator|=
name|reader
operator|.
name|getStripes
argument_list|()
expr_stmt|;
name|metadataCache
operator|.
name|cacheStripes
argument_list|(
name|internedFilePath
argument_list|,
name|stripes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|types
operator|==
literal|null
condition|)
block|{
name|types
operator|=
name|reader
operator|.
name|getTypes
argument_list|()
expr_stmt|;
name|metadataCache
operator|.
name|cacheTypes
argument_list|(
name|internedFilePath
argument_list|,
name|types
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Determine which stripes belong to this split and make keys to get chunks from cache.
comment|// This assumes all splits will have the same columns.
if|if
condition|(
name|includedCols
operator|==
literal|null
condition|)
block|{
name|includedCols
operator|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|types
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|types
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|includedCols
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|List
argument_list|<
name|ChunkKey
argument_list|>
argument_list|>
name|keys
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|ChunkKey
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|long
name|stripeIxFromAndTo
init|=
name|determineStripesAndCacheKeys
argument_list|(
name|fileSplit
argument_list|,
name|includedCols
argument_list|,
name|internedFilePath
argument_list|,
name|stripes
argument_list|,
name|keys
argument_list|)
decl_stmt|;
name|int
name|stripeIxFrom
init|=
call|(
name|int
call|)
argument_list|(
name|stripeIxFromAndTo
operator|>>>
literal|32
argument_list|)
decl_stmt|,
name|stripeIxTo
init|=
call|(
name|int
call|)
argument_list|(
name|stripeIxFromAndTo
operator|&
operator|(
name|long
operator|)
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
comment|// Prepare structures for tracking the results.
name|int
name|resultVectorCount
init|=
name|stripeIxTo
operator|-
name|stripeIxFrom
decl_stmt|;
name|Chunk
index|[]
index|[]
name|resultMatrix
init|=
operator|new
name|Chunk
index|[
name|resultVectorCount
index|]
index|[]
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// TODO: we store result buffers uniquely in a set, so we could lock/unlock them once. This may
comment|//       be more expensive than just making locking faster, and locking-unlocking as needed.
name|HashSet
argument_list|<
name|WeakBuffer
argument_list|>
index|[]
name|resultBuffers
init|=
operator|new
name|HashSet
index|[
name|resultVectorCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|resultVectorCount
condition|;
operator|++
name|i
control|)
block|{
name|resultMatrix
index|[
name|i
index|]
operator|=
operator|new
name|Chunk
index|[
name|types
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|resultBuffers
index|[
name|i
index|]
operator|=
operator|new
name|HashSet
argument_list|<
name|WeakBuffer
argument_list|>
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|context
operator|.
name|isStopped
condition|)
return|return;
comment|// TODO: after this moment, we must be careful when checking isStopped to avoid
comment|//       leaving some chunks locked and un-consumed. For now we just never check.
comment|// For now we will fetch missing results by stripe - this is how reader needs them.
name|List
argument_list|<
name|Integer
argument_list|>
name|readyStripes
init|=
name|getChunksFromCache
argument_list|(
name|keys
argument_list|,
name|types
operator|.
name|size
argument_list|()
argument_list|,
name|stripeIxFrom
argument_list|,
name|resultBuffers
argument_list|,
name|resultMatrix
argument_list|)
decl_stmt|;
if|if
condition|(
name|readyStripes
operator|!=
literal|null
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Got "
operator|+
name|readyStripes
operator|.
name|size
argument_list|()
operator|+
literal|" full stripes from cache"
argument_list|)
expr_stmt|;
for|for
control|(
name|Integer
name|stripeIx
range|:
name|readyStripes
control|)
block|{
name|int
name|stripeIxMod
init|=
name|stripeIx
operator|-
name|stripeIxFrom
decl_stmt|;
name|VectorImpl
name|vector
init|=
name|createVectorForStripe
argument_list|(
name|resultMatrix
index|[
name|stripeIxMod
index|]
argument_list|,
name|resultBuffers
index|[
name|stripeIxMod
index|]
argument_list|,
name|types
argument_list|,
name|includedCols
argument_list|)
decl_stmt|;
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceMttEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Returning stripe "
operator|+
name|stripeIx
operator|+
literal|" from cache"
argument_list|)
expr_stmt|;
block|}
name|consumer
operator|.
name|consumeVector
argument_list|(
name|vector
argument_list|)
expr_stmt|;
name|resultMatrix
index|[
name|stripeIxMod
index|]
operator|=
literal|null
expr_stmt|;
name|resultBuffers
index|[
name|stripeIxMod
index|]
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// Now we have a set of keys for all the things that are missing. Fetch them...
comment|// TODO: this should happen on some sort of IO thread pool.
for|for
control|(
name|List
argument_list|<
name|ChunkKey
argument_list|>
name|stripeKeys
range|:
name|keys
control|)
block|{
if|if
condition|(
name|stripeKeys
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|int
name|stripeIx
init|=
name|stripeKeys
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|stripeIx
decl_stmt|;
name|StripeInformation
name|si
init|=
name|stripes
operator|.
name|get
argument_list|(
name|stripeIx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|includeList
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|includedCols
operator|.
name|size
argument_list|()
operator|==
name|stripeKeys
operator|.
name|size
argument_list|()
condition|)
block|{
name|includeList
operator|=
name|includedCols
expr_stmt|;
block|}
else|else
block|{
name|includeList
operator|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|stripeKeys
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|ChunkKey
name|key
range|:
name|stripeKeys
control|)
block|{
name|includeList
operator|.
name|add
argument_list|(
name|key
operator|.
name|colIx
argument_list|)
expr_stmt|;
block|}
block|}
name|boolean
index|[]
name|includes
init|=
name|OrcInputFormat
operator|.
name|genIncludedColumns
argument_list|(
name|types
argument_list|,
name|includeList
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|Llap
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reading stripe "
operator|+
name|stripeIx
operator|+
literal|" {"
operator|+
name|si
operator|.
name|getOffset
argument_list|()
operator|+
literal|", "
operator|+
name|si
operator|.
name|getLength
argument_list|()
operator|+
literal|"}, cols "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|includes
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reader
operator|==
literal|null
condition|)
block|{
name|reader
operator|=
name|createReader
argument_list|(
name|fileSplit
argument_list|)
expr_stmt|;
block|}
name|RecordReader
name|stripeReader
init|=
name|reader
operator|.
name|rows
argument_list|(
name|si
operator|.
name|getOffset
argument_list|()
argument_list|,
name|si
operator|.
name|getLength
argument_list|()
argument_list|,
name|includes
argument_list|)
decl_stmt|;
name|int
name|stripeIxMod
init|=
name|stripeIx
operator|-
name|stripeIxFrom
decl_stmt|;
name|Chunk
index|[]
name|result
init|=
name|resultMatrix
index|[
name|stripeIxMod
index|]
decl_stmt|;
name|HashSet
argument_list|<
name|WeakBuffer
argument_list|>
name|buffers
init|=
name|resultBuffers
index|[
name|stripeIxMod
index|]
decl_stmt|;
name|loadStripe
argument_list|(
name|stripeReader
argument_list|,
name|stripeKeys
argument_list|,
name|result
argument_list|,
name|buffers
argument_list|)
expr_stmt|;
name|stripeReader
operator|.
name|close
argument_list|()
expr_stmt|;
name|VectorImpl
name|vector
init|=
name|createVectorForStripe
argument_list|(
name|result
argument_list|,
name|buffers
argument_list|,
name|types
argument_list|,
name|includedCols
argument_list|)
decl_stmt|;
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceMttEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Returning stripe "
operator|+
name|stripeIx
operator|+
literal|" from FS"
argument_list|)
expr_stmt|;
block|}
name|consumer
operator|.
name|consumeVector
argument_list|(
name|vector
argument_list|)
expr_stmt|;
block|}
name|consumer
operator|.
name|setDone
argument_list|()
expr_stmt|;
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceMttEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"loadInternal is done"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Determines which stripe range belongs to a split, and generates cache keys    *  for all these stripes and all the included columns.    * @param fileSplit The split.    * @param includedCols Included columns.    * @param internedFilePath Interned file path from the split, for cache keys.    * @param stripes Stripe information from the reader.    * @param keys The keys for cache lookups are inserted here.    * @return Combined int-s for stripe from (inc.) and to (exc.) indexes, because Java is a joke    */
specifier|private
name|long
name|determineStripesAndCacheKeys
parameter_list|(
name|FileSplit
name|fileSplit
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|includedCols
parameter_list|,
name|String
name|internedFilePath
parameter_list|,
name|List
argument_list|<
name|StripeInformation
argument_list|>
name|stripes
parameter_list|,
name|List
argument_list|<
name|List
argument_list|<
name|ChunkKey
argument_list|>
argument_list|>
name|keys
parameter_list|)
block|{
comment|// The unit of caching for ORC is (stripe x column) (see ChunkKey). Note that we do not use
comment|// SARG anywhere, because file-level filtering on sarg is already performed during split
comment|// generation, and stripe-level filtering to get row groups is not very helpful right now.
name|long
name|offset
init|=
name|fileSplit
operator|.
name|getStart
argument_list|()
decl_stmt|,
name|maxOffset
init|=
name|offset
operator|+
name|fileSplit
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|int
name|stripeIxFrom
init|=
operator|-
literal|1
decl_stmt|,
name|stripeIxTo
init|=
operator|-
literal|1
decl_stmt|,
name|stripeIx
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|Llap
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|String
name|tmp
init|=
literal|"FileSplit {"
operator|+
name|fileSplit
operator|.
name|getStart
argument_list|()
operator|+
literal|", "
operator|+
name|fileSplit
operator|.
name|getLength
argument_list|()
operator|+
literal|"}; stripes "
decl_stmt|;
for|for
control|(
name|StripeInformation
name|stripe
range|:
name|stripes
control|)
block|{
name|tmp
operator|+=
literal|"{"
operator|+
name|stripe
operator|.
name|getOffset
argument_list|()
operator|+
literal|", "
operator|+
name|stripe
operator|.
name|getLength
argument_list|()
operator|+
literal|"}, "
expr_stmt|;
block|}
name|Llap
operator|.
name|LOG
operator|.
name|debug
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|StripeInformation
name|stripe
range|:
name|stripes
control|)
block|{
name|long
name|stripeStart
init|=
name|stripe
operator|.
name|getOffset
argument_list|()
decl_stmt|;
if|if
condition|(
name|offset
operator|>
name|stripeStart
condition|)
continue|continue;
if|if
condition|(
name|stripeIxFrom
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Including from "
operator|+
name|stripeIx
operator|+
literal|" ("
operator|+
name|stripeStart
operator|+
literal|">= "
operator|+
name|offset
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
name|stripeIxFrom
operator|=
name|stripeIx
expr_stmt|;
block|}
if|if
condition|(
name|stripeStart
operator|>=
name|maxOffset
condition|)
block|{
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Including until "
operator|+
name|stripeIxTo
operator|+
literal|" ("
operator|+
name|stripeStart
operator|+
literal|">= "
operator|+
name|maxOffset
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
name|stripeIxTo
operator|=
name|stripeIx
expr_stmt|;
break|break;
block|}
name|ArrayList
argument_list|<
name|ChunkKey
argument_list|>
name|stripeKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ChunkKey
argument_list|>
argument_list|(
name|includedCols
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|keys
operator|.
name|add
argument_list|(
name|stripeKeys
argument_list|)
expr_stmt|;
for|for
control|(
name|Integer
name|colIx
range|:
name|includedCols
control|)
block|{
name|stripeKeys
operator|.
name|add
argument_list|(
operator|new
name|ChunkKey
argument_list|(
name|internedFilePath
argument_list|,
name|stripeIx
argument_list|,
name|colIx
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|++
name|stripeIx
expr_stmt|;
block|}
if|if
condition|(
name|stripeIxTo
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Including until "
operator|+
name|stripeIx
operator|+
literal|" (end of file)"
argument_list|)
expr_stmt|;
block|}
name|stripeIxTo
operator|=
name|stripeIx
expr_stmt|;
block|}
return|return
operator|(
operator|(
operator|(
name|long
operator|)
name|stripeIxFrom
operator|)
operator|<<
literal|32
operator|)
operator|+
name|stripeIxTo
return|;
block|}
comment|/**    * Gets chunks from cache and generates include arrays for things to be fetched.    * @param keys Keys to get.    * @param colCount Column count in the file.    * @param stripeIxFrom Stripe index start in the split.    * @param resultBuffers Resulting buffers are added here.    * @param resultMatrix Results that are fetched from cache are added here.    * @return Matrix of things are not cache.    */
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|getChunksFromCache
parameter_list|(
name|List
argument_list|<
name|List
argument_list|<
name|ChunkKey
argument_list|>
argument_list|>
name|keys
parameter_list|,
name|int
name|colCount
parameter_list|,
name|int
name|stripeIxFrom
parameter_list|,
name|HashSet
argument_list|<
name|WeakBuffer
argument_list|>
index|[]
name|resultBuffers
parameter_list|,
name|Chunk
index|[]
index|[]
name|resultMatrix
parameter_list|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|readyStripes
init|=
literal|null
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|ChunkKey
argument_list|>
name|stripeKeys
range|:
name|keys
control|)
block|{
name|int
name|stripeIx
init|=
name|stripeKeys
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|stripeIx
decl_stmt|;
name|int
name|stripeIxMod
init|=
name|stripeIx
operator|-
name|stripeIxFrom
decl_stmt|;
name|Chunk
index|[]
name|chunksForStripe
init|=
name|resultMatrix
index|[
name|stripeIxMod
index|]
decl_stmt|;
name|HashSet
argument_list|<
name|WeakBuffer
argument_list|>
name|buffersForStripe
init|=
name|resultBuffers
index|[
name|stripeIxMod
index|]
decl_stmt|;
name|Iterator
argument_list|<
name|ChunkKey
argument_list|>
name|iter
init|=
name|stripeKeys
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|ChunkKey
name|key
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|Chunk
name|result
init|=
name|chunkPool
operator|.
name|getChunk
argument_list|(
name|key
argument_list|,
name|buffersForStripe
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
name|Llap
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found result in cache for "
operator|+
name|key
operator|+
literal|": "
operator|+
name|result
operator|.
name|toFullString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|chunksForStripe
index|[
name|key
operator|.
name|colIx
index|]
operator|=
name|result
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|stripeKeys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|readyStripes
operator|==
literal|null
condition|)
block|{
name|readyStripes
operator|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|readyStripes
operator|.
name|add
argument_list|(
name|stripeIx
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|readyStripes
return|;
block|}
specifier|private
name|Reader
name|createReader
parameter_list|(
name|FileSplit
name|fileSplit
parameter_list|)
throws|throws
name|IOException
block|{
name|FileSystem
name|fs
init|=
name|cachedFs
decl_stmt|;
name|Path
name|path
init|=
name|fileSplit
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
if|if
condition|(
literal|"pfile"
operator|.
name|equals
argument_list|(
name|path
operator|.
name|toUri
argument_list|()
operator|.
name|getScheme
argument_list|()
argument_list|)
condition|)
block|{
name|fs
operator|=
name|path
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// Cannot use cached FS due to hive tests' proxy FS.
block|}
return|return
name|OrcFile
operator|.
name|createReader
argument_list|(
name|path
argument_list|,
name|OrcFile
operator|.
name|readerOptions
argument_list|(
name|conf
argument_list|)
operator|.
name|filesystem
argument_list|(
name|fs
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|void
name|loadStripe
parameter_list|(
name|RecordReader
name|reader
parameter_list|,
name|List
argument_list|<
name|ChunkKey
argument_list|>
name|keys
parameter_list|,
name|Chunk
index|[]
name|results
parameter_list|,
name|HashSet
argument_list|<
name|WeakBuffer
argument_list|>
name|resultBuffers
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// Reader is reading a single stripe; read the entirety of each column.
name|Object
name|readCtx
init|=
name|reader
operator|.
name|prepareColumnRead
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|keyIx
init|=
literal|0
init|;
name|keyIx
operator|<
name|keys
operator|.
name|size
argument_list|()
condition|;
operator|++
name|keyIx
control|)
block|{
name|ChunkKey
name|key
init|=
name|keys
operator|.
name|get
argument_list|(
name|keyIx
argument_list|)
decl_stmt|;
name|BufferInProgress
name|colBuffer
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|colBuffer
operator|=
name|prepareReusableBuffer
argument_list|(
name|resultBuffers
argument_list|)
expr_stmt|;
name|writer
operator|.
name|prepare
argument_list|(
name|colBuffer
argument_list|)
expr_stmt|;
name|boolean
name|hasMoreValues
init|=
name|reader
operator|.
name|readNextColumnStripe
argument_list|(
name|readCtx
argument_list|,
name|writer
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|hasMoreValues
condition|)
break|break;
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Stripe doesn't fit into buffer"
argument_list|)
expr_stmt|;
block|}
comment|// We couldn't write all rows to this buffer, so we'll close the chunk.
name|results
index|[
name|key
operator|.
name|colIx
index|]
operator|=
name|mergeResultChunks
argument_list|(
name|colBuffer
argument_list|,
name|results
index|[
name|key
operator|.
name|colIx
index|]
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Done with the reader:
comment|// 1) add final chunk to result;
comment|// 2) add reusable buffer back to list;
comment|// 3) add results to cache and resolve conflicts.
name|Chunk
name|val
init|=
name|results
index|[
name|key
operator|.
name|colIx
index|]
operator|=
name|mergeResultChunks
argument_list|(
name|colBuffer
argument_list|,
name|results
index|[
name|key
operator|.
name|colIx
index|]
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|Llap
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Caching chunk "
operator|+
name|key
operator|+
literal|" => "
operator|+
name|val
operator|.
name|toFullString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Chunk
name|cachedVal
init|=
name|chunkPool
operator|.
name|addOrGetChunk
argument_list|(
name|key
argument_list|,
name|val
argument_list|,
name|resultBuffers
argument_list|)
decl_stmt|;
if|if
condition|(
name|cachedVal
operator|!=
name|val
condition|)
block|{
comment|// Someone else has read and cached the same value while we were reading. Assumed to be
comment|// very rare (otherwise we'd need measures to prevent it), so we will not be efficient;
comment|// we will rebuild resultBuffers rather than removing buffers from them.
name|results
index|[
name|key
operator|.
name|colIx
index|]
operator|=
name|cachedVal
expr_stmt|;
name|resultBuffers
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|results
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|Chunk
name|chunk1
init|=
name|results
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|chunk1
operator|!=
literal|null
condition|)
block|{
name|resultBuffers
operator|.
name|add
argument_list|(
name|chunk1
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|chunk1
operator|=
name|chunk1
operator|.
name|nextChunk
expr_stmt|;
block|}
block|}
name|Chunk
name|chunk
init|=
name|cachedVal
decl_stmt|;
while|while
condition|(
name|chunk
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|resultBuffers
operator|.
name|contains
argument_list|(
name|chunk
operator|.
name|buffer
argument_list|)
condition|)
block|{
name|chunk
operator|.
name|buffer
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|chunk
operator|=
name|chunk
operator|.
name|nextChunk
expr_stmt|;
block|}
block|}
name|returnReusableBuffer
argument_list|(
name|colBuffer
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|VectorImpl
name|createVectorForStripe
parameter_list|(
name|Chunk
index|[]
name|rowForStripe
parameter_list|,
name|Collection
argument_list|<
name|WeakBuffer
argument_list|>
name|resultBuffers
parameter_list|,
name|List
argument_list|<
name|Type
argument_list|>
name|types
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|includedCols
parameter_list|)
block|{
name|VectorImpl
name|vector
init|=
operator|new
name|VectorImpl
argument_list|(
name|resultBuffers
argument_list|,
name|types
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Integer
name|colIx
range|:
name|includedCols
control|)
block|{
comment|// TODO: this "+ 1" is a hack relying on knowledge of ORC. It might change, esp. w/ACID.
name|Vector
operator|.
name|Type
name|type
init|=
name|vectorTypeFromOrcType
argument_list|(
name|types
operator|.
name|get
argument_list|(
name|colIx
operator|+
literal|1
argument_list|)
operator|.
name|getKind
argument_list|()
argument_list|)
decl_stmt|;
name|vector
operator|.
name|addChunk
argument_list|(
name|colIx
argument_list|,
name|rowForStripe
index|[
name|colIx
index|]
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|vector
return|;
block|}
specifier|private
specifier|static
name|Vector
operator|.
name|Type
name|vectorTypeFromOrcType
parameter_list|(
name|Kind
name|orcType
parameter_list|)
block|{
switch|switch
condition|(
name|orcType
condition|)
block|{
case|case
name|BOOLEAN
case|:
case|case
name|BYTE
case|:
case|case
name|SHORT
case|:
case|case
name|INT
case|:
case|case
name|LONG
case|:
case|case
name|DATE
case|:
case|case
name|TIMESTAMP
case|:
return|return
name|Vector
operator|.
name|Type
operator|.
name|LONG
return|;
case|case
name|FLOAT
case|:
case|case
name|DOUBLE
case|:
return|return
name|Vector
operator|.
name|Type
operator|.
name|DOUBLE
return|;
case|case
name|STRING
case|:
return|return
name|Vector
operator|.
name|Type
operator|.
name|BINARY
return|;
case|case
name|DECIMAL
case|:
return|return
name|Vector
operator|.
name|Type
operator|.
name|DECIMAL
return|;
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Unsupported type "
operator|+
name|orcType
argument_list|)
throw|;
block|}
block|}
specifier|public
specifier|static
class|class
name|ChunkKey
block|{
comment|/** @param file This MUST be interned by caller. */
specifier|private
name|ChunkKey
parameter_list|(
name|String
name|file
parameter_list|,
name|int
name|stripeIx
parameter_list|,
name|int
name|colIx
parameter_list|)
block|{
name|this
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|this
operator|.
name|stripeIx
operator|=
name|stripeIx
expr_stmt|;
name|this
operator|.
name|colIx
operator|=
name|colIx
expr_stmt|;
block|}
specifier|private
specifier|final
name|String
name|file
decl_stmt|;
specifier|private
specifier|final
name|int
name|stripeIx
decl_stmt|;
specifier|private
specifier|final
name|int
name|colIx
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"["
operator|+
name|file
operator|+
literal|", stripe "
operator|+
name|stripeIx
operator|+
literal|", colIx "
operator|+
name|colIx
operator|+
literal|"]"
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
specifier|final
name|int
name|prime
init|=
literal|31
decl_stmt|;
name|int
name|result
init|=
name|prime
operator|+
operator|(
operator|(
name|file
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|System
operator|.
name|identityHashCode
argument_list|(
name|file
argument_list|)
operator|)
decl_stmt|;
return|return
operator|(
name|prime
operator|*
name|result
operator|+
name|colIx
operator|)
operator|*
name|prime
operator|+
name|stripeIx
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|ChunkKey
operator|)
condition|)
return|return
literal|false
return|;
name|ChunkKey
name|other
init|=
operator|(
name|ChunkKey
operator|)
name|obj
decl_stmt|;
comment|// Strings are interned and can thus be compared like this.
return|return
name|stripeIx
operator|==
name|other
operator|.
name|stripeIx
operator|&&
name|colIx
operator|==
name|other
operator|.
name|colIx
operator|&&
name|file
operator|==
name|other
operator|.
name|file
return|;
block|}
block|}
block|}
end_class

end_unit

