begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|chunk
package|;
end_package

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|DebugUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|api
operator|.
name|Llap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|api
operator|.
name|Vector
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|chunk
operator|.
name|ChunkUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|chunk
operator|.
name|ChunkUtils
operator|.
name|RleSegmentType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|loader
operator|.
name|BufferInProgress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|loader
operator|.
name|ChunkPool
operator|.
name|Chunk
import|;
end_import

begin_comment
comment|/**  * Chunk writer. Reusable, not thread safe. See ChunkReader for format details.  */
end_comment

begin_class
specifier|public
class|class
name|ChunkWriterImpl
implements|implements
name|ChunkWriter
block|{
specifier|private
name|BufferInProgress
name|colBuffer
decl_stmt|;
specifier|public
name|void
name|prepare
parameter_list|(
name|BufferInProgress
name|colBuffer
parameter_list|)
block|{
name|this
operator|.
name|colBuffer
operator|=
name|colBuffer
expr_stmt|;
name|Chunk
name|chunk
init|=
name|this
operator|.
name|colBuffer
operator|.
name|ensureChunk
argument_list|()
decl_stmt|;
if|if
condition|(
name|chunk
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|// This is a new chunk; reserve space for header.
name|colBuffer
operator|.
name|offset
operator|+=
literal|8
expr_stmt|;
name|chunk
operator|.
name|length
operator|=
literal|8
expr_stmt|;
block|}
name|valuesOffset
operator|=
name|colBuffer
operator|.
name|offset
expr_stmt|;
block|}
comment|/**    * Completes the chunk by writing the header with externally-tracked row count.    * Does not have to be prepare()-d - any chunk can be update via this method.    * @param chunk Chunk to update.    * @param rowCount Row count in the chunk.    */
specifier|public
name|void
name|finishChunk
parameter_list|(
name|Chunk
name|chunk
parameter_list|,
name|int
name|rowCount
parameter_list|)
block|{
comment|// The space for chunk start is reserved; no need to update offset or length.
assert|assert
name|currentSegmentStart
operator|==
operator|-
literal|1
assert|;
name|ByteBuffer
name|buf
init|=
name|chunk
operator|.
name|buffer
operator|.
name|getContents
argument_list|()
decl_stmt|;
name|buf
operator|.
name|put
argument_list|(
name|chunk
operator|.
name|offset
argument_list|,
name|ChunkUtils
operator|.
name|FORMAT_VERSION
argument_list|)
expr_stmt|;
name|buf
operator|.
name|putInt
argument_list|(
name|chunk
operator|.
name|offset
operator|+
literal|1
argument_list|,
name|rowCount
argument_list|)
expr_stmt|;
block|}
comment|// State of current segment.
specifier|private
name|int
name|currentSegmentStart
init|=
operator|-
literal|1
decl_stmt|,
name|currentSegmentValues
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|boolean
name|currentSegmentIsRepeating
init|=
literal|false
decl_stmt|,
name|currentSegmentHasNulls
init|=
literal|false
decl_stmt|;
specifier|private
name|long
name|currentRepeatingLongValue
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|int
name|currentSizeOf
init|=
operator|-
literal|1
decl_stmt|;
comment|// State of the unique segment currently being written.
specifier|private
name|int
name|currentBitmaskOffset
init|=
operator|-
literal|1
decl_stmt|,
name|currentBitmaskLimit
init|=
operator|-
literal|1
decl_stmt|,
name|valuesOffset
init|=
operator|-
literal|1
decl_stmt|,
name|valuesSinceBitmask
init|=
operator|-
literal|1
decl_stmt|;
annotation|@
name|Override
specifier|public
name|int
name|estimateValueCountThatFits
parameter_list|(
name|Type
name|type
parameter_list|,
name|boolean
name|hasNulls
parameter_list|)
block|{
comment|// Assume we'd only need to write unique values without nulls, we can always do that.
comment|// If we are in the middle of a bitmask segment, space for bitmask was already reserved
comment|// so values will take just as much space as without bitmask.
comment|// Caller is supposed to re-estimate after every write.
return|return
operator|(
name|colBuffer
operator|.
name|getSpaceLeft
argument_list|(
name|valuesOffset
argument_list|)
operator|-
literal|8
operator|)
operator|/
name|ChunkUtils
operator|.
name|TYPE_SIZES
index|[
name|type
operator|.
name|value
argument_list|()
index|]
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeLongs
parameter_list|(
name|long
index|[]
name|src
parameter_list|,
name|int
name|srcOffset
parameter_list|,
name|int
name|srcCount
parameter_list|,
name|NullsState
name|nullsState
parameter_list|)
block|{
name|writeLongsInternal
argument_list|(
name|src
argument_list|,
name|srcOffset
argument_list|,
name|srcCount
argument_list|,
name|nullsState
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeLongs
parameter_list|(
name|byte
index|[]
name|src
parameter_list|,
name|int
name|srcOffset
parameter_list|,
name|int
name|srcCount
parameter_list|,
name|NullsState
name|nullsState
parameter_list|)
block|{
name|writeLongsInternal
argument_list|(
name|src
argument_list|,
name|srcOffset
argument_list|,
name|srcCount
argument_list|,
name|nullsState
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|writeLongsInternal
parameter_list|(
name|Object
name|srcObj
parameter_list|,
name|int
name|srcOffset
parameter_list|,
name|int
name|srcCount
parameter_list|,
name|NullsState
name|nullsState
parameter_list|,
name|boolean
name|isLongSrc
parameter_list|)
block|{
name|long
index|[]
name|srcL
init|=
name|isLongSrc
condition|?
operator|(
name|long
index|[]
operator|)
name|srcObj
else|:
literal|null
decl_stmt|;
name|byte
index|[]
name|srcB
init|=
name|isLongSrc
condition|?
literal|null
else|:
operator|(
name|byte
index|[]
operator|)
name|srcObj
decl_stmt|;
name|ByteBuffer
name|buffer
init|=
name|colBuffer
operator|.
name|buffer
operator|.
name|getContents
argument_list|()
decl_stmt|;
name|currentSizeOf
operator|=
name|ChunkUtils
operator|.
name|TYPE_SIZES
index|[
name|Type
operator|.
name|LONG
operator|.
name|value
argument_list|()
index|]
expr_stmt|;
name|ensureUniqueValueSegment
argument_list|(
name|buffer
argument_list|,
name|srcCount
argument_list|,
name|nullsState
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|currentSegmentHasNulls
condition|)
block|{
name|valuesOffset
operator|=
name|isLongSrc
condition|?
name|writeLongs
argument_list|(
name|buffer
argument_list|,
name|valuesOffset
argument_list|,
name|srcL
argument_list|,
name|srcOffset
argument_list|,
name|srcCount
argument_list|,
name|currentSizeOf
argument_list|)
else|:
name|writeLongs
argument_list|(
name|buffer
argument_list|,
name|valuesOffset
argument_list|,
name|srcB
argument_list|,
name|srcOffset
argument_list|,
name|srcCount
argument_list|,
name|currentSizeOf
argument_list|)
expr_stmt|;
name|currentSegmentValues
operator|+=
name|srcCount
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|valuesSinceBitmask
operator|==
name|currentBitmaskLimit
condition|)
block|{
name|startNextBitmask
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
comment|// Write bitmasks followed by values, until we write all the values.
while|while
condition|(
name|srcCount
operator|>
literal|0
condition|)
block|{
name|int
name|valuesToWrite
init|=
name|Math
operator|.
name|min
argument_list|(
name|currentBitmaskLimit
operator|-
name|valuesSinceBitmask
argument_list|,
name|srcCount
argument_list|)
decl_stmt|;
assert|assert
name|valuesToWrite
operator|>
literal|0
operator|:
name|valuesSinceBitmask
operator|+
literal|"/"
operator|+
name|currentBitmaskLimit
operator|+
literal|" "
operator|+
name|srcCount
assert|;
name|writeZeroesIntoBytes
argument_list|(
name|buffer
argument_list|,
name|currentBitmaskOffset
argument_list|,
name|valuesSinceBitmask
argument_list|,
name|valuesToWrite
argument_list|)
expr_stmt|;
name|valuesOffset
operator|=
name|isLongSrc
condition|?
name|writeLongs
argument_list|(
name|buffer
argument_list|,
name|valuesOffset
argument_list|,
name|srcL
argument_list|,
name|srcOffset
argument_list|,
name|valuesToWrite
argument_list|,
name|currentSizeOf
argument_list|)
else|:
name|writeLongs
argument_list|(
name|buffer
argument_list|,
name|valuesOffset
argument_list|,
name|srcB
argument_list|,
name|srcOffset
argument_list|,
name|valuesToWrite
argument_list|,
name|currentSizeOf
argument_list|)
expr_stmt|;
name|valuesSinceBitmask
operator|+=
name|valuesToWrite
expr_stmt|;
name|currentSegmentValues
operator|+=
name|valuesToWrite
expr_stmt|;
name|srcOffset
operator|+=
name|valuesToWrite
expr_stmt|;
name|srcCount
operator|-=
name|valuesToWrite
expr_stmt|;
if|if
condition|(
name|srcCount
operator|>
literal|0
condition|)
block|{
assert|assert
name|valuesSinceBitmask
operator|==
name|currentBitmaskLimit
assert|;
name|startNextBitmask
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeDoubles
parameter_list|(
name|double
index|[]
name|src
parameter_list|,
name|int
name|srcOffset
parameter_list|,
name|int
name|srcCount
parameter_list|,
name|NullsState
name|nullsState
parameter_list|)
block|{
name|ByteBuffer
name|buffer
init|=
name|colBuffer
operator|.
name|buffer
operator|.
name|getContents
argument_list|()
decl_stmt|;
name|currentSizeOf
operator|=
name|ChunkUtils
operator|.
name|TYPE_SIZES
index|[
name|Type
operator|.
name|DOUBLE
operator|.
name|value
argument_list|()
index|]
expr_stmt|;
name|ensureUniqueValueSegment
argument_list|(
name|buffer
argument_list|,
name|srcCount
argument_list|,
name|nullsState
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|currentSegmentHasNulls
condition|)
block|{
name|valuesOffset
operator|=
name|writeDoubles
argument_list|(
name|buffer
argument_list|,
name|valuesOffset
argument_list|,
name|src
argument_list|,
name|srcOffset
argument_list|,
name|srcCount
argument_list|,
name|currentSizeOf
argument_list|)
expr_stmt|;
name|currentSegmentValues
operator|+=
name|srcCount
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|valuesSinceBitmask
operator|==
name|currentBitmaskLimit
condition|)
block|{
name|startNextBitmask
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
comment|// Write bitmasks followed by values, until we write all the values.
while|while
condition|(
name|srcCount
operator|>
literal|0
condition|)
block|{
name|int
name|valuesToWrite
init|=
name|Math
operator|.
name|min
argument_list|(
name|currentBitmaskLimit
operator|-
name|valuesSinceBitmask
argument_list|,
name|srcCount
argument_list|)
decl_stmt|;
assert|assert
name|valuesToWrite
operator|>
literal|0
assert|;
name|writeZeroesIntoBytes
argument_list|(
name|buffer
argument_list|,
name|currentBitmaskOffset
argument_list|,
name|valuesSinceBitmask
argument_list|,
name|valuesToWrite
argument_list|)
expr_stmt|;
name|valuesOffset
operator|=
name|writeDoubles
argument_list|(
name|buffer
argument_list|,
name|valuesOffset
argument_list|,
name|src
argument_list|,
name|srcOffset
argument_list|,
name|valuesToWrite
argument_list|,
name|currentSizeOf
argument_list|)
expr_stmt|;
name|valuesSinceBitmask
operator|+=
name|valuesToWrite
expr_stmt|;
name|currentSegmentValues
operator|+=
name|valuesToWrite
expr_stmt|;
name|srcOffset
operator|+=
name|valuesToWrite
expr_stmt|;
name|srcCount
operator|-=
name|valuesToWrite
expr_stmt|;
if|if
condition|(
name|srcCount
operator|>
literal|0
condition|)
block|{
assert|assert
name|valuesSinceBitmask
operator|==
name|currentBitmaskLimit
assert|;
name|startNextBitmask
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeNulls
parameter_list|(
name|int
name|count
parameter_list|,
name|boolean
name|followedByNonNull
parameter_list|)
block|{
if|if
condition|(
operator|!
name|currentSegmentHasNulls
operator|||
operator|(
operator|!
name|currentSegmentIsRepeating
operator|&&
name|valuesSinceBitmask
operator|==
literal|0
operator|&&
name|count
operator|>
name|END_UNIQUE_SEGMENT_RUN_LEN
operator|)
condition|)
block|{
name|finishCurrentSegment
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|currentSegmentStart
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|currentSegmentIsRepeating
condition|)
block|{
assert|assert
name|currentSegmentHasNulls
operator|&&
name|valuesSinceBitmask
operator|>
literal|0
assert|;
assert|assert
name|currentSizeOf
operator|>
literal|0
assert|;
name|ByteBuffer
name|buffer
init|=
name|colBuffer
operator|.
name|buffer
operator|.
name|getContents
argument_list|()
decl_stmt|;
comment|// We are writing into an existing segment with bitmasks. Currently, we arbitrarily
comment|// choose to finish writing bitmask in such cases. Given that we write values despite
comment|// bitmask, this may be suboptimal, but otherwise we might write million tiny segments.
name|int
name|valuesToWrite
init|=
name|Math
operator|.
name|min
argument_list|(
name|currentBitmaskLimit
operator|-
name|valuesSinceBitmask
argument_list|,
name|count
argument_list|)
decl_stmt|;
if|if
condition|(
name|valuesToWrite
operator|>
literal|0
condition|)
block|{
name|writeOnesIntoBytes
argument_list|(
name|buffer
argument_list|,
name|currentBitmaskOffset
argument_list|,
name|valuesSinceBitmask
argument_list|,
name|valuesToWrite
argument_list|)
expr_stmt|;
name|valuesOffset
operator|+=
operator|(
name|currentSizeOf
operator|*
name|valuesToWrite
operator|)
expr_stmt|;
name|valuesSinceBitmask
operator|+=
name|valuesToWrite
expr_stmt|;
name|currentSegmentValues
operator|+=
name|valuesToWrite
expr_stmt|;
name|count
operator|-=
name|valuesToWrite
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
comment|// Might not make sense if count remaining is low and is followed by non-nulls.
name|finishCurrentSegment
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|currentSegmentStart
operator|==
operator|-
literal|1
condition|)
block|{
comment|// We have no segment. For small count, starting a bitmask might make sense, but for now
comment|// we always start repeated nulls segment, even if it doesn't make any sense.
name|currentSizeOf
operator|=
operator|-
literal|1
expr_stmt|;
name|startRepeatingSegment
argument_list|()
expr_stmt|;
name|currentSegmentHasNulls
operator|=
literal|true
expr_stmt|;
block|}
assert|assert
name|currentSegmentIsRepeating
operator|&&
name|currentSegmentHasNulls
assert|;
name|currentSegmentValues
operator|+=
name|count
expr_stmt|;
block|}
comment|/** Arbitrary; the tradeoff is between wasting space writing repeated values,    *  and having many tiny segments that are more expensive to read. */
specifier|private
specifier|static
specifier|final
name|int
name|END_UNIQUE_SEGMENT_RUN_LEN
init|=
literal|10
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|writeRepeatedLongs
parameter_list|(
name|long
name|value
parameter_list|,
name|int
name|count
parameter_list|,
name|NullsState
name|nullsState
parameter_list|)
block|{
name|boolean
name|isIncompatibleRepeating
init|=
name|currentSegmentIsRepeating
operator|&&
operator|(
name|currentSegmentHasNulls
operator|||
name|currentRepeatingLongValue
operator|!=
name|value
operator|)
decl_stmt|;
name|boolean
name|isAtEndOfBitmask
init|=
operator|!
name|currentSegmentIsRepeating
operator|&&
name|currentSegmentHasNulls
operator|&&
name|valuesSinceBitmask
operator|==
literal|0
decl_stmt|;
if|if
condition|(
name|isIncompatibleRepeating
operator|||
operator|(
name|isAtEndOfBitmask
operator|&&
name|count
operator|>=
name|END_UNIQUE_SEGMENT_RUN_LEN
operator|)
condition|)
block|{
name|finishCurrentSegment
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|currentSegmentStart
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|currentSegmentIsRepeating
condition|)
block|{
assert|assert
name|currentSizeOf
operator|>
literal|0
assert|;
name|ByteBuffer
name|buffer
init|=
name|colBuffer
operator|.
name|buffer
operator|.
name|getContents
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentSegmentHasNulls
condition|)
block|{
assert|assert
name|valuesSinceBitmask
operator|>
literal|0
assert|;
comment|// See writeNulls - similar logic.
name|int
name|valuesToWrite
init|=
name|Math
operator|.
name|min
argument_list|(
name|currentBitmaskLimit
operator|-
name|valuesSinceBitmask
argument_list|,
name|count
argument_list|)
decl_stmt|;
if|if
condition|(
name|valuesToWrite
operator|>
literal|0
condition|)
block|{
name|writeZeroesIntoBytes
argument_list|(
name|buffer
argument_list|,
name|currentBitmaskOffset
argument_list|,
name|valuesSinceBitmask
argument_list|,
name|valuesToWrite
argument_list|)
expr_stmt|;
name|valuesOffset
operator|=
name|writeLongs
argument_list|(
name|buffer
argument_list|,
name|valuesOffset
argument_list|,
name|value
argument_list|,
name|valuesToWrite
argument_list|,
name|currentSizeOf
argument_list|)
expr_stmt|;
name|valuesSinceBitmask
operator|+=
name|valuesToWrite
expr_stmt|;
name|currentSegmentValues
operator|+=
name|valuesToWrite
expr_stmt|;
name|count
operator|-=
name|valuesToWrite
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|finishCurrentSegment
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|count
operator|<
name|END_UNIQUE_SEGMENT_RUN_LEN
condition|)
block|{
name|valuesOffset
operator|=
name|writeLongs
argument_list|(
name|buffer
argument_list|,
name|valuesOffset
argument_list|,
name|value
argument_list|,
name|count
argument_list|,
name|currentSizeOf
argument_list|)
expr_stmt|;
name|valuesSinceBitmask
operator|+=
name|count
expr_stmt|;
name|currentSegmentValues
operator|+=
name|count
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|finishCurrentSegment
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|currentSegmentStart
operator|==
operator|-
literal|1
condition|)
block|{
comment|// We have no segment. For small count, starting a bitmask might make sense, but for now
comment|// we always start repeated segment, even if it doesn't make any sense.
name|currentSizeOf
operator|=
name|ChunkUtils
operator|.
name|TYPE_SIZES
index|[
name|Type
operator|.
name|LONG
operator|.
name|value
argument_list|()
index|]
expr_stmt|;
name|startRepeatingSegment
argument_list|()
expr_stmt|;
name|currentSegmentHasNulls
operator|=
literal|false
expr_stmt|;
name|currentRepeatingLongValue
operator|=
name|value
expr_stmt|;
name|colBuffer
operator|.
name|buffer
operator|.
name|getContents
argument_list|()
operator|.
name|putLong
argument_list|(
name|valuesOffset
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|valuesOffset
operator|+=
name|currentSizeOf
expr_stmt|;
block|}
assert|assert
name|currentSegmentIsRepeating
operator|&&
operator|(
name|currentRepeatingLongValue
operator|==
name|value
operator|)
assert|;
name|currentSegmentValues
operator|+=
name|count
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|finishCurrentSegment
parameter_list|()
block|{
if|if
condition|(
name|currentSegmentStart
operator|==
operator|-
literal|1
condition|)
return|return;
name|ByteBuffer
name|buffer
init|=
name|colBuffer
operator|.
name|buffer
operator|.
name|getContents
argument_list|()
decl_stmt|;
name|RleSegmentType
name|segmentType
init|=
name|RleSegmentType
operator|.
name|INVALID
decl_stmt|;
if|if
condition|(
name|currentSegmentIsRepeating
operator|||
operator|!
name|currentSegmentHasNulls
operator|||
name|valuesSinceBitmask
operator|==
literal|0
operator|||
name|valuesSinceBitmask
operator|==
name|currentBitmaskLimit
condition|)
block|{
comment|// Simple case - just write the type and count into current segment header.
name|segmentType
operator|=
name|currentSegmentIsRepeating
condition|?
operator|(
name|currentSegmentHasNulls
condition|?
name|RleSegmentType
operator|.
name|REPEATING_NULL
else|:
name|RleSegmentType
operator|.
name|REPEATING_VALUE
operator|)
else|:
operator|(
name|currentSegmentHasNulls
condition|?
name|RleSegmentType
operator|.
name|UNIQUE_NULL_BITMASK
else|:
name|RleSegmentType
operator|.
name|UNIQUE_NOT_NULL
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// Complicated case - bitmask is not finished, we may need to move values.
name|segmentType
operator|=
name|RleSegmentType
operator|.
name|UNIQUE_NULL_BITMASK
expr_stmt|;
name|int
name|adjustedValues
init|=
name|ChunkUtils
operator|.
name|align64
argument_list|(
name|valuesSinceBitmask
argument_list|)
decl_stmt|;
comment|// Rounded to 8 bytes.
name|int
name|bytesShift
init|=
operator|(
name|ChunkUtils
operator|.
name|align64
argument_list|(
name|currentBitmaskLimit
argument_list|)
operator|-
name|adjustedValues
operator|)
operator|>>>
literal|3
decl_stmt|;
comment|// Will never happen when bitmask is 8 bytes - minimum and maximum sizes are the same.
if|if
condition|(
name|bytesShift
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Adjusting last bitmask by "
operator|+
name|bytesShift
operator|+
literal|" bytes"
argument_list|)
expr_stmt|;
block|}
assert|assert
name|currentSizeOf
operator|>
literal|0
assert|;
name|int
name|valuesSize
init|=
name|valuesSinceBitmask
operator|*
name|currentSizeOf
decl_stmt|;
name|int
name|valuesStart
init|=
name|valuesOffset
operator|-
name|valuesSize
decl_stmt|;
assert|assert
name|buffer
operator|.
name|hasArray
argument_list|()
assert|;
name|byte
index|[]
name|arr
init|=
name|buffer
operator|.
name|array
argument_list|()
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|arr
argument_list|,
name|valuesStart
argument_list|,
name|arr
argument_list|,
name|valuesStart
operator|-
name|bytesShift
argument_list|,
name|valuesSize
argument_list|)
expr_stmt|;
name|valuesOffset
operator|-=
name|bytesShift
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DebugUtils
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|Llap
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Writing "
operator|+
name|segmentType
operator|+
literal|" header w/ "
operator|+
name|currentSegmentValues
operator|+
literal|" values at "
operator|+
name|currentSegmentStart
operator|+
literal|" till "
operator|+
name|valuesOffset
argument_list|)
expr_stmt|;
block|}
name|writeSegmentHeader
argument_list|(
name|buffer
argument_list|,
name|currentSegmentStart
argument_list|,
name|segmentType
argument_list|,
name|currentSegmentValues
argument_list|)
expr_stmt|;
name|colBuffer
operator|.
name|update
argument_list|(
name|valuesOffset
argument_list|,
name|currentSegmentValues
argument_list|)
expr_stmt|;
name|currentSegmentStart
operator|=
operator|-
literal|1
expr_stmt|;
block|}
specifier|private
name|void
name|startRepeatingSegment
parameter_list|()
block|{
name|currentSegmentIsRepeating
operator|=
literal|true
expr_stmt|;
name|currentSegmentStart
operator|=
name|valuesOffset
expr_stmt|;
name|currentSegmentValues
operator|=
literal|0
expr_stmt|;
name|currentBitmaskOffset
operator|=
operator|-
literal|1
expr_stmt|;
name|valuesOffset
operator|+=
literal|8
expr_stmt|;
block|}
specifier|private
name|void
name|ensureUniqueValueSegment
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|,
name|int
name|valueCount
parameter_list|,
name|NullsState
name|nullsState
parameter_list|)
block|{
name|boolean
name|forceNoNulls
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|currentSegmentStart
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|currentSegmentIsRepeating
condition|)
block|{
if|if
condition|(
operator|!
name|currentSegmentHasNulls
operator|||
name|canValuesFitIntoCurrentSegment
argument_list|(
name|buffer
argument_list|,
name|valueCount
argument_list|,
name|currentSizeOf
argument_list|)
condition|)
block|{
return|return;
comment|// We have an unique-value segment w/o bitmasks, or values fit w/bitmasks.
block|}
name|forceNoNulls
operator|=
literal|true
expr_stmt|;
block|}
name|finishCurrentSegment
argument_list|()
expr_stmt|;
block|}
comment|// There no unique-value segment (or we just finished one), start one.
name|currentSegmentStart
operator|=
name|valuesOffset
expr_stmt|;
name|valuesOffset
operator|+=
literal|8
expr_stmt|;
name|currentSegmentIsRepeating
operator|=
literal|false
expr_stmt|;
name|valuesSinceBitmask
operator|=
name|currentSegmentValues
operator|=
literal|0
expr_stmt|;
name|currentSegmentHasNulls
operator|=
operator|!
name|forceNoNulls
operator|&&
name|shouldNewSegmentHaveBitmasks
argument_list|(
name|valueCount
argument_list|,
name|nullsState
argument_list|,
name|buffer
argument_list|,
name|valuesOffset
argument_list|,
name|currentSizeOf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|currentSegmentHasNulls
condition|)
block|{
name|currentBitmaskOffset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|startNextBitmask
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|startNextBitmask
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|)
block|{
name|currentBitmaskOffset
operator|=
name|valuesOffset
expr_stmt|;
name|int
name|spaceLeft
init|=
name|buffer
operator|.
name|limit
argument_list|()
operator|-
name|currentBitmaskOffset
decl_stmt|;
name|valuesSinceBitmask
operator|=
literal|0
expr_stmt|;
name|valuesOffset
operator|=
name|currentBitmaskOffset
expr_stmt|;
if|if
condition|(
name|spaceLeft
operator|>=
name|ChunkUtils
operator|.
name|getFullBitmaskSize
argument_list|(
name|currentSizeOf
argument_list|)
condition|)
block|{
comment|// Most of the time, standard-sized bitmask will fit (we are not at the end of the buffer).
name|currentBitmaskLimit
operator|=
name|ChunkUtils
operator|.
name|BITMASK_SIZE_BITS
expr_stmt|;
name|valuesOffset
operator|+=
name|ChunkUtils
operator|.
name|BITMASK_SIZE_BYTES
expr_stmt|;
return|return;
block|}
comment|// Only part of the bitmask will fit, so we will have a smaller one.
name|int
name|incrementSize
init|=
literal|8
operator|+
operator|(
name|currentSizeOf
operator|<<
literal|6
operator|)
decl_stmt|;
comment|// 8 bytes, 64 values (minimum bitmask alignment)
name|int
name|incrementsThatFit
init|=
operator|(
name|spaceLeft
operator|/
name|incrementSize
operator|)
decl_stmt|;
comment|// Per each part, we will add 8 bytes to have space for bitmask, and space for 64 values.
name|valuesOffset
operator|+=
operator|(
name|incrementsThatFit
operator|<<
literal|3
operator|)
expr_stmt|;
name|currentBitmaskLimit
operator|=
name|incrementsThatFit
operator|>>>
literal|6
expr_stmt|;
comment|// If there's more space, try to fit 8 more bytes of bitmask with less than 64 values.
name|spaceLeft
operator|=
operator|(
name|spaceLeft
operator|%
name|incrementSize
operator|)
operator|-
literal|8
expr_stmt|;
comment|// 8 bytes for that last bitmask
if|if
condition|(
name|spaceLeft
operator|>=
name|currentSizeOf
condition|)
block|{
name|valuesOffset
operator|+=
literal|8
expr_stmt|;
name|currentBitmaskLimit
operator|+=
operator|(
name|spaceLeft
operator|/
name|currentSizeOf
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|currentBitmaskLimit
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Bitmask won't fit; caller should have checked that"
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|void
name|writeZeroesIntoBytes
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|,
name|int
name|bitmaskOffset
parameter_list|,
name|int
name|valuesSinceBitmask
parameter_list|,
name|int
name|valuesToWrite
parameter_list|)
block|{
comment|// No need to write 0s into the tail of a partial byte - already set to 0s by
comment|// the previous call to writeZeroesIntoBytes or writeOnesIntoBytes.
name|int
name|bitsToSkip
init|=
literal|8
operator|-
operator|(
name|valuesSinceBitmask
operator|&
literal|7
operator|)
decl_stmt|;
if|if
condition|(
name|bitsToSkip
operator|<
literal|8
condition|)
block|{
name|valuesToWrite
operator|-=
name|bitsToSkip
expr_stmt|;
name|valuesSinceBitmask
operator|+=
name|bitsToSkip
expr_stmt|;
if|if
condition|(
name|valuesToWrite
operator|<=
literal|0
condition|)
return|return;
block|}
name|int
name|nextByteToModify
init|=
name|bitmaskOffset
operator|+
operator|(
name|valuesSinceBitmask
operator|>>>
literal|3
operator|)
decl_stmt|;
while|while
condition|(
name|valuesToWrite
operator|>
literal|0
condition|)
block|{
name|buffer
operator|.
name|put
argument_list|(
name|nextByteToModify
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
name|valuesToWrite
operator|-=
literal|8
expr_stmt|;
operator|++
name|nextByteToModify
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|writeOnesIntoBytes
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|,
name|int
name|bitmaskOffset
parameter_list|,
name|int
name|valuesSinceBitmask
parameter_list|,
name|int
name|valuesToWrite
parameter_list|)
block|{
comment|// We need to set the bits in the bitmask to one. We may have to do partial bits,
comment|// then whole bytes, then partial bits again for the last rows. I hate bits.
name|int
name|nextByteToModify
init|=
name|bitmaskOffset
operator|+
operator|(
name|valuesSinceBitmask
operator|>>>
literal|3
operator|)
decl_stmt|;
name|int
name|bitsWritten
init|=
name|writeOneBitsFromPartialByte
argument_list|(
name|buffer
argument_list|,
name|nextByteToModify
argument_list|,
name|valuesSinceBitmask
argument_list|,
name|valuesToWrite
argument_list|)
decl_stmt|;
if|if
condition|(
name|bitsWritten
operator|>
literal|0
condition|)
block|{
name|valuesToWrite
operator|-=
name|bitsWritten
expr_stmt|;
operator|++
name|nextByteToModify
expr_stmt|;
block|}
while|while
condition|(
name|valuesToWrite
operator|>
literal|8
condition|)
block|{
name|buffer
operator|.
name|put
argument_list|(
name|nextByteToModify
argument_list|,
operator|(
name|byte
operator|)
literal|0xff
argument_list|)
expr_stmt|;
name|valuesToWrite
operator|-=
literal|8
expr_stmt|;
operator|++
name|nextByteToModify
expr_stmt|;
block|}
if|if
condition|(
name|valuesToWrite
operator|>
literal|0
condition|)
block|{
name|int
name|newBitsMask
init|=
operator|(
operator|(
literal|1
operator|<<
name|valuesToWrite
operator|)
operator|-
literal|1
operator|)
operator|<<
operator|(
literal|8
operator|-
name|valuesToWrite
operator|)
decl_stmt|;
name|buffer
operator|.
name|put
argument_list|(
name|nextByteToModify
argument_list|,
operator|(
name|byte
operator|)
name|newBitsMask
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|int
name|writeOneBitsFromPartialByte
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|,
name|int
name|bufferOffset
parameter_list|,
name|int
name|valuesInBitmask
parameter_list|,
name|int
name|valuesToWrite
parameter_list|)
block|{
name|int
name|bitOffset
init|=
name|valuesInBitmask
operator|&
literal|7
decl_stmt|;
if|if
condition|(
name|bitOffset
operator|==
literal|0
condition|)
return|return
literal|0
return|;
assert|assert
name|bitOffset
operator|<
literal|8
assert|;
name|byte
name|partialByte
init|=
name|buffer
operator|.
name|get
argument_list|(
name|bufferOffset
argument_list|)
decl_stmt|;
name|int
name|unusedBits
init|=
literal|8
operator|-
name|bitOffset
decl_stmt|;
name|int
name|result
init|=
name|Math
operator|.
name|min
argument_list|(
name|unusedBits
argument_list|,
name|valuesToWrite
argument_list|)
decl_stmt|;
comment|// Make newBitCount ones, then shift them to create 0s on the right.
name|int
name|newBitsMask
init|=
operator|(
operator|(
literal|1
operator|<<
name|result
operator|)
operator|-
literal|1
operator|)
operator|<<
operator|(
name|unusedBits
operator|-
name|result
operator|)
decl_stmt|;
name|byte
name|newByte
init|=
call|(
name|byte
call|)
argument_list|(
name|partialByte
operator||
name|newBitsMask
argument_list|)
decl_stmt|;
name|buffer
operator|.
name|put
argument_list|(
name|bufferOffset
argument_list|,
name|newByte
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
specifier|static
name|boolean
name|shouldNewSegmentHaveBitmasks
parameter_list|(
name|int
name|valueCount
parameter_list|,
name|NullsState
name|nullsState
parameter_list|,
name|ByteBuffer
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|sizeOf
parameter_list|)
block|{
comment|// This is rather arbitrary. We'll write some values w/o bitmask if there are enough.
comment|// What is enough is an interesting question. We pay 8 bytes extra for segment header
comment|// if this is immediately followed by some nulls; so use this as a guideline. If we
comment|// don't know if this is followed by null or more values, use half?
if|if
condition|(
name|nullsState
operator|==
name|NullsState
operator|.
name|NO_NULLS
operator|||
name|valueCount
operator|>=
name|ChunkUtils
operator|.
name|BITMASK_SIZE_BITS
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|canValuesFitWithBitmasks
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
name|valueCount
argument_list|,
name|sizeOf
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|canValuesFitIntoCurrentSegment
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|,
name|int
name|valueCount
parameter_list|,
name|int
name|sizeOf
parameter_list|)
block|{
name|int
name|valuesIntoCurrentBitmask
init|=
operator|(
name|currentBitmaskLimit
operator|-
name|valuesSinceBitmask
operator|)
decl_stmt|;
name|valueCount
operator|-=
name|valuesIntoCurrentBitmask
expr_stmt|;
if|if
condition|(
name|valueCount
operator|<=
literal|0
condition|)
return|return
literal|true
return|;
name|int
name|nextBitmaskOffset
init|=
name|valuesOffset
operator|+
name|valuesIntoCurrentBitmask
operator|*
name|sizeOf
decl_stmt|;
return|return
name|canValuesFitWithBitmasks
argument_list|(
name|buffer
argument_list|,
name|nextBitmaskOffset
argument_list|,
name|valueCount
argument_list|,
name|sizeOf
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|boolean
name|canValuesFitWithBitmasks
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|valueCount
parameter_list|,
name|int
name|elementSize
parameter_list|)
block|{
return|return
operator|(
name|determineSizeWithBitMask
argument_list|(
name|valueCount
argument_list|,
name|elementSize
argument_list|)
operator|<
operator|(
name|buffer
operator|.
name|limit
argument_list|()
operator|-
name|offset
operator|)
operator|)
return|;
block|}
specifier|private
specifier|static
name|int
name|determineSizeWithBitMask
parameter_list|(
name|int
name|count
parameter_list|,
name|int
name|elementSize
parameter_list|)
block|{
return|return
name|count
operator|*
name|elementSize
operator|+
operator|(
name|ChunkUtils
operator|.
name|align64
argument_list|(
name|count
argument_list|)
operator|>>>
literal|3
operator|)
return|;
block|}
specifier|private
specifier|static
name|void
name|writeSegmentHeader
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|RleSegmentType
name|type
parameter_list|,
name|int
name|rowCount
parameter_list|)
block|{
name|buffer
operator|.
name|put
argument_list|(
name|offset
operator|++
argument_list|,
name|type
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|putInt
argument_list|(
name|offset
argument_list|,
name|rowCount
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|int
name|writeLongs
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|long
index|[]
name|cv
parameter_list|,
name|int
name|cvOffset
parameter_list|,
name|int
name|rowsToWrite
parameter_list|,
name|int
name|sizeOf
parameter_list|)
block|{
assert|assert
name|sizeOf
operator|>
literal|0
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rowsToWrite
condition|;
operator|++
name|i
control|)
block|{
name|buffer
operator|.
name|putLong
argument_list|(
name|offset
argument_list|,
name|cv
index|[
name|cvOffset
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|sizeOf
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
specifier|private
specifier|static
name|int
name|writeDoubles
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|double
index|[]
name|cv
parameter_list|,
name|int
name|cvOffset
parameter_list|,
name|int
name|rowsToWrite
parameter_list|,
name|int
name|sizeOf
parameter_list|)
block|{
assert|assert
name|sizeOf
operator|>
literal|0
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rowsToWrite
condition|;
operator|++
name|i
control|)
block|{
name|buffer
operator|.
name|putDouble
argument_list|(
name|offset
argument_list|,
name|cv
index|[
name|cvOffset
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|sizeOf
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
specifier|private
specifier|static
name|int
name|writeLongs
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|byte
index|[]
name|cv
parameter_list|,
name|int
name|cvOffset
parameter_list|,
name|int
name|rowsToWrite
parameter_list|,
name|int
name|sizeOf
parameter_list|)
block|{
assert|assert
name|sizeOf
operator|>
literal|0
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rowsToWrite
condition|;
operator|++
name|i
control|)
block|{
name|buffer
operator|.
name|putLong
argument_list|(
name|offset
argument_list|,
name|cv
index|[
name|cvOffset
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|sizeOf
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
specifier|private
specifier|static
name|int
name|writeLongs
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|long
name|value
parameter_list|,
name|int
name|rowsToWrite
parameter_list|,
name|int
name|sizeOf
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rowsToWrite
condition|;
operator|++
name|i
control|)
block|{
name|buffer
operator|.
name|putLong
argument_list|(
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|sizeOf
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
block|}
end_class

end_unit

