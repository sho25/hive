begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|tools
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|math3
operator|.
name|stat
operator|.
name|descriptive
operator|.
name|DescriptiveStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|math3
operator|.
name|stat
operator|.
name|descriptive
operator|.
name|rank
operator|.
name|Median
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jetbrains
operator|.
name|annotations
operator|.
name|NotNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jetbrains
operator|.
name|annotations
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Formatter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|tools
operator|.
name|Util
operator|.
name|filterMatches
import|;
end_import

begin_comment
comment|/**  * Group of benchmarks that can be joined together.  * Every benchmark has an associated name and code to run it.  * It is possible to run all benchmarks or only ones matching the filter.<p>  *  * Results can be optionally sanitized - any result that is outside of  * mean +/- margin * delta is removed from the result set. This helps remove random  * outliers.  *  *<h1>Example</h1>  *  *<pre>  *   StringBuilder sb = new StringBuilder();  *   Formatter fmt = new Formatter(sb);  *   BenchmarkSuite suite = new BenchmarkSuite();  *      // Arrange various benchmarks in a suite  *      BenchmarkSuite result = suite  *           .setScale(scale)  *           .doSanitize(true)  *           .add("someBenchmark", someBenchmarkFunc)  *           .add("anotherBenchmark", anotherBenchmarkFunc)  *           .runMatching(patterns, exclude);  *      result.display(fmt);  *</pre>  *  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|BenchmarkSuite
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|BenchmarkSuite
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Delta margin for data sanitizing. When sanitizing is enabled, we filter out
comment|// all result which are outside
comment|// mean +/- MARGIN * stddev
specifier|private
specifier|static
specifier|final
name|double
name|MARGIN
init|=
literal|2
decl_stmt|;
comment|// Collection of benchmarks
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Supplier
argument_list|<
name|DescriptiveStatistics
argument_list|>
argument_list|>
name|suite
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// List of benchmarks. All benchmarks are executed in the order
comment|// they are inserted
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|benchmarks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Once benchmarks are executed, results are stored in TreeMap to prserve the order.
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|DescriptiveStatistics
argument_list|>
name|result
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Whether sanitizing of results is requested
specifier|private
name|boolean
name|doSanitize
init|=
literal|false
decl_stmt|;
comment|// Time units - we use milliseconds.
specifier|private
name|TimeUnit
name|scale
init|=
name|TimeUnit
operator|.
name|MILLISECONDS
decl_stmt|;
comment|/**    * Set scaling factor for displaying results.    * When data is reported, all times are divided by scale functor.    * Data is always collected in nanoseconds, so this can be used to present    * data using different time units.    * @param scale: scaling factor    * @return this for chaining    */
specifier|public
name|BenchmarkSuite
name|setScale
parameter_list|(
name|TimeUnit
name|scale
parameter_list|)
block|{
name|this
operator|.
name|scale
operator|=
name|scale
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Enable or disable result sanitization.    * This should be done before benchmarks are executed.    * @param sanitize enable sanitization if true, disable if false    * @return this object, allowing chained calls.    */
specifier|public
name|BenchmarkSuite
name|doSanitize
parameter_list|(
name|boolean
name|sanitize
parameter_list|)
block|{
name|this
operator|.
name|doSanitize
operator|=
name|sanitize
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Get raw benchmark results    * @return map of benchmark name to the statistics describing the result    */
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|DescriptiveStatistics
argument_list|>
name|getResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
comment|/**    * Run all benchmarks in the 'names' list.    * @param names list of benchmarks to run    * @return this to allow chaining    */
specifier|private
name|BenchmarkSuite
name|runAll
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|names
parameter_list|)
block|{
if|if
condition|(
name|doSanitize
condition|)
block|{
name|names
operator|.
name|forEach
argument_list|(
name|name
lambda|->
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Running benchmark {}"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|result
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|sanitize
argument_list|(
name|suite
operator|.
name|get
argument_list|(
name|name
argument_list|)
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|names
operator|.
name|forEach
argument_list|(
name|name
lambda|->
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Running benchmark {}"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|result
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|suite
operator|.
name|get
argument_list|(
name|name
argument_list|)
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/**    * Return list of benchmark names that match positive patterns and do not    * match negative patterns.    * @param positive regexp patterns that should match benchmark name    * @param negatve regexp patterns that should be excluded when matches    * @return list of benchmark names    */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|listMatching
parameter_list|(
annotation|@
name|Nullable
name|Pattern
index|[]
name|positive
parameter_list|,
annotation|@
name|Nullable
name|Pattern
index|[]
name|negatve
parameter_list|)
block|{
return|return
name|filterMatches
argument_list|(
name|benchmarks
argument_list|,
name|positive
argument_list|,
name|negatve
argument_list|)
return|;
block|}
comment|/**    * Run all benchmarks (filtered by positive and negative matches.    * See {@link #listMatching(Pattern[], Pattern[])} for details.    * @param positive regexp patterns that should match benchmark name    * @param negatve regexp patterns that should be excluded when matches    * @return this    */
specifier|public
name|BenchmarkSuite
name|runMatching
parameter_list|(
annotation|@
name|Nullable
name|Pattern
index|[]
name|positive
parameter_list|,
annotation|@
name|Nullable
name|Pattern
index|[]
name|negatve
parameter_list|)
block|{
return|return
name|runAll
argument_list|(
name|filterMatches
argument_list|(
name|benchmarks
argument_list|,
name|positive
argument_list|,
name|negatve
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Add new benchmark to the suite.    * @param name benchmark name    * @param b benchmark corresponding to name    * @return this    */
specifier|public
name|BenchmarkSuite
name|add
parameter_list|(
annotation|@
name|NotNull
name|String
name|name
parameter_list|,
annotation|@
name|NotNull
name|Supplier
argument_list|<
name|DescriptiveStatistics
argument_list|>
name|b
parameter_list|)
block|{
name|suite
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|benchmarks
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Get new statistics that excludes values beyond mean +/- 2 * stdev    *    * @param data Source data    * @return new {@link @DescriptiveStatistics objects with sanitized data}    */
specifier|private
specifier|static
name|DescriptiveStatistics
name|sanitize
parameter_list|(
annotation|@
name|NotNull
name|DescriptiveStatistics
name|data
parameter_list|)
block|{
name|double
name|meanValue
init|=
name|data
operator|.
name|getMean
argument_list|()
decl_stmt|;
name|double
name|delta
init|=
name|MARGIN
operator|*
name|meanValue
decl_stmt|;
name|double
name|minVal
init|=
name|meanValue
operator|-
name|delta
decl_stmt|;
name|double
name|maxVal
init|=
name|meanValue
operator|+
name|delta
decl_stmt|;
return|return
operator|new
name|DescriptiveStatistics
argument_list|(
name|Arrays
operator|.
name|stream
argument_list|(
name|data
operator|.
name|getValues
argument_list|()
argument_list|)
operator|.
name|filter
argument_list|(
name|x
lambda|->
name|x
operator|>
name|minVal
operator|&&
name|x
operator|<
name|maxVal
argument_list|)
operator|.
name|toArray
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get median value for given statistics.    * @param data collected datapoints.    * @return median value.    */
specifier|private
specifier|static
name|double
name|median
parameter_list|(
annotation|@
name|NotNull
name|DescriptiveStatistics
name|data
parameter_list|)
block|{
return|return
operator|new
name|Median
argument_list|()
operator|.
name|evaluate
argument_list|(
name|data
operator|.
name|getValues
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Produce printable result    * @param fmt text formatter - destination of formatted results.    * @param name benchmark name    * @param stats benchmark data    */
specifier|private
name|void
name|displayStats
parameter_list|(
annotation|@
name|NotNull
name|Formatter
name|fmt
parameter_list|,
annotation|@
name|NotNull
name|String
name|name
parameter_list|,
annotation|@
name|NotNull
name|DescriptiveStatistics
name|stats
parameter_list|)
block|{
name|double
name|mean
init|=
name|stats
operator|.
name|getMean
argument_list|()
decl_stmt|;
name|double
name|err
init|=
name|stats
operator|.
name|getStandardDeviation
argument_list|()
operator|/
name|mean
operator|*
literal|100
decl_stmt|;
name|long
name|conv
init|=
name|scale
operator|.
name|toNanos
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|fmt
operator|.
name|format
argument_list|(
literal|"%-30s %-8.4g %-8.4g %-8.4g %-8.4g %-8.4g%n"
argument_list|,
name|name
argument_list|,
name|mean
operator|/
name|conv
argument_list|,
name|median
argument_list|(
name|stats
argument_list|)
operator|/
name|conv
argument_list|,
name|stats
operator|.
name|getMin
argument_list|()
operator|/
name|conv
argument_list|,
name|stats
operator|.
name|getMax
argument_list|()
operator|/
name|conv
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
comment|/**    * Produce results in printable CSV format, separated by separator.    * @param fmt text formatter - destination of formatted results.    * @param name benchmark name    * @param stats benchmark data    * @param separator field separator    */
specifier|private
name|void
name|displayCSV
parameter_list|(
annotation|@
name|NotNull
name|Formatter
name|fmt
parameter_list|,
annotation|@
name|NotNull
name|String
name|name
parameter_list|,
annotation|@
name|NotNull
name|DescriptiveStatistics
name|stats
parameter_list|,
annotation|@
name|NotNull
name|String
name|separator
parameter_list|)
block|{
name|double
name|mean
init|=
name|stats
operator|.
name|getMean
argument_list|()
decl_stmt|;
name|double
name|err
init|=
name|stats
operator|.
name|getStandardDeviation
argument_list|()
operator|/
name|mean
operator|*
literal|100
decl_stmt|;
name|long
name|conv
init|=
name|scale
operator|.
name|toNanos
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|fmt
operator|.
name|format
argument_list|(
literal|"%s%s%g%s%g%s%g%s%g%s%g%n"
argument_list|,
name|name
argument_list|,
name|separator
argument_list|,
name|mean
operator|/
name|conv
argument_list|,
name|separator
argument_list|,
name|median
argument_list|(
name|stats
argument_list|)
operator|/
name|conv
argument_list|,
name|separator
argument_list|,
name|stats
operator|.
name|getMin
argument_list|()
operator|/
name|conv
argument_list|,
name|separator
argument_list|,
name|stats
operator|.
name|getMax
argument_list|()
operator|/
name|conv
argument_list|,
name|separator
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
comment|/**    * Format all results    * @param fmt text formatter - destination of formatted results.    * @return this    */
name|BenchmarkSuite
name|display
parameter_list|(
name|Formatter
name|fmt
parameter_list|)
block|{
name|fmt
operator|.
name|format
argument_list|(
literal|"%-30s %-8s %-8s %-8s %-8s %-8s%n"
argument_list|,
literal|"Operation"
argument_list|,
literal|"Mean"
argument_list|,
literal|"Med"
argument_list|,
literal|"Min"
argument_list|,
literal|"Max"
argument_list|,
literal|"Err%"
argument_list|)
expr_stmt|;
name|result
operator|.
name|forEach
argument_list|(
parameter_list|(
name|name
parameter_list|,
name|stat
parameter_list|)
lambda|->
name|displayStats
argument_list|(
name|fmt
argument_list|,
name|name
argument_list|,
name|stat
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Format all results in CSV format    * @param fmt text formatter - destination of formatted results.    * @param separator field separator    * @return this    */
name|BenchmarkSuite
name|displayCSV
parameter_list|(
name|Formatter
name|fmt
parameter_list|,
name|String
name|separator
parameter_list|)
block|{
name|fmt
operator|.
name|format
argument_list|(
literal|"%s%s%s%s%s%s%s%s%s%s%s%n"
argument_list|,
literal|"Operation"
argument_list|,
name|separator
argument_list|,
literal|"Mean"
argument_list|,
name|separator
argument_list|,
literal|"Med"
argument_list|,
name|separator
argument_list|,
literal|"Min"
argument_list|,
name|separator
argument_list|,
literal|"Max"
argument_list|,
name|separator
argument_list|,
literal|"Err%"
argument_list|)
expr_stmt|;
name|result
operator|.
name|forEach
argument_list|(
parameter_list|(
name|name
parameter_list|,
name|s
parameter_list|)
lambda|->
name|displayCSV
argument_list|(
name|fmt
argument_list|,
name|name
argument_list|,
name|s
argument_list|,
name|separator
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
end_class

end_unit

