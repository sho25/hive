begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
operator|.
name|join
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
operator|.
name|normalizeSpace
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
operator|.
name|repeat
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|Warehouse
operator|.
name|DEFAULT_CATALOG_NAME
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jdo
operator|.
name|PersistenceManager
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jdo
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jdo
operator|.
name|Transaction
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jdo
operator|.
name|datastore
operator|.
name|JDOConnection
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|AggregateStatsCache
operator|.
name|AggrColStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|AggrStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ColumnStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ColumnStatisticsData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ColumnStatisticsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ColumnStatisticsObj
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Database
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|GetPartitionsFilterSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|HiveObjectPrivilege
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|HiveObjectRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|HiveObjectType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|MetaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Order
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Partition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|PrincipalType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|PrivilegeGrantInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLCheckConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLDefaultConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLForeignKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLNotNullConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLPrimaryKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLUniqueConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SerDeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SkewedInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|StorageDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|conf
operator|.
name|MetastoreConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|conf
operator|.
name|MetastoreConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|model
operator|.
name|MConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|model
operator|.
name|MCreationMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|model
operator|.
name|MDatabase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|model
operator|.
name|MNotificationLog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|model
operator|.
name|MNotificationNextId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|model
operator|.
name|MPartitionColumnPrivilege
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|model
operator|.
name|MPartitionColumnStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|model
operator|.
name|MPartitionPrivilege
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|model
operator|.
name|MTableColumnStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|model
operator|.
name|MWMResourcePlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|parser
operator|.
name|ExpressionTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|parser
operator|.
name|ExpressionTree
operator|.
name|FilterBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|parser
operator|.
name|ExpressionTree
operator|.
name|LeafNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|parser
operator|.
name|ExpressionTree
operator|.
name|LogicalOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|parser
operator|.
name|ExpressionTree
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|parser
operator|.
name|ExpressionTree
operator|.
name|TreeNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|parser
operator|.
name|ExpressionTree
operator|.
name|TreeVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|utils
operator|.
name|MetaStoreServerUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|utils
operator|.
name|MetaStoreUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|utils
operator|.
name|MetaStoreServerUtils
operator|.
name|ColStatsObjWithSourceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|common
operator|.
name|util
operator|.
name|BloomFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|datanucleus
operator|.
name|store
operator|.
name|rdbms
operator|.
name|query
operator|.
name|ForwardQueryResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * This class contains the optimizations for MetaStore that rely on direct SQL access to  * the underlying database. It should use ANSI SQL and be compatible with common databases  * such as MySQL (note that MySQL doesn't use full ANSI mode by default), Postgres, etc.  *  * As of now, only the partition retrieval is done this way to improve job startup time;  * JDOQL partition retrieval is still present so as not to limit the ORM solution we have  * to SQL stores only. There's always a way to do without direct SQL.  */
end_comment

begin_class
class|class
name|MetaStoreDirectSql
block|{
specifier|private
specifier|static
specifier|final
name|int
name|NO_BATCHING
init|=
operator|-
literal|1
decl_stmt|,
name|DETECT_BATCHING
init|=
literal|0
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MetaStoreDirectSql
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|PersistenceManager
name|pm
decl_stmt|;
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
specifier|private
specifier|final
name|String
name|schema
decl_stmt|;
comment|/**    * We want to avoid db-specific code in this class and stick with ANSI SQL. However:    * 1) mysql and postgres are differently ansi-incompatible (mysql by default doesn't support    * quoted identifiers, and postgres contravenes ANSI by coercing unquoted ones to lower case).    * MySQL's way of working around this is simpler (just set ansi quotes mode on), so we will    * use that. MySQL detection is done by actually issuing the set-ansi-quotes command;    *    * Use sparingly, we don't want to devolve into another DataNucleus...    */
specifier|private
specifier|final
name|DatabaseProduct
name|dbType
decl_stmt|;
specifier|private
specifier|final
name|int
name|batchSize
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|convertMapNullsToEmptyStrings
decl_stmt|;
specifier|private
specifier|final
name|String
name|defaultPartName
decl_stmt|;
comment|/**    * Whether direct SQL can be used with the current datastore backing {@link #pm}.    */
specifier|private
specifier|final
name|boolean
name|isCompatibleDatastore
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|isAggregateStatsCacheEnabled
decl_stmt|;
specifier|private
specifier|final
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|fieldnameToTableName
decl_stmt|;
specifier|private
name|AggregateStatsCache
name|aggrStatsCache
decl_stmt|;
comment|/**    * This method returns a comma separated string consisting of String values of a given list.    * This is used for preparing "SOMETHING_ID in (...)" to use in SQL queries.    * @param objectIds the objectId collection    * @return The concatenated list    * @throws MetaException If the list contains wrong data    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|String
name|getIdListForIn
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|objectIds
parameter_list|)
throws|throws
name|MetaException
block|{
return|return
name|objectIds
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|i
lambda|->
name|i
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|joining
argument_list|(
literal|","
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Target
argument_list|(
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|ElementType
operator|.
name|FIELD
argument_list|)
annotation|@
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Retention
argument_list|(
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
specifier|private
annotation_defn|@interface
name|TableName
block|{}
comment|// Table names with schema name, if necessary
annotation|@
name|TableName
specifier|private
name|String
name|DBS
decl_stmt|,
name|TBLS
decl_stmt|,
name|PARTITIONS
decl_stmt|,
name|DATABASE_PARAMS
decl_stmt|,
name|PARTITION_PARAMS
decl_stmt|,
name|SORT_COLS
decl_stmt|,
name|SD_PARAMS
decl_stmt|,
name|SDS
decl_stmt|,
name|SERDES
decl_stmt|,
name|SKEWED_STRING_LIST_VALUES
decl_stmt|,
name|SKEWED_VALUES
decl_stmt|,
name|BUCKETING_COLS
decl_stmt|,
name|SKEWED_COL_NAMES
decl_stmt|,
name|SKEWED_COL_VALUE_LOC_MAP
decl_stmt|,
name|COLUMNS_V2
decl_stmt|,
name|PARTITION_KEYS
decl_stmt|,
name|SERDE_PARAMS
decl_stmt|,
name|PART_COL_STATS
decl_stmt|,
name|KEY_CONSTRAINTS
decl_stmt|,
name|TAB_COL_STATS
decl_stmt|,
name|PARTITION_KEY_VALS
decl_stmt|,
name|PART_PRIVS
decl_stmt|,
name|PART_COL_PRIVS
decl_stmt|,
name|SKEWED_STRING_LIST
decl_stmt|,
name|CDS
decl_stmt|,
name|TBL_COL_PRIVS
decl_stmt|;
specifier|public
name|MetaStoreDirectSql
parameter_list|(
name|PersistenceManager
name|pm
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|String
name|schema
parameter_list|)
block|{
name|this
operator|.
name|pm
operator|=
name|pm
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|schema
operator|=
name|schema
expr_stmt|;
name|DatabaseProduct
name|dbType
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbType
operator|=
name|DatabaseProduct
operator|.
name|determineDatabaseProduct
argument_list|(
name|getProductName
argument_list|(
name|pm
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot determine database product; assuming OTHER"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|dbType
operator|=
name|DatabaseProduct
operator|.
name|OTHER
expr_stmt|;
block|}
name|this
operator|.
name|dbType
operator|=
name|dbType
expr_stmt|;
name|int
name|batchSize
init|=
name|MetastoreConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|DIRECT_SQL_PARTITION_BATCH_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|batchSize
operator|==
name|DETECT_BATCHING
condition|)
block|{
name|batchSize
operator|=
name|DatabaseProduct
operator|.
name|needsInBatching
argument_list|(
name|dbType
argument_list|)
condition|?
literal|1000
else|:
name|NO_BATCHING
expr_stmt|;
block|}
name|this
operator|.
name|batchSize
operator|=
name|batchSize
expr_stmt|;
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|fieldNameToTableNameBuilder
init|=
operator|new
name|ImmutableMap
operator|.
name|Builder
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|f
range|:
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getDeclaredFields
argument_list|()
control|)
block|{
if|if
condition|(
name|f
operator|.
name|getAnnotation
argument_list|(
name|TableName
operator|.
name|class
argument_list|)
operator|==
literal|null
condition|)
continue|continue;
try|try
block|{
name|String
name|value
init|=
name|getFullyQualifiedName
argument_list|(
name|schema
argument_list|,
name|f
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|f
operator|.
name|set
argument_list|(
name|this
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|fieldNameToTableNameBuilder
operator|.
name|put
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
decl||
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Internal error, cannot set "
operator|+
name|f
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
name|convertMapNullsToEmptyStrings
operator|=
name|MetastoreConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|ORM_RETRIEVE_MAPNULLS_AS_EMPTY_STRINGS
argument_list|)
expr_stmt|;
name|defaultPartName
operator|=
name|MetastoreConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|DEFAULTPARTITIONNAME
argument_list|)
expr_stmt|;
name|String
name|jdoIdFactory
init|=
name|MetastoreConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|IDENTIFIER_FACTORY
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
literal|"datanucleus1"
operator|.
name|equalsIgnoreCase
argument_list|(
name|jdoIdFactory
argument_list|)
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Underlying metastore does not use 'datanucleus1' for its ORM naming scheme."
operator|+
literal|" Disabling directSQL as it uses hand-hardcoded SQL with that assumption."
argument_list|)
expr_stmt|;
name|isCompatibleDatastore
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|isInTest
init|=
name|MetastoreConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_IN_TEST
argument_list|)
decl_stmt|;
name|isCompatibleDatastore
operator|=
operator|(
operator|!
name|isInTest
operator|||
name|ensureDbInit
argument_list|()
operator|)
operator|&&
name|runTestQuery
argument_list|()
expr_stmt|;
if|if
condition|(
name|isCompatibleDatastore
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using direct SQL, underlying DB is "
operator|+
name|dbType
argument_list|)
expr_stmt|;
block|}
block|}
name|isAggregateStatsCacheEnabled
operator|=
name|MetastoreConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|AGGREGATE_STATS_CACHE_ENABLED
argument_list|)
expr_stmt|;
if|if
condition|(
name|isAggregateStatsCacheEnabled
condition|)
block|{
name|aggrStatsCache
operator|=
name|AggregateStatsCache
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|// now use the tableanames to create the mapping
comment|// note that some of the optional single-valued fields are not present
name|fieldnameToTableName
operator|=
name|fieldNameToTableNameBuilder
operator|.
name|put
argument_list|(
literal|"createTime"
argument_list|,
name|PARTITIONS
operator|+
literal|".\"CREATE_TIME\""
argument_list|)
operator|.
name|put
argument_list|(
literal|"lastAccessTime"
argument_list|,
name|PARTITIONS
operator|+
literal|".\"LAST_ACCESS_TIME\""
argument_list|)
operator|.
name|put
argument_list|(
literal|"writeId"
argument_list|,
name|PARTITIONS
operator|+
literal|".\"WRITE_ID\""
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.location"
argument_list|,
name|SDS
operator|+
literal|".\"LOCATION\""
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.inputFormat"
argument_list|,
name|SDS
operator|+
literal|".\"INPUT_FORMAT\""
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.outputFormat"
argument_list|,
name|SDS
operator|+
literal|".\"OUTPUT_FORMAT\""
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.storedAsSubDirectories"
argument_list|,
name|SDS
operator|+
literal|".\"IS_STOREDASSUBDIRECTORIES\""
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.compressed"
argument_list|,
name|SDS
operator|+
literal|".\"IS_COMPRESSED\""
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.numBuckets"
argument_list|,
name|SDS
operator|+
literal|".\"NUM_BUCKETS\""
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.serdeInfo.name"
argument_list|,
name|SERDES
operator|+
literal|".\"NAME\""
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.serdeInfo.serializationLib"
argument_list|,
name|SERDES
operator|+
literal|".\"SLIB\""
argument_list|)
operator|.
name|put
argument_list|(
literal|"PART_ID"
argument_list|,
name|PARTITIONS
operator|+
literal|".\"PART_ID\""
argument_list|)
operator|.
name|put
argument_list|(
literal|"SD_ID"
argument_list|,
name|SDS
operator|+
literal|".\"SD_ID\""
argument_list|)
operator|.
name|put
argument_list|(
literal|"SERDE_ID"
argument_list|,
name|SERDES
operator|+
literal|".\"SERDE_ID\""
argument_list|)
operator|.
name|put
argument_list|(
literal|"CD_ID"
argument_list|,
name|SDS
operator|+
literal|".\"CD_ID\""
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
specifier|private
specifier|static
name|String
name|getFullyQualifiedName
parameter_list|(
name|String
name|schema
parameter_list|,
name|String
name|tblName
parameter_list|)
block|{
return|return
operator|(
operator|(
name|schema
operator|==
literal|null
operator|||
name|schema
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
literal|""
else|:
literal|"\""
operator|+
name|schema
operator|+
literal|"\".\""
operator|)
operator|+
literal|"\""
operator|+
name|tblName
operator|+
literal|"\""
return|;
block|}
specifier|public
name|MetaStoreDirectSql
parameter_list|(
name|PersistenceManager
name|pm
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
argument_list|(
name|pm
argument_list|,
name|conf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
specifier|static
name|String
name|getProductName
parameter_list|(
name|PersistenceManager
name|pm
parameter_list|)
block|{
name|JDOConnection
name|jdoConn
init|=
name|pm
operator|.
name|getDataStoreConnection
argument_list|()
decl_stmt|;
try|try
block|{
return|return
operator|(
operator|(
name|Connection
operator|)
name|jdoConn
operator|.
name|getNativeConnection
argument_list|()
operator|)
operator|.
name|getMetaData
argument_list|()
operator|.
name|getDatabaseProductName
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error retrieving product name"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|jdoConn
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// We must release the connection before we call other pm methods.
block|}
block|}
specifier|private
name|boolean
name|ensureDbInit
parameter_list|()
block|{
name|Transaction
name|tx
init|=
name|pm
operator|.
name|currentTransaction
argument_list|()
decl_stmt|;
name|boolean
name|doCommit
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|tx
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|tx
operator|.
name|begin
argument_list|()
expr_stmt|;
name|doCommit
operator|=
literal|true
expr_stmt|;
block|}
name|LinkedList
argument_list|<
name|Query
argument_list|>
name|initQueries
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
try|try
block|{
comment|// Force the underlying db to initialize.
name|initQueries
operator|.
name|add
argument_list|(
name|pm
operator|.
name|newQuery
argument_list|(
name|MDatabase
operator|.
name|class
argument_list|,
literal|"name == ''"
argument_list|)
argument_list|)
expr_stmt|;
name|initQueries
operator|.
name|add
argument_list|(
name|pm
operator|.
name|newQuery
argument_list|(
name|MTableColumnStatistics
operator|.
name|class
argument_list|,
literal|"dbName == ''"
argument_list|)
argument_list|)
expr_stmt|;
name|initQueries
operator|.
name|add
argument_list|(
name|pm
operator|.
name|newQuery
argument_list|(
name|MPartitionColumnStatistics
operator|.
name|class
argument_list|,
literal|"dbName == ''"
argument_list|)
argument_list|)
expr_stmt|;
name|initQueries
operator|.
name|add
argument_list|(
name|pm
operator|.
name|newQuery
argument_list|(
name|MConstraint
operator|.
name|class
argument_list|,
literal|"childIntegerIndex< 0"
argument_list|)
argument_list|)
expr_stmt|;
name|initQueries
operator|.
name|add
argument_list|(
name|pm
operator|.
name|newQuery
argument_list|(
name|MNotificationLog
operator|.
name|class
argument_list|,
literal|"dbName == ''"
argument_list|)
argument_list|)
expr_stmt|;
name|initQueries
operator|.
name|add
argument_list|(
name|pm
operator|.
name|newQuery
argument_list|(
name|MNotificationNextId
operator|.
name|class
argument_list|,
literal|"nextEventId< -1"
argument_list|)
argument_list|)
expr_stmt|;
name|initQueries
operator|.
name|add
argument_list|(
name|pm
operator|.
name|newQuery
argument_list|(
name|MWMResourcePlan
operator|.
name|class
argument_list|,
literal|"name == ''"
argument_list|)
argument_list|)
expr_stmt|;
name|initQueries
operator|.
name|add
argument_list|(
name|pm
operator|.
name|newQuery
argument_list|(
name|MCreationMetadata
operator|.
name|class
argument_list|,
literal|"dbName == ''"
argument_list|)
argument_list|)
expr_stmt|;
name|initQueries
operator|.
name|add
argument_list|(
name|pm
operator|.
name|newQuery
argument_list|(
name|MPartitionPrivilege
operator|.
name|class
argument_list|,
literal|"principalName == ''"
argument_list|)
argument_list|)
expr_stmt|;
name|initQueries
operator|.
name|add
argument_list|(
name|pm
operator|.
name|newQuery
argument_list|(
name|MPartitionColumnPrivilege
operator|.
name|class
argument_list|,
literal|"principalName == ''"
argument_list|)
argument_list|)
expr_stmt|;
name|Query
name|q
decl_stmt|;
while|while
condition|(
operator|(
name|q
operator|=
name|initQueries
operator|.
name|peekFirst
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|q
operator|.
name|execute
argument_list|()
expr_stmt|;
name|initQueries
operator|.
name|pollFirst
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|doCommit
operator|=
literal|false
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Database initialization failed; direct SQL is disabled"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|tx
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|doCommit
condition|)
block|{
name|tx
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Query
name|q
range|:
name|initQueries
control|)
block|{
try|try
block|{
name|q
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{         }
block|}
block|}
block|}
specifier|private
name|boolean
name|runTestQuery
parameter_list|()
block|{
name|Transaction
name|tx
init|=
name|pm
operator|.
name|currentTransaction
argument_list|()
decl_stmt|;
name|boolean
name|doCommit
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|tx
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|tx
operator|.
name|begin
argument_list|()
expr_stmt|;
name|doCommit
operator|=
literal|true
expr_stmt|;
block|}
name|Query
name|query
init|=
literal|null
decl_stmt|;
comment|// Run a self-test query. If it doesn't work, we will self-disable. What a PITA...
name|String
name|selfTestQuery
init|=
literal|"select \"DB_ID\" from "
operator|+
name|DBS
operator|+
literal|""
decl_stmt|;
try|try
block|{
name|prepareTxn
argument_list|()
expr_stmt|;
name|query
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|selfTestQuery
argument_list|)
expr_stmt|;
name|query
operator|.
name|execute
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|doCommit
operator|=
literal|false
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Self-test query ["
operator|+
name|selfTestQuery
operator|+
literal|"] failed; direct SQL is disabled"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|tx
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|doCommit
condition|)
block|{
name|tx
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|query
operator|!=
literal|null
condition|)
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|String
name|getSchema
parameter_list|()
block|{
return|return
name|schema
return|;
block|}
specifier|public
name|boolean
name|isCompatibleDatastore
parameter_list|()
block|{
return|return
name|isCompatibleDatastore
return|;
block|}
specifier|private
name|void
name|executeNoResult
parameter_list|(
specifier|final
name|String
name|queryText
parameter_list|)
throws|throws
name|SQLException
block|{
name|JDOConnection
name|jdoConn
init|=
name|pm
operator|.
name|getDataStoreConnection
argument_list|()
decl_stmt|;
name|Statement
name|statement
init|=
literal|null
decl_stmt|;
name|boolean
name|doTrace
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
try|try
block|{
name|long
name|start
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|statement
operator|=
operator|(
operator|(
name|Connection
operator|)
name|jdoConn
operator|.
name|getNativeConnection
argument_list|()
operator|)
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|statement
operator|.
name|execute
argument_list|(
name|queryText
argument_list|)
expr_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|statement
operator|!=
literal|null
condition|)
block|{
name|statement
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|jdoConn
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// We must release the connection before we call other pm methods.
block|}
block|}
specifier|public
name|Database
name|getDatabase
parameter_list|(
name|String
name|catName
parameter_list|,
name|String
name|dbName
parameter_list|)
throws|throws
name|MetaException
block|{
name|Query
name|queryDbSelector
init|=
literal|null
decl_stmt|;
name|Query
name|queryDbParams
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbName
operator|=
name|dbName
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|catName
operator|=
name|catName
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|String
name|queryTextDbSelector
init|=
literal|"select "
operator|+
literal|"\"DB_ID\", \"NAME\", \"DB_LOCATION_URI\", \"DESC\", "
operator|+
literal|"\"OWNER_NAME\", \"OWNER_TYPE\", \"CTLG_NAME\" , \"CREATE_TIME\""
operator|+
literal|"FROM "
operator|+
name|DBS
operator|+
literal|" where \"NAME\" = ? and \"CTLG_NAME\" = ? "
decl_stmt|;
name|Object
index|[]
name|params
init|=
operator|new
name|Object
index|[]
block|{
name|dbName
block|,
name|catName
block|}
decl_stmt|;
name|queryDbSelector
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryTextDbSelector
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"getDatabase:query instantiated : "
operator|+
name|queryTextDbSelector
operator|+
literal|" with param ["
operator|+
name|params
index|[
literal|0
index|]
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|sqlResult
init|=
name|executeWithArray
argument_list|(
name|queryDbSelector
argument_list|,
name|params
argument_list|,
name|queryTextDbSelector
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|sqlResult
operator|==
literal|null
operator|)
operator|||
name|sqlResult
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
assert|assert
operator|(
name|sqlResult
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
assert|;
if|if
condition|(
name|sqlResult
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Object
index|[]
name|dbline
init|=
name|sqlResult
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Long
name|dbid
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlLong
argument_list|(
name|dbline
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|String
name|queryTextDbParams
init|=
literal|"select \"PARAM_KEY\", \"PARAM_VALUE\" "
operator|+
literal|" from "
operator|+
name|DATABASE_PARAMS
operator|+
literal|" "
operator|+
literal|" WHERE \"DB_ID\" = ? "
operator|+
literal|" AND \"PARAM_KEY\" IS NOT NULL"
decl_stmt|;
name|params
index|[
literal|0
index|]
operator|=
name|dbid
expr_stmt|;
name|queryDbParams
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryTextDbParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"getDatabase:query2 instantiated : "
operator|+
name|queryTextDbParams
operator|+
literal|" with param ["
operator|+
name|params
index|[
literal|0
index|]
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|dbParams
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|sqlResult2
init|=
name|MetastoreDirectSqlUtils
operator|.
name|ensureList
argument_list|(
name|executeWithArray
argument_list|(
name|queryDbParams
argument_list|,
name|params
argument_list|,
name|queryTextDbParams
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sqlResult2
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Object
index|[]
name|line
range|:
name|sqlResult2
control|)
block|{
name|dbParams
operator|.
name|put
argument_list|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Database
name|db
init|=
operator|new
name|Database
argument_list|()
decl_stmt|;
name|db
operator|.
name|setName
argument_list|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|dbline
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|.
name|setLocationUri
argument_list|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|dbline
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|.
name|setDescription
argument_list|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|dbline
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|.
name|setOwnerName
argument_list|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|dbline
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|type
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|dbline
index|[
literal|5
index|]
argument_list|)
decl_stmt|;
name|db
operator|.
name|setOwnerType
argument_list|(
operator|(
literal|null
operator|==
name|type
operator|||
name|type
operator|.
name|trim
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
literal|null
else|:
name|PrincipalType
operator|.
name|valueOf
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|.
name|setCatalogName
argument_list|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|dbline
index|[
literal|6
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|.
name|setCreateTime
argument_list|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlInt
argument_list|(
name|dbline
index|[
literal|7
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|.
name|setParameters
argument_list|(
name|MetaStoreServerUtils
operator|.
name|trimMapNulls
argument_list|(
name|dbParams
argument_list|,
name|convertMapNullsToEmptyStrings
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"getDatabase: directsql returning db "
operator|+
name|db
operator|.
name|getName
argument_list|()
operator|+
literal|" locn["
operator|+
name|db
operator|.
name|getLocationUri
argument_list|()
operator|+
literal|"] desc ["
operator|+
name|db
operator|.
name|getDescription
argument_list|()
operator|+
literal|"] owner ["
operator|+
name|db
operator|.
name|getOwnerName
argument_list|()
operator|+
literal|"] ownertype ["
operator|+
name|db
operator|.
name|getOwnerType
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
return|return
name|db
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|queryDbSelector
operator|!=
literal|null
condition|)
block|{
name|queryDbSelector
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|queryDbParams
operator|!=
literal|null
condition|)
block|{
name|queryDbParams
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Get table names by using direct SQL queries.    * @param catName catalog name    * @param dbName Metastore database namme    * @param tableType Table type, or null if we want to get all tables    * @return list of table names    */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getTables
parameter_list|(
name|String
name|catName
parameter_list|,
name|String
name|dbName
parameter_list|,
name|TableType
name|tableType
parameter_list|,
name|int
name|limit
parameter_list|)
throws|throws
name|MetaException
block|{
name|String
name|queryText
init|=
literal|"SELECT "
operator|+
name|TBLS
operator|+
literal|".\"TBL_NAME\""
operator|+
literal|" FROM "
operator|+
name|TBLS
operator|+
literal|" "
operator|+
literal|" INNER JOIN "
operator|+
name|DBS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"DB_ID\" = "
operator|+
name|DBS
operator|+
literal|".\"DB_ID\" "
operator|+
literal|" WHERE "
operator|+
name|DBS
operator|+
literal|".\"NAME\" = ? AND "
operator|+
name|DBS
operator|+
literal|".\"CTLG_NAME\" = ? "
operator|+
operator|(
name|tableType
operator|==
literal|null
condition|?
literal|""
else|:
literal|"AND "
operator|+
name|TBLS
operator|+
literal|".\"TBL_TYPE\" = ? "
operator|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|pms
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|pms
operator|.
name|add
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|pms
operator|.
name|add
argument_list|(
name|catName
argument_list|)
expr_stmt|;
if|if
condition|(
name|tableType
operator|!=
literal|null
condition|)
block|{
name|pms
operator|.
name|add
argument_list|(
name|tableType
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Query
argument_list|<
name|?
argument_list|>
name|queryParams
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
return|return
name|executeWithArray
argument_list|(
name|queryParams
argument_list|,
name|pms
operator|.
name|toArray
argument_list|()
argument_list|,
name|queryText
argument_list|,
name|limit
argument_list|)
return|;
block|}
comment|/**    * Get table names by using direct SQL queries.    *    * @param dbName Metastore database namme    * @return list of table names    */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getMaterializedViewsForRewriting
parameter_list|(
name|String
name|dbName
parameter_list|)
throws|throws
name|MetaException
block|{
name|String
name|queryText
init|=
literal|"SELECT "
operator|+
name|TBLS
operator|+
literal|".\"TBL_NAME\""
operator|+
literal|" FROM "
operator|+
name|TBLS
operator|+
literal|" "
operator|+
literal|" INNER JOIN "
operator|+
name|DBS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"DB_ID\" = "
operator|+
name|DBS
operator|+
literal|".\"DB_ID\" "
operator|+
literal|" WHERE "
operator|+
name|DBS
operator|+
literal|".\"NAME\" = ? AND "
operator|+
name|TBLS
operator|+
literal|".\"TBL_TYPE\" = ? "
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|pms
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|pms
operator|.
name|add
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|pms
operator|.
name|add
argument_list|(
name|TableType
operator|.
name|MATERIALIZED_VIEW
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|Query
argument_list|<
name|?
argument_list|>
name|queryParams
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
return|return
name|executeWithArray
argument_list|(
name|queryParams
argument_list|,
name|pms
operator|.
name|toArray
argument_list|()
argument_list|,
name|queryText
argument_list|)
return|;
block|}
comment|/**    * Gets partitions by using direct SQL queries.    * @param catName Metastore catalog name.    * @param dbName Metastore db name.    * @param tblName Metastore table name.    * @param partNames Partition names to get.    * @return List of partitions.    */
specifier|public
name|List
argument_list|<
name|Partition
argument_list|>
name|getPartitionsViaSqlFilter
parameter_list|(
specifier|final
name|String
name|catName
parameter_list|,
specifier|final
name|String
name|dbName
parameter_list|,
specifier|final
name|String
name|tblName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|partNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
return|return
name|Batchable
operator|.
name|runBatched
argument_list|(
name|batchSize
argument_list|,
name|partNames
argument_list|,
operator|new
name|Batchable
argument_list|<
name|String
argument_list|,
name|Partition
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Partition
argument_list|>
name|run
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|input
parameter_list|)
throws|throws
name|MetaException
block|{
name|String
name|filter
init|=
literal|""
operator|+
name|PARTITIONS
operator|+
literal|".\"PART_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|input
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|partitionIds
init|=
name|getPartitionIdsViaSqlFilter
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tblName
argument_list|,
name|filter
argument_list|,
name|input
argument_list|,
name|Collections
operator|.
expr|<
name|String
operator|>
name|emptyList
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|partitionIds
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
comment|// no partitions, bail early.
block|}
return|return
name|getPartitionsFromPartitionIds
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tblName
argument_list|,
literal|null
argument_list|,
name|partitionIds
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Gets partitions by using direct SQL queries.    * @param filter The filter.    * @param max The maximum number of partitions to return.    * @return List of partitions.    */
specifier|public
name|List
argument_list|<
name|Partition
argument_list|>
name|getPartitionsViaSqlFilter
parameter_list|(
name|SqlFilterForPushdown
name|filter
parameter_list|,
name|Integer
name|max
parameter_list|)
throws|throws
name|MetaException
block|{
name|Boolean
name|isViewTable
init|=
name|isViewTable
argument_list|(
name|filter
operator|.
name|table
argument_list|)
decl_stmt|;
name|String
name|catName
init|=
name|filter
operator|.
name|table
operator|.
name|isSetCatName
argument_list|()
condition|?
name|filter
operator|.
name|table
operator|.
name|getCatName
argument_list|()
else|:
name|DEFAULT_CATALOG_NAME
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|partitionIds
init|=
name|getPartitionIdsViaSqlFilter
argument_list|(
name|catName
argument_list|,
name|filter
operator|.
name|table
operator|.
name|getDbName
argument_list|()
argument_list|,
name|filter
operator|.
name|table
operator|.
name|getTableName
argument_list|()
argument_list|,
name|filter
operator|.
name|filter
argument_list|,
name|filter
operator|.
name|params
argument_list|,
name|filter
operator|.
name|joins
argument_list|,
name|max
argument_list|)
decl_stmt|;
if|if
condition|(
name|partitionIds
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
comment|// no partitions, bail early.
block|}
return|return
name|Batchable
operator|.
name|runBatched
argument_list|(
name|batchSize
argument_list|,
name|partitionIds
argument_list|,
operator|new
name|Batchable
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Partition
argument_list|>
name|run
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|input
parameter_list|)
throws|throws
name|MetaException
block|{
return|return
name|getPartitionsFromPartitionIds
argument_list|(
name|catName
argument_list|,
name|filter
operator|.
name|table
operator|.
name|getDbName
argument_list|()
argument_list|,
name|filter
operator|.
name|table
operator|.
name|getTableName
argument_list|()
argument_list|,
name|isViewTable
argument_list|,
name|input
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * This method can be used to return "partially-filled" partitions when clients are only interested in    * some fields of the Partition objects. The partitionFields parameter is a list of dot separated    * partition field names. For example, if a client is interested in only partition location,    * serializationLib, values and parameters it can specify sd.location, sd.serdeInfo.serializationLib,    * values, parameters in the partitionFields list. In such a case all the returned partitions will have    * only the requested fields set and the rest of the fields will remain unset. The implementation of this method    * runs queries only for the fields which are requested and pushes down the projection to the database to improve    * performance.    *    * @param tbl                    Table whose partitions are being requested    * @param partitionFields        List of dot separated field names. Each dot separated string represents nested levels. For    *                               instance sd.serdeInfo.serializationLib represents the serializationLib field of the StorageDescriptor    *                               for a the partition    * @param includeParamKeyPattern The SQL regex pattern which is used to include the parameter keys. Can include _ or %    *                               When this pattern is set, only the partition parameter key-value pairs where the key matches    *                               the pattern will be returned. This is applied in conjunction with excludeParamKeyPattern if it is set.    * @param excludeParamKeyPattern The SQL regex paterrn which is used to exclude the parameter keys. Can include _ or %    *                               When this pattern is set, all the partition parameters where key is NOT LIKE the pattern    *                               are returned. This is applied in conjunction with the includeParamKeyPattern if it is set.    * @param filterSpec             The filterSpec from<code>GetPartitionsRequest</code> which includes the filter mode (BY_EXPR, BY_VALUES or BY_NAMES)    *                               and the list of filter strings to be used to filter the results    * @param filter                 SqlFilterForPushDown which is set in the<code>canUseDirectSql</code> method before this method is called.    *                               The filter is used only when the mode is BY_EXPR    * @return    * @throws MetaException    */
specifier|public
name|List
argument_list|<
name|Partition
argument_list|>
name|getPartitionsUsingProjectionAndFilterSpec
parameter_list|(
name|Table
name|tbl
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|partitionFields
parameter_list|,
specifier|final
name|String
name|includeParamKeyPattern
parameter_list|,
specifier|final
name|String
name|excludeParamKeyPattern
parameter_list|,
name|GetPartitionsFilterSpec
name|filterSpec
parameter_list|,
name|SqlFilterForPushdown
name|filter
parameter_list|)
throws|throws
name|MetaException
block|{
specifier|final
name|String
name|tblName
init|=
name|tbl
operator|.
name|getTableName
argument_list|()
decl_stmt|;
specifier|final
name|String
name|dbName
init|=
name|tbl
operator|.
name|getDbName
argument_list|()
decl_stmt|;
specifier|final
name|String
name|catName
init|=
name|tbl
operator|.
name|getCatName
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|partitionIds
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|filterSpec
operator|.
name|isSetFilterMode
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|filters
init|=
name|filterSpec
operator|.
name|getFilters
argument_list|()
decl_stmt|;
if|if
condition|(
name|filters
operator|==
literal|null
operator|||
name|filters
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Invalid filter expressions in the filter spec"
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|filterSpec
operator|.
name|getFilterMode
argument_list|()
condition|)
block|{
case|case
name|BY_EXPR
case|:
name|partitionIds
operator|=
name|getPartitionIdsViaSqlFilter
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tblName
argument_list|,
name|filter
operator|.
name|filter
argument_list|,
name|filter
operator|.
name|params
argument_list|,
name|filter
operator|.
name|joins
argument_list|,
literal|null
argument_list|)
expr_stmt|;
break|break;
case|case
name|BY_NAMES
case|:
name|String
name|partNamesFilter
init|=
literal|""
operator|+
name|PARTITIONS
operator|+
literal|".\"PART_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|filterSpec
operator|.
name|getFilters
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
decl_stmt|;
name|partitionIds
operator|=
name|getPartitionIdsViaSqlFilter
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tblName
argument_list|,
name|partNamesFilter
argument_list|,
name|filterSpec
operator|.
name|getFilters
argument_list|()
argument_list|,
name|Collections
operator|.
name|EMPTY_LIST
argument_list|,
literal|null
argument_list|)
expr_stmt|;
break|break;
case|case
name|BY_VALUES
case|:
comment|// we are going to use the SQL regex pattern in the LIKE clause below. So the default string
comment|// is _% and not .*
name|String
name|partNameMatcher
init|=
name|MetaStoreUtils
operator|.
name|makePartNameMatcher
argument_list|(
name|tbl
argument_list|,
name|filters
argument_list|,
literal|"_%"
argument_list|)
decl_stmt|;
name|String
name|partNamesLikeFilter
init|=
literal|""
operator|+
name|PARTITIONS
operator|+
literal|".\"PART_NAME\" LIKE (?)"
decl_stmt|;
name|partitionIds
operator|=
name|getPartitionIdsViaSqlFilter
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tblName
argument_list|,
name|partNamesLikeFilter
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|partNameMatcher
argument_list|)
argument_list|,
name|Collections
operator|.
name|EMPTY_LIST
argument_list|,
literal|null
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unsupported filter mode "
operator|+
name|filterSpec
operator|.
name|getFilterMode
argument_list|()
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// there is no filter mode. Fetch all the partition ids
name|partitionIds
operator|=
name|getPartitionIdsViaSqlFilter
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tblName
argument_list|,
literal|null
argument_list|,
name|Collections
operator|.
name|EMPTY_LIST
argument_list|,
name|Collections
operator|.
name|EMPTY_LIST
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|partitionIds
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
comment|// check if table object has table type as view
name|Boolean
name|isView
init|=
name|isViewTable
argument_list|(
name|tbl
argument_list|)
decl_stmt|;
if|if
condition|(
name|isView
operator|==
literal|null
condition|)
block|{
name|isView
operator|=
name|isViewTable
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tblName
argument_list|)
expr_stmt|;
block|}
name|PartitionProjectionEvaluator
name|projectionEvaluator
init|=
operator|new
name|PartitionProjectionEvaluator
argument_list|(
name|pm
argument_list|,
name|fieldnameToTableName
argument_list|,
name|partitionFields
argument_list|,
name|convertMapNullsToEmptyStrings
argument_list|,
name|isView
argument_list|,
name|includeParamKeyPattern
argument_list|,
name|excludeParamKeyPattern
argument_list|)
decl_stmt|;
comment|// Get full objects. For Oracle/etc. do it in batches.
return|return
name|Batchable
operator|.
name|runBatched
argument_list|(
name|batchSize
argument_list|,
name|partitionIds
argument_list|,
operator|new
name|Batchable
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Partition
argument_list|>
name|run
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|input
parameter_list|)
throws|throws
name|MetaException
block|{
return|return
name|projectionEvaluator
operator|.
name|getPartitionsUsingProjectionList
argument_list|(
name|input
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
specifier|public
specifier|static
class|class
name|SqlFilterForPushdown
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|Object
argument_list|>
name|params
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|joins
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|String
name|filter
decl_stmt|;
specifier|private
name|Table
name|table
decl_stmt|;
block|}
specifier|public
name|boolean
name|generateSqlFilterForPushdown
parameter_list|(
name|Table
name|table
parameter_list|,
name|ExpressionTree
name|tree
parameter_list|,
name|SqlFilterForPushdown
name|result
parameter_list|)
throws|throws
name|MetaException
block|{
return|return
name|generateSqlFilterForPushdown
argument_list|(
name|table
argument_list|,
name|tree
argument_list|,
literal|null
argument_list|,
name|result
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|generateSqlFilterForPushdown
parameter_list|(
name|Table
name|table
parameter_list|,
name|ExpressionTree
name|tree
parameter_list|,
name|String
name|defaultPartitionName
parameter_list|,
name|SqlFilterForPushdown
name|result
parameter_list|)
throws|throws
name|MetaException
block|{
comment|// Derby and Oracle do not interpret filters ANSI-properly in some cases and need a workaround.
name|boolean
name|dbHasJoinCastBug
init|=
name|DatabaseProduct
operator|.
name|hasJoinOperationOrderBug
argument_list|(
name|dbType
argument_list|)
decl_stmt|;
name|result
operator|.
name|table
operator|=
name|table
expr_stmt|;
name|result
operator|.
name|filter
operator|=
name|PartitionFilterGenerator
operator|.
name|generateSqlFilter
argument_list|(
name|table
argument_list|,
name|tree
argument_list|,
name|result
operator|.
name|params
argument_list|,
name|result
operator|.
name|joins
argument_list|,
name|dbHasJoinCastBug
argument_list|,
operator|(
operator|(
name|defaultPartitionName
operator|==
literal|null
operator|)
condition|?
name|defaultPartName
else|:
name|defaultPartitionName
operator|)
argument_list|,
name|dbType
argument_list|,
name|schema
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|filter
operator|!=
literal|null
return|;
block|}
comment|/**    * Gets all partitions of a table by using direct SQL queries.    * @param catName Metastore catalog name.    * @param dbName Metastore db name.    * @param tblName Metastore table name.    * @param max The maximum number of partitions to return.    * @return List of partitions.    */
specifier|public
name|List
argument_list|<
name|Partition
argument_list|>
name|getPartitions
parameter_list|(
name|String
name|catName
parameter_list|,
name|String
name|dbName
parameter_list|,
name|String
name|tblName
parameter_list|,
name|Integer
name|max
parameter_list|)
throws|throws
name|MetaException
block|{
name|List
argument_list|<
name|Long
argument_list|>
name|partitionIds
init|=
name|getPartitionIdsViaSqlFilter
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tblName
argument_list|,
literal|null
argument_list|,
name|Collections
operator|.
expr|<
name|String
operator|>
name|emptyList
argument_list|()
argument_list|,
name|Collections
operator|.
expr|<
name|String
operator|>
name|emptyList
argument_list|()
argument_list|,
name|max
argument_list|)
decl_stmt|;
if|if
condition|(
name|partitionIds
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
comment|// no partitions, bail early.
block|}
comment|// Get full objects. For Oracle/etc. do it in batches.
name|List
argument_list|<
name|Partition
argument_list|>
name|result
init|=
name|Batchable
operator|.
name|runBatched
argument_list|(
name|batchSize
argument_list|,
name|partitionIds
argument_list|,
operator|new
name|Batchable
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Partition
argument_list|>
name|run
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|input
parameter_list|)
throws|throws
name|MetaException
block|{
return|return
name|getPartitionsFromPartitionIds
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tblName
argument_list|,
literal|null
argument_list|,
name|input
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
return|return
name|result
return|;
block|}
specifier|private
specifier|static
name|Boolean
name|isViewTable
parameter_list|(
name|Table
name|t
parameter_list|)
block|{
return|return
name|t
operator|.
name|isSetTableType
argument_list|()
condition|?
name|t
operator|.
name|getTableType
argument_list|()
operator|.
name|equals
argument_list|(
name|TableType
operator|.
name|VIRTUAL_VIEW
operator|.
name|toString
argument_list|()
argument_list|)
else|:
literal|null
return|;
block|}
specifier|private
name|boolean
name|isViewTable
parameter_list|(
name|String
name|catName
parameter_list|,
name|String
name|dbName
parameter_list|,
name|String
name|tblName
parameter_list|)
throws|throws
name|MetaException
block|{
name|Query
name|query
init|=
literal|null
decl_stmt|;
try|try
block|{
name|String
name|queryText
init|=
literal|"select \"TBL_TYPE\" from "
operator|+
name|TBLS
operator|+
literal|""
operator|+
literal|" inner join "
operator|+
name|DBS
operator|+
literal|" on "
operator|+
name|TBLS
operator|+
literal|".\"DB_ID\" = "
operator|+
name|DBS
operator|+
literal|".\"DB_ID\" "
operator|+
literal|" where "
operator|+
name|TBLS
operator|+
literal|".\"TBL_NAME\" = ? and "
operator|+
name|DBS
operator|+
literal|".\"NAME\" = ? and "
operator|+
name|DBS
operator|+
literal|".\"CTLG_NAME\" = ?"
decl_stmt|;
name|Object
index|[]
name|params
init|=
operator|new
name|Object
index|[]
block|{
name|tblName
block|,
name|dbName
block|,
name|catName
block|}
decl_stmt|;
name|query
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
name|query
operator|.
name|setUnique
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Object
name|result
init|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|params
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
return|return
operator|(
name|result
operator|!=
literal|null
operator|)
operator|&&
name|result
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|TableType
operator|.
name|VIRTUAL_VIEW
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|query
operator|!=
literal|null
condition|)
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Get partition ids for the query using direct SQL queries, to avoid bazillion    * queries created by DN retrieving stuff for each object individually.    * @param catName MetaStore catalog name    * @param dbName MetaStore db name    * @param tblName MetaStore table name    * @param sqlFilter SQL filter to use. Better be SQL92-compliant.    * @param paramsForFilter params for ?-s in SQL filter text. Params must be in order.    * @param joinsForFilter if the filter needs additional join statement, they must be in    *                       this list. Better be SQL92-compliant.    * @param max The maximum number of partitions to return.    * @return List of partition objects.    */
specifier|private
name|List
argument_list|<
name|Long
argument_list|>
name|getPartitionIdsViaSqlFilter
parameter_list|(
name|String
name|catName
parameter_list|,
name|String
name|dbName
parameter_list|,
name|String
name|tblName
parameter_list|,
name|String
name|sqlFilter
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|Object
argument_list|>
name|paramsForFilter
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|joinsForFilter
parameter_list|,
name|Integer
name|max
parameter_list|)
throws|throws
name|MetaException
block|{
name|boolean
name|doTrace
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
specifier|final
name|String
name|dbNameLcase
init|=
name|dbName
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
specifier|final
name|String
name|tblNameLcase
init|=
name|tblName
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
specifier|final
name|String
name|catNameLcase
init|=
name|normalizeSpace
argument_list|(
name|catName
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
comment|// We have to be mindful of order during filtering if we are not returning all partitions.
name|String
name|orderForFilter
init|=
operator|(
name|max
operator|!=
literal|null
operator|)
condition|?
literal|" order by \"PART_NAME\" asc"
else|:
literal|""
decl_stmt|;
name|String
name|queryText
init|=
literal|"select "
operator|+
name|PARTITIONS
operator|+
literal|".\"PART_ID\" from "
operator|+
name|PARTITIONS
operator|+
literal|""
operator|+
literal|"  inner join "
operator|+
name|TBLS
operator|+
literal|" on "
operator|+
name|PARTITIONS
operator|+
literal|".\"TBL_ID\" = "
operator|+
name|TBLS
operator|+
literal|".\"TBL_ID\" "
operator|+
literal|"    and "
operator|+
name|TBLS
operator|+
literal|".\"TBL_NAME\" = ? "
operator|+
literal|"  inner join "
operator|+
name|DBS
operator|+
literal|" on "
operator|+
name|TBLS
operator|+
literal|".\"DB_ID\" = "
operator|+
name|DBS
operator|+
literal|".\"DB_ID\" "
operator|+
literal|"     and "
operator|+
name|DBS
operator|+
literal|".\"NAME\" = ? "
operator|+
name|join
argument_list|(
name|joinsForFilter
argument_list|,
literal|' '
argument_list|)
operator|+
literal|" where "
operator|+
name|DBS
operator|+
literal|".\"CTLG_NAME\" = ? "
operator|+
operator|(
name|StringUtils
operator|.
name|isBlank
argument_list|(
name|sqlFilter
argument_list|)
condition|?
literal|""
else|:
operator|(
literal|" and "
operator|+
name|sqlFilter
operator|)
operator|)
operator|+
name|orderForFilter
decl_stmt|;
name|Object
index|[]
name|params
init|=
operator|new
name|Object
index|[
name|paramsForFilter
operator|.
name|size
argument_list|()
operator|+
literal|3
index|]
decl_stmt|;
name|params
index|[
literal|0
index|]
operator|=
name|tblNameLcase
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|dbNameLcase
expr_stmt|;
name|params
index|[
literal|2
index|]
operator|=
name|catNameLcase
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paramsForFilter
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|params
index|[
name|i
operator|+
literal|3
index|]
operator|=
name|paramsForFilter
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|long
name|start
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|Query
name|query
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|sqlResult
init|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|params
argument_list|,
name|queryText
argument_list|,
operator|(
operator|(
name|max
operator|==
literal|null
operator|)
condition|?
operator|-
literal|1
else|:
name|max
operator|.
name|intValue
argument_list|()
operator|)
argument_list|)
decl_stmt|;
name|long
name|queryTime
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|queryTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|sqlResult
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
comment|// no partitions, bail early.
block|}
name|List
argument_list|<
name|Long
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|sqlResult
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Object
name|fields
range|:
name|sqlResult
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlLong
argument_list|(
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/** Should be called with the list short enough to not trip up Oracle/etc. */
specifier|private
name|List
argument_list|<
name|Partition
argument_list|>
name|getPartitionsFromPartitionIds
parameter_list|(
name|String
name|catName
parameter_list|,
name|String
name|dbName
parameter_list|,
name|String
name|tblName
parameter_list|,
name|Boolean
name|isView
parameter_list|,
name|List
argument_list|<
name|Long
argument_list|>
name|partIdList
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|projectionFields
parameter_list|)
throws|throws
name|MetaException
block|{
name|boolean
name|doTrace
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
name|int
name|idStringWidth
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|Math
operator|.
name|log10
argument_list|(
name|partIdList
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|// 1 for comma
name|int
name|sbCapacity
init|=
name|partIdList
operator|.
name|size
argument_list|()
operator|*
name|idStringWidth
decl_stmt|;
comment|// Get most of the fields for the IDs provided.
comment|// Assume db and table names are the same for all partition, as provided in arguments.
name|String
name|partIds
init|=
name|getIdListForIn
argument_list|(
name|partIdList
argument_list|)
decl_stmt|;
name|String
name|queryText
init|=
literal|"select "
operator|+
name|PARTITIONS
operator|+
literal|".\"PART_ID\", "
operator|+
name|SDS
operator|+
literal|".\"SD_ID\", "
operator|+
name|SDS
operator|+
literal|".\"CD_ID\","
operator|+
literal|" "
operator|+
name|SERDES
operator|+
literal|".\"SERDE_ID\", "
operator|+
name|PARTITIONS
operator|+
literal|".\"CREATE_TIME\","
operator|+
literal|" "
operator|+
name|PARTITIONS
operator|+
literal|".\"LAST_ACCESS_TIME\", "
operator|+
name|SDS
operator|+
literal|".\"INPUT_FORMAT\", "
operator|+
name|SDS
operator|+
literal|".\"IS_COMPRESSED\","
operator|+
literal|" "
operator|+
name|SDS
operator|+
literal|".\"IS_STOREDASSUBDIRECTORIES\", "
operator|+
name|SDS
operator|+
literal|".\"LOCATION\", "
operator|+
name|SDS
operator|+
literal|".\"NUM_BUCKETS\","
operator|+
literal|" "
operator|+
name|SDS
operator|+
literal|".\"OUTPUT_FORMAT\", "
operator|+
name|SERDES
operator|+
literal|".\"NAME\", "
operator|+
name|SERDES
operator|+
literal|".\"SLIB\", "
operator|+
name|PARTITIONS
operator|+
literal|".\"WRITE_ID\""
operator|+
literal|" from "
operator|+
name|PARTITIONS
operator|+
literal|""
operator|+
literal|"  left outer join "
operator|+
name|SDS
operator|+
literal|" on "
operator|+
name|PARTITIONS
operator|+
literal|".\"SD_ID\" = "
operator|+
name|SDS
operator|+
literal|".\"SD_ID\" "
operator|+
literal|"  left outer join "
operator|+
name|SERDES
operator|+
literal|" on "
operator|+
name|SDS
operator|+
literal|".\"SERDE_ID\" = "
operator|+
name|SERDES
operator|+
literal|".\"SERDE_ID\" "
operator|+
literal|"where \"PART_ID\" in ("
operator|+
name|partIds
operator|+
literal|") order by \"PART_NAME\" asc"
decl_stmt|;
name|long
name|start
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|Query
name|query
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|sqlResult
init|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
literal|null
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|long
name|queryTime
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
comment|// Read all the fields and create partitions, SDs and serdes.
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
name|partitions
init|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sds
init|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|SerDeInfo
argument_list|>
name|serdes
init|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|SerDeInfo
argument_list|>
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
name|colss
init|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// Keep order by name, consistent with JDO.
name|ArrayList
argument_list|<
name|Partition
argument_list|>
name|orderedResult
init|=
operator|new
name|ArrayList
argument_list|<
name|Partition
argument_list|>
argument_list|(
name|partIdList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// Prepare StringBuilder-s for "in (...)" lists to use in one-to-many queries.
name|StringBuilder
name|sdSb
init|=
operator|new
name|StringBuilder
argument_list|(
name|sbCapacity
argument_list|)
decl_stmt|,
name|serdeSb
init|=
operator|new
name|StringBuilder
argument_list|(
name|sbCapacity
argument_list|)
decl_stmt|;
name|StringBuilder
name|colsSb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|7
argument_list|)
decl_stmt|;
comment|// We expect that there's only one field schema.
name|tblName
operator|=
name|tblName
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|dbName
operator|=
name|dbName
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|catName
operator|=
name|normalizeSpace
argument_list|(
name|catName
argument_list|)
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|partitions
operator|.
name|navigableKeySet
argument_list|()
expr_stmt|;
for|for
control|(
name|Object
index|[]
name|fields
range|:
name|sqlResult
control|)
block|{
comment|// Here comes the ugly part...
name|long
name|partitionId
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlLong
argument_list|(
name|fields
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|Long
name|sdId
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlLong
argument_list|(
name|fields
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|Long
name|colId
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlLong
argument_list|(
name|fields
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|Long
name|serdeId
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlLong
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
comment|// A partition must have at least sdId and serdeId set, or nothing set if it's a view.
if|if
condition|(
name|sdId
operator|==
literal|null
operator|||
name|serdeId
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|isView
operator|==
literal|null
condition|)
block|{
name|isView
operator|=
name|isViewTable
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tblName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sdId
operator|!=
literal|null
operator|||
name|colId
operator|!=
literal|null
operator|||
name|serdeId
operator|!=
literal|null
operator|)
operator|||
operator|!
name|isView
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unexpected null for one of the IDs, SD "
operator|+
name|sdId
operator|+
literal|", serde "
operator|+
name|serdeId
operator|+
literal|" for a "
operator|+
operator|(
name|isView
condition|?
literal|""
else|:
literal|"non-"
operator|)
operator|+
literal|" view"
argument_list|)
throw|;
block|}
block|}
name|Partition
name|part
init|=
operator|new
name|Partition
argument_list|()
decl_stmt|;
name|orderedResult
operator|.
name|add
argument_list|(
name|part
argument_list|)
expr_stmt|;
comment|// Set the collection fields; some code might not check presence before accessing them.
name|part
operator|.
name|setParameters
argument_list|(
operator|new
name|HashMap
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
name|part
operator|.
name|setValues
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|part
operator|.
name|setCatName
argument_list|(
name|catName
argument_list|)
expr_stmt|;
name|part
operator|.
name|setDbName
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|part
operator|.
name|setTableName
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
index|[
literal|4
index|]
operator|!=
literal|null
condition|)
name|part
operator|.
name|setCreateTime
argument_list|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlInt
argument_list|(
name|fields
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
index|[
literal|5
index|]
operator|!=
literal|null
condition|)
name|part
operator|.
name|setLastAccessTime
argument_list|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlInt
argument_list|(
name|fields
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|Long
name|writeId
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlLong
argument_list|(
name|fields
index|[
literal|14
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|writeId
operator|!=
literal|null
condition|)
block|{
name|part
operator|.
name|setWriteId
argument_list|(
name|writeId
argument_list|)
expr_stmt|;
block|}
name|partitions
operator|.
name|put
argument_list|(
name|partitionId
argument_list|,
name|part
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdId
operator|==
literal|null
condition|)
continue|continue;
comment|// Probably a view.
assert|assert
name|serdeId
operator|!=
literal|null
assert|;
comment|// We assume each partition has an unique SD.
name|StorageDescriptor
name|sd
init|=
operator|new
name|StorageDescriptor
argument_list|()
decl_stmt|;
name|StorageDescriptor
name|oldSd
init|=
name|sds
operator|.
name|put
argument_list|(
name|sdId
argument_list|,
name|sd
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldSd
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Partitions reuse SDs; we don't expect that"
argument_list|)
throw|;
block|}
comment|// Set the collection fields; some code might not check presence before accessing them.
name|sd
operator|.
name|setSortCols
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|Order
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|sd
operator|.
name|setBucketCols
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|sd
operator|.
name|setParameters
argument_list|(
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|sd
operator|.
name|setSkewedInfo
argument_list|(
operator|new
name|SkewedInfo
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
argument_list|,
operator|new
name|HashMap
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|String
argument_list|>
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|sd
operator|.
name|setInputFormat
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|Boolean
name|tmpBoolean
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlBoolean
argument_list|(
name|fields
index|[
literal|7
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmpBoolean
operator|!=
literal|null
condition|)
name|sd
operator|.
name|setCompressed
argument_list|(
name|tmpBoolean
argument_list|)
expr_stmt|;
name|tmpBoolean
operator|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlBoolean
argument_list|(
name|fields
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpBoolean
operator|!=
literal|null
condition|)
name|sd
operator|.
name|setStoredAsSubDirectories
argument_list|(
name|tmpBoolean
argument_list|)
expr_stmt|;
name|sd
operator|.
name|setLocation
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
index|[
literal|10
index|]
operator|!=
literal|null
condition|)
name|sd
operator|.
name|setNumBuckets
argument_list|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlInt
argument_list|(
name|fields
index|[
literal|10
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|sd
operator|.
name|setOutputFormat
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
name|sdSb
operator|.
name|append
argument_list|(
name|sdId
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|part
operator|.
name|setSd
argument_list|(
name|sd
argument_list|)
expr_stmt|;
if|if
condition|(
name|colId
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|cols
init|=
name|colss
operator|.
name|get
argument_list|(
name|colId
argument_list|)
decl_stmt|;
comment|// We expect that colId will be the same for all (or many) SDs.
if|if
condition|(
name|cols
operator|==
literal|null
condition|)
block|{
name|cols
operator|=
operator|new
name|ArrayList
argument_list|<
name|FieldSchema
argument_list|>
argument_list|()
expr_stmt|;
name|colss
operator|.
name|put
argument_list|(
name|colId
argument_list|,
name|cols
argument_list|)
expr_stmt|;
name|colsSb
operator|.
name|append
argument_list|(
name|colId
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sd
operator|.
name|setCols
argument_list|(
name|cols
argument_list|)
expr_stmt|;
block|}
comment|// We assume each SD has an unique serde.
name|SerDeInfo
name|serde
init|=
operator|new
name|SerDeInfo
argument_list|()
decl_stmt|;
name|SerDeInfo
name|oldSerde
init|=
name|serdes
operator|.
name|put
argument_list|(
name|serdeId
argument_list|,
name|serde
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldSerde
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"SDs reuse serdes; we don't expect that"
argument_list|)
throw|;
block|}
name|serde
operator|.
name|setParameters
argument_list|(
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|serde
operator|.
name|setName
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
name|serde
operator|.
name|setSerializationLib
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|13
index|]
argument_list|)
expr_stmt|;
name|serdeSb
operator|.
name|append
argument_list|(
name|serdeId
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|sd
operator|.
name|setSerdeInfo
argument_list|(
name|serde
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
block|}
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|queryTime
argument_list|)
expr_stmt|;
comment|// Now get all the one-to-many things. Start with partitions.
name|MetastoreDirectSqlUtils
operator|.
name|setPartitionParameters
argument_list|(
name|PARTITION_PARAMS
argument_list|,
name|convertMapNullsToEmptyStrings
argument_list|,
name|pm
argument_list|,
name|partIds
argument_list|,
name|partitions
argument_list|)
expr_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|setPartitionValues
argument_list|(
name|PARTITION_KEY_VALS
argument_list|,
name|pm
argument_list|,
name|partIds
argument_list|,
name|partitions
argument_list|)
expr_stmt|;
comment|// Prepare IN (blah) lists for the following queries. Cut off the final ','s.
if|if
condition|(
name|sdSb
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
assert|assert
name|serdeSb
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|&&
name|colsSb
operator|.
name|length
argument_list|()
operator|==
literal|0
assert|;
return|return
name|orderedResult
return|;
comment|// No SDs, probably a view.
block|}
name|String
name|sdIds
init|=
name|trimCommaList
argument_list|(
name|sdSb
argument_list|)
decl_stmt|;
name|String
name|serdeIds
init|=
name|trimCommaList
argument_list|(
name|serdeSb
argument_list|)
decl_stmt|;
name|String
name|colIds
init|=
name|trimCommaList
argument_list|(
name|colsSb
argument_list|)
decl_stmt|;
comment|// Get all the stuff for SD. Don't do empty-list check - we expect partitions do have SDs.
name|MetastoreDirectSqlUtils
operator|.
name|setSDParameters
argument_list|(
name|SD_PARAMS
argument_list|,
name|convertMapNullsToEmptyStrings
argument_list|,
name|pm
argument_list|,
name|sds
argument_list|,
name|sdIds
argument_list|)
expr_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|setSDSortCols
argument_list|(
name|SORT_COLS
argument_list|,
name|pm
argument_list|,
name|sds
argument_list|,
name|sdIds
argument_list|)
expr_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|setSDBucketCols
argument_list|(
name|BUCKETING_COLS
argument_list|,
name|pm
argument_list|,
name|sds
argument_list|,
name|sdIds
argument_list|)
expr_stmt|;
comment|// Skewed columns stuff.
name|boolean
name|hasSkewedColumns
init|=
name|MetastoreDirectSqlUtils
operator|.
name|setSkewedColNames
argument_list|(
name|SKEWED_COL_NAMES
argument_list|,
name|pm
argument_list|,
name|sds
argument_list|,
name|sdIds
argument_list|)
decl_stmt|;
comment|// Assume we don't need to fetch the rest of the skewed column data if we have no columns.
if|if
condition|(
name|hasSkewedColumns
condition|)
block|{
comment|// We are skipping the SKEWED_STRING_LIST table here, as it seems to be totally useless.
name|MetastoreDirectSqlUtils
operator|.
name|setSkewedColValues
argument_list|(
name|SKEWED_STRING_LIST_VALUES
argument_list|,
name|SKEWED_VALUES
argument_list|,
name|pm
argument_list|,
name|sds
argument_list|,
name|sdIds
argument_list|)
expr_stmt|;
comment|// We are skipping the SKEWED_STRING_LIST table here, as it seems to be totally useless.
name|MetastoreDirectSqlUtils
operator|.
name|setSkewedColLocationMaps
argument_list|(
name|SKEWED_COL_VALUE_LOC_MAP
argument_list|,
name|SKEWED_STRING_LIST_VALUES
argument_list|,
name|pm
argument_list|,
name|sds
argument_list|,
name|sdIds
argument_list|)
expr_stmt|;
block|}
comment|// if (hasSkewedColumns)
comment|// Get FieldSchema stuff if any.
if|if
condition|(
operator|!
name|colss
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// We are skipping the CDS table here, as it seems to be totally useless.
name|MetastoreDirectSqlUtils
operator|.
name|setSDCols
argument_list|(
name|COLUMNS_V2
argument_list|,
name|pm
argument_list|,
name|colss
argument_list|,
name|colIds
argument_list|)
expr_stmt|;
block|}
comment|// Finally, get all the stuff for serdes - just the params.
name|MetastoreDirectSqlUtils
operator|.
name|setSerdeParams
argument_list|(
name|SERDE_PARAMS
argument_list|,
name|convertMapNullsToEmptyStrings
argument_list|,
name|pm
argument_list|,
name|serdes
argument_list|,
name|serdeIds
argument_list|)
expr_stmt|;
return|return
name|orderedResult
return|;
block|}
specifier|public
name|int
name|getNumPartitionsViaSqlFilter
parameter_list|(
name|SqlFilterForPushdown
name|filter
parameter_list|)
throws|throws
name|MetaException
block|{
name|boolean
name|doTrace
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
name|String
name|catName
init|=
name|filter
operator|.
name|table
operator|.
name|getCatName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|String
name|dbName
init|=
name|filter
operator|.
name|table
operator|.
name|getDbName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|String
name|tblName
init|=
name|filter
operator|.
name|table
operator|.
name|getTableName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
comment|// Get number of partitions by doing count on PART_ID.
name|String
name|queryText
init|=
literal|"select count("
operator|+
name|PARTITIONS
operator|+
literal|".\"PART_ID\") from "
operator|+
name|PARTITIONS
operator|+
literal|""
operator|+
literal|"  inner join "
operator|+
name|TBLS
operator|+
literal|" on "
operator|+
name|PARTITIONS
operator|+
literal|".\"TBL_ID\" = "
operator|+
name|TBLS
operator|+
literal|".\"TBL_ID\" "
operator|+
literal|"    and "
operator|+
name|TBLS
operator|+
literal|".\"TBL_NAME\" = ? "
operator|+
literal|"  inner join "
operator|+
name|DBS
operator|+
literal|" on "
operator|+
name|TBLS
operator|+
literal|".\"DB_ID\" = "
operator|+
name|DBS
operator|+
literal|".\"DB_ID\" "
operator|+
literal|"     and "
operator|+
name|DBS
operator|+
literal|".\"NAME\" = ? "
operator|+
name|join
argument_list|(
name|filter
operator|.
name|joins
argument_list|,
literal|' '
argument_list|)
operator|+
literal|" where "
operator|+
name|DBS
operator|+
literal|".\"CTLG_NAME\" = ? "
operator|+
operator|(
name|filter
operator|.
name|filter
operator|==
literal|null
operator|||
name|filter
operator|.
name|filter
operator|.
name|trim
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
literal|""
else|:
operator|(
literal|" and "
operator|+
name|filter
operator|.
name|filter
operator|)
operator|)
decl_stmt|;
name|Object
index|[]
name|params
init|=
operator|new
name|Object
index|[
name|filter
operator|.
name|params
operator|.
name|size
argument_list|()
operator|+
literal|3
index|]
decl_stmt|;
name|params
index|[
literal|0
index|]
operator|=
name|tblName
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|dbName
expr_stmt|;
name|params
index|[
literal|2
index|]
operator|=
name|catName
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|filter
operator|.
name|params
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|params
index|[
name|i
operator|+
literal|3
index|]
operator|=
name|filter
operator|.
name|params
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|long
name|start
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|Query
name|query
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|query
operator|.
name|setUnique
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|int
name|sqlResult
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlInt
argument_list|(
name|query
operator|.
name|executeWithArray
argument_list|(
name|params
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|queryTime
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|queryTime
argument_list|)
expr_stmt|;
return|return
name|sqlResult
return|;
block|}
specifier|private
specifier|static
name|String
name|trimCommaList
parameter_list|(
name|StringBuilder
name|sb
parameter_list|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|setLength
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
specifier|static
class|class
name|PartitionFilterGenerator
extends|extends
name|TreeVisitor
block|{
specifier|private
specifier|final
name|Table
name|table
decl_stmt|;
specifier|private
specifier|final
name|FilterBuilder
name|filterBuffer
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|Object
argument_list|>
name|params
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|joins
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|dbHasJoinCastBug
decl_stmt|;
specifier|private
specifier|final
name|String
name|defaultPartName
decl_stmt|;
specifier|private
specifier|final
name|DatabaseProduct
name|dbType
decl_stmt|;
specifier|private
specifier|final
name|String
name|PARTITION_KEY_VALS
decl_stmt|,
name|PARTITIONS
decl_stmt|,
name|DBS
decl_stmt|,
name|TBLS
decl_stmt|;
specifier|private
name|PartitionFilterGenerator
parameter_list|(
name|Table
name|table
parameter_list|,
name|List
argument_list|<
name|Object
argument_list|>
name|params
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|joins
parameter_list|,
name|boolean
name|dbHasJoinCastBug
parameter_list|,
name|String
name|defaultPartName
parameter_list|,
name|DatabaseProduct
name|dbType
parameter_list|,
name|String
name|schema
parameter_list|)
block|{
name|this
operator|.
name|table
operator|=
name|table
expr_stmt|;
name|this
operator|.
name|params
operator|=
name|params
expr_stmt|;
name|this
operator|.
name|joins
operator|=
name|joins
expr_stmt|;
name|this
operator|.
name|dbHasJoinCastBug
operator|=
name|dbHasJoinCastBug
expr_stmt|;
name|this
operator|.
name|filterBuffer
operator|=
operator|new
name|FilterBuilder
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|defaultPartName
operator|=
name|defaultPartName
expr_stmt|;
name|this
operator|.
name|dbType
operator|=
name|dbType
expr_stmt|;
name|this
operator|.
name|PARTITION_KEY_VALS
operator|=
name|getFullyQualifiedName
argument_list|(
name|schema
argument_list|,
literal|"PARTITION_KEY_VALS"
argument_list|)
expr_stmt|;
name|this
operator|.
name|PARTITIONS
operator|=
name|getFullyQualifiedName
argument_list|(
name|schema
argument_list|,
literal|"PARTITIONS"
argument_list|)
expr_stmt|;
name|this
operator|.
name|DBS
operator|=
name|getFullyQualifiedName
argument_list|(
name|schema
argument_list|,
literal|"DBS"
argument_list|)
expr_stmt|;
name|this
operator|.
name|TBLS
operator|=
name|getFullyQualifiedName
argument_list|(
name|schema
argument_list|,
literal|"TBLS"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Generate the ANSI SQL92 filter for the given expression tree      * @param table the table being queried      * @param params the ordered parameters for the resulting expression      * @param joins the joins necessary for the resulting expression      * @return the string representation of the expression tree      */
specifier|private
specifier|static
name|String
name|generateSqlFilter
parameter_list|(
name|Table
name|table
parameter_list|,
name|ExpressionTree
name|tree
parameter_list|,
name|List
argument_list|<
name|Object
argument_list|>
name|params
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|joins
parameter_list|,
name|boolean
name|dbHasJoinCastBug
parameter_list|,
name|String
name|defaultPartName
parameter_list|,
name|DatabaseProduct
name|dbType
parameter_list|,
name|String
name|schema
parameter_list|)
throws|throws
name|MetaException
block|{
assert|assert
name|table
operator|!=
literal|null
assert|;
if|if
condition|(
name|tree
operator|==
literal|null
condition|)
block|{
comment|// consistent with other APIs like makeExpressionTree, null is returned to indicate that
comment|// the filter could not pushed down due to parsing issue etc
return|return
literal|null
return|;
block|}
if|if
condition|(
name|tree
operator|.
name|getRoot
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|""
return|;
block|}
name|PartitionFilterGenerator
name|visitor
init|=
operator|new
name|PartitionFilterGenerator
argument_list|(
name|table
argument_list|,
name|params
argument_list|,
name|joins
argument_list|,
name|dbHasJoinCastBug
argument_list|,
name|defaultPartName
argument_list|,
name|dbType
argument_list|,
name|schema
argument_list|)
decl_stmt|;
name|tree
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
if|if
condition|(
name|visitor
operator|.
name|filterBuffer
operator|.
name|hasError
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Unable to push down SQL filter: "
operator|+
name|visitor
operator|.
name|filterBuffer
operator|.
name|getErrorMessage
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Some joins might be null (see processNode for LeafNode), clean them up.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|joins
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|joins
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|!=
literal|null
condition|)
continue|continue;
name|joins
operator|.
name|remove
argument_list|(
name|i
operator|--
argument_list|)
expr_stmt|;
block|}
return|return
literal|"("
operator|+
name|visitor
operator|.
name|filterBuffer
operator|.
name|getFilter
argument_list|()
operator|+
literal|")"
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|beginTreeNode
parameter_list|(
name|TreeNode
name|node
parameter_list|)
throws|throws
name|MetaException
block|{
name|filterBuffer
operator|.
name|append
argument_list|(
literal|" ("
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|midTreeNode
parameter_list|(
name|TreeNode
name|node
parameter_list|)
throws|throws
name|MetaException
block|{
name|filterBuffer
operator|.
name|append
argument_list|(
operator|(
name|node
operator|.
name|getAndOr
argument_list|()
operator|==
name|LogicalOperator
operator|.
name|AND
operator|)
condition|?
literal|" and "
else|:
literal|" or "
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|endTreeNode
parameter_list|(
name|TreeNode
name|node
parameter_list|)
throws|throws
name|MetaException
block|{
name|filterBuffer
operator|.
name|append
argument_list|(
literal|") "
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|shouldStop
parameter_list|()
block|{
return|return
name|filterBuffer
operator|.
name|hasError
argument_list|()
return|;
block|}
specifier|private
specifier|static
enum|enum
name|FilterType
block|{
name|Integral
block|,
name|String
block|,
name|Date
block|,
name|Invalid
block|;
specifier|static
name|FilterType
name|fromType
parameter_list|(
name|String
name|colTypeStr
parameter_list|)
block|{
if|if
condition|(
name|colTypeStr
operator|.
name|equals
argument_list|(
name|ColumnType
operator|.
name|STRING_TYPE_NAME
argument_list|)
condition|)
block|{
return|return
name|FilterType
operator|.
name|String
return|;
block|}
elseif|else
if|if
condition|(
name|colTypeStr
operator|.
name|equals
argument_list|(
name|ColumnType
operator|.
name|DATE_TYPE_NAME
argument_list|)
condition|)
block|{
return|return
name|FilterType
operator|.
name|Date
return|;
block|}
elseif|else
if|if
condition|(
name|ColumnType
operator|.
name|IntegralTypes
operator|.
name|contains
argument_list|(
name|colTypeStr
argument_list|)
condition|)
block|{
return|return
name|FilterType
operator|.
name|Integral
return|;
block|}
return|return
name|FilterType
operator|.
name|Invalid
return|;
block|}
specifier|public
specifier|static
name|FilterType
name|fromClass
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
return|return
name|FilterType
operator|.
name|String
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Long
condition|)
block|{
return|return
name|FilterType
operator|.
name|Integral
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|java
operator|.
name|sql
operator|.
name|Date
condition|)
block|{
return|return
name|FilterType
operator|.
name|Date
return|;
block|}
return|return
name|FilterType
operator|.
name|Invalid
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LeafNode
name|node
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|node
operator|.
name|operator
operator|==
name|Operator
operator|.
name|LIKE
condition|)
block|{
name|filterBuffer
operator|.
name|setError
argument_list|(
literal|"LIKE is not supported for SQL filter pushdown"
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|partColCount
init|=
name|table
operator|.
name|getPartitionKeys
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|partColIndex
init|=
name|node
operator|.
name|getPartColIndexForFilter
argument_list|(
name|table
argument_list|,
name|filterBuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|filterBuffer
operator|.
name|hasError
argument_list|()
condition|)
return|return;
comment|// We skipped 'like', other ops should all work as long as the types are right.
name|String
name|colTypeStr
init|=
name|table
operator|.
name|getPartitionKeys
argument_list|()
operator|.
name|get
argument_list|(
name|partColIndex
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|FilterType
name|colType
init|=
name|FilterType
operator|.
name|fromType
argument_list|(
name|colTypeStr
argument_list|)
decl_stmt|;
if|if
condition|(
name|colType
operator|==
name|FilterType
operator|.
name|Invalid
condition|)
block|{
name|filterBuffer
operator|.
name|setError
argument_list|(
literal|"Filter pushdown not supported for type "
operator|+
name|colTypeStr
argument_list|)
expr_stmt|;
return|return;
block|}
name|FilterType
name|valType
init|=
name|FilterType
operator|.
name|fromClass
argument_list|(
name|node
operator|.
name|value
argument_list|)
decl_stmt|;
name|Object
name|nodeValue
init|=
name|node
operator|.
name|value
decl_stmt|;
if|if
condition|(
name|valType
operator|==
name|FilterType
operator|.
name|Invalid
condition|)
block|{
name|filterBuffer
operator|.
name|setError
argument_list|(
literal|"Filter pushdown not supported for value "
operator|+
name|node
operator|.
name|value
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// if Filter.g does date parsing for quoted strings, we'd need to verify there's no
comment|// type mismatch when string col is filtered by a string that looks like date.
if|if
condition|(
name|colType
operator|==
name|FilterType
operator|.
name|Date
operator|&&
name|valType
operator|==
name|FilterType
operator|.
name|String
condition|)
block|{
comment|// Filter.g cannot parse a quoted date; try to parse date here too.
try|try
block|{
name|nodeValue
operator|=
name|MetaStoreUtils
operator|.
name|PARTITION_DATE_FORMAT
operator|.
name|get
argument_list|()
operator|.
name|parse
argument_list|(
operator|(
name|String
operator|)
name|nodeValue
argument_list|)
expr_stmt|;
name|valType
operator|=
name|FilterType
operator|.
name|Date
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|pe
parameter_list|)
block|{
comment|// do nothing, handled below - types will mismatch
block|}
block|}
comment|// We format it so we are sure we are getting the right value
if|if
condition|(
name|valType
operator|==
name|FilterType
operator|.
name|Date
condition|)
block|{
comment|// Format
name|nodeValue
operator|=
name|MetaStoreUtils
operator|.
name|PARTITION_DATE_FORMAT
operator|.
name|get
argument_list|()
operator|.
name|format
argument_list|(
name|nodeValue
argument_list|)
expr_stmt|;
block|}
name|boolean
name|isDefaultPartition
init|=
operator|(
name|valType
operator|==
name|FilterType
operator|.
name|String
operator|)
operator|&&
name|defaultPartName
operator|.
name|equals
argument_list|(
name|nodeValue
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|colType
operator|!=
name|valType
operator|)
operator|&&
operator|(
operator|!
name|isDefaultPartition
operator|)
condition|)
block|{
comment|// It's not clear how filtering for e.g. "stringCol> 5" should work (which side is
comment|// to be coerced?). Let the expression evaluation sort this one out, not metastore.
name|filterBuffer
operator|.
name|setError
argument_list|(
literal|"Cannot push down filter for "
operator|+
name|colTypeStr
operator|+
literal|" column and value "
operator|+
name|nodeValue
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|joins
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// There's a fixed number of partition cols that we might have filters on. To avoid
comment|// joining multiple times for one column (if there are several filters on it), we will
comment|// keep numCols elements in the list, one for each column; we will fill it with nulls,
comment|// put each join at a corresponding index when necessary, and remove nulls in the end.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partColCount
condition|;
operator|++
name|i
control|)
block|{
name|joins
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|joins
operator|.
name|get
argument_list|(
name|partColIndex
argument_list|)
operator|==
literal|null
condition|)
block|{
name|joins
operator|.
name|set
argument_list|(
name|partColIndex
argument_list|,
literal|"inner join "
operator|+
name|PARTITION_KEY_VALS
operator|+
literal|" \"FILTER"
operator|+
name|partColIndex
operator|+
literal|"\" on \"FILTER"
operator|+
name|partColIndex
operator|+
literal|"\".\"PART_ID\" = "
operator|+
name|PARTITIONS
operator|+
literal|".\"PART_ID\""
operator|+
literal|" and \"FILTER"
operator|+
name|partColIndex
operator|+
literal|"\".\"INTEGER_IDX\" = "
operator|+
name|partColIndex
argument_list|)
expr_stmt|;
block|}
comment|// Build the filter and add parameters linearly; we are traversing leaf nodes LTR.
name|String
name|tableValue
init|=
literal|"\"FILTER"
operator|+
name|partColIndex
operator|+
literal|"\".\"PART_KEY_VAL\""
decl_stmt|;
name|String
name|nodeValue0
init|=
literal|"?"
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|isReverseOrder
condition|)
block|{
name|params
operator|.
name|add
argument_list|(
name|nodeValue
argument_list|)
expr_stmt|;
block|}
name|String
name|tableColumn
init|=
name|tableValue
decl_stmt|;
if|if
condition|(
operator|(
name|colType
operator|!=
name|FilterType
operator|.
name|String
operator|)
operator|&&
operator|(
operator|!
name|isDefaultPartition
operator|)
condition|)
block|{
comment|// The underlying database field is varchar, we need to compare numbers.
if|if
condition|(
name|colType
operator|==
name|FilterType
operator|.
name|Integral
condition|)
block|{
name|tableValue
operator|=
literal|"cast("
operator|+
name|tableValue
operator|+
literal|" as decimal(21,0))"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|colType
operator|==
name|FilterType
operator|.
name|Date
condition|)
block|{
if|if
condition|(
name|dbType
operator|==
name|DatabaseProduct
operator|.
name|ORACLE
condition|)
block|{
comment|// Oracle requires special treatment... as usual.
name|tableValue
operator|=
literal|"TO_DATE("
operator|+
name|tableValue
operator|+
literal|", 'YYYY-MM-DD')"
expr_stmt|;
block|}
else|else
block|{
name|tableValue
operator|=
literal|"cast("
operator|+
name|tableValue
operator|+
literal|" as date)"
expr_stmt|;
block|}
block|}
comment|// Workaround for HIVE_DEFAULT_PARTITION - ignore it like JDO does, for now.
name|String
name|tableValue0
init|=
name|tableValue
decl_stmt|;
name|tableValue
operator|=
literal|"(case when "
operator|+
name|tableColumn
operator|+
literal|"<> ?"
expr_stmt|;
name|params
operator|.
name|add
argument_list|(
name|defaultPartName
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbHasJoinCastBug
condition|)
block|{
comment|// This is a workaround for DERBY-6358 and Oracle bug; it is pretty horrible.
name|tableValue
operator|+=
operator|(
literal|" and "
operator|+
name|TBLS
operator|+
literal|".\"TBL_NAME\" = ? and "
operator|+
name|DBS
operator|+
literal|".\"NAME\" = ? and "
operator|+
name|DBS
operator|+
literal|".\"CTLG_NAME\" = ? and "
operator|+
literal|"\"FILTER"
operator|+
name|partColIndex
operator|+
literal|"\".\"PART_ID\" = "
operator|+
name|PARTITIONS
operator|+
literal|".\"PART_ID\" and "
operator|+
literal|"\"FILTER"
operator|+
name|partColIndex
operator|+
literal|"\".\"INTEGER_IDX\" = "
operator|+
name|partColIndex
operator|)
expr_stmt|;
name|params
operator|.
name|add
argument_list|(
name|table
operator|.
name|getTableName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
name|params
operator|.
name|add
argument_list|(
name|table
operator|.
name|getDbName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
name|params
operator|.
name|add
argument_list|(
name|table
operator|.
name|getCatName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|tableValue
operator|+=
literal|" then "
operator|+
name|tableValue0
operator|+
literal|" else null end)"
expr_stmt|;
if|if
condition|(
name|valType
operator|==
name|FilterType
operator|.
name|Date
condition|)
block|{
if|if
condition|(
name|dbType
operator|==
name|DatabaseProduct
operator|.
name|ORACLE
condition|)
block|{
comment|// Oracle requires special treatment... as usual.
name|nodeValue0
operator|=
literal|"TO_DATE("
operator|+
name|nodeValue0
operator|+
literal|", 'YYYY-MM-DD')"
expr_stmt|;
block|}
else|else
block|{
name|nodeValue0
operator|=
literal|"cast("
operator|+
name|nodeValue0
operator|+
literal|" as date)"
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|node
operator|.
name|isReverseOrder
condition|)
block|{
name|params
operator|.
name|add
argument_list|(
name|nodeValue
argument_list|)
expr_stmt|;
block|}
name|filterBuffer
operator|.
name|append
argument_list|(
name|node
operator|.
name|isReverseOrder
condition|?
literal|"("
operator|+
name|nodeValue0
operator|+
literal|" "
operator|+
name|node
operator|.
name|operator
operator|.
name|getSqlOp
argument_list|()
operator|+
literal|" "
operator|+
name|tableValue
operator|+
literal|")"
else|:
literal|"("
operator|+
name|tableValue
operator|+
literal|" "
operator|+
name|node
operator|.
name|operator
operator|.
name|getSqlOp
argument_list|()
operator|+
literal|" "
operator|+
name|nodeValue0
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Retrieve the column statistics for the specified columns of the table. NULL    * is returned if the columns are not provided.    * @param catName     the catalog name of the table    * @param dbName      the database name of the table    * @param tableName   the table name    * @param colNames    the list of the column names    * @param engine      engine making the request    * @return            the column statistics for the specified columns    * @throws MetaException    */
specifier|public
name|ColumnStatistics
name|getTableStats
parameter_list|(
specifier|final
name|String
name|catName
parameter_list|,
specifier|final
name|String
name|dbName
parameter_list|,
specifier|final
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|,
name|String
name|engine
parameter_list|,
name|boolean
name|enableBitVector
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|colNames
operator|==
literal|null
operator|||
name|colNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|boolean
name|doTrace
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
specifier|final
name|String
name|queryText0
init|=
literal|"select "
operator|+
name|getStatsList
argument_list|(
name|enableBitVector
argument_list|)
operator|+
literal|" from "
operator|+
name|TAB_COL_STATS
operator|+
literal|" where \"CAT_NAME\" = ? and \"DB_NAME\" = ? and \"TABLE_NAME\" = ? "
operator|+
literal|" and \"ENGINE\" = ? and \"COLUMN_NAME\" in ("
decl_stmt|;
name|Batchable
argument_list|<
name|String
argument_list|,
name|Object
index|[]
argument_list|>
name|b
init|=
operator|new
name|Batchable
argument_list|<
name|String
argument_list|,
name|Object
index|[]
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|run
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|input
parameter_list|)
throws|throws
name|MetaException
block|{
name|String
name|queryText
init|=
name|queryText0
operator|+
name|makeParams
argument_list|(
name|input
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
decl_stmt|;
name|Object
index|[]
name|params
init|=
operator|new
name|Object
index|[
name|input
operator|.
name|size
argument_list|()
operator|+
literal|4
index|]
decl_stmt|;
name|params
index|[
literal|0
index|]
operator|=
name|catName
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|dbName
expr_stmt|;
name|params
index|[
literal|2
index|]
operator|=
name|tableName
expr_stmt|;
name|params
index|[
literal|3
index|]
operator|=
name|engine
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|input
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|params
index|[
name|i
operator|+
literal|4
index|]
operator|=
name|input
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|long
name|start
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|Query
name|query
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|Object
name|qResult
init|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|params
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText0
operator|+
literal|"...)"
argument_list|,
name|start
argument_list|,
operator|(
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qResult
operator|==
literal|null
condition|)
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
name|addQueryAfterUse
argument_list|(
name|query
argument_list|)
expr_stmt|;
return|return
name|MetastoreDirectSqlUtils
operator|.
name|ensureList
argument_list|(
name|qResult
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|list
init|=
name|Batchable
operator|.
name|runBatched
argument_list|(
name|batchSize
argument_list|,
name|colNames
argument_list|,
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ColumnStatisticsDesc
name|csd
init|=
operator|new
name|ColumnStatisticsDesc
argument_list|(
literal|true
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
name|csd
operator|.
name|setCatName
argument_list|(
name|catName
argument_list|)
expr_stmt|;
name|ColumnStatistics
name|result
init|=
name|makeColumnStats
argument_list|(
name|list
argument_list|,
name|csd
argument_list|,
literal|0
argument_list|,
name|engine
argument_list|)
decl_stmt|;
name|b
operator|.
name|closeAllQueries
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|public
name|List
argument_list|<
name|HiveObjectPrivilege
argument_list|>
name|getTableAllColumnGrants
parameter_list|(
name|String
name|catName
parameter_list|,
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|authorizer
parameter_list|)
throws|throws
name|MetaException
block|{
name|Query
name|query
init|=
literal|null
decl_stmt|;
comment|// These constants should match the SELECT clause of the query.
specifier|final
name|int
name|authorizerIndex
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|columnNameIndex
init|=
literal|1
decl_stmt|;
specifier|final
name|int
name|createTimeIndex
init|=
literal|2
decl_stmt|;
specifier|final
name|int
name|grantOptionIndex
init|=
literal|3
decl_stmt|;
specifier|final
name|int
name|grantorIndex
init|=
literal|4
decl_stmt|;
specifier|final
name|int
name|grantorTypeIndex
init|=
literal|5
decl_stmt|;
specifier|final
name|int
name|principalNameIndex
init|=
literal|6
decl_stmt|;
specifier|final
name|int
name|principalTypeIndex
init|=
literal|7
decl_stmt|;
specifier|final
name|int
name|privilegeIndex
init|=
literal|8
decl_stmt|;
comment|// Retrieve the privileges from the object store. Just grab only the required fields.
name|String
name|queryText
init|=
literal|"select "
operator|+
name|TBL_COL_PRIVS
operator|+
literal|".\"AUTHORIZER\", "
operator|+
name|TBL_COL_PRIVS
operator|+
literal|".\"COLUMN_NAME\", "
operator|+
name|TBL_COL_PRIVS
operator|+
literal|".\"CREATE_TIME\", "
operator|+
name|TBL_COL_PRIVS
operator|+
literal|".\"GRANT_OPTION\", "
operator|+
name|TBL_COL_PRIVS
operator|+
literal|".\"GRANTOR\", "
operator|+
name|TBL_COL_PRIVS
operator|+
literal|".\"GRANTOR_TYPE\", "
operator|+
name|TBL_COL_PRIVS
operator|+
literal|".\"PRINCIPAL_NAME\", "
operator|+
name|TBL_COL_PRIVS
operator|+
literal|".\"PRINCIPAL_TYPE\", "
operator|+
name|TBL_COL_PRIVS
operator|+
literal|".\"TBL_COL_PRIV\" "
operator|+
literal|"FROM "
operator|+
name|TBL_COL_PRIVS
operator|+
literal|" JOIN "
operator|+
name|TBLS
operator|+
literal|" ON "
operator|+
name|TBL_COL_PRIVS
operator|+
literal|".\"TBL_ID\" = "
operator|+
name|TBLS
operator|+
literal|".\"TBL_ID\""
operator|+
literal|" JOIN "
operator|+
name|DBS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"DB_ID\" = "
operator|+
name|DBS
operator|+
literal|".\"DB_ID\" "
operator|+
literal|" WHERE "
operator|+
name|TBLS
operator|+
literal|".\"TBL_NAME\" = ?"
operator|+
literal|" AND "
operator|+
name|DBS
operator|+
literal|".\"NAME\" = ?"
operator|+
literal|" AND "
operator|+
name|DBS
operator|+
literal|".\"CTLG_NAME\" = ?"
decl_stmt|;
comment|// Build the parameters, they should match the WHERE clause of the query.
name|int
name|numParams
init|=
name|authorizer
operator|!=
literal|null
condition|?
literal|4
else|:
literal|3
decl_stmt|;
name|Object
index|[]
name|params
init|=
operator|new
name|Object
index|[
name|numParams
index|]
decl_stmt|;
name|params
index|[
literal|0
index|]
operator|=
name|tableName
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|dbName
expr_stmt|;
name|params
index|[
literal|2
index|]
operator|=
name|catName
expr_stmt|;
if|if
condition|(
name|authorizer
operator|!=
literal|null
condition|)
block|{
name|queryText
operator|=
name|queryText
operator|+
literal|" AND "
operator|+
name|TBL_COL_PRIVS
operator|+
literal|".\"AUTHORIZER\" = ?"
expr_stmt|;
name|params
index|[
literal|3
index|]
operator|=
name|authorizer
expr_stmt|;
block|}
comment|// Collect the results into a list that the caller can consume.
name|List
argument_list|<
name|HiveObjectPrivilege
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|doTrace
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
name|long
name|start
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|query
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
try|try
block|{
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|queryResult
init|=
name|MetastoreDirectSqlUtils
operator|.
name|ensureList
argument_list|(
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|params
argument_list|,
name|queryText
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|end
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
comment|// If there is some result convert it into HivePrivilege bag and return.
for|for
control|(
name|Object
index|[]
name|privLine
range|:
name|queryResult
control|)
block|{
name|String
name|privAuthorizer
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|privLine
index|[
name|authorizerIndex
index|]
argument_list|)
decl_stmt|;
name|String
name|principalName
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|privLine
index|[
name|principalNameIndex
index|]
argument_list|)
decl_stmt|;
name|PrincipalType
name|ptype
init|=
name|PrincipalType
operator|.
name|valueOf
argument_list|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|privLine
index|[
name|principalTypeIndex
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|columnName
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|privLine
index|[
name|columnNameIndex
index|]
argument_list|)
decl_stmt|;
name|String
name|privilege
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|privLine
index|[
name|privilegeIndex
index|]
argument_list|)
decl_stmt|;
name|int
name|createTime
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlInt
argument_list|(
name|privLine
index|[
name|createTimeIndex
index|]
argument_list|)
decl_stmt|;
name|String
name|grantor
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|privLine
index|[
name|grantorIndex
index|]
argument_list|)
decl_stmt|;
name|PrincipalType
name|grantorType
init|=
name|PrincipalType
operator|.
name|valueOf
argument_list|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|privLine
index|[
name|grantorTypeIndex
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|boolean
name|grantOption
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlBoolean
argument_list|(
name|privLine
index|[
name|grantOptionIndex
index|]
argument_list|)
decl_stmt|;
name|HiveObjectRef
name|objectRef
init|=
operator|new
name|HiveObjectRef
argument_list|(
name|HiveObjectType
operator|.
name|COLUMN
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|,
literal|null
argument_list|,
name|columnName
argument_list|)
decl_stmt|;
name|objectRef
operator|.
name|setCatName
argument_list|(
name|catName
argument_list|)
expr_stmt|;
name|PrivilegeGrantInfo
name|grantInfo
init|=
operator|new
name|PrivilegeGrantInfo
argument_list|(
name|privilege
argument_list|,
name|createTime
argument_list|,
name|grantor
argument_list|,
name|grantorType
argument_list|,
name|grantOption
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
operator|new
name|HiveObjectPrivilege
argument_list|(
name|objectRef
argument_list|,
name|principalName
argument_list|,
name|ptype
argument_list|,
name|grantInfo
argument_list|,
name|privAuthorizer
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|public
name|AggrStats
name|aggrColStatsForPartitions
parameter_list|(
name|String
name|catName
parameter_list|,
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|,
name|String
name|engine
parameter_list|,
name|boolean
name|useDensityFunctionForNDVEstimation
parameter_list|,
name|double
name|ndvTuner
parameter_list|,
name|boolean
name|enableBitVector
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|colNames
operator|.
name|isEmpty
argument_list|()
operator|||
name|partNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Columns is empty or partNames is empty : Short-circuiting stats eval"
argument_list|)
expr_stmt|;
return|return
operator|new
name|AggrStats
argument_list|(
name|Collections
operator|.
expr|<
name|ColumnStatisticsObj
operator|>
name|emptyList
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
comment|// Nothing to aggregate
block|}
name|long
name|partsFound
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|colStatsList
decl_stmt|;
comment|// Try to read from the cache first
if|if
condition|(
name|isAggregateStatsCacheEnabled
operator|&&
operator|(
name|partNames
operator|.
name|size
argument_list|()
operator|<
name|aggrStatsCache
operator|.
name|getMaxPartsPerCacheNode
argument_list|()
operator|)
condition|)
block|{
name|AggrColStats
name|colStatsAggrCached
decl_stmt|;
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|colStatsAggrFromDB
decl_stmt|;
name|int
name|maxPartsPerCacheNode
init|=
name|aggrStatsCache
operator|.
name|getMaxPartsPerCacheNode
argument_list|()
decl_stmt|;
name|double
name|fpp
init|=
name|aggrStatsCache
operator|.
name|getFalsePositiveProbability
argument_list|()
decl_stmt|;
name|colStatsList
operator|=
operator|new
name|ArrayList
argument_list|<
name|ColumnStatisticsObj
argument_list|>
argument_list|()
expr_stmt|;
comment|// Bloom filter for the new node that we will eventually add to the cache
name|BloomFilter
name|bloomFilter
init|=
name|createPartsBloomFilter
argument_list|(
name|maxPartsPerCacheNode
argument_list|,
name|fpp
argument_list|,
name|partNames
argument_list|)
decl_stmt|;
name|boolean
name|computePartsFound
init|=
literal|true
decl_stmt|;
for|for
control|(
name|String
name|colName
range|:
name|colNames
control|)
block|{
comment|// Check the cache first
name|colStatsAggrCached
operator|=
name|aggrStatsCache
operator|.
name|get
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|,
name|colName
argument_list|,
name|partNames
argument_list|)
expr_stmt|;
if|if
condition|(
name|colStatsAggrCached
operator|!=
literal|null
condition|)
block|{
name|colStatsList
operator|.
name|add
argument_list|(
name|colStatsAggrCached
operator|.
name|getColStats
argument_list|()
argument_list|)
expr_stmt|;
name|partsFound
operator|=
name|colStatsAggrCached
operator|.
name|getNumPartsCached
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|computePartsFound
condition|)
block|{
name|partsFound
operator|=
name|partsFoundForPartitions
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|colNames
argument_list|,
name|engine
argument_list|)
expr_stmt|;
name|computePartsFound
operator|=
literal|false
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|colNamesForDB
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|colNamesForDB
operator|.
name|add
argument_list|(
name|colName
argument_list|)
expr_stmt|;
comment|// Read aggregated stats for one column
name|colStatsAggrFromDB
operator|=
name|columnStatisticsObjForPartitions
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|colNamesForDB
argument_list|,
name|engine
argument_list|,
name|partsFound
argument_list|,
name|useDensityFunctionForNDVEstimation
argument_list|,
name|ndvTuner
argument_list|,
name|enableBitVector
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|colStatsAggrFromDB
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ColumnStatisticsObj
name|colStatsAggr
init|=
name|colStatsAggrFromDB
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|colStatsList
operator|.
name|add
argument_list|(
name|colStatsAggr
argument_list|)
expr_stmt|;
comment|// Update the cache to add this new aggregate node
name|aggrStatsCache
operator|.
name|add
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|,
name|colName
argument_list|,
name|partsFound
argument_list|,
name|colStatsAggr
argument_list|,
name|bloomFilter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|partsFound
operator|=
name|partsFoundForPartitions
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|colNames
argument_list|,
name|engine
argument_list|)
expr_stmt|;
name|colStatsList
operator|=
name|columnStatisticsObjForPartitions
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|colNames
argument_list|,
name|engine
argument_list|,
name|partsFound
argument_list|,
name|useDensityFunctionForNDVEstimation
argument_list|,
name|ndvTuner
argument_list|,
name|enableBitVector
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"useDensityFunctionForNDVEstimation = "
operator|+
name|useDensityFunctionForNDVEstimation
operator|+
literal|"\npartsFound = "
operator|+
name|partsFound
operator|+
literal|"\nColumnStatisticsObj = "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|colStatsList
operator|.
name|toArray
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|AggrStats
argument_list|(
name|colStatsList
argument_list|,
name|partsFound
argument_list|)
return|;
block|}
specifier|private
name|BloomFilter
name|createPartsBloomFilter
parameter_list|(
name|int
name|maxPartsPerCacheNode
parameter_list|,
name|double
name|fpp
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|)
block|{
name|BloomFilter
name|bloomFilter
init|=
operator|new
name|BloomFilter
argument_list|(
name|maxPartsPerCacheNode
argument_list|,
name|fpp
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|partName
range|:
name|partNames
control|)
block|{
name|bloomFilter
operator|.
name|add
argument_list|(
name|partName
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|bloomFilter
return|;
block|}
specifier|private
name|long
name|partsFoundForPartitions
parameter_list|(
specifier|final
name|String
name|catName
parameter_list|,
specifier|final
name|String
name|dbName
parameter_list|,
specifier|final
name|String
name|tableName
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|,
name|String
name|engine
parameter_list|)
throws|throws
name|MetaException
block|{
assert|assert
operator|!
name|colNames
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|partNames
operator|.
name|isEmpty
argument_list|()
assert|;
specifier|final
name|boolean
name|doTrace
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
specifier|final
name|String
name|queryText0
init|=
literal|"select count(\"COLUMN_NAME\") from "
operator|+
name|PART_COL_STATS
operator|+
literal|""
operator|+
literal|" where \"CAT_NAME\" = ? and \"DB_NAME\" = ? and \"TABLE_NAME\" = ? "
operator|+
literal|" and \"COLUMN_NAME\" in (%1$s) and \"PARTITION_NAME\" in (%2$s)"
operator|+
literal|" and \"ENGINE\" = ? "
operator|+
literal|" group by \"PARTITION_NAME\""
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|allCounts
init|=
name|Batchable
operator|.
name|runBatched
argument_list|(
name|batchSize
argument_list|,
name|colNames
argument_list|,
operator|new
name|Batchable
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Long
argument_list|>
name|run
parameter_list|(
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|inputColName
parameter_list|)
throws|throws
name|MetaException
block|{
return|return
name|Batchable
operator|.
name|runBatched
argument_list|(
name|batchSize
argument_list|,
name|partNames
argument_list|,
operator|new
name|Batchable
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Long
argument_list|>
name|run
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|inputPartNames
parameter_list|)
throws|throws
name|MetaException
block|{
name|long
name|partsFound
init|=
literal|0
decl_stmt|;
name|String
name|queryText
init|=
name|String
operator|.
name|format
argument_list|(
name|queryText0
argument_list|,
name|makeParams
argument_list|(
name|inputColName
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|makeParams
argument_list|(
name|inputPartNames
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|start
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|Query
name|query
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
try|try
block|{
name|Object
name|qResult
init|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|prepareParams
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|,
name|inputPartNames
argument_list|,
name|inputColName
argument_list|,
name|engine
argument_list|)
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|long
name|end
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|ForwardQueryResult
argument_list|<
name|?
argument_list|>
name|fqr
init|=
operator|(
name|ForwardQueryResult
argument_list|<
name|?
argument_list|>
operator|)
name|qResult
decl_stmt|;
name|Iterator
argument_list|<
name|?
argument_list|>
name|iter
init|=
name|fqr
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlLong
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|==
name|inputColName
operator|.
name|size
argument_list|()
condition|)
block|{
name|partsFound
operator|++
expr_stmt|;
block|}
block|}
return|return
name|Lists
operator|.
expr|<
name|Long
operator|>
name|newArrayList
argument_list|(
name|partsFound
argument_list|)
return|;
block|}
finally|finally
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|long
name|partsFound
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Long
name|val
range|:
name|allCounts
control|)
block|{
name|partsFound
operator|+=
name|val
expr_stmt|;
block|}
return|return
name|partsFound
return|;
block|}
specifier|private
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|columnStatisticsObjForPartitions
parameter_list|(
specifier|final
name|String
name|catName
parameter_list|,
specifier|final
name|String
name|dbName
parameter_list|,
specifier|final
name|String
name|tableName
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|,
name|String
name|engine
parameter_list|,
name|long
name|partsFound
parameter_list|,
specifier|final
name|boolean
name|useDensityFunctionForNDVEstimation
parameter_list|,
specifier|final
name|double
name|ndvTuner
parameter_list|,
specifier|final
name|boolean
name|enableBitVector
parameter_list|)
throws|throws
name|MetaException
block|{
specifier|final
name|boolean
name|areAllPartsFound
init|=
operator|(
name|partsFound
operator|==
name|partNames
operator|.
name|size
argument_list|()
operator|)
decl_stmt|;
return|return
name|Batchable
operator|.
name|runBatched
argument_list|(
name|batchSize
argument_list|,
name|colNames
argument_list|,
operator|new
name|Batchable
argument_list|<
name|String
argument_list|,
name|ColumnStatisticsObj
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|run
parameter_list|(
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|inputColNames
parameter_list|)
throws|throws
name|MetaException
block|{
return|return
name|Batchable
operator|.
name|runBatched
argument_list|(
name|batchSize
argument_list|,
name|partNames
argument_list|,
operator|new
name|Batchable
argument_list|<
name|String
argument_list|,
name|ColumnStatisticsObj
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|run
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|inputPartNames
parameter_list|)
throws|throws
name|MetaException
block|{
return|return
name|columnStatisticsObjForPartitionsBatch
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|,
name|inputPartNames
argument_list|,
name|inputColNames
argument_list|,
name|engine
argument_list|,
name|areAllPartsFound
argument_list|,
name|useDensityFunctionForNDVEstimation
argument_list|,
name|ndvTuner
argument_list|,
name|enableBitVector
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
specifier|public
name|List
argument_list|<
name|ColStatsObjWithSourceInfo
argument_list|>
name|getColStatsForAllTablePartitions
parameter_list|(
name|String
name|catName
parameter_list|,
name|String
name|dbName
parameter_list|,
name|boolean
name|enableBitVector
parameter_list|)
throws|throws
name|MetaException
block|{
name|String
name|queryText
init|=
literal|"select \"TABLE_NAME\", \"PARTITION_NAME\", "
operator|+
name|getStatsList
argument_list|(
name|enableBitVector
argument_list|)
operator|+
literal|" from "
operator|+
literal|" "
operator|+
name|PART_COL_STATS
operator|+
literal|" where \"DB_NAME\" = ? and \"CAT_NAME\" = ?"
decl_stmt|;
name|long
name|start
init|=
literal|0
decl_stmt|;
name|long
name|end
init|=
literal|0
decl_stmt|;
name|Query
name|query
init|=
literal|null
decl_stmt|;
name|boolean
name|doTrace
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
name|Object
name|qResult
init|=
literal|null
decl_stmt|;
name|start
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|List
argument_list|<
name|ColStatsObjWithSourceInfo
argument_list|>
name|colStatsForDB
init|=
operator|new
name|ArrayList
argument_list|<
name|ColStatsObjWithSourceInfo
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|query
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
name|qResult
operator|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
operator|new
name|Object
index|[]
block|{
name|dbName
block|,
name|catName
block|}
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
if|if
condition|(
name|qResult
operator|==
literal|null
condition|)
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
return|return
name|colStatsForDB
return|;
block|}
name|end
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|list
init|=
name|MetastoreDirectSqlUtils
operator|.
name|ensureList
argument_list|(
name|qResult
argument_list|)
decl_stmt|;
for|for
control|(
name|Object
index|[]
name|row
range|:
name|list
control|)
block|{
name|String
name|tblName
init|=
operator|(
name|String
operator|)
name|row
index|[
literal|0
index|]
decl_stmt|;
name|String
name|partName
init|=
operator|(
name|String
operator|)
name|row
index|[
literal|1
index|]
decl_stmt|;
name|ColumnStatisticsObj
name|colStatObj
init|=
name|prepareCSObj
argument_list|(
name|row
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|colStatsForDB
operator|.
name|add
argument_list|(
operator|new
name|ColStatsObjWithSourceInfo
argument_list|(
name|colStatObj
argument_list|,
name|catName
argument_list|,
name|dbName
argument_list|,
name|tblName
argument_list|,
name|partName
argument_list|)
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
return|return
name|colStatsForDB
return|;
block|}
comment|/** Should be called with the list short enough to not trip up Oracle/etc. */
specifier|private
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|columnStatisticsObjForPartitionsBatch
parameter_list|(
name|String
name|catName
parameter_list|,
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|,
name|String
name|engine
parameter_list|,
name|boolean
name|areAllPartsFound
parameter_list|,
name|boolean
name|useDensityFunctionForNDVEstimation
parameter_list|,
name|double
name|ndvTuner
parameter_list|,
name|boolean
name|enableBitVector
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|enableBitVector
condition|)
block|{
return|return
name|aggrStatsUseJava
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|colNames
argument_list|,
name|engine
argument_list|,
name|areAllPartsFound
argument_list|,
name|useDensityFunctionForNDVEstimation
argument_list|,
name|ndvTuner
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|aggrStatsUseDB
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|colNames
argument_list|,
name|engine
argument_list|,
name|areAllPartsFound
argument_list|,
name|useDensityFunctionForNDVEstimation
argument_list|,
name|ndvTuner
argument_list|)
return|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|aggrStatsUseJava
parameter_list|(
name|String
name|catName
parameter_list|,
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|,
name|String
name|engine
parameter_list|,
name|boolean
name|areAllPartsFound
parameter_list|,
name|boolean
name|useDensityFunctionForNDVEstimation
parameter_list|,
name|double
name|ndvTuner
parameter_list|)
throws|throws
name|MetaException
block|{
comment|// 1. get all the stats for colNames in partNames;
name|List
argument_list|<
name|ColumnStatistics
argument_list|>
name|partStats
init|=
name|getPartitionStats
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|colNames
argument_list|,
name|engine
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// 2. use util function to aggr stats
return|return
name|MetaStoreServerUtils
operator|.
name|aggrPartitionStats
argument_list|(
name|partStats
argument_list|,
name|catName
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|colNames
argument_list|,
name|areAllPartsFound
argument_list|,
name|useDensityFunctionForNDVEstimation
argument_list|,
name|ndvTuner
argument_list|)
return|;
block|}
specifier|private
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|aggrStatsUseDB
parameter_list|(
name|String
name|catName
parameter_list|,
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|,
name|String
name|engine
parameter_list|,
name|boolean
name|areAllPartsFound
parameter_list|,
name|boolean
name|useDensityFunctionForNDVEstimation
parameter_list|,
name|double
name|ndvTuner
parameter_list|)
throws|throws
name|MetaException
block|{
comment|// TODO: all the extrapolation logic should be moved out of this class,
comment|// only mechanical data retrieval should remain here.
name|String
name|commonPrefix
init|=
literal|"select \"COLUMN_NAME\", \"COLUMN_TYPE\", "
operator|+
literal|"min(\"LONG_LOW_VALUE\"), max(\"LONG_HIGH_VALUE\"), min(\"DOUBLE_LOW_VALUE\"), max(\"DOUBLE_HIGH_VALUE\"), "
operator|+
literal|"min(cast(\"BIG_DECIMAL_LOW_VALUE\" as decimal)), max(cast(\"BIG_DECIMAL_HIGH_VALUE\" as decimal)), "
operator|+
literal|"sum(\"NUM_NULLS\"), max(\"NUM_DISTINCTS\"), "
operator|+
literal|"max(\"AVG_COL_LEN\"), max(\"MAX_COL_LEN\"), sum(\"NUM_TRUES\"), sum(\"NUM_FALSES\"), "
comment|// The following data is used to compute a partitioned table's NDV based
comment|// on partitions' NDV when useDensityFunctionForNDVEstimation = true. Global NDVs cannot be
comment|// accurately derived from partition NDVs, because the domain of column value two partitions
comment|// can overlap. If there is no overlap then global NDV is just the sum
comment|// of partition NDVs (UpperBound). But if there is some overlay then
comment|// global NDV can be anywhere between sum of partition NDVs (no overlap)
comment|// and same as one of the partition NDV (domain of column value in all other
comment|// partitions is subset of the domain value in one of the partition)
comment|// (LowerBound).But under uniform distribution, we can roughly estimate the global
comment|// NDV by leveraging the min/max values.
comment|// And, we also guarantee that the estimation makes sense by comparing it to the
comment|// UpperBound (calculated by "sum(\"NUM_DISTINCTS\")")
comment|// and LowerBound (calculated by "max(\"NUM_DISTINCTS\")")
operator|+
literal|"avg((\"LONG_HIGH_VALUE\"-\"LONG_LOW_VALUE\")/cast(\"NUM_DISTINCTS\" as decimal)),"
operator|+
literal|"avg((\"DOUBLE_HIGH_VALUE\"-\"DOUBLE_LOW_VALUE\")/\"NUM_DISTINCTS\"),"
operator|+
literal|"avg((cast(\"BIG_DECIMAL_HIGH_VALUE\" as decimal)-cast(\"BIG_DECIMAL_LOW_VALUE\" as decimal))/\"NUM_DISTINCTS\"),"
operator|+
literal|"sum(\"NUM_DISTINCTS\")"
operator|+
literal|" from "
operator|+
name|PART_COL_STATS
operator|+
literal|""
operator|+
literal|" where \"CAT_NAME\" = ? and \"DB_NAME\" = ? and \"TABLE_NAME\" = ? "
decl_stmt|;
name|String
name|queryText
init|=
literal|null
decl_stmt|;
name|long
name|start
init|=
literal|0
decl_stmt|;
name|long
name|end
init|=
literal|0
decl_stmt|;
name|Query
name|query
init|=
literal|null
decl_stmt|;
name|boolean
name|doTrace
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
name|Object
name|qResult
init|=
literal|null
decl_stmt|;
name|ForwardQueryResult
argument_list|<
name|?
argument_list|>
name|fqr
init|=
literal|null
decl_stmt|;
comment|// Check if the status of all the columns of all the partitions exists
comment|// Extrapolation is not needed.
if|if
condition|(
name|areAllPartsFound
condition|)
block|{
name|queryText
operator|=
name|commonPrefix
operator|+
literal|" and \"COLUMN_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|colNames
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
operator|+
literal|" and \"PARTITION_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|partNames
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
operator|+
literal|" and \"ENGINE\" = ? "
operator|+
literal|" group by \"COLUMN_NAME\", \"COLUMN_TYPE\""
expr_stmt|;
name|start
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|query
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
name|qResult
operator|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|prepareParams
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|colNames
argument_list|,
name|engine
argument_list|)
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
if|if
condition|(
name|qResult
operator|==
literal|null
condition|)
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
name|end
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|list
init|=
name|MetastoreDirectSqlUtils
operator|.
name|ensureList
argument_list|(
name|qResult
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|colStats
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnStatisticsObj
argument_list|>
argument_list|(
name|list
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Object
index|[]
name|row
range|:
name|list
control|)
block|{
name|colStats
operator|.
name|add
argument_list|(
name|prepareCSObjWithAdjustedNDV
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|useDensityFunctionForNDVEstimation
argument_list|,
name|ndvTuner
argument_list|)
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
block|}
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
return|return
name|colStats
return|;
block|}
else|else
block|{
comment|// Extrapolation is needed for some columns.
comment|// In this case, at least a column status for a partition is missing.
comment|// We need to extrapolate this partition based on the other partitions
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|colStats
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnStatisticsObj
argument_list|>
argument_list|(
name|colNames
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|queryText
operator|=
literal|"select \"COLUMN_NAME\", \"COLUMN_TYPE\", count(\"PARTITION_NAME\") "
operator|+
literal|" from "
operator|+
name|PART_COL_STATS
operator|+
literal|" where \"CAT_NAME\" = ? and \"DB_NAME\" = ? and \"TABLE_NAME\" = ? "
operator|+
literal|" and \"COLUMN_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|colNames
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
operator|+
literal|" and \"PARTITION_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|partNames
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
operator|+
literal|" and \"ENGINE\" = ? "
operator|+
literal|" group by \"COLUMN_NAME\", \"COLUMN_TYPE\""
expr_stmt|;
name|start
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|query
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
name|qResult
operator|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|prepareParams
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|colNames
argument_list|,
name|engine
argument_list|)
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
name|end
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|qResult
operator|==
literal|null
condition|)
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|noExtraColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
index|[]
argument_list|>
name|extraColumnNameTypeParts
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
index|[]
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|list
init|=
name|MetastoreDirectSqlUtils
operator|.
name|ensureList
argument_list|(
name|qResult
argument_list|)
decl_stmt|;
for|for
control|(
name|Object
index|[]
name|row
range|:
name|list
control|)
block|{
name|String
name|colName
init|=
operator|(
name|String
operator|)
name|row
index|[
literal|0
index|]
decl_stmt|;
name|String
name|colType
init|=
operator|(
name|String
operator|)
name|row
index|[
literal|1
index|]
decl_stmt|;
comment|// Extrapolation is not needed for this column if
comment|// count(\"PARTITION_NAME\")==partNames.size()
comment|// Or, extrapolation is not possible for this column if
comment|// count(\"PARTITION_NAME\")<2
name|Long
name|count
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlLong
argument_list|(
name|row
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|==
name|partNames
operator|.
name|size
argument_list|()
operator|||
name|count
operator|<
literal|2
condition|)
block|{
name|noExtraColumnNames
operator|.
name|add
argument_list|(
name|colName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|extraColumnNameTypeParts
operator|.
name|put
argument_list|(
name|colName
argument_list|,
operator|new
name|String
index|[]
block|{
name|colType
block|,
name|String
operator|.
name|valueOf
argument_list|(
name|count
argument_list|)
block|}
argument_list|)
expr_stmt|;
block|}
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
block|}
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
comment|// Extrapolation is not needed for columns noExtraColumnNames
if|if
condition|(
name|noExtraColumnNames
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|queryText
operator|=
name|commonPrefix
operator|+
literal|" and \"COLUMN_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|noExtraColumnNames
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
operator|+
literal|" and \"PARTITION_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|partNames
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
operator|+
literal|" and \"ENGINE\" = ? "
operator|+
literal|" group by \"COLUMN_NAME\", \"COLUMN_TYPE\""
expr_stmt|;
name|start
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|query
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
name|qResult
operator|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|prepareParams
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|noExtraColumnNames
argument_list|,
name|engine
argument_list|)
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
if|if
condition|(
name|qResult
operator|==
literal|null
condition|)
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
name|list
operator|=
name|MetastoreDirectSqlUtils
operator|.
name|ensureList
argument_list|(
name|qResult
argument_list|)
expr_stmt|;
for|for
control|(
name|Object
index|[]
name|row
range|:
name|list
control|)
block|{
name|colStats
operator|.
name|add
argument_list|(
name|prepareCSObjWithAdjustedNDV
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|useDensityFunctionForNDVEstimation
argument_list|,
name|ndvTuner
argument_list|)
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
block|}
name|end
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
comment|// Extrapolation is needed for extraColumnNames.
comment|// give a sequence number for all the partitions
if|if
condition|(
name|extraColumnNameTypeParts
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|indexMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|partNames
operator|.
name|size
argument_list|()
condition|;
name|index
operator|++
control|)
block|{
name|indexMap
operator|.
name|put
argument_list|(
name|partNames
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
comment|// get sum for all columns to reduce the number of queries
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|Object
argument_list|>
argument_list|>
name|sumMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|Object
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|queryText
operator|=
literal|"select \"COLUMN_NAME\", sum(\"NUM_NULLS\"), sum(\"NUM_TRUES\"), sum(\"NUM_FALSES\"), sum(\"NUM_DISTINCTS\")"
operator|+
literal|" from "
operator|+
name|PART_COL_STATS
operator|+
literal|" where \"CAT_NAME\" = ? and \"DB_NAME\" = ? and \"TABLE_NAME\" = ? "
operator|+
literal|" and \"COLUMN_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|extraColumnNameTypeParts
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
operator|+
literal|" and \"PARTITION_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|partNames
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
operator|+
literal|" and \"ENGINE\" = ? "
operator|+
literal|" group by \"COLUMN_NAME\""
expr_stmt|;
name|start
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|query
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|extraColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|extraColumnNames
operator|.
name|addAll
argument_list|(
name|extraColumnNameTypeParts
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|qResult
operator|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|prepareParams
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|extraColumnNames
argument_list|,
name|engine
argument_list|)
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
if|if
condition|(
name|qResult
operator|==
literal|null
condition|)
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
name|list
operator|=
name|MetastoreDirectSqlUtils
operator|.
name|ensureList
argument_list|(
name|qResult
argument_list|)
expr_stmt|;
comment|// see the indexes for colstats in IExtrapolatePartStatus
name|Integer
index|[]
name|sumIndex
init|=
operator|new
name|Integer
index|[]
block|{
literal|6
block|,
literal|10
block|,
literal|11
block|,
literal|15
block|}
decl_stmt|;
for|for
control|(
name|Object
index|[]
name|row
range|:
name|list
control|)
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|Object
argument_list|>
name|indexToObject
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|ind
init|=
literal|1
init|;
name|ind
operator|<
name|row
operator|.
name|length
condition|;
name|ind
operator|++
control|)
block|{
name|indexToObject
operator|.
name|put
argument_list|(
name|sumIndex
index|[
name|ind
operator|-
literal|1
index|]
argument_list|,
name|row
index|[
name|ind
index|]
argument_list|)
expr_stmt|;
block|}
comment|// row[0] is the column name
name|sumMap
operator|.
name|put
argument_list|(
operator|(
name|String
operator|)
name|row
index|[
literal|0
index|]
argument_list|,
name|indexToObject
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
block|}
name|end
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
index|[]
argument_list|>
name|entry
range|:
name|extraColumnNameTypeParts
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Object
index|[]
name|row
init|=
operator|new
name|Object
index|[
name|IExtrapolatePartStatus
operator|.
name|colStatNames
operator|.
name|length
operator|+
literal|2
index|]
decl_stmt|;
name|String
name|colName
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|colType
init|=
name|entry
operator|.
name|getValue
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
name|Long
name|sumVal
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
comment|// fill in colname
name|row
index|[
literal|0
index|]
operator|=
name|colName
expr_stmt|;
comment|// fill in coltype
name|row
index|[
literal|1
index|]
operator|=
name|colType
expr_stmt|;
comment|// use linear extrapolation. more complicated one can be added in the
comment|// future.
name|IExtrapolatePartStatus
name|extrapolateMethod
init|=
operator|new
name|LinearExtrapolatePartStatus
argument_list|()
decl_stmt|;
comment|// fill in colstatus
name|Integer
index|[]
name|index
init|=
literal|null
decl_stmt|;
name|boolean
name|decimal
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|colType
operator|.
name|toLowerCase
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"decimal"
argument_list|)
condition|)
block|{
name|index
operator|=
name|IExtrapolatePartStatus
operator|.
name|indexMaps
operator|.
name|get
argument_list|(
literal|"decimal"
argument_list|)
expr_stmt|;
name|decimal
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|index
operator|=
name|IExtrapolatePartStatus
operator|.
name|indexMaps
operator|.
name|get
argument_list|(
name|colType
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// if the colType is not the known type, long, double, etc, then get
comment|// all index.
if|if
condition|(
name|index
operator|==
literal|null
condition|)
block|{
name|index
operator|=
name|IExtrapolatePartStatus
operator|.
name|indexMaps
operator|.
name|get
argument_list|(
literal|"default"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|colStatIndex
range|:
name|index
control|)
block|{
name|String
name|colStatName
init|=
name|IExtrapolatePartStatus
operator|.
name|colStatNames
index|[
name|colStatIndex
index|]
decl_stmt|;
comment|// if the aggregation type is sum, we do a scale-up
if|if
condition|(
name|IExtrapolatePartStatus
operator|.
name|aggrTypes
index|[
name|colStatIndex
index|]
operator|==
name|IExtrapolatePartStatus
operator|.
name|AggrType
operator|.
name|Sum
condition|)
block|{
name|Object
name|o
init|=
name|sumMap
operator|.
name|get
argument_list|(
name|colName
argument_list|)
operator|.
name|get
argument_list|(
name|colStatIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
name|row
index|[
literal|2
operator|+
name|colStatIndex
index|]
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|Long
name|val
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlLong
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|row
index|[
literal|2
operator|+
name|colStatIndex
index|]
operator|=
name|val
operator|/
name|sumVal
operator|*
operator|(
name|partNames
operator|.
name|size
argument_list|()
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IExtrapolatePartStatus
operator|.
name|aggrTypes
index|[
name|colStatIndex
index|]
operator|==
name|IExtrapolatePartStatus
operator|.
name|AggrType
operator|.
name|Min
operator|||
name|IExtrapolatePartStatus
operator|.
name|aggrTypes
index|[
name|colStatIndex
index|]
operator|==
name|IExtrapolatePartStatus
operator|.
name|AggrType
operator|.
name|Max
condition|)
block|{
comment|// if the aggregation type is min/max, we extrapolate from the
comment|// left/right borders
if|if
condition|(
operator|!
name|decimal
condition|)
block|{
name|queryText
operator|=
literal|"select \""
operator|+
name|colStatName
operator|+
literal|"\",\"PARTITION_NAME\" from "
operator|+
name|PART_COL_STATS
operator|+
literal|" where \"CAT_NAME\" = ? and \"DB_NAME\" = ? and \"TABLE_NAME\" = ?"
operator|+
literal|" and \"COLUMN_NAME\" = ?"
operator|+
literal|" and \"PARTITION_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|partNames
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
operator|+
literal|" and \"ENGINE\" = ? "
operator|+
literal|" order by \""
operator|+
name|colStatName
operator|+
literal|"\""
expr_stmt|;
block|}
else|else
block|{
name|queryText
operator|=
literal|"select \""
operator|+
name|colStatName
operator|+
literal|"\",\"PARTITION_NAME\" from "
operator|+
name|PART_COL_STATS
operator|+
literal|" where \"CAT_NAME\" = ? and \"DB_NAME\" = ? and \"TABLE_NAME\" = ?"
operator|+
literal|" and \"COLUMN_NAME\" = ?"
operator|+
literal|" and \"PARTITION_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|partNames
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
operator|+
literal|" and \"ENGINE\" = ? "
operator|+
literal|" order by cast(\""
operator|+
name|colStatName
operator|+
literal|"\" as decimal)"
expr_stmt|;
block|}
name|start
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|query
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
name|qResult
operator|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|prepareParams
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|colName
argument_list|)
argument_list|,
name|engine
argument_list|)
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
if|if
condition|(
name|qResult
operator|==
literal|null
condition|)
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
name|fqr
operator|=
operator|(
name|ForwardQueryResult
argument_list|<
name|?
argument_list|>
operator|)
name|qResult
expr_stmt|;
name|Object
index|[]
name|min
init|=
operator|(
name|Object
index|[]
operator|)
operator|(
name|fqr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
decl_stmt|;
name|Object
index|[]
name|max
init|=
operator|(
name|Object
index|[]
operator|)
operator|(
name|fqr
operator|.
name|get
argument_list|(
name|fqr
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|)
decl_stmt|;
name|end
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
if|if
condition|(
name|min
index|[
literal|0
index|]
operator|==
literal|null
operator|||
name|max
index|[
literal|0
index|]
operator|==
literal|null
condition|)
block|{
name|row
index|[
literal|2
operator|+
name|colStatIndex
index|]
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|row
index|[
literal|2
operator|+
name|colStatIndex
index|]
operator|=
name|extrapolateMethod
operator|.
name|extrapolate
argument_list|(
name|min
argument_list|,
name|max
argument_list|,
name|colStatIndex
argument_list|,
name|indexMap
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// if the aggregation type is avg, we use the average on the existing ones.
name|queryText
operator|=
literal|"select "
operator|+
literal|"avg((\"LONG_HIGH_VALUE\"-\"LONG_LOW_VALUE\")/cast(\"NUM_DISTINCTS\" as decimal)),"
operator|+
literal|"avg((\"DOUBLE_HIGH_VALUE\"-\"DOUBLE_LOW_VALUE\")/\"NUM_DISTINCTS\"),"
operator|+
literal|"avg((cast(\"BIG_DECIMAL_HIGH_VALUE\" as decimal)-cast(\"BIG_DECIMAL_LOW_VALUE\" as decimal))/\"NUM_DISTINCTS\")"
operator|+
literal|" from "
operator|+
name|PART_COL_STATS
operator|+
literal|""
operator|+
literal|" where \"CAT_NAME\" = ? and \"DB_NAME\" = ? and \"TABLE_NAME\" = ?"
operator|+
literal|" and \"COLUMN_NAME\" = ?"
operator|+
literal|" and \"PARTITION_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|partNames
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
operator|+
literal|" and \"ENGINE\" = ? "
operator|+
literal|" group by \"COLUMN_NAME\""
expr_stmt|;
name|start
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|query
operator|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
name|qResult
operator|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|prepareParams
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|colName
argument_list|)
argument_list|,
name|engine
argument_list|)
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
if|if
condition|(
name|qResult
operator|==
literal|null
condition|)
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
name|fqr
operator|=
operator|(
name|ForwardQueryResult
argument_list|<
name|?
argument_list|>
operator|)
name|qResult
expr_stmt|;
name|Object
index|[]
name|avg
init|=
operator|(
name|Object
index|[]
operator|)
operator|(
name|fqr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
decl_stmt|;
comment|// colStatIndex=12,13,14 respond to "AVG_LONG", "AVG_DOUBLE",
comment|// "AVG_DECIMAL"
name|row
index|[
literal|2
operator|+
name|colStatIndex
index|]
operator|=
name|avg
index|[
name|colStatIndex
operator|-
literal|12
index|]
expr_stmt|;
name|end
operator|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
block|}
name|colStats
operator|.
name|add
argument_list|(
name|prepareCSObjWithAdjustedNDV
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|useDensityFunctionForNDVEstimation
argument_list|,
name|ndvTuner
argument_list|)
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|colStats
return|;
block|}
block|}
specifier|private
name|ColumnStatisticsObj
name|prepareCSObj
parameter_list|(
name|Object
index|[]
name|row
parameter_list|,
name|int
name|i
parameter_list|)
throws|throws
name|MetaException
block|{
name|ColumnStatisticsData
name|data
init|=
operator|new
name|ColumnStatisticsData
argument_list|()
decl_stmt|;
name|ColumnStatisticsObj
name|cso
init|=
operator|new
name|ColumnStatisticsObj
argument_list|(
operator|(
name|String
operator|)
name|row
index|[
name|i
operator|++
index|]
argument_list|,
operator|(
name|String
operator|)
name|row
index|[
name|i
operator|++
index|]
argument_list|,
name|data
argument_list|)
decl_stmt|;
name|Object
name|llow
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|lhigh
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|dlow
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|dhigh
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|declow
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|dechigh
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|nulls
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|dist
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|bitVector
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|avglen
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|maxlen
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|trues
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|falses
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|;
name|StatObjectConverter
operator|.
name|fillColumnStatisticsData
argument_list|(
name|cso
operator|.
name|getColType
argument_list|()
argument_list|,
name|data
argument_list|,
name|llow
argument_list|,
name|lhigh
argument_list|,
name|dlow
argument_list|,
name|dhigh
argument_list|,
name|declow
argument_list|,
name|dechigh
argument_list|,
name|nulls
argument_list|,
name|dist
argument_list|,
name|bitVector
argument_list|,
name|avglen
argument_list|,
name|maxlen
argument_list|,
name|trues
argument_list|,
name|falses
argument_list|)
expr_stmt|;
return|return
name|cso
return|;
block|}
specifier|private
name|ColumnStatisticsObj
name|prepareCSObjWithAdjustedNDV
parameter_list|(
name|Object
index|[]
name|row
parameter_list|,
name|int
name|i
parameter_list|,
name|boolean
name|useDensityFunctionForNDVEstimation
parameter_list|,
name|double
name|ndvTuner
parameter_list|)
throws|throws
name|MetaException
block|{
name|ColumnStatisticsData
name|data
init|=
operator|new
name|ColumnStatisticsData
argument_list|()
decl_stmt|;
name|ColumnStatisticsObj
name|cso
init|=
operator|new
name|ColumnStatisticsObj
argument_list|(
operator|(
name|String
operator|)
name|row
index|[
name|i
operator|++
index|]
argument_list|,
operator|(
name|String
operator|)
name|row
index|[
name|i
operator|++
index|]
argument_list|,
name|data
argument_list|)
decl_stmt|;
name|Object
name|llow
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|lhigh
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|dlow
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|dhigh
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|declow
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|dechigh
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|nulls
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|dist
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|avglen
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|maxlen
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|trues
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|falses
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|avgLong
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|avgDouble
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|avgDecimal
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|,
name|sumDist
init|=
name|row
index|[
name|i
operator|++
index|]
decl_stmt|;
name|StatObjectConverter
operator|.
name|fillColumnStatisticsData
argument_list|(
name|cso
operator|.
name|getColType
argument_list|()
argument_list|,
name|data
argument_list|,
name|llow
argument_list|,
name|lhigh
argument_list|,
name|dlow
argument_list|,
name|dhigh
argument_list|,
name|declow
argument_list|,
name|dechigh
argument_list|,
name|nulls
argument_list|,
name|dist
argument_list|,
name|avglen
argument_list|,
name|maxlen
argument_list|,
name|trues
argument_list|,
name|falses
argument_list|,
name|avgLong
argument_list|,
name|avgDouble
argument_list|,
name|avgDecimal
argument_list|,
name|sumDist
argument_list|,
name|useDensityFunctionForNDVEstimation
argument_list|,
name|ndvTuner
argument_list|)
expr_stmt|;
return|return
name|cso
return|;
block|}
specifier|private
name|Object
index|[]
name|prepareParams
parameter_list|(
name|String
name|catName
parameter_list|,
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|,
name|String
name|engine
parameter_list|)
throws|throws
name|MetaException
block|{
name|Object
index|[]
name|params
init|=
operator|new
name|Object
index|[
name|colNames
operator|.
name|size
argument_list|()
operator|+
name|partNames
operator|.
name|size
argument_list|()
operator|+
literal|4
index|]
decl_stmt|;
name|int
name|paramI
init|=
literal|0
decl_stmt|;
name|params
index|[
name|paramI
operator|++
index|]
operator|=
name|catName
expr_stmt|;
name|params
index|[
name|paramI
operator|++
index|]
operator|=
name|dbName
expr_stmt|;
name|params
index|[
name|paramI
operator|++
index|]
operator|=
name|tableName
expr_stmt|;
for|for
control|(
name|String
name|colName
range|:
name|colNames
control|)
block|{
name|params
index|[
name|paramI
operator|++
index|]
operator|=
name|colName
expr_stmt|;
block|}
for|for
control|(
name|String
name|partName
range|:
name|partNames
control|)
block|{
name|params
index|[
name|paramI
operator|++
index|]
operator|=
name|partName
expr_stmt|;
block|}
name|params
index|[
name|paramI
operator|++
index|]
operator|=
name|engine
expr_stmt|;
return|return
name|params
return|;
block|}
specifier|public
name|List
argument_list|<
name|ColumnStatistics
argument_list|>
name|getPartitionStats
parameter_list|(
specifier|final
name|String
name|catName
parameter_list|,
specifier|final
name|String
name|dbName
parameter_list|,
specifier|final
name|String
name|tableName
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|,
name|String
name|engine
parameter_list|,
name|boolean
name|enableBitVector
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|colNames
operator|.
name|isEmpty
argument_list|()
operator|||
name|partNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
specifier|final
name|boolean
name|doTrace
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
specifier|final
name|String
name|queryText0
init|=
literal|"select \"PARTITION_NAME\", "
operator|+
name|getStatsList
argument_list|(
name|enableBitVector
argument_list|)
operator|+
literal|" from "
operator|+
literal|" "
operator|+
name|PART_COL_STATS
operator|+
literal|" where \"CAT_NAME\" = ? and \"DB_NAME\" = ? and \"TABLE_NAME\" = ? and "
operator|+
literal|"\"COLUMN_NAME\""
operator|+
literal|"  in (%1$s) AND \"PARTITION_NAME\" in (%2$s) "
operator|+
literal|" and \"ENGINE\" = ? "
operator|+
literal|" order by \"PARTITION_NAME\""
decl_stmt|;
name|Batchable
argument_list|<
name|String
argument_list|,
name|Object
index|[]
argument_list|>
name|b
init|=
operator|new
name|Batchable
argument_list|<
name|String
argument_list|,
name|Object
index|[]
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|run
parameter_list|(
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|inputColNames
parameter_list|)
throws|throws
name|MetaException
block|{
name|Batchable
argument_list|<
name|String
argument_list|,
name|Object
index|[]
argument_list|>
name|b2
init|=
operator|new
name|Batchable
argument_list|<
name|String
argument_list|,
name|Object
index|[]
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|run
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|inputPartNames
parameter_list|)
throws|throws
name|MetaException
block|{
name|String
name|queryText
init|=
name|String
operator|.
name|format
argument_list|(
name|queryText0
argument_list|,
name|makeParams
argument_list|(
name|inputColNames
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|makeParams
argument_list|(
name|inputPartNames
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|start
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|Query
name|query
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|Object
name|qResult
init|=
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|prepareParams
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|,
name|inputPartNames
argument_list|,
name|inputColNames
argument_list|,
name|engine
argument_list|)
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText0
argument_list|,
name|start
argument_list|,
operator|(
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qResult
operator|==
literal|null
condition|)
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
name|addQueryAfterUse
argument_list|(
name|query
argument_list|)
expr_stmt|;
return|return
name|MetastoreDirectSqlUtils
operator|.
name|ensureList
argument_list|(
name|qResult
argument_list|)
return|;
block|}
block|}
decl_stmt|;
try|try
block|{
return|return
name|Batchable
operator|.
name|runBatched
argument_list|(
name|batchSize
argument_list|,
name|partNames
argument_list|,
name|b2
argument_list|)
return|;
block|}
finally|finally
block|{
name|addQueryAfterUse
argument_list|(
name|b2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|list
init|=
name|Batchable
operator|.
name|runBatched
argument_list|(
name|batchSize
argument_list|,
name|colNames
argument_list|,
name|b
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ColumnStatistics
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnStatistics
argument_list|>
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|list
operator|.
name|size
argument_list|()
argument_list|,
name|partNames
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|lastPartName
init|=
literal|null
decl_stmt|;
name|int
name|from
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|boolean
name|isLast
init|=
name|i
operator|==
name|list
operator|.
name|size
argument_list|()
decl_stmt|;
name|String
name|partName
init|=
name|isLast
condition|?
literal|null
else|:
operator|(
name|String
operator|)
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|isLast
operator|&&
name|partName
operator|.
name|equals
argument_list|(
name|lastPartName
argument_list|)
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|from
operator|!=
name|i
condition|)
block|{
name|ColumnStatisticsDesc
name|csd
init|=
operator|new
name|ColumnStatisticsDesc
argument_list|(
literal|false
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
name|csd
operator|.
name|setCatName
argument_list|(
name|catName
argument_list|)
expr_stmt|;
name|csd
operator|.
name|setPartName
argument_list|(
name|lastPartName
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
name|makeColumnStats
argument_list|(
name|list
operator|.
name|subList
argument_list|(
name|from
argument_list|,
name|i
argument_list|)
argument_list|,
name|csd
argument_list|,
literal|1
argument_list|,
name|engine
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lastPartName
operator|=
name|partName
expr_stmt|;
name|from
operator|=
name|i
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
block|}
name|b
operator|.
name|closeAllQueries
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/** The common query part for table and partition stats */
specifier|private
specifier|final
name|String
name|getStatsList
parameter_list|(
name|boolean
name|enableBitVector
parameter_list|)
block|{
return|return
literal|"\"COLUMN_NAME\", \"COLUMN_TYPE\", \"LONG_LOW_VALUE\", \"LONG_HIGH_VALUE\", "
operator|+
literal|"\"DOUBLE_LOW_VALUE\", \"DOUBLE_HIGH_VALUE\", \"BIG_DECIMAL_LOW_VALUE\", "
operator|+
literal|"\"BIG_DECIMAL_HIGH_VALUE\", \"NUM_NULLS\", \"NUM_DISTINCTS\", "
operator|+
operator|(
name|enableBitVector
condition|?
literal|"\"BIT_VECTOR\", "
else|:
literal|"\'\', "
operator|)
operator|+
literal|"\"AVG_COL_LEN\", "
operator|+
literal|"\"MAX_COL_LEN\", \"NUM_TRUES\", \"NUM_FALSES\", \"LAST_ANALYZED\" "
return|;
block|}
specifier|private
name|ColumnStatistics
name|makeColumnStats
parameter_list|(
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|list
parameter_list|,
name|ColumnStatisticsDesc
name|csd
parameter_list|,
name|int
name|offset
parameter_list|,
name|String
name|engine
parameter_list|)
throws|throws
name|MetaException
block|{
name|ColumnStatistics
name|result
init|=
operator|new
name|ColumnStatistics
argument_list|()
decl_stmt|;
name|result
operator|.
name|setStatsDesc
argument_list|(
name|csd
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|csos
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnStatisticsObj
argument_list|>
argument_list|(
name|list
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Object
index|[]
name|row
range|:
name|list
control|)
block|{
comment|// LastAnalyzed is stored per column but thrift has it per several;
comment|// get the lowest for now as nobody actually uses this field.
name|Object
name|laObj
init|=
name|row
index|[
name|offset
operator|+
literal|15
index|]
decl_stmt|;
if|if
condition|(
name|laObj
operator|!=
literal|null
operator|&&
operator|(
operator|!
name|csd
operator|.
name|isSetLastAnalyzed
argument_list|()
operator|||
name|csd
operator|.
name|getLastAnalyzed
argument_list|()
operator|>
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlLong
argument_list|(
name|laObj
argument_list|)
operator|)
condition|)
block|{
name|csd
operator|.
name|setLastAnalyzed
argument_list|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlLong
argument_list|(
name|laObj
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|csos
operator|.
name|add
argument_list|(
name|prepareCSObj
argument_list|(
name|row
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|setStatsObj
argument_list|(
name|csos
argument_list|)
expr_stmt|;
name|result
operator|.
name|setEngine
argument_list|(
name|engine
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
name|String
name|makeParams
parameter_list|(
name|int
name|size
parameter_list|)
block|{
comment|// W/ size 0, query will fail, but at least we'd get to see the query in debug output.
return|return
operator|(
name|size
operator|==
literal|0
operator|)
condition|?
literal|""
else|:
name|repeat
argument_list|(
literal|",?"
argument_list|,
name|size
argument_list|)
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
parameter_list|<
name|T
parameter_list|>
name|T
name|executeWithArray
parameter_list|(
name|Query
name|query
parameter_list|,
name|Object
index|[]
name|params
parameter_list|,
name|String
name|sql
parameter_list|)
throws|throws
name|MetaException
block|{
return|return
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|params
argument_list|,
name|sql
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
parameter_list|<
name|T
parameter_list|>
name|T
name|executeWithArray
parameter_list|(
name|Query
name|query
parameter_list|,
name|Object
index|[]
name|params
parameter_list|,
name|String
name|sql
parameter_list|,
name|int
name|limit
parameter_list|)
throws|throws
name|MetaException
block|{
return|return
name|MetastoreDirectSqlUtils
operator|.
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|params
argument_list|,
name|sql
argument_list|,
name|limit
argument_list|)
return|;
block|}
comment|/**    * This run the necessary logic to prepare for queries. It should be called once, after the    * txn on DataNucleus connection is opened, and before any queries are issued. What it does    * currently is run db-specific logic, e.g. setting ansi quotes mode for MySQL. The reason it    * must be used inside of the txn is connection pooling; there's no way to guarantee that the    * effect will apply to the connection that is executing the queries otherwise.    */
specifier|public
name|void
name|prepareTxn
parameter_list|()
throws|throws
name|MetaException
block|{
if|if
condition|(
name|dbType
operator|!=
name|DatabaseProduct
operator|.
name|MYSQL
condition|)
return|return;
try|try
block|{
assert|assert
name|pm
operator|.
name|currentTransaction
argument_list|()
operator|.
name|isActive
argument_list|()
assert|;
comment|// must be inside tx together with queries
name|executeNoResult
argument_list|(
literal|"SET @@session.sql_mode=ANSI_QUOTES"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|sqlEx
parameter_list|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Error setting ansi quotes: "
operator|+
name|sqlEx
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|public
name|List
argument_list|<
name|SQLForeignKey
argument_list|>
name|getForeignKeys
parameter_list|(
name|String
name|catName
parameter_list|,
name|String
name|parent_db_name
parameter_list|,
name|String
name|parent_tbl_name
parameter_list|,
name|String
name|foreign_db_name
parameter_list|,
name|String
name|foreign_tbl_name
parameter_list|)
throws|throws
name|MetaException
block|{
name|List
argument_list|<
name|SQLForeignKey
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|String
name|queryText
init|=
literal|"SELECT  \"D2\".\"NAME\", \"T2\".\"TBL_NAME\", "
operator|+
literal|"CASE WHEN \"C2\".\"COLUMN_NAME\" IS NOT NULL THEN \"C2\".\"COLUMN_NAME\" "
operator|+
literal|"ELSE \"P2\".\"PKEY_NAME\" END, "
operator|+
literal|""
operator|+
name|DBS
operator|+
literal|".\"NAME\", "
operator|+
name|TBLS
operator|+
literal|".\"TBL_NAME\", "
operator|+
literal|"CASE WHEN "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"COLUMN_NAME\" IS NOT NULL THEN "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"COLUMN_NAME\" "
operator|+
literal|"ELSE "
operator|+
name|PARTITION_KEYS
operator|+
literal|".\"PKEY_NAME\" END, "
operator|+
literal|""
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"POSITION\", "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"UPDATE_RULE\", "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"DELETE_RULE\", "
operator|+
literal|""
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"CONSTRAINT_NAME\" , \"KEY_CONSTRAINTS2\".\"CONSTRAINT_NAME\", "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"ENABLE_VALIDATE_RELY\" "
operator|+
literal|" from "
operator|+
name|TBLS
operator|+
literal|" "
operator|+
literal|" INNER JOIN "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"TBL_ID\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"CHILD_TBL_ID\" "
operator|+
literal|" INNER JOIN "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|" \"KEY_CONSTRAINTS2\" ON \"KEY_CONSTRAINTS2\".\"PARENT_TBL_ID\"  = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_TBL_ID\" "
operator|+
literal|" AND \"KEY_CONSTRAINTS2\".\"PARENT_CD_ID\"  = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_CD_ID\" AND "
operator|+
literal|" \"KEY_CONSTRAINTS2\".\"PARENT_INTEGER_IDX\"  = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_INTEGER_IDX\" "
operator|+
literal|" INNER JOIN "
operator|+
name|DBS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"DB_ID\" = "
operator|+
name|DBS
operator|+
literal|".\"DB_ID\" "
operator|+
literal|" INNER JOIN "
operator|+
name|TBLS
operator|+
literal|" \"T2\" ON  "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_TBL_ID\" = \"T2\".\"TBL_ID\" "
operator|+
literal|" INNER JOIN "
operator|+
name|DBS
operator|+
literal|" \"D2\" ON \"T2\".\"DB_ID\" = \"D2\".\"DB_ID\" "
operator|+
literal|" LEFT OUTER JOIN "
operator|+
name|COLUMNS_V2
operator|+
literal|"  ON "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"CD_ID\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"CHILD_CD_ID\" AND "
operator|+
literal|" "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"INTEGER_IDX\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"CHILD_INTEGER_IDX\" "
operator|+
literal|" LEFT OUTER JOIN "
operator|+
name|PARTITION_KEYS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"TBL_ID\" = "
operator|+
name|PARTITION_KEYS
operator|+
literal|".\"TBL_ID\" AND "
operator|+
literal|" "
operator|+
name|PARTITION_KEYS
operator|+
literal|".\"INTEGER_IDX\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"CHILD_INTEGER_IDX\" "
operator|+
literal|" LEFT OUTER JOIN "
operator|+
name|COLUMNS_V2
operator|+
literal|" \"C2\" ON \"C2\".\"CD_ID\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_CD_ID\" AND "
operator|+
literal|" \"C2\".\"INTEGER_IDX\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_INTEGER_IDX\" "
operator|+
literal|" LEFT OUTER JOIN "
operator|+
name|PARTITION_KEYS
operator|+
literal|" \"P2\" ON \"P2\".\"TBL_ID\" = "
operator|+
name|TBLS
operator|+
literal|".\"TBL_ID\" AND "
operator|+
literal|" \"P2\".\"INTEGER_IDX\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_INTEGER_IDX\" "
operator|+
literal|" WHERE "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"CONSTRAINT_TYPE\" = "
operator|+
name|MConstraint
operator|.
name|FOREIGN_KEY_CONSTRAINT
operator|+
literal|" AND \"KEY_CONSTRAINTS2\".\"CONSTRAINT_TYPE\" = "
operator|+
name|MConstraint
operator|.
name|PRIMARY_KEY_CONSTRAINT
operator|+
literal|" AND"
operator|+
literal|" "
operator|+
name|DBS
operator|+
literal|".\"CTLG_NAME\" = ? AND"
operator|+
operator|(
name|foreign_db_name
operator|==
literal|null
condition|?
literal|""
else|:
literal|" "
operator|+
name|DBS
operator|+
literal|".\"NAME\" = ? AND"
operator|)
operator|+
operator|(
name|foreign_tbl_name
operator|==
literal|null
condition|?
literal|""
else|:
literal|" "
operator|+
name|TBLS
operator|+
literal|".\"TBL_NAME\" = ? AND"
operator|)
operator|+
operator|(
name|parent_tbl_name
operator|==
literal|null
condition|?
literal|""
else|:
literal|" \"T2\".\"TBL_NAME\" = ? AND"
operator|)
operator|+
operator|(
name|parent_db_name
operator|==
literal|null
condition|?
literal|""
else|:
literal|" \"D2\".\"NAME\" = ?"
operator|)
decl_stmt|;
name|queryText
operator|=
name|queryText
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|queryText
operator|.
name|endsWith
argument_list|(
literal|"AND"
argument_list|)
condition|)
block|{
name|queryText
operator|=
name|queryText
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|queryText
operator|.
name|length
argument_list|()
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|pms
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|pms
operator|.
name|add
argument_list|(
name|catName
argument_list|)
expr_stmt|;
if|if
condition|(
name|foreign_db_name
operator|!=
literal|null
condition|)
block|{
name|pms
operator|.
name|add
argument_list|(
name|foreign_db_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|foreign_tbl_name
operator|!=
literal|null
condition|)
block|{
name|pms
operator|.
name|add
argument_list|(
name|foreign_tbl_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parent_tbl_name
operator|!=
literal|null
condition|)
block|{
name|pms
operator|.
name|add
argument_list|(
name|parent_tbl_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parent_db_name
operator|!=
literal|null
condition|)
block|{
name|pms
operator|.
name|add
argument_list|(
name|parent_db_name
argument_list|)
expr_stmt|;
block|}
name|Query
name|queryParams
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|sqlResult
init|=
name|MetastoreDirectSqlUtils
operator|.
name|ensureList
argument_list|(
name|executeWithArray
argument_list|(
name|queryParams
argument_list|,
name|pms
operator|.
name|toArray
argument_list|()
argument_list|,
name|queryText
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sqlResult
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Object
index|[]
name|line
range|:
name|sqlResult
control|)
block|{
name|int
name|enableValidateRely
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlInt
argument_list|(
name|line
index|[
literal|11
index|]
argument_list|)
decl_stmt|;
name|boolean
name|enable
init|=
operator|(
name|enableValidateRely
operator|&
literal|4
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|validate
init|=
operator|(
name|enableValidateRely
operator|&
literal|2
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|rely
init|=
operator|(
name|enableValidateRely
operator|&
literal|1
operator|)
operator|!=
literal|0
decl_stmt|;
name|SQLForeignKey
name|currKey
init|=
operator|new
name|SQLForeignKey
argument_list|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|4
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|5
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlInt
argument_list|(
name|line
index|[
literal|6
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlInt
argument_list|(
name|line
index|[
literal|7
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlInt
argument_list|(
name|line
index|[
literal|8
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|9
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|10
index|]
argument_list|)
argument_list|,
name|enable
argument_list|,
name|validate
argument_list|,
name|rely
argument_list|)
decl_stmt|;
name|currKey
operator|.
name|setCatName
argument_list|(
name|catName
argument_list|)
expr_stmt|;
name|ret
operator|.
name|add
argument_list|(
name|currKey
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
specifier|public
name|List
argument_list|<
name|SQLPrimaryKey
argument_list|>
name|getPrimaryKeys
parameter_list|(
name|String
name|catName
parameter_list|,
name|String
name|db_name
parameter_list|,
name|String
name|tbl_name
parameter_list|)
throws|throws
name|MetaException
block|{
name|List
argument_list|<
name|SQLPrimaryKey
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|String
name|queryText
init|=
literal|"SELECT "
operator|+
name|DBS
operator|+
literal|".\"NAME\", "
operator|+
name|TBLS
operator|+
literal|".\"TBL_NAME\", "
operator|+
literal|"CASE WHEN "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"COLUMN_NAME\" IS NOT NULL THEN "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"COLUMN_NAME\" "
operator|+
literal|"ELSE "
operator|+
name|PARTITION_KEYS
operator|+
literal|".\"PKEY_NAME\" END, "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"POSITION\", "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"CONSTRAINT_NAME\", "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"ENABLE_VALIDATE_RELY\", "
operator|+
name|DBS
operator|+
literal|".\"CTLG_NAME\""
operator|+
literal|" from "
operator|+
name|TBLS
operator|+
literal|" "
operator|+
literal|" INNER JOIN "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"TBL_ID\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_TBL_ID\" "
operator|+
literal|" INNER JOIN "
operator|+
name|DBS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"DB_ID\" = "
operator|+
name|DBS
operator|+
literal|".\"DB_ID\" "
operator|+
literal|" LEFT OUTER JOIN "
operator|+
name|COLUMNS_V2
operator|+
literal|" ON "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"CD_ID\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_CD_ID\" AND "
operator|+
literal|" "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"INTEGER_IDX\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_INTEGER_IDX\" "
operator|+
literal|" LEFT OUTER JOIN "
operator|+
name|PARTITION_KEYS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"TBL_ID\" = "
operator|+
name|PARTITION_KEYS
operator|+
literal|".\"TBL_ID\" AND "
operator|+
literal|" "
operator|+
name|PARTITION_KEYS
operator|+
literal|".\"INTEGER_IDX\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_INTEGER_IDX\" "
operator|+
literal|" WHERE "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"CONSTRAINT_TYPE\" = "
operator|+
name|MConstraint
operator|.
name|PRIMARY_KEY_CONSTRAINT
operator|+
literal|" AND"
operator|+
literal|" "
operator|+
name|DBS
operator|+
literal|".\"CTLG_NAME\" = ? AND"
operator|+
operator|(
name|db_name
operator|==
literal|null
condition|?
literal|""
else|:
literal|" "
operator|+
name|DBS
operator|+
literal|".\"NAME\" = ? AND"
operator|)
operator|+
operator|(
name|tbl_name
operator|==
literal|null
condition|?
literal|""
else|:
literal|" "
operator|+
name|TBLS
operator|+
literal|".\"TBL_NAME\" = ? "
operator|)
decl_stmt|;
name|queryText
operator|=
name|queryText
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|queryText
operator|.
name|endsWith
argument_list|(
literal|"AND"
argument_list|)
condition|)
block|{
name|queryText
operator|=
name|queryText
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|queryText
operator|.
name|length
argument_list|()
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|pms
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|pms
operator|.
name|add
argument_list|(
name|catName
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_name
operator|!=
literal|null
condition|)
block|{
name|pms
operator|.
name|add
argument_list|(
name|db_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tbl_name
operator|!=
literal|null
condition|)
block|{
name|pms
operator|.
name|add
argument_list|(
name|tbl_name
argument_list|)
expr_stmt|;
block|}
name|Query
name|queryParams
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|sqlResult
init|=
name|MetastoreDirectSqlUtils
operator|.
name|ensureList
argument_list|(
name|executeWithArray
argument_list|(
name|queryParams
argument_list|,
name|pms
operator|.
name|toArray
argument_list|()
argument_list|,
name|queryText
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sqlResult
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Object
index|[]
name|line
range|:
name|sqlResult
control|)
block|{
name|int
name|enableValidateRely
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlInt
argument_list|(
name|line
index|[
literal|5
index|]
argument_list|)
decl_stmt|;
name|boolean
name|enable
init|=
operator|(
name|enableValidateRely
operator|&
literal|4
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|validate
init|=
operator|(
name|enableValidateRely
operator|&
literal|2
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|rely
init|=
operator|(
name|enableValidateRely
operator|&
literal|1
operator|)
operator|!=
literal|0
decl_stmt|;
name|SQLPrimaryKey
name|currKey
init|=
operator|new
name|SQLPrimaryKey
argument_list|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlInt
argument_list|(
name|line
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|4
index|]
argument_list|)
argument_list|,
name|enable
argument_list|,
name|validate
argument_list|,
name|rely
argument_list|)
decl_stmt|;
name|currKey
operator|.
name|setCatName
argument_list|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|6
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|add
argument_list|(
name|currKey
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
specifier|public
name|List
argument_list|<
name|SQLUniqueConstraint
argument_list|>
name|getUniqueConstraints
parameter_list|(
name|String
name|catName
parameter_list|,
name|String
name|db_name
parameter_list|,
name|String
name|tbl_name
parameter_list|)
throws|throws
name|MetaException
block|{
name|List
argument_list|<
name|SQLUniqueConstraint
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<
name|SQLUniqueConstraint
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|queryText
init|=
literal|"SELECT "
operator|+
name|DBS
operator|+
literal|".\"NAME\", "
operator|+
name|TBLS
operator|+
literal|".\"TBL_NAME\", "
operator|+
literal|"CASE WHEN "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"COLUMN_NAME\" IS NOT NULL THEN "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"COLUMN_NAME\" "
operator|+
literal|"ELSE "
operator|+
name|PARTITION_KEYS
operator|+
literal|".\"PKEY_NAME\" END, "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"POSITION\", "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"CONSTRAINT_NAME\", "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"ENABLE_VALIDATE_RELY\" "
operator|+
literal|" from "
operator|+
name|TBLS
operator|+
literal|" "
operator|+
literal|" INNER JOIN "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"TBL_ID\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_TBL_ID\" "
operator|+
literal|" INNER JOIN "
operator|+
name|DBS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"DB_ID\" = "
operator|+
name|DBS
operator|+
literal|".\"DB_ID\" "
operator|+
literal|" LEFT OUTER JOIN "
operator|+
name|COLUMNS_V2
operator|+
literal|" ON "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"CD_ID\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_CD_ID\" AND "
operator|+
literal|" "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"INTEGER_IDX\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_INTEGER_IDX\" "
operator|+
literal|" LEFT OUTER JOIN "
operator|+
name|PARTITION_KEYS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"TBL_ID\" = "
operator|+
name|PARTITION_KEYS
operator|+
literal|".\"TBL_ID\" AND "
operator|+
literal|" "
operator|+
name|PARTITION_KEYS
operator|+
literal|".\"INTEGER_IDX\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_INTEGER_IDX\" "
operator|+
literal|" WHERE "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"CONSTRAINT_TYPE\" = "
operator|+
name|MConstraint
operator|.
name|UNIQUE_CONSTRAINT
operator|+
literal|" AND"
operator|+
literal|" "
operator|+
name|DBS
operator|+
literal|".\"CTLG_NAME\" = ? AND"
operator|+
operator|(
name|db_name
operator|==
literal|null
condition|?
literal|""
else|:
literal|" "
operator|+
name|DBS
operator|+
literal|".\"NAME\" = ? AND"
operator|)
operator|+
operator|(
name|tbl_name
operator|==
literal|null
condition|?
literal|""
else|:
literal|" "
operator|+
name|TBLS
operator|+
literal|".\"TBL_NAME\" = ? "
operator|)
decl_stmt|;
name|queryText
operator|=
name|queryText
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|queryText
operator|.
name|endsWith
argument_list|(
literal|"AND"
argument_list|)
condition|)
block|{
name|queryText
operator|=
name|queryText
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|queryText
operator|.
name|length
argument_list|()
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|pms
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|pms
operator|.
name|add
argument_list|(
name|catName
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_name
operator|!=
literal|null
condition|)
block|{
name|pms
operator|.
name|add
argument_list|(
name|db_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tbl_name
operator|!=
literal|null
condition|)
block|{
name|pms
operator|.
name|add
argument_list|(
name|tbl_name
argument_list|)
expr_stmt|;
block|}
name|Query
name|queryParams
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|sqlResult
init|=
name|MetastoreDirectSqlUtils
operator|.
name|ensureList
argument_list|(
name|executeWithArray
argument_list|(
name|queryParams
argument_list|,
name|pms
operator|.
name|toArray
argument_list|()
argument_list|,
name|queryText
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sqlResult
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Object
index|[]
name|line
range|:
name|sqlResult
control|)
block|{
name|int
name|enableValidateRely
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlInt
argument_list|(
name|line
index|[
literal|5
index|]
argument_list|)
decl_stmt|;
name|boolean
name|enable
init|=
operator|(
name|enableValidateRely
operator|&
literal|4
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|validate
init|=
operator|(
name|enableValidateRely
operator|&
literal|2
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|rely
init|=
operator|(
name|enableValidateRely
operator|&
literal|1
operator|)
operator|!=
literal|0
decl_stmt|;
name|ret
operator|.
name|add
argument_list|(
operator|new
name|SQLUniqueConstraint
argument_list|(
name|catName
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlInt
argument_list|(
name|line
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|4
index|]
argument_list|)
argument_list|,
name|enable
argument_list|,
name|validate
argument_list|,
name|rely
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
specifier|public
name|List
argument_list|<
name|SQLNotNullConstraint
argument_list|>
name|getNotNullConstraints
parameter_list|(
name|String
name|catName
parameter_list|,
name|String
name|db_name
parameter_list|,
name|String
name|tbl_name
parameter_list|)
throws|throws
name|MetaException
block|{
name|List
argument_list|<
name|SQLNotNullConstraint
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|String
name|queryText
init|=
literal|"SELECT "
operator|+
name|DBS
operator|+
literal|".\"NAME\", "
operator|+
name|TBLS
operator|+
literal|".\"TBL_NAME\","
operator|+
literal|"CASE WHEN "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"COLUMN_NAME\" IS NOT NULL THEN "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"COLUMN_NAME\" "
operator|+
literal|"ELSE "
operator|+
name|PARTITION_KEYS
operator|+
literal|".\"PKEY_NAME\" END, "
operator|+
literal|""
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"CONSTRAINT_NAME\", "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"ENABLE_VALIDATE_RELY\" "
operator|+
literal|" from "
operator|+
name|TBLS
operator|+
literal|" "
operator|+
literal|" INNER JOIN "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"TBL_ID\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_TBL_ID\" "
operator|+
literal|" INNER JOIN "
operator|+
name|DBS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"DB_ID\" = "
operator|+
name|DBS
operator|+
literal|".\"DB_ID\" "
operator|+
literal|" LEFT OUTER JOIN "
operator|+
name|COLUMNS_V2
operator|+
literal|" ON "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"CD_ID\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_CD_ID\" AND "
operator|+
literal|" "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"INTEGER_IDX\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_INTEGER_IDX\" "
operator|+
literal|" LEFT OUTER JOIN "
operator|+
name|PARTITION_KEYS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"TBL_ID\" = "
operator|+
name|PARTITION_KEYS
operator|+
literal|".\"TBL_ID\" AND "
operator|+
literal|" "
operator|+
name|PARTITION_KEYS
operator|+
literal|".\"INTEGER_IDX\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_INTEGER_IDX\" "
operator|+
literal|" WHERE "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"CONSTRAINT_TYPE\" = "
operator|+
name|MConstraint
operator|.
name|NOT_NULL_CONSTRAINT
operator|+
literal|" AND"
operator|+
literal|" "
operator|+
name|DBS
operator|+
literal|".\"CTLG_NAME\" = ? AND"
operator|+
operator|(
name|db_name
operator|==
literal|null
condition|?
literal|""
else|:
literal|" "
operator|+
name|DBS
operator|+
literal|".\"NAME\" = ? AND"
operator|)
operator|+
operator|(
name|tbl_name
operator|==
literal|null
condition|?
literal|""
else|:
literal|" "
operator|+
name|TBLS
operator|+
literal|".\"TBL_NAME\" = ? "
operator|)
decl_stmt|;
name|queryText
operator|=
name|queryText
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|queryText
operator|.
name|endsWith
argument_list|(
literal|"AND"
argument_list|)
condition|)
block|{
name|queryText
operator|=
name|queryText
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|queryText
operator|.
name|length
argument_list|()
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|pms
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|pms
operator|.
name|add
argument_list|(
name|catName
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_name
operator|!=
literal|null
condition|)
block|{
name|pms
operator|.
name|add
argument_list|(
name|db_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tbl_name
operator|!=
literal|null
condition|)
block|{
name|pms
operator|.
name|add
argument_list|(
name|tbl_name
argument_list|)
expr_stmt|;
block|}
name|Query
name|queryParams
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|sqlResult
init|=
name|MetastoreDirectSqlUtils
operator|.
name|ensureList
argument_list|(
name|executeWithArray
argument_list|(
name|queryParams
argument_list|,
name|pms
operator|.
name|toArray
argument_list|()
argument_list|,
name|queryText
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sqlResult
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Object
index|[]
name|line
range|:
name|sqlResult
control|)
block|{
name|int
name|enableValidateRely
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlInt
argument_list|(
name|line
index|[
literal|4
index|]
argument_list|)
decl_stmt|;
name|boolean
name|enable
init|=
operator|(
name|enableValidateRely
operator|&
literal|4
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|validate
init|=
operator|(
name|enableValidateRely
operator|&
literal|2
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|rely
init|=
operator|(
name|enableValidateRely
operator|&
literal|1
operator|)
operator|!=
literal|0
decl_stmt|;
name|ret
operator|.
name|add
argument_list|(
operator|new
name|SQLNotNullConstraint
argument_list|(
name|catName
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|enable
argument_list|,
name|validate
argument_list|,
name|rely
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
specifier|public
name|List
argument_list|<
name|SQLDefaultConstraint
argument_list|>
name|getDefaultConstraints
parameter_list|(
name|String
name|catName
parameter_list|,
name|String
name|db_name
parameter_list|,
name|String
name|tbl_name
parameter_list|)
throws|throws
name|MetaException
block|{
name|List
argument_list|<
name|SQLDefaultConstraint
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<
name|SQLDefaultConstraint
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|queryText
init|=
literal|"SELECT "
operator|+
name|DBS
operator|+
literal|".\"NAME\", "
operator|+
name|TBLS
operator|+
literal|".\"TBL_NAME\","
operator|+
literal|"CASE WHEN "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"COLUMN_NAME\" IS NOT NULL THEN "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"COLUMN_NAME\" "
operator|+
literal|"ELSE "
operator|+
name|PARTITION_KEYS
operator|+
literal|".\"PKEY_NAME\" END, "
operator|+
literal|""
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"CONSTRAINT_NAME\", "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"ENABLE_VALIDATE_RELY\", "
operator|+
literal|""
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"DEFAULT_VALUE\" "
operator|+
literal|" from "
operator|+
name|TBLS
operator|+
literal|" "
operator|+
literal|" INNER JOIN "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"TBL_ID\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_TBL_ID\" "
operator|+
literal|" INNER JOIN "
operator|+
name|DBS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"DB_ID\" = "
operator|+
name|DBS
operator|+
literal|".\"DB_ID\" "
operator|+
literal|" LEFT OUTER JOIN "
operator|+
name|COLUMNS_V2
operator|+
literal|" ON "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"CD_ID\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_CD_ID\" AND "
operator|+
literal|" "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"INTEGER_IDX\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_INTEGER_IDX\" "
operator|+
literal|" LEFT OUTER JOIN "
operator|+
name|PARTITION_KEYS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"TBL_ID\" = "
operator|+
name|PARTITION_KEYS
operator|+
literal|".\"TBL_ID\" AND "
operator|+
literal|" "
operator|+
name|PARTITION_KEYS
operator|+
literal|".\"INTEGER_IDX\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_INTEGER_IDX\" "
operator|+
literal|" WHERE "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"CONSTRAINT_TYPE\" = "
operator|+
name|MConstraint
operator|.
name|DEFAULT_CONSTRAINT
operator|+
literal|" AND"
operator|+
literal|" "
operator|+
name|DBS
operator|+
literal|".\"CTLG_NAME\" = ? AND"
operator|+
operator|(
name|db_name
operator|==
literal|null
condition|?
literal|""
else|:
literal|" "
operator|+
name|DBS
operator|+
literal|".\"NAME\" = ? AND"
operator|)
operator|+
operator|(
name|tbl_name
operator|==
literal|null
condition|?
literal|""
else|:
literal|" "
operator|+
name|TBLS
operator|+
literal|".\"TBL_NAME\" = ? "
operator|)
decl_stmt|;
name|queryText
operator|=
name|queryText
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|queryText
operator|.
name|endsWith
argument_list|(
literal|"AND"
argument_list|)
condition|)
block|{
name|queryText
operator|=
name|queryText
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|queryText
operator|.
name|length
argument_list|()
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"getDefaultConstraints: directsql : "
operator|+
name|queryText
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|pms
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|pms
operator|.
name|add
argument_list|(
name|catName
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_name
operator|!=
literal|null
condition|)
block|{
name|pms
operator|.
name|add
argument_list|(
name|db_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tbl_name
operator|!=
literal|null
condition|)
block|{
name|pms
operator|.
name|add
argument_list|(
name|tbl_name
argument_list|)
expr_stmt|;
block|}
name|Query
name|queryParams
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|sqlResult
init|=
name|MetastoreDirectSqlUtils
operator|.
name|ensureList
argument_list|(
name|executeWithArray
argument_list|(
name|queryParams
argument_list|,
name|pms
operator|.
name|toArray
argument_list|()
argument_list|,
name|queryText
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sqlResult
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Object
index|[]
name|line
range|:
name|sqlResult
control|)
block|{
name|int
name|enableValidateRely
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlInt
argument_list|(
name|line
index|[
literal|4
index|]
argument_list|)
decl_stmt|;
name|boolean
name|enable
init|=
operator|(
name|enableValidateRely
operator|&
literal|4
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|validate
init|=
operator|(
name|enableValidateRely
operator|&
literal|2
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|rely
init|=
operator|(
name|enableValidateRely
operator|&
literal|1
operator|)
operator|!=
literal|0
decl_stmt|;
name|SQLDefaultConstraint
name|currConstraint
init|=
operator|new
name|SQLDefaultConstraint
argument_list|(
name|catName
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|5
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|enable
argument_list|,
name|validate
argument_list|,
name|rely
argument_list|)
decl_stmt|;
name|ret
operator|.
name|add
argument_list|(
name|currConstraint
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
specifier|public
name|List
argument_list|<
name|SQLCheckConstraint
argument_list|>
name|getCheckConstraints
parameter_list|(
name|String
name|catName
parameter_list|,
name|String
name|db_name
parameter_list|,
name|String
name|tbl_name
parameter_list|)
throws|throws
name|MetaException
block|{
name|List
argument_list|<
name|SQLCheckConstraint
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<
name|SQLCheckConstraint
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|queryText
init|=
literal|"SELECT "
operator|+
name|DBS
operator|+
literal|".\"NAME\", "
operator|+
name|TBLS
operator|+
literal|".\"TBL_NAME\","
operator|+
literal|"CASE WHEN "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"COLUMN_NAME\" IS NOT NULL THEN "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"COLUMN_NAME\" "
operator|+
literal|"ELSE "
operator|+
name|PARTITION_KEYS
operator|+
literal|".\"PKEY_NAME\" END, "
operator|+
literal|""
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"CONSTRAINT_NAME\", "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"ENABLE_VALIDATE_RELY\", "
operator|+
literal|""
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"DEFAULT_VALUE\" "
operator|+
literal|" from "
operator|+
name|TBLS
operator|+
literal|" "
operator|+
literal|" INNER JOIN "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"TBL_ID\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_TBL_ID\" "
operator|+
literal|" INNER JOIN "
operator|+
name|DBS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"DB_ID\" = "
operator|+
name|DBS
operator|+
literal|".\"DB_ID\" "
operator|+
literal|" LEFT OUTER JOIN "
operator|+
name|COLUMNS_V2
operator|+
literal|" ON "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"CD_ID\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_CD_ID\" AND "
operator|+
literal|" "
operator|+
name|COLUMNS_V2
operator|+
literal|".\"INTEGER_IDX\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_INTEGER_IDX\" "
operator|+
literal|" LEFT OUTER JOIN "
operator|+
name|PARTITION_KEYS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"TBL_ID\" = "
operator|+
name|PARTITION_KEYS
operator|+
literal|".\"TBL_ID\" AND "
operator|+
literal|" "
operator|+
name|PARTITION_KEYS
operator|+
literal|".\"INTEGER_IDX\" = "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"PARENT_INTEGER_IDX\" "
operator|+
literal|" WHERE "
operator|+
name|KEY_CONSTRAINTS
operator|+
literal|".\"CONSTRAINT_TYPE\" = "
operator|+
name|MConstraint
operator|.
name|CHECK_CONSTRAINT
operator|+
literal|" AND"
operator|+
literal|" "
operator|+
name|DBS
operator|+
literal|".\"CTLG_NAME\" = ? AND"
operator|+
operator|(
name|db_name
operator|==
literal|null
condition|?
literal|""
else|:
literal|" "
operator|+
name|DBS
operator|+
literal|".\"NAME\" = ? AND"
operator|)
operator|+
operator|(
name|tbl_name
operator|==
literal|null
condition|?
literal|""
else|:
literal|" "
operator|+
name|TBLS
operator|+
literal|".\"TBL_NAME\" = ? "
operator|)
decl_stmt|;
name|queryText
operator|=
name|queryText
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|queryText
operator|.
name|endsWith
argument_list|(
literal|"AND"
argument_list|)
condition|)
block|{
name|queryText
operator|=
name|queryText
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|queryText
operator|.
name|length
argument_list|()
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"getCheckConstraints: directsql : "
operator|+
name|queryText
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|pms
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|pms
operator|.
name|add
argument_list|(
name|catName
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_name
operator|!=
literal|null
condition|)
block|{
name|pms
operator|.
name|add
argument_list|(
name|db_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tbl_name
operator|!=
literal|null
condition|)
block|{
name|pms
operator|.
name|add
argument_list|(
name|tbl_name
argument_list|)
expr_stmt|;
block|}
name|Query
name|queryParams
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|sqlResult
init|=
name|MetastoreDirectSqlUtils
operator|.
name|ensureList
argument_list|(
name|executeWithArray
argument_list|(
name|queryParams
argument_list|,
name|pms
operator|.
name|toArray
argument_list|()
argument_list|,
name|queryText
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sqlResult
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Object
index|[]
name|line
range|:
name|sqlResult
control|)
block|{
name|int
name|enableValidateRely
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlInt
argument_list|(
name|line
index|[
literal|4
index|]
argument_list|)
decl_stmt|;
name|boolean
name|enable
init|=
operator|(
name|enableValidateRely
operator|&
literal|4
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|validate
init|=
operator|(
name|enableValidateRely
operator|&
literal|2
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|rely
init|=
operator|(
name|enableValidateRely
operator|&
literal|1
operator|)
operator|!=
literal|0
decl_stmt|;
name|SQLCheckConstraint
name|currConstraint
init|=
operator|new
name|SQLCheckConstraint
argument_list|(
name|catName
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|5
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|enable
argument_list|,
name|validate
argument_list|,
name|rely
argument_list|)
decl_stmt|;
name|ret
operator|.
name|add
argument_list|(
name|currConstraint
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Drop partitions by using direct SQL queries.    * @param catName Metastore catalog name.    * @param dbName Metastore db name.    * @param tblName Metastore table name.    * @param partNames Partition names to get.    * @return List of partitions.    */
specifier|public
name|void
name|dropPartitionsViaSqlFilter
parameter_list|(
specifier|final
name|String
name|catName
parameter_list|,
specifier|final
name|String
name|dbName
parameter_list|,
specifier|final
name|String
name|tblName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|partNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|Batchable
operator|.
name|runBatched
argument_list|(
name|batchSize
argument_list|,
name|partNames
argument_list|,
operator|new
name|Batchable
argument_list|<
name|String
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Void
argument_list|>
name|run
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|input
parameter_list|)
throws|throws
name|MetaException
block|{
name|String
name|filter
init|=
literal|""
operator|+
name|PARTITIONS
operator|+
literal|".\"PART_NAME\" in ("
operator|+
name|makeParams
argument_list|(
name|input
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|")"
decl_stmt|;
comment|// Get partition ids
name|List
argument_list|<
name|Long
argument_list|>
name|partitionIds
init|=
name|getPartitionIdsViaSqlFilter
argument_list|(
name|catName
argument_list|,
name|dbName
argument_list|,
name|tblName
argument_list|,
name|filter
argument_list|,
name|input
argument_list|,
name|Collections
operator|.
expr|<
name|String
operator|>
name|emptyList
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|partitionIds
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
comment|// no partitions, bail early.
block|}
name|dropPartitionsByPartitionIds
argument_list|(
name|partitionIds
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Drops Partition-s. Should be called with the list short enough to not trip up Oracle/etc.    * @param partitionIdList The partition identifiers to drop    * @throws MetaException If there is an SQL exception during the execution it converted to    * MetaException    */
specifier|private
name|void
name|dropPartitionsByPartitionIds
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|partitionIdList
parameter_list|)
throws|throws
name|MetaException
block|{
name|String
name|queryText
decl_stmt|;
if|if
condition|(
name|partitionIdList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|String
name|partitionIds
init|=
name|getIdListForIn
argument_list|(
name|partitionIdList
argument_list|)
decl_stmt|;
comment|// Get the corresponding SD_ID-s, CD_ID-s, SERDE_ID-s
name|queryText
operator|=
literal|"SELECT "
operator|+
name|SDS
operator|+
literal|".\"SD_ID\", "
operator|+
name|SDS
operator|+
literal|".\"CD_ID\", "
operator|+
name|SDS
operator|+
literal|".\"SERDE_ID\" "
operator|+
literal|"from "
operator|+
name|SDS
operator|+
literal|" "
operator|+
literal|"INNER JOIN "
operator|+
name|PARTITIONS
operator|+
literal|" ON "
operator|+
name|PARTITIONS
operator|+
literal|".\"SD_ID\" = "
operator|+
name|SDS
operator|+
literal|".\"SD_ID\" "
operator|+
literal|"WHERE "
operator|+
name|PARTITIONS
operator|+
literal|".\"PART_ID\" in ("
operator|+
name|partitionIds
operator|+
literal|")"
expr_stmt|;
name|Query
name|query
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|sqlResult
init|=
name|MetastoreDirectSqlUtils
operator|.
name|ensureList
argument_list|(
name|executeWithArray
argument_list|(
name|query
argument_list|,
literal|null
argument_list|,
name|queryText
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|sdIdList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|partitionIdList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|columnDescriptorIdList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|serdeIdList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|partitionIdList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sqlResult
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Object
index|[]
name|fields
range|:
name|sqlResult
control|)
block|{
name|sdIdList
operator|.
name|add
argument_list|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlLong
argument_list|(
name|fields
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|Long
name|colId
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlLong
argument_list|(
name|fields
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|columnDescriptorIdList
operator|.
name|contains
argument_list|(
name|colId
argument_list|)
condition|)
block|{
name|columnDescriptorIdList
operator|.
name|add
argument_list|(
name|colId
argument_list|)
expr_stmt|;
block|}
name|serdeIdList
operator|.
name|add
argument_list|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlLong
argument_list|(
name|fields
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Drop privileges
name|queryText
operator|=
literal|"delete from "
operator|+
name|PART_PRIVS
operator|+
literal|" where \"PART_ID\" in ("
operator|+
name|partitionIds
operator|+
literal|")"
expr_stmt|;
name|executeNoResult
argument_list|(
name|queryText
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
comment|// Drop column level privileges
name|queryText
operator|=
literal|"delete from "
operator|+
name|PART_COL_PRIVS
operator|+
literal|" where \"PART_ID\" in ("
operator|+
name|partitionIds
operator|+
literal|")"
expr_stmt|;
name|executeNoResult
argument_list|(
name|queryText
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
comment|// Drop partition statistics
name|queryText
operator|=
literal|"delete from "
operator|+
name|PART_COL_STATS
operator|+
literal|" where \"PART_ID\" in ("
operator|+
name|partitionIds
operator|+
literal|")"
expr_stmt|;
name|executeNoResult
argument_list|(
name|queryText
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
comment|// Drop the partition params
name|queryText
operator|=
literal|"delete from "
operator|+
name|PARTITION_PARAMS
operator|+
literal|" where \"PART_ID\" in ("
operator|+
name|partitionIds
operator|+
literal|")"
expr_stmt|;
name|executeNoResult
argument_list|(
name|queryText
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
comment|// Drop the partition key vals
name|queryText
operator|=
literal|"delete from "
operator|+
name|PARTITION_KEY_VALS
operator|+
literal|" where \"PART_ID\" in ("
operator|+
name|partitionIds
operator|+
literal|")"
expr_stmt|;
name|executeNoResult
argument_list|(
name|queryText
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
comment|// Drop the partitions
name|queryText
operator|=
literal|"delete from "
operator|+
name|PARTITIONS
operator|+
literal|" where \"PART_ID\" in ("
operator|+
name|partitionIds
operator|+
literal|")"
expr_stmt|;
name|executeNoResult
argument_list|(
name|queryText
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|sqlException
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"SQL error executing query while dropping partition"
argument_list|,
name|sqlException
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Encountered error while dropping partitions."
argument_list|)
throw|;
block|}
name|dropStorageDescriptors
argument_list|(
name|sdIdList
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
name|dropSerdes
argument_list|(
name|serdeIdList
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
name|dropDanglingColumnDescriptors
argument_list|(
name|columnDescriptorIdList
argument_list|)
expr_stmt|;
block|}
comment|/**    * Drops SD-s. Should be called with the list short enough to not trip up Oracle/etc.    * @param storageDescriptorIdList The storage descriptor identifiers to drop    * @throws MetaException If there is an SQL exception during the execution it converted to    * MetaException    */
specifier|private
name|void
name|dropStorageDescriptors
parameter_list|(
name|List
argument_list|<
name|Object
argument_list|>
name|storageDescriptorIdList
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|storageDescriptorIdList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|String
name|queryText
decl_stmt|;
name|String
name|sdIds
init|=
name|getIdListForIn
argument_list|(
name|storageDescriptorIdList
argument_list|)
decl_stmt|;
comment|// Get the corresponding SKEWED_STRING_LIST_ID data
name|queryText
operator|=
literal|"select "
operator|+
name|SKEWED_VALUES
operator|+
literal|".\"STRING_LIST_ID_EID\" "
operator|+
literal|"from "
operator|+
name|SKEWED_VALUES
operator|+
literal|" "
operator|+
literal|"WHERE "
operator|+
name|SKEWED_VALUES
operator|+
literal|".\"SD_ID_OID\" in  ("
operator|+
name|sdIds
operator|+
literal|")"
expr_stmt|;
name|Query
name|query
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|sqlResult
init|=
name|MetastoreDirectSqlUtils
operator|.
name|ensureList
argument_list|(
name|executeWithArray
argument_list|(
name|query
argument_list|,
literal|null
argument_list|,
name|queryText
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|skewedStringListIdList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sqlResult
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Object
index|[]
name|fields
range|:
name|sqlResult
control|)
block|{
name|skewedStringListIdList
operator|.
name|add
argument_list|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlLong
argument_list|(
name|fields
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
name|String
name|skewedStringListIds
init|=
name|getIdListForIn
argument_list|(
name|skewedStringListIdList
argument_list|)
decl_stmt|;
try|try
block|{
comment|// Drop the SD params
name|queryText
operator|=
literal|"delete from "
operator|+
name|SD_PARAMS
operator|+
literal|" where \"SD_ID\" in ("
operator|+
name|sdIds
operator|+
literal|")"
expr_stmt|;
name|executeNoResult
argument_list|(
name|queryText
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
comment|// Drop the sort cols
name|queryText
operator|=
literal|"delete from "
operator|+
name|SORT_COLS
operator|+
literal|" where \"SD_ID\" in ("
operator|+
name|sdIds
operator|+
literal|")"
expr_stmt|;
name|executeNoResult
argument_list|(
name|queryText
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
comment|// Drop the bucketing cols
name|queryText
operator|=
literal|"delete from "
operator|+
name|BUCKETING_COLS
operator|+
literal|" where \"SD_ID\" in ("
operator|+
name|sdIds
operator|+
literal|")"
expr_stmt|;
name|executeNoResult
argument_list|(
name|queryText
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
comment|// Drop the skewed string lists
if|if
condition|(
name|skewedStringListIdList
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Drop the skewed string value loc map
name|queryText
operator|=
literal|"delete from "
operator|+
name|SKEWED_COL_VALUE_LOC_MAP
operator|+
literal|" where \"SD_ID\" in ("
operator|+
name|sdIds
operator|+
literal|")"
expr_stmt|;
name|executeNoResult
argument_list|(
name|queryText
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
comment|// Drop the skewed values
name|queryText
operator|=
literal|"delete from "
operator|+
name|SKEWED_VALUES
operator|+
literal|" where \"SD_ID_OID\" in ("
operator|+
name|sdIds
operator|+
literal|")"
expr_stmt|;
name|executeNoResult
argument_list|(
name|queryText
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
comment|// Drop the skewed string list values
name|queryText
operator|=
literal|"delete from "
operator|+
name|SKEWED_STRING_LIST_VALUES
operator|+
literal|" where \"STRING_LIST_ID\" in ("
operator|+
name|skewedStringListIds
operator|+
literal|")"
expr_stmt|;
name|executeNoResult
argument_list|(
name|queryText
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
comment|// Drop the skewed string list
name|queryText
operator|=
literal|"delete from "
operator|+
name|SKEWED_STRING_LIST
operator|+
literal|" where \"STRING_LIST_ID\" in ("
operator|+
name|skewedStringListIds
operator|+
literal|")"
expr_stmt|;
name|executeNoResult
argument_list|(
name|queryText
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
block|}
comment|// Drop the skewed cols
name|queryText
operator|=
literal|"delete from "
operator|+
name|SKEWED_COL_NAMES
operator|+
literal|" where \"SD_ID\" in ("
operator|+
name|sdIds
operator|+
literal|")"
expr_stmt|;
name|executeNoResult
argument_list|(
name|queryText
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
comment|// Drop the sds
name|queryText
operator|=
literal|"delete from "
operator|+
name|SDS
operator|+
literal|" where \"SD_ID\" in ("
operator|+
name|sdIds
operator|+
literal|")"
expr_stmt|;
name|executeNoResult
argument_list|(
name|queryText
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|sqlException
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"SQL error executing query while dropping storage descriptor."
argument_list|,
name|sqlException
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Encountered error while dropping storage descriptor."
argument_list|)
throw|;
block|}
block|}
comment|/**    * Drops Serde-s. Should be called with the list short enough to not trip up Oracle/etc.    * @param serdeIdList The serde identifiers to drop    * @throws MetaException If there is an SQL exception during the execution it converted to    * MetaException    */
specifier|private
name|void
name|dropSerdes
parameter_list|(
name|List
argument_list|<
name|Object
argument_list|>
name|serdeIdList
parameter_list|)
throws|throws
name|MetaException
block|{
name|String
name|queryText
decl_stmt|;
if|if
condition|(
name|serdeIdList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|String
name|serdeIds
init|=
name|getIdListForIn
argument_list|(
name|serdeIdList
argument_list|)
decl_stmt|;
try|try
block|{
comment|// Drop the serde params
name|queryText
operator|=
literal|"delete from "
operator|+
name|SERDE_PARAMS
operator|+
literal|" where \"SERDE_ID\" in ("
operator|+
name|serdeIds
operator|+
literal|")"
expr_stmt|;
name|executeNoResult
argument_list|(
name|queryText
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
comment|// Drop the serdes
name|queryText
operator|=
literal|"delete from "
operator|+
name|SERDES
operator|+
literal|" where \"SERDE_ID\" in ("
operator|+
name|serdeIds
operator|+
literal|")"
expr_stmt|;
name|executeNoResult
argument_list|(
name|queryText
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|sqlException
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"SQL error executing query while dropping serde."
argument_list|,
name|sqlException
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Encountered error while dropping serde."
argument_list|)
throw|;
block|}
block|}
comment|/**    * Checks if the column descriptors still has references for other SD-s. If not, then removes    * them. Should be called with the list short enough to not trip up Oracle/etc.    * @param columnDescriptorIdList The column identifiers    * @throws MetaException If there is an SQL exception during the execution it converted to    * MetaException    */
specifier|private
name|void
name|dropDanglingColumnDescriptors
parameter_list|(
name|List
argument_list|<
name|Object
argument_list|>
name|columnDescriptorIdList
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|columnDescriptorIdList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|String
name|queryText
decl_stmt|;
name|String
name|colIds
init|=
name|getIdListForIn
argument_list|(
name|columnDescriptorIdList
argument_list|)
decl_stmt|;
comment|// Drop column descriptor, if no relation left
name|queryText
operator|=
literal|"SELECT "
operator|+
name|SDS
operator|+
literal|".\"CD_ID\", count(1) "
operator|+
literal|"from "
operator|+
name|SDS
operator|+
literal|" "
operator|+
literal|"WHERE "
operator|+
name|SDS
operator|+
literal|".\"CD_ID\" in ("
operator|+
name|colIds
operator|+
literal|") "
operator|+
literal|"GROUP BY "
operator|+
name|SDS
operator|+
literal|".\"CD_ID\""
expr_stmt|;
name|Query
name|query
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|sqlResult
init|=
name|MetastoreDirectSqlUtils
operator|.
name|ensureList
argument_list|(
name|executeWithArray
argument_list|(
name|query
argument_list|,
literal|null
argument_list|,
name|queryText
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|danglingColumnDescriptorIdList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|columnDescriptorIdList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sqlResult
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Object
index|[]
name|fields
range|:
name|sqlResult
control|)
block|{
if|if
condition|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlInt
argument_list|(
name|fields
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|danglingColumnDescriptorIdList
operator|.
name|add
argument_list|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlLong
argument_list|(
name|fields
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|danglingColumnDescriptorIdList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|String
name|danglingCDIds
init|=
name|getIdListForIn
argument_list|(
name|danglingColumnDescriptorIdList
argument_list|)
decl_stmt|;
comment|// Drop the columns_v2
name|queryText
operator|=
literal|"delete from "
operator|+
name|COLUMNS_V2
operator|+
literal|" where \"CD_ID\" in ("
operator|+
name|danglingCDIds
operator|+
literal|")"
expr_stmt|;
name|executeNoResult
argument_list|(
name|queryText
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
comment|// Drop the cols
name|queryText
operator|=
literal|"delete from "
operator|+
name|CDS
operator|+
literal|" where \"CD_ID\" in ("
operator|+
name|danglingCDIds
operator|+
literal|")"
expr_stmt|;
name|executeNoResult
argument_list|(
name|queryText
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|sqlException
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"SQL error executing query while dropping dangling col descriptions"
argument_list|,
name|sqlException
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Encountered error while dropping col descriptions"
argument_list|)
throw|;
block|}
block|}
block|}
specifier|public
specifier|final
specifier|static
name|Object
index|[]
name|STATS_TABLE_TYPES
init|=
operator|new
name|Object
index|[]
block|{
name|TableType
operator|.
name|MANAGED_TABLE
operator|.
name|toString
argument_list|()
block|,
name|TableType
operator|.
name|MATERIALIZED_VIEW
operator|.
name|toString
argument_list|()
block|}
decl_stmt|;
specifier|public
name|List
argument_list|<
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|TableName
argument_list|>
name|getTableNamesWithStats
parameter_list|()
throws|throws
name|MetaException
block|{
comment|// Could we also join with ACID tables to only get tables with outdated stats?
name|String
name|queryText0
init|=
literal|"SELECT DISTINCT "
operator|+
name|TBLS
operator|+
literal|".\"TBL_NAME\", "
operator|+
name|DBS
operator|+
literal|".\"NAME\", "
operator|+
name|DBS
operator|+
literal|".\"CTLG_NAME\" FROM "
operator|+
name|TBLS
operator|+
literal|" INNER JOIN "
operator|+
name|DBS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"DB_ID\" = "
operator|+
name|DBS
operator|+
literal|".\"DB_ID\""
decl_stmt|;
name|String
name|queryText1
init|=
literal|" WHERE "
operator|+
name|TBLS
operator|+
literal|".\"TBL_TYPE\" IN ("
operator|+
name|makeParams
argument_list|(
name|STATS_TABLE_TYPES
operator|.
name|length
argument_list|)
operator|+
literal|")"
decl_stmt|;
name|List
argument_list|<
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|TableName
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|String
name|queryText
init|=
name|queryText0
operator|+
literal|" INNER JOIN "
operator|+
name|TAB_COL_STATS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"TBL_ID\" = "
operator|+
name|TAB_COL_STATS
operator|+
literal|".\"TBL_ID\""
operator|+
name|queryText1
decl_stmt|;
name|getStatsTableListResult
argument_list|(
name|queryText
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|queryText
operator|=
name|queryText0
operator|+
literal|" INNER JOIN "
operator|+
name|PARTITIONS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"TBL_ID\" = "
operator|+
name|PARTITIONS
operator|+
literal|".\"TBL_ID\""
operator|+
literal|" INNER JOIN "
operator|+
name|PART_COL_STATS
operator|+
literal|" ON "
operator|+
name|PARTITIONS
operator|+
literal|".\"PART_ID\" = "
operator|+
name|PART_COL_STATS
operator|+
literal|".\"PART_ID\""
operator|+
name|queryText1
expr_stmt|;
name|getStatsTableListResult
argument_list|(
name|queryText
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|getColAndPartNamesWithStats
parameter_list|(
name|String
name|catName
parameter_list|,
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|)
throws|throws
name|MetaException
block|{
comment|// Could we also join with ACID tables to only get tables with outdated stats?
name|String
name|queryText
init|=
literal|"SELECT DISTINCT "
operator|+
name|PARTITIONS
operator|+
literal|".\"PART_NAME\", "
operator|+
name|PART_COL_STATS
operator|+
literal|".\"COLUMN_NAME\" FROM "
operator|+
name|TBLS
operator|+
literal|" INNER JOIN "
operator|+
name|DBS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"DB_ID\" = "
operator|+
name|DBS
operator|+
literal|".\"DB_ID\" INNER JOIN "
operator|+
name|PARTITIONS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"TBL_ID\" = "
operator|+
name|PARTITIONS
operator|+
literal|".\"TBL_ID\"  INNER JOIN "
operator|+
name|PART_COL_STATS
operator|+
literal|" ON "
operator|+
name|PARTITIONS
operator|+
literal|".\"PART_ID\" = "
operator|+
name|PART_COL_STATS
operator|+
literal|".\"PART_ID\" WHERE "
operator|+
name|DBS
operator|+
literal|".\"NAME\" = ? AND "
operator|+
name|DBS
operator|+
literal|".\"CTLG_NAME\" = ? AND "
operator|+
name|TBLS
operator|+
literal|".\"TBL_NAME\" = ? ORDER BY "
operator|+
name|PARTITIONS
operator|+
literal|".\"PART_NAME\""
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Running {}"
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
name|Query
argument_list|<
name|?
argument_list|>
name|query
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
try|try
block|{
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|sqlResult
init|=
name|MetastoreDirectSqlUtils
operator|.
name|ensureList
argument_list|(
name|executeWithArray
argument_list|(
name|query
argument_list|,
operator|new
name|Object
index|[]
block|{
name|dbName
block|,
name|catName
block|,
name|tableName
block|}
argument_list|,
name|queryText
argument_list|)
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|String
name|lastPartName
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|cols
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Object
index|[]
name|line
range|:
name|sqlResult
control|)
block|{
name|String
name|col
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|String
name|part
init|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|part
operator|.
name|equals
argument_list|(
name|lastPartName
argument_list|)
condition|)
block|{
if|if
condition|(
name|lastPartName
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|put
argument_list|(
name|lastPartName
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
name|cols
operator|=
name|cols
operator|==
literal|null
condition|?
operator|new
name|ArrayList
argument_list|<>
argument_list|()
else|:
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|cols
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|lastPartName
operator|=
name|part
expr_stmt|;
block|}
name|cols
operator|.
name|add
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lastPartName
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|put
argument_list|(
name|lastPartName
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
finally|finally
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|List
argument_list|<
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|TableName
argument_list|>
name|getAllTableNamesForStats
parameter_list|()
throws|throws
name|MetaException
block|{
name|String
name|queryText
init|=
literal|"SELECT "
operator|+
name|TBLS
operator|+
literal|".\"TBL_NAME\", "
operator|+
name|DBS
operator|+
literal|".\"NAME\", "
operator|+
name|DBS
operator|+
literal|".\"CTLG_NAME\" FROM "
operator|+
name|TBLS
operator|+
literal|" INNER JOIN "
operator|+
name|DBS
operator|+
literal|" ON "
operator|+
name|TBLS
operator|+
literal|".\"DB_ID\" = "
operator|+
name|DBS
operator|+
literal|".\"DB_ID\""
operator|+
literal|" WHERE "
operator|+
name|TBLS
operator|+
literal|".\"TBL_TYPE\" IN ("
operator|+
name|makeParams
argument_list|(
name|STATS_TABLE_TYPES
operator|.
name|length
argument_list|)
operator|+
literal|")"
decl_stmt|;
name|List
argument_list|<
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|TableName
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|getStatsTableListResult
argument_list|(
name|queryText
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
name|void
name|getStatsTableListResult
parameter_list|(
name|String
name|queryText
parameter_list|,
name|List
argument_list|<
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|TableName
argument_list|>
name|result
parameter_list|)
throws|throws
name|MetaException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Running {}"
argument_list|,
name|queryText
argument_list|)
expr_stmt|;
name|Query
argument_list|<
name|?
argument_list|>
name|query
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
try|try
block|{
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|sqlResult
init|=
name|MetastoreDirectSqlUtils
operator|.
name|ensureList
argument_list|(
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|STATS_TABLE_TYPES
argument_list|,
name|queryText
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|Object
index|[]
name|line
range|:
name|sqlResult
control|)
block|{
name|result
operator|.
name|add
argument_list|(
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|TableName
argument_list|(
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlString
argument_list|(
name|line
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|lockDbTable
parameter_list|(
name|String
name|tableName
parameter_list|)
throws|throws
name|MetaException
block|{
name|String
name|lockCommand
init|=
literal|"lock table \""
operator|+
name|tableName
operator|+
literal|"\" in exclusive mode"
decl_stmt|;
try|try
block|{
name|executeNoResult
argument_list|(
name|lockCommand
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|sqle
parameter_list|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Error while locking table "
operator|+
name|tableName
operator|+
literal|": "
operator|+
name|sqle
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

