begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|tools
operator|.
name|schematool
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|DatabaseMetaData
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|PreparedStatement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLFeatureNotSupportedException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|ArrayUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|tuple
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|HiveMetaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|TableType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|tools
operator|.
name|schematool
operator|.
name|HiveSchemaHelper
operator|.
name|MetaStoreConnectionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|tools
operator|.
name|schematool
operator|.
name|HiveSchemaHelper
operator|.
name|NestedScriptParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_comment
comment|/**  * Print Hive version and schema version.  */
end_comment

begin_class
class|class
name|SchemaToolTaskValidate
extends|extends
name|SchemaToolTask
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SchemaToolTaskValidate
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
annotation|@
name|Override
name|void
name|setCommandLineArguments
parameter_list|(
name|SchemaToolCommandLine
name|cl
parameter_list|)
block|{
comment|// do nothing
block|}
annotation|@
name|Override
name|void
name|execute
parameter_list|()
throws|throws
name|HiveMetaException
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Starting metastore validation\n"
argument_list|)
expr_stmt|;
name|Connection
name|conn
init|=
name|schemaTool
operator|.
name|getConnectionToMetastore
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|true
decl_stmt|;
try|try
block|{
name|success
operator|&=
name|validateSchemaVersions
argument_list|()
expr_stmt|;
name|success
operator|&=
name|validateSequences
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|success
operator|&=
name|validateSchemaTables
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|success
operator|&=
name|validateLocations
argument_list|(
name|conn
argument_list|,
name|schemaTool
operator|.
name|getValidationServers
argument_list|()
argument_list|)
expr_stmt|;
name|success
operator|&=
name|validateColumnNullValues
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|conn
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|conn
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveMetaException
argument_list|(
literal|"Failed to close metastore connection"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"Done with metastore validation: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"[FAIL]"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|HiveMetaException
argument_list|(
literal|"Validation failed"
argument_list|)
throw|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"[SUCCESS]"
argument_list|)
expr_stmt|;
block|}
block|}
name|boolean
name|validateSchemaVersions
parameter_list|()
throws|throws
name|HiveMetaException
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Validating schema version"
argument_list|)
expr_stmt|;
try|try
block|{
name|String
name|hiveSchemaVersion
init|=
name|schemaTool
operator|.
name|getMetaStoreSchemaInfo
argument_list|()
operator|.
name|getHiveSchemaVersion
argument_list|()
decl_stmt|;
name|MetaStoreConnectionInfo
name|connectionInfo
init|=
name|schemaTool
operator|.
name|getConnectionInfo
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|String
name|newSchemaVersion
init|=
name|schemaTool
operator|.
name|getMetaStoreSchemaInfo
argument_list|()
operator|.
name|getMetaStoreSchemaVersion
argument_list|(
name|connectionInfo
argument_list|)
decl_stmt|;
name|schemaTool
operator|.
name|assertCompatibleVersion
argument_list|(
name|hiveSchemaVersion
argument_list|,
name|newSchemaVersion
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveMetaException
name|hme
parameter_list|)
block|{
if|if
condition|(
name|hme
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"Metastore schema version is not compatible"
argument_list|)
operator|||
name|hme
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"Multiple versions were found in metastore"
argument_list|)
operator|||
name|hme
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"Could not find version info in metastore VERSION table"
argument_list|)
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|hme
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"[FAIL]\n"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
throw|throw
name|hme
throw|;
block|}
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"[SUCCESS]\n"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
specifier|static
specifier|final
name|String
name|QUERY_SEQ
init|=
literal|"  select t.<q>NEXT_VAL<q>"
operator|+
literal|"    from<q>SEQUENCE_TABLE<q> t "
operator|+
literal|"   where t.<q>SEQUENCE_NAME<q> = ? "
operator|+
literal|"order by t.<q>SEQUENCE_NAME<q>"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|QUERY_MAX_ID
init|=
literal|"select max(<q>%s<q>)"
operator|+
literal|"  from<q>%s<q>"
decl_stmt|;
annotation|@
name|VisibleForTesting
name|boolean
name|validateSequences
parameter_list|(
name|Connection
name|conn
parameter_list|)
throws|throws
name|HiveMetaException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Pair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|seqNameToTable
init|=
operator|new
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Pair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
operator|.
name|put
argument_list|(
literal|"MDatabase"
argument_list|,
name|Pair
operator|.
name|of
argument_list|(
literal|"DBS"
argument_list|,
literal|"DB_ID"
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
literal|"MRole"
argument_list|,
name|Pair
operator|.
name|of
argument_list|(
literal|"ROLES"
argument_list|,
literal|"ROLE_ID"
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
literal|"MGlobalPrivilege"
argument_list|,
name|Pair
operator|.
name|of
argument_list|(
literal|"GLOBAL_PRIVS"
argument_list|,
literal|"USER_GRANT_ID"
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
literal|"MTable"
argument_list|,
name|Pair
operator|.
name|of
argument_list|(
literal|"TBLS"
argument_list|,
literal|"TBL_ID"
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
literal|"MStorageDescriptor"
argument_list|,
name|Pair
operator|.
name|of
argument_list|(
literal|"SDS"
argument_list|,
literal|"SD_ID"
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
literal|"MSerDeInfo"
argument_list|,
name|Pair
operator|.
name|of
argument_list|(
literal|"SERDES"
argument_list|,
literal|"SERDE_ID"
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
literal|"MColumnDescriptor"
argument_list|,
name|Pair
operator|.
name|of
argument_list|(
literal|"CDS"
argument_list|,
literal|"CD_ID"
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
literal|"MTablePrivilege"
argument_list|,
name|Pair
operator|.
name|of
argument_list|(
literal|"TBL_PRIVS"
argument_list|,
literal|"TBL_GRANT_ID"
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
literal|"MTableColumnStatistics"
argument_list|,
name|Pair
operator|.
name|of
argument_list|(
literal|"TAB_COL_STATS"
argument_list|,
literal|"CS_ID"
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
literal|"MPartition"
argument_list|,
name|Pair
operator|.
name|of
argument_list|(
literal|"PARTITIONS"
argument_list|,
literal|"PART_ID"
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
literal|"MPartitionColumnStatistics"
argument_list|,
name|Pair
operator|.
name|of
argument_list|(
literal|"PART_COL_STATS"
argument_list|,
literal|"CS_ID"
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
literal|"MFunction"
argument_list|,
name|Pair
operator|.
name|of
argument_list|(
literal|"FUNCS"
argument_list|,
literal|"FUNC_ID"
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
literal|"MIndex"
argument_list|,
name|Pair
operator|.
name|of
argument_list|(
literal|"IDXS"
argument_list|,
literal|"INDEX_ID"
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
literal|"MStringList"
argument_list|,
name|Pair
operator|.
name|of
argument_list|(
literal|"SKEWED_STRING_LIST"
argument_list|,
literal|"STRING_LIST_ID"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Validating sequence number for SEQUENCE_TABLE"
argument_list|)
expr_stmt|;
name|boolean
name|isValid
init|=
literal|true
decl_stmt|;
try|try
block|{
name|Statement
name|stmt
init|=
name|conn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Pair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|e
range|:
name|seqNameToTable
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|tableName
init|=
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getLeft
argument_list|()
decl_stmt|;
name|String
name|tableKey
init|=
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getRight
argument_list|()
decl_stmt|;
name|String
name|fullSequenceName
init|=
literal|"org.apache.hadoop.hive.metastore.model."
operator|+
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|seqQuery
init|=
name|schemaTool
operator|.
name|quote
argument_list|(
name|QUERY_SEQ
argument_list|)
decl_stmt|;
name|String
name|maxIdQuery
init|=
name|String
operator|.
name|format
argument_list|(
name|schemaTool
operator|.
name|quote
argument_list|(
name|QUERY_MAX_ID
argument_list|)
argument_list|,
name|tableKey
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
name|ResultSet
name|res
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|maxIdQuery
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|.
name|next
argument_list|()
condition|)
block|{
name|long
name|maxId
init|=
name|res
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxId
operator|>
literal|0
condition|)
block|{
name|PreparedStatement
name|stmtSeq
init|=
name|conn
operator|.
name|prepareStatement
argument_list|(
name|seqQuery
argument_list|)
decl_stmt|;
name|stmtSeq
operator|.
name|setString
argument_list|(
literal|1
argument_list|,
name|fullSequenceName
argument_list|)
expr_stmt|;
name|ResultSet
name|resSeq
init|=
name|stmtSeq
operator|.
name|executeQuery
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|resSeq
operator|.
name|next
argument_list|()
condition|)
block|{
name|isValid
operator|=
literal|false
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Missing SEQUENCE_NAME "
operator|+
name|e
operator|.
name|getKey
argument_list|()
operator|+
literal|" from SEQUENCE_TABLE"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resSeq
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
operator|<
name|maxId
condition|)
block|{
name|isValid
operator|=
literal|false
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"NEXT_VAL for "
operator|+
name|e
operator|.
name|getKey
argument_list|()
operator|+
literal|" in SEQUENCE_TABLE< max("
operator|+
name|tableKey
operator|+
literal|") in "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|isValid
condition|?
literal|"[SUCCESS]\n"
else|:
literal|"[FAIL]\n"
argument_list|)
expr_stmt|;
return|return
name|isValid
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveMetaException
argument_list|(
literal|"Failed to validate sequence number for SEQUENCE_TABLE"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|VisibleForTesting
name|boolean
name|validateSchemaTables
parameter_list|(
name|Connection
name|conn
parameter_list|)
throws|throws
name|HiveMetaException
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Validating metastore schema tables"
argument_list|)
expr_stmt|;
name|String
name|version
init|=
literal|null
decl_stmt|;
try|try
block|{
name|MetaStoreConnectionInfo
name|connectionInfo
init|=
name|schemaTool
operator|.
name|getConnectionInfo
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|version
operator|=
name|schemaTool
operator|.
name|getMetaStoreSchemaInfo
argument_list|()
operator|.
name|getMetaStoreSchemaVersion
argument_list|(
name|connectionInfo
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveMetaException
name|he
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Failed to determine schema version from Hive Metastore DB. "
operator|+
name|he
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Failed in schema table validation."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to determine schema version from Hive Metastore DB,"
operator|+
name|he
operator|.
name|getMessage
argument_list|()
argument_list|,
name|he
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|Connection
name|hmsConn
init|=
name|schemaTool
operator|.
name|getConnectionToMetastore
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Validating tables in the schema for version "
operator|+
name|version
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|dbTables
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|String
name|schema
init|=
literal|null
decl_stmt|;
try|try
block|{
name|schema
operator|=
name|hmsConn
operator|.
name|getSchema
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLFeatureNotSupportedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"schema is not supported"
argument_list|)
expr_stmt|;
block|}
name|DatabaseMetaData
name|metadata
init|=
name|conn
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|rs
operator|=
name|metadata
operator|.
name|getTables
argument_list|(
literal|null
argument_list|,
name|schema
argument_list|,
literal|"%"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"TABLE"
block|}
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|String
name|table
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"TABLE_NAME"
argument_list|)
decl_stmt|;
name|dbTables
operator|.
name|add
argument_list|(
name|table
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found table "
operator|+
name|table
operator|+
literal|" in HMS dbstore"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveMetaException
argument_list|(
literal|"Failed to retrieve schema tables from Hive Metastore DB,"
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|rs
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|rs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveMetaException
argument_list|(
literal|"Failed to close resultset"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|// parse the schema file to determine the tables that are expected to exist
comment|// we are using oracle schema because it is simpler to parse, no quotes or backticks etc
name|List
argument_list|<
name|String
argument_list|>
name|schemaTables
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|subScripts
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|String
name|baseDir
init|=
operator|new
name|File
argument_list|(
name|schemaTool
operator|.
name|getMetaStoreSchemaInfo
argument_list|()
operator|.
name|getMetaStoreScriptDir
argument_list|()
argument_list|)
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|String
name|schemaFile
init|=
operator|new
name|File
argument_list|(
name|schemaTool
operator|.
name|getMetaStoreSchemaInfo
argument_list|()
operator|.
name|getMetaStoreScriptDir
argument_list|()
argument_list|,
name|schemaTool
operator|.
name|getMetaStoreSchemaInfo
argument_list|()
operator|.
name|generateInitFileName
argument_list|(
name|version
argument_list|)
argument_list|)
operator|.
name|getPath
argument_list|()
decl_stmt|;
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Parsing schema script "
operator|+
name|schemaFile
argument_list|)
expr_stmt|;
name|subScripts
operator|.
name|addAll
argument_list|(
name|findCreateTable
argument_list|(
name|schemaFile
argument_list|,
name|schemaTables
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|subScripts
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|schemaFile
operator|=
name|baseDir
operator|+
literal|"/"
operator|+
name|schemaTool
operator|.
name|getDbType
argument_list|()
operator|+
literal|"/"
operator|+
name|subScripts
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Parsing subscript "
operator|+
name|schemaFile
argument_list|)
expr_stmt|;
name|subScripts
operator|.
name|addAll
argument_list|(
name|findCreateTable
argument_list|(
name|schemaFile
argument_list|,
name|schemaTables
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Exception in parsing schema file. Cause:"
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Failed in schema table validation."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Schema tables:[ "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|schemaTables
operator|.
name|toArray
argument_list|()
argument_list|)
operator|+
literal|" ]"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"DB tables:[ "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|dbTables
operator|.
name|toArray
argument_list|()
argument_list|)
operator|+
literal|" ]"
argument_list|)
expr_stmt|;
comment|// now diff the lists
name|schemaTables
operator|.
name|removeAll
argument_list|(
name|dbTables
argument_list|)
expr_stmt|;
if|if
condition|(
name|schemaTables
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|schemaTables
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Table(s) [ "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|schemaTables
operator|.
name|toArray
argument_list|()
argument_list|)
operator|+
literal|" ] "
operator|+
literal|"are missing from the metastore database schema."
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"[FAIL]\n"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"[SUCCESS]\n"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
annotation|@
name|VisibleForTesting
name|List
argument_list|<
name|String
argument_list|>
name|findCreateTable
parameter_list|(
name|String
name|path
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|tableList
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
operator|(
operator|new
name|File
argument_list|(
name|path
argument_list|)
operator|)
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
name|path
operator|+
literal|" does not exist. Potentially incorrect version in the metastore VERSION table"
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|subs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|NestedScriptParser
name|sp
init|=
name|HiveSchemaHelper
operator|.
name|getDbCommandParser
argument_list|(
name|schemaTool
operator|.
name|getDbType
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|Pattern
name|regexp
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"CREATE TABLE(\\s+IF NOT EXISTS)?\\s+(\\S+).*"
argument_list|)
decl_stmt|;
try|try
init|(
name|BufferedReader
name|reader
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|FileReader
argument_list|(
name|path
argument_list|)
argument_list|)
init|)
block|{
name|String
name|line
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|reader
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|sp
operator|.
name|isNestedScript
argument_list|(
name|line
argument_list|)
condition|)
block|{
name|String
name|subScript
init|=
name|sp
operator|.
name|getScriptName
argument_list|(
name|line
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Schema subscript "
operator|+
name|subScript
operator|+
literal|" found"
argument_list|)
expr_stmt|;
name|subs
operator|.
name|add
argument_list|(
name|subScript
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|line
operator|=
name|line
operator|.
name|replaceAll
argument_list|(
literal|"( )+"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
comment|//suppress multi-spaces
name|line
operator|=
name|line
operator|.
name|replaceAll
argument_list|(
literal|"\\("
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|line
operator|=
name|line
operator|.
name|replaceAll
argument_list|(
literal|"IF NOT EXISTS "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|line
operator|=
name|line
operator|.
name|replaceAll
argument_list|(
literal|"`"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|line
operator|=
name|line
operator|.
name|replaceAll
argument_list|(
literal|"'"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|line
operator|=
name|line
operator|.
name|replaceAll
argument_list|(
literal|"\""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|Matcher
name|matcher
init|=
name|regexp
operator|.
name|matcher
argument_list|(
name|line
argument_list|)
decl_stmt|;
if|if
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|table
init|=
name|matcher
operator|.
name|group
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|schemaTool
operator|.
name|getDbType
argument_list|()
operator|.
name|equals
argument_list|(
literal|"derby"
argument_list|)
condition|)
block|{
name|table
operator|=
name|table
operator|.
name|replaceAll
argument_list|(
literal|"APP\\."
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|tableList
operator|.
name|add
argument_list|(
name|table
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found table "
operator|+
name|table
operator|+
literal|" in the schema"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|subs
return|;
block|}
annotation|@
name|VisibleForTesting
name|boolean
name|validateLocations
parameter_list|(
name|Connection
name|conn
parameter_list|,
name|URI
index|[]
name|defaultServers
parameter_list|)
throws|throws
name|HiveMetaException
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Validating DFS locations"
argument_list|)
expr_stmt|;
name|boolean
name|rtn
init|=
literal|true
decl_stmt|;
name|rtn
operator|&=
name|checkMetaStoreDBLocation
argument_list|(
name|conn
argument_list|,
name|defaultServers
argument_list|)
expr_stmt|;
name|rtn
operator|&=
name|checkMetaStoreTableLocation
argument_list|(
name|conn
argument_list|,
name|defaultServers
argument_list|)
expr_stmt|;
name|rtn
operator|&=
name|checkMetaStorePartitionLocation
argument_list|(
name|conn
argument_list|,
name|defaultServers
argument_list|)
expr_stmt|;
name|rtn
operator|&=
name|checkMetaStoreSkewedColumnsLocation
argument_list|(
name|conn
argument_list|,
name|defaultServers
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|rtn
condition|?
literal|"[SUCCESS]\n"
else|:
literal|"[FAIL]\n"
argument_list|)
expr_stmt|;
return|return
name|rtn
return|;
block|}
specifier|private
specifier|static
specifier|final
name|String
name|QUERY_DB_LOCATION
init|=
literal|"  select dbt.<q>DB_ID<q>, "
operator|+
literal|"         dbt.<q>NAME<q>, "
operator|+
literal|"         dbt.<q>DB_LOCATION_URI<q> "
operator|+
literal|"    from<q>DBS<q> dbt "
operator|+
literal|"order by dbt.<q>DB_ID<q> "
decl_stmt|;
specifier|private
name|boolean
name|checkMetaStoreDBLocation
parameter_list|(
name|Connection
name|conn
parameter_list|,
name|URI
index|[]
name|defaultServers
parameter_list|)
throws|throws
name|HiveMetaException
block|{
name|String
name|dbLocQuery
init|=
name|schemaTool
operator|.
name|quote
argument_list|(
name|QUERY_DB_LOCATION
argument_list|)
decl_stmt|;
name|int
name|numOfInvalid
init|=
literal|0
decl_stmt|;
try|try
init|(
name|Statement
name|stmt
init|=
name|conn
operator|.
name|createStatement
argument_list|()
init|;
name|ResultSet
name|res
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|dbLocQuery
argument_list|)
init|)
block|{
while|while
condition|(
name|res
operator|.
name|next
argument_list|()
condition|)
block|{
name|String
name|locValue
init|=
name|res
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|String
name|dbName
init|=
name|getNameOrID
argument_list|(
name|res
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|checkLocation
argument_list|(
literal|"Database "
operator|+
name|dbName
argument_list|,
name|locValue
argument_list|,
name|defaultServers
argument_list|)
condition|)
block|{
name|numOfInvalid
operator|++
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveMetaException
argument_list|(
literal|"Failed to get DB Location Info."
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|numOfInvalid
operator|==
literal|0
return|;
block|}
specifier|private
specifier|static
specifier|final
name|String
name|TAB_ID_RANGE_QUERY
init|=
literal|"select max(<q>TBL_ID<q>), "
operator|+
literal|"       min(<q>TBL_ID<q>) "
operator|+
literal|"  from<q>TBLS<q> "
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|TAB_LOC_QUERY
init|=
literal|"    select tbl.<q>TBL_ID<q>, "
operator|+
literal|"           tbl.<q>TBL_NAME<q>, "
operator|+
literal|"           sd.<q>LOCATION<q>, "
operator|+
literal|"           dbt.<q>DB_ID<q>, "
operator|+
literal|"           dbt.<q>NAME<q> "
operator|+
literal|"      from<q>TBLS<q> tbl "
operator|+
literal|"inner join<q>SDS<q> sd on sd.<q>SD_ID<q> = tbl.<q>SD_ID<q> "
operator|+
literal|"inner join<q>DBS<q> dbt on tbl.<q>DB_ID<q> = dbt.<q>DB_ID<q> "
operator|+
literal|"     where tbl.<q>TBL_TYPE<q> != '%s' "
operator|+
literal|"       and tbl.<q>TBL_ID<q>>= ? "
operator|+
literal|"       and tbl.<q>TBL_ID<q><= ? "
operator|+
literal|"  order by tbl.<q>TBL_ID<q> "
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|TAB_LOC_CHECK_SIZE
init|=
literal|2000
decl_stmt|;
specifier|private
name|boolean
name|checkMetaStoreTableLocation
parameter_list|(
name|Connection
name|conn
parameter_list|,
name|URI
index|[]
name|defaultServers
parameter_list|)
throws|throws
name|HiveMetaException
block|{
name|String
name|tabIDRangeQuery
init|=
name|schemaTool
operator|.
name|quote
argument_list|(
name|TAB_ID_RANGE_QUERY
argument_list|)
decl_stmt|;
name|String
name|tabLocQuery
init|=
name|String
operator|.
name|format
argument_list|(
name|schemaTool
operator|.
name|quote
argument_list|(
name|TAB_LOC_QUERY
argument_list|)
argument_list|,
name|TableType
operator|.
name|VIRTUAL_VIEW
argument_list|)
decl_stmt|;
try|try
block|{
name|long
name|maxID
init|=
literal|0
decl_stmt|,
name|minID
init|=
literal|0
decl_stmt|;
try|try
init|(
name|Statement
name|stmt
init|=
name|conn
operator|.
name|createStatement
argument_list|()
init|;
name|ResultSet
name|res
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|tabIDRangeQuery
argument_list|)
init|)
block|{
if|if
condition|(
name|res
operator|.
name|next
argument_list|()
condition|)
block|{
name|maxID
operator|=
name|res
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|minID
operator|=
name|res
operator|.
name|getLong
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|numOfInvalid
init|=
literal|0
decl_stmt|;
try|try
init|(
name|PreparedStatement
name|pStmt
init|=
name|conn
operator|.
name|prepareStatement
argument_list|(
name|tabLocQuery
argument_list|)
init|)
block|{
while|while
condition|(
name|minID
operator|<=
name|maxID
condition|)
block|{
name|pStmt
operator|.
name|setLong
argument_list|(
literal|1
argument_list|,
name|minID
argument_list|)
expr_stmt|;
name|pStmt
operator|.
name|setLong
argument_list|(
literal|2
argument_list|,
name|minID
operator|+
name|TAB_LOC_CHECK_SIZE
argument_list|)
expr_stmt|;
try|try
init|(
name|ResultSet
name|res
init|=
name|pStmt
operator|.
name|executeQuery
argument_list|()
init|)
block|{
while|while
condition|(
name|res
operator|.
name|next
argument_list|()
condition|)
block|{
name|String
name|locValue
init|=
name|res
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|String
name|entity
init|=
literal|"Database "
operator|+
name|getNameOrID
argument_list|(
name|res
argument_list|,
literal|5
argument_list|,
literal|4
argument_list|)
operator|+
literal|", Table "
operator|+
name|getNameOrID
argument_list|(
name|res
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|checkLocation
argument_list|(
name|entity
argument_list|,
name|locValue
argument_list|,
name|defaultServers
argument_list|)
condition|)
block|{
name|numOfInvalid
operator|++
expr_stmt|;
block|}
block|}
block|}
name|minID
operator|+=
name|TAB_LOC_CHECK_SIZE
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
name|numOfInvalid
operator|==
literal|0
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveMetaException
argument_list|(
literal|"Failed to get Table Location Info."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|String
name|QUERY_PART_ID_RANGE
init|=
literal|"select max(<q>PART_ID<q>),"
operator|+
literal|"       min(<q>PART_ID<q>)"
operator|+
literal|"  from<q>PARTITIONS<q> "
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|QUERY_PART_LOC
init|=
literal|"    select pt.<q>PART_ID<q>, "
operator|+
literal|"           pt.<q>PART_NAME<q>, "
operator|+
literal|"           sd.<q>LOCATION<q>, "
operator|+
literal|"           tbl.<q>TBL_ID<q>, "
operator|+
literal|"           tbl.<q>TBL_NAME<q>, "
operator|+
literal|"           dbt.<q>DB_ID<q>, "
operator|+
literal|"           dbt.<q>NAME<q> "
operator|+
literal|"      from<q>PARTITIONS<q> pt "
operator|+
literal|"inner join<q>SDS<q> sd on sd.<q>SD_ID<q> = pt.<q>SD_ID<q> "
operator|+
literal|"inner join<q>TBLS<q> tbl on tbl.<q>TBL_ID<q> = pt.<q>TBL_ID<q> "
operator|+
literal|"inner join<q>DBS<q> dbt on dbt.<q>DB_ID<q> = tbl.<q>DB_ID<q> "
operator|+
literal|"     where pt.<q>PART_ID<q>>= ? "
operator|+
literal|"       and pt.<q>PART_ID<q><= ? "
operator|+
literal|"  order by tbl.<q>TBL_ID<q> "
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|PART_LOC_CHECK_SIZE
init|=
literal|2000
decl_stmt|;
specifier|private
name|boolean
name|checkMetaStorePartitionLocation
parameter_list|(
name|Connection
name|conn
parameter_list|,
name|URI
index|[]
name|defaultServers
parameter_list|)
throws|throws
name|HiveMetaException
block|{
name|String
name|queryPartIDRange
init|=
name|schemaTool
operator|.
name|quote
argument_list|(
name|QUERY_PART_ID_RANGE
argument_list|)
decl_stmt|;
name|String
name|queryPartLoc
init|=
name|schemaTool
operator|.
name|quote
argument_list|(
name|QUERY_PART_LOC
argument_list|)
decl_stmt|;
try|try
block|{
name|long
name|maxID
init|=
literal|0
decl_stmt|,
name|minID
init|=
literal|0
decl_stmt|;
try|try
init|(
name|Statement
name|stmt
init|=
name|conn
operator|.
name|createStatement
argument_list|()
init|;
name|ResultSet
name|res
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|queryPartIDRange
argument_list|)
init|)
block|{
if|if
condition|(
name|res
operator|.
name|next
argument_list|()
condition|)
block|{
name|maxID
operator|=
name|res
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|minID
operator|=
name|res
operator|.
name|getLong
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|numOfInvalid
init|=
literal|0
decl_stmt|;
try|try
init|(
name|PreparedStatement
name|pStmt
init|=
name|conn
operator|.
name|prepareStatement
argument_list|(
name|queryPartLoc
argument_list|)
init|)
block|{
while|while
condition|(
name|minID
operator|<=
name|maxID
condition|)
block|{
name|pStmt
operator|.
name|setLong
argument_list|(
literal|1
argument_list|,
name|minID
argument_list|)
expr_stmt|;
name|pStmt
operator|.
name|setLong
argument_list|(
literal|2
argument_list|,
name|minID
operator|+
name|PART_LOC_CHECK_SIZE
argument_list|)
expr_stmt|;
try|try
init|(
name|ResultSet
name|res
init|=
name|pStmt
operator|.
name|executeQuery
argument_list|()
init|)
block|{
while|while
condition|(
name|res
operator|.
name|next
argument_list|()
condition|)
block|{
name|String
name|locValue
init|=
name|res
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|String
name|entity
init|=
literal|"Database "
operator|+
name|getNameOrID
argument_list|(
name|res
argument_list|,
literal|7
argument_list|,
literal|6
argument_list|)
operator|+
literal|", Table "
operator|+
name|getNameOrID
argument_list|(
name|res
argument_list|,
literal|5
argument_list|,
literal|4
argument_list|)
operator|+
literal|", Partition "
operator|+
name|getNameOrID
argument_list|(
name|res
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|checkLocation
argument_list|(
name|entity
argument_list|,
name|locValue
argument_list|,
name|defaultServers
argument_list|)
condition|)
block|{
name|numOfInvalid
operator|++
expr_stmt|;
block|}
block|}
block|}
name|minID
operator|+=
name|PART_LOC_CHECK_SIZE
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
name|numOfInvalid
operator|==
literal|0
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveMetaException
argument_list|(
literal|"Failed to get Partition Location Info."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|String
name|QUERY_SKEWED_COL_ID_RANGE
init|=
literal|"select max(<q>STRING_LIST_ID_KID<q>), "
operator|+
literal|"       min(<q>STRING_LIST_ID_KID<q>) "
operator|+
literal|"  from<q>SKEWED_COL_VALUE_LOC_MAP<q> "
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|QUERY_SKEWED_COL_LOC
init|=
literal|"  select t.<q>TBL_NAME<q>, "
operator|+
literal|"         t.<q>TBL_ID<q>, "
operator|+
literal|"         sk.<q>STRING_LIST_ID_KID<q>, "
operator|+
literal|"         sk.<q>LOCATION<q>, "
operator|+
literal|"         db.<q>NAME<q>, "
operator|+
literal|"         db.<q>DB_ID<q> "
operator|+
literal|"    from<q>TBLS<q> t "
operator|+
literal|"    join<q>SDS<q> s on s.<q>SD_ID<q> = t.<q>SD_ID<q> "
operator|+
literal|"    join<q>DBS<q> db on db.<q>DB_ID<q> = t.<q>DB_ID<q> "
operator|+
literal|"    join<q>SKEWED_COL_VALUE_LOC_MAP<q> sk on sk.<q>SD_ID<q> = s.<q>SD_ID<q> "
operator|+
literal|"   where sk.<q>STRING_LIST_ID_KID<q>>= ? "
operator|+
literal|"     and sk.<q>STRING_LIST_ID_KID<q><= ? "
operator|+
literal|"order by t.<q>TBL_ID<q> "
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|SKEWED_COL_LOC_CHECK_SIZE
init|=
literal|2000
decl_stmt|;
specifier|private
name|boolean
name|checkMetaStoreSkewedColumnsLocation
parameter_list|(
name|Connection
name|conn
parameter_list|,
name|URI
index|[]
name|defaultServers
parameter_list|)
throws|throws
name|HiveMetaException
block|{
name|String
name|querySkewedColIDRange
init|=
name|schemaTool
operator|.
name|quote
argument_list|(
name|QUERY_SKEWED_COL_ID_RANGE
argument_list|)
decl_stmt|;
name|String
name|querySkewedColLoc
init|=
name|schemaTool
operator|.
name|quote
argument_list|(
name|QUERY_SKEWED_COL_LOC
argument_list|)
decl_stmt|;
try|try
block|{
name|long
name|maxID
init|=
literal|0
decl_stmt|,
name|minID
init|=
literal|0
decl_stmt|;
try|try
init|(
name|Statement
name|stmt
init|=
name|conn
operator|.
name|createStatement
argument_list|()
init|;
name|ResultSet
name|res
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|querySkewedColIDRange
argument_list|)
init|)
block|{
if|if
condition|(
name|res
operator|.
name|next
argument_list|()
condition|)
block|{
name|maxID
operator|=
name|res
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|minID
operator|=
name|res
operator|.
name|getLong
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|numOfInvalid
init|=
literal|0
decl_stmt|;
try|try
init|(
name|PreparedStatement
name|pStmt
init|=
name|conn
operator|.
name|prepareStatement
argument_list|(
name|querySkewedColLoc
argument_list|)
init|)
block|{
while|while
condition|(
name|minID
operator|<=
name|maxID
condition|)
block|{
name|pStmt
operator|.
name|setLong
argument_list|(
literal|1
argument_list|,
name|minID
argument_list|)
expr_stmt|;
name|pStmt
operator|.
name|setLong
argument_list|(
literal|2
argument_list|,
name|minID
operator|+
name|SKEWED_COL_LOC_CHECK_SIZE
argument_list|)
expr_stmt|;
try|try
init|(
name|ResultSet
name|res
init|=
name|pStmt
operator|.
name|executeQuery
argument_list|()
init|)
block|{
while|while
condition|(
name|res
operator|.
name|next
argument_list|()
condition|)
block|{
name|String
name|locValue
init|=
name|res
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|String
name|entity
init|=
literal|"Database "
operator|+
name|getNameOrID
argument_list|(
name|res
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|)
operator|+
literal|", Table "
operator|+
name|getNameOrID
argument_list|(
name|res
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
operator|+
literal|", String list "
operator|+
name|res
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|checkLocation
argument_list|(
name|entity
argument_list|,
name|locValue
argument_list|,
name|defaultServers
argument_list|)
condition|)
block|{
name|numOfInvalid
operator|++
expr_stmt|;
block|}
block|}
block|}
name|minID
operator|+=
name|SKEWED_COL_LOC_CHECK_SIZE
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
name|numOfInvalid
operator|==
literal|0
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveMetaException
argument_list|(
literal|"Failed to get skewed columns location info."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Check if the location is valid for the given entity.    * @param entity          the entity to represent a database, partition or table    * @param entityLocation  the location    * @param defaultServers  a list of the servers that the location needs to match.    *                        The location host needs to match one of the given servers.    *                        If empty, then no check against such list.    * @return true if the location is valid    */
specifier|private
name|boolean
name|checkLocation
parameter_list|(
name|String
name|entity
parameter_list|,
name|String
name|entityLocation
parameter_list|,
name|URI
index|[]
name|defaultServers
parameter_list|)
block|{
name|boolean
name|isValid
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|entityLocation
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|entity
operator|+
literal|", Error: empty location"
argument_list|)
expr_stmt|;
name|isValid
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|URI
name|currentUri
init|=
operator|new
name|Path
argument_list|(
name|entityLocation
argument_list|)
operator|.
name|toUri
argument_list|()
decl_stmt|;
name|String
name|scheme
init|=
name|currentUri
operator|.
name|getScheme
argument_list|()
decl_stmt|;
name|String
name|path
init|=
name|currentUri
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|scheme
argument_list|)
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|entity
operator|+
literal|", Location: "
operator|+
name|entityLocation
operator|+
literal|", Error: missing location scheme."
argument_list|)
expr_stmt|;
name|isValid
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|entity
operator|+
literal|", Location: "
operator|+
name|entityLocation
operator|+
literal|", Error: missing location path."
argument_list|)
expr_stmt|;
name|isValid
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ArrayUtils
operator|.
name|isNotEmpty
argument_list|(
name|defaultServers
argument_list|)
operator|&&
name|currentUri
operator|.
name|getAuthority
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|String
name|authority
init|=
name|currentUri
operator|.
name|getAuthority
argument_list|()
decl_stmt|;
name|boolean
name|matchServer
init|=
literal|false
decl_stmt|;
for|for
control|(
name|URI
name|server
range|:
name|defaultServers
control|)
block|{
if|if
condition|(
name|StringUtils
operator|.
name|equalsIgnoreCase
argument_list|(
name|server
operator|.
name|getScheme
argument_list|()
argument_list|,
name|scheme
argument_list|)
operator|&&
name|StringUtils
operator|.
name|equalsIgnoreCase
argument_list|(
name|server
operator|.
name|getAuthority
argument_list|()
argument_list|,
name|authority
argument_list|)
condition|)
block|{
name|matchServer
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|matchServer
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|entity
operator|+
literal|", Location: "
operator|+
name|entityLocation
operator|+
literal|", Error: mismatched server."
argument_list|)
expr_stmt|;
name|isValid
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|// if there is no path element other than "/", report it but not fail
if|if
condition|(
name|isValid
operator|&&
name|StringUtils
operator|.
name|containsOnly
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|entity
operator|+
literal|", Location: "
operator|+
name|entityLocation
operator|+
literal|", Warn: location set to root, "
operator|+
literal|"not a recommended config."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|pe
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|entity
operator|+
literal|", Error: invalid location - "
operator|+
name|pe
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|isValid
operator|=
literal|false
expr_stmt|;
block|}
block|}
return|return
name|isValid
return|;
block|}
specifier|private
name|String
name|getNameOrID
parameter_list|(
name|ResultSet
name|res
parameter_list|,
name|int
name|nameInx
parameter_list|,
name|int
name|idInx
parameter_list|)
throws|throws
name|SQLException
block|{
name|String
name|itemName
init|=
name|res
operator|.
name|getString
argument_list|(
name|nameInx
argument_list|)
decl_stmt|;
return|return
operator|(
name|itemName
operator|==
literal|null
operator|||
name|itemName
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
literal|"ID: "
operator|+
name|res
operator|.
name|getString
argument_list|(
name|idInx
argument_list|)
else|:
literal|"Name: "
operator|+
name|itemName
return|;
block|}
specifier|private
specifier|static
specifier|final
name|String
name|QUERY_COLUMN_NULL_VALUES
init|=
literal|"  select t.*"
operator|+
literal|"    from<q>TBLS<q> t"
operator|+
literal|"   where t.<q>SD_ID<q> IS NULL"
operator|+
literal|"     and (t.<q>TBL_TYPE<q> = '"
operator|+
name|TableType
operator|.
name|EXTERNAL_TABLE
operator|+
literal|"' or"
operator|+
literal|"          t.<q>TBL_TYPE<q> = '"
operator|+
name|TableType
operator|.
name|MANAGED_TABLE
operator|+
literal|"') "
operator|+
literal|"order by t.<q>TBL_ID<q> "
decl_stmt|;
annotation|@
name|VisibleForTesting
name|boolean
name|validateColumnNullValues
parameter_list|(
name|Connection
name|conn
parameter_list|)
throws|throws
name|HiveMetaException
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Validating columns for incorrect NULL values."
argument_list|)
expr_stmt|;
name|boolean
name|isValid
init|=
literal|true
decl_stmt|;
name|String
name|queryColumnNullValues
init|=
name|schemaTool
operator|.
name|quote
argument_list|(
name|QUERY_COLUMN_NULL_VALUES
argument_list|)
decl_stmt|;
try|try
init|(
name|Statement
name|stmt
init|=
name|conn
operator|.
name|createStatement
argument_list|()
init|;
name|ResultSet
name|res
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|queryColumnNullValues
argument_list|)
init|)
block|{
while|while
condition|(
name|res
operator|.
name|next
argument_list|()
condition|)
block|{
name|long
name|tableId
init|=
name|res
operator|.
name|getLong
argument_list|(
literal|"TBL_ID"
argument_list|)
decl_stmt|;
name|String
name|tableName
init|=
name|res
operator|.
name|getString
argument_list|(
literal|"TBL_NAME"
argument_list|)
decl_stmt|;
name|String
name|tableType
init|=
name|res
operator|.
name|getString
argument_list|(
literal|"TBL_TYPE"
argument_list|)
decl_stmt|;
name|isValid
operator|=
literal|false
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"SD_ID in TBLS should not be NULL for Table Name="
operator|+
name|tableName
operator|+
literal|", Table ID="
operator|+
name|tableId
operator|+
literal|", Table Type="
operator|+
name|tableType
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|isValid
condition|?
literal|"[SUCCESS]\n"
else|:
literal|"[FAIL]\n"
argument_list|)
expr_stmt|;
return|return
name|isValid
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveMetaException
argument_list|(
literal|"Failed to validate columns for incorrect NULL values"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

