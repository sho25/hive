begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  *  Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *       http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
package|;
end_package

begin_import
import|import
name|com
operator|.
name|fasterxml
operator|.
name|jackson
operator|.
name|databind
operator|.
name|JsonNode
import|;
end_import

begin_import
import|import
name|com
operator|.
name|fasterxml
operator|.
name|jackson
operator|.
name|databind
operator|.
name|node
operator|.
name|ArrayNode
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableBiMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|MetaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Partition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SerDeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|StorageDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|utils
operator|.
name|MetaStoreServerUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jdo
operator|.
name|PersistenceManager
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jdo
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlLong
import|;
end_import

begin_comment
comment|/**  * Evaluator for partition projection filters which specify parts of the partition that should be  * used using dot notation for fields.  */
end_comment

begin_class
specifier|public
class|class
name|PartitionProjectionEvaluator
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|PartitionProjectionEvaluator
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|convertMapNullsToEmptyStrings
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|isView
decl_stmt|;
specifier|private
specifier|final
name|String
name|includeParamKeyPattern
decl_stmt|;
specifier|private
specifier|final
name|String
name|excludeParamKeyPattern
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|projectionFields
decl_stmt|;
interface|interface
name|PartitionFieldValueSetter
parameter_list|<
name|T
parameter_list|>
block|{
name|void
name|setValue
parameter_list|(
name|T
name|part
parameter_list|,
name|PartitionFieldNode
name|node
parameter_list|,
name|Object
name|value
parameter_list|)
throws|throws
name|MetaException
function_decl|;
block|}
specifier|private
specifier|final
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|MutivaluedFieldSetter
argument_list|>
name|multiValuedFieldSetters
init|=
operator|new
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|MutivaluedFieldSetter
argument_list|>
argument_list|()
operator|.
name|put
argument_list|(
literal|"values"
argument_list|,
operator|new
name|PartitionValuesSetter
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"parameters"
argument_list|,
operator|new
name|PartitionParametersSetter
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.cols"
argument_list|,
operator|new
name|PartitionSDColsSetter
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.bucketCols"
argument_list|,
operator|new
name|PartitionSDBucketColsSetter
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.sortCols"
argument_list|,
operator|new
name|PartitionSortColsSetter
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.parameters"
argument_list|,
operator|new
name|PartitionSDParametersSetter
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.serdeInfo.parameters"
argument_list|,
operator|new
name|PartitionSerdeInfoParametersSetter
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.skewedInfo.skewedColNames"
argument_list|,
operator|new
name|PartitionSkewedColsNamesSetter
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.skewedInfo.skewedColValues"
argument_list|,
operator|new
name|PartitionSkewedColsValuesSetter
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.skewedInfo.skewedColValueLocationMaps"
argument_list|,
operator|new
name|PartitionSkewedColValLocationMapSetter
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|PART_ID
init|=
literal|"PART_ID"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|SD_ID
init|=
literal|"SD_ID"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|SERDE_ID
init|=
literal|"SERDE_ID"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|CD_ID
init|=
literal|"CD_ID"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|PartitionFieldNode
name|partIdNode
init|=
operator|new
name|PartitionFieldNode
argument_list|(
name|PART_ID
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|PartitionFieldNode
name|sdIdNode
init|=
operator|new
name|PartitionFieldNode
argument_list|(
name|SD_ID
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|PartitionFieldNode
name|serdeIdNode
init|=
operator|new
name|PartitionFieldNode
argument_list|(
name|SERDE_ID
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|PartitionFieldNode
name|cdIdNode
init|=
operator|new
name|PartitionFieldNode
argument_list|(
name|CD_ID
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|fieldNameToTableName
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|PartitionFieldNode
argument_list|>
name|roots
decl_stmt|;
specifier|private
specifier|final
name|String
name|PARTITIONS
decl_stmt|;
specifier|private
specifier|final
name|String
name|SDS
decl_stmt|;
specifier|private
specifier|final
name|String
name|SERDES
decl_stmt|;
specifier|private
specifier|final
name|String
name|PARTITION_PARAMS
decl_stmt|;
specifier|private
specifier|final
name|PersistenceManager
name|pm
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|static
specifier|final
name|String
name|SD_PATTERN
init|=
literal|"sd|sd\\."
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|static
specifier|final
name|String
name|SERDE_PATTERN
init|=
literal|"sd\\.serdeInfo|sd\\.serdeInfo\\."
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|static
specifier|final
name|String
name|CD_PATTERN
init|=
literal|"sd\\.cols|sd\\.cols\\."
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|SD_INDEX
init|=
literal|0
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|CD_INDEX
init|=
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|SERDE_INDEX
init|=
literal|2
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|PART_INDEX
init|=
literal|3
decl_stmt|;
comment|// this map stores all the single valued fields in the Partition class and maps them to the corresponding
comment|// single-valued fields from the MPartition class. This map is used to parse the given partition fields
comment|// as well as to convert a given partition field list to a JDO setResult string when direct-SQL
comment|// is disabled
specifier|private
specifier|static
specifier|final
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|allPartitionSingleValuedFields
init|=
operator|new
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
operator|.
name|put
argument_list|(
literal|"dbName"
argument_list|,
literal|"table.database.name"
argument_list|)
operator|.
name|put
argument_list|(
literal|"tableName"
argument_list|,
literal|"table.tableName"
argument_list|)
operator|.
name|put
argument_list|(
literal|"createTime"
argument_list|,
literal|"createTime"
argument_list|)
operator|.
name|put
argument_list|(
literal|"lastAccessTime"
argument_list|,
literal|"lastAccessTime"
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.location"
argument_list|,
literal|"sd.location"
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.inputFormat"
argument_list|,
literal|"sd.inputFormat"
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.outputFormat"
argument_list|,
literal|"sd.outputFormat"
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.compressed"
argument_list|,
literal|"sd.isCompressed"
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.numBuckets"
argument_list|,
literal|"sd.numBuckets"
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.serdeInfo.name"
argument_list|,
literal|"sd.serDeInfo.name"
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.serdeInfo.serializationLib"
argument_list|,
literal|"sd.serDeInfo.serializationLib"
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.serdeInfo.description"
argument_list|,
literal|"sd.serDeInfo.description"
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.serdeInfo.serializerClass"
argument_list|,
literal|"sd.serDeInfo.serializerClass"
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.serdeInfo.deserializerClass"
argument_list|,
literal|"sd.serDeInfo.deserializerClass"
argument_list|)
operator|.
name|put
argument_list|(
literal|"sd.serdeInfo.serdeType"
argument_list|,
literal|"sd.serDeInfo.serdeType"
argument_list|)
operator|.
name|put
argument_list|(
literal|"catName"
argument_list|,
literal|"table.database.catalogName"
argument_list|)
operator|.
name|put
argument_list|(
literal|"writeId"
argument_list|,
literal|"writeId"
argument_list|)
comment|//TODO there is no mapping for isStatsCompliant to JDO MPartition
comment|//.put("isStatsCompliant", "isStatsCompliant")
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|ImmutableSet
argument_list|<
name|String
argument_list|>
name|allPartitionMultiValuedFields
init|=
operator|new
name|ImmutableSet
operator|.
name|Builder
argument_list|<
name|String
argument_list|>
argument_list|()
operator|.
name|add
argument_list|(
literal|"values"
argument_list|)
operator|.
name|add
argument_list|(
literal|"sd.cols.name"
argument_list|)
operator|.
name|add
argument_list|(
literal|"sd.cols.type"
argument_list|)
operator|.
name|add
argument_list|(
literal|"sd.cols.comment"
argument_list|)
operator|.
name|add
argument_list|(
literal|"sd.serdeInfo.parameters"
argument_list|)
operator|.
name|add
argument_list|(
literal|"sd.bucketCols"
argument_list|)
operator|.
name|add
argument_list|(
literal|"sd.sortCols.col"
argument_list|)
operator|.
name|add
argument_list|(
literal|"sd.sortCols.order"
argument_list|)
operator|.
name|add
argument_list|(
literal|"sd.parameters"
argument_list|)
operator|.
name|add
argument_list|(
literal|"sd.skewedInfo.skewedColNames"
argument_list|)
operator|.
name|add
argument_list|(
literal|"sd.skewedInfo.skewedColValues"
argument_list|)
operator|.
name|add
argument_list|(
literal|"sd.skewedInfo.skewedColValueLocationMaps"
argument_list|)
operator|.
name|add
argument_list|(
literal|"parameters"
argument_list|)
operator|.
name|add
argument_list|(
literal|"privileges.userPrivileges"
argument_list|)
operator|.
name|add
argument_list|(
literal|"privileges.groupPrivileges"
argument_list|)
operator|.
name|add
argument_list|(
literal|"privileges.rolePrivileges"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|ImmutableSet
argument_list|<
name|String
argument_list|>
name|allPartitionFields
init|=
operator|new
name|ImmutableSet
operator|.
name|Builder
argument_list|<
name|String
argument_list|>
argument_list|()
operator|.
name|addAll
argument_list|(
name|allPartitionSingleValuedFields
operator|.
name|keySet
argument_list|()
argument_list|)
operator|.
name|addAll
argument_list|(
name|allPartitionMultiValuedFields
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|public
name|PartitionProjectionEvaluator
parameter_list|(
name|PersistenceManager
name|pm
parameter_list|,
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|fieldNameToTableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|projectionFields
parameter_list|,
name|boolean
name|convertMapNullsToEmptyStrings
parameter_list|,
name|boolean
name|isView
parameter_list|,
name|String
name|includeParamKeyPattern
parameter_list|,
name|String
name|excludeParamKeyPattern
parameter_list|)
throws|throws
name|MetaException
block|{
name|this
operator|.
name|pm
operator|=
name|pm
expr_stmt|;
name|this
operator|.
name|fieldNameToTableName
operator|=
name|fieldNameToTableName
expr_stmt|;
name|this
operator|.
name|convertMapNullsToEmptyStrings
operator|=
name|convertMapNullsToEmptyStrings
expr_stmt|;
name|this
operator|.
name|isView
operator|=
name|isView
expr_stmt|;
name|this
operator|.
name|includeParamKeyPattern
operator|=
name|includeParamKeyPattern
expr_stmt|;
name|this
operator|.
name|excludeParamKeyPattern
operator|=
name|excludeParamKeyPattern
expr_stmt|;
name|this
operator|.
name|PARTITIONS
operator|=
name|fieldNameToTableName
operator|.
name|containsKey
argument_list|(
literal|"PARTITIONS_TABLE_NAME"
argument_list|)
condition|?
name|fieldNameToTableName
operator|.
name|get
argument_list|(
literal|"PARTITIONS_TABLE_NAME"
argument_list|)
else|:
literal|"PARTITIONS"
expr_stmt|;
name|this
operator|.
name|SDS
operator|=
name|fieldNameToTableName
operator|.
name|containsKey
argument_list|(
literal|"SDS_TABLE_NAME"
argument_list|)
condition|?
name|fieldNameToTableName
operator|.
name|get
argument_list|(
literal|"SDS_TABLE_NAME"
argument_list|)
else|:
literal|"SDS"
expr_stmt|;
name|this
operator|.
name|SERDES
operator|=
name|fieldNameToTableName
operator|.
name|containsKey
argument_list|(
literal|"SERDES_TABLE_NAME"
argument_list|)
condition|?
name|fieldNameToTableName
operator|.
name|get
argument_list|(
literal|"SERDES_TABLE_NAME"
argument_list|)
else|:
literal|"SERDES"
expr_stmt|;
name|this
operator|.
name|PARTITION_PARAMS
operator|=
name|fieldNameToTableName
operator|.
name|containsKey
argument_list|(
literal|"PARTITION_PARAMS"
argument_list|)
condition|?
name|fieldNameToTableName
operator|.
name|get
argument_list|(
literal|"PARTITION_PARAMS"
argument_list|)
else|:
literal|"PARTITION_PARAMS"
expr_stmt|;
name|roots
operator|=
name|parse
argument_list|(
name|projectionFields
argument_list|)
expr_stmt|;
comment|// we always query PART_ID
name|roots
operator|.
name|add
argument_list|(
name|partIdNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|find
argument_list|(
name|SD_PATTERN
argument_list|)
condition|)
block|{
name|roots
operator|.
name|add
argument_list|(
name|sdIdNode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|find
argument_list|(
name|SERDE_PATTERN
argument_list|)
condition|)
block|{
name|roots
operator|.
name|add
argument_list|(
name|serdeIdNode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|find
argument_list|(
name|CD_PATTERN
argument_list|)
condition|)
block|{
name|roots
operator|.
name|add
argument_list|(
name|cdIdNode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Given a Java regex string pattern, checks if the the partitionFieldNode tree    * has any node whose fieldName matches the given pattern    * @param searchField    * @return    */
annotation|@
name|VisibleForTesting
name|boolean
name|find
parameter_list|(
name|String
name|searchField
parameter_list|)
block|{
name|Pattern
name|p
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|searchField
argument_list|)
decl_stmt|;
for|for
control|(
name|PartitionFieldNode
name|node
range|:
name|roots
control|)
block|{
if|if
condition|(
name|find
argument_list|(
name|node
argument_list|,
name|p
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
specifier|static
name|boolean
name|find
parameter_list|(
name|PartitionFieldNode
name|root
parameter_list|,
name|Pattern
name|p
parameter_list|)
block|{
if|if
condition|(
name|root
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|p
operator|.
name|matcher
argument_list|(
name|root
operator|.
name|fieldName
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
for|for
control|(
name|PartitionFieldNode
name|child
range|:
name|root
operator|.
name|children
control|)
block|{
if|if
condition|(
name|find
argument_list|(
name|child
argument_list|,
name|p
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * if top level field name is given expand the top level field such that all the children    * of that node are added to the projection list. eg. if only "sd" is provided in the projection    * list, it means all the nested fields for sd should be added to the projection fields    * @param projectionList    * @return    */
specifier|private
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|expand
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|projectionList
parameter_list|)
throws|throws
name|MetaException
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|result
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|projectedField
range|:
name|projectionList
control|)
block|{
if|if
condition|(
name|allPartitionFields
operator|.
name|contains
argument_list|(
name|projectedField
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|projectedField
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|partitionField
range|:
name|allPartitionFields
control|)
block|{
if|if
condition|(
name|partitionField
operator|.
name|startsWith
argument_list|(
name|projectedField
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found "
operator|+
name|partitionField
operator|+
literal|" included within given projection field "
operator|+
name|projectedField
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
name|partitionField
argument_list|)
expr_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Invalid field name "
operator|+
name|projectedField
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
annotation|@
name|VisibleForTesting
name|Set
argument_list|<
name|PartitionFieldNode
argument_list|>
name|getRoots
parameter_list|()
block|{
return|return
name|roots
return|;
block|}
specifier|private
specifier|static
name|void
name|validate
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|projectionFields
parameter_list|)
throws|throws
name|MetaException
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|verify
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|projectionFields
argument_list|)
decl_stmt|;
name|verify
operator|.
name|removeAll
argument_list|(
name|allPartitionFields
argument_list|)
expr_stmt|;
if|if
condition|(
name|verify
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Invalid partition fields in the projection spec"
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|verify
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|verify
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|private
name|Set
argument_list|<
name|PartitionFieldNode
argument_list|>
name|parse
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|inputProjectionFields
parameter_list|)
throws|throws
name|MetaException
block|{
comment|// in case of dbName and tableName we rely on table object to get their values
name|this
operator|.
name|projectionFields
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|inputProjectionFields
argument_list|)
expr_stmt|;
name|projectionFields
operator|.
name|remove
argument_list|(
literal|"dbName"
argument_list|)
expr_stmt|;
name|projectionFields
operator|.
name|remove
argument_list|(
literal|"tableName"
argument_list|)
expr_stmt|;
name|projectionFields
operator|.
name|remove
argument_list|(
literal|"catName"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isView
condition|)
block|{
comment|// if this is a view SDs are not set so can be skipped
name|projectionFields
operator|.
name|removeIf
argument_list|(
name|s
lambda|->
name|s
operator|.
name|matches
argument_list|(
name|SD_PATTERN
argument_list|)
operator|||
name|s
operator|.
name|matches
argument_list|(
name|SERDE_PATTERN
argument_list|)
operator|||
name|s
operator|.
name|matches
argument_list|(
name|CD_PATTERN
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// remove redundant fields
name|projectionFields
operator|=
name|PartitionProjectionEvaluator
operator|.
name|expand
argument_list|(
name|projectionFields
argument_list|)
expr_stmt|;
name|removeUnsupportedFields
argument_list|()
expr_stmt|;
name|validate
argument_list|(
name|projectionFields
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|PartitionFieldNode
argument_list|>
name|nestedNodes
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|PartitionFieldNode
argument_list|>
name|rootNodes
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|projectedField
range|:
name|projectionFields
control|)
block|{
name|String
index|[]
name|fields
init|=
name|projectedField
operator|.
name|split
argument_list|(
literal|"\\."
argument_list|)
decl_stmt|;
if|if
condition|(
name|fields
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Invalid projected field {}. Ignoring .."
argument_list|,
name|projectedField
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|StringBuilder
name|fieldNameBuilder
init|=
operator|new
name|StringBuilder
argument_list|(
name|fields
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|PartitionFieldNode
name|currentNode
init|=
name|createIfNotExists
argument_list|(
name|nestedNodes
argument_list|,
name|fieldNameBuilder
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|rootNodes
operator|.
name|add
argument_list|(
name|currentNode
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|fields
operator|.
name|length
condition|;
name|level
operator|++
control|)
block|{
specifier|final
name|String
name|name
init|=
name|fieldNameBuilder
operator|.
name|append
argument_list|(
literal|"."
argument_list|)
operator|.
name|append
argument_list|(
name|fields
index|[
name|level
index|]
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|PartitionFieldNode
name|childNode
init|=
name|createIfNotExists
argument_list|(
name|nestedNodes
argument_list|,
name|name
argument_list|)
decl_stmt|;
comment|// all the children of a multi-valued nodes are also multi-valued
if|if
condition|(
name|currentNode
operator|.
name|isMultiValued
condition|)
block|{
name|childNode
operator|.
name|setMultiValued
argument_list|()
expr_stmt|;
block|}
name|currentNode
operator|.
name|addChild
argument_list|(
name|childNode
argument_list|)
expr_stmt|;
name|currentNode
operator|=
name|childNode
expr_stmt|;
block|}
block|}
return|return
name|rootNodes
return|;
block|}
comment|// TODO some of the optional partition fields are never set by DirectSQL implementation
comment|// Removing such fields to keep it consistent with methods in MetastoreDirectSQL class
specifier|private
name|void
name|removeUnsupportedFields
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|unsupportedFields
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"sd.serdeInfo.serializerClass"
argument_list|,
literal|"sd.serdeInfo.deserializerClass"
argument_list|,
literal|"sd.serdeInfo.serdeType"
argument_list|,
literal|"sd.serdeInfo.description"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|unsupportedField
range|:
name|unsupportedFields
control|)
block|{
if|if
condition|(
name|projectionFields
operator|.
name|contains
argument_list|(
name|unsupportedField
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"DirectSQL does not return partitions with the optional field"
operator|+
name|unsupportedField
operator|+
literal|" set. Removing it from the projection list"
argument_list|)
expr_stmt|;
name|projectionFields
operator|.
name|remove
argument_list|(
name|unsupportedField
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|PartitionFieldNode
name|createIfNotExists
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|PartitionFieldNode
argument_list|>
name|nestedNodes
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
name|PartitionFieldNode
name|currentNode
init|=
name|nestedNodes
operator|.
name|computeIfAbsent
argument_list|(
name|fieldName
argument_list|,
name|k
lambda|->
block|{
if|if
condition|(
name|multiValuedFieldSetters
operator|.
name|containsKey
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
return|return
operator|new
name|PartitionFieldNode
argument_list|(
name|fieldName
argument_list|,
literal|true
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|PartitionFieldNode
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
return|return
name|currentNode
return|;
block|}
comment|/**    * Given a list of partition ids, returns the List of partially filled partitions based on the    * projection list used to instantiate this PartitionProjectionEvaluator    * @param partitionIds List of partition ids corresponding to the Partitions objects which are requested    * @return Partitions where each partition has only the projected fields set    * @throws MetaException    */
specifier|public
name|List
argument_list|<
name|Partition
argument_list|>
name|getPartitionsUsingProjectionList
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|partitionIds
parameter_list|)
throws|throws
name|MetaException
block|{
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sds
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
name|cds
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|SerDeInfo
argument_list|>
name|serdes
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
name|partitions
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Partition
argument_list|>
name|results
init|=
name|setSingleValuedFields
argument_list|(
name|partitionIds
argument_list|,
name|partitions
argument_list|,
name|sds
argument_list|,
name|serdes
argument_list|,
name|cds
argument_list|)
decl_stmt|;
name|setMultivaluedFields
argument_list|(
name|partitions
argument_list|,
name|sds
argument_list|,
name|serdes
argument_list|,
name|cds
argument_list|)
expr_stmt|;
return|return
name|results
return|;
block|}
specifier|private
name|List
argument_list|<
name|Partition
argument_list|>
name|setSingleValuedFields
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|partitionIds
parameter_list|,
specifier|final
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
name|partitions
parameter_list|,
specifier|final
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sdIds
parameter_list|,
specifier|final
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|SerDeInfo
argument_list|>
name|serdeIds
parameter_list|,
specifier|final
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
name|cdIds
parameter_list|)
throws|throws
name|MetaException
block|{
name|StringBuilder
name|queryTextBuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|numColumns
init|=
name|buildQueryForSingleValuedFields
argument_list|(
name|partitionIds
argument_list|,
name|queryTextBuilder
argument_list|)
decl_stmt|;
name|String
name|queryText
init|=
name|queryTextBuilder
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Query
argument_list|<
name|?
argument_list|>
name|query
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
try|try
block|{
name|long
name|start
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|sqlResult
init|=
name|MetastoreDirectSqlUtils
operator|.
name|executeWithArray
argument_list|(
name|query
argument_list|,
literal|null
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|long
name|queryTime
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|timingTrace
argument_list|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|queryTime
argument_list|)
expr_stmt|;
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
specifier|final
name|Long
index|[]
name|ids
init|=
operator|new
name|Long
index|[
literal|4
index|]
decl_stmt|;
name|Object
index|[]
name|rowVals
init|=
operator|new
name|Object
index|[
literal|1
index|]
decl_stmt|;
comment|// Keep order by name, consistent with JDO.
name|ArrayList
argument_list|<
name|Partition
argument_list|>
name|orderedResult
init|=
operator|new
name|ArrayList
argument_list|<
name|Partition
argument_list|>
argument_list|(
name|partitionIds
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Object
name|row
range|:
name|sqlResult
control|)
block|{
if|if
condition|(
name|numColumns
operator|>
literal|1
condition|)
block|{
name|rowVals
operator|=
operator|(
name|Object
index|[]
operator|)
name|row
expr_stmt|;
block|}
else|else
block|{
comment|// only one column is selected by query. The result class will be Object
name|rowVals
index|[
literal|0
index|]
operator|=
name|row
expr_stmt|;
block|}
name|Partition
name|part
init|=
operator|new
name|Partition
argument_list|()
decl_stmt|;
for|for
control|(
name|PartitionFieldNode
name|root
range|:
name|roots
control|)
block|{
name|traverseAndSetValues
argument_list|(
name|part
argument_list|,
name|root
argument_list|,
name|rowVals
argument_list|,
operator|new
name|PartitionFieldValueSetter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|setValue
parameter_list|(
name|Object
name|partition
parameter_list|,
name|PartitionFieldNode
name|node
parameter_list|,
name|Object
name|value
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
operator|!
name|node
operator|.
name|isMultiValued
condition|)
block|{
comment|// in case of serdeid and sdId node we just collect the sdIds for further processing
if|if
condition|(
name|node
operator|.
name|equals
argument_list|(
name|sdIdNode
argument_list|)
condition|)
block|{
name|ids
index|[
name|SD_INDEX
index|]
operator|=
name|extractSqlLong
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|equals
argument_list|(
name|serdeIdNode
argument_list|)
condition|)
block|{
name|ids
index|[
name|SERDE_INDEX
index|]
operator|=
name|extractSqlLong
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|equals
argument_list|(
name|cdIdNode
argument_list|)
condition|)
block|{
name|ids
index|[
name|CD_INDEX
index|]
operator|=
name|extractSqlLong
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|equals
argument_list|(
name|partIdNode
argument_list|)
condition|)
block|{
name|ids
index|[
name|PART_INDEX
index|]
operator|=
name|extractSqlLong
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// incase of sd.compressed and sd.storedAsSubDirectories we need special code to convert
comment|// string to a boolean value
if|if
condition|(
name|node
operator|.
name|fieldName
operator|.
name|equals
argument_list|(
literal|"sd.compressed"
argument_list|)
operator|||
name|node
operator|.
name|fieldName
operator|.
name|equals
argument_list|(
literal|"sd.storedAsSubDirectories"
argument_list|)
condition|)
block|{
name|value
operator|=
name|MetastoreDirectSqlUtils
operator|.
name|extractSqlBoolean
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|MetaStoreServerUtils
operator|.
name|setNestedProperty
argument_list|(
name|partition
argument_list|,
name|node
operator|.
name|fieldName
argument_list|,
name|value
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|// PART_ID is always queried
if|if
condition|(
name|ids
index|[
name|PART_INDEX
index|]
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Could not find PART_ID for partition "
operator|+
name|part
argument_list|)
throw|;
block|}
name|partitions
operator|.
name|put
argument_list|(
name|ids
index|[
name|PART_INDEX
index|]
argument_list|,
name|part
argument_list|)
expr_stmt|;
name|orderedResult
operator|.
name|add
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|ids
index|[
name|PART_INDEX
index|]
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|ids
index|[
name|SD_INDEX
index|]
operator|!=
literal|null
condition|)
block|{
comment|// sd object is initialized if any of the sd single-valued fields are in the projection
if|if
condition|(
name|part
operator|.
name|getSd
argument_list|()
operator|==
literal|null
condition|)
block|{
name|part
operator|.
name|setSd
argument_list|(
operator|new
name|StorageDescriptor
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sdIds
operator|.
name|put
argument_list|(
name|ids
index|[
name|SD_INDEX
index|]
argument_list|,
name|part
operator|.
name|getSd
argument_list|()
argument_list|)
expr_stmt|;
name|ids
index|[
name|SD_INDEX
index|]
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|ids
index|[
name|SERDE_INDEX
index|]
operator|!=
literal|null
condition|)
block|{
comment|// serde object must have already been intialized above in MetaStoreUtils.setNestedProperty call
if|if
condition|(
name|part
operator|.
name|getSd
argument_list|()
operator|.
name|getSerdeInfo
argument_list|()
operator|==
literal|null
condition|)
block|{
name|part
operator|.
name|getSd
argument_list|()
operator|.
name|setSerdeInfo
argument_list|(
operator|new
name|SerDeInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|serdeIds
operator|.
name|put
argument_list|(
name|ids
index|[
name|SERDE_INDEX
index|]
argument_list|,
name|part
operator|.
name|getSd
argument_list|()
operator|.
name|getSerdeInfo
argument_list|()
argument_list|)
expr_stmt|;
name|ids
index|[
name|SERDE_INDEX
index|]
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|ids
index|[
name|CD_INDEX
index|]
operator|!=
literal|null
condition|)
block|{
comment|// common case is all the SDs will reuse the same CD
comment|// allocate List<FieldSchema> only when you see a new CD_ID
name|cdIds
operator|.
name|putIfAbsent
argument_list|(
name|ids
index|[
name|CD_INDEX
index|]
argument_list|,
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|part
operator|.
name|getSd
argument_list|()
operator|.
name|getCols
argument_list|()
operator|==
literal|null
condition|)
block|{
name|part
operator|.
name|getSd
argument_list|()
operator|.
name|setCols
argument_list|(
name|cdIds
operator|.
name|get
argument_list|(
name|ids
index|[
name|CD_INDEX
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ids
index|[
name|CD_INDEX
index|]
operator|=
literal|null
expr_stmt|;
block|}
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
block|}
return|return
name|orderedResult
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception received while getting partitions using projected fields"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
finally|finally
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|setMultivaluedFields
parameter_list|(
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
name|partitions
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sds
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|SerDeInfo
argument_list|>
name|serdes
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
name|cds
parameter_list|)
throws|throws
name|MetaException
block|{
for|for
control|(
name|PartitionFieldNode
name|root
range|:
name|roots
control|)
block|{
name|traverseAndSetMultiValuedFields
argument_list|(
name|root
argument_list|,
name|partitions
argument_list|,
name|sds
argument_list|,
name|serdes
argument_list|,
name|cds
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|traverseAndSetMultiValuedFields
parameter_list|(
name|PartitionFieldNode
name|root
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
name|partitions
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sds
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|SerDeInfo
argument_list|>
name|serdes
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
name|cds
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|root
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// if a multi-valued node is found set its value using its value-setters
comment|// note that once a multi-valued node is found the method does not recurse further
comment|// this is because the multi-valued setter also sets the values of all its descendents
if|if
condition|(
name|root
operator|.
name|isMultiValued
condition|)
block|{
name|MutivaluedFieldSetter
name|multiValuedFieldSetter
init|=
name|multiValuedFieldSetters
operator|.
name|get
argument_list|(
name|root
operator|.
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|multiValuedFieldSetter
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Cannot find multi-valued field setter for field "
operator|+
name|root
operator|.
name|fieldName
argument_list|)
throw|;
block|}
name|multiValuedFieldSetter
operator|.
name|setValue
argument_list|(
name|root
argument_list|,
name|partitions
argument_list|,
name|sds
argument_list|,
name|serdes
argument_list|,
name|cds
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|PartitionFieldNode
name|child
range|:
name|root
operator|.
name|children
control|)
block|{
name|traverseAndSetMultiValuedFields
argument_list|(
name|child
argument_list|,
name|partitions
argument_list|,
name|sds
argument_list|,
name|serdes
argument_list|,
name|cds
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|traverseAndSetValues
parameter_list|(
name|Partition
name|part
parameter_list|,
name|PartitionFieldNode
name|root
parameter_list|,
name|Object
index|[]
name|row
parameter_list|,
name|PartitionFieldValueSetter
name|valueSetter
parameter_list|)
throws|throws
name|MetaException
block|{
comment|// if root is null or is multiValued, do not recurse further
comment|// multi-valued fields are set separately in setMultiValuedFields method
if|if
condition|(
name|root
operator|==
literal|null
operator|||
name|root
operator|.
name|isMultiValued
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|root
operator|.
name|isLeafNode
argument_list|()
condition|)
block|{
name|valueSetter
operator|.
name|setValue
argument_list|(
name|part
argument_list|,
name|root
argument_list|,
name|row
index|[
name|root
operator|.
name|fieldIndex
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|PartitionFieldNode
name|child
range|:
name|root
operator|.
name|children
control|)
block|{
name|traverseAndSetValues
argument_list|(
name|part
argument_list|,
name|child
argument_list|,
name|row
argument_list|,
name|valueSetter
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|String
name|SPACE
init|=
literal|" "
decl_stmt|;
specifier|private
name|int
name|buildQueryForSingleValuedFields
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|partitionIds
parameter_list|,
name|StringBuilder
name|queryTextBuilder
parameter_list|)
block|{
name|queryTextBuilder
operator|.
name|append
argument_list|(
literal|"select "
argument_list|)
expr_stmt|;
comment|// build projection columns using the ProjectedFields
comment|// it should not matter if you select all the
name|List
argument_list|<
name|String
argument_list|>
name|columnList
init|=
name|getSingleValuedColumnNames
argument_list|(
name|roots
argument_list|)
decl_stmt|;
name|queryTextBuilder
operator|.
name|append
argument_list|(
name|Joiner
operator|.
name|on
argument_list|(
literal|','
argument_list|)
operator|.
name|join
argument_list|(
name|columnList
argument_list|)
argument_list|)
expr_stmt|;
name|queryTextBuilder
operator|.
name|append
argument_list|(
name|SPACE
argument_list|)
expr_stmt|;
name|queryTextBuilder
operator|.
name|append
argument_list|(
literal|"from "
operator|+
name|PARTITIONS
argument_list|)
expr_stmt|;
comment|// if SD fields are selected add join clause with SDS
name|boolean
name|foundSD
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|find
argument_list|(
name|SD_PATTERN
argument_list|)
condition|)
block|{
name|queryTextBuilder
operator|.
name|append
argument_list|(
name|SPACE
argument_list|)
expr_stmt|;
name|queryTextBuilder
operator|.
name|append
argument_list|(
literal|"left outer join "
operator|+
name|SDS
operator|+
literal|" on "
operator|+
name|PARTITIONS
operator|+
literal|".\"SD_ID\" = "
operator|+
name|SDS
operator|+
literal|".\"SD_ID\""
argument_list|)
expr_stmt|;
name|foundSD
operator|=
literal|true
expr_stmt|;
block|}
comment|// if serde fields are selected add join clause on serdes
if|if
condition|(
name|foundSD
operator|||
name|find
argument_list|(
name|SERDE_PATTERN
argument_list|)
condition|)
block|{
name|queryTextBuilder
operator|.
name|append
argument_list|(
name|SPACE
argument_list|)
expr_stmt|;
name|queryTextBuilder
operator|.
name|append
argument_list|(
literal|"  left outer join "
operator|+
name|SERDES
operator|+
literal|" on "
operator|+
name|SDS
operator|+
literal|".\"SERDE_ID\" = "
operator|+
name|SERDES
operator|+
literal|".\"SERDE_ID\""
argument_list|)
expr_stmt|;
block|}
name|queryTextBuilder
operator|.
name|append
argument_list|(
name|SPACE
argument_list|)
expr_stmt|;
comment|//add where clause
name|queryTextBuilder
operator|.
name|append
argument_list|(
literal|"where \"PART_ID\" in ("
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|','
argument_list|)
operator|.
name|join
argument_list|(
name|partitionIds
argument_list|)
operator|+
literal|") order by \"PART_NAME\" asc"
argument_list|)
expr_stmt|;
return|return
name|columnList
operator|.
name|size
argument_list|()
return|;
block|}
specifier|private
name|int
name|getSingleValuedColumnName
parameter_list|(
name|PartitionFieldNode
name|root
parameter_list|,
name|int
name|fieldId
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|columnNames
parameter_list|)
block|{
if|if
condition|(
name|root
operator|==
literal|null
condition|)
block|{
return|return
name|fieldId
return|;
block|}
if|if
condition|(
name|root
operator|.
name|isLeafNode
argument_list|()
operator|&&
operator|!
name|root
operator|.
name|isMultiValued
condition|)
block|{
if|if
condition|(
name|fieldNameToTableName
operator|.
name|containsKey
argument_list|(
name|root
operator|.
name|fieldName
argument_list|)
condition|)
block|{
name|columnNames
operator|.
name|add
argument_list|(
name|fieldNameToTableName
operator|.
name|get
argument_list|(
name|root
operator|.
name|fieldName
argument_list|)
argument_list|)
expr_stmt|;
name|root
operator|.
name|setFieldIndex
argument_list|(
name|fieldId
operator|++
argument_list|)
expr_stmt|;
return|return
name|fieldId
return|;
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"No column name mapping found for partition field "
operator|+
name|root
operator|.
name|fieldName
argument_list|)
throw|;
block|}
for|for
control|(
name|PartitionFieldNode
name|child
range|:
name|root
operator|.
name|children
control|)
block|{
name|fieldId
operator|=
name|getSingleValuedColumnName
argument_list|(
name|child
argument_list|,
name|fieldId
argument_list|,
name|columnNames
argument_list|)
expr_stmt|;
block|}
return|return
name|fieldId
return|;
block|}
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getSingleValuedColumnNames
parameter_list|(
name|Set
argument_list|<
name|PartitionFieldNode
argument_list|>
name|roots
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|columnNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|fieldIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|PartitionFieldNode
name|node
range|:
name|roots
control|)
block|{
name|fieldIndex
operator|=
name|getSingleValuedColumnName
argument_list|(
name|node
argument_list|,
name|fieldIndex
argument_list|,
name|columnNames
argument_list|)
expr_stmt|;
block|}
return|return
name|columnNames
return|;
block|}
specifier|private
specifier|static
name|void
name|getNestedFieldName
parameter_list|(
name|JsonNode
name|jsonNode
parameter_list|,
name|String
name|fieldName
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|results
parameter_list|)
block|{
if|if
condition|(
name|jsonNode
operator|instanceof
name|ArrayNode
condition|)
block|{
name|Iterator
argument_list|<
name|JsonNode
argument_list|>
name|elements
init|=
operator|(
operator|(
name|ArrayNode
operator|)
name|jsonNode
operator|)
operator|.
name|elements
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|elements
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|results
operator|.
name|add
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|elements
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|JsonNode
name|element
init|=
name|elements
operator|.
name|next
argument_list|()
decl_stmt|;
name|getNestedFieldName
argument_list|(
name|element
argument_list|,
name|fieldName
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|JsonNode
argument_list|>
argument_list|>
name|fields
init|=
name|jsonNode
operator|.
name|fields
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fields
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|results
operator|.
name|add
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|fields
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|String
argument_list|,
name|JsonNode
argument_list|>
name|fieldKV
init|=
name|fields
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|key
init|=
name|fieldKV
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|getNestedFieldName
argument_list|(
name|fieldKV
operator|.
name|getValue
argument_list|()
argument_list|,
name|fieldName
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|?
name|key
else|:
name|fieldName
operator|+
literal|"."
operator|+
name|key
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|static
class|class
name|PartitionFieldNode
block|{
specifier|private
name|String
name|fieldName
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|PartitionFieldNode
argument_list|>
name|children
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
literal|4
argument_list|)
decl_stmt|;
specifier|private
name|boolean
name|isMultiValued
decl_stmt|;
specifier|private
name|int
name|fieldIndex
decl_stmt|;
name|PartitionFieldNode
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|this
operator|.
name|fieldName
operator|=
name|fieldName
expr_stmt|;
name|isMultiValued
operator|=
literal|false
expr_stmt|;
block|}
name|PartitionFieldNode
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|boolean
name|isMultiValued
parameter_list|)
block|{
name|this
operator|.
name|fieldName
operator|=
name|fieldName
expr_stmt|;
name|this
operator|.
name|isMultiValued
operator|=
name|isMultiValued
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
return|return
literal|false
return|;
name|PartitionFieldNode
name|that
init|=
operator|(
name|PartitionFieldNode
operator|)
name|o
decl_stmt|;
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|,
name|that
operator|.
name|fieldName
argument_list|)
return|;
block|}
name|boolean
name|isLeafNode
parameter_list|()
block|{
return|return
name|children
operator|==
literal|null
operator|||
name|children
operator|.
name|isEmpty
argument_list|()
return|;
block|}
name|void
name|setFieldIndex
parameter_list|(
name|int
name|fieldIndex
parameter_list|)
block|{
name|this
operator|.
name|fieldIndex
operator|=
name|fieldIndex
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
name|void
name|addChild
parameter_list|(
name|PartitionFieldNode
name|child
parameter_list|)
block|{
name|children
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
name|String
name|getFieldName
parameter_list|()
block|{
return|return
name|fieldName
return|;
block|}
annotation|@
name|VisibleForTesting
name|Set
argument_list|<
name|PartitionFieldNode
argument_list|>
name|getChildren
parameter_list|()
block|{
return|return
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|children
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
name|boolean
name|isMultiValued
parameter_list|()
block|{
return|return
name|isMultiValued
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|fieldName
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
name|void
name|setMultiValued
parameter_list|()
block|{
name|this
operator|.
name|isMultiValued
operator|=
literal|true
expr_stmt|;
block|}
block|}
specifier|private
interface|interface
name|MutivaluedFieldSetter
block|{
name|void
name|setValue
parameter_list|(
name|PartitionFieldNode
name|root
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
name|partitions
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sds
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|SerDeInfo
argument_list|>
name|serdes
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
name|cds
parameter_list|)
throws|throws
name|MetaException
function_decl|;
block|}
specifier|private
class|class
name|PartitionValuesSetter
implements|implements
name|MutivaluedFieldSetter
block|{
specifier|private
name|PartitionValuesSetter
parameter_list|()
block|{
comment|//
block|}
annotation|@
name|Override
specifier|public
name|void
name|setValue
parameter_list|(
name|PartitionFieldNode
name|root
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
name|partitions
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sds
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|SerDeInfo
argument_list|>
name|serdes
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
name|cds
parameter_list|)
throws|throws
name|MetaException
block|{
specifier|final
name|String
name|tableName
init|=
name|fieldNameToTableName
operator|.
name|containsKey
argument_list|(
literal|"PARTITION_KEY_VALS"
argument_list|)
condition|?
name|fieldNameToTableName
operator|.
name|get
argument_list|(
literal|"PARTITION_KEY_VALS"
argument_list|)
else|:
literal|"PARTITION_KEY_VALS"
decl_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|setPartitionValues
argument_list|(
name|tableName
argument_list|,
name|pm
argument_list|,
name|Joiner
operator|.
name|on
argument_list|(
literal|','
argument_list|)
operator|.
name|join
argument_list|(
name|partitions
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|,
name|partitions
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
class|class
name|PartitionParametersSetter
implements|implements
name|MutivaluedFieldSetter
block|{
specifier|private
name|PartitionParametersSetter
parameter_list|()
block|{
comment|//
block|}
annotation|@
name|Override
specifier|public
name|void
name|setValue
parameter_list|(
name|PartitionFieldNode
name|root
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
name|partitions
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sds
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|SerDeInfo
argument_list|>
name|serdes
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
name|cds
parameter_list|)
throws|throws
name|MetaException
block|{
name|MetastoreDirectSqlUtils
operator|.
name|setPartitionParametersWithFilter
argument_list|(
name|PARTITION_PARAMS
argument_list|,
name|convertMapNullsToEmptyStrings
argument_list|,
name|pm
argument_list|,
name|Joiner
operator|.
name|on
argument_list|(
literal|','
argument_list|)
operator|.
name|join
argument_list|(
name|partitions
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|,
name|partitions
argument_list|,
name|includeParamKeyPattern
argument_list|,
name|excludeParamKeyPattern
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
class|class
name|PartitionSDColsSetter
implements|implements
name|MutivaluedFieldSetter
block|{
specifier|private
name|PartitionSDColsSetter
parameter_list|()
block|{
comment|// prevent instantiation
block|}
annotation|@
name|Override
specifier|public
name|void
name|setValue
parameter_list|(
name|PartitionFieldNode
name|root
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
name|partitions
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sds
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|SerDeInfo
argument_list|>
name|serdes
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
name|cds
parameter_list|)
throws|throws
name|MetaException
block|{
comment|// find the fields which are requested for sd.cols
comment|// children field names would be sd.cols.name, sd.cols.type or sd.cols.description
name|List
argument_list|<
name|String
argument_list|>
name|childFields
init|=
name|getChildrenFieldNames
argument_list|(
name|root
argument_list|)
decl_stmt|;
specifier|final
name|String
name|tableName
init|=
name|fieldNameToTableName
operator|.
name|containsKey
argument_list|(
literal|"COLUMNS_V2"
argument_list|)
condition|?
name|fieldNameToTableName
operator|.
name|get
argument_list|(
literal|"COLUMNS_V2"
argument_list|)
else|:
literal|"COLUMNS_V2"
decl_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|setSDCols
argument_list|(
name|tableName
argument_list|,
name|childFields
argument_list|,
name|pm
argument_list|,
name|cds
argument_list|,
name|Joiner
operator|.
name|on
argument_list|(
literal|','
argument_list|)
operator|.
name|join
argument_list|(
name|cds
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
class|class
name|PartitionSDBucketColsSetter
implements|implements
name|MutivaluedFieldSetter
block|{
specifier|private
name|PartitionSDBucketColsSetter
parameter_list|()
block|{
comment|//
block|}
annotation|@
name|Override
specifier|public
name|void
name|setValue
parameter_list|(
name|PartitionFieldNode
name|root
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
name|partitions
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sds
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|SerDeInfo
argument_list|>
name|serdes
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
name|cds
parameter_list|)
throws|throws
name|MetaException
block|{
specifier|final
name|String
name|tableName
init|=
name|fieldNameToTableName
operator|.
name|containsKey
argument_list|(
literal|"BUCKETING_COLS"
argument_list|)
condition|?
name|fieldNameToTableName
operator|.
name|get
argument_list|(
literal|"BUCKETING_COLS"
argument_list|)
else|:
literal|"BUCKETING_COLS"
decl_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|setSDBucketCols
argument_list|(
name|tableName
argument_list|,
name|pm
argument_list|,
name|sds
argument_list|,
name|Joiner
operator|.
name|on
argument_list|(
literal|','
argument_list|)
operator|.
name|join
argument_list|(
name|sds
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
class|class
name|PartitionSortColsSetter
implements|implements
name|MutivaluedFieldSetter
block|{
specifier|private
name|PartitionSortColsSetter
parameter_list|()
block|{
comment|//
block|}
annotation|@
name|Override
specifier|public
name|void
name|setValue
parameter_list|(
name|PartitionFieldNode
name|root
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
name|partitions
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sds
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|SerDeInfo
argument_list|>
name|serdes
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
name|cds
parameter_list|)
throws|throws
name|MetaException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|childFieldNames
init|=
name|getChildrenFieldNames
argument_list|(
name|root
argument_list|)
decl_stmt|;
specifier|final
name|String
name|tableName
init|=
name|fieldNameToTableName
operator|.
name|containsKey
argument_list|(
literal|"SORT_COLS"
argument_list|)
condition|?
name|fieldNameToTableName
operator|.
name|get
argument_list|(
literal|"SORT_COLS"
argument_list|)
else|:
literal|"SORT_COLS"
decl_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|setSDSortCols
argument_list|(
name|tableName
argument_list|,
name|childFieldNames
argument_list|,
name|pm
argument_list|,
name|sds
argument_list|,
name|Joiner
operator|.
name|on
argument_list|(
literal|','
argument_list|)
operator|.
name|join
argument_list|(
name|sds
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getChildrenFieldNames
parameter_list|(
name|PartitionFieldNode
name|root
parameter_list|)
throws|throws
name|MetaException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|childFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
for|for
control|(
name|PartitionFieldNode
name|child
range|:
name|root
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|.
name|getFieldName
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
literal|"."
argument_list|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Error parsing multi-valued field name "
operator|+
name|child
operator|.
name|getFieldName
argument_list|()
argument_list|)
throw|;
block|}
name|childFields
operator|.
name|add
argument_list|(
name|child
operator|.
name|getFieldName
argument_list|()
operator|.
name|substring
argument_list|(
name|child
operator|.
name|getFieldName
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
literal|"."
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|childFields
return|;
block|}
specifier|private
class|class
name|PartitionSDParametersSetter
implements|implements
name|MutivaluedFieldSetter
block|{
specifier|private
name|PartitionSDParametersSetter
parameter_list|()
block|{
comment|//
block|}
annotation|@
name|Override
specifier|public
name|void
name|setValue
parameter_list|(
name|PartitionFieldNode
name|root
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
name|partitions
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sds
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|SerDeInfo
argument_list|>
name|serdes
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
name|cds
parameter_list|)
throws|throws
name|MetaException
block|{
specifier|final
name|String
name|tableName
init|=
name|fieldNameToTableName
operator|.
name|containsKey
argument_list|(
literal|"SD_PARAMS"
argument_list|)
condition|?
name|fieldNameToTableName
operator|.
name|get
argument_list|(
literal|"SD_PARAMS"
argument_list|)
else|:
literal|"SD_PARAMS"
decl_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|setSDParameters
argument_list|(
name|tableName
argument_list|,
name|convertMapNullsToEmptyStrings
argument_list|,
name|pm
argument_list|,
name|sds
argument_list|,
name|Joiner
operator|.
name|on
argument_list|(
literal|','
argument_list|)
operator|.
name|join
argument_list|(
name|sds
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
class|class
name|PartitionSerdeInfoParametersSetter
implements|implements
name|MutivaluedFieldSetter
block|{
specifier|private
name|PartitionSerdeInfoParametersSetter
parameter_list|()
block|{
comment|//
block|}
annotation|@
name|Override
specifier|public
name|void
name|setValue
parameter_list|(
name|PartitionFieldNode
name|root
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
name|partitions
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sds
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|SerDeInfo
argument_list|>
name|serdes
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
name|cds
parameter_list|)
throws|throws
name|MetaException
block|{
specifier|final
name|String
name|tableName
init|=
name|fieldNameToTableName
operator|.
name|containsKey
argument_list|(
literal|"SERDE_PARAMS"
argument_list|)
condition|?
name|fieldNameToTableName
operator|.
name|get
argument_list|(
literal|"SERDE_PARAMS"
argument_list|)
else|:
literal|"SERDE_PARAMS"
decl_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|setSerdeParams
argument_list|(
name|tableName
argument_list|,
name|convertMapNullsToEmptyStrings
argument_list|,
name|pm
argument_list|,
name|serdes
argument_list|,
name|Joiner
operator|.
name|on
argument_list|(
literal|','
argument_list|)
operator|.
name|join
argument_list|(
name|serdes
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
class|class
name|PartitionSkewedColsNamesSetter
implements|implements
name|MutivaluedFieldSetter
block|{
specifier|private
name|PartitionSkewedColsNamesSetter
parameter_list|()
block|{
comment|//
block|}
annotation|@
name|Override
specifier|public
name|void
name|setValue
parameter_list|(
name|PartitionFieldNode
name|root
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
name|partitions
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sds
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|SerDeInfo
argument_list|>
name|serdes
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
name|cds
parameter_list|)
throws|throws
name|MetaException
block|{
specifier|final
name|String
name|tableName
init|=
name|fieldNameToTableName
operator|.
name|containsKey
argument_list|(
literal|"SKEWED_COL_NAMES"
argument_list|)
condition|?
name|fieldNameToTableName
operator|.
name|get
argument_list|(
literal|"SKEWED_COL_NAMES"
argument_list|)
else|:
literal|"SKEWED_COL_NAMES"
decl_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|setSkewedColNames
argument_list|(
name|tableName
argument_list|,
name|pm
argument_list|,
name|sds
argument_list|,
name|Joiner
operator|.
name|on
argument_list|(
literal|','
argument_list|)
operator|.
name|join
argument_list|(
name|sds
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
class|class
name|PartitionSkewedColsValuesSetter
implements|implements
name|MutivaluedFieldSetter
block|{
specifier|private
name|PartitionSkewedColsValuesSetter
parameter_list|()
block|{
comment|//
block|}
annotation|@
name|Override
specifier|public
name|void
name|setValue
parameter_list|(
name|PartitionFieldNode
name|root
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
name|partitions
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sds
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|SerDeInfo
argument_list|>
name|serdes
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
name|cds
parameter_list|)
throws|throws
name|MetaException
block|{
specifier|final
name|String
name|skewedStringListVals
init|=
name|fieldNameToTableName
operator|.
name|containsKey
argument_list|(
literal|"SKEWED_STRING_LIST_VALUES"
argument_list|)
condition|?
name|fieldNameToTableName
operator|.
name|get
argument_list|(
literal|"SKEWED_STRING_LIST_VALUES"
argument_list|)
else|:
literal|"SKEWED_STRING_LIST_VALUES"
decl_stmt|;
specifier|final
name|String
name|skewedVals
init|=
name|fieldNameToTableName
operator|.
name|containsKey
argument_list|(
literal|"SKEWED_VALUES"
argument_list|)
condition|?
name|fieldNameToTableName
operator|.
name|get
argument_list|(
literal|"SKEWED_VALUES"
argument_list|)
else|:
literal|"SKEWED_VALUES"
decl_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|setSkewedColValues
argument_list|(
name|skewedStringListVals
argument_list|,
name|skewedVals
argument_list|,
name|pm
argument_list|,
name|sds
argument_list|,
name|Joiner
operator|.
name|on
argument_list|(
literal|','
argument_list|)
operator|.
name|join
argument_list|(
name|sds
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
class|class
name|PartitionSkewedColValLocationMapSetter
implements|implements
name|MutivaluedFieldSetter
block|{
specifier|private
name|PartitionSkewedColValLocationMapSetter
parameter_list|()
block|{
comment|//
block|}
annotation|@
name|Override
specifier|public
name|void
name|setValue
parameter_list|(
name|PartitionFieldNode
name|root
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
name|partitions
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sds
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|SerDeInfo
argument_list|>
name|serdes
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
name|cds
parameter_list|)
throws|throws
name|MetaException
block|{
specifier|final
name|String
name|skewedStringListVals
init|=
name|fieldNameToTableName
operator|.
name|containsKey
argument_list|(
literal|"SKEWED_STRING_LIST_VALUES"
argument_list|)
condition|?
name|fieldNameToTableName
operator|.
name|get
argument_list|(
literal|"SKEWED_STRING_LIST_VALUES"
argument_list|)
else|:
literal|"SKEWED_STRING_LIST_VALUES"
decl_stmt|;
specifier|final
name|String
name|skewedColValLocMap
init|=
name|fieldNameToTableName
operator|.
name|containsKey
argument_list|(
literal|"SKEWED_COL_VALUE_LOC_MAP"
argument_list|)
condition|?
name|fieldNameToTableName
operator|.
name|get
argument_list|(
literal|"SKEWED_COL_VALUE_LOC_MAP"
argument_list|)
else|:
literal|"SKEWED_COL_VALUE_LOC_MAP"
decl_stmt|;
name|MetastoreDirectSqlUtils
operator|.
name|setSkewedColLocationMaps
argument_list|(
name|skewedColValLocMap
argument_list|,
name|skewedStringListVals
argument_list|,
name|pm
argument_list|,
name|sds
argument_list|,
name|Joiner
operator|.
name|on
argument_list|(
literal|','
argument_list|)
operator|.
name|join
argument_list|(
name|sds
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Given a list of partition fields, checks if all the fields requested are single-valued. If all    * the fields are single-valued returns list of equivalent MPartition fieldnames    * which can be used in the setResult clause of a JDO query    *    * @param partitionFields List of partitionFields in the projection    * @return List of JDO field names which can be used in setResult clause    * of a JDO query. Returns null if input partitionFields cannot be used in a setResult clause    */
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|getMPartitionFieldNames
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|partitionFields
parameter_list|)
throws|throws
name|MetaException
block|{
comment|// if there are no partitionFields requested, it means all the fields are requested which include
comment|// multi-valued fields.
if|if
condition|(
name|partitionFields
operator|==
literal|null
operator|||
name|partitionFields
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// throw exception if there are invalid field names
name|PartitionProjectionEvaluator
operator|.
name|validate
argument_list|(
name|partitionFields
argument_list|)
expr_stmt|;
comment|// else, check if all the fields are single-valued. In case there are multi-valued fields requested
comment|// return null since setResult in JDO doesn't support multi-valued fields
if|if
condition|(
operator|!
name|allPartitionSingleValuedFields
operator|.
name|keySet
argument_list|()
operator|.
name|containsAll
argument_list|(
name|partitionFields
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|jdoFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|partitionFields
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|partitionField
range|:
name|partitionFields
control|)
block|{
name|jdoFields
operator|.
name|add
argument_list|(
name|allPartitionSingleValuedFields
operator|.
name|get
argument_list|(
name|partitionField
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|jdoFields
return|;
block|}
block|}
end_class

end_unit

