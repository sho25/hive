begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  *  Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *       http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|BooleanUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|MetaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Order
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Partition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SerDeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SkewedInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|StorageDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|utils
operator|.
name|MetaStoreServerUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|utils
operator|.
name|MetaStoreUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jdo
operator|.
name|PersistenceManager
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jdo
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Blob
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Clob
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_comment
comment|/**  * Helper utilities used by DirectSQL code in HiveMetastore.  */
end_comment

begin_class
class|class
name|MetastoreDirectSqlUtils
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MetastoreDirectSqlUtils
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|MetastoreDirectSqlUtils
parameter_list|()
block|{    }
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|executeWithArray
parameter_list|(
name|Query
name|query
parameter_list|,
name|Object
index|[]
name|params
parameter_list|,
name|String
name|sql
parameter_list|)
throws|throws
name|MetaException
block|{
return|return
operator|(
name|T
operator|)
name|executeWithArray
argument_list|(
name|query
argument_list|,
name|params
argument_list|,
name|sql
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|executeWithArray
parameter_list|(
name|Query
name|query
parameter_list|,
name|Object
index|[]
name|params
parameter_list|,
name|String
name|sql
parameter_list|,
name|int
name|limit
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
if|if
condition|(
name|limit
operator|>=
literal|0
condition|)
name|query
operator|.
name|setRange
argument_list|(
literal|0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
return|return
call|(
name|T
call|)
argument_list|(
operator|(
name|params
operator|==
literal|null
operator|)
condition|?
name|query
operator|.
name|execute
argument_list|()
else|:
name|query
operator|.
name|executeWithArray
argument_list|(
name|params
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|StringBuilder
name|errorBuilder
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"Failed to execute ["
operator|+
name|sql
operator|+
literal|"] with parameters ["
argument_list|)
decl_stmt|;
if|if
condition|(
name|params
operator|!=
literal|null
condition|)
block|{
name|boolean
name|isFirst
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Object
name|param
range|:
name|params
control|)
block|{
name|errorBuilder
operator|.
name|append
argument_list|(
operator|(
name|isFirst
condition|?
literal|""
else|:
literal|", "
operator|)
operator|+
name|param
argument_list|)
expr_stmt|;
name|isFirst
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|warn
argument_list|(
name|errorBuilder
operator|.
name|toString
argument_list|()
operator|+
literal|"]"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
comment|// We just logged an exception with (in case of JDO) a humongous callstack. Make a new one.
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"See previous errors; "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|static
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|ensureList
parameter_list|(
name|Object
name|result
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
operator|!
operator|(
name|result
operator|instanceof
name|List
argument_list|<
name|?
argument_list|>
operator|)
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Wrong result type "
operator|+
name|result
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
return|return
operator|(
name|List
argument_list|<
name|Object
index|[]
argument_list|>
operator|)
name|result
return|;
block|}
specifier|static
name|Long
name|extractSqlLong
parameter_list|(
name|Object
name|obj
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|Number
operator|)
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Expected numeric type but got "
operator|+
name|obj
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
return|return
operator|(
operator|(
name|Number
operator|)
name|obj
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
specifier|static
name|void
name|timingTrace
parameter_list|(
name|boolean
name|doTrace
parameter_list|,
name|String
name|queryText
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|queryTime
parameter_list|)
block|{
if|if
condition|(
operator|!
name|doTrace
condition|)
return|return;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Direct SQL query in "
operator|+
operator|(
name|queryTime
operator|-
name|start
operator|)
operator|/
literal|1000000.0
operator|+
literal|"ms + "
operator|+
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|queryTime
operator|)
operator|/
literal|1000000.0
operator|+
literal|"ms, the query is ["
operator|+
name|queryText
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
specifier|static
parameter_list|<
name|T
parameter_list|>
name|int
name|loopJoinOrderedResult
parameter_list|(
name|PersistenceManager
name|pm
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|T
argument_list|>
name|tree
parameter_list|,
name|String
name|queryText
parameter_list|,
name|int
name|keyIndex
parameter_list|,
name|ApplyFunc
argument_list|<
name|T
argument_list|>
name|func
parameter_list|)
throws|throws
name|MetaException
block|{
return|return
name|loopJoinOrderedResult
argument_list|(
name|pm
argument_list|,
name|tree
argument_list|,
name|queryText
argument_list|,
literal|null
argument_list|,
name|keyIndex
argument_list|,
name|func
argument_list|)
return|;
block|}
comment|/**    * Merges applies the result of a PM SQL query into a tree of object.    * Essentially it's an object join. DN could do this for us, but it issues queries    * separately for every object, which is suboptimal.    * @param pm    * @param tree The object tree, by ID.    * @param queryText The query text.    * @param keyIndex Index of the Long column corresponding to the map ID in query result rows.    * @param func The function that is called on each (object,row) pair with the same id.    * @return the count of results returned from the query.    */
specifier|static
parameter_list|<
name|T
parameter_list|>
name|int
name|loopJoinOrderedResult
parameter_list|(
name|PersistenceManager
name|pm
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|T
argument_list|>
name|tree
parameter_list|,
name|String
name|queryText
parameter_list|,
name|Object
index|[]
name|parameters
parameter_list|,
name|int
name|keyIndex
parameter_list|,
name|ApplyFunc
argument_list|<
name|T
argument_list|>
name|func
parameter_list|)
throws|throws
name|MetaException
block|{
name|boolean
name|doTrace
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
name|long
name|start
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|Query
name|query
init|=
name|pm
operator|.
name|newQuery
argument_list|(
literal|"javax.jdo.query.SQL"
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
name|Object
name|result
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|parameters
operator|==
literal|null
operator|||
name|parameters
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|query
operator|.
name|execute
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|query
operator|.
name|executeWithArray
argument_list|(
name|parameters
argument_list|)
expr_stmt|;
block|}
name|long
name|queryTime
init|=
name|doTrace
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|list
init|=
name|ensureList
argument_list|(
name|result
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Object
index|[]
argument_list|>
name|iter
init|=
name|list
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Object
index|[]
name|fields
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|T
argument_list|>
name|entry
range|:
name|tree
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|fields
operator|==
literal|null
operator|&&
operator|!
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
break|break;
name|long
name|id
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
while|while
condition|(
name|fields
operator|!=
literal|null
operator|||
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
name|fields
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
name|long
name|nestedId
init|=
name|extractSqlLong
argument_list|(
name|fields
index|[
name|keyIndex
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|nestedId
operator|<
name|id
condition|)
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Found entries for unknown ID "
operator|+
name|nestedId
argument_list|)
throw|;
if|if
condition|(
name|nestedId
operator|>
name|id
condition|)
break|break;
comment|// fields belong to one of the next entries
name|func
operator|.
name|apply
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|fields
argument_list|)
expr_stmt|;
name|fields
operator|=
literal|null
expr_stmt|;
block|}
name|Deadline
operator|.
name|checkTimeout
argument_list|()
expr_stmt|;
block|}
name|int
name|rv
init|=
name|list
operator|.
name|size
argument_list|()
decl_stmt|;
name|query
operator|.
name|closeAll
argument_list|()
expr_stmt|;
name|timingTrace
argument_list|(
name|doTrace
argument_list|,
name|queryText
argument_list|,
name|start
argument_list|,
name|queryTime
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
specifier|static
name|void
name|setPartitionParameters
parameter_list|(
name|String
name|PARTITION_PARAMS
parameter_list|,
name|boolean
name|convertMapNullsToEmptyStrings
parameter_list|,
name|PersistenceManager
name|pm
parameter_list|,
name|String
name|partIds
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
name|partitions
parameter_list|)
throws|throws
name|MetaException
block|{
name|String
name|queryText
decl_stmt|;
name|queryText
operator|=
literal|"select \"PART_ID\", \"PARAM_KEY\", \"PARAM_VALUE\" from "
operator|+
name|PARTITION_PARAMS
operator|+
literal|""
operator|+
literal|" where \"PART_ID\" in ("
operator|+
name|partIds
operator|+
literal|") and \"PARAM_KEY\" is not null"
operator|+
literal|" order by \"PART_ID\" asc"
expr_stmt|;
name|loopJoinOrderedResult
argument_list|(
name|pm
argument_list|,
name|partitions
argument_list|,
name|queryText
argument_list|,
literal|0
argument_list|,
operator|new
name|ApplyFunc
argument_list|<
name|Partition
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|Partition
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
block|{
name|t
operator|.
name|putToParameters
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|1
index|]
argument_list|,
name|extractSqlClob
argument_list|(
name|fields
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Perform conversion of null map values
for|for
control|(
name|Partition
name|t
range|:
name|partitions
operator|.
name|values
argument_list|()
control|)
block|{
name|t
operator|.
name|setParameters
argument_list|(
name|MetaStoreServerUtils
operator|.
name|trimMapNulls
argument_list|(
name|t
operator|.
name|getParameters
argument_list|()
argument_list|,
name|convertMapNullsToEmptyStrings
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|setPartitionParametersWithFilter
parameter_list|(
name|String
name|PARTITION_PARAMS
parameter_list|,
name|boolean
name|convertMapNullsToEmptyStrings
parameter_list|,
name|PersistenceManager
name|pm
parameter_list|,
name|String
name|partIds
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
name|partitions
parameter_list|,
name|String
name|includeParamKeyPattern
parameter_list|,
name|String
name|excludeParamKeyPattern
parameter_list|)
throws|throws
name|MetaException
block|{
name|StringBuilder
name|queryTextBuilder
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"select \"PART_ID\", \"PARAM_KEY\", \"PARAM_VALUE\" from "
argument_list|)
operator|.
name|append
argument_list|(
name|PARTITION_PARAMS
argument_list|)
operator|.
name|append
argument_list|(
literal|" where \"PART_ID\" in ("
argument_list|)
operator|.
name|append
argument_list|(
name|partIds
argument_list|)
operator|.
name|append
argument_list|(
literal|") and \"PARAM_KEY\" is not null"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|queryParams
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
empty_stmt|;
if|if
condition|(
name|includeParamKeyPattern
operator|!=
literal|null
operator|&&
operator|!
name|includeParamKeyPattern
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|queryTextBuilder
operator|.
name|append
argument_list|(
literal|" and \"PARAM_KEY\" LIKE (?)"
argument_list|)
expr_stmt|;
name|queryParams
operator|.
name|add
argument_list|(
name|includeParamKeyPattern
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|excludeParamKeyPattern
operator|!=
literal|null
operator|&&
operator|!
name|excludeParamKeyPattern
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|queryTextBuilder
operator|.
name|append
argument_list|(
literal|" and \"PARAM_KEY\" NOT LIKE (?)"
argument_list|)
expr_stmt|;
name|queryParams
operator|.
name|add
argument_list|(
name|excludeParamKeyPattern
argument_list|)
expr_stmt|;
block|}
name|queryTextBuilder
operator|.
name|append
argument_list|(
literal|" order by \"PART_ID\" asc"
argument_list|)
expr_stmt|;
name|String
name|queryText
init|=
name|queryTextBuilder
operator|.
name|toString
argument_list|()
decl_stmt|;
name|loopJoinOrderedResult
argument_list|(
name|pm
argument_list|,
name|partitions
argument_list|,
name|queryText
argument_list|,
name|queryParams
operator|.
name|toArray
argument_list|()
argument_list|,
literal|0
argument_list|,
operator|new
name|ApplyFunc
argument_list|<
name|Partition
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|Partition
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
block|{
name|t
operator|.
name|putToParameters
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|1
index|]
argument_list|,
name|extractSqlClob
argument_list|(
name|fields
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Perform conversion of null map values
for|for
control|(
name|Partition
name|t
range|:
name|partitions
operator|.
name|values
argument_list|()
control|)
block|{
name|t
operator|.
name|setParameters
argument_list|(
name|MetaStoreServerUtils
operator|.
name|trimMapNulls
argument_list|(
name|t
operator|.
name|getParameters
argument_list|()
argument_list|,
name|convertMapNullsToEmptyStrings
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|setPartitionValues
parameter_list|(
name|String
name|PARTITION_KEY_VALS
parameter_list|,
name|PersistenceManager
name|pm
parameter_list|,
name|String
name|partIds
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Partition
argument_list|>
name|partitions
parameter_list|)
throws|throws
name|MetaException
block|{
name|String
name|queryText
decl_stmt|;
name|queryText
operator|=
literal|"select \"PART_ID\", \"PART_KEY_VAL\" from "
operator|+
name|PARTITION_KEY_VALS
operator|+
literal|""
operator|+
literal|" where \"PART_ID\" in ("
operator|+
name|partIds
operator|+
literal|")"
operator|+
literal|" order by \"PART_ID\" asc, \"INTEGER_IDX\" asc"
expr_stmt|;
name|loopJoinOrderedResult
argument_list|(
name|pm
argument_list|,
name|partitions
argument_list|,
name|queryText
argument_list|,
literal|0
argument_list|,
operator|new
name|ApplyFunc
argument_list|<
name|Partition
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|Partition
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
block|{
name|t
operator|.
name|addToValues
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|static
name|String
name|extractSqlClob
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
return|return
literal|null
return|;
try|try
block|{
if|if
condition|(
name|value
operator|instanceof
name|Clob
condition|)
block|{
comment|// we trim the Clob value to a max length an int can hold
name|int
name|maxLength
init|=
operator|(
operator|(
operator|(
name|Clob
operator|)
name|value
operator|)
operator|.
name|length
argument_list|()
operator|<
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|2
operator|)
condition|?
call|(
name|int
call|)
argument_list|(
operator|(
name|Clob
operator|)
name|value
argument_list|)
operator|.
name|length
argument_list|()
else|:
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|2
decl_stmt|;
return|return
operator|(
operator|(
name|Clob
operator|)
name|value
operator|)
operator|.
name|getSubString
argument_list|(
literal|1L
argument_list|,
name|maxLength
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|value
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|sqle
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|static
name|void
name|setSDParameters
parameter_list|(
name|String
name|SD_PARAMS
parameter_list|,
name|boolean
name|convertMapNullsToEmptyStrings
parameter_list|,
name|PersistenceManager
name|pm
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sds
parameter_list|,
name|String
name|sdIds
parameter_list|)
throws|throws
name|MetaException
block|{
name|String
name|queryText
decl_stmt|;
name|queryText
operator|=
literal|"select \"SD_ID\", \"PARAM_KEY\", \"PARAM_VALUE\" from "
operator|+
name|SD_PARAMS
operator|+
literal|""
operator|+
literal|" where \"SD_ID\" in ("
operator|+
name|sdIds
operator|+
literal|") and \"PARAM_KEY\" is not null"
operator|+
literal|" order by \"SD_ID\" asc"
expr_stmt|;
name|loopJoinOrderedResult
argument_list|(
name|pm
argument_list|,
name|sds
argument_list|,
name|queryText
argument_list|,
literal|0
argument_list|,
operator|new
name|ApplyFunc
argument_list|<
name|StorageDescriptor
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|StorageDescriptor
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
block|{
name|t
operator|.
name|putToParameters
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|1
index|]
argument_list|,
name|extractSqlClob
argument_list|(
name|fields
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Perform conversion of null map values
for|for
control|(
name|StorageDescriptor
name|t
range|:
name|sds
operator|.
name|values
argument_list|()
control|)
block|{
name|t
operator|.
name|setParameters
argument_list|(
name|MetaStoreServerUtils
operator|.
name|trimMapNulls
argument_list|(
name|t
operator|.
name|getParameters
argument_list|()
argument_list|,
name|convertMapNullsToEmptyStrings
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|int
name|extractSqlInt
parameter_list|(
name|Object
name|field
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|field
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
specifier|static
name|void
name|setSDSortCols
parameter_list|(
name|String
name|SORT_COLS
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|columnNames
parameter_list|,
name|PersistenceManager
name|pm
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sds
parameter_list|,
name|String
name|sdIds
parameter_list|)
throws|throws
name|MetaException
block|{
name|StringBuilder
name|queryTextBuilder
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"select \"SD_ID\""
argument_list|)
decl_stmt|;
name|int
name|counter
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|columnNames
operator|.
name|contains
argument_list|(
literal|"col"
argument_list|)
condition|)
block|{
name|counter
operator|++
expr_stmt|;
name|queryTextBuilder
operator|.
name|append
argument_list|(
literal|", \"COLUMN_NAME\""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|columnNames
operator|.
name|contains
argument_list|(
literal|"order"
argument_list|)
condition|)
block|{
name|counter
operator|++
expr_stmt|;
name|queryTextBuilder
operator|.
name|append
argument_list|(
literal|", \"ORDER\""
argument_list|)
expr_stmt|;
block|}
name|queryTextBuilder
operator|.
name|append
argument_list|(
literal|" from "
argument_list|)
operator|.
name|append
argument_list|(
name|SORT_COLS
argument_list|)
operator|.
name|append
argument_list|(
literal|" where \"SD_ID\" in ("
argument_list|)
operator|.
name|append
argument_list|(
name|sdIds
argument_list|)
operator|.
name|append
argument_list|(
literal|") order by \"SD_ID\" asc, \"INTEGER_IDX\" asc"
argument_list|)
expr_stmt|;
name|String
name|queryText
init|=
name|queryTextBuilder
operator|.
name|toString
argument_list|()
decl_stmt|;
specifier|final
name|int
name|finalCounter
init|=
name|counter
decl_stmt|;
name|loopJoinOrderedResult
argument_list|(
name|pm
argument_list|,
name|sds
argument_list|,
name|queryText
argument_list|,
literal|0
argument_list|,
operator|new
name|ApplyFunc
argument_list|<
name|StorageDescriptor
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|StorageDescriptor
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
block|{
if|if
condition|(
name|finalCounter
operator|>
literal|1
operator|&&
name|fields
index|[
literal|2
index|]
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|Order
name|order
init|=
operator|new
name|Order
argument_list|()
decl_stmt|;
if|if
condition|(
name|finalCounter
operator|>
literal|0
condition|)
block|{
name|order
operator|.
name|setCol
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|finalCounter
operator|>
literal|1
condition|)
block|{
name|order
operator|.
name|setOrder
argument_list|(
name|extractSqlInt
argument_list|(
name|fields
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|t
operator|.
name|addToSortCols
argument_list|(
name|order
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|setSDSortCols
parameter_list|(
name|String
name|SORT_COLS
parameter_list|,
name|PersistenceManager
name|pm
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sds
parameter_list|,
name|String
name|sdIds
parameter_list|)
throws|throws
name|MetaException
block|{
name|String
name|queryText
decl_stmt|;
name|queryText
operator|=
literal|"select \"SD_ID\", \"COLUMN_NAME\", "
operator|+
name|SORT_COLS
operator|+
literal|".\"ORDER\""
operator|+
literal|" from "
operator|+
name|SORT_COLS
operator|+
literal|""
operator|+
literal|" where \"SD_ID\" in ("
operator|+
name|sdIds
operator|+
literal|")"
operator|+
literal|" order by \"SD_ID\" asc, \"INTEGER_IDX\" asc"
expr_stmt|;
name|loopJoinOrderedResult
argument_list|(
name|pm
argument_list|,
name|sds
argument_list|,
name|queryText
argument_list|,
literal|0
argument_list|,
operator|new
name|ApplyFunc
argument_list|<
name|StorageDescriptor
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|StorageDescriptor
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
block|{
if|if
condition|(
name|fields
index|[
literal|2
index|]
operator|==
literal|null
condition|)
return|return;
name|t
operator|.
name|addToSortCols
argument_list|(
operator|new
name|Order
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|1
index|]
argument_list|,
name|extractSqlInt
argument_list|(
name|fields
index|[
literal|2
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|setSDBucketCols
parameter_list|(
name|String
name|BUCKETING_COLS
parameter_list|,
name|PersistenceManager
name|pm
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sds
parameter_list|,
name|String
name|sdIds
parameter_list|)
throws|throws
name|MetaException
block|{
name|String
name|queryText
decl_stmt|;
name|queryText
operator|=
literal|"select \"SD_ID\", \"BUCKET_COL_NAME\" from "
operator|+
name|BUCKETING_COLS
operator|+
literal|""
operator|+
literal|" where \"SD_ID\" in ("
operator|+
name|sdIds
operator|+
literal|")"
operator|+
literal|" order by \"SD_ID\" asc, \"INTEGER_IDX\" asc"
expr_stmt|;
name|loopJoinOrderedResult
argument_list|(
name|pm
argument_list|,
name|sds
argument_list|,
name|queryText
argument_list|,
literal|0
argument_list|,
operator|new
name|ApplyFunc
argument_list|<
name|StorageDescriptor
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|StorageDescriptor
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
block|{
name|t
operator|.
name|addToBucketCols
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|static
name|boolean
name|setSkewedColNames
parameter_list|(
name|String
name|SKEWED_COL_NAMES
parameter_list|,
name|PersistenceManager
name|pm
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sds
parameter_list|,
name|String
name|sdIds
parameter_list|)
throws|throws
name|MetaException
block|{
name|String
name|queryText
decl_stmt|;
name|queryText
operator|=
literal|"select \"SD_ID\", \"SKEWED_COL_NAME\" from "
operator|+
name|SKEWED_COL_NAMES
operator|+
literal|""
operator|+
literal|" where \"SD_ID\" in ("
operator|+
name|sdIds
operator|+
literal|")"
operator|+
literal|" order by \"SD_ID\" asc, \"INTEGER_IDX\" asc"
expr_stmt|;
return|return
name|loopJoinOrderedResult
argument_list|(
name|pm
argument_list|,
name|sds
argument_list|,
name|queryText
argument_list|,
literal|0
argument_list|,
operator|new
name|ApplyFunc
argument_list|<
name|StorageDescriptor
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|StorageDescriptor
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
block|{
if|if
condition|(
operator|!
name|t
operator|.
name|isSetSkewedInfo
argument_list|()
condition|)
name|t
operator|.
name|setSkewedInfo
argument_list|(
operator|new
name|SkewedInfo
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|getSkewedInfo
argument_list|()
operator|.
name|addToSkewedColNames
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
operator|>
literal|0
return|;
block|}
specifier|static
name|void
name|setSkewedColValues
parameter_list|(
name|String
name|SKEWED_STRING_LIST_VALUES
parameter_list|,
name|String
name|SKEWED_VALUES
parameter_list|,
name|PersistenceManager
name|pm
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sds
parameter_list|,
name|String
name|sdIds
parameter_list|)
throws|throws
name|MetaException
block|{
name|String
name|queryText
decl_stmt|;
name|queryText
operator|=
literal|"select "
operator|+
name|SKEWED_VALUES
operator|+
literal|".\"SD_ID_OID\","
operator|+
literal|"  "
operator|+
name|SKEWED_STRING_LIST_VALUES
operator|+
literal|".\"STRING_LIST_ID\","
operator|+
literal|"  "
operator|+
name|SKEWED_STRING_LIST_VALUES
operator|+
literal|".\"STRING_LIST_VALUE\" "
operator|+
literal|"from "
operator|+
name|SKEWED_VALUES
operator|+
literal|" "
operator|+
literal|"  left outer join "
operator|+
name|SKEWED_STRING_LIST_VALUES
operator|+
literal|" on "
operator|+
name|SKEWED_VALUES
operator|+
literal|"."
operator|+
literal|"\"STRING_LIST_ID_EID\" = "
operator|+
name|SKEWED_STRING_LIST_VALUES
operator|+
literal|".\"STRING_LIST_ID\" "
operator|+
literal|"where "
operator|+
name|SKEWED_VALUES
operator|+
literal|".\"SD_ID_OID\" in ("
operator|+
name|sdIds
operator|+
literal|") "
operator|+
literal|"  and "
operator|+
name|SKEWED_VALUES
operator|+
literal|".\"STRING_LIST_ID_EID\" is not null "
operator|+
literal|"  and "
operator|+
name|SKEWED_VALUES
operator|+
literal|".\"INTEGER_IDX\">= 0 "
operator|+
literal|"order by "
operator|+
name|SKEWED_VALUES
operator|+
literal|".\"SD_ID_OID\" asc, "
operator|+
name|SKEWED_VALUES
operator|+
literal|".\"INTEGER_IDX\" asc,"
operator|+
literal|"  "
operator|+
name|SKEWED_STRING_LIST_VALUES
operator|+
literal|".\"INTEGER_IDX\" asc"
expr_stmt|;
name|loopJoinOrderedResult
argument_list|(
name|pm
argument_list|,
name|sds
argument_list|,
name|queryText
argument_list|,
literal|0
argument_list|,
operator|new
name|ApplyFunc
argument_list|<
name|StorageDescriptor
argument_list|>
argument_list|()
block|{
specifier|private
name|Long
name|currentListId
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|currentList
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|StorageDescriptor
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
operator|!
name|t
operator|.
name|isSetSkewedInfo
argument_list|()
condition|)
name|t
operator|.
name|setSkewedInfo
argument_list|(
operator|new
name|SkewedInfo
argument_list|()
argument_list|)
expr_stmt|;
comment|// Note that this is not a typical list accumulator - there's no call to finalize
comment|// the last list. Instead we add list to SD first, as well as locally to add elements.
if|if
condition|(
name|fields
index|[
literal|1
index|]
operator|==
literal|null
condition|)
block|{
name|currentList
operator|=
literal|null
expr_stmt|;
comment|// left outer join produced a list with no values
name|currentListId
operator|=
literal|null
expr_stmt|;
name|t
operator|.
name|getSkewedInfo
argument_list|()
operator|.
name|addToSkewedColValues
argument_list|(
name|Collections
operator|.
expr|<
name|String
operator|>
name|emptyList
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|long
name|fieldsListId
init|=
name|extractSqlLong
argument_list|(
name|fields
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentListId
operator|==
literal|null
operator|||
name|fieldsListId
operator|!=
name|currentListId
condition|)
block|{
name|currentList
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|currentListId
operator|=
name|fieldsListId
expr_stmt|;
name|t
operator|.
name|getSkewedInfo
argument_list|()
operator|.
name|addToSkewedColValues
argument_list|(
name|currentList
argument_list|)
expr_stmt|;
block|}
name|currentList
operator|.
name|add
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|setSkewedColLocationMaps
parameter_list|(
name|String
name|SKEWED_COL_VALUE_LOC_MAP
parameter_list|,
name|String
name|SKEWED_STRING_LIST_VALUES
parameter_list|,
name|PersistenceManager
name|pm
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|StorageDescriptor
argument_list|>
name|sds
parameter_list|,
name|String
name|sdIds
parameter_list|)
throws|throws
name|MetaException
block|{
name|String
name|queryText
decl_stmt|;
name|queryText
operator|=
literal|"select "
operator|+
name|SKEWED_COL_VALUE_LOC_MAP
operator|+
literal|".\"SD_ID\","
operator|+
literal|" "
operator|+
name|SKEWED_STRING_LIST_VALUES
operator|+
literal|".STRING_LIST_ID,"
operator|+
literal|" "
operator|+
name|SKEWED_COL_VALUE_LOC_MAP
operator|+
literal|".\"LOCATION\","
operator|+
literal|" "
operator|+
name|SKEWED_STRING_LIST_VALUES
operator|+
literal|".\"STRING_LIST_VALUE\" "
operator|+
literal|"from "
operator|+
name|SKEWED_COL_VALUE_LOC_MAP
operator|+
literal|""
operator|+
literal|"  left outer join "
operator|+
name|SKEWED_STRING_LIST_VALUES
operator|+
literal|" on "
operator|+
name|SKEWED_COL_VALUE_LOC_MAP
operator|+
literal|"."
operator|+
literal|"\"STRING_LIST_ID_KID\" = "
operator|+
name|SKEWED_STRING_LIST_VALUES
operator|+
literal|".\"STRING_LIST_ID\" "
operator|+
literal|"where "
operator|+
name|SKEWED_COL_VALUE_LOC_MAP
operator|+
literal|".\"SD_ID\" in ("
operator|+
name|sdIds
operator|+
literal|")"
operator|+
literal|"  and "
operator|+
name|SKEWED_COL_VALUE_LOC_MAP
operator|+
literal|".\"STRING_LIST_ID_KID\" is not null "
operator|+
literal|"order by "
operator|+
name|SKEWED_COL_VALUE_LOC_MAP
operator|+
literal|".\"SD_ID\" asc,"
operator|+
literal|"  "
operator|+
name|SKEWED_STRING_LIST_VALUES
operator|+
literal|".\"STRING_LIST_ID\" asc,"
operator|+
literal|"  "
operator|+
name|SKEWED_STRING_LIST_VALUES
operator|+
literal|".\"INTEGER_IDX\" asc"
expr_stmt|;
name|loopJoinOrderedResult
argument_list|(
name|pm
argument_list|,
name|sds
argument_list|,
name|queryText
argument_list|,
literal|0
argument_list|,
operator|new
name|ApplyFunc
argument_list|<
name|StorageDescriptor
argument_list|>
argument_list|()
block|{
specifier|private
name|Long
name|currentListId
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|currentList
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|StorageDescriptor
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
operator|!
name|t
operator|.
name|isSetSkewedInfo
argument_list|()
condition|)
block|{
name|SkewedInfo
name|skewedInfo
init|=
operator|new
name|SkewedInfo
argument_list|()
decl_stmt|;
name|skewedInfo
operator|.
name|setSkewedColValueLocationMaps
argument_list|(
operator|new
name|HashMap
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|setSkewedInfo
argument_list|(
name|skewedInfo
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|String
argument_list|>
name|skewMap
init|=
name|t
operator|.
name|getSkewedInfo
argument_list|()
operator|.
name|getSkewedColValueLocationMaps
argument_list|()
decl_stmt|;
comment|// Note that this is not a typical list accumulator - there's no call to finalize
comment|// the last list. Instead we add list to SD first, as well as locally to add elements.
if|if
condition|(
name|fields
index|[
literal|1
index|]
operator|==
literal|null
condition|)
block|{
name|currentList
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
comment|// left outer join produced a list with no values
name|currentListId
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|long
name|fieldsListId
init|=
name|extractSqlLong
argument_list|(
name|fields
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentListId
operator|==
literal|null
operator|||
name|fieldsListId
operator|!=
name|currentListId
condition|)
block|{
name|currentList
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|currentListId
operator|=
name|fieldsListId
expr_stmt|;
block|}
else|else
block|{
name|skewMap
operator|.
name|remove
argument_list|(
name|currentList
argument_list|)
expr_stmt|;
comment|// value based compare.. remove first
block|}
name|currentList
operator|.
name|add
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
name|skewMap
operator|.
name|put
argument_list|(
name|currentList
argument_list|,
operator|(
name|String
operator|)
name|fields
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|setSDCols
parameter_list|(
name|String
name|COLUMNS_V2
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|columnNames
parameter_list|,
name|PersistenceManager
name|pm
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
name|colss
parameter_list|,
name|String
name|colIds
parameter_list|)
throws|throws
name|MetaException
block|{
name|StringBuilder
name|queryTextBuilder
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"select \"CD_ID\""
argument_list|)
decl_stmt|;
name|int
name|counter
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|columnNames
operator|.
name|contains
argument_list|(
literal|"name"
argument_list|)
condition|)
block|{
name|counter
operator|++
expr_stmt|;
name|queryTextBuilder
operator|.
name|append
argument_list|(
literal|", \"COLUMN_NAME\""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|columnNames
operator|.
name|contains
argument_list|(
literal|"type"
argument_list|)
condition|)
block|{
name|counter
operator|++
expr_stmt|;
name|queryTextBuilder
operator|.
name|append
argument_list|(
literal|", \"TYPE_NAME\""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|columnNames
operator|.
name|contains
argument_list|(
literal|"comment"
argument_list|)
condition|)
block|{
name|counter
operator|++
expr_stmt|;
name|queryTextBuilder
operator|.
name|append
argument_list|(
literal|", \"COMMENT\""
argument_list|)
expr_stmt|;
block|}
name|queryTextBuilder
operator|.
name|append
argument_list|(
literal|" from "
argument_list|)
operator|.
name|append
argument_list|(
name|COLUMNS_V2
argument_list|)
operator|.
name|append
argument_list|(
literal|" where \"CD_ID\" in ("
argument_list|)
operator|.
name|append
argument_list|(
name|colIds
argument_list|)
operator|.
name|append
argument_list|(
literal|") order by \"CD_ID\" asc, \"INTEGER_IDX\" asc"
argument_list|)
expr_stmt|;
name|String
name|queryText
init|=
name|queryTextBuilder
operator|.
name|toString
argument_list|()
decl_stmt|;
name|int
name|finalCounter
init|=
name|counter
decl_stmt|;
name|loopJoinOrderedResult
argument_list|(
name|pm
argument_list|,
name|colss
argument_list|,
name|queryText
argument_list|,
literal|0
argument_list|,
operator|new
name|ApplyFunc
argument_list|<
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
block|{
name|FieldSchema
name|fieldSchema
init|=
operator|new
name|FieldSchema
argument_list|()
decl_stmt|;
if|if
condition|(
name|finalCounter
operator|>
literal|0
condition|)
block|{
name|fieldSchema
operator|.
name|setName
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|finalCounter
operator|>
literal|1
condition|)
block|{
name|fieldSchema
operator|.
name|setType
argument_list|(
name|extractSqlClob
argument_list|(
name|fields
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|finalCounter
operator|>
literal|2
condition|)
block|{
name|fieldSchema
operator|.
name|setComment
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
name|t
operator|.
name|add
argument_list|(
name|fieldSchema
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|setSDCols
parameter_list|(
name|String
name|COLUMNS_V2
parameter_list|,
name|PersistenceManager
name|pm
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
name|colss
parameter_list|,
name|String
name|colIds
parameter_list|)
throws|throws
name|MetaException
block|{
name|String
name|queryText
decl_stmt|;
name|queryText
operator|=
literal|"select \"CD_ID\", \"COMMENT\", \"COLUMN_NAME\", \"TYPE_NAME\""
operator|+
literal|" from "
operator|+
name|COLUMNS_V2
operator|+
literal|" where \"CD_ID\" in ("
operator|+
name|colIds
operator|+
literal|")"
operator|+
literal|" order by \"CD_ID\" asc, \"INTEGER_IDX\" asc"
expr_stmt|;
name|loopJoinOrderedResult
argument_list|(
name|pm
argument_list|,
name|colss
argument_list|,
name|queryText
argument_list|,
literal|0
argument_list|,
operator|new
name|ApplyFunc
argument_list|<
name|List
argument_list|<
name|FieldSchema
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
block|{
name|t
operator|.
name|add
argument_list|(
operator|new
name|FieldSchema
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|2
index|]
argument_list|,
name|extractSqlClob
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|fields
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|setSerdeParams
parameter_list|(
name|String
name|SERDE_PARAMS
parameter_list|,
name|boolean
name|convertMapNullsToEmptyStrings
parameter_list|,
name|PersistenceManager
name|pm
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|SerDeInfo
argument_list|>
name|serdes
parameter_list|,
name|String
name|serdeIds
parameter_list|)
throws|throws
name|MetaException
block|{
name|String
name|queryText
decl_stmt|;
name|queryText
operator|=
literal|"select \"SERDE_ID\", \"PARAM_KEY\", \"PARAM_VALUE\" from "
operator|+
name|SERDE_PARAMS
operator|+
literal|""
operator|+
literal|" where \"SERDE_ID\" in ("
operator|+
name|serdeIds
operator|+
literal|") and \"PARAM_KEY\" is not null"
operator|+
literal|" order by \"SERDE_ID\" asc"
expr_stmt|;
name|loopJoinOrderedResult
argument_list|(
name|pm
argument_list|,
name|serdes
argument_list|,
name|queryText
argument_list|,
literal|0
argument_list|,
operator|new
name|ApplyFunc
argument_list|<
name|SerDeInfo
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|SerDeInfo
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
block|{
name|t
operator|.
name|putToParameters
argument_list|(
operator|(
name|String
operator|)
name|fields
index|[
literal|1
index|]
argument_list|,
name|extractSqlClob
argument_list|(
name|fields
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Perform conversion of null map values
for|for
control|(
name|SerDeInfo
name|t
range|:
name|serdes
operator|.
name|values
argument_list|()
control|)
block|{
name|t
operator|.
name|setParameters
argument_list|(
name|MetaStoreServerUtils
operator|.
name|trimMapNulls
argument_list|(
name|t
operator|.
name|getParameters
argument_list|()
argument_list|,
name|convertMapNullsToEmptyStrings
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Convert a boolean value returned from the RDBMS to a Java Boolean object.    * MySQL has booleans, but e.g. Derby uses 'Y'/'N' mapping.    *    * @param value    *          column value from the database    * @return The Boolean value of the database column value, null if the column    *         value is null    * @throws MetaException    *           if the column value cannot be converted into a Boolean object    */
specifier|static
name|Boolean
name|extractSqlBoolean
parameter_list|(
name|Object
name|value
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
name|Boolean
operator|)
name|value
return|;
block|}
comment|// check if oracle db returned 0 or 1 for boolean value
if|if
condition|(
name|value
operator|instanceof
name|Number
condition|)
block|{
try|try
block|{
return|return
name|BooleanUtils
operator|.
name|toBooleanObject
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|intValue
argument_list|()
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
comment|// NOOP
block|}
block|}
if|if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
try|try
block|{
return|return
name|BooleanUtils
operator|.
name|toBooleanObject
argument_list|(
operator|(
name|String
operator|)
name|value
argument_list|,
literal|"Y"
argument_list|,
literal|"N"
argument_list|,
literal|null
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
comment|// NOOP
block|}
block|}
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Cannot extract boolean from column value "
operator|+
name|value
argument_list|)
throw|;
block|}
specifier|static
name|String
name|extractSqlString
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|value
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|static
name|Double
name|extractSqlDouble
parameter_list|(
name|Object
name|obj
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|Number
operator|)
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Expected numeric type but got "
operator|+
name|obj
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
return|return
operator|(
operator|(
name|Number
operator|)
name|obj
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
specifier|static
name|byte
index|[]
name|extractSqlBlob
parameter_list|(
name|Object
name|value
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|value
operator|instanceof
name|Blob
condition|)
block|{
comment|//derby, oracle
try|try
block|{
comment|// getBytes function says: pos the ordinal position of the first byte in
comment|// the BLOB value to be extracted; the first byte is at position 1
return|return
operator|(
operator|(
name|Blob
operator|)
name|value
operator|)
operator|.
name|getBytes
argument_list|(
literal|1
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|Blob
operator|)
name|value
argument_list|)
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Encounter error while processing blob."
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|byte
index|[]
condition|)
block|{
comment|// mysql, postgres, sql server
return|return
operator|(
name|byte
index|[]
operator|)
name|value
return|;
block|}
else|else
block|{
comment|// this may happen when enablebitvector is false
name|LOG
operator|.
name|debug
argument_list|(
literal|"Expected blob type but got "
operator|+
name|value
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|FunctionalInterface
specifier|static
interface|interface
name|ApplyFunc
parameter_list|<
name|Target
parameter_list|>
block|{
name|void
name|apply
parameter_list|(
name|Target
name|t
parameter_list|,
name|Object
index|[]
name|fields
parameter_list|)
throws|throws
name|MetaException
function_decl|;
block|}
block|}
end_class

end_unit

