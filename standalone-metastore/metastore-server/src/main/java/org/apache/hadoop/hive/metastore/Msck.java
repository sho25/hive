begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *<p>  * http://www.apache.org/licenses/LICENSE-2.0  *<p>  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|tuple
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|DataOperationType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|LockRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|LockResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|LockState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|MetaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|MetastoreException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Partition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|conf
operator|.
name|MetastoreConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|utils
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|utils
operator|.
name|MetaStoreServerUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|utils
operator|.
name|RetryUtilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|TException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * Msck repairs table metadata specifically related to partition information to be in-sync with directories in table  * location.  */
end_comment

begin_class
specifier|public
class|class
name|Msck
block|{
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|Msck
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|separator
init|=
literal|9
decl_stmt|;
comment|// tabCode
specifier|private
specifier|static
specifier|final
name|int
name|terminator
init|=
literal|10
decl_stmt|;
comment|// newLineCode
specifier|private
name|boolean
name|acquireLock
decl_stmt|;
specifier|private
name|boolean
name|deleteData
decl_stmt|;
specifier|private
name|Configuration
name|conf
decl_stmt|;
specifier|private
name|IMetaStoreClient
name|msc
decl_stmt|;
specifier|public
name|Msck
parameter_list|(
name|boolean
name|acquireLock
parameter_list|,
name|boolean
name|deleteData
parameter_list|)
block|{
name|this
operator|.
name|acquireLock
operator|=
name|acquireLock
expr_stmt|;
name|this
operator|.
name|deleteData
operator|=
name|deleteData
expr_stmt|;
block|}
specifier|public
name|Configuration
name|getConf
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
specifier|public
name|void
name|setConf
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
block|}
specifier|public
name|void
name|init
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|MetaException
block|{
if|if
condition|(
name|msc
operator|==
literal|null
condition|)
block|{
comment|// the only reason we are using new conf here is to override EXPRESSION_PROXY_CLASS
name|Configuration
name|metastoreConf
init|=
name|MetastoreConf
operator|.
name|newMetastoreConf
argument_list|(
operator|new
name|Configuration
argument_list|(
name|conf
argument_list|)
argument_list|)
decl_stmt|;
name|metastoreConf
operator|.
name|set
argument_list|(
name|MetastoreConf
operator|.
name|ConfVars
operator|.
name|EXPRESSION_PROXY_CLASS
operator|.
name|getVarname
argument_list|()
argument_list|,
name|MsckPartitionExpressionProxy
operator|.
name|class
operator|.
name|getCanonicalName
argument_list|()
argument_list|)
expr_stmt|;
name|setConf
argument_list|(
name|metastoreConf
argument_list|)
expr_stmt|;
name|this
operator|.
name|msc
operator|=
operator|new
name|HiveMetaStoreClient
argument_list|(
name|metastoreConf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * MetastoreCheck, see if the data in the metastore matches what is on the    * dfs. Current version checks for tables and partitions that are either    * missing on disk on in the metastore.    *    * @param msckInfo Information about the tables and partitions we want to check for.    * @return Returns 0 when execution succeeds and above 0 if it fails.    */
specifier|public
name|int
name|repair
parameter_list|(
name|MsckInfo
name|msckInfo
parameter_list|)
block|{
name|CheckResult
name|result
init|=
operator|new
name|CheckResult
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|repairOutput
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|String
name|qualifiedTableName
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|long
name|txnId
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|long
name|partitionExpirySeconds
init|=
name|msckInfo
operator|.
name|getPartitionExpirySeconds
argument_list|()
decl_stmt|;
try|try
block|{
name|Table
name|table
init|=
name|getMsc
argument_list|()
operator|.
name|getTable
argument_list|(
name|msckInfo
operator|.
name|getCatalogName
argument_list|()
argument_list|,
name|msckInfo
operator|.
name|getDbName
argument_list|()
argument_list|,
name|msckInfo
operator|.
name|getTableName
argument_list|()
argument_list|)
decl_stmt|;
name|qualifiedTableName
operator|=
name|Warehouse
operator|.
name|getCatalogQualifiedTableName
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|HiveMetaStoreChecker
name|checker
init|=
operator|new
name|HiveMetaStoreChecker
argument_list|(
name|getMsc
argument_list|()
argument_list|,
name|getConf
argument_list|()
argument_list|,
name|partitionExpirySeconds
argument_list|)
decl_stmt|;
comment|// checkMetastore call will fill in result with partitions that are present in filesystem
comment|// and missing in metastore - accessed through getPartitionsNotInMs
comment|// And partitions that are not present in filesystem and metadata exists in metastore -
comment|// accessed through getPartitionNotOnFS
name|checker
operator|.
name|checkMetastore
argument_list|(
name|msckInfo
operator|.
name|getCatalogName
argument_list|()
argument_list|,
name|msckInfo
operator|.
name|getDbName
argument_list|()
argument_list|,
name|msckInfo
operator|.
name|getTableName
argument_list|()
argument_list|,
name|msckInfo
operator|.
name|getPartSpecs
argument_list|()
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|CheckResult
operator|.
name|PartitionResult
argument_list|>
name|partsNotInMs
init|=
name|result
operator|.
name|getPartitionsNotInMs
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|CheckResult
operator|.
name|PartitionResult
argument_list|>
name|partsNotInFs
init|=
name|result
operator|.
name|getPartitionsNotOnFs
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|CheckResult
operator|.
name|PartitionResult
argument_list|>
name|expiredPartitions
init|=
name|result
operator|.
name|getExpiredPartitions
argument_list|()
decl_stmt|;
name|int
name|totalPartsToFix
init|=
name|partsNotInMs
operator|.
name|size
argument_list|()
operator|+
name|partsNotInFs
operator|.
name|size
argument_list|()
operator|+
name|expiredPartitions
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// if nothing changed to partitions and if we are not repairing (add or drop) don't acquire for lock unnecessarily
name|boolean
name|lockRequired
init|=
name|totalPartsToFix
operator|>
literal|0
operator|&&
name|msckInfo
operator|.
name|isRepairPartitions
argument_list|()
operator|&&
operator|(
name|msckInfo
operator|.
name|isAddPartitions
argument_list|()
operator|||
name|msckInfo
operator|.
name|isDropPartitions
argument_list|()
operator|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{} - #partsNotInMs: {} #partsNotInFs: {} #expiredPartitions: {} lockRequired: {} (R: {} A: {} D: {})"
argument_list|,
name|qualifiedTableName
argument_list|,
name|partsNotInMs
operator|.
name|size
argument_list|()
argument_list|,
name|partsNotInFs
operator|.
name|size
argument_list|()
argument_list|,
name|expiredPartitions
operator|.
name|size
argument_list|()
argument_list|,
name|lockRequired
argument_list|,
name|msckInfo
operator|.
name|isRepairPartitions
argument_list|()
argument_list|,
name|msckInfo
operator|.
name|isAddPartitions
argument_list|()
argument_list|,
name|msckInfo
operator|.
name|isDropPartitions
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|msckInfo
operator|.
name|isRepairPartitions
argument_list|()
condition|)
block|{
comment|// Repair metadata in HMS
name|long
name|lockId
decl_stmt|;
if|if
condition|(
name|acquireLock
operator|&&
name|lockRequired
operator|&&
name|table
operator|.
name|getParameters
argument_list|()
operator|!=
literal|null
operator|&&
name|MetaStoreServerUtils
operator|.
name|isTransactionalTable
argument_list|(
name|table
operator|.
name|getParameters
argument_list|()
argument_list|)
condition|)
block|{
comment|// Running MSCK from beeline/cli will make DDL task acquire X lock when repair is enabled, since we are directly
comment|// invoking msck.repair() without SQL statement, we need to do the same and acquire X lock (repair is default)
name|LockRequest
name|lockRequest
init|=
name|createLockRequest
argument_list|(
name|msckInfo
operator|.
name|getDbName
argument_list|()
argument_list|,
name|msckInfo
operator|.
name|getTableName
argument_list|()
argument_list|)
decl_stmt|;
name|txnId
operator|=
name|lockRequest
operator|.
name|getTxnid
argument_list|()
expr_stmt|;
try|try
block|{
name|LockResponse
name|res
init|=
name|getMsc
argument_list|()
operator|.
name|lock
argument_list|(
name|lockRequest
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|.
name|getState
argument_list|()
operator|!=
name|LockState
operator|.
name|ACQUIRED
condition|)
block|{
throw|throw
operator|new
name|MetastoreException
argument_list|(
literal|"Unable to acquire lock(X) on "
operator|+
name|qualifiedTableName
argument_list|)
throw|;
block|}
name|lockId
operator|=
name|res
operator|.
name|getLockid
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|MetastoreException
argument_list|(
literal|"Unable to acquire lock(X) on "
operator|+
name|qualifiedTableName
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Acquired lock(X) on {}. LockId: {}"
argument_list|,
name|qualifiedTableName
argument_list|,
name|lockId
argument_list|)
expr_stmt|;
block|}
name|int
name|maxRetries
init|=
name|MetastoreConf
operator|.
name|getIntVar
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|MetastoreConf
operator|.
name|ConfVars
operator|.
name|MSCK_REPAIR_BATCH_MAX_RETRIES
argument_list|)
decl_stmt|;
name|int
name|decayingFactor
init|=
literal|2
decl_stmt|;
if|if
condition|(
name|msckInfo
operator|.
name|isAddPartitions
argument_list|()
operator|&&
operator|!
name|partsNotInMs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// MSCK called to add missing paritions into metastore and there are
comment|// missing partitions.
name|int
name|batchSize
init|=
name|MetastoreConf
operator|.
name|getIntVar
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|MetastoreConf
operator|.
name|ConfVars
operator|.
name|MSCK_REPAIR_BATCH_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|batchSize
operator|==
literal|0
condition|)
block|{
comment|//batching is not enabled. Try to add all the partitions in one call
name|batchSize
operator|=
name|partsNotInMs
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|AbstractList
argument_list|<
name|String
argument_list|>
name|vals
init|=
literal|null
decl_stmt|;
name|String
name|settingStr
init|=
name|MetastoreConf
operator|.
name|getVar
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|MetastoreConf
operator|.
name|ConfVars
operator|.
name|MSCK_PATH_VALIDATION
argument_list|)
decl_stmt|;
name|boolean
name|doValidate
init|=
operator|!
operator|(
literal|"ignore"
operator|.
name|equals
argument_list|(
name|settingStr
argument_list|)
operator|)
decl_stmt|;
name|boolean
name|doSkip
init|=
name|doValidate
operator|&&
literal|"skip"
operator|.
name|equals
argument_list|(
name|settingStr
argument_list|)
decl_stmt|;
comment|// The default setting is "throw"; assume doValidate&& !doSkip means throw.
if|if
condition|(
name|doValidate
condition|)
block|{
comment|// Validate that we can add partition without escaping. Escaping was originally intended
comment|// to avoid creating invalid HDFS paths; however, if we escape the HDFS path (that we
comment|// deem invalid but HDFS actually supports - it is possible to create HDFS paths with
comment|// unprintable characters like ASCII 7), metastore will create another directory instead
comment|// of the one we are trying to "repair" here.
name|Iterator
argument_list|<
name|CheckResult
operator|.
name|PartitionResult
argument_list|>
name|iter
init|=
name|partsNotInMs
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|CheckResult
operator|.
name|PartitionResult
name|part
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|vals
operator|=
name|Warehouse
operator|.
name|makeValsFromName
argument_list|(
name|part
operator|.
name|getPartitionName
argument_list|()
argument_list|,
name|vals
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MetaException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|MetastoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
for|for
control|(
name|String
name|val
range|:
name|vals
control|)
block|{
name|String
name|escapedPath
init|=
name|FileUtils
operator|.
name|escapePathName
argument_list|(
name|val
argument_list|)
decl_stmt|;
assert|assert
name|escapedPath
operator|!=
literal|null
assert|;
if|if
condition|(
name|escapedPath
operator|.
name|equals
argument_list|(
name|val
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|String
name|errorMsg
init|=
literal|"Repair: Cannot add partition "
operator|+
name|msckInfo
operator|.
name|getTableName
argument_list|()
operator|+
literal|':'
operator|+
name|part
operator|.
name|getPartitionName
argument_list|()
operator|+
literal|" due to invalid characters in the name"
decl_stmt|;
if|if
condition|(
name|doSkip
condition|)
block|{
name|repairOutput
operator|.
name|add
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|MetastoreException
argument_list|(
name|errorMsg
argument_list|)
throw|;
block|}
block|}
block|}
block|}
try|try
block|{
name|createPartitionsInBatches
argument_list|(
name|getMsc
argument_list|()
argument_list|,
name|repairOutput
argument_list|,
name|partsNotInMs
argument_list|,
name|table
argument_list|,
name|batchSize
argument_list|,
name|decayingFactor
argument_list|,
name|maxRetries
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|MetastoreException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|msckInfo
operator|.
name|isDropPartitions
argument_list|()
operator|&&
operator|(
operator|!
name|partsNotInFs
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|expiredPartitions
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
comment|// MSCK called to drop stale paritions from metastore and there are
comment|// stale partitions.
name|int
name|batchSize
init|=
name|MetastoreConf
operator|.
name|getIntVar
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|MetastoreConf
operator|.
name|ConfVars
operator|.
name|MSCK_REPAIR_BATCH_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|batchSize
operator|==
literal|0
condition|)
block|{
comment|//batching is not enabled. Try to drop all the partitions in one call
name|batchSize
operator|=
name|partsNotInFs
operator|.
name|size
argument_list|()
operator|+
name|expiredPartitions
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|dropPartitionsInBatches
argument_list|(
name|getMsc
argument_list|()
argument_list|,
name|repairOutput
argument_list|,
name|partsNotInFs
argument_list|,
name|expiredPartitions
argument_list|,
name|table
argument_list|,
name|batchSize
argument_list|,
name|decayingFactor
argument_list|,
name|maxRetries
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|MetastoreException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to run metacheck: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|msckInfo
operator|.
name|getResFile
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|BufferedWriter
name|resultOut
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Path
name|resFile
init|=
operator|new
name|Path
argument_list|(
name|msckInfo
operator|.
name|getResFile
argument_list|()
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|resFile
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|resultOut
operator|=
operator|new
name|BufferedWriter
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
name|fs
operator|.
name|create
argument_list|(
name|resFile
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|firstWritten
init|=
literal|false
decl_stmt|;
name|firstWritten
operator||=
name|writeMsckResult
argument_list|(
name|result
operator|.
name|getTablesNotInMs
argument_list|()
argument_list|,
literal|"Tables not in metastore:"
argument_list|,
name|resultOut
argument_list|,
name|firstWritten
argument_list|)
expr_stmt|;
name|firstWritten
operator||=
name|writeMsckResult
argument_list|(
name|result
operator|.
name|getTablesNotOnFs
argument_list|()
argument_list|,
literal|"Tables missing on filesystem:"
argument_list|,
name|resultOut
argument_list|,
name|firstWritten
argument_list|)
expr_stmt|;
name|firstWritten
operator||=
name|writeMsckResult
argument_list|(
name|result
operator|.
name|getPartitionsNotInMs
argument_list|()
argument_list|,
literal|"Partitions not in metastore:"
argument_list|,
name|resultOut
argument_list|,
name|firstWritten
argument_list|)
expr_stmt|;
name|firstWritten
operator||=
name|writeMsckResult
argument_list|(
name|result
operator|.
name|getPartitionsNotOnFs
argument_list|()
argument_list|,
literal|"Partitions missing from filesystem:"
argument_list|,
name|resultOut
argument_list|,
name|firstWritten
argument_list|)
expr_stmt|;
name|firstWritten
operator||=
name|writeMsckResult
argument_list|(
name|result
operator|.
name|getExpiredPartitions
argument_list|()
argument_list|,
literal|"Expired partitions (retention period: "
operator|+
name|partitionExpirySeconds
operator|+
literal|"s) :"
argument_list|,
name|resultOut
argument_list|,
name|firstWritten
argument_list|)
expr_stmt|;
comment|// sorting to stabilize qfile output (msck_repair_drop.q)
name|Collections
operator|.
name|sort
argument_list|(
name|repairOutput
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|rout
range|:
name|repairOutput
control|)
block|{
if|if
condition|(
name|firstWritten
condition|)
block|{
name|resultOut
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|firstWritten
operator|=
literal|true
expr_stmt|;
block|}
name|resultOut
operator|.
name|write
argument_list|(
name|rout
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to save metacheck output: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|resultOut
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|resultOut
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to close output file: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Tables not in metastore: {}"
argument_list|,
name|result
operator|.
name|getTablesNotInMs
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Tables missing on filesystem: {}"
argument_list|,
name|result
operator|.
name|getTablesNotOnFs
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Partitions not in metastore: {}"
argument_list|,
name|result
operator|.
name|getPartitionsNotInMs
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Partitions missing from filesystem: {}"
argument_list|,
name|result
operator|.
name|getPartitionsNotOnFs
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Expired partitions: {}"
argument_list|,
name|result
operator|.
name|getExpiredPartitions
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|acquireLock
operator|&&
name|txnId
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|success
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"txnId: {} succeeded. Committing.."
argument_list|,
name|txnId
argument_list|)
expr_stmt|;
name|getMsc
argument_list|()
operator|.
name|commitTxn
argument_list|(
name|txnId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error while committing txnId: {} for table: {}"
argument_list|,
name|txnId
argument_list|,
name|qualifiedTableName
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"txnId: {} failed. Aborting.."
argument_list|,
name|txnId
argument_list|)
expr_stmt|;
name|getMsc
argument_list|()
operator|.
name|abortTxns
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
name|txnId
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error while aborting txnId: {} for table: {}"
argument_list|,
name|txnId
argument_list|,
name|qualifiedTableName
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|getMsc
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|getMsc
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
name|msc
operator|=
literal|null
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
specifier|private
name|LockRequest
name|createLockRequest
parameter_list|(
specifier|final
name|String
name|dbName
parameter_list|,
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|TException
block|{
name|UserGroupInformation
name|loggedInUser
init|=
literal|null
decl_stmt|;
name|String
name|username
decl_stmt|;
try|try
block|{
name|loggedInUser
operator|=
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to get logged in user via UGI. err: {}"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loggedInUser
operator|==
literal|null
condition|)
block|{
name|username
operator|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"user.name"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|username
operator|=
name|loggedInUser
operator|.
name|getShortUserName
argument_list|()
expr_stmt|;
block|}
name|long
name|txnId
init|=
name|getMsc
argument_list|()
operator|.
name|openTxn
argument_list|(
name|username
argument_list|)
decl_stmt|;
name|String
name|agentInfo
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|LockRequestBuilder
name|requestBuilder
init|=
operator|new
name|LockRequestBuilder
argument_list|(
name|agentInfo
argument_list|)
decl_stmt|;
name|requestBuilder
operator|.
name|setUser
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|requestBuilder
operator|.
name|setTransactionId
argument_list|(
name|txnId
argument_list|)
expr_stmt|;
name|LockComponentBuilder
name|lockCompBuilder
init|=
operator|new
name|LockComponentBuilder
argument_list|()
operator|.
name|setDbName
argument_list|(
name|dbName
argument_list|)
operator|.
name|setTableName
argument_list|(
name|tableName
argument_list|)
operator|.
name|setIsTransactional
argument_list|(
literal|true
argument_list|)
operator|.
name|setExclusive
argument_list|()
comment|// WriteType is DDL_EXCLUSIVE for MSCK REPAIR so we need NO_TXN. Refer AcidUtils.makeLockComponents
operator|.
name|setOperationType
argument_list|(
name|DataOperationType
operator|.
name|NO_TXN
argument_list|)
decl_stmt|;
name|requestBuilder
operator|.
name|addLockComponent
argument_list|(
name|lockCompBuilder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Created lock(X) request with info - user: {} txnId: {} agentInfo: {} dbName: {} tableName: {}"
argument_list|,
name|username
argument_list|,
name|txnId
argument_list|,
name|agentInfo
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
return|return
name|requestBuilder
operator|.
name|build
argument_list|()
return|;
block|}
specifier|public
name|IMetaStoreClient
name|getMsc
parameter_list|()
block|{
return|return
name|msc
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|void
name|createPartitionsInBatches
parameter_list|(
specifier|final
name|IMetaStoreClient
name|metastoreClient
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|repairOutput
parameter_list|,
name|Set
argument_list|<
name|CheckResult
operator|.
name|PartitionResult
argument_list|>
name|partsNotInMs
parameter_list|,
name|Table
name|table
parameter_list|,
name|int
name|batchSize
parameter_list|,
name|int
name|decayingFactor
parameter_list|,
name|int
name|maxRetries
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|addMsgFormat
init|=
literal|"Repair: Added partition to metastore "
operator|+
name|table
operator|.
name|getTableName
argument_list|()
operator|+
literal|":%s"
decl_stmt|;
name|Set
argument_list|<
name|CheckResult
operator|.
name|PartitionResult
argument_list|>
name|batchWork
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|partsNotInMs
argument_list|)
decl_stmt|;
operator|new
name|RetryUtilities
operator|.
name|ExponentiallyDecayingBatchWork
argument_list|<
name|Void
argument_list|>
argument_list|(
name|batchSize
argument_list|,
name|decayingFactor
argument_list|,
name|maxRetries
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|execute
parameter_list|(
name|int
name|size
parameter_list|)
throws|throws
name|MetastoreException
block|{
try|try
block|{
while|while
condition|(
operator|!
name|batchWork
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|Partition
argument_list|>
name|partsToAdd
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|//get the current batch size
name|int
name|currentBatchSize
init|=
name|size
decl_stmt|;
comment|//store the partitions temporarily until processed
name|List
argument_list|<
name|CheckResult
operator|.
name|PartitionResult
argument_list|>
name|lastBatch
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|currentBatchSize
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|addMsgs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|currentBatchSize
argument_list|)
decl_stmt|;
comment|//add the number of partitions given by the current batchsize
for|for
control|(
name|CheckResult
operator|.
name|PartitionResult
name|part
range|:
name|batchWork
control|)
block|{
if|if
condition|(
name|currentBatchSize
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|Path
name|tablePath
init|=
name|MetaStoreServerUtils
operator|.
name|getPath
argument_list|(
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
name|tablePath
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
name|Warehouse
operator|.
name|makeSpecFromName
argument_list|(
name|part
operator|.
name|getPartitionName
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|location
init|=
operator|new
name|Path
argument_list|(
name|tablePath
argument_list|,
name|Warehouse
operator|.
name|makePartPath
argument_list|(
name|partSpec
argument_list|)
argument_list|)
decl_stmt|;
name|Partition
name|partition
init|=
name|MetaStoreServerUtils
operator|.
name|createMetaPartitionObject
argument_list|(
name|table
argument_list|,
name|partSpec
argument_list|,
name|location
argument_list|)
decl_stmt|;
name|partition
operator|.
name|setWriteId
argument_list|(
name|table
operator|.
name|getWriteId
argument_list|()
argument_list|)
expr_stmt|;
name|partsToAdd
operator|.
name|add
argument_list|(
name|partition
argument_list|)
expr_stmt|;
name|lastBatch
operator|.
name|add
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|addMsgs
operator|.
name|add
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|addMsgFormat
argument_list|,
name|part
operator|.
name|getPartitionName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|currentBatchSize
operator|--
expr_stmt|;
block|}
name|metastoreClient
operator|.
name|add_partitions
argument_list|(
name|partsToAdd
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// if last batch is successful remove it from partsNotInMs
name|batchWork
operator|.
name|removeAll
argument_list|(
name|lastBatch
argument_list|)
expr_stmt|;
name|repairOutput
operator|.
name|addAll
argument_list|(
name|addMsgs
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|TException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|MetastoreException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
specifier|private
specifier|static
name|String
name|makePartExpr
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|spec
parameter_list|)
throws|throws
name|MetaException
block|{
name|StringBuilder
name|suffixBuf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|e
range|:
name|spec
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|==
literal|null
operator|||
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Partition spec is incorrect. "
operator|+
name|spec
argument_list|)
throw|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|suffixBuf
operator|.
name|append
argument_list|(
literal|" AND "
argument_list|)
expr_stmt|;
block|}
name|suffixBuf
operator|.
name|append
argument_list|(
name|Warehouse
operator|.
name|escapePathName
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|suffixBuf
operator|.
name|append
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|suffixBuf
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
operator|.
name|append
argument_list|(
name|Warehouse
operator|.
name|escapePathName
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return
name|suffixBuf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// Drops partitions in batches.  partNotInFs is split into batches based on batchSize
comment|// and dropped.  The dropping will be through RetryUtilities which will retry when there is a
comment|// failure after reducing the batchSize by decayingFactor.  Retrying will cease when maxRetries
comment|// limit is reached or batchSize reduces to 0, whichever comes earlier.
annotation|@
name|VisibleForTesting
specifier|public
name|void
name|dropPartitionsInBatches
parameter_list|(
specifier|final
name|IMetaStoreClient
name|metastoreClient
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|repairOutput
parameter_list|,
name|Set
argument_list|<
name|CheckResult
operator|.
name|PartitionResult
argument_list|>
name|partsNotInFs
parameter_list|,
name|Set
argument_list|<
name|CheckResult
operator|.
name|PartitionResult
argument_list|>
name|expiredPartitions
parameter_list|,
name|Table
name|table
parameter_list|,
name|int
name|batchSize
parameter_list|,
name|int
name|decayingFactor
parameter_list|,
name|int
name|maxRetries
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|dropMsgFormat
init|=
literal|"Repair: Dropped partition from metastore "
operator|+
name|Warehouse
operator|.
name|getCatalogQualifiedTableName
argument_list|(
name|table
argument_list|)
operator|+
literal|":%s"
decl_stmt|;
comment|// Copy of partitions that will be split into batches
name|Set
argument_list|<
name|CheckResult
operator|.
name|PartitionResult
argument_list|>
name|batchWork
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|partsNotInFs
argument_list|)
decl_stmt|;
if|if
condition|(
name|expiredPartitions
operator|!=
literal|null
operator|&&
operator|!
name|expiredPartitions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|batchWork
operator|.
name|addAll
argument_list|(
name|expiredPartitions
argument_list|)
expr_stmt|;
block|}
name|PartitionDropOptions
name|dropOptions
init|=
operator|new
name|PartitionDropOptions
argument_list|()
operator|.
name|deleteData
argument_list|(
name|deleteData
argument_list|)
operator|.
name|ifExists
argument_list|(
literal|true
argument_list|)
decl_stmt|;
operator|new
name|RetryUtilities
operator|.
name|ExponentiallyDecayingBatchWork
argument_list|<
name|Void
argument_list|>
argument_list|(
name|batchSize
argument_list|,
name|decayingFactor
argument_list|,
name|maxRetries
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|execute
parameter_list|(
name|int
name|size
parameter_list|)
throws|throws
name|MetastoreException
block|{
try|try
block|{
while|while
condition|(
operator|!
name|batchWork
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|currentBatchSize
init|=
name|size
decl_stmt|;
comment|// to store the partitions that are currently being processed
name|List
argument_list|<
name|CheckResult
operator|.
name|PartitionResult
argument_list|>
name|lastBatch
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|currentBatchSize
argument_list|)
decl_stmt|;
comment|// drop messages for the dropped partitions
name|List
argument_list|<
name|String
argument_list|>
name|dropMsgs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|currentBatchSize
argument_list|)
decl_stmt|;
comment|// Partitions to be dropped
name|List
argument_list|<
name|String
argument_list|>
name|dropParts
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|currentBatchSize
argument_list|)
decl_stmt|;
for|for
control|(
name|CheckResult
operator|.
name|PartitionResult
name|part
range|:
name|batchWork
control|)
block|{
comment|// This batch is full: break out of for loop to execute
if|if
condition|(
name|currentBatchSize
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|dropParts
operator|.
name|add
argument_list|(
name|part
operator|.
name|getPartitionName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Add the part to lastBatch to track the parition being dropped
name|lastBatch
operator|.
name|add
argument_list|(
name|part
argument_list|)
expr_stmt|;
comment|// Update messages
name|dropMsgs
operator|.
name|add
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|dropMsgFormat
argument_list|,
name|part
operator|.
name|getPartitionName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Decrement batch size.  When this gets to 0, the batch will be executed
name|currentBatchSize
operator|--
expr_stmt|;
block|}
comment|// this call is deleting partitions that are already missing from filesystem
comment|// so 3rd parameter (deleteData) is set to false
comment|// msck is doing a clean up of hms.  if for some reason the partition is already
comment|// deleted, then it is good.  So, the last parameter ifexists is set to true
name|List
argument_list|<
name|Pair
argument_list|<
name|Integer
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|partExprs
init|=
name|getPartitionExpr
argument_list|(
name|dropParts
argument_list|)
decl_stmt|;
name|metastoreClient
operator|.
name|dropPartitions
argument_list|(
name|table
operator|.
name|getCatName
argument_list|()
argument_list|,
name|table
operator|.
name|getDbName
argument_list|()
argument_list|,
name|table
operator|.
name|getTableName
argument_list|()
argument_list|,
name|partExprs
argument_list|,
name|dropOptions
argument_list|)
expr_stmt|;
comment|// if last batch is successful remove it from partsNotInFs
name|batchWork
operator|.
name|removeAll
argument_list|(
name|lastBatch
argument_list|)
expr_stmt|;
name|repairOutput
operator|.
name|addAll
argument_list|(
name|dropMsgs
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|TException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|MetastoreException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|Pair
argument_list|<
name|Integer
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|getPartitionExpr
parameter_list|(
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|parts
parameter_list|)
throws|throws
name|MetaException
block|{
name|List
argument_list|<
name|Pair
argument_list|<
name|Integer
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|expr
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|parts
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parts
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|partName
init|=
name|parts
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
name|Warehouse
operator|.
name|makeSpecFromName
argument_list|(
name|partName
argument_list|)
decl_stmt|;
name|String
name|partExpr
init|=
name|makePartExpr
argument_list|(
name|partSpec
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Generated partExpr: {} for partName: {}"
argument_list|,
name|partExpr
argument_list|,
name|partName
argument_list|)
expr_stmt|;
block|}
name|expr
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|i
argument_list|,
name|partExpr
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
comment|/**    * Write the result of msck to a writer.    *    * @param result The result we're going to write    * @param msg    Message to write.    * @param out    Writer to write to    * @param wrote  if any previous call wrote data    * @return true if something was written    * @throws IOException In case the writing fails    */
specifier|private
name|boolean
name|writeMsckResult
parameter_list|(
name|Set
argument_list|<
name|?
argument_list|>
name|result
parameter_list|,
name|String
name|msg
parameter_list|,
name|Writer
name|out
parameter_list|,
name|boolean
name|wrote
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|wrote
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|write
argument_list|(
name|msg
argument_list|)
expr_stmt|;
for|for
control|(
name|Object
name|entry
range|:
name|result
control|)
block|{
name|out
operator|.
name|write
argument_list|(
name|separator
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|entry
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
end_class

end_unit

