begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|txn
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|classification
operator|.
name|RetrySemantics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|CompactionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|MetaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|OpenTxnRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|conf
operator|.
name|MetastoreConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|conf
operator|.
name|MetastoreConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|PreparedStatement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * Extends the transaction handler with methods needed only by the compactor threads.  These  * methods are not available through the thrift interface.  */
end_comment

begin_class
class|class
name|CompactionTxnHandler
extends|extends
name|TxnHandler
block|{
specifier|static
specifier|final
specifier|private
name|String
name|CLASS_NAME
init|=
name|CompactionTxnHandler
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|CLASS_NAME
argument_list|)
decl_stmt|;
specifier|public
name|CompactionTxnHandler
parameter_list|()
block|{   }
comment|/**    * This will look through the completed_txn_components table and look for partitions or tables    * that may be ready for compaction.  Also, look through txns and txn_components tables for    * aborted transactions that we should add to the list.    * @param abortedThreshold  number of aborted queries forming a potential compaction request.    * @return list of CompactionInfo structs.  These will not have id, type,    * or runAs set since these are only potential compactions not actual ones.    */
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|ReadOnly
specifier|public
name|Set
argument_list|<
name|CompactionInfo
argument_list|>
name|findPotentialCompactions
parameter_list|(
name|int
name|abortedThreshold
parameter_list|)
throws|throws
name|MetaException
block|{
return|return
name|findPotentialCompactions
argument_list|(
name|abortedThreshold
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|ReadOnly
specifier|public
name|Set
argument_list|<
name|CompactionInfo
argument_list|>
name|findPotentialCompactions
parameter_list|(
name|int
name|abortedThreshold
parameter_list|,
name|long
name|checkInterval
parameter_list|)
throws|throws
name|MetaException
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Set
argument_list|<
name|CompactionInfo
argument_list|>
name|response
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
comment|// Check for completed transactions
name|String
name|s
init|=
literal|"SELECT DISTINCT \"TC\".\"CTC_DATABASE\", \"TC\".\"CTC_TABLE\", \"TC\".\"CTC_PARTITION\" "
operator|+
literal|"FROM \"COMPLETED_TXN_COMPONENTS\" TC "
operator|+
operator|(
name|checkInterval
operator|>
literal|0
condition|?
literal|"LEFT JOIN ( "
operator|+
literal|"  SELECT \"C1\".* FROM \"COMPLETED_COMPACTIONS\" \"C1\" "
operator|+
literal|"  INNER JOIN ( "
operator|+
literal|"    SELECT MAX(\"CC_ID\") \"CC_ID\" FROM \"COMPLETED_COMPACTIONS\" "
operator|+
literal|"    GROUP BY \"CC_DATABASE\", \"CC_TABLE\", \"CC_PARTITION\""
operator|+
literal|"  ) \"C2\" "
operator|+
literal|"  ON \"C1\".\"CC_ID\" = \"C2\".\"CC_ID\" "
operator|+
literal|"  WHERE \"C1\".\"CC_STATE\" IN ("
operator|+
name|quoteChar
argument_list|(
name|ATTEMPTED_STATE
argument_list|)
operator|+
literal|","
operator|+
name|quoteChar
argument_list|(
name|FAILED_STATE
argument_list|)
operator|+
literal|")"
operator|+
literal|") \"C\" "
operator|+
literal|"ON \"TC\".\"CTC_DATABASE\" = \"C\".\"CC_DATABASE\" AND \"TC\".\"CTC_TABLE\" = \"C\".\"CC_TABLE\" "
operator|+
literal|"  AND (\"TC\".\"CTC_PARTITION\" = \"C\".\"CC_PARTITION\" OR (\"TC\".\"CTC_PARTITION\" IS NULL AND \"C\".\"CC_PARTITION\" IS NULL)) "
operator|+
literal|"WHERE \"C\".\"CC_ID\" IS NOT NULL OR "
operator|+
name|isWithinCheckInterval
argument_list|(
literal|"\"TC\".\"CTC_TIMESTAMP\""
argument_list|,
name|checkInterval
argument_list|)
else|:
literal|""
operator|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|CompactionInfo
name|info
init|=
operator|new
name|CompactionInfo
argument_list|()
decl_stmt|;
name|info
operator|.
name|dbname
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|info
operator|.
name|tableName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|info
operator|.
name|partName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|response
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
name|rs
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Check for aborted txns
name|s
operator|=
literal|"SELECT \"TC_DATABASE\", \"TC_TABLE\", \"TC_PARTITION\" "
operator|+
literal|"FROM \"TXNS\", \"TXN_COMPONENTS\" "
operator|+
literal|"WHERE \"TXN_ID\" = \"TC_TXNID\" AND \"TXN_STATE\" = '"
operator|+
name|TXN_ABORTED
operator|+
literal|"' "
operator|+
literal|"GROUP BY \"TC_DATABASE\", \"TC_TABLE\", \"TC_PARTITION\" "
operator|+
literal|"HAVING COUNT(*)> "
operator|+
name|abortedThreshold
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|CompactionInfo
name|info
init|=
operator|new
name|CompactionInfo
argument_list|()
decl_stmt|;
name|info
operator|.
name|dbname
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|info
operator|.
name|tableName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|info
operator|.
name|partName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|info
operator|.
name|tooManyAborts
operator|=
literal|true
expr_stmt|;
name|response
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"findPotentialCompactions(maxAborted:"
operator|+
name|abortedThreshold
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
return|return
name|response
return|;
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|findPotentialCompactions
argument_list|(
name|abortedThreshold
argument_list|,
name|checkInterval
argument_list|)
return|;
block|}
block|}
comment|/**    * This will grab the next compaction request off of    * the queue, and assign it to the worker.    * @param workerId id of the worker calling this, will be recorded in the db    * @return an info element for this compaction request, or null if there is no work to do now.    */
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|SafeToRetry
specifier|public
name|CompactionInfo
name|findNextToCompact
parameter_list|(
name|String
name|workerId
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
comment|//need a separate stmt for executeUpdate() otherwise it will close the ResultSet(HIVE-12725)
name|Statement
name|updStmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"SELECT \"CQ_ID\", \"CQ_DATABASE\", \"CQ_TABLE\", \"CQ_PARTITION\", "
operator|+
literal|"\"CQ_TYPE\", \"CQ_TBLPROPERTIES\" FROM \"COMPACTION_QUEUE\" WHERE \"CQ_STATE\" = '"
operator|+
name|INITIATED_STATE
operator|+
literal|"'"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No compactions found ready to compact"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
name|updStmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
do|do
block|{
name|CompactionInfo
name|info
init|=
operator|new
name|CompactionInfo
argument_list|()
decl_stmt|;
name|info
operator|.
name|id
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|info
operator|.
name|dbname
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|info
operator|.
name|tableName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|info
operator|.
name|partName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|info
operator|.
name|type
operator|=
name|dbCompactionType2ThriftType
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|properties
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
expr_stmt|;
comment|// Now, update this record as being worked on by this worker.
name|long
name|now
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|s
operator|=
literal|"UPDATE \"COMPACTION_QUEUE\" SET \"CQ_WORKER_ID\" = '"
operator|+
name|workerId
operator|+
literal|"', "
operator|+
literal|"\"CQ_START\" = "
operator|+
name|now
operator|+
literal|", \"CQ_STATE\" = '"
operator|+
name|WORKING_STATE
operator|+
literal|"' WHERE \"CQ_ID\" = "
operator|+
name|info
operator|.
name|id
operator|+
literal|" AND \"CQ_STATE\"='"
operator|+
name|INITIATED_STATE
operator|+
literal|"'"
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|updCount
init|=
name|updStmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|updCount
operator|==
literal|1
condition|)
block|{
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
name|info
return|;
block|}
if|if
condition|(
name|updCount
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Another Worker picked up "
operator|+
name|info
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to set to cq_state="
operator|+
name|WORKING_STATE
operator|+
literal|" for compaction record: "
operator|+
name|info
operator|+
literal|". updCnt="
operator|+
name|updCount
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
do|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
do|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to select next element for compaction, "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"findNextToCompact(workerId:"
operator|+
name|workerId
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|updStmt
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|findNextToCompact
argument_list|(
name|workerId
argument_list|)
return|;
block|}
block|}
comment|/**    * This will mark an entry in the queue as compacted    * and put it in the ready to clean state.    * @param info info on the compaction entry to mark as compacted.    */
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|SafeToRetry
specifier|public
name|void
name|markCompacted
parameter_list|(
name|CompactionInfo
name|info
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"UPDATE \"COMPACTION_QUEUE\" SET \"CQ_STATE\" = '"
operator|+
name|READY_FOR_CLEANING
operator|+
literal|"', "
operator|+
literal|"\"CQ_WORKER_ID\" = NULL WHERE \"CQ_ID\" = "
operator|+
name|info
operator|.
name|id
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|updCnt
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|updCnt
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to set cq_state="
operator|+
name|READY_FOR_CLEANING
operator|+
literal|" for compaction record: "
operator|+
name|info
operator|+
literal|". updCnt="
operator|+
name|updCnt
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to update compaction queue "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"markCompacted("
operator|+
name|info
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|markCompacted
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Find entries in the queue that are ready to    * be cleaned.    * @return information on the entry in the queue.    */
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|ReadOnly
specifier|public
name|List
argument_list|<
name|CompactionInfo
argument_list|>
name|findReadyToClean
parameter_list|()
throws|throws
name|MetaException
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|CompactionInfo
argument_list|>
name|rc
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"SELECT \"CQ_ID\", \"CQ_DATABASE\", \"CQ_TABLE\", \"CQ_PARTITION\", "
operator|+
literal|"\"CQ_TYPE\", \"CQ_RUN_AS\", \"CQ_HIGHEST_WRITE_ID\" FROM \"COMPACTION_QUEUE\" WHERE \"CQ_STATE\" = '"
operator|+
name|READY_FOR_CLEANING
operator|+
literal|"'"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|CompactionInfo
name|info
init|=
operator|new
name|CompactionInfo
argument_list|()
decl_stmt|;
name|info
operator|.
name|id
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|info
operator|.
name|dbname
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|info
operator|.
name|tableName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|info
operator|.
name|partName
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|MAJOR_TYPE
case|:
name|info
operator|.
name|type
operator|=
name|CompactionType
operator|.
name|MAJOR
expr_stmt|;
break|break;
case|case
name|MINOR_TYPE
case|:
name|info
operator|.
name|type
operator|=
name|CompactionType
operator|.
name|MINOR
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unexpected compaction type "
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
argument_list|)
throw|;
block|}
name|info
operator|.
name|runAs
operator|=
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|info
operator|.
name|highestWriteId
operator|=
name|rs
operator|.
name|getLong
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|rc
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
name|rc
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to select next element for cleaning, "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"findReadyToClean"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|findReadyToClean
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|long
name|findMinOpenTxnId
parameter_list|()
throws|throws
name|MetaException
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
return|return
name|findMinOpenTxnGLB
argument_list|(
name|stmt
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to findMinOpenTxnId() due to:"
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"findMinOpenTxnId"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to execute findMinOpenTxnId() "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|findMinOpenTxnId
argument_list|()
return|;
block|}
block|}
comment|/**    * See doc at {@link TxnStore#findMinOpenTxnId()}    * Note that {@link #openTxns(OpenTxnRequest)} makes update of NEXT_TXN and MIN_HISTORY_LEVEL    * a single atomic operation (and no one else should update these tables except the cleaner    * which deletes rows from MIN_HISTORY_LEVEL which can only allow minOpenTxn to move higher)    */
specifier|private
name|long
name|findMinOpenTxnGLB
parameter_list|(
name|Statement
name|stmt
parameter_list|)
throws|throws
name|MetaException
throws|,
name|SQLException
block|{
name|String
name|s
init|=
literal|"SELECT \"NTXN_NEXT\" FROM \"NEXT_TXN_ID\""
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Transaction tables not properly "
operator|+
literal|"initialized, no record found in next_txn_id"
argument_list|)
throw|;
block|}
name|long
name|hwm
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|s
operator|=
literal|"SELECT MIN(\"MHL_MIN_OPEN_TXNID\") FROM \"MIN_HISTORY_LEVEL\""
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|rs
operator|.
name|next
argument_list|()
expr_stmt|;
name|long
name|minOpenTxnId
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
block|{
return|return
name|hwm
return|;
block|}
comment|//since generating new txnid uses select for update on single row in NEXT_TXN_ID
assert|assert
name|hwm
operator|>=
name|minOpenTxnId
operator|:
literal|"(hwm, minOpenTxnId)=("
operator|+
name|hwm
operator|+
literal|","
operator|+
name|minOpenTxnId
operator|+
literal|")"
assert|;
return|return
name|minOpenTxnId
return|;
block|}
comment|/**    * This will remove an entry from the queue after    * it has been compacted.    *    * @param info info on the compaction entry to remove    */
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|CannotRetry
specifier|public
name|void
name|markCleaned
parameter_list|(
name|CompactionInfo
name|info
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|PreparedStatement
name|pStmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|pStmt
operator|=
name|dbConn
operator|.
name|prepareStatement
argument_list|(
literal|"SELECT \"CQ_ID\", \"CQ_DATABASE\", \"CQ_TABLE\", \"CQ_PARTITION\", "
operator|+
literal|"\"CQ_STATE\", \"CQ_TYPE\", \"CQ_TBLPROPERTIES\", \"CQ_WORKER_ID\", \"CQ_START\", \"CQ_RUN_AS\", "
operator|+
literal|"\"CQ_HIGHEST_WRITE_ID\", \"CQ_META_INFO\", \"CQ_HADOOP_JOB_ID\", \"CQ_ERROR_MESSAGE\" "
operator|+
literal|"FROM \"COMPACTION_QUEUE\" WHERE \"CQ_ID\" = ?"
argument_list|)
expr_stmt|;
name|pStmt
operator|.
name|setLong
argument_list|(
literal|1
argument_list|,
name|info
operator|.
name|id
argument_list|)
expr_stmt|;
name|rs
operator|=
name|pStmt
operator|.
name|executeQuery
argument_list|()
expr_stmt|;
if|if
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|info
operator|=
name|CompactionInfo
operator|.
name|loadFullFromCompactionQueue
argument_list|(
name|rs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"No record with CQ_ID="
operator|+
name|info
operator|.
name|id
operator|+
literal|" found in COMPACTION_QUEUE"
argument_list|)
throw|;
block|}
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|String
name|s
init|=
literal|"delete from COMPACTION_QUEUE where cq_id = ?"
decl_stmt|;
name|pStmt
operator|=
name|dbConn
operator|.
name|prepareStatement
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|pStmt
operator|.
name|setLong
argument_list|(
literal|1
argument_list|,
name|info
operator|.
name|id
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|updCount
init|=
name|pStmt
operator|.
name|executeUpdate
argument_list|()
decl_stmt|;
if|if
condition|(
name|updCount
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to delete compaction record: "
operator|+
name|info
operator|+
literal|".  Update count="
operator|+
name|updCount
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
name|pStmt
operator|=
name|dbConn
operator|.
name|prepareStatement
argument_list|(
literal|"INSERT INTO \"COMPLETED_COMPACTIONS\"(\"CC_ID\", \"CC_DATABASE\", "
operator|+
literal|"\"CC_TABLE\", \"CC_PARTITION\", \"CC_STATE\", \"CC_TYPE\", \"CC_TBLPROPERTIES\", \"CC_WORKER_ID\", "
operator|+
literal|"\"CC_START\", \"CC_END\", \"CC_RUN_AS\", \"CC_HIGHEST_WRITE_ID\", \"CC_META_INFO\", "
operator|+
literal|"\"CC_HADOOP_JOB_ID\", \"CC_ERROR_MESSAGE\")"
operator|+
literal|" VALUES(?,?,?,?,?, ?,?,?,?,?, ?,?,?,?,?)"
argument_list|)
expr_stmt|;
name|info
operator|.
name|state
operator|=
name|SUCCEEDED_STATE
expr_stmt|;
name|CompactionInfo
operator|.
name|insertIntoCompletedCompactions
argument_list|(
name|pStmt
argument_list|,
name|info
argument_list|,
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
argument_list|)
expr_stmt|;
name|updCount
operator|=
name|pStmt
operator|.
name|executeUpdate
argument_list|()
expr_stmt|;
comment|// Remove entries from completed_txn_components as well, so we don't start looking there
comment|// again but only up to the highest write ID include in this compaction job.
comment|//highestWriteId will be NULL in upgrade scenarios
name|s
operator|=
literal|"DELETE FROM \"COMPLETED_TXN_COMPONENTS\" WHERE \"CTC_DATABASE\" = ? AND "
operator|+
literal|"\"CTC_TABLE\" = ?"
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|partName
operator|!=
literal|null
condition|)
block|{
name|s
operator|+=
literal|" AND \"CTC_PARTITION\" = ?"
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|.
name|highestWriteId
operator|!=
literal|0
condition|)
block|{
name|s
operator|+=
literal|" AND \"CTC_WRITEID\"<= ?"
expr_stmt|;
block|}
name|pStmt
operator|=
name|dbConn
operator|.
name|prepareStatement
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|int
name|paramCount
init|=
literal|1
decl_stmt|;
name|pStmt
operator|.
name|setString
argument_list|(
name|paramCount
operator|++
argument_list|,
name|info
operator|.
name|dbname
argument_list|)
expr_stmt|;
name|pStmt
operator|.
name|setString
argument_list|(
name|paramCount
operator|++
argument_list|,
name|info
operator|.
name|tableName
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|partName
operator|!=
literal|null
condition|)
block|{
name|pStmt
operator|.
name|setString
argument_list|(
name|paramCount
operator|++
argument_list|,
name|info
operator|.
name|partName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|.
name|highestWriteId
operator|!=
literal|0
condition|)
block|{
name|pStmt
operator|.
name|setLong
argument_list|(
name|paramCount
operator|++
argument_list|,
name|info
operator|.
name|highestWriteId
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|updCount
operator|=
name|pStmt
operator|.
name|executeUpdate
argument_list|()
operator|)
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Expected to remove at least one row from completed_txn_components when "
operator|+
literal|"marking compaction entry as clean!"
argument_list|)
expr_stmt|;
block|}
comment|/**          * compaction may remove data from aborted txns above tc_writeid bit it only guarantees to          * remove it up to (inclusive) tc_writeid, so it's critical to not remove metadata about          * aborted TXN_COMPONENTS above tc_writeid (and consequently about aborted txns).          * See {@link ql.txn.compactor.Cleaner.removeFiles()}          */
name|s
operator|=
literal|"SELECT DISTINCT \"TXN_ID\" FROM \"TXNS\", \"TXN_COMPONENTS\" WHERE \"TXN_ID\" = \"TC_TXNID\" "
operator|+
literal|"AND \"TXN_STATE\" = '"
operator|+
name|TXN_ABORTED
operator|+
literal|"' AND \"TC_DATABASE\" = ? AND \"TC_TABLE\" = ?"
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|highestWriteId
operator|!=
literal|0
condition|)
name|s
operator|+=
literal|" AND \"TC_WRITEID\"<= ?"
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|partName
operator|!=
literal|null
condition|)
name|s
operator|+=
literal|" AND \"TC_PARTITION\" = ?"
expr_stmt|;
name|pStmt
operator|=
name|dbConn
operator|.
name|prepareStatement
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|paramCount
operator|=
literal|1
expr_stmt|;
name|pStmt
operator|.
name|setString
argument_list|(
name|paramCount
operator|++
argument_list|,
name|info
operator|.
name|dbname
argument_list|)
expr_stmt|;
name|pStmt
operator|.
name|setString
argument_list|(
name|paramCount
operator|++
argument_list|,
name|info
operator|.
name|tableName
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|highestWriteId
operator|!=
literal|0
condition|)
block|{
name|pStmt
operator|.
name|setLong
argument_list|(
name|paramCount
operator|++
argument_list|,
name|info
operator|.
name|highestWriteId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|.
name|partName
operator|!=
literal|null
condition|)
block|{
name|pStmt
operator|.
name|setString
argument_list|(
name|paramCount
operator|++
argument_list|,
name|info
operator|.
name|partName
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|pStmt
operator|.
name|executeQuery
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|txnids
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|questions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|long
name|id
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|txnids
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|questions
operator|.
name|add
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
block|}
comment|// Remove entries from txn_components, as there may be aborted txn components
if|if
condition|(
name|txnids
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|queries
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Prepare prefix and suffix
name|StringBuilder
name|prefix
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|StringBuilder
name|suffix
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|prefix
operator|.
name|append
argument_list|(
literal|"DELETE FROM \"TXN_COMPONENTS\" WHERE "
argument_list|)
expr_stmt|;
comment|//because 1 txn may include different partitions/tables even in auto commit mode
name|suffix
operator|.
name|append
argument_list|(
literal|" AND \"TC_DATABASE\" = ?"
argument_list|)
expr_stmt|;
name|suffix
operator|.
name|append
argument_list|(
literal|" AND \"TC_TABLE\" = ?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|partName
operator|!=
literal|null
condition|)
block|{
name|suffix
operator|.
name|append
argument_list|(
literal|" AND \"TC_PARTITION\" = ?"
argument_list|)
expr_stmt|;
block|}
comment|// Populate the complete query with provided prefix and suffix
name|List
argument_list|<
name|Integer
argument_list|>
name|counts
init|=
name|TxnUtils
operator|.
name|buildQueryWithINClauseStrings
argument_list|(
name|conf
argument_list|,
name|queries
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|,
name|questions
argument_list|,
literal|"\"TC_TXNID\""
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|totalCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queries
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|query
init|=
name|queries
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|insertCount
init|=
name|counts
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|query
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|pStmt
operator|=
name|dbConn
operator|.
name|prepareStatement
argument_list|(
name|query
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|insertCount
condition|;
name|j
operator|++
control|)
block|{
name|pStmt
operator|.
name|setLong
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|txnids
operator|.
name|get
argument_list|(
name|totalCount
operator|+
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|totalCount
operator|+=
name|insertCount
expr_stmt|;
name|paramCount
operator|=
name|insertCount
operator|+
literal|1
expr_stmt|;
name|pStmt
operator|.
name|setString
argument_list|(
name|paramCount
operator|++
argument_list|,
name|info
operator|.
name|dbname
argument_list|)
expr_stmt|;
name|pStmt
operator|.
name|setString
argument_list|(
name|paramCount
operator|++
argument_list|,
name|info
operator|.
name|tableName
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|partName
operator|!=
literal|null
condition|)
block|{
name|pStmt
operator|.
name|setString
argument_list|(
name|paramCount
operator|++
argument_list|,
name|info
operator|.
name|partName
argument_list|)
expr_stmt|;
block|}
name|int
name|rc
init|=
name|pStmt
operator|.
name|executeUpdate
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removed "
operator|+
name|rc
operator|+
literal|" records from txn_components"
argument_list|)
expr_stmt|;
comment|// Don't bother cleaning from the txns table.  A separate call will do that.  We don't
comment|// know here which txns still have components from other tables or partitions in the
comment|// table, so we don't know which ones we can and cannot clean.
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to delete from compaction queue "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"markCleaned("
operator|+
name|info
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|pStmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|markCleaned
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Clean up entries from TXN_TO_WRITE_ID table less than min_uncommited_txnid as found by    * min(NEXT_TXN_ID.ntxn_next, min(MIN_HISTORY_LEVEL.mhl_min_open_txnid), min(Aborted TXNS.txn_id)).    */
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|SafeToRetry
specifier|public
name|void
name|cleanTxnToWriteIdTable
parameter_list|()
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// We query for minimum values in all the queries and they can only increase by any concurrent
comment|// operations. So, READ COMMITTED is sufficient.
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
comment|// First need to find the min_uncommitted_txnid which is currently seen by any open transactions.
comment|// If there are no txns which are currently open or aborted in the system, then current value of
comment|// NEXT_TXN_ID.ntxn_next could be min_uncommitted_txnid.
name|long
name|minUncommittedTxnId
init|=
name|findMinOpenTxnGLB
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
comment|// If there are aborted txns, then the minimum aborted txnid could be the min_uncommitted_txnid
comment|// if lesser than both NEXT_TXN_ID.ntxn_next and min(MIN_HISTORY_LEVEL .mhl_min_open_txnid).
name|String
name|s
init|=
literal|"SELECT MIN(\"TXN_ID\") FROM \"TXNS\" WHERE \"TXN_STATE\" = "
operator|+
name|quoteChar
argument_list|(
name|TXN_ABORTED
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|long
name|minAbortedTxnId
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|minAbortedTxnId
operator|>
literal|0
condition|)
block|{
name|minUncommittedTxnId
operator|=
name|Math
operator|.
name|min
argument_list|(
name|minAbortedTxnId
argument_list|,
name|minUncommittedTxnId
argument_list|)
expr_stmt|;
block|}
block|}
comment|// As all txns below min_uncommitted_txnid are either committed or empty_aborted, we are allowed
comment|// to cleanup the entries less than min_uncommitted_txnid from the TXN_TO_WRITE_ID table.
name|s
operator|=
literal|"DELETE FROM \"TXN_TO_WRITE_ID\" WHERE \"T2W_TXNID\"< "
operator|+
name|minUncommittedTxnId
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute delete<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Removed "
operator|+
name|rc
operator|+
literal|" rows from TXN_TO_WRITE_ID with Txn Low-Water-Mark: "
operator|+
name|minUncommittedTxnId
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to delete from txns table "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"cleanTxnToWriteIdTable"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|cleanTxnToWriteIdTable
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Clean up aborted transactions from txns that have no components in txn_components. The reason such    * txns exist can be that now work was done in this txn (e.g. Streaming opened TransactionBatch and    * abandoned it w/o doing any work) or due to {@link #markCleaned(CompactionInfo)} being called.    */
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|SafeToRetry
specifier|public
name|void
name|cleanEmptyAbortedTxns
parameter_list|()
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|//Aborted is a terminal state, so nothing about the txn can change
comment|//after that, so READ COMMITTED is sufficient.
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"SELECT \"TXN_ID\" FROM \"TXNS\" WHERE "
operator|+
literal|"\"TXN_ID\" NOT IN (SELECT \"TC_TXNID\" FROM \"TXN_COMPONENTS\") AND "
operator|+
literal|"\"TXN_STATE\" = '"
operator|+
name|TXN_ABORTED
operator|+
literal|"'"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute query<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|txnids
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
name|txnids
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|txnids
operator|.
name|size
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return;
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|txnids
argument_list|)
expr_stmt|;
comment|//easier to read logs
name|List
argument_list|<
name|String
argument_list|>
name|queries
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|StringBuilder
name|prefix
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|StringBuilder
name|suffix
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// Delete from TXNS.
name|prefix
operator|.
name|append
argument_list|(
literal|"DELETE FROM \"TXNS\" WHERE "
argument_list|)
expr_stmt|;
name|suffix
operator|.
name|append
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|TxnUtils
operator|.
name|buildQueryWithINClause
argument_list|(
name|conf
argument_list|,
name|queries
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|,
name|txnids
argument_list|,
literal|"\"TXN_ID\""
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|query
range|:
name|queries
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|query
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Removed "
operator|+
name|rc
operator|+
literal|"  empty Aborted transactions from TXNS"
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Aborted transactions removed from TXNS: "
operator|+
name|txnids
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to delete from txns table "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"cleanEmptyAbortedTxns"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|cleanEmptyAbortedTxns
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * This will take all entries assigned to workers    * on a host return them to INITIATED state.  The initiator should use this at start up to    * clean entries from any workers that were in the middle of compacting when the metastore    * shutdown.  It does not reset entries from worker threads on other hosts as those may still    * be working.    * @param hostname Name of this host.  It is assumed this prefixes the thread's worker id,    *                 so that like hostname% will match the worker id.    */
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|Idempotent
specifier|public
name|void
name|revokeFromLocalWorkers
parameter_list|(
name|String
name|hostname
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"UPDATE \"COMPACTION_QUEUE\" SET \"CQ_WORKER_ID\" = NULL, \"CQ_START\" = NULL, \"CQ_STATE\" = '"
operator|+
name|INITIATED_STATE
operator|+
literal|"' WHERE \"CQ_STATE\" = '"
operator|+
name|WORKING_STATE
operator|+
literal|"' AND \"CQ_WORKER_ID\" LIKE '"
operator|+
name|hostname
operator|+
literal|"%'"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
comment|// It isn't an error if the following returns no rows, as the local workers could have died
comment|// with  nothing assigned to them.
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to change dead worker's records back to initiated state "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"revokeFromLocalWorkers(hostname:"
operator|+
name|hostname
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|revokeFromLocalWorkers
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This call will return all compaction queue    * entries assigned to a worker but over the timeout back to the initiated state.    * This should be called by the initiator on start up and occasionally when running to clean up    * after dead threads.  At start up {@link #revokeFromLocalWorkers(String)} should be called    * first.    * @param timeout number of milliseconds since start time that should elapse before a worker is    *                declared dead.    */
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|Idempotent
specifier|public
name|void
name|revokeTimedoutWorkers
parameter_list|(
name|long
name|timeout
parameter_list|)
throws|throws
name|MetaException
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|long
name|latestValidStart
init|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
operator|-
name|timeout
decl_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"UPDATE \"COMPACTION_QUEUE\" SET \"CQ_WORKER_ID\" = NULL, \"CQ_START\" = NULL, \"CQ_STATE\" = '"
operator|+
name|INITIATED_STATE
operator|+
literal|"' WHERE \"CQ_STATE\" = '"
operator|+
name|WORKING_STATE
operator|+
literal|"' AND \"CQ_START\"< "
operator|+
name|latestValidStart
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
comment|// It isn't an error if the following returns no rows, as the local workers could have died
comment|// with  nothing assigned to them.
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to change dead worker's records back to initiated state "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"revokeTimedoutWorkers(timeout:"
operator|+
name|timeout
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|closeDbConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|revokeTimedoutWorkers
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Queries metastore DB directly to find columns in the table which have statistics information.    * If {@code ci} includes partition info then per partition stats info is examined, otherwise    * table level stats are examined.    * @throws MetaException    */
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|ReadOnly
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|findColumnsWithStats
parameter_list|(
name|CompactionInfo
name|ci
parameter_list|)
throws|throws
name|MetaException
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|PreparedStatement
name|pStmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|String
name|quote
init|=
name|getIdentifierQuoteString
argument_list|(
name|dbConn
argument_list|)
decl_stmt|;
name|StringBuilder
name|bldr
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|bldr
operator|.
name|append
argument_list|(
literal|"SELECT "
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|"COLUMN_NAME"
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|" FROM "
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
operator|(
name|ci
operator|.
name|partName
operator|==
literal|null
condition|?
literal|"TAB_COL_STATS"
else|:
literal|"PART_COL_STATS"
operator|)
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|" WHERE "
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|"DB_NAME"
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|" = ?"
argument_list|)
operator|.
name|append
argument_list|(
literal|" AND "
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|"TABLE_NAME"
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|" = ?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|.
name|partName
operator|!=
literal|null
condition|)
block|{
name|bldr
operator|.
name|append
argument_list|(
literal|" AND "
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|"PARTITION_NAME"
argument_list|)
operator|.
name|append
argument_list|(
name|quote
argument_list|)
operator|.
name|append
argument_list|(
literal|" = ?"
argument_list|)
expr_stmt|;
block|}
name|String
name|s
init|=
name|bldr
operator|.
name|toString
argument_list|()
decl_stmt|;
name|pStmt
operator|=
name|dbConn
operator|.
name|prepareStatement
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|pStmt
operator|.
name|setString
argument_list|(
literal|1
argument_list|,
name|ci
operator|.
name|dbname
argument_list|)
expr_stmt|;
name|pStmt
operator|.
name|setString
argument_list|(
literal|2
argument_list|,
name|ci
operator|.
name|tableName
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|.
name|partName
operator|!=
literal|null
condition|)
block|{
name|pStmt
operator|.
name|setString
argument_list|(
literal|3
argument_list|,
name|ci
operator|.
name|partName
argument_list|)
expr_stmt|;
block|}
comment|/*String s = "SELECT COLUMN_NAME FROM " + (ci.partName == null ? "TAB_COL_STATS" :           "PART_COL_STATS")          + " WHERE DB_NAME='" + ci.dbname + "' AND TABLE_NAME='" + ci.tableName + "'"         + (ci.partName == null ? "" : " AND PARTITION_NAME='" + ci.partName + "'");*/
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|pStmt
operator|.
name|executeQuery
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|columns
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|columns
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found columns to update stats: "
operator|+
name|columns
operator|+
literal|" on "
operator|+
name|ci
operator|.
name|tableName
operator|+
operator|(
name|ci
operator|.
name|partName
operator|==
literal|null
condition|?
literal|""
else|:
literal|"/"
operator|+
name|ci
operator|.
name|partName
operator|)
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
name|columns
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"findColumnsWithStats("
operator|+
name|ci
operator|.
name|tableName
operator|+
operator|(
name|ci
operator|.
name|partName
operator|==
literal|null
condition|?
literal|""
else|:
literal|"/"
operator|+
name|ci
operator|.
name|partName
operator|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|pStmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|ex
parameter_list|)
block|{
return|return
name|findColumnsWithStats
argument_list|(
name|ci
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|updateCompactorState
parameter_list|(
name|CompactionInfo
name|ci
parameter_list|,
name|long
name|compactionTxnId
parameter_list|)
throws|throws
name|MetaException
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|sqlText
init|=
literal|"UPDATE \"COMPACTION_QUEUE\" SET \"CQ_HIGHEST_WRITE_ID\" = "
operator|+
name|ci
operator|.
name|highestWriteId
operator|+
literal|", \"CQ_RUN_AS\" = "
operator|+
name|quoteString
argument_list|(
name|ci
operator|.
name|runAs
argument_list|)
operator|+
literal|" WHERE \"CQ_ID\" = "
operator|+
name|ci
operator|.
name|id
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"About to execute: "
operator|+
name|sqlText
argument_list|)
expr_stmt|;
block|}
name|int
name|updCount
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|sqlText
argument_list|)
decl_stmt|;
if|if
condition|(
name|updCount
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Could not find record in COMPACTION_QUEUE for "
operator|+
name|ci
argument_list|)
throw|;
block|}
comment|/*We make an entry in TXN_COMPONENTS for the partition/table that the compactor is         * working on in case this txn aborts and so we need to ensure that its TXNS entry is         * not removed until Cleaner has removed all files that this txn may have written, i.e.         * make it work the same way as any other write.  TC_WRITEID is set to the highest         * WriteId that this compactor run considered since there compactor doesn't allocate         * a new write id (so as not to invalidate result set caches/materialized views) but         * we need to set it to something to that markCleaned() only cleans TXN_COMPONENTS up to         * the level to which aborted files/data has been cleaned.*/
name|sqlText
operator|=
literal|"INSERT INTO \"TXN_COMPONENTS\"("
operator|+
literal|"\"TC_TXNID\", "
operator|+
literal|"\"TC_DATABASE\", "
operator|+
literal|"\"TC_TABLE\", "
operator|+
operator|(
name|ci
operator|.
name|partName
operator|==
literal|null
condition|?
literal|""
else|:
literal|"\"TC_PARTITION\", "
operator|)
operator|+
literal|"\"TC_WRITEID\", "
operator|+
literal|"\"TC_OPERATION_TYPE\")"
operator|+
literal|" VALUES("
operator|+
name|compactionTxnId
operator|+
literal|","
operator|+
name|quoteString
argument_list|(
name|ci
operator|.
name|dbname
argument_list|)
operator|+
literal|","
operator|+
name|quoteString
argument_list|(
name|ci
operator|.
name|tableName
argument_list|)
operator|+
literal|","
operator|+
operator|(
name|ci
operator|.
name|partName
operator|==
literal|null
condition|?
literal|""
else|:
name|quoteString
argument_list|(
name|ci
operator|.
name|partName
argument_list|)
operator|+
literal|","
operator|)
operator|+
name|ci
operator|.
name|highestWriteId
operator|+
literal|", "
operator|+
name|quoteChar
argument_list|(
name|OperationType
operator|.
name|COMPACT
operator|.
name|getSqlConst
argument_list|()
argument_list|)
operator|+
literal|")"
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"About to execute: "
operator|+
name|sqlText
argument_list|)
expr_stmt|;
block|}
name|updCount
operator|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|sqlText
argument_list|)
expr_stmt|;
if|if
condition|(
name|updCount
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Could not find record in COMPACTION_QUEUE for "
operator|+
name|ci
argument_list|)
throw|;
block|}
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"updateCompactorState("
operator|+
name|ci
operator|+
literal|","
operator|+
name|compactionTxnId
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
literal|null
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|ex
parameter_list|)
block|{
name|updateCompactorState
argument_list|(
name|ci
argument_list|,
name|compactionTxnId
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
class|class
name|RetentionCounters
block|{
name|int
name|attemptedRetention
init|=
literal|0
decl_stmt|;
name|int
name|failedRetention
init|=
literal|0
decl_stmt|;
name|int
name|succeededRetention
init|=
literal|0
decl_stmt|;
name|RetentionCounters
parameter_list|(
name|int
name|attemptedRetention
parameter_list|,
name|int
name|failedRetention
parameter_list|,
name|int
name|succeededRetention
parameter_list|)
block|{
name|this
operator|.
name|attemptedRetention
operator|=
name|attemptedRetention
expr_stmt|;
name|this
operator|.
name|failedRetention
operator|=
name|failedRetention
expr_stmt|;
name|this
operator|.
name|succeededRetention
operator|=
name|succeededRetention
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkForDeletion
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|deleteSet
parameter_list|,
name|CompactionInfo
name|ci
parameter_list|,
name|RetentionCounters
name|rc
parameter_list|)
block|{
switch|switch
condition|(
name|ci
operator|.
name|state
condition|)
block|{
case|case
name|ATTEMPTED_STATE
case|:
if|if
condition|(
operator|--
name|rc
operator|.
name|attemptedRetention
operator|<
literal|0
condition|)
block|{
name|deleteSet
operator|.
name|add
argument_list|(
name|ci
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FAILED_STATE
case|:
if|if
condition|(
operator|--
name|rc
operator|.
name|failedRetention
operator|<
literal|0
condition|)
block|{
name|deleteSet
operator|.
name|add
argument_list|(
name|ci
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SUCCEEDED_STATE
case|:
if|if
condition|(
operator|--
name|rc
operator|.
name|succeededRetention
operator|<
literal|0
condition|)
block|{
name|deleteSet
operator|.
name|add
argument_list|(
name|ci
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|//do nothing to hanlde future RU/D where we may want to add new state types
block|}
block|}
comment|/**    * For any given compactable entity (partition; table if not partitioned) the history of compactions    * may look like "sssfffaaasffss", for example.  The idea is to retain the tail (most recent) of the    * history such that a configurable number of each type of state is present.  Any other entries    * can be purged.  This scheme has advantage of always retaining the last failure/success even if    * it's not recent.    * @throws MetaException    */
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|SafeToRetry
specifier|public
name|void
name|purgeCompactionHistory
parameter_list|()
throws|throws
name|MetaException
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|PreparedStatement
name|pStmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|deleteSet
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|RetentionCounters
name|rc
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
comment|/*cc_id is monotonically increasing so for any entity sorts in order of compaction history,         thus this query groups by entity and withing group sorts most recent first*/
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
literal|"SELECT \"CC_ID\", \"CC_DATABASE\", \"CC_TABLE\", \"CC_PARTITION\", \"CC_STATE\" "
operator|+
literal|"FROM \"COMPLETED_COMPACTIONS\" ORDER BY \"CC_DATABASE\", \"CC_TABLE\", \"CC_PARTITION\", \"CC_ID\" DESC"
argument_list|)
expr_stmt|;
name|String
name|lastCompactedEntity
init|=
literal|null
decl_stmt|;
comment|/*In each group, walk from most recent and count occurences of each state type.  Once you         * have counted enough (for each state) to satisfy retention policy, delete all other         * instances of this status.*/
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|CompactionInfo
name|ci
init|=
operator|new
name|CompactionInfo
argument_list|(
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
argument_list|,
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
argument_list|,
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
argument_list|,
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
argument_list|,
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ci
operator|.
name|getFullPartitionName
argument_list|()
operator|.
name|equals
argument_list|(
name|lastCompactedEntity
argument_list|)
condition|)
block|{
name|lastCompactedEntity
operator|=
name|ci
operator|.
name|getFullPartitionName
argument_list|()
expr_stmt|;
name|rc
operator|=
operator|new
name|RetentionCounters
argument_list|(
name|MetastoreConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_ATTEMPTED
argument_list|)
argument_list|,
name|getFailedCompactionRetention
argument_list|()
argument_list|,
name|MetastoreConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_SUCCEEDED
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|checkForDeletion
argument_list|(
name|deleteSet
argument_list|,
name|ci
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleteSet
operator|.
name|size
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|queries
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|StringBuilder
name|prefix
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|StringBuilder
name|suffix
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|prefix
operator|.
name|append
argument_list|(
literal|"DELETE FROM \"COMPLETED_COMPACTIONS\" WHERE "
argument_list|)
expr_stmt|;
name|suffix
operator|.
name|append
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|questions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|deleteSet
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|deleteSet
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|questions
operator|.
name|add
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|counts
init|=
name|TxnUtils
operator|.
name|buildQueryWithINClauseStrings
argument_list|(
name|conf
argument_list|,
name|queries
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|,
name|questions
argument_list|,
literal|"\"CC_ID\""
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|totalCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queries
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|query
init|=
name|queries
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|insertCount
init|=
name|counts
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|query
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|pStmt
operator|=
name|dbConn
operator|.
name|prepareStatement
argument_list|(
name|query
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|insertCount
condition|;
name|j
operator|++
control|)
block|{
name|pStmt
operator|.
name|setLong
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|deleteSet
operator|.
name|get
argument_list|(
name|totalCount
operator|+
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|totalCount
operator|+=
name|insertCount
expr_stmt|;
name|int
name|count
init|=
name|pStmt
operator|.
name|executeUpdate
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removed "
operator|+
name|count
operator|+
literal|" records from COMPLETED_COMPACTIONS"
argument_list|)
expr_stmt|;
block|}
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"purgeCompactionHistory()"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MetaException
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|ex
parameter_list|)
block|{
name|purgeCompactionHistory
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * this ensures that the number of failed compaction entries retained is> than number of failed    * compaction threshold which prevents new compactions from being scheduled.    */
specifier|private
name|int
name|getFailedCompactionRetention
parameter_list|()
block|{
name|int
name|failedThreshold
init|=
name|MetastoreConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|COMPACTOR_INITIATOR_FAILED_THRESHOLD
argument_list|)
decl_stmt|;
name|int
name|failedRetention
init|=
name|MetastoreConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_FAILED
argument_list|)
decl_stmt|;
if|if
condition|(
name|failedRetention
operator|<
name|failedThreshold
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Invalid configuration "
operator|+
name|ConfVars
operator|.
name|COMPACTOR_INITIATOR_FAILED_THRESHOLD
operator|.
name|getVarname
argument_list|()
operator|+
literal|"="
operator|+
name|failedRetention
operator|+
literal|"< "
operator|+
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_FAILED
operator|+
literal|"="
operator|+
name|failedRetention
operator|+
literal|".  Will use "
operator|+
name|ConfVars
operator|.
name|COMPACTOR_INITIATOR_FAILED_THRESHOLD
operator|.
name|getVarname
argument_list|()
operator|+
literal|"="
operator|+
name|failedRetention
argument_list|)
expr_stmt|;
name|failedRetention
operator|=
name|failedThreshold
expr_stmt|;
block|}
return|return
name|failedRetention
return|;
block|}
comment|/**    * Returns {@code true} if there already exists sufficient number of consecutive failures for    * this table/partition so that no new automatic compactions will be scheduled.    * User initiated compactions don't do this check.    *    * Do we allow compacting whole table (when it's partitioned)?  No, though perhaps we should.    * That would be a meta operations, i.e. first find all partitions for this table (which have    * txn info) and schedule each compaction separately.  This avoids complications in this logic.    */
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|ReadOnly
specifier|public
name|boolean
name|checkFailedCompactions
parameter_list|(
name|CompactionInfo
name|ci
parameter_list|)
throws|throws
name|MetaException
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|PreparedStatement
name|pStmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|pStmt
operator|=
name|dbConn
operator|.
name|prepareStatement
argument_list|(
literal|"SELECT \"CC_STATE\" FROM \"COMPLETED_COMPACTIONS\" WHERE "
operator|+
literal|"\"CC_DATABASE\" = ? AND "
operator|+
literal|"\"CC_TABLE\" = ? "
operator|+
operator|(
name|ci
operator|.
name|partName
operator|!=
literal|null
condition|?
literal|"AND \"CC_PARTITION\" = ?"
else|:
literal|""
operator|)
operator|+
literal|" AND \"CC_STATE\" != "
operator|+
name|quoteChar
argument_list|(
name|ATTEMPTED_STATE
argument_list|)
operator|+
literal|" ORDER BY \"CC_ID\" DESC"
argument_list|)
expr_stmt|;
name|pStmt
operator|.
name|setString
argument_list|(
literal|1
argument_list|,
name|ci
operator|.
name|dbname
argument_list|)
expr_stmt|;
name|pStmt
operator|.
name|setString
argument_list|(
literal|2
argument_list|,
name|ci
operator|.
name|tableName
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|.
name|partName
operator|!=
literal|null
condition|)
block|{
name|pStmt
operator|.
name|setString
argument_list|(
literal|3
argument_list|,
name|ci
operator|.
name|partName
argument_list|)
expr_stmt|;
block|}
name|rs
operator|=
name|pStmt
operator|.
name|executeQuery
argument_list|()
expr_stmt|;
name|int
name|numFailed
init|=
literal|0
decl_stmt|;
name|int
name|numTotal
init|=
literal|0
decl_stmt|;
name|int
name|failedThreshold
init|=
name|MetastoreConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|COMPACTOR_INITIATOR_FAILED_THRESHOLD
argument_list|)
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
operator|&&
operator|++
name|numTotal
operator|<=
name|failedThreshold
condition|)
block|{
if|if
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|FAILED_STATE
condition|)
block|{
name|numFailed
operator|++
expr_stmt|;
block|}
else|else
block|{
name|numFailed
operator|--
expr_stmt|;
block|}
block|}
return|return
name|numFailed
operator|==
name|failedThreshold
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to check for failed compactions "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"checkFailedCompactions("
operator|+
name|ci
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
comment|//weren't able to check
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|pStmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
return|return
name|checkFailedCompactions
argument_list|(
name|ci
argument_list|)
return|;
block|}
block|}
comment|/**    * If there is an entry in compaction_queue with ci.id, remove it    * Make entry in completed_compactions with status 'f'.    * If there is no entry in compaction_queue, it means Initiator failed to even schedule a compaction,    * which we record as ATTEMPTED_STATE entry in history.    */
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|CannotRetry
specifier|public
name|void
name|markFailed
parameter_list|(
name|CompactionInfo
name|ci
parameter_list|)
throws|throws
name|MetaException
block|{
comment|//todo: this should not throw
comment|//todo: this should take "comment" as parameter to set in CC_META_INFO to provide some context for the failure
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
name|PreparedStatement
name|pStmt
init|=
literal|null
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
comment|// the error message related to the failure is wrapped inside CompactionInfo
comment|// fetch this info, since ci will be reused in subsequent queries
name|String
name|errorMessage
init|=
name|ci
operator|.
name|errorMessage
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|pStmt
operator|=
name|dbConn
operator|.
name|prepareStatement
argument_list|(
literal|"SELECT \"CQ_ID\", \"CQ_DATABASE\", \"CQ_TABLE\", \"CQ_PARTITION\", "
operator|+
literal|"\"CQ_STATE\", \"CQ_TYPE\", \"CQ_TBLPROPERTIES\", \"CQ_WORKER_ID\", \"CQ_START\", \"CQ_RUN_AS\", "
operator|+
literal|"\"CQ_HIGHEST_WRITE_ID\", \"CQ_META_INFO\", \"CQ_HADOOP_JOB_ID\", \"CQ_ERROR_MESSAGE\" "
operator|+
literal|"FROM \"COMPACTION_QUEUE\" WHERE \"CQ_ID\" = ?"
argument_list|)
expr_stmt|;
name|pStmt
operator|.
name|setLong
argument_list|(
literal|1
argument_list|,
name|ci
operator|.
name|id
argument_list|)
expr_stmt|;
name|rs
operator|=
name|pStmt
operator|.
name|executeQuery
argument_list|()
expr_stmt|;
if|if
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|ci
operator|=
name|CompactionInfo
operator|.
name|loadFullFromCompactionQueue
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|String
name|s
init|=
literal|"DELETE FROM \"COMPACTION_QUEUE\" WHERE \"CQ_ID\" = ?"
decl_stmt|;
name|pStmt
operator|=
name|dbConn
operator|.
name|prepareStatement
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|pStmt
operator|.
name|setLong
argument_list|(
literal|1
argument_list|,
name|ci
operator|.
name|id
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute update<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|updCnt
init|=
name|pStmt
operator|.
name|executeUpdate
argument_list|()
decl_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ci
operator|.
name|id
operator|>
literal|0
condition|)
block|{
comment|//the record with valid CQ_ID has disappeared - this is a sign of something wrong
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"No record with CQ_ID="
operator|+
name|ci
operator|.
name|id
operator|+
literal|" found in COMPACTION_QUEUE"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|ci
operator|.
name|id
operator|==
literal|0
condition|)
block|{
comment|//The failure occurred before we even made an entry in COMPACTION_QUEUE
comment|//generate ID so that we can make an entry in COMPLETED_COMPACTIONS
name|ci
operator|.
name|id
operator|=
name|generateCompactionQueueId
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|//mostly this indicates that the Initiator is paying attention to some table even though
comment|//compactions are not happening.
name|ci
operator|.
name|state
operator|=
name|ATTEMPTED_STATE
expr_stmt|;
comment|//this is not strictly accurate, but 'type' cannot be null.
if|if
condition|(
name|ci
operator|.
name|type
operator|==
literal|null
condition|)
block|{
name|ci
operator|.
name|type
operator|=
name|CompactionType
operator|.
name|MINOR
expr_stmt|;
block|}
name|ci
operator|.
name|start
operator|=
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ci
operator|.
name|state
operator|=
name|FAILED_STATE
expr_stmt|;
block|}
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|pStmt
operator|=
name|dbConn
operator|.
name|prepareStatement
argument_list|(
literal|"INSERT INTO \"COMPLETED_COMPACTIONS\" "
operator|+
literal|"(\"CC_ID\", \"CC_DATABASE\", \"CC_TABLE\", \"CC_PARTITION\", \"CC_STATE\", \"CC_TYPE\", "
operator|+
literal|"\"CC_TBLPROPERTIES\", \"CC_WORKER_ID\", \"CC_START\", \"CC_END\", \"CC_RUN_AS\", "
operator|+
literal|"\"CC_HIGHEST_WRITE_ID\", \"CC_META_INFO\", \"CC_HADOOP_JOB_ID\", \"CC_ERROR_MESSAGE\") "
operator|+
literal|"VALUES(?,?,?,?,?, ?,?,?,?,?, ?,?,?,?,?)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorMessage
operator|!=
literal|null
condition|)
block|{
name|ci
operator|.
name|errorMessage
operator|=
name|errorMessage
expr_stmt|;
block|}
name|CompactionInfo
operator|.
name|insertIntoCompletedCompactions
argument_list|(
name|pStmt
argument_list|,
name|ci
argument_list|,
name|getDbTime
argument_list|(
name|dbConn
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|updCount
init|=
name|pStmt
operator|.
name|executeUpdate
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"markFailed("
operator|+
name|ci
operator|.
name|id
operator|+
literal|"):"
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
try|try
block|{
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"markFailed("
operator|+
name|ci
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MetaException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"markFailed("
operator|+
name|ci
operator|+
literal|") failed: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|rs
argument_list|,
name|stmt
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|null
argument_list|,
name|pStmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|markFailed
argument_list|(
name|ci
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|RetrySemantics
operator|.
name|Idempotent
specifier|public
name|void
name|setHadoopJobId
parameter_list|(
name|String
name|hadoopJobId
parameter_list|,
name|long
name|id
parameter_list|)
block|{
try|try
block|{
name|Connection
name|dbConn
init|=
literal|null
decl_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dbConn
operator|=
name|getDbConn
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|dbConn
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|String
name|s
init|=
literal|"UPDATE \"COMPACTION_QUEUE\" SET \"CQ_HADOOP_JOB_ID\" = "
operator|+
name|quoteString
argument_list|(
name|hadoopJobId
argument_list|)
operator|+
literal|" WHERE \"CQ_ID\" = "
operator|+
name|id
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to execute<"
operator|+
name|s
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|int
name|updateCount
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to commit"
argument_list|)
expr_stmt|;
name|closeStmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|dbConn
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"setHadoopJobId("
operator|+
name|hadoopJobId
operator|+
literal|","
operator|+
name|id
operator|+
literal|"):"
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to rollback"
argument_list|)
expr_stmt|;
name|rollbackDBConn
argument_list|(
name|dbConn
argument_list|)
expr_stmt|;
try|try
block|{
name|checkRetryable
argument_list|(
name|dbConn
argument_list|,
name|e
argument_list|,
literal|"setHadoopJobId("
operator|+
name|hadoopJobId
operator|+
literal|","
operator|+
name|id
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MetaException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to connect to transaction database "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"setHadoopJobId("
operator|+
name|hadoopJobId
operator|+
literal|","
operator|+
name|id
operator|+
literal|") failed: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|close
argument_list|(
literal|null
argument_list|,
name|stmt
argument_list|,
name|dbConn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RetryException
name|e
parameter_list|)
block|{
name|setHadoopJobId
argument_list|(
name|hadoopJobId
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

