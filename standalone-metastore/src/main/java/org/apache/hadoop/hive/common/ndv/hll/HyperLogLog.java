begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ndv
operator|.
name|hll
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ndv
operator|.
name|NumDistinctValueEstimator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|HiveDecimal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|util
operator|.
name|JavaDataModel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|common
operator|.
name|util
operator|.
name|Murmur3
import|;
end_import

begin_comment
comment|/**  *<pre>  * This is an implementation of the following variants of hyperloglog (HLL)  * algorithm   * Original  - Original HLL algorithm from Flajolet et. al from  *             http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf  * HLLNoBias - Google's implementation of bias correction based on lookup table  *             http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/40671.pdf  * HLL++     - Google's implementation of HLL++ algorithm that uses SPARSE registers  *             http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/40671.pdf  *   * Following are the constructor parameters that determines which algorithm is  * used  *<b>numRegisterIndexBits</b> - number of LSB hashcode bits to be used as register index.  *<i>Default is 14</i>. min = 4 and max = 16  *<b>numHashBits</b> - number of bits for hashcode.<i>Default is 64</i>. min = 32 and max = 128  *<b>encoding</b> - Type of encoding to use (SPARSE or DENSE). The algorithm automatically  *            switches to DENSE beyond a threshold.<i>Default: SPARSE</i>  *<b>enableBitPacking</b> - To enable bit packing or not. Bit packing improves compression  *                    at the cost of more CPU cycles.<i>Default: true</i>  *<b>noBias</b> - Use Google's bias table lookup for short range bias correction.  *          Enabling this will highly improve the estimation accuracy for short  *          range values.<i>Default: true</i>  *  *</pre>  */
end_comment

begin_class
specifier|public
class|class
name|HyperLogLog
implements|implements
name|NumDistinctValueEstimator
block|{
specifier|private
specifier|final
specifier|static
name|int
name|DEFAULT_HASH_BITS
init|=
literal|64
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|long
name|HASH64_ZERO
init|=
name|Murmur3
operator|.
name|hash64
argument_list|(
operator|new
name|byte
index|[]
block|{
literal|0
block|}
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|long
name|HASH64_ONE
init|=
name|Murmur3
operator|.
name|hash64
argument_list|(
operator|new
name|byte
index|[]
block|{
literal|1
block|}
argument_list|)
decl_stmt|;
specifier|public
enum|enum
name|EncodingType
block|{
name|SPARSE
block|,
name|DENSE
block|}
comment|// number of bits to address registers
specifier|private
specifier|final
name|int
name|p
decl_stmt|;
comment|// number of registers - 2^p
specifier|private
specifier|final
name|int
name|m
decl_stmt|;
comment|// refer paper
specifier|private
name|float
name|alphaMM
decl_stmt|;
comment|// enable/disable bias correction using table lookup
specifier|private
specifier|final
name|boolean
name|noBias
decl_stmt|;
comment|// enable/disable bitpacking
specifier|private
specifier|final
name|boolean
name|bitPacking
decl_stmt|;
comment|// Not making it configurable for perf reasons (avoid checks)
specifier|private
specifier|final
name|int
name|chosenHashBits
init|=
name|DEFAULT_HASH_BITS
decl_stmt|;
specifier|private
name|HLLDenseRegister
name|denseRegister
decl_stmt|;
specifier|private
name|HLLSparseRegister
name|sparseRegister
decl_stmt|;
comment|// counts are cached to avoid repeated complex computation. If register value
comment|// is updated the count will be computed again.
specifier|private
name|long
name|cachedCount
decl_stmt|;
specifier|private
name|boolean
name|invalidateCount
decl_stmt|;
specifier|private
name|EncodingType
name|encoding
decl_stmt|;
comment|// threshold to switch from SPARSE to DENSE encoding
specifier|private
name|int
name|encodingSwitchThreshold
decl_stmt|;
specifier|private
name|HyperLogLog
parameter_list|(
name|HyperLogLogBuilder
name|hllBuilder
parameter_list|)
block|{
if|if
condition|(
name|hllBuilder
operator|.
name|numRegisterIndexBits
argument_list|<
name|HLLConstants
operator|.
name|MIN_P_VALUE
operator|||
name|hllBuilder
operator|.
name|numRegisterIndexBits
argument_list|>
name|HLLConstants
operator|.
name|MAX_P_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"p value should be between "
operator|+
name|HLLConstants
operator|.
name|MIN_P_VALUE
operator|+
literal|" to "
operator|+
name|HLLConstants
operator|.
name|MAX_P_VALUE
argument_list|)
throw|;
block|}
name|this
operator|.
name|p
operator|=
name|hllBuilder
operator|.
name|numRegisterIndexBits
expr_stmt|;
name|this
operator|.
name|m
operator|=
literal|1
operator|<<
name|p
expr_stmt|;
name|this
operator|.
name|noBias
operator|=
name|hllBuilder
operator|.
name|noBias
expr_stmt|;
name|this
operator|.
name|bitPacking
operator|=
name|hllBuilder
operator|.
name|bitPacking
expr_stmt|;
comment|// the threshold should be less than 12K bytes for p = 14.
comment|// The reason to divide by 5 is, in sparse mode after serialization the
comment|// entriesin sparse map are compressed, and delta encoded as varints. The
comment|// worst case size of varints are 5 bytes. Hence, 12K/5 ~= 2400 entries in
comment|// sparse map.
if|if
condition|(
name|bitPacking
condition|)
block|{
name|this
operator|.
name|encodingSwitchThreshold
operator|=
operator|(
operator|(
name|m
operator|*
literal|6
operator|)
operator|/
literal|8
operator|)
operator|/
literal|5
expr_stmt|;
block|}
else|else
block|{
comment|// if bitpacking is disabled, all register values takes 8 bits and hence
comment|// we can be more flexible with the threshold. For p=14, 16K/5 = 3200
comment|// entries in sparse map can be allowed.
name|this
operator|.
name|encodingSwitchThreshold
operator|=
name|m
operator|/
literal|3
expr_stmt|;
block|}
comment|// initializeAlpha(DEFAULT_HASH_BITS);
comment|// alphaMM value for 128 bits hash seems to perform better for default 64 hash bits
name|this
operator|.
name|alphaMM
operator|=
literal|0.7213f
operator|/
operator|(
literal|1
operator|+
literal|1.079f
operator|/
name|m
operator|)
expr_stmt|;
comment|// For efficiency alpha is multiplied by m^2
name|this
operator|.
name|alphaMM
operator|=
name|this
operator|.
name|alphaMM
operator|*
name|m
operator|*
name|m
expr_stmt|;
name|this
operator|.
name|cachedCount
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|invalidateCount
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|encoding
operator|=
name|hllBuilder
operator|.
name|encoding
expr_stmt|;
if|if
condition|(
name|encoding
operator|.
name|equals
argument_list|(
name|EncodingType
operator|.
name|SPARSE
argument_list|)
condition|)
block|{
name|this
operator|.
name|sparseRegister
operator|=
operator|new
name|HLLSparseRegister
argument_list|(
name|p
argument_list|,
name|HLLConstants
operator|.
name|P_PRIME_VALUE
argument_list|,
name|HLLConstants
operator|.
name|Q_PRIME_VALUE
argument_list|)
expr_stmt|;
name|this
operator|.
name|denseRegister
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|sparseRegister
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|denseRegister
operator|=
operator|new
name|HLLDenseRegister
argument_list|(
name|p
argument_list|,
name|bitPacking
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|HyperLogLogBuilder
name|builder
parameter_list|()
block|{
return|return
operator|new
name|HyperLogLogBuilder
argument_list|()
return|;
block|}
specifier|public
specifier|static
class|class
name|HyperLogLogBuilder
block|{
specifier|private
name|int
name|numRegisterIndexBits
init|=
literal|14
decl_stmt|;
specifier|private
name|EncodingType
name|encoding
init|=
name|EncodingType
operator|.
name|SPARSE
decl_stmt|;
specifier|private
name|boolean
name|bitPacking
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|noBias
init|=
literal|true
decl_stmt|;
specifier|public
name|HyperLogLogBuilder
parameter_list|()
block|{     }
specifier|public
name|HyperLogLogBuilder
name|setNumRegisterIndexBits
parameter_list|(
name|int
name|b
parameter_list|)
block|{
name|this
operator|.
name|numRegisterIndexBits
operator|=
name|b
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|HyperLogLogBuilder
name|setEncoding
parameter_list|(
name|EncodingType
name|enc
parameter_list|)
block|{
name|this
operator|.
name|encoding
operator|=
name|enc
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|HyperLogLogBuilder
name|enableBitPacking
parameter_list|(
name|boolean
name|b
parameter_list|)
block|{
name|this
operator|.
name|bitPacking
operator|=
name|b
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|HyperLogLogBuilder
name|enableNoBias
parameter_list|(
name|boolean
name|nb
parameter_list|)
block|{
name|this
operator|.
name|noBias
operator|=
name|nb
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|HyperLogLog
name|build
parameter_list|()
block|{
return|return
operator|new
name|HyperLogLog
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|// see paper for alpha initialization.
specifier|private
name|void
name|initializeAlpha
parameter_list|(
specifier|final
name|int
name|hashBits
parameter_list|)
block|{
if|if
condition|(
name|hashBits
operator|<=
literal|16
condition|)
block|{
name|alphaMM
operator|=
literal|0.673f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hashBits
operator|<=
literal|32
condition|)
block|{
name|alphaMM
operator|=
literal|0.697f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hashBits
operator|<=
literal|64
condition|)
block|{
name|alphaMM
operator|=
literal|0.709f
expr_stmt|;
block|}
else|else
block|{
name|alphaMM
operator|=
literal|0.7213f
operator|/
call|(
name|float
call|)
argument_list|(
literal|1
operator|+
literal|1.079f
operator|/
name|m
argument_list|)
expr_stmt|;
block|}
comment|// For efficiency alpha is multiplied by m^2
name|alphaMM
operator|=
name|alphaMM
operator|*
name|m
operator|*
name|m
expr_stmt|;
block|}
specifier|public
name|void
name|addBoolean
parameter_list|(
name|boolean
name|val
parameter_list|)
block|{
name|add
argument_list|(
name|val
condition|?
name|HASH64_ONE
else|:
name|HASH64_ZERO
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|addByte
parameter_list|(
name|byte
name|val
parameter_list|)
block|{
name|add
argument_list|(
name|Murmur3
operator|.
name|hash64
argument_list|(
operator|new
name|byte
index|[]
block|{
name|val
block|}
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|addBytes
parameter_list|(
name|byte
index|[]
name|val
parameter_list|)
block|{
name|add
argument_list|(
name|Murmur3
operator|.
name|hash64
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|addShort
parameter_list|(
name|short
name|val
parameter_list|)
block|{
name|add
argument_list|(
name|Murmur3
operator|.
name|hash64
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|addInt
parameter_list|(
name|int
name|val
parameter_list|)
block|{
name|add
argument_list|(
name|Murmur3
operator|.
name|hash64
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|addLong
parameter_list|(
name|long
name|val
parameter_list|)
block|{
name|add
argument_list|(
name|Murmur3
operator|.
name|hash64
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|addFloat
parameter_list|(
name|float
name|val
parameter_list|)
block|{
name|add
argument_list|(
name|Murmur3
operator|.
name|hash64
argument_list|(
name|Float
operator|.
name|floatToIntBits
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|addDouble
parameter_list|(
name|double
name|val
parameter_list|)
block|{
name|add
argument_list|(
name|Murmur3
operator|.
name|hash64
argument_list|(
name|Double
operator|.
name|doubleToLongBits
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|addChar
parameter_list|(
name|char
name|val
parameter_list|)
block|{
name|add
argument_list|(
name|Murmur3
operator|.
name|hash64
argument_list|(
operator|(
name|short
operator|)
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Java's default charset will be used for strings.    * @param val    *          - input string    */
specifier|public
name|void
name|addString
parameter_list|(
name|String
name|val
parameter_list|)
block|{
name|add
argument_list|(
name|Murmur3
operator|.
name|hash64
argument_list|(
name|val
operator|.
name|getBytes
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|addString
parameter_list|(
name|String
name|val
parameter_list|,
name|Charset
name|charset
parameter_list|)
block|{
name|add
argument_list|(
name|Murmur3
operator|.
name|hash64
argument_list|(
name|val
operator|.
name|getBytes
argument_list|(
name|charset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|add
parameter_list|(
name|long
name|hashcode
parameter_list|)
block|{
if|if
condition|(
name|encoding
operator|.
name|equals
argument_list|(
name|EncodingType
operator|.
name|SPARSE
argument_list|)
condition|)
block|{
if|if
condition|(
name|sparseRegister
operator|.
name|add
argument_list|(
name|hashcode
argument_list|)
condition|)
block|{
name|invalidateCount
operator|=
literal|true
expr_stmt|;
block|}
comment|// if size of sparse map excess the threshold convert the sparse map to
comment|// dense register and switch to DENSE encoding
if|if
condition|(
name|sparseRegister
operator|.
name|getSize
argument_list|()
operator|>
name|encodingSwitchThreshold
condition|)
block|{
name|encoding
operator|=
name|EncodingType
operator|.
name|DENSE
expr_stmt|;
name|denseRegister
operator|=
name|sparseToDenseRegister
argument_list|(
name|sparseRegister
argument_list|)
expr_stmt|;
name|sparseRegister
operator|=
literal|null
expr_stmt|;
name|invalidateCount
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|denseRegister
operator|.
name|add
argument_list|(
name|hashcode
argument_list|)
condition|)
block|{
name|invalidateCount
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|long
name|estimateNumDistinctValues
parameter_list|()
block|{
comment|// FMSketch treats the ndv of all nulls as 1 but hll treates the ndv as 0.
comment|// In order to get rid of divide by 0 problem, we follow FMSketch
return|return
name|count
argument_list|()
operator|>
literal|0
condition|?
name|count
argument_list|()
else|:
literal|1
return|;
block|}
specifier|public
name|long
name|count
parameter_list|()
block|{
comment|// compute count only if the register values are updated else return the
comment|// cached count
if|if
condition|(
name|invalidateCount
operator|||
name|cachedCount
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|encoding
operator|.
name|equals
argument_list|(
name|EncodingType
operator|.
name|SPARSE
argument_list|)
condition|)
block|{
comment|// if encoding is still SPARSE use linear counting with increase
comment|// accuracy (as we use pPrime bits for register index)
name|int
name|mPrime
init|=
literal|1
operator|<<
name|sparseRegister
operator|.
name|getPPrime
argument_list|()
decl_stmt|;
name|cachedCount
operator|=
name|linearCount
argument_list|(
name|mPrime
argument_list|,
name|mPrime
operator|-
name|sparseRegister
operator|.
name|getSparseMap
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// for DENSE encoding, use bias table lookup for HLLNoBias algorithm
comment|// else fallback to HLLOriginal algorithm
name|double
name|sum
init|=
name|denseRegister
operator|.
name|getSumInversePow2
argument_list|()
decl_stmt|;
name|long
name|numZeros
init|=
name|denseRegister
operator|.
name|getNumZeroes
argument_list|()
decl_stmt|;
comment|// cardinality estimate from normalized bias corrected harmonic mean on
comment|// the registers
name|cachedCount
operator|=
call|(
name|long
call|)
argument_list|(
name|alphaMM
operator|*
operator|(
literal|1.0
operator|/
name|sum
operator|)
argument_list|)
expr_stmt|;
name|long
name|pow
init|=
operator|(
name|long
operator|)
name|Math
operator|.
name|pow
argument_list|(
literal|2
argument_list|,
name|chosenHashBits
argument_list|)
decl_stmt|;
comment|// when bias correction is enabled
if|if
condition|(
name|noBias
condition|)
block|{
name|cachedCount
operator|=
name|cachedCount
operator|<=
literal|5
operator|*
name|m
condition|?
operator|(
name|cachedCount
operator|-
name|estimateBias
argument_list|(
name|cachedCount
argument_list|)
operator|)
else|:
name|cachedCount
expr_stmt|;
name|long
name|h
init|=
name|cachedCount
decl_stmt|;
if|if
condition|(
name|numZeros
operator|!=
literal|0
condition|)
block|{
name|h
operator|=
name|linearCount
argument_list|(
name|m
argument_list|,
name|numZeros
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|<
name|getThreshold
argument_list|()
condition|)
block|{
name|cachedCount
operator|=
name|h
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// HLL algorithm shows stronger bias for values in (2.5 * m) range.
comment|// To compensate for this short range bias, linear counting is used
comment|// for values before this short range. The original paper also says
comment|// similar bias is seen for long range values due to hash collisions
comment|// in range>1/30*(2^32). For the default case, we do not have to
comment|// worry about this long range bias as the paper used 32-bit hashing
comment|// and we use 64-bit hashing as default. 2^64 values are too high to
comment|// observe long range bias (hash collisions).
if|if
condition|(
name|cachedCount
operator|<=
literal|2.5
operator|*
name|m
condition|)
block|{
comment|// for short range use linear counting
if|if
condition|(
name|numZeros
operator|!=
literal|0
condition|)
block|{
name|cachedCount
operator|=
name|linearCount
argument_list|(
name|m
argument_list|,
name|numZeros
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|chosenHashBits
argument_list|<
literal|64
operator|&&
name|cachedCount
argument_list|>
argument_list|(
literal|0.033333
operator|*
name|pow
argument_list|)
condition|)
block|{
comment|// long range bias for 32-bit hashcodes
if|if
condition|(
name|cachedCount
operator|>
operator|(
literal|1
operator|/
literal|30
operator|)
operator|*
name|pow
condition|)
block|{
name|cachedCount
operator|=
call|(
name|long
call|)
argument_list|(
operator|-
name|pow
operator|*
name|Math
operator|.
name|log
argument_list|(
literal|1.0
operator|-
operator|(
name|double
operator|)
name|cachedCount
operator|/
operator|(
name|double
operator|)
name|pow
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|invalidateCount
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|cachedCount
return|;
block|}
specifier|private
name|long
name|getThreshold
parameter_list|()
block|{
return|return
call|(
name|long
call|)
argument_list|(
name|HLLConstants
operator|.
name|thresholdData
index|[
name|p
operator|-
literal|4
index|]
operator|+
literal|0.5
argument_list|)
return|;
block|}
comment|/**    * Estimate bias from lookup table    * @param count    *          - cardinality before bias correction    * @return cardinality after bias correction    */
specifier|private
name|long
name|estimateBias
parameter_list|(
name|long
name|count
parameter_list|)
block|{
name|double
index|[]
name|rawEstForP
init|=
name|HLLConstants
operator|.
name|rawEstimateData
index|[
name|p
operator|-
literal|4
index|]
decl_stmt|;
comment|// compute distance and store it in sorted map
name|TreeMap
argument_list|<
name|Double
argument_list|,
name|Integer
argument_list|>
name|estIndexMap
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
name|double
name|distance
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rawEstForP
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|distance
operator|=
name|Math
operator|.
name|pow
argument_list|(
name|count
operator|-
name|rawEstForP
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|estIndexMap
operator|.
name|put
argument_list|(
name|distance
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|// take top-k closest neighbors and compute the bias corrected cardinality
name|long
name|result
init|=
literal|0
decl_stmt|;
name|double
index|[]
name|biasForP
init|=
name|HLLConstants
operator|.
name|biasData
index|[
name|p
operator|-
literal|4
index|]
decl_stmt|;
name|double
name|biasSum
init|=
literal|0
decl_stmt|;
name|int
name|kNeighbors
init|=
name|HLLConstants
operator|.
name|K_NEAREST_NEIGHBOR
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Double
argument_list|,
name|Integer
argument_list|>
name|entry
range|:
name|estIndexMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|biasSum
operator|+=
name|biasForP
index|[
name|entry
operator|.
name|getValue
argument_list|()
index|]
expr_stmt|;
name|kNeighbors
operator|--
expr_stmt|;
if|if
condition|(
name|kNeighbors
operator|<=
literal|0
condition|)
block|{
break|break;
block|}
block|}
comment|// 0.5 added for rounding off
name|result
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
name|biasSum
operator|/
name|HLLConstants
operator|.
name|K_NEAREST_NEIGHBOR
operator|)
operator|+
literal|0.5
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|public
name|void
name|setCount
parameter_list|(
name|long
name|count
parameter_list|)
block|{
name|this
operator|.
name|cachedCount
operator|=
name|count
expr_stmt|;
name|this
operator|.
name|invalidateCount
operator|=
literal|true
expr_stmt|;
block|}
specifier|private
name|long
name|linearCount
parameter_list|(
name|int
name|mVal
parameter_list|,
name|long
name|numZeros
parameter_list|)
block|{
return|return
call|(
name|long
call|)
argument_list|(
name|Math
operator|.
name|round
argument_list|(
name|mVal
operator|*
name|Math
operator|.
name|log
argument_list|(
name|mVal
operator|/
operator|(
operator|(
name|double
operator|)
name|numZeros
operator|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|// refer paper
specifier|public
name|double
name|getStandardError
parameter_list|()
block|{
return|return
literal|1.04
operator|/
name|Math
operator|.
name|sqrt
argument_list|(
name|m
argument_list|)
return|;
block|}
specifier|public
name|HLLDenseRegister
name|getHLLDenseRegister
parameter_list|()
block|{
return|return
name|denseRegister
return|;
block|}
specifier|public
name|HLLSparseRegister
name|getHLLSparseRegister
parameter_list|()
block|{
return|return
name|sparseRegister
return|;
block|}
comment|/**    * Reconstruct sparse map from serialized integer list    * @param reg    *          - uncompressed and delta decoded integer list    */
specifier|public
name|void
name|setHLLSparseRegister
parameter_list|(
name|int
index|[]
name|reg
parameter_list|)
block|{
for|for
control|(
name|int
name|i
range|:
name|reg
control|)
block|{
name|int
name|key
init|=
name|i
operator|>>>
name|HLLConstants
operator|.
name|Q_PRIME_VALUE
decl_stmt|;
name|byte
name|value
init|=
call|(
name|byte
call|)
argument_list|(
name|i
operator|&
literal|0x3f
argument_list|)
decl_stmt|;
name|sparseRegister
operator|.
name|set
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Reconstruct dense registers from byte array    * @param reg    *          - unpacked byte array    */
specifier|public
name|void
name|setHLLDenseRegister
parameter_list|(
name|byte
index|[]
name|reg
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|byte
name|b
range|:
name|reg
control|)
block|{
name|denseRegister
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
comment|/**    * Merge the specified hyperloglog to the current one. Encoding switches    * automatically after merge if the encoding switch threshold is exceeded.    * @param hll    *          - hyperloglog to be merged    * @throws IllegalArgumentException    */
specifier|public
name|void
name|merge
parameter_list|(
name|HyperLogLog
name|hll
parameter_list|)
block|{
if|if
condition|(
name|p
operator|!=
name|hll
operator|.
name|p
operator|||
name|chosenHashBits
operator|!=
name|hll
operator|.
name|chosenHashBits
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"HyperLogLog cannot be merged as either p or hashbits are different. Current: "
operator|+
name|toString
argument_list|()
operator|+
literal|" Provided: "
operator|+
name|hll
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|EncodingType
name|otherEncoding
init|=
name|hll
operator|.
name|getEncoding
argument_list|()
decl_stmt|;
if|if
condition|(
name|encoding
operator|.
name|equals
argument_list|(
name|EncodingType
operator|.
name|SPARSE
argument_list|)
operator|&&
name|otherEncoding
operator|.
name|equals
argument_list|(
name|EncodingType
operator|.
name|SPARSE
argument_list|)
condition|)
block|{
name|sparseRegister
operator|.
name|merge
argument_list|(
name|hll
operator|.
name|getHLLSparseRegister
argument_list|()
argument_list|)
expr_stmt|;
comment|// if after merge the sparse switching threshold is exceeded then change
comment|// to dense encoding
if|if
condition|(
name|sparseRegister
operator|.
name|getSize
argument_list|()
operator|>
name|encodingSwitchThreshold
condition|)
block|{
name|encoding
operator|=
name|EncodingType
operator|.
name|DENSE
expr_stmt|;
name|denseRegister
operator|=
name|sparseToDenseRegister
argument_list|(
name|sparseRegister
argument_list|)
expr_stmt|;
name|sparseRegister
operator|=
literal|null
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|encoding
operator|.
name|equals
argument_list|(
name|EncodingType
operator|.
name|DENSE
argument_list|)
operator|&&
name|otherEncoding
operator|.
name|equals
argument_list|(
name|EncodingType
operator|.
name|DENSE
argument_list|)
condition|)
block|{
name|denseRegister
operator|.
name|merge
argument_list|(
name|hll
operator|.
name|getHLLDenseRegister
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|encoding
operator|.
name|equals
argument_list|(
name|EncodingType
operator|.
name|SPARSE
argument_list|)
operator|&&
name|otherEncoding
operator|.
name|equals
argument_list|(
name|EncodingType
operator|.
name|DENSE
argument_list|)
condition|)
block|{
name|denseRegister
operator|=
name|sparseToDenseRegister
argument_list|(
name|sparseRegister
argument_list|)
expr_stmt|;
name|denseRegister
operator|.
name|merge
argument_list|(
name|hll
operator|.
name|getHLLDenseRegister
argument_list|()
argument_list|)
expr_stmt|;
name|sparseRegister
operator|=
literal|null
expr_stmt|;
name|encoding
operator|=
name|EncodingType
operator|.
name|DENSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|encoding
operator|.
name|equals
argument_list|(
name|EncodingType
operator|.
name|DENSE
argument_list|)
operator|&&
name|otherEncoding
operator|.
name|equals
argument_list|(
name|EncodingType
operator|.
name|SPARSE
argument_list|)
condition|)
block|{
name|HLLDenseRegister
name|otherDenseRegister
init|=
name|sparseToDenseRegister
argument_list|(
name|hll
operator|.
name|getHLLSparseRegister
argument_list|()
argument_list|)
decl_stmt|;
name|denseRegister
operator|.
name|merge
argument_list|(
name|otherDenseRegister
argument_list|)
expr_stmt|;
block|}
name|invalidateCount
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * Converts sparse to dense hll register    * @param sparseRegister    *          - sparse register to be converted    * @return converted dense register    */
specifier|private
name|HLLDenseRegister
name|sparseToDenseRegister
parameter_list|(
name|HLLSparseRegister
name|sparseRegister
parameter_list|)
block|{
if|if
condition|(
name|sparseRegister
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|p
init|=
name|sparseRegister
operator|.
name|getP
argument_list|()
decl_stmt|;
name|int
name|pMask
init|=
operator|(
literal|1
operator|<<
name|p
operator|)
operator|-
literal|1
decl_stmt|;
name|HLLDenseRegister
name|result
init|=
operator|new
name|HLLDenseRegister
argument_list|(
name|p
argument_list|,
name|bitPacking
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|Byte
argument_list|>
name|entry
range|:
name|sparseRegister
operator|.
name|getSparseMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|int
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|int
name|idx
init|=
name|key
operator|&
name|pMask
decl_stmt|;
name|result
operator|.
name|set
argument_list|(
name|idx
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Encoding: "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|encoding
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", p: "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", estimatedCardinality: "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|estimateNumDistinctValues
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
name|String
name|toStringExtended
parameter_list|()
block|{
if|if
condition|(
name|encoding
operator|.
name|equals
argument_list|(
name|EncodingType
operator|.
name|DENSE
argument_list|)
condition|)
block|{
return|return
name|toString
argument_list|()
operator|+
literal|", "
operator|+
name|denseRegister
operator|.
name|toExtendedString
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|encoding
operator|.
name|equals
argument_list|(
name|EncodingType
operator|.
name|SPARSE
argument_list|)
condition|)
block|{
return|return
name|toString
argument_list|()
operator|+
literal|", "
operator|+
name|sparseRegister
operator|.
name|toExtendedString
argument_list|()
return|;
block|}
return|return
name|toString
argument_list|()
return|;
block|}
specifier|public
name|int
name|getNumRegisterIndexBits
parameter_list|()
block|{
return|return
name|p
return|;
block|}
specifier|public
name|EncodingType
name|getEncoding
parameter_list|()
block|{
return|return
name|encoding
return|;
block|}
specifier|public
name|void
name|setEncoding
parameter_list|(
name|EncodingType
name|encoding
parameter_list|)
block|{
name|this
operator|.
name|encoding
operator|=
name|encoding
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|HyperLogLog
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|HyperLogLog
name|other
init|=
operator|(
name|HyperLogLog
operator|)
name|obj
decl_stmt|;
name|long
name|count
init|=
name|estimateNumDistinctValues
argument_list|()
decl_stmt|;
name|long
name|otherCount
init|=
name|other
operator|.
name|estimateNumDistinctValues
argument_list|()
decl_stmt|;
name|boolean
name|result
init|=
name|p
operator|==
name|other
operator|.
name|p
operator|&&
name|chosenHashBits
operator|==
name|other
operator|.
name|chosenHashBits
operator|&&
name|encoding
operator|.
name|equals
argument_list|(
name|other
operator|.
name|encoding
argument_list|)
operator|&&
name|count
operator|==
name|otherCount
decl_stmt|;
if|if
condition|(
name|encoding
operator|.
name|equals
argument_list|(
name|EncodingType
operator|.
name|DENSE
argument_list|)
condition|)
block|{
name|result
operator|=
name|result
operator|&&
name|denseRegister
operator|.
name|equals
argument_list|(
name|other
operator|.
name|getHLLDenseRegister
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|encoding
operator|.
name|equals
argument_list|(
name|EncodingType
operator|.
name|SPARSE
argument_list|)
condition|)
block|{
name|result
operator|=
name|result
operator|&&
name|sparseRegister
operator|.
name|equals
argument_list|(
name|other
operator|.
name|getHLLSparseRegister
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|hashcode
init|=
literal|0
decl_stmt|;
name|hashcode
operator|+=
literal|31
operator|*
name|p
expr_stmt|;
name|hashcode
operator|+=
literal|31
operator|*
name|chosenHashBits
expr_stmt|;
name|hashcode
operator|+=
name|encoding
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|hashcode
operator|+=
literal|31
operator|*
name|estimateNumDistinctValues
argument_list|()
expr_stmt|;
if|if
condition|(
name|encoding
operator|.
name|equals
argument_list|(
name|EncodingType
operator|.
name|DENSE
argument_list|)
condition|)
block|{
name|hashcode
operator|+=
literal|31
operator|*
name|denseRegister
operator|.
name|hashCode
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|encoding
operator|.
name|equals
argument_list|(
name|EncodingType
operator|.
name|SPARSE
argument_list|)
condition|)
block|{
name|hashcode
operator|+=
literal|31
operator|*
name|sparseRegister
operator|.
name|hashCode
argument_list|()
expr_stmt|;
block|}
return|return
name|hashcode
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{   }
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|serialize
parameter_list|()
block|{
name|ByteArrayOutputStream
name|bos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
comment|// write bytes to bos ...
try|try
block|{
name|HyperLogLogUtils
operator|.
name|serializeHLL
argument_list|(
name|bos
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|byte
index|[]
name|result
init|=
name|bos
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|bos
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|NumDistinctValueEstimator
name|deserialize
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
block|{
name|InputStream
name|is
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|buf
argument_list|)
decl_stmt|;
try|try
block|{
name|HyperLogLog
name|result
init|=
name|HyperLogLogUtils
operator|.
name|deserializeHLL
argument_list|(
name|is
argument_list|)
decl_stmt|;
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|addToEstimator
parameter_list|(
name|long
name|v
parameter_list|)
block|{
name|addLong
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addToEstimator
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|addString
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addToEstimator
parameter_list|(
name|double
name|d
parameter_list|)
block|{
name|addDouble
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addToEstimator
parameter_list|(
name|HiveDecimal
name|decimal
parameter_list|)
block|{
name|addDouble
argument_list|(
name|decimal
operator|.
name|doubleValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|mergeEstimators
parameter_list|(
name|NumDistinctValueEstimator
name|o
parameter_list|)
block|{
name|merge
argument_list|(
operator|(
name|HyperLogLog
operator|)
name|o
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|lengthFor
parameter_list|(
name|JavaDataModel
name|model
parameter_list|)
block|{
comment|// 5 is the head, 1<<p means the number of bytes for register
return|return
operator|(
literal|5
operator|+
operator|(
literal|1
operator|<<
name|p
operator|)
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|canMerge
parameter_list|(
name|NumDistinctValueEstimator
name|o
parameter_list|)
block|{
return|return
name|o
operator|instanceof
name|HyperLogLog
return|;
block|}
block|}
end_class

end_unit

