begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|HBaseAdmin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|HTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Delete
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Get
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Scan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|PrefixFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ResultScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|stats
operator|.
name|StatsAggregator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|stats
operator|.
name|StatsSetupConst
import|;
end_import

begin_comment
comment|/**  * A class that implements the StatsAggregator interface through HBase.  */
end_comment

begin_class
specifier|public
class|class
name|HBaseStatsAggregator
implements|implements
name|StatsAggregator
block|{
specifier|private
name|HTable
name|htable
decl_stmt|;
specifier|private
name|byte
index|[]
name|rowCountFamily
decl_stmt|,
name|rowCountColumn
decl_stmt|;
specifier|private
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Does the necessary HBase initializations.    */
specifier|public
name|boolean
name|connect
parameter_list|(
name|Configuration
name|hiveconf
parameter_list|)
block|{
try|try
block|{
name|HBaseConfiguration
name|hbaseConf
init|=
operator|new
name|HBaseConfiguration
argument_list|(
name|hiveconf
argument_list|)
decl_stmt|;
name|HBaseAdmin
name|hbase
init|=
operator|new
name|HBaseAdmin
argument_list|(
name|hbaseConf
argument_list|)
decl_stmt|;
name|rowCountFamily
operator|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|HBaseStatsSetupConstants
operator|.
name|PART_STAT_ROW_COUNT_COLUMN_FAMILY
argument_list|)
expr_stmt|;
name|rowCountColumn
operator|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|HBaseStatsSetupConstants
operator|.
name|PART_STAT_ROW_COUNT_COLUMN_NAME
argument_list|)
expr_stmt|;
name|htable
operator|=
operator|new
name|HTable
argument_list|(
name|HBaseStatsSetupConstants
operator|.
name|PART_STAT_TABLE_NAME
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error during HBase connection. "
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Aggregates temporary stats from HBase;    */
specifier|public
name|String
name|aggregateStats
parameter_list|(
name|String
name|rowID
parameter_list|,
name|String
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|!=
name|StatsSetupConst
operator|.
name|ROW_COUNT
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Warning. Invalid statistic. Currently "
operator|+
literal|"row count is the only supported statistic"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|int
name|retValue
init|=
literal|0
decl_stmt|;
try|try
block|{
name|Scan
name|scan
init|=
operator|new
name|Scan
argument_list|()
decl_stmt|;
name|scan
operator|.
name|addColumn
argument_list|(
name|rowCountFamily
argument_list|,
name|rowCountColumn
argument_list|)
expr_stmt|;
comment|// Filter the row by its ID
comment|// The complete key is "tableName/PartSpecs/jobID/taskID"
comment|// This is a prefix filter, the prefix is "tableName/PartSpecs/JobID", i.e. the taskID is ignored
comment|// In SQL, this is equivalent to "Select * FROM tableName where ID LIKE 'tableName/PartSpecs/JobID%';"
name|PrefixFilter
name|filter
init|=
operator|new
name|PrefixFilter
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|rowID
argument_list|)
argument_list|)
decl_stmt|;
name|scan
operator|.
name|setFilter
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|ResultScanner
name|scanner
init|=
name|htable
operator|.
name|getScanner
argument_list|(
name|scan
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|Delete
argument_list|>
name|toDelete
init|=
operator|new
name|ArrayList
argument_list|<
name|Delete
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Result
name|result
range|:
name|scanner
control|)
block|{
name|retValue
operator|+=
name|Integer
operator|.
name|parseInt
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|result
operator|.
name|getValue
argument_list|(
name|rowCountFamily
argument_list|,
name|rowCountColumn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Automatic Cleaning:           IMPORTANT: Since we publish and aggregate only 1 value (1 column) which is the row count, it           is valid to delete the row after aggregation (automatic cleaning) because we know that there is no           other values to aggregate.           If ;in the future; other values are aggregated and published, then we cannot do cleaning except           when we are sure that all values are aggregated, or we can separate the implementation of cleaning           through a separate method which the developer has to call it manually in the code.          */
name|Delete
name|delete
init|=
operator|new
name|Delete
argument_list|(
name|result
operator|.
name|getRow
argument_list|()
argument_list|)
decl_stmt|;
name|toDelete
operator|.
name|add
argument_list|(
name|delete
argument_list|)
expr_stmt|;
block|}
name|htable
operator|.
name|delete
argument_list|(
name|toDelete
argument_list|)
expr_stmt|;
return|return
name|Integer
operator|.
name|toString
argument_list|(
name|retValue
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error during publishing aggregation. "
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|boolean
name|closeConnection
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|cleanUp
parameter_list|(
name|String
name|rowID
parameter_list|)
block|{
try|try
block|{
name|Scan
name|scan
init|=
operator|new
name|Scan
argument_list|()
decl_stmt|;
comment|// Filter the row by its ID
comment|// The complete key is "tableName/PartSpecs/jobID/taskID"
comment|// This is a prefix filter, the prefix is "JobID"
comment|// In SQL, this is equivalent to "Select * FROM tableName where ID LIKE 'JobID%';"
name|PrefixFilter
name|filter
init|=
operator|new
name|PrefixFilter
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|rowID
argument_list|)
argument_list|)
decl_stmt|;
name|scan
operator|.
name|setFilter
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|ResultScanner
name|scanner
init|=
name|htable
operator|.
name|getScanner
argument_list|(
name|scan
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|Delete
argument_list|>
name|toDelete
init|=
operator|new
name|ArrayList
argument_list|<
name|Delete
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Result
name|result
range|:
name|scanner
control|)
block|{
name|Delete
name|delete
init|=
operator|new
name|Delete
argument_list|(
name|result
operator|.
name|getRow
argument_list|()
argument_list|)
decl_stmt|;
name|toDelete
operator|.
name|add
argument_list|(
name|delete
argument_list|)
expr_stmt|;
block|}
name|htable
operator|.
name|delete
argument_list|(
name|toDelete
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error during publishing aggregation. "
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
end_class

end_unit

