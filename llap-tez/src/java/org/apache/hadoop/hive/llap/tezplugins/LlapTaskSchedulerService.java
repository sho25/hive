begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|tezplugins
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|DelayQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Delayed
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|mutable
operator|.
name|MutableInt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|metrics
operator|.
name|LlapMetricsSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|metrics
operator|.
name|MetricsUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|registry
operator|.
name|ServiceInstance
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|registry
operator|.
name|ServiceInstanceSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|registry
operator|.
name|ServiceInstanceStateChangeListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|registry
operator|.
name|impl
operator|.
name|LlapRegistryService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|tezplugins
operator|.
name|helpers
operator|.
name|MonotonicClock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|tezplugins
operator|.
name|scheduler
operator|.
name|LoggingFutureCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|tezplugins
operator|.
name|metrics
operator|.
name|LlapTaskSchedulerMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|JvmPauseMonitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Container
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|NodeId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Priority
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|Clock
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ListenableFuture
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ListeningExecutorService
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|MoreExecutors
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|common
operator|.
name|TezUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|dag
operator|.
name|api
operator|.
name|TezUncheckedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|serviceplugins
operator|.
name|api
operator|.
name|ServicePluginErrorDefaults
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|serviceplugins
operator|.
name|api
operator|.
name|TaskAttemptEndReason
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|serviceplugins
operator|.
name|api
operator|.
name|TaskScheduler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|serviceplugins
operator|.
name|api
operator|.
name|TaskSchedulerContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
specifier|public
class|class
name|LlapTaskSchedulerService
extends|extends
name|TaskScheduler
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|LlapTaskSchedulerService
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|TaskStartComparator
name|TASK_INFO_COMPARATOR
init|=
operator|new
name|TaskStartComparator
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
comment|// interface into the registry service
specifier|private
name|ServiceInstanceSet
name|activeInstances
decl_stmt|;
comment|// Tracks all instances, including ones which have been disabled in the past.
comment|// LinkedHashMap to provide the same iteration order when selecting a random host.
annotation|@
name|VisibleForTesting
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|NodeInfo
argument_list|>
name|instanceToNodeMap
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// TODO Ideally, remove elements from this once it's known that no tasks are linked to the instance (all deallocated)
comment|// Tracks tasks which could not be allocated immediately.
annotation|@
name|VisibleForTesting
comment|// Tasks are tracked in the order requests come in, at different priority levels.
comment|// TODO HIVE-13538 For tasks at the same priority level, it may be worth attempting to schedule tasks with
comment|// locality information before those without locality information
specifier|final
name|TreeMap
argument_list|<
name|Priority
argument_list|,
name|List
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|pendingTasks
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
operator|new
name|Comparator
argument_list|<
name|Priority
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Priority
name|o1
parameter_list|,
name|Priority
name|o2
parameter_list|)
block|{
return|return
name|o1
operator|.
name|getPriority
argument_list|()
operator|-
name|o2
operator|.
name|getPriority
argument_list|()
return|;
block|}
block|}
argument_list|)
decl_stmt|;
comment|// Tracks running and queued tasks. Cleared after a task completes.
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|Object
argument_list|,
name|TaskInfo
argument_list|>
name|knownTasks
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Tracks tasks which are running. Useful for selecting a task to preempt based on when it started.
specifier|private
specifier|final
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|runningTasks
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Queue for disabled nodes. Nodes make it out of this queue when their expiration timeout is hit.
annotation|@
name|VisibleForTesting
specifier|final
name|DelayQueue
argument_list|<
name|NodeInfo
argument_list|>
name|disabledNodesQueue
init|=
operator|new
name|DelayQueue
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
name|DelayQueue
argument_list|<
name|TaskInfo
argument_list|>
name|delayedTaskQueue
init|=
operator|new
name|DelayQueue
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ContainerFactory
name|containerFactory
decl_stmt|;
specifier|private
specifier|final
name|Random
name|random
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
name|Clock
name|clock
decl_stmt|;
specifier|private
specifier|final
name|ListeningExecutorService
name|nodeEnabledExecutor
decl_stmt|;
specifier|private
specifier|final
name|NodeEnablerCallable
name|nodeEnablerCallable
init|=
operator|new
name|NodeEnablerCallable
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ListeningExecutorService
name|delayedTaskSchedulerExecutor
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
name|DelayedTaskSchedulerCallable
name|delayedTaskSchedulerCallable
decl_stmt|;
specifier|private
specifier|final
name|ReentrantReadWriteLock
name|lock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ReentrantReadWriteLock
operator|.
name|ReadLock
name|readLock
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ReentrantReadWriteLock
operator|.
name|WriteLock
name|writeLock
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Lock
name|scheduleLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Condition
name|scheduleCondition
init|=
name|scheduleLock
operator|.
name|newCondition
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|AtomicBoolean
name|pendingScheduleInvocations
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|ListeningExecutorService
name|schedulerExecutor
decl_stmt|;
specifier|private
specifier|final
name|SchedulerCallable
name|schedulerCallable
init|=
operator|new
name|SchedulerCallable
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|AtomicBoolean
name|isStopped
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|// Tracks total pending preemptions.
specifier|private
specifier|final
name|AtomicInteger
name|pendingPreemptions
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// Tracks pending preemptions per host, using the hostname || Always to be accessed inside a lock
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|MutableInt
argument_list|>
name|pendingPreemptionsPerHost
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|NodeBlacklistConf
name|nodeBlacklistConf
decl_stmt|;
specifier|private
specifier|final
name|LocalityDelayConf
name|localityDelayConf
decl_stmt|;
comment|// Per daemon
specifier|private
specifier|final
name|int
name|memoryPerInstance
decl_stmt|;
specifier|private
specifier|final
name|int
name|coresPerInstance
decl_stmt|;
specifier|private
specifier|final
name|int
name|executorsPerInstance
decl_stmt|;
specifier|private
specifier|final
name|int
name|numSchedulableTasksPerNode
decl_stmt|;
comment|// Per Executor Thread
specifier|private
specifier|final
name|Resource
name|resourcePerExecutor
decl_stmt|;
comment|// when there are no live nodes in the cluster and this timeout elapses the query is failed
specifier|private
specifier|final
name|long
name|timeout
decl_stmt|;
specifier|private
specifier|final
name|Lock
name|timeoutLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ScheduledExecutorService
name|timeoutExecutor
decl_stmt|;
specifier|private
specifier|final
name|SchedulerTimeoutMonitor
name|timeoutMonitor
decl_stmt|;
specifier|private
name|ScheduledFuture
argument_list|<
name|?
argument_list|>
name|timeoutFuture
decl_stmt|;
specifier|private
specifier|final
name|LlapRegistryService
name|registry
init|=
operator|new
name|LlapRegistryService
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
specifier|volatile
name|ListenableFuture
argument_list|<
name|Void
argument_list|>
name|nodeEnablerFuture
decl_stmt|;
specifier|private
specifier|volatile
name|ListenableFuture
argument_list|<
name|Void
argument_list|>
name|delayedTaskSchedulerFuture
decl_stmt|;
specifier|private
specifier|volatile
name|ListenableFuture
argument_list|<
name|Void
argument_list|>
name|schedulerFuture
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|private
specifier|final
name|AtomicInteger
name|dagCounter
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// Statistics to track allocations
comment|// All of stats variables are visible for testing.
annotation|@
name|VisibleForTesting
name|StatsPerDag
name|dagStats
init|=
operator|new
name|StatsPerDag
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|LlapTaskSchedulerMetrics
name|metrics
decl_stmt|;
specifier|private
specifier|final
name|JvmPauseMonitor
name|pauseMonitor
decl_stmt|;
specifier|public
name|LlapTaskSchedulerService
parameter_list|(
name|TaskSchedulerContext
name|taskSchedulerContext
parameter_list|)
block|{
name|this
argument_list|(
name|taskSchedulerContext
argument_list|,
operator|new
name|MonotonicClock
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|LlapTaskSchedulerService
parameter_list|(
name|TaskSchedulerContext
name|taskSchedulerContext
parameter_list|,
name|Clock
name|clock
parameter_list|,
name|boolean
name|initMetrics
parameter_list|)
block|{
name|super
argument_list|(
name|taskSchedulerContext
argument_list|)
expr_stmt|;
name|this
operator|.
name|clock
operator|=
name|clock
expr_stmt|;
name|this
operator|.
name|delayedTaskSchedulerCallable
operator|=
name|createDelayedTaskSchedulerCallable
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|conf
operator|=
name|TezUtils
operator|.
name|createConfFromUserPayload
argument_list|(
name|taskSchedulerContext
operator|.
name|getInitialUserPayload
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|TezUncheckedException
argument_list|(
literal|"Failed to parse user payload for "
operator|+
name|LlapTaskSchedulerService
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|this
operator|.
name|containerFactory
operator|=
operator|new
name|ContainerFactory
argument_list|(
name|taskSchedulerContext
operator|.
name|getApplicationAttemptId
argument_list|()
argument_list|,
name|taskSchedulerContext
operator|.
name|getCustomClusterIdentifier
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO HIVE-13483 Get all of these properties from the registry. This will need to take care of different instances
comment|// publishing potentially different values when we support changing configurations dynamically.
comment|// For now, this can simply be fetched from a single registry instance.
name|this
operator|.
name|memoryPerInstance
operator|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_DAEMON_MEMORY_PER_INSTANCE_MB
argument_list|)
expr_stmt|;
name|this
operator|.
name|coresPerInstance
operator|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_DAEMON_VCPUS_PER_INSTANCE
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorsPerInstance
operator|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_DAEMON_NUM_EXECUTORS
argument_list|)
expr_stmt|;
name|this
operator|.
name|nodeBlacklistConf
operator|=
operator|new
name|NodeBlacklistConf
argument_list|(
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_TASK_SCHEDULER_NODE_REENABLE_MIN_TIMEOUT_MS
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
argument_list|,
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_TASK_SCHEDULER_NODE_REENABLE_MAX_TIMEOUT_MS
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
argument_list|,
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_TASK_SCHEDULER_NODE_DISABLE_BACK_OFF_FACTOR
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|numSchedulableTasksPerNode
operator|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_TASK_SCHEDULER_NUM_SCHEDULABLE_TASKS_PER_NODE
argument_list|)
expr_stmt|;
name|long
name|localityDelayMs
init|=
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_TASK_SCHEDULER_LOCALITY_DELAY
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
name|this
operator|.
name|localityDelayConf
operator|=
operator|new
name|LocalityDelayConf
argument_list|(
name|localityDelayMs
argument_list|)
expr_stmt|;
name|this
operator|.
name|timeoutMonitor
operator|=
operator|new
name|SchedulerTimeoutMonitor
argument_list|()
expr_stmt|;
name|this
operator|.
name|timeout
operator|=
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_DAEMON_TASK_SCHEDULER_TIMEOUT_SECONDS
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|this
operator|.
name|timeoutExecutor
operator|=
name|Executors
operator|.
name|newSingleThreadScheduledExecutor
argument_list|(
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
literal|"LlapTaskSchedulerTimeoutMonitor"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|timeoutFuture
operator|=
literal|null
expr_stmt|;
name|int
name|memoryPerExecutor
init|=
call|(
name|int
call|)
argument_list|(
name|memoryPerInstance
operator|/
operator|(
name|float
operator|)
name|executorsPerInstance
argument_list|)
decl_stmt|;
name|int
name|coresPerExecutor
init|=
call|(
name|int
call|)
argument_list|(
name|coresPerInstance
operator|/
operator|(
name|float
operator|)
name|executorsPerInstance
argument_list|)
decl_stmt|;
name|this
operator|.
name|resourcePerExecutor
operator|=
name|Resource
operator|.
name|newInstance
argument_list|(
name|memoryPerExecutor
argument_list|,
name|coresPerExecutor
argument_list|)
expr_stmt|;
name|String
name|instanceId
init|=
name|HiveConf
operator|.
name|getTrimmedVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_DAEMON_SERVICE_HOSTS
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|instanceId
argument_list|,
name|ConfVars
operator|.
name|LLAP_DAEMON_SERVICE_HOSTS
operator|.
name|varname
operator|+
literal|" must be defined"
argument_list|)
expr_stmt|;
name|ExecutorService
name|executorServiceRaw
init|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|(
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
literal|"LlapSchedulerNodeEnabler"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|nodeEnabledExecutor
operator|=
name|MoreExecutors
operator|.
name|listeningDecorator
argument_list|(
name|executorServiceRaw
argument_list|)
expr_stmt|;
name|ExecutorService
name|delayedTaskSchedulerExecutorRaw
init|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
literal|1
argument_list|,
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
literal|"LlapSchedulerDelayedTaskHandler"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|delayedTaskSchedulerExecutor
operator|=
name|MoreExecutors
operator|.
name|listeningDecorator
argument_list|(
name|delayedTaskSchedulerExecutorRaw
argument_list|)
expr_stmt|;
name|ExecutorService
name|schedulerExecutorServiceRaw
init|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|(
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
literal|"LlapScheduler"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|schedulerExecutor
operator|=
name|MoreExecutors
operator|.
name|listeningDecorator
argument_list|(
name|schedulerExecutorServiceRaw
argument_list|)
expr_stmt|;
if|if
condition|(
name|initMetrics
condition|)
block|{
comment|// Initialize the metrics system
name|LlapMetricsSystem
operator|.
name|initialize
argument_list|(
literal|"LlapTaskScheduler"
argument_list|)
expr_stmt|;
name|this
operator|.
name|pauseMonitor
operator|=
operator|new
name|JvmPauseMonitor
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|pauseMonitor
operator|.
name|start
argument_list|()
expr_stmt|;
name|String
name|displayName
init|=
literal|"LlapTaskSchedulerMetrics-"
operator|+
name|MetricsUtils
operator|.
name|getHostName
argument_list|()
decl_stmt|;
name|String
name|sessionId
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"llap.daemon.metrics.sessionid"
argument_list|)
decl_stmt|;
comment|// TODO: Not sure about the use of this. Should we instead use workerIdentity as sessionId?
name|this
operator|.
name|metrics
operator|=
name|LlapTaskSchedulerMetrics
operator|.
name|create
argument_list|(
name|displayName
argument_list|,
name|sessionId
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|setNumExecutors
argument_list|(
name|executorsPerInstance
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|setMemoryPerInstance
argument_list|(
name|memoryPerInstance
operator|*
literal|1024L
operator|*
literal|1024L
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|setCpuCoresPerInstance
argument_list|(
name|coresPerExecutor
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|getJvmMetrics
argument_list|()
operator|.
name|setPauseMonitor
argument_list|(
name|pauseMonitor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|metrics
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|pauseMonitor
operator|=
literal|null
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Running with configuration: "
operator|+
literal|"memoryPerInstance="
operator|+
name|memoryPerInstance
operator|+
literal|", vCoresPerInstance="
operator|+
name|coresPerInstance
operator|+
literal|", executorsPerInstance="
operator|+
name|executorsPerInstance
operator|+
literal|", resourcePerInstanceInferred="
operator|+
name|resourcePerExecutor
operator|+
literal|", nodeBlacklistConf="
operator|+
name|nodeBlacklistConf
operator|+
literal|", localityDelayMs="
operator|+
name|localityDelayMs
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|initialize
parameter_list|()
block|{
name|registry
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|start
parameter_list|()
throws|throws
name|IOException
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|nodeEnablerFuture
operator|=
name|nodeEnabledExecutor
operator|.
name|submit
argument_list|(
name|nodeEnablerCallable
argument_list|)
expr_stmt|;
name|Futures
operator|.
name|addCallback
argument_list|(
name|nodeEnablerFuture
argument_list|,
operator|new
name|LoggingFutureCallback
argument_list|(
literal|"NodeEnablerThread"
argument_list|,
name|LOG
argument_list|)
argument_list|)
expr_stmt|;
name|delayedTaskSchedulerFuture
operator|=
name|delayedTaskSchedulerExecutor
operator|.
name|submit
argument_list|(
name|delayedTaskSchedulerCallable
argument_list|)
expr_stmt|;
name|Futures
operator|.
name|addCallback
argument_list|(
name|delayedTaskSchedulerFuture
argument_list|,
operator|new
name|LoggingFutureCallback
argument_list|(
literal|"DelayedTaskSchedulerThread"
argument_list|,
name|LOG
argument_list|)
argument_list|)
expr_stmt|;
name|schedulerFuture
operator|=
name|schedulerExecutor
operator|.
name|submit
argument_list|(
name|schedulerCallable
argument_list|)
expr_stmt|;
name|Futures
operator|.
name|addCallback
argument_list|(
name|schedulerFuture
argument_list|,
operator|new
name|LoggingFutureCallback
argument_list|(
literal|"SchedulerThread"
argument_list|,
name|LOG
argument_list|)
argument_list|)
expr_stmt|;
name|registry
operator|.
name|start
argument_list|()
expr_stmt|;
name|registry
operator|.
name|registerStateChangeListener
argument_list|(
operator|new
name|NodeStateChangeListener
argument_list|()
argument_list|)
expr_stmt|;
name|activeInstances
operator|=
name|registry
operator|.
name|getInstances
argument_list|()
expr_stmt|;
for|for
control|(
name|ServiceInstance
name|inst
range|:
name|activeInstances
operator|.
name|getAll
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|addNode
argument_list|(
name|inst
argument_list|,
operator|new
name|NodeInfo
argument_list|(
name|inst
argument_list|,
name|nodeBlacklistConf
argument_list|,
name|clock
argument_list|,
name|numSchedulableTasksPerNode
argument_list|,
name|metrics
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
class|class
name|NodeStateChangeListener
implements|implements
name|ServiceInstanceStateChangeListener
block|{
specifier|private
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|NodeStateChangeListener
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|onCreate
parameter_list|(
specifier|final
name|ServiceInstance
name|serviceInstance
parameter_list|)
block|{
name|addNode
argument_list|(
name|serviceInstance
argument_list|,
operator|new
name|NodeInfo
argument_list|(
name|serviceInstance
argument_list|,
name|nodeBlacklistConf
argument_list|,
name|clock
argument_list|,
name|numSchedulableTasksPerNode
argument_list|,
name|metrics
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Added node with identity: {}"
argument_list|,
name|serviceInstance
operator|.
name|getWorkerIdentity
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onUpdate
parameter_list|(
specifier|final
name|ServiceInstance
name|serviceInstance
parameter_list|)
block|{
name|instanceToNodeMap
operator|.
name|put
argument_list|(
name|serviceInstance
operator|.
name|getWorkerIdentity
argument_list|()
argument_list|,
operator|new
name|NodeInfo
argument_list|(
name|serviceInstance
argument_list|,
name|nodeBlacklistConf
argument_list|,
name|clock
argument_list|,
name|numSchedulableTasksPerNode
argument_list|,
name|metrics
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Updated node with identity: {}"
argument_list|,
name|serviceInstance
operator|.
name|getWorkerIdentity
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onRemove
parameter_list|(
specifier|final
name|ServiceInstance
name|serviceInstance
parameter_list|)
block|{
comment|// FIXME: disabling this for now
comment|// instanceToNodeMap.remove(serviceInstance.getWorkerIdentity());
name|LOG
operator|.
name|info
argument_list|(
literal|"Removed node with identity: {}"
argument_list|,
name|serviceInstance
operator|.
name|getWorkerIdentity
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setClusterNodeCount
argument_list|(
name|activeInstances
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// if there are no more nodes. Signal timeout monitor to start timer
if|if
condition|(
name|activeInstances
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No node found. Signalling scheduler timeout monitor thread to start timer."
argument_list|)
expr_stmt|;
name|startTimeoutMonitor
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|startTimeoutMonitor
parameter_list|()
block|{
name|timeoutLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// If timer is null, start a new one.
comment|// If timer has completed during previous invocation, start a new one.
comment|// If timer already started and is not completed, leaving it running without resetting it.
if|if
condition|(
operator|(
name|timeoutFuture
operator|==
literal|null
operator|||
operator|(
name|timeoutFuture
operator|!=
literal|null
operator|&&
name|timeoutFuture
operator|.
name|isDone
argument_list|()
operator|)
operator|)
operator|&&
name|activeInstances
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|timeoutFuture
operator|=
name|timeoutExecutor
operator|.
name|schedule
argument_list|(
name|timeoutMonitor
argument_list|,
name|timeout
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Scheduled timeout monitor task to run after {} ms"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Timeout monitor task not started. Timeout future state: {}, #instances: {}"
argument_list|,
name|timeoutFuture
operator|==
literal|null
condition|?
literal|"null"
else|:
name|timeoutFuture
operator|.
name|isDone
argument_list|()
argument_list|,
name|activeInstances
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|timeoutLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|stopTimeoutMonitor
parameter_list|()
block|{
name|timeoutLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|timeoutFuture
operator|!=
literal|null
operator|&&
name|activeInstances
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|&&
name|timeoutFuture
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopped timeout monitor task"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Timeout monitor task not stopped. Timeout future state: {}, #instances: {}"
argument_list|,
name|timeoutFuture
operator|==
literal|null
condition|?
literal|"null"
else|:
name|timeoutFuture
operator|.
name|isDone
argument_list|()
argument_list|,
name|activeInstances
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|timeoutFuture
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
name|timeoutLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|isStopped
operator|.
name|getAndSet
argument_list|(
literal|true
argument_list|)
condition|)
block|{
name|nodeEnablerCallable
operator|.
name|shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
name|nodeEnablerFuture
operator|!=
literal|null
condition|)
block|{
name|nodeEnablerFuture
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|nodeEnabledExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|timeoutExecutor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
name|timeoutFuture
operator|!=
literal|null
condition|)
block|{
name|timeoutFuture
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|timeoutFuture
operator|=
literal|null
expr_stmt|;
block|}
name|timeoutExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|delayedTaskSchedulerCallable
operator|.
name|shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
name|delayedTaskSchedulerFuture
operator|!=
literal|null
condition|)
block|{
name|delayedTaskSchedulerFuture
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|delayedTaskSchedulerExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|schedulerCallable
operator|.
name|shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
name|schedulerFuture
operator|!=
literal|null
condition|)
block|{
name|schedulerFuture
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|schedulerExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
if|if
condition|(
name|registry
operator|!=
literal|null
condition|)
block|{
name|registry
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|pauseMonitor
operator|!=
literal|null
condition|)
block|{
name|pauseMonitor
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|LlapMetricsSystem
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Resource
name|getTotalResources
parameter_list|()
block|{
name|int
name|memory
init|=
literal|0
decl_stmt|;
name|int
name|vcores
init|=
literal|0
decl_stmt|;
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|numInstancesFound
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ServiceInstance
name|inst
range|:
name|activeInstances
operator|.
name|getAll
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|inst
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|Resource
name|r
init|=
name|inst
operator|.
name|getResource
argument_list|()
decl_stmt|;
name|memory
operator|+=
name|r
operator|.
name|getMemory
argument_list|()
expr_stmt|;
name|vcores
operator|+=
name|r
operator|.
name|getVirtualCores
argument_list|()
expr_stmt|;
name|numInstancesFound
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"GetTotalResources: numInstancesFound={}, totalMem={}, totalVcores={}"
argument_list|,
name|numInstancesFound
argument_list|,
name|memory
argument_list|,
name|vcores
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|Resource
operator|.
name|newInstance
argument_list|(
name|memory
argument_list|,
name|vcores
argument_list|)
return|;
block|}
comment|/**    * The difference between this and getTotalResources() is that this only gives currently free    * resource instances, while the other lists all the instances that may become available in a    * while.    */
annotation|@
name|Override
specifier|public
name|Resource
name|getAvailableResources
parameter_list|()
block|{
comment|// need a state store eventually for current state& measure backoffs
name|int
name|memory
init|=
literal|0
decl_stmt|;
name|int
name|vcores
init|=
literal|0
decl_stmt|;
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|NodeInfo
argument_list|>
name|entry
range|:
name|instanceToNodeMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getServiceInstance
argument_list|()
operator|.
name|isAlive
argument_list|()
operator|&&
operator|!
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|isDisabled
argument_list|()
condition|)
block|{
name|Resource
name|r
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getServiceInstance
argument_list|()
operator|.
name|getResource
argument_list|()
decl_stmt|;
name|memory
operator|+=
name|r
operator|.
name|getMemory
argument_list|()
expr_stmt|;
name|vcores
operator|+=
name|r
operator|.
name|getVirtualCores
argument_list|()
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|Resource
operator|.
name|newInstance
argument_list|(
name|memory
argument_list|,
name|vcores
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getClusterNodeCount
parameter_list|()
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ServiceInstance
name|inst
range|:
name|activeInstances
operator|.
name|getAll
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|inst
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|n
operator|++
expr_stmt|;
block|}
block|}
return|return
name|n
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|dagComplete
parameter_list|()
block|{
comment|// This is effectively DAG completed, and can be used to reset statistics being tracked.
name|LOG
operator|.
name|info
argument_list|(
literal|"DAG: "
operator|+
name|dagCounter
operator|.
name|get
argument_list|()
operator|+
literal|" completed. Scheduling stats: "
operator|+
name|dagStats
argument_list|)
expr_stmt|;
name|dagCounter
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrCompletedDagCount
argument_list|()
expr_stmt|;
block|}
name|dagStats
operator|=
operator|new
name|StatsPerDag
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|blacklistNode
parameter_list|(
name|NodeId
name|nodeId
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"BlacklistNode not supported"
argument_list|)
expr_stmt|;
comment|// TODO HIVE-13484 What happens when we try scheduling a task on a node that Tez at this point thinks is blacklisted.
block|}
annotation|@
name|Override
specifier|public
name|void
name|unblacklistNode
parameter_list|(
name|NodeId
name|nodeId
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"unBlacklistNode not supported"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|allocateTask
parameter_list|(
name|Object
name|task
parameter_list|,
name|Resource
name|capability
parameter_list|,
name|String
index|[]
name|hosts
parameter_list|,
name|String
index|[]
name|racks
parameter_list|,
name|Priority
name|priority
parameter_list|,
name|Object
name|containerSignature
parameter_list|,
name|Object
name|clientCookie
parameter_list|)
block|{
name|TaskInfo
name|taskInfo
init|=
operator|new
name|TaskInfo
argument_list|(
name|localityDelayConf
argument_list|,
name|clock
argument_list|,
name|task
argument_list|,
name|clientCookie
argument_list|,
name|priority
argument_list|,
name|capability
argument_list|,
name|hosts
argument_list|,
name|racks
argument_list|,
name|clock
operator|.
name|getTime
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Received allocateRequest. task={}, priority={}, capability={}, hosts={}"
argument_list|,
name|task
argument_list|,
name|priority
argument_list|,
name|capability
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|hosts
argument_list|)
argument_list|)
expr_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|dagStats
operator|.
name|registerTaskRequest
argument_list|(
name|hosts
argument_list|,
name|racks
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|addPendingTask
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
name|trySchedulingPendingTasks
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|allocateTask
parameter_list|(
name|Object
name|task
parameter_list|,
name|Resource
name|capability
parameter_list|,
name|ContainerId
name|containerId
parameter_list|,
name|Priority
name|priority
parameter_list|,
name|Object
name|containerSignature
parameter_list|,
name|Object
name|clientCookie
parameter_list|)
block|{
comment|// Container affinity can be implemented as Host affinity for LLAP. Not required until
comment|// 1:1 edges are used in Hive.
name|TaskInfo
name|taskInfo
init|=
operator|new
name|TaskInfo
argument_list|(
name|localityDelayConf
argument_list|,
name|clock
argument_list|,
name|task
argument_list|,
name|clientCookie
argument_list|,
name|priority
argument_list|,
name|capability
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|clock
operator|.
name|getTime
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Received allocateRequest. task={}, priority={}, capability={}, containerId={}"
argument_list|,
name|task
argument_list|,
name|priority
argument_list|,
name|capability
argument_list|,
name|containerId
argument_list|)
expr_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|dagStats
operator|.
name|registerTaskRequest
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|addPendingTask
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
name|trySchedulingPendingTasks
argument_list|()
expr_stmt|;
block|}
comment|// This may be invoked before a container is ever assigned to a task. allocateTask... app decides
comment|// the task is no longer required, and asks for a de-allocation.
annotation|@
name|Override
specifier|public
name|boolean
name|deallocateTask
parameter_list|(
name|Object
name|task
parameter_list|,
name|boolean
name|taskSucceeded
parameter_list|,
name|TaskAttemptEndReason
name|endReason
parameter_list|,
name|String
name|diagnostics
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processing deallocateTask for task={}, taskSucceeded={}, endReason={}"
argument_list|,
name|task
argument_list|,
name|taskSucceeded
argument_list|,
name|endReason
argument_list|)
expr_stmt|;
block|}
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// Updating several local structures
name|TaskInfo
name|taskInfo
decl_stmt|;
try|try
block|{
name|taskInfo
operator|=
name|unregisterTask
argument_list|(
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|taskInfo
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not determine ContainerId for task: "
operator|+
name|task
operator|+
literal|" . Could have hit a race condition. Ignoring."
operator|+
literal|" The query may hang since this \"unknown\" container is now taking up a slot permanently"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|taskInfo
operator|.
name|containerId
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|taskInfo
operator|.
name|getState
argument_list|()
operator|==
name|TaskInfo
operator|.
name|State
operator|.
name|ASSIGNED
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Task: "
operator|+
name|task
operator|+
literal|" assigned, but could not find the corresponding containerId."
operator|+
literal|" The query may hang since this \"unknown\" container is now taking up a slot permanently"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignoring deallocate request for task "
operator|+
name|task
operator|+
literal|" which hasn't been assigned to a container"
argument_list|)
expr_stmt|;
name|removePendingTask
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
name|ServiceInstance
name|assignedInstance
init|=
name|taskInfo
operator|.
name|assignedInstance
decl_stmt|;
assert|assert
name|assignedInstance
operator|!=
literal|null
assert|;
name|NodeInfo
name|nodeInfo
init|=
name|instanceToNodeMap
operator|.
name|get
argument_list|(
name|assignedInstance
operator|.
name|getWorkerIdentity
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|nodeInfo
operator|!=
literal|null
assert|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing de-allocate request for task={}, state={}, endReason={}"
argument_list|,
name|taskInfo
operator|.
name|task
argument_list|,
name|taskInfo
operator|.
name|getState
argument_list|()
argument_list|,
name|endReason
argument_list|)
expr_stmt|;
comment|// Re-enable the node if preempted
if|if
condition|(
name|taskInfo
operator|.
name|getState
argument_list|()
operator|==
name|TaskInfo
operator|.
name|State
operator|.
name|PREEMPTED
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing deallocateTask for {} which was preempted, EndReason={}"
argument_list|,
name|task
argument_list|,
name|endReason
argument_list|)
expr_stmt|;
name|unregisterPendingPreemption
argument_list|(
name|taskInfo
operator|.
name|assignedInstance
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
name|nodeInfo
operator|.
name|registerUnsuccessfulTaskEnd
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodeInfo
operator|.
name|isDisabled
argument_list|()
condition|)
block|{
comment|// Re-enable the node. If a task succeeded, a slot may have become available.
comment|// Also reset commFailures since a task was able to communicate back and indicate success.
name|nodeInfo
operator|.
name|enableNode
argument_list|()
expr_stmt|;
comment|// Re-insert into the queue to force the poll thread to remove the element.
name|reinsertNodeInfo
argument_list|(
name|nodeInfo
argument_list|)
expr_stmt|;
block|}
comment|// In case of success, trigger a scheduling run for pending tasks.
name|trySchedulingPendingTasks
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|taskSucceeded
condition|)
block|{
comment|// The node may have been blacklisted at this point - which means it may not be in the
comment|// activeNodeList.
name|nodeInfo
operator|.
name|registerTaskSuccess
argument_list|()
expr_stmt|;
if|if
condition|(
name|nodeInfo
operator|.
name|isDisabled
argument_list|()
condition|)
block|{
comment|// Re-enable the node. If a task succeeded, a slot may have become available.
comment|// Also reset commFailures since a task was able to communicate back and indicate success.
name|nodeInfo
operator|.
name|enableNode
argument_list|()
expr_stmt|;
comment|// Re-insert into the queue to force the poll thread to remove the element.
name|reinsertNodeInfo
argument_list|(
name|nodeInfo
argument_list|)
expr_stmt|;
block|}
comment|// In case of success, trigger a scheduling run for pending tasks.
name|trySchedulingPendingTasks
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Task Failed
name|nodeInfo
operator|.
name|registerUnsuccessfulTaskEnd
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|endReason
operator|!=
literal|null
operator|&&
name|EnumSet
operator|.
name|of
argument_list|(
name|TaskAttemptEndReason
operator|.
name|EXECUTOR_BUSY
argument_list|,
name|TaskAttemptEndReason
operator|.
name|COMMUNICATION_ERROR
argument_list|)
operator|.
name|contains
argument_list|(
name|endReason
argument_list|)
condition|)
block|{
if|if
condition|(
name|endReason
operator|==
name|TaskAttemptEndReason
operator|.
name|COMMUNICATION_ERROR
condition|)
block|{
name|dagStats
operator|.
name|registerCommFailure
argument_list|(
name|taskInfo
operator|.
name|assignedInstance
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|endReason
operator|==
name|TaskAttemptEndReason
operator|.
name|EXECUTOR_BUSY
condition|)
block|{
name|dagStats
operator|.
name|registerTaskRejected
argument_list|(
name|taskInfo
operator|.
name|assignedInstance
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|endReason
operator|!=
literal|null
operator|&&
name|endReason
operator|==
name|TaskAttemptEndReason
operator|.
name|NODE_FAILED
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Task {} ended on {} nodeInfo.toString() with a NODE_FAILED message."
operator|+
literal|" An message should come in from the registry to disable this node unless"
operator|+
literal|" this was a temporary communication failure"
argument_list|,
name|task
argument_list|,
name|assignedInstance
argument_list|)
expr_stmt|;
block|}
name|boolean
name|commFailure
init|=
name|endReason
operator|!=
literal|null
operator|&&
name|endReason
operator|==
name|TaskAttemptEndReason
operator|.
name|COMMUNICATION_ERROR
decl_stmt|;
name|disableInstance
argument_list|(
name|assignedInstance
argument_list|,
name|commFailure
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|getContext
argument_list|()
operator|.
name|containerBeingReleased
argument_list|(
name|taskInfo
operator|.
name|containerId
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|reinsertNodeInfo
parameter_list|(
specifier|final
name|NodeInfo
name|nodeInfo
parameter_list|)
block|{
if|if
condition|(
name|disabledNodesQueue
operator|.
name|remove
argument_list|(
name|nodeInfo
argument_list|)
condition|)
block|{
name|disabledNodesQueue
operator|.
name|add
argument_list|(
name|nodeInfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setDisabledNodeCount
argument_list|(
name|disabledNodesQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Object
name|deallocateContainer
parameter_list|(
name|ContainerId
name|containerId
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring deallocateContainer for containerId: "
operator|+
name|containerId
argument_list|)
expr_stmt|;
comment|// Containers are not being tracked for re-use.
comment|// This is safe to ignore since a deallocate task will come in.
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setShouldUnregister
parameter_list|()
block|{    }
annotation|@
name|Override
specifier|public
name|boolean
name|hasUnregistered
parameter_list|()
block|{
comment|// Nothing to do. No registration involved.
return|return
literal|true
return|;
block|}
comment|/**    * @param request the list of preferred hosts. null implies any host    * @return    */
specifier|private
name|SelectHostResult
name|selectHost
parameter_list|(
name|TaskInfo
name|request
parameter_list|)
block|{
name|String
index|[]
name|requestedHosts
init|=
name|request
operator|.
name|requestedHosts
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"selectingHost for task={} on hosts={}"
argument_list|,
name|request
operator|.
name|task
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|requestedHosts
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|long
name|schedulerAttemptTime
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// Read-lock. Not updating any stats at the moment.
try|try
block|{
comment|// If there's no memory available, fail
if|if
condition|(
name|getTotalResources
argument_list|()
operator|.
name|getMemory
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return
name|SELECT_HOST_RESULT_INADEQUATE_TOTAL_CAPACITY
return|;
block|}
name|boolean
name|shouldDelayForLocality
init|=
name|request
operator|.
name|shouldDelayForLocality
argument_list|(
name|schedulerAttemptTime
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"ShouldDelayForLocality={} for task={} on hosts={}"
argument_list|,
name|shouldDelayForLocality
argument_list|,
name|request
operator|.
name|task
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|requestedHosts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|requestedHosts
operator|!=
literal|null
operator|&&
name|requestedHosts
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|int
name|prefHostCount
init|=
operator|-
literal|1
decl_stmt|;
name|boolean
name|requestedHostsWillBecomeAvailable
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|host
range|:
name|requestedHosts
control|)
block|{
name|prefHostCount
operator|++
expr_stmt|;
comment|// Pick the first host always. Weak attempt at cache affinity.
name|Set
argument_list|<
name|ServiceInstance
argument_list|>
name|instances
init|=
name|activeInstances
operator|.
name|getByHost
argument_list|(
name|host
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|instances
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|ServiceInstance
name|inst
range|:
name|instances
control|)
block|{
name|NodeInfo
name|nodeInfo
init|=
name|instanceToNodeMap
operator|.
name|get
argument_list|(
name|inst
operator|.
name|getWorkerIdentity
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeInfo
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|nodeInfo
operator|.
name|canAcceptTask
argument_list|()
condition|)
block|{
comment|// Successfully scheduled.
name|LOG
operator|.
name|info
argument_list|(
literal|"Assigning "
operator|+
name|nodeToString
argument_list|(
name|inst
argument_list|,
name|nodeInfo
argument_list|)
operator|+
literal|" when looking for "
operator|+
name|host
operator|+
literal|". local=true"
operator|+
literal|" FirstRequestedHost="
operator|+
operator|(
name|prefHostCount
operator|==
literal|0
operator|)
operator|+
operator|(
name|requestedHosts
operator|.
name|length
operator|>
literal|1
condition|?
literal|", #prefLocations="
operator|+
name|requestedHosts
operator|.
name|length
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|SelectHostResult
argument_list|(
name|inst
argument_list|,
name|nodeInfo
argument_list|)
return|;
block|}
else|else
block|{
comment|// The node cannot accept a task at the moment.
if|if
condition|(
name|shouldDelayForLocality
condition|)
block|{
comment|// Perform some checks on whether the node will become available or not.
if|if
condition|(
name|request
operator|.
name|shouldForceLocality
argument_list|()
condition|)
block|{
name|requestedHostsWillBecomeAvailable
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nodeInfo
operator|.
name|getEnableTime
argument_list|()
operator|>
name|request
operator|.
name|getLocalityDelayTimeout
argument_list|()
operator|&&
name|nodeInfo
operator|.
name|isDisabled
argument_list|()
operator|&&
name|nodeInfo
operator|.
name|hadCommFailure
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Host={} will not become available within requested timeout"
argument_list|,
name|nodeInfo
argument_list|)
expr_stmt|;
comment|// This node will likely be activated after the task timeout expires.
block|}
else|else
block|{
comment|// Worth waiting for the timeout.
name|requestedHostsWillBecomeAvailable
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Null NodeInfo when attempting to get host with worker identity {}, and host {}"
argument_list|,
name|inst
operator|.
name|getWorkerIdentity
argument_list|()
argument_list|,
name|host
argument_list|)
expr_stmt|;
comment|// Leave requestedHostWillBecomeAvailable as is. If some other host is found - delay,
comment|// else ends up allocating to a random host immediately.
block|}
block|}
block|}
block|}
comment|// Check if forcing the location is required.
if|if
condition|(
name|shouldDelayForLocality
condition|)
block|{
if|if
condition|(
name|requestedHostsWillBecomeAvailable
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Delaying local allocation for ["
operator|+
name|request
operator|.
name|task
operator|+
literal|"] when trying to allocate on ["
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|requestedHosts
argument_list|)
operator|+
literal|"]"
operator|+
literal|". ScheduleAttemptTime="
operator|+
name|schedulerAttemptTime
operator|+
literal|", taskDelayTimeout="
operator|+
name|request
operator|.
name|getLocalityDelayTimeout
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|SELECT_HOST_RESULT_DELAYED_LOCALITY
return|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping local allocation for ["
operator|+
name|request
operator|.
name|task
operator|+
literal|"] when trying to allocate on ["
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|requestedHosts
argument_list|)
operator|+
literal|"] since none of these hosts are part of the known list"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* fall through - miss in locality (random scheduling) or no locality-requested */
name|Entry
argument_list|<
name|String
argument_list|,
name|NodeInfo
argument_list|>
index|[]
name|all
init|=
name|instanceToNodeMap
operator|.
name|entrySet
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|Entry
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|// Check again
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting random allocation for task={}"
argument_list|,
name|request
operator|.
name|task
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|all
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|int
name|n
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|all
operator|.
name|length
argument_list|)
decl_stmt|;
comment|// start at random offset and iterate whole list
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|all
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Entry
argument_list|<
name|String
argument_list|,
name|NodeInfo
argument_list|>
name|inst
init|=
name|all
index|[
operator|(
name|i
operator|+
name|n
operator|)
operator|%
name|all
operator|.
name|length
index|]
decl_stmt|;
if|if
condition|(
name|inst
operator|.
name|getValue
argument_list|()
operator|.
name|canAcceptTask
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Assigning "
operator|+
name|nodeToString
argument_list|(
name|inst
operator|.
name|getValue
argument_list|()
operator|.
name|getServiceInstance
argument_list|()
argument_list|,
name|inst
operator|.
name|getValue
argument_list|()
argument_list|)
operator|+
literal|" when looking for any host, from #hosts="
operator|+
name|all
operator|.
name|length
operator|+
literal|", requestedHosts="
operator|+
operator|(
operator|(
name|requestedHosts
operator|==
literal|null
operator|||
name|requestedHosts
operator|.
name|length
operator|==
literal|0
operator|)
condition|?
literal|"null"
else|:
name|Arrays
operator|.
name|toString
argument_list|(
name|requestedHosts
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|SelectHostResult
argument_list|(
name|inst
operator|.
name|getValue
argument_list|()
operator|.
name|getServiceInstance
argument_list|()
argument_list|,
name|inst
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|SELECT_HOST_RESULT_DELAYED_RESOURCES
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|scanForNodeChanges
parameter_list|()
block|{
comment|/* check again whether nodes are disabled or just missing */
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|ServiceInstance
name|inst
range|:
name|activeInstances
operator|.
name|getAll
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|inst
operator|.
name|isAlive
argument_list|()
operator|&&
name|instanceToNodeMap
operator|.
name|containsKey
argument_list|(
name|inst
operator|.
name|getWorkerIdentity
argument_list|()
argument_list|)
operator|==
literal|false
condition|)
block|{
comment|/* that's a good node, not added to the allocations yet */
name|LOG
operator|.
name|info
argument_list|(
literal|"Found a new node: "
operator|+
name|inst
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|addNode
argument_list|(
name|inst
argument_list|,
operator|new
name|NodeInfo
argument_list|(
name|inst
argument_list|,
name|nodeBlacklistConf
argument_list|,
name|clock
argument_list|,
name|numSchedulableTasksPerNode
argument_list|,
name|metrics
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|addNode
parameter_list|(
name|ServiceInstance
name|inst
parameter_list|,
name|NodeInfo
name|node
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding node: "
operator|+
name|inst
argument_list|)
expr_stmt|;
comment|// we have just added a new node. Signal timeout monitor to reset timer
if|if
condition|(
name|activeInstances
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"New node added. Signalling scheduler timeout monitor thread to stop timer."
argument_list|)
expr_stmt|;
name|stopTimeoutMonitor
argument_list|()
expr_stmt|;
block|}
name|instanceToNodeMap
operator|.
name|put
argument_list|(
name|inst
operator|.
name|getWorkerIdentity
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setClusterNodeCount
argument_list|(
name|activeInstances
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Trigger scheduling since a new node became available.
name|trySchedulingPendingTasks
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|reenableDisabledNode
parameter_list|(
name|NodeInfo
name|nodeInfo
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Attempting to re-enable node: "
operator|+
name|nodeInfo
operator|.
name|getServiceInstance
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodeInfo
operator|.
name|getServiceInstance
argument_list|()
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|nodeInfo
operator|.
name|enableNode
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing dead node "
operator|+
name|nodeInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|disableInstance
parameter_list|(
name|ServiceInstance
name|instance
parameter_list|,
name|boolean
name|isCommFailure
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|NodeInfo
name|nodeInfo
init|=
name|instanceToNodeMap
operator|.
name|get
argument_list|(
name|instance
operator|.
name|getWorkerIdentity
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeInfo
operator|==
literal|null
operator|||
name|nodeInfo
operator|.
name|isDisabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node: "
operator|+
name|instance
operator|+
literal|" already disabled, or invalid. Not doing anything."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|nodeInfo
operator|.
name|disableNode
argument_list|(
name|isCommFailure
argument_list|)
expr_stmt|;
comment|// TODO: handle task to container map events in case of hard failures
name|disabledNodesQueue
operator|.
name|add
argument_list|(
name|nodeInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setDisabledNodeCount
argument_list|(
name|disabledNodesQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Trigger a scheduling run - in case there's some task which was waiting for this node to
comment|// become available.
name|trySchedulingPendingTasks
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|addPendingTask
parameter_list|(
name|TaskInfo
name|taskInfo
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|tasksAtPriority
init|=
name|pendingTasks
operator|.
name|get
argument_list|(
name|taskInfo
operator|.
name|priority
argument_list|)
decl_stmt|;
if|if
condition|(
name|tasksAtPriority
operator|==
literal|null
condition|)
block|{
name|tasksAtPriority
operator|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
expr_stmt|;
name|pendingTasks
operator|.
name|put
argument_list|(
name|taskInfo
operator|.
name|priority
argument_list|,
name|tasksAtPriority
argument_list|)
expr_stmt|;
block|}
comment|// Delayed tasks will not kick in right now. That will happen in the scheduling loop.
name|tasksAtPriority
operator|.
name|add
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
name|knownTasks
operator|.
name|putIfAbsent
argument_list|(
name|taskInfo
operator|.
name|task
argument_list|,
name|taskInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrPendingTasksCount
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"PendingTasksInfo={}"
argument_list|,
name|constructPendingTaskCountsLogMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Remove a task from the pending list */
specifier|private
name|void
name|removePendingTask
parameter_list|(
name|TaskInfo
name|taskInfo
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|Priority
name|priority
init|=
name|taskInfo
operator|.
name|priority
decl_stmt|;
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|taskInfoList
init|=
name|pendingTasks
operator|.
name|get
argument_list|(
name|priority
argument_list|)
decl_stmt|;
if|if
condition|(
name|taskInfoList
operator|==
literal|null
operator|||
name|taskInfoList
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|taskInfoList
operator|.
name|remove
argument_list|(
name|taskInfo
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not find task: "
operator|+
name|taskInfo
operator|.
name|task
operator|+
literal|" in pending list, at priority: "
operator|+
name|priority
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Register a running task into the runningTasks structure */
specifier|private
name|void
name|registerRunningTask
parameter_list|(
name|TaskInfo
name|taskInfo
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|priority
init|=
name|taskInfo
operator|.
name|priority
operator|.
name|getPriority
argument_list|()
decl_stmt|;
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
name|tasksAtpriority
init|=
name|runningTasks
operator|.
name|get
argument_list|(
name|priority
argument_list|)
decl_stmt|;
if|if
condition|(
name|tasksAtpriority
operator|==
literal|null
condition|)
block|{
name|tasksAtpriority
operator|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|TASK_INFO_COMPARATOR
argument_list|)
expr_stmt|;
name|runningTasks
operator|.
name|put
argument_list|(
name|priority
argument_list|,
name|tasksAtpriority
argument_list|)
expr_stmt|;
block|}
name|tasksAtpriority
operator|.
name|add
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|decrPendingTasksCount
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Unregister a task from the known and running structures */
specifier|private
name|TaskInfo
name|unregisterTask
parameter_list|(
name|Object
name|task
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|TaskInfo
name|taskInfo
init|=
name|knownTasks
operator|.
name|remove
argument_list|(
name|task
argument_list|)
decl_stmt|;
if|if
condition|(
name|taskInfo
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|taskInfo
operator|.
name|getState
argument_list|()
operator|==
name|TaskInfo
operator|.
name|State
operator|.
name|ASSIGNED
condition|)
block|{
comment|// Remove from the running list.
name|int
name|priority
init|=
name|taskInfo
operator|.
name|priority
operator|.
name|getPriority
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|TaskInfo
argument_list|>
name|tasksAtPriority
init|=
name|runningTasks
operator|.
name|get
argument_list|(
name|priority
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|tasksAtPriority
operator|!=
literal|null
argument_list|,
literal|"runningTasks should contain an entry if the task was in running state. Caused by task: {}"
argument_list|,
name|task
argument_list|)
expr_stmt|;
name|tasksAtPriority
operator|.
name|remove
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|tasksAtPriority
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|runningTasks
operator|.
name|remove
argument_list|(
name|priority
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not find TaskInfo for task: {}. Not removing it from the running set"
argument_list|,
name|task
argument_list|)
expr_stmt|;
block|}
return|return
name|taskInfo
return|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
enum|enum
name|ScheduleResult
block|{
comment|// Successfully scheduled
name|SCHEDULED
block|,
comment|// Delayed to find a local match
name|DELAYED_LOCALITY
block|,
comment|// Delayed due to temporary resource availability
name|DELAYED_RESOURCES
block|,
comment|// Inadequate total resources - will never succeed / wait for new executors to become available
name|INADEQUATE_TOTAL_RESOURCES
block|,   }
annotation|@
name|VisibleForTesting
specifier|protected
name|void
name|schedulePendingTasks
parameter_list|()
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ScheduleRun: {}"
argument_list|,
name|constructPendingTaskCountsLogMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|Priority
argument_list|,
name|List
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
argument_list|>
name|pendingIterator
init|=
name|pendingTasks
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|pendingIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|Priority
argument_list|,
name|List
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|entry
init|=
name|pendingIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|taskListAtPriority
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|TaskInfo
argument_list|>
name|taskIter
init|=
name|taskListAtPriority
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|boolean
name|scheduledAllAtPriority
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|taskIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// TODO Optimization: Add a check to see if there's any capacity available. No point in
comment|// walking through all active nodes, if they don't have potential capacity.
name|TaskInfo
name|taskInfo
init|=
name|taskIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|taskInfo
operator|.
name|getNumPreviousAssignAttempts
argument_list|()
operator|==
literal|1
condition|)
block|{
name|dagStats
operator|.
name|registerDelayedAllocation
argument_list|()
expr_stmt|;
block|}
name|taskInfo
operator|.
name|triedAssigningTask
argument_list|()
expr_stmt|;
name|ScheduleResult
name|scheduleResult
init|=
name|scheduleTask
argument_list|(
name|taskInfo
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"ScheduleResult for Task: {} = {}"
argument_list|,
name|taskInfo
argument_list|,
name|scheduleResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|scheduleResult
operator|==
name|ScheduleResult
operator|.
name|SCHEDULED
condition|)
block|{
name|taskIter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|scheduleResult
operator|==
name|ScheduleResult
operator|.
name|INADEQUATE_TOTAL_RESOURCES
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Inadequate total resources before scheduling pending tasks."
operator|+
literal|" Signalling scheduler timeout monitor thread to start timer."
argument_list|)
expr_stmt|;
name|startTimeoutMonitor
argument_list|()
expr_stmt|;
comment|// TODO Nothing else should be done for this task. Move on.
block|}
comment|// Try pre-empting a task so that a higher priority task can take it's place.
comment|// Preempt only if there's no pending preemptions to avoid preempting twice for a task.
name|String
index|[]
name|potentialHosts
decl_stmt|;
if|if
condition|(
name|scheduleResult
operator|==
name|ScheduleResult
operator|.
name|DELAYED_LOCALITY
condition|)
block|{
comment|// Add the task to the delayed task queue if it does not already exist.
name|maybeAddToDelayedTaskQueue
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
comment|// Try preempting a lower priority task in any case.
comment|// preempt only on specific hosts, if no preemptions already exist on those.
name|potentialHosts
operator|=
name|taskInfo
operator|.
name|requestedHosts
expr_stmt|;
comment|//Protect against a bad location being requested.
if|if
condition|(
name|potentialHosts
operator|==
literal|null
operator|||
name|potentialHosts
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|potentialHosts
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// preempt on any host.
name|potentialHosts
operator|=
literal|null
expr_stmt|;
block|}
comment|// At this point we're dealing with all return types, except ScheduleResult.SCHEDULED.
if|if
condition|(
name|potentialHosts
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting to preempt on requested host for task={}, potentialHosts={}"
argument_list|,
name|taskInfo
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|potentialHosts
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Preempt on specific host
name|boolean
name|shouldPreempt
init|=
literal|true
decl_stmt|;
for|for
control|(
name|String
name|host
range|:
name|potentialHosts
control|)
block|{
comment|// Preempt only if there are not pending preemptions on the same host
comment|// When the premption registers, the request at the highest priority will be given the slot,
comment|// even if the initial request was for some other task.
comment|// TODO Maybe register which task the preemption was for, to avoid a bad non-local allocation.
name|MutableInt
name|pendingHostPreemptions
init|=
name|pendingPreemptionsPerHost
operator|.
name|get
argument_list|(
name|host
argument_list|)
decl_stmt|;
if|if
condition|(
name|pendingHostPreemptions
operator|!=
literal|null
operator|&&
name|pendingHostPreemptions
operator|.
name|intValue
argument_list|()
operator|>
literal|0
condition|)
block|{
name|shouldPreempt
operator|=
literal|false
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not preempting for task={}. Found an existing preemption request on host={}, pendingPreemptionCount={}"
argument_list|,
name|taskInfo
operator|.
name|task
argument_list|,
name|host
argument_list|,
name|pendingHostPreemptions
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|shouldPreempt
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Preempting for {} on potential hosts={}. TotalPendingPreemptions={}"
argument_list|,
name|taskInfo
operator|.
name|task
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|potentialHosts
argument_list|)
argument_list|,
name|pendingPreemptions
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|preemptTasks
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getPriority
argument_list|()
argument_list|,
literal|1
argument_list|,
name|potentialHosts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not preempting for {} on potential hosts={}. An existing preemption request exists"
argument_list|,
name|taskInfo
operator|.
name|task
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|potentialHosts
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Either DELAYED_RESOURCES or DELAYED_LOCALITY with an unknown requested host.
comment|// Request for a preemption if there's none pending. If a single preemption is pending,
comment|// and this is the next task to be assigned, it will be assigned once that slot becomes available.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting to preempt on any host for task={}, pendingPreemptions={}"
argument_list|,
name|taskInfo
operator|.
name|task
argument_list|,
name|pendingPreemptions
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pendingPreemptions
operator|.
name|get
argument_list|()
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Preempting for task={} on any available host"
argument_list|,
name|taskInfo
operator|.
name|task
argument_list|)
expr_stmt|;
name|preemptTasks
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getPriority
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping preemption since there are {} pending preemption request. For task={}"
argument_list|,
name|pendingPreemptions
operator|.
name|get
argument_list|()
argument_list|,
name|taskInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Since there was an allocation failure - don't try assigning tasks at the next priority.
name|scheduledAllAtPriority
operator|=
literal|false
expr_stmt|;
comment|// Don't break if this allocation failure was a result of a LOCALITY_DELAY. Others could still be allocated.
if|if
condition|(
name|scheduleResult
operator|!=
name|ScheduleResult
operator|.
name|DELAYED_LOCALITY
condition|)
block|{
break|break;
block|}
block|}
comment|// end of else - i.e. could not allocate
block|}
comment|// end of loop over pending tasks
if|if
condition|(
name|taskListAtPriority
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Remove the entry, if there's nothing left at the specific priority level
name|pendingIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|scheduledAllAtPriority
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unable to schedule all requests at priority={}. Skipping subsequent priority levels"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
comment|// Don't attempt scheduling for additional priorities
break|break;
block|}
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|String
name|constructPendingTaskCountsLogMessage
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|totalCount
init|=
literal|0
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"numPriorityLevels="
argument_list|)
operator|.
name|append
argument_list|(
name|pendingTasks
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|". "
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|Priority
argument_list|,
name|List
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
argument_list|>
name|pendingIterator
init|=
name|pendingTasks
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|pendingIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|Priority
argument_list|,
name|List
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|entry
init|=
name|pendingIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|int
name|count
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|==
literal|null
condition|?
literal|0
else|:
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"[p="
argument_list|)
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|",c="
argument_list|)
operator|.
name|append
argument_list|(
name|count
argument_list|)
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
name|totalCount
operator|+=
name|count
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|". totalPendingTasks="
argument_list|)
operator|.
name|append
argument_list|(
name|totalCount
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|". delayedTaskQueueSize="
argument_list|)
operator|.
name|append
argument_list|(
name|delayedTaskQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|ScheduleResult
name|scheduleTask
parameter_list|(
name|TaskInfo
name|taskInfo
parameter_list|)
block|{
name|SelectHostResult
name|selectHostResult
init|=
name|selectHost
argument_list|(
name|taskInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectHostResult
operator|.
name|scheduleResult
operator|==
name|ScheduleResult
operator|.
name|SCHEDULED
condition|)
block|{
name|NodeServiceInstancePair
name|nsPair
init|=
name|selectHostResult
operator|.
name|nodeServiceInstancePair
decl_stmt|;
name|Container
name|container
init|=
name|containerFactory
operator|.
name|createContainer
argument_list|(
name|resourcePerExecutor
argument_list|,
name|taskInfo
operator|.
name|priority
argument_list|,
name|nsPair
operator|.
name|getServiceInstance
argument_list|()
operator|.
name|getHost
argument_list|()
argument_list|,
name|nsPair
operator|.
name|getServiceInstance
argument_list|()
operator|.
name|getRpcPort
argument_list|()
argument_list|,
name|nsPair
operator|.
name|getServiceInstance
argument_list|()
operator|.
name|getServicesAddress
argument_list|()
argument_list|)
decl_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// While updating local structures
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Assigned task {} to container {} on node={}"
argument_list|,
name|taskInfo
argument_list|,
name|container
operator|.
name|getId
argument_list|()
argument_list|,
name|nsPair
operator|.
name|getServiceInstance
argument_list|()
argument_list|)
expr_stmt|;
name|dagStats
operator|.
name|registerTaskAllocated
argument_list|(
name|taskInfo
operator|.
name|requestedHosts
argument_list|,
name|taskInfo
operator|.
name|requestedRacks
argument_list|,
name|nsPair
operator|.
name|getServiceInstance
argument_list|()
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
name|taskInfo
operator|.
name|setAssignmentInfo
argument_list|(
name|nsPair
operator|.
name|getServiceInstance
argument_list|()
argument_list|,
name|container
operator|.
name|getId
argument_list|()
argument_list|,
name|clock
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
name|registerRunningTask
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
name|nsPair
operator|.
name|getNodeInfo
argument_list|()
operator|.
name|registerTaskScheduled
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|getContext
argument_list|()
operator|.
name|taskAllocated
argument_list|(
name|taskInfo
operator|.
name|task
argument_list|,
name|taskInfo
operator|.
name|clientCookie
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
return|return
name|selectHostResult
operator|.
name|scheduleResult
return|;
block|}
comment|// Removes tasks from the runningList and sends out a preempt request to the system.
comment|// Subsequent tasks will be scheduled again once the de-allocate request for the preempted
comment|// task is processed.
specifier|private
name|void
name|preemptTasks
parameter_list|(
name|int
name|forPriority
parameter_list|,
name|int
name|numTasksToPreempt
parameter_list|,
name|String
index|[]
name|potentialHosts
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|preemptHosts
decl_stmt|;
if|if
condition|(
name|potentialHosts
operator|==
literal|null
condition|)
block|{
name|preemptHosts
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|preemptHosts
operator|=
name|Sets
operator|.
name|newHashSet
argument_list|(
name|potentialHosts
argument_list|)
expr_stmt|;
block|}
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|preemptedTaskList
init|=
literal|null
decl_stmt|;
try|try
block|{
name|NavigableMap
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|orderedMap
init|=
name|runningTasks
operator|.
name|descendingMap
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
argument_list|>
name|iterator
init|=
name|orderedMap
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|preemptedCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
operator|&&
name|preemptedCount
operator|<
name|numTasksToPreempt
condition|)
block|{
name|Entry
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|entryAtPriority
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryAtPriority
operator|.
name|getKey
argument_list|()
operator|>
name|forPriority
condition|)
block|{
name|Iterator
argument_list|<
name|TaskInfo
argument_list|>
name|taskInfoIterator
init|=
name|entryAtPriority
operator|.
name|getValue
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|taskInfoIterator
operator|.
name|hasNext
argument_list|()
operator|&&
name|preemptedCount
operator|<
name|numTasksToPreempt
condition|)
block|{
name|TaskInfo
name|taskInfo
init|=
name|taskInfoIterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|preemptHosts
operator|==
literal|null
operator|||
name|preemptHosts
operator|.
name|contains
argument_list|(
name|taskInfo
operator|.
name|assignedInstance
operator|.
name|getHost
argument_list|()
argument_list|)
condition|)
block|{
comment|// Candidate for preemption.
name|preemptedCount
operator|++
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"preempting {} for task at priority {} with potentialHosts={}"
argument_list|,
name|taskInfo
argument_list|,
name|forPriority
argument_list|,
name|potentialHosts
operator|==
literal|null
condition|?
literal|""
else|:
name|Arrays
operator|.
name|toString
argument_list|(
name|potentialHosts
argument_list|)
argument_list|)
expr_stmt|;
name|taskInfo
operator|.
name|setPreemptedInfo
argument_list|(
name|clock
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|preemptedTaskList
operator|==
literal|null
condition|)
block|{
name|preemptedTaskList
operator|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|dagStats
operator|.
name|registerTaskPreempted
argument_list|(
name|taskInfo
operator|.
name|assignedInstance
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
name|preemptedTaskList
operator|.
name|add
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
name|registerPendingPreemption
argument_list|(
name|taskInfo
operator|.
name|assignedInstance
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
comment|// Remove from the runningTaskList
name|taskInfoIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Remove entire priority level if it's been emptied.
if|if
condition|(
name|entryAtPriority
operator|.
name|getValue
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// No tasks qualify as preemptable
name|LOG
operator|.
name|info
argument_list|(
literal|"No tasks qualify as killable to schedule tasks at priority {}"
argument_list|,
name|forPriority
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// Send out the preempted request outside of the lock.
if|if
condition|(
name|preemptedTaskList
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|TaskInfo
name|taskInfo
range|:
name|preemptedTaskList
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Preempting task {}"
argument_list|,
name|taskInfo
argument_list|)
expr_stmt|;
name|getContext
argument_list|()
operator|.
name|preemptContainer
argument_list|(
name|taskInfo
operator|.
name|containerId
argument_list|)
expr_stmt|;
comment|// Preemption will finally be registered as a deallocateTask as a result of preemptContainer
comment|// That resets preemption info and allows additional tasks to be pre-empted if required.
block|}
block|}
comment|// The schedule loop will be triggered again when the deallocateTask request comes in for the
comment|// preempted task.
block|}
specifier|private
name|void
name|registerPendingPreemption
parameter_list|(
name|String
name|host
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|pendingPreemptions
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrPendingPreemptionTasksCount
argument_list|()
expr_stmt|;
block|}
name|MutableInt
name|val
init|=
name|pendingPreemptionsPerHost
operator|.
name|get
argument_list|(
name|host
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
name|val
operator|=
operator|new
name|MutableInt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pendingPreemptionsPerHost
operator|.
name|put
argument_list|(
name|host
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|val
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|unregisterPendingPreemption
parameter_list|(
name|String
name|host
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|pendingPreemptions
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|decrPendingPreemptionTasksCount
argument_list|()
expr_stmt|;
block|}
name|MutableInt
name|val
init|=
name|pendingPreemptionsPerHost
operator|.
name|get
argument_list|(
name|host
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|.
name|decrement
argument_list|()
expr_stmt|;
comment|// Not bothering with removing the entry. There's a limited number of hosts, and a good
comment|// chance that the entry will make it back in when the AM is used for a long duration.
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|maybeAddToDelayedTaskQueue
parameter_list|(
name|TaskInfo
name|taskInfo
parameter_list|)
block|{
comment|// There's no point adding a task with forceLocality set - since that will never exit the queue.
comment|// Add other tasks if they are not already in the queue.
if|if
condition|(
operator|!
name|taskInfo
operator|.
name|shouldForceLocality
argument_list|()
operator|&&
operator|!
name|taskInfo
operator|.
name|isInDelayedQueue
argument_list|()
condition|)
block|{
name|taskInfo
operator|.
name|setInDelayedQueue
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|delayedTaskQueue
operator|.
name|add
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|String
name|nodeToString
parameter_list|(
name|ServiceInstance
name|serviceInstance
parameter_list|,
name|NodeInfo
name|nodeInfo
parameter_list|)
block|{
return|return
name|serviceInstance
operator|.
name|getHost
argument_list|()
operator|+
literal|":"
operator|+
name|serviceInstance
operator|.
name|getRpcPort
argument_list|()
operator|+
literal|", workerIdentity="
operator|+
name|serviceInstance
operator|.
name|getWorkerIdentity
argument_list|()
operator|+
literal|", webAddress="
operator|+
name|serviceInstance
operator|.
name|getServicesAddress
argument_list|()
operator|+
literal|", currentlyScheduledTasksOnNode="
operator|+
name|nodeInfo
operator|.
name|numScheduledTasks
return|;
block|}
comment|// ------ Inner classes defined after this point ------
annotation|@
name|VisibleForTesting
class|class
name|DelayedTaskSchedulerCallable
implements|implements
name|Callable
argument_list|<
name|Void
argument_list|>
block|{
specifier|private
specifier|final
name|AtomicBoolean
name|isShutdown
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
block|{
while|while
condition|(
operator|!
name|isShutdown
operator|.
name|get
argument_list|()
operator|&&
operator|!
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
try|try
block|{
name|TaskInfo
name|taskInfo
init|=
name|getNextTask
argument_list|()
decl_stmt|;
name|taskInfo
operator|.
name|setInDelayedQueue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Tasks can exist in the delayed queue even after they have been scheduled.
comment|// Trigger scheduling only if the task is still in PENDING state.
name|processEvictedTask
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isShutdown
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"DelayedTaskScheduler thread interrupted after shutdown"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"DelayedTaskScheduler thread interrupted before being shutdown"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"DelayedTaskScheduler thread interrupted without being shutdown"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|isShutdown
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
name|TaskInfo
name|getNextTask
parameter_list|()
throws|throws
name|InterruptedException
block|{
return|return
name|delayedTaskQueue
operator|.
name|take
argument_list|()
return|;
block|}
specifier|public
name|void
name|processEvictedTask
parameter_list|(
name|TaskInfo
name|taskInfo
parameter_list|)
block|{
if|if
condition|(
name|shouldScheduleTask
argument_list|(
name|taskInfo
argument_list|)
condition|)
block|{
name|trySchedulingPendingTasks
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|shouldScheduleTask
parameter_list|(
name|TaskInfo
name|taskInfo
parameter_list|)
block|{
return|return
name|taskInfo
operator|.
name|getState
argument_list|()
operator|==
name|TaskInfo
operator|.
name|State
operator|.
name|PENDING
return|;
block|}
block|}
annotation|@
name|VisibleForTesting
name|DelayedTaskSchedulerCallable
name|createDelayedTaskSchedulerCallable
parameter_list|()
block|{
return|return
operator|new
name|DelayedTaskSchedulerCallable
argument_list|()
return|;
block|}
specifier|private
class|class
name|NodeEnablerCallable
implements|implements
name|Callable
argument_list|<
name|Void
argument_list|>
block|{
specifier|private
specifier|final
name|AtomicBoolean
name|isShutdown
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|REFRESH_INTERVAL
init|=
literal|10000l
decl_stmt|;
name|long
name|nextPollInterval
init|=
name|REFRESH_INTERVAL
decl_stmt|;
name|long
name|lastRefreshTime
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
block|{
name|lastRefreshTime
operator|=
name|LlapTaskSchedulerService
operator|.
name|this
operator|.
name|clock
operator|.
name|getTime
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|isShutdown
operator|.
name|get
argument_list|()
operator|&&
operator|!
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|NodeInfo
name|nodeInfo
init|=
name|disabledNodesQueue
operator|.
name|poll
argument_list|(
name|nextPollInterval
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeInfo
operator|!=
literal|null
condition|)
block|{
name|long
name|currentTime
init|=
name|LlapTaskSchedulerService
operator|.
name|this
operator|.
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
comment|// A node became available. Enable the node and try scheduling.
name|reenableDisabledNode
argument_list|(
name|nodeInfo
argument_list|)
expr_stmt|;
name|trySchedulingPendingTasks
argument_list|()
expr_stmt|;
name|nextPollInterval
operator|-=
operator|(
name|currentTime
operator|-
name|lastRefreshTime
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|nextPollInterval
operator|<
literal|0
operator|||
name|nodeInfo
operator|==
literal|null
condition|)
block|{
comment|// timeout expired. Reset the poll interval and refresh nodes.
name|nextPollInterval
operator|=
name|REFRESH_INTERVAL
expr_stmt|;
name|lastRefreshTime
operator|=
name|LlapTaskSchedulerService
operator|.
name|this
operator|.
name|clock
operator|.
name|getTime
argument_list|()
expr_stmt|;
comment|// TODO Get rid of this polling once we have notificaitons from the registry sub-system
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Refreshing instances based on poll interval"
argument_list|)
expr_stmt|;
block|}
name|scanForNodeChanges
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isShutdown
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"NodeEnabler thread interrupted after shutdown"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"NodeEnabler thread interrupted without being shutdown"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"NodeEnabler thread interrupted without being shutdown"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|// Call this first, then send in an interrupt to the thread.
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|isShutdown
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|trySchedulingPendingTasks
parameter_list|()
block|{
name|scheduleLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|pendingScheduleInvocations
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|scheduleCondition
operator|.
name|signal
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|scheduleLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
class|class
name|SchedulerTimeoutMonitor
implements|implements
name|Runnable
block|{
specifier|private
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SchedulerTimeoutMonitor
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Reporting SERVICE_UNAVAILABLE error as no instances are running"
argument_list|)
expr_stmt|;
try|try
block|{
name|getContext
argument_list|()
operator|.
name|reportError
argument_list|(
name|ServicePluginErrorDefaults
operator|.
name|SERVICE_UNAVAILABLE
argument_list|,
literal|"No LLAP Daemons are running"
argument_list|,
name|getContext
argument_list|()
operator|.
name|getCurrentDagInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception when reporting SERVICE_UNAVAILABLE error for dag: {}"
argument_list|,
name|getContext
argument_list|()
operator|.
name|getCurrentDagInfo
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
class|class
name|SchedulerCallable
implements|implements
name|Callable
argument_list|<
name|Void
argument_list|>
block|{
specifier|private
name|AtomicBoolean
name|isShutdown
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
block|{
while|while
condition|(
operator|!
name|isShutdown
operator|.
name|get
argument_list|()
operator|&&
operator|!
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
name|scheduleLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
while|while
condition|(
operator|!
name|pendingScheduleInvocations
operator|.
name|get
argument_list|()
condition|)
block|{
name|scheduleCondition
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isShutdown
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Scheduler thread interrupted after shutdown"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Scheduler thread interrupted without being shutdown"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Scheduler thread interrupted without being shutdown"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|scheduleLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// Set pending to false since scheduling is about to run. Any triggers up to this point
comment|// will be handled in the next run.
comment|// A new request may come in right after this is set to false, but before the actual scheduling.
comment|// This will be handled in this run, but will cause an immediate run after, which is harmless.
comment|// This is mainly to handle a trySchedue request while in the middle of a run - since the event
comment|// which triggered it may not be processed for all tasks in the run.
name|pendingScheduleInvocations
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Schedule outside of the scheduleLock - which should only be used to wait on the condition.
name|schedulePendingTasks
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|// Call this first, then send in an interrupt to the thread.
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|isShutdown
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ------ Additional static classes defined after this point ------
annotation|@
name|VisibleForTesting
specifier|static
class|class
name|NodeInfo
implements|implements
name|Delayed
block|{
specifier|private
specifier|final
name|NodeBlacklistConf
name|blacklistConf
decl_stmt|;
specifier|final
name|ServiceInstance
name|serviceInstance
decl_stmt|;
specifier|private
specifier|final
name|Clock
name|clock
decl_stmt|;
name|long
name|expireTimeMillis
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|long
name|numSuccessfulTasks
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|numSuccessfulTasksAtLastBlacklist
init|=
operator|-
literal|1
decl_stmt|;
name|float
name|cumulativeBackoffFactor
init|=
literal|1.0f
decl_stmt|;
comment|// Indicates whether a node had a recent communication failure.
comment|// This is primarily for tracking and logging purposes for the moment.
comment|// TODO At some point, treat task rejection and communication failures differently.
specifier|private
name|boolean
name|hadCommFailure
init|=
literal|false
decl_stmt|;
comment|// Indicates whether a node is disabled - for whatever reason - commFailure, busy, etc.
specifier|private
name|boolean
name|disabled
init|=
literal|false
decl_stmt|;
specifier|private
name|int
name|numPreemptedTasks
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|numScheduledTasks
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|int
name|numSchedulableTasks
decl_stmt|;
specifier|private
specifier|final
name|LlapTaskSchedulerMetrics
name|metrics
decl_stmt|;
comment|/**      * Create a NodeInfo bound to a service instance      *  @param serviceInstance         the associated serviceInstance      * @param blacklistConf           blacklist configuration      * @param clock                   clock to use to obtain timing information      * @param numSchedulableTasksConf number of schedulable tasks on the node. 0 represents auto *                                detect based on the serviceInstance, -1 indicates indicates      * @param metrics      */
name|NodeInfo
parameter_list|(
name|ServiceInstance
name|serviceInstance
parameter_list|,
name|NodeBlacklistConf
name|blacklistConf
parameter_list|,
name|Clock
name|clock
parameter_list|,
name|int
name|numSchedulableTasksConf
parameter_list|,
specifier|final
name|LlapTaskSchedulerMetrics
name|metrics
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|numSchedulableTasksConf
operator|>=
operator|-
literal|1
argument_list|,
literal|"NumSchedulableTasks must be>=-1"
argument_list|)
expr_stmt|;
name|this
operator|.
name|serviceInstance
operator|=
name|serviceInstance
expr_stmt|;
name|this
operator|.
name|blacklistConf
operator|=
name|blacklistConf
expr_stmt|;
name|this
operator|.
name|clock
operator|=
name|clock
expr_stmt|;
name|this
operator|.
name|metrics
operator|=
name|metrics
expr_stmt|;
if|if
condition|(
name|numSchedulableTasksConf
operator|==
literal|0
condition|)
block|{
name|int
name|pendingQueueuCapacity
init|=
literal|0
decl_stmt|;
name|String
name|pendingQueueCapacityString
init|=
name|serviceInstance
operator|.
name|getProperties
argument_list|()
operator|.
name|get
argument_list|(
name|ConfVars
operator|.
name|LLAP_DAEMON_TASK_SCHEDULER_WAIT_QUEUE_SIZE
operator|.
name|varname
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Setting up node: {} with available capacity={}, pendingQueueSize={}, memory={}"
argument_list|,
name|serviceInstance
argument_list|,
name|serviceInstance
operator|.
name|getResource
argument_list|()
operator|.
name|getVirtualCores
argument_list|()
argument_list|,
name|pendingQueueCapacityString
argument_list|,
name|serviceInstance
operator|.
name|getResource
argument_list|()
operator|.
name|getMemory
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pendingQueueCapacityString
operator|!=
literal|null
condition|)
block|{
name|pendingQueueuCapacity
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|pendingQueueCapacityString
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|numSchedulableTasks
operator|=
name|serviceInstance
operator|.
name|getResource
argument_list|()
operator|.
name|getVirtualCores
argument_list|()
operator|+
name|pendingQueueuCapacity
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|numSchedulableTasks
operator|=
name|numSchedulableTasksConf
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Setting up node: "
operator|+
name|serviceInstance
operator|+
literal|" with schedulableCapacity="
operator|+
name|this
operator|.
name|numSchedulableTasks
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrSchedulableTasksCount
argument_list|(
name|numSchedulableTasks
argument_list|)
expr_stmt|;
block|}
block|}
name|ServiceInstance
name|getServiceInstance
parameter_list|()
block|{
return|return
name|serviceInstance
return|;
block|}
name|void
name|enableNode
parameter_list|()
block|{
name|expireTimeMillis
operator|=
operator|-
literal|1
expr_stmt|;
name|disabled
operator|=
literal|false
expr_stmt|;
name|hadCommFailure
operator|=
literal|false
expr_stmt|;
block|}
name|void
name|disableNode
parameter_list|(
name|boolean
name|commFailure
parameter_list|)
block|{
name|long
name|duration
init|=
name|blacklistConf
operator|.
name|minDelay
decl_stmt|;
name|long
name|currentTime
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|this
operator|.
name|hadCommFailure
operator|=
name|commFailure
expr_stmt|;
name|disabled
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|numSuccessfulTasksAtLastBlacklist
operator|==
name|numSuccessfulTasks
condition|)
block|{
comment|// Relying on a task succeeding to reset the exponent.
comment|// There's no notifications on whether a task gets accepted or not. That would be ideal to
comment|// reset this.
name|cumulativeBackoffFactor
operator|=
name|cumulativeBackoffFactor
operator|*
name|blacklistConf
operator|.
name|backoffFactor
expr_stmt|;
block|}
else|else
block|{
comment|// Was able to execute something before the last blacklist. Reset the exponent.
name|cumulativeBackoffFactor
operator|=
literal|1.0f
expr_stmt|;
block|}
name|long
name|delayTime
init|=
call|(
name|long
call|)
argument_list|(
name|duration
operator|*
name|cumulativeBackoffFactor
argument_list|)
decl_stmt|;
if|if
condition|(
name|delayTime
operator|>
name|blacklistConf
operator|.
name|maxDelay
condition|)
block|{
name|delayTime
operator|=
name|blacklistConf
operator|.
name|maxDelay
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Disabling instance {} for {} milli-seconds. commFailure={}"
argument_list|,
name|serviceInstance
argument_list|,
name|delayTime
argument_list|,
name|commFailure
argument_list|)
expr_stmt|;
block|}
name|expireTimeMillis
operator|=
name|currentTime
operator|+
name|delayTime
expr_stmt|;
name|numSuccessfulTasksAtLastBlacklist
operator|=
name|numSuccessfulTasks
expr_stmt|;
block|}
name|void
name|registerTaskScheduled
parameter_list|()
block|{
name|numScheduledTasks
operator|++
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrRunningTasksCount
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|decrSchedulableTasksCount
argument_list|()
expr_stmt|;
block|}
block|}
name|void
name|registerTaskSuccess
parameter_list|()
block|{
name|numSuccessfulTasks
operator|++
expr_stmt|;
name|numScheduledTasks
operator|--
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrSuccessfulTasksCount
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|decrRunningTasksCount
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|incrSchedulableTasksCount
argument_list|()
expr_stmt|;
block|}
block|}
name|void
name|registerUnsuccessfulTaskEnd
parameter_list|(
name|boolean
name|wasPreempted
parameter_list|)
block|{
name|numScheduledTasks
operator|--
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|decrRunningTasksCount
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|incrSchedulableTasksCount
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|wasPreempted
condition|)
block|{
name|numPreemptedTasks
operator|++
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrPreemptedTasksCount
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * @return the time at which this node will be re-enabled      */
specifier|public
name|long
name|getEnableTime
parameter_list|()
block|{
return|return
name|expireTimeMillis
return|;
block|}
specifier|public
name|boolean
name|isDisabled
parameter_list|()
block|{
return|return
name|disabled
return|;
block|}
specifier|public
name|boolean
name|hadCommFailure
parameter_list|()
block|{
return|return
name|hadCommFailure
return|;
block|}
comment|/* Returning true does not guarantee that the task will run, considering other queries     may be running in the system. Also depends upon the capacity usage configuration      */
specifier|public
name|boolean
name|canAcceptTask
parameter_list|()
block|{
name|boolean
name|result
init|=
operator|!
name|hadCommFailure
operator|&&
operator|!
name|disabled
operator|&&
name|serviceInstance
operator|.
name|isAlive
argument_list|()
operator|&&
operator|(
name|numSchedulableTasks
operator|==
operator|-
literal|1
operator|||
operator|(
operator|(
name|numSchedulableTasks
operator|-
name|numScheduledTasks
operator|)
operator|>
literal|0
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Node["
operator|+
name|serviceInstance
operator|.
name|getHost
argument_list|()
operator|+
literal|":"
operator|+
name|serviceInstance
operator|.
name|getRpcPort
argument_list|()
operator|+
literal|", "
operator|+
name|serviceInstance
operator|.
name|getWorkerIdentity
argument_list|()
operator|+
literal|"]: "
operator|+
literal|"canAcceptTask={}, numScheduledTasks={}, numSchedulableTasks={}, hadCommFailure={}, disabled={}, serviceInstance.isAlive={}"
argument_list|,
name|result
argument_list|,
name|numScheduledTasks
argument_list|,
name|numSchedulableTasks
argument_list|,
name|hadCommFailure
argument_list|,
name|disabled
argument_list|,
name|serviceInstance
operator|.
name|isAlive
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getDelay
parameter_list|(
name|TimeUnit
name|unit
parameter_list|)
block|{
return|return
name|unit
operator|.
name|convert
argument_list|(
name|expireTimeMillis
operator|-
name|clock
operator|.
name|getTime
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
name|Delayed
name|o
parameter_list|)
block|{
name|NodeInfo
name|other
init|=
operator|(
name|NodeInfo
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|other
operator|.
name|expireTimeMillis
operator|>
name|this
operator|.
name|expireTimeMillis
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|other
operator|.
name|expireTimeMillis
operator|<
name|this
operator|.
name|expireTimeMillis
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"NodeInfo{"
operator|+
literal|"instance="
operator|+
name|serviceInstance
operator|+
literal|", expireTimeMillis="
operator|+
name|expireTimeMillis
operator|+
literal|", numSuccessfulTasks="
operator|+
name|numSuccessfulTasks
operator|+
literal|", numSuccessfulTasksAtLastBlacklist="
operator|+
name|numSuccessfulTasksAtLastBlacklist
operator|+
literal|", cumulativeBackoffFactor="
operator|+
name|cumulativeBackoffFactor
operator|+
literal|", numSchedulableTasks="
operator|+
name|numSchedulableTasks
operator|+
literal|", numScheduledTasks="
operator|+
name|numScheduledTasks
operator|+
literal|", disabled="
operator|+
name|disabled
operator|+
literal|", commFailures="
operator|+
name|hadCommFailure
operator|+
literal|'}'
return|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|static
class|class
name|StatsPerDag
block|{
name|int
name|numRequestedAllocations
init|=
literal|0
decl_stmt|;
name|int
name|numRequestsWithLocation
init|=
literal|0
decl_stmt|;
name|int
name|numRequestsWithoutLocation
init|=
literal|0
decl_stmt|;
name|int
name|numTotalAllocations
init|=
literal|0
decl_stmt|;
name|int
name|numLocalAllocations
init|=
literal|0
decl_stmt|;
name|int
name|numNonLocalAllocations
init|=
literal|0
decl_stmt|;
name|int
name|numAllocationsNoLocalityRequest
init|=
literal|0
decl_stmt|;
name|int
name|numRejectedTasks
init|=
literal|0
decl_stmt|;
name|int
name|numCommFailures
init|=
literal|0
decl_stmt|;
name|int
name|numDelayedAllocations
init|=
literal|0
decl_stmt|;
name|int
name|numPreemptedTasks
init|=
literal|0
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
name|localityBasedNumAllocationsPerHost
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
name|numAllocationsPerHost
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumPreemptedTasks="
argument_list|)
operator|.
name|append
argument_list|(
name|numPreemptedTasks
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumRequestedAllocations="
argument_list|)
operator|.
name|append
argument_list|(
name|numRequestedAllocations
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumRequestsWithlocation="
argument_list|)
operator|.
name|append
argument_list|(
name|numRequestsWithLocation
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumLocalAllocations="
argument_list|)
operator|.
name|append
argument_list|(
name|numLocalAllocations
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumNonLocalAllocations="
argument_list|)
operator|.
name|append
argument_list|(
name|numNonLocalAllocations
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumTotalAllocations="
argument_list|)
operator|.
name|append
argument_list|(
name|numTotalAllocations
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumRequestsWithoutLocation="
argument_list|)
operator|.
name|append
argument_list|(
name|numRequestsWithoutLocation
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumRejectedTasks="
argument_list|)
operator|.
name|append
argument_list|(
name|numRejectedTasks
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumCommFailures="
argument_list|)
operator|.
name|append
argument_list|(
name|numCommFailures
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumDelayedAllocations="
argument_list|)
operator|.
name|append
argument_list|(
name|numDelayedAllocations
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"LocalityBasedAllocationsPerHost="
argument_list|)
operator|.
name|append
argument_list|(
name|localityBasedNumAllocationsPerHost
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumAllocationsPerHost="
argument_list|)
operator|.
name|append
argument_list|(
name|numAllocationsPerHost
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
name|void
name|registerTaskRequest
parameter_list|(
name|String
index|[]
name|requestedHosts
parameter_list|,
name|String
index|[]
name|requestedRacks
parameter_list|)
block|{
name|numRequestedAllocations
operator|++
expr_stmt|;
comment|// TODO Change after HIVE-9987. For now, there's no rack matching.
if|if
condition|(
name|requestedHosts
operator|!=
literal|null
operator|&&
name|requestedHosts
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|numRequestsWithLocation
operator|++
expr_stmt|;
block|}
else|else
block|{
name|numRequestsWithoutLocation
operator|++
expr_stmt|;
block|}
block|}
name|void
name|registerTaskAllocated
parameter_list|(
name|String
index|[]
name|requestedHosts
parameter_list|,
name|String
index|[]
name|requestedRacks
parameter_list|,
name|String
name|allocatedHost
parameter_list|)
block|{
comment|// TODO Change after HIVE-9987. For now, there's no rack matching.
if|if
condition|(
name|requestedHosts
operator|!=
literal|null
operator|&&
name|requestedHosts
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|requestedHostSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|requestedHosts
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|requestedHostSet
operator|.
name|contains
argument_list|(
name|allocatedHost
argument_list|)
condition|)
block|{
name|numLocalAllocations
operator|++
expr_stmt|;
name|_registerAllocationInHostMap
argument_list|(
name|allocatedHost
argument_list|,
name|localityBasedNumAllocationsPerHost
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|numNonLocalAllocations
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|numAllocationsNoLocalityRequest
operator|++
expr_stmt|;
block|}
name|numTotalAllocations
operator|++
expr_stmt|;
name|_registerAllocationInHostMap
argument_list|(
name|allocatedHost
argument_list|,
name|numAllocationsPerHost
argument_list|)
expr_stmt|;
block|}
name|void
name|registerTaskPreempted
parameter_list|(
name|String
name|host
parameter_list|)
block|{
name|numPreemptedTasks
operator|++
expr_stmt|;
block|}
name|void
name|registerCommFailure
parameter_list|(
name|String
name|host
parameter_list|)
block|{
name|numCommFailures
operator|++
expr_stmt|;
block|}
name|void
name|registerTaskRejected
parameter_list|(
name|String
name|host
parameter_list|)
block|{
name|numRejectedTasks
operator|++
expr_stmt|;
block|}
name|void
name|registerDelayedAllocation
parameter_list|()
block|{
name|numDelayedAllocations
operator|++
expr_stmt|;
block|}
specifier|private
name|void
name|_registerAllocationInHostMap
parameter_list|(
name|String
name|host
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
name|hostMap
parameter_list|)
block|{
name|AtomicInteger
name|val
init|=
name|hostMap
operator|.
name|get
argument_list|(
name|host
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
name|val
operator|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hostMap
operator|.
name|put
argument_list|(
name|host
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|val
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
comment|// TODO There needs to be a mechanism to figure out different attempts for the same task. Delays
comment|// could potentially be changed based on this.
annotation|@
name|VisibleForTesting
specifier|static
class|class
name|TaskInfo
implements|implements
name|Delayed
block|{
enum|enum
name|State
block|{
name|PENDING
block|,
name|ASSIGNED
block|,
name|PREEMPTED
block|}
comment|// IDs used to ensure two TaskInfos are different without using the underlying task instance.
comment|// Required for insertion into a TreeMap
specifier|static
specifier|final
name|AtomicLong
name|ID_GEN
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|long
name|uniqueId
decl_stmt|;
specifier|final
name|LocalityDelayConf
name|localityDelayConf
decl_stmt|;
specifier|final
name|Clock
name|clock
decl_stmt|;
specifier|final
name|Object
name|task
decl_stmt|;
specifier|final
name|Object
name|clientCookie
decl_stmt|;
specifier|final
name|Priority
name|priority
decl_stmt|;
specifier|final
name|Resource
name|capability
decl_stmt|;
specifier|final
name|String
index|[]
name|requestedHosts
decl_stmt|;
specifier|final
name|String
index|[]
name|requestedRacks
decl_stmt|;
specifier|final
name|long
name|requestTime
decl_stmt|;
specifier|final
name|long
name|localityDelayTimeout
decl_stmt|;
name|long
name|startTime
decl_stmt|;
name|long
name|preemptTime
decl_stmt|;
name|ContainerId
name|containerId
decl_stmt|;
name|ServiceInstance
name|assignedInstance
decl_stmt|;
specifier|private
name|State
name|state
init|=
name|State
operator|.
name|PENDING
decl_stmt|;
name|boolean
name|inDelayedQueue
init|=
literal|false
decl_stmt|;
specifier|private
name|int
name|numAssignAttempts
init|=
literal|0
decl_stmt|;
comment|// TaskInfo instances for two different tasks will not be the same. Only a single instance should
comment|// ever be created for a taskAttempt
specifier|public
name|TaskInfo
parameter_list|(
name|LocalityDelayConf
name|localityDelayConf
parameter_list|,
name|Clock
name|clock
parameter_list|,
name|Object
name|task
parameter_list|,
name|Object
name|clientCookie
parameter_list|,
name|Priority
name|priority
parameter_list|,
name|Resource
name|capability
parameter_list|,
name|String
index|[]
name|hosts
parameter_list|,
name|String
index|[]
name|racks
parameter_list|,
name|long
name|requestTime
parameter_list|)
block|{
name|this
operator|.
name|localityDelayConf
operator|=
name|localityDelayConf
expr_stmt|;
name|this
operator|.
name|clock
operator|=
name|clock
expr_stmt|;
name|this
operator|.
name|task
operator|=
name|task
expr_stmt|;
name|this
operator|.
name|clientCookie
operator|=
name|clientCookie
expr_stmt|;
name|this
operator|.
name|priority
operator|=
name|priority
expr_stmt|;
name|this
operator|.
name|capability
operator|=
name|capability
expr_stmt|;
name|this
operator|.
name|requestedHosts
operator|=
name|hosts
expr_stmt|;
name|this
operator|.
name|requestedRacks
operator|=
name|racks
expr_stmt|;
name|this
operator|.
name|requestTime
operator|=
name|requestTime
expr_stmt|;
if|if
condition|(
name|localityDelayConf
operator|.
name|getNodeLocalityDelay
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|localityDelayTimeout
operator|=
name|Long
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|localityDelayConf
operator|.
name|getNodeLocalityDelay
argument_list|()
operator|==
literal|0
condition|)
block|{
name|localityDelayTimeout
operator|=
literal|0L
expr_stmt|;
block|}
else|else
block|{
name|localityDelayTimeout
operator|=
name|requestTime
operator|+
name|localityDelayConf
operator|.
name|getNodeLocalityDelay
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|uniqueId
operator|=
name|ID_GEN
operator|.
name|getAndIncrement
argument_list|()
expr_stmt|;
block|}
specifier|synchronized
name|void
name|setAssignmentInfo
parameter_list|(
name|ServiceInstance
name|instance
parameter_list|,
name|ContainerId
name|containerId
parameter_list|,
name|long
name|startTime
parameter_list|)
block|{
name|this
operator|.
name|assignedInstance
operator|=
name|instance
expr_stmt|;
name|this
operator|.
name|containerId
operator|=
name|containerId
expr_stmt|;
name|this
operator|.
name|startTime
operator|=
name|startTime
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|State
operator|.
name|ASSIGNED
expr_stmt|;
block|}
specifier|synchronized
name|void
name|setPreemptedInfo
parameter_list|(
name|long
name|preemptTime
parameter_list|)
block|{
name|this
operator|.
name|state
operator|=
name|State
operator|.
name|PREEMPTED
expr_stmt|;
name|this
operator|.
name|preemptTime
operator|=
name|preemptTime
expr_stmt|;
block|}
specifier|synchronized
name|void
name|setInDelayedQueue
parameter_list|(
name|boolean
name|val
parameter_list|)
block|{
name|this
operator|.
name|inDelayedQueue
operator|=
name|val
expr_stmt|;
block|}
specifier|synchronized
name|void
name|triedAssigningTask
parameter_list|()
block|{
name|numAssignAttempts
operator|++
expr_stmt|;
block|}
specifier|synchronized
name|int
name|getNumPreviousAssignAttempts
parameter_list|()
block|{
return|return
name|numAssignAttempts
return|;
block|}
specifier|synchronized
name|State
name|getState
parameter_list|()
block|{
return|return
name|state
return|;
block|}
specifier|synchronized
name|boolean
name|isInDelayedQueue
parameter_list|()
block|{
return|return
name|inDelayedQueue
return|;
block|}
name|boolean
name|shouldDelayForLocality
parameter_list|(
name|long
name|schedulerAttemptTime
parameter_list|)
block|{
comment|// getDelay<=0 means the task will be evicted from the queue.
return|return
name|localityDelayTimeout
operator|>
name|schedulerAttemptTime
return|;
block|}
name|boolean
name|shouldForceLocality
parameter_list|()
block|{
return|return
name|localityDelayTimeout
operator|==
name|Long
operator|.
name|MAX_VALUE
return|;
block|}
name|long
name|getLocalityDelayTimeout
parameter_list|()
block|{
return|return
name|localityDelayTimeout
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|TaskInfo
name|taskInfo
init|=
operator|(
name|TaskInfo
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|uniqueId
operator|!=
name|taskInfo
operator|.
name|uniqueId
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|task
operator|.
name|equals
argument_list|(
name|taskInfo
operator|.
name|task
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|result
init|=
call|(
name|int
call|)
argument_list|(
name|uniqueId
operator|^
operator|(
name|uniqueId
operator|>>>
literal|32
operator|)
argument_list|)
decl_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
name|task
operator|.
name|hashCode
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"TaskInfo{"
operator|+
literal|"task="
operator|+
name|task
operator|+
literal|", priority="
operator|+
name|priority
operator|+
literal|", startTime="
operator|+
name|startTime
operator|+
literal|", containerId="
operator|+
name|containerId
operator|+
literal|", assignedInstance="
operator|+
name|assignedInstance
operator|+
literal|", uniqueId="
operator|+
name|uniqueId
operator|+
literal|", localityDelayTimeout="
operator|+
name|localityDelayTimeout
operator|+
literal|'}'
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getDelay
parameter_list|(
name|TimeUnit
name|unit
parameter_list|)
block|{
return|return
name|unit
operator|.
name|convert
argument_list|(
name|localityDelayTimeout
operator|-
name|clock
operator|.
name|getTime
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
name|Delayed
name|o
parameter_list|)
block|{
name|TaskInfo
name|other
init|=
operator|(
name|TaskInfo
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|other
operator|.
name|localityDelayTimeout
operator|>
name|this
operator|.
name|localityDelayTimeout
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|other
operator|.
name|localityDelayTimeout
operator|<
name|this
operator|.
name|localityDelayTimeout
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
comment|// Newer tasks first.
specifier|private
specifier|static
class|class
name|TaskStartComparator
implements|implements
name|Comparator
argument_list|<
name|TaskInfo
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|TaskInfo
name|o1
parameter_list|,
name|TaskInfo
name|o2
parameter_list|)
block|{
if|if
condition|(
name|o1
operator|.
name|startTime
operator|>
name|o2
operator|.
name|startTime
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|o1
operator|.
name|startTime
operator|<
name|o2
operator|.
name|startTime
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
comment|// Comparing on time is not sufficient since two may be created at the same time,
comment|// in which case inserting into a TreeSet/Map would break
if|if
condition|(
name|o1
operator|.
name|uniqueId
operator|>
name|o2
operator|.
name|uniqueId
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|o1
operator|.
name|uniqueId
operator|<
name|o2
operator|.
name|uniqueId
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
specifier|private
specifier|static
class|class
name|SelectHostResult
block|{
specifier|final
name|NodeServiceInstancePair
name|nodeServiceInstancePair
decl_stmt|;
specifier|final
name|ScheduleResult
name|scheduleResult
decl_stmt|;
name|SelectHostResult
parameter_list|(
name|ServiceInstance
name|serviceInstance
parameter_list|,
name|NodeInfo
name|nodeInfo
parameter_list|)
block|{
name|this
operator|.
name|nodeServiceInstancePair
operator|=
operator|new
name|NodeServiceInstancePair
argument_list|(
name|serviceInstance
argument_list|,
name|nodeInfo
argument_list|)
expr_stmt|;
name|this
operator|.
name|scheduleResult
operator|=
name|ScheduleResult
operator|.
name|SCHEDULED
expr_stmt|;
block|}
name|SelectHostResult
parameter_list|(
name|ScheduleResult
name|scheduleResult
parameter_list|)
block|{
name|this
operator|.
name|nodeServiceInstancePair
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|scheduleResult
operator|=
name|scheduleResult
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|SelectHostResult
name|SELECT_HOST_RESULT_INADEQUATE_TOTAL_CAPACITY
init|=
operator|new
name|SelectHostResult
argument_list|(
name|ScheduleResult
operator|.
name|INADEQUATE_TOTAL_RESOURCES
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|SelectHostResult
name|SELECT_HOST_RESULT_DELAYED_LOCALITY
init|=
operator|new
name|SelectHostResult
argument_list|(
name|ScheduleResult
operator|.
name|DELAYED_LOCALITY
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|SelectHostResult
name|SELECT_HOST_RESULT_DELAYED_RESOURCES
init|=
operator|new
name|SelectHostResult
argument_list|(
name|ScheduleResult
operator|.
name|DELAYED_RESOURCES
argument_list|)
decl_stmt|;
specifier|private
specifier|static
class|class
name|NodeServiceInstancePair
block|{
specifier|final
name|NodeInfo
name|nodeInfo
decl_stmt|;
specifier|final
name|ServiceInstance
name|serviceInstance
decl_stmt|;
specifier|private
name|NodeServiceInstancePair
parameter_list|(
name|ServiceInstance
name|serviceInstance
parameter_list|,
name|NodeInfo
name|nodeInfo
parameter_list|)
block|{
name|this
operator|.
name|serviceInstance
operator|=
name|serviceInstance
expr_stmt|;
name|this
operator|.
name|nodeInfo
operator|=
name|nodeInfo
expr_stmt|;
block|}
specifier|public
name|ServiceInstance
name|getServiceInstance
parameter_list|()
block|{
return|return
name|serviceInstance
return|;
block|}
specifier|public
name|NodeInfo
name|getNodeInfo
parameter_list|()
block|{
return|return
name|nodeInfo
return|;
block|}
block|}
specifier|private
specifier|static
specifier|final
class|class
name|NodeBlacklistConf
block|{
specifier|private
specifier|final
name|long
name|minDelay
decl_stmt|;
specifier|private
specifier|final
name|long
name|maxDelay
decl_stmt|;
specifier|private
specifier|final
name|float
name|backoffFactor
decl_stmt|;
specifier|public
name|NodeBlacklistConf
parameter_list|(
name|long
name|minDelay
parameter_list|,
name|long
name|maxDelay
parameter_list|,
name|float
name|backoffFactor
parameter_list|)
block|{
name|this
operator|.
name|minDelay
operator|=
name|minDelay
expr_stmt|;
name|this
operator|.
name|maxDelay
operator|=
name|maxDelay
expr_stmt|;
name|this
operator|.
name|backoffFactor
operator|=
name|backoffFactor
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"NodeBlacklistConf{"
operator|+
literal|"minDelay="
operator|+
name|minDelay
operator|+
literal|", maxDelay="
operator|+
name|maxDelay
operator|+
literal|", backoffFactor="
operator|+
name|backoffFactor
operator|+
literal|'}'
return|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|static
specifier|final
class|class
name|LocalityDelayConf
block|{
specifier|private
specifier|final
name|long
name|nodeLocalityDelay
decl_stmt|;
specifier|public
name|LocalityDelayConf
parameter_list|(
name|long
name|nodeLocalityDelay
parameter_list|)
block|{
name|this
operator|.
name|nodeLocalityDelay
operator|=
name|nodeLocalityDelay
expr_stmt|;
block|}
specifier|public
name|long
name|getNodeLocalityDelay
parameter_list|()
block|{
return|return
name|nodeLocalityDelay
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"LocalityDelayConf{"
operator|+
literal|"nodeLocalityDelay="
operator|+
name|nodeLocalityDelay
operator|+
literal|'}'
return|;
block|}
block|}
block|}
end_class

end_unit

