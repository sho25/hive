begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|tezplugins
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
operator|.
name|ByteArrayDataOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|registry
operator|.
name|ServiceInstanceSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|registry
operator|.
name|impl
operator|.
name|TezAmRegistryImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|registry
operator|.
name|ServiceInstanceStateChangeListener
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|DelayQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Delayed
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|codec
operator|.
name|binary
operator|.
name|Base64
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|mutable
operator|.
name|MutableInt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|JvmPauseMonitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|metrics
operator|.
name|LlapMetricsSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|metrics
operator|.
name|MetricsUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|plugin
operator|.
name|rpc
operator|.
name|LlapPluginProtocolProtos
operator|.
name|UpdateQueryRequestProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|registry
operator|.
name|LlapServiceInstance
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|registry
operator|.
name|LlapServiceInstanceSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|registry
operator|.
name|impl
operator|.
name|InactiveServiceInstance
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|registry
operator|.
name|impl
operator|.
name|LlapRegistryService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|tezplugins
operator|.
name|LlapTaskCommunicator
operator|.
name|OperationCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|tezplugins
operator|.
name|endpoint
operator|.
name|LlapPluginServerImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|tezplugins
operator|.
name|helpers
operator|.
name|MonotonicClock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|tezplugins
operator|.
name|metrics
operator|.
name|LlapTaskSchedulerMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|tezplugins
operator|.
name|scheduler
operator|.
name|LoggingFutureCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|registry
operator|.
name|ServiceInstanceStateChangeListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|registry
operator|.
name|impl
operator|.
name|TezAmRegistryImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Container
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|NodeId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|NodeReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|NodeState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Priority
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|Clock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|common
operator|.
name|util
operator|.
name|Ref
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|common
operator|.
name|TezUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|common
operator|.
name|security
operator|.
name|JobTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|common
operator|.
name|security
operator|.
name|JobTokenSecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|dag
operator|.
name|api
operator|.
name|TezUncheckedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|dag
operator|.
name|app
operator|.
name|dag
operator|.
name|DAG
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|dag
operator|.
name|app
operator|.
name|dag
operator|.
name|TaskAttempt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|dag
operator|.
name|app
operator|.
name|dag
operator|.
name|Vertex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|dag
operator|.
name|app
operator|.
name|dag
operator|.
name|impl
operator|.
name|Edge
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|dag
operator|.
name|records
operator|.
name|TezDAGID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|dag
operator|.
name|records
operator|.
name|TezTaskAttemptID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|dag
operator|.
name|records
operator|.
name|TezVertexID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|serviceplugins
operator|.
name|api
operator|.
name|DagInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|serviceplugins
operator|.
name|api
operator|.
name|ServicePluginErrorDefaults
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|serviceplugins
operator|.
name|api
operator|.
name|TaskAttemptEndReason
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|serviceplugins
operator|.
name|api
operator|.
name|TaskScheduler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|serviceplugins
operator|.
name|api
operator|.
name|TaskSchedulerContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
operator|.
name|ByteArrayDataOutput
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
operator|.
name|ByteStreams
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ListenableFuture
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ListeningExecutorService
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|MoreExecutors
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_class
specifier|public
class|class
name|LlapTaskSchedulerService
extends|extends
name|TaskScheduler
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|LlapTaskSchedulerService
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Logger
name|WM_LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
literal|"GuaranteedTasks"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|TaskStartComparator
name|TASK_INFO_COMPARATOR
init|=
operator|new
name|TaskStartComparator
argument_list|()
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|Comparator
argument_list|<
name|Priority
argument_list|>
name|PRIORITY_COMPARATOR
init|=
operator|new
name|Comparator
argument_list|<
name|Priority
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Priority
name|o1
parameter_list|,
name|Priority
name|o2
parameter_list|)
block|{
return|return
name|o1
operator|.
name|getPriority
argument_list|()
operator|-
name|o2
operator|.
name|getPriority
argument_list|()
return|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|final
name|UpdateOperationCallback
name|UPDATE_CALLBACK
init|=
operator|new
name|UpdateOperationCallback
argument_list|()
decl_stmt|;
specifier|private
specifier|final
class|class
name|UpdateOperationCallback
implements|implements
name|OperationCallback
argument_list|<
name|Boolean
argument_list|,
name|TaskInfo
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|void
name|setDone
parameter_list|(
name|TaskInfo
name|ctx
parameter_list|,
name|Boolean
name|result
parameter_list|)
block|{
name|handleUpdateResult
argument_list|(
name|ctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setError
parameter_list|(
name|TaskInfo
name|ctx
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
comment|// The exception has been logged by the lower layer.
name|handleUpdateResult
argument_list|(
name|ctx
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: this is an ugly hack; see the same in LlapTaskCommunicator for discussion.
comment|//       This only lives for the duration of the service init.
specifier|static
name|LlapTaskSchedulerService
name|instance
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
comment|// interface into the registry service
specifier|private
name|LlapServiceInstanceSet
name|activeInstances
decl_stmt|;
comment|// Tracks all instances, including ones which have been disabled in the past.
comment|// LinkedHashMap to provide the same iteration order when selecting a random host.
annotation|@
name|VisibleForTesting
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|NodeInfo
argument_list|>
name|instanceToNodeMap
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// TODO Ideally, remove elements from this once it's known that no tasks are linked to the instance (all deallocated)
comment|// Tracks tasks which could not be allocated immediately.
comment|// Tasks are tracked in the order requests come in, at different priority levels.
comment|// TODO HIVE-13538 For tasks at the same priority level, it may be worth attempting to schedule tasks with
comment|// locality information before those without locality information
specifier|private
specifier|final
name|TreeMap
argument_list|<
name|Priority
argument_list|,
name|List
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|pendingTasks
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|PRIORITY_COMPARATOR
argument_list|)
decl_stmt|;
comment|// Tracks running and queued (allocated) tasks. Cleared after a task completes.
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|Object
argument_list|,
name|TaskInfo
argument_list|>
name|knownTasks
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|TezTaskAttemptID
argument_list|,
name|TaskInfo
argument_list|>
name|tasksById
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Tracks tasks which are running. Useful for selecting a task to preempt based on when it started.
specifier|private
specifier|final
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|guaranteedTasks
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|,
name|speculativeTasks
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|LlapPluginServerImpl
name|pluginEndpoint
decl_stmt|;
comment|// Queue for disabled nodes. Nodes make it out of this queue when their expiration timeout is hit.
annotation|@
name|VisibleForTesting
specifier|final
name|DelayQueue
argument_list|<
name|NodeInfo
argument_list|>
name|disabledNodesQueue
init|=
operator|new
name|DelayQueue
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
name|DelayQueue
argument_list|<
name|TaskInfo
argument_list|>
name|delayedTaskQueue
init|=
operator|new
name|DelayQueue
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|dagRunning
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|ContainerFactory
name|containerFactory
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
name|Clock
name|clock
decl_stmt|;
specifier|private
specifier|final
name|ListeningExecutorService
name|nodeEnabledExecutor
decl_stmt|;
specifier|private
specifier|final
name|NodeEnablerCallable
name|nodeEnablerCallable
init|=
operator|new
name|NodeEnablerCallable
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ListeningExecutorService
name|delayedTaskSchedulerExecutor
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|final
name|DelayedTaskSchedulerCallable
name|delayedTaskSchedulerCallable
decl_stmt|;
specifier|private
specifier|final
name|ReentrantReadWriteLock
name|lock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ReentrantReadWriteLock
operator|.
name|ReadLock
name|readLock
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ReentrantReadWriteLock
operator|.
name|WriteLock
name|writeLock
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Lock
name|scheduleLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Condition
name|scheduleCondition
init|=
name|scheduleLock
operator|.
name|newCondition
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|AtomicBoolean
name|pendingScheduleInvocations
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|ListeningExecutorService
name|schedulerExecutor
decl_stmt|;
specifier|private
specifier|final
name|SchedulerCallable
name|schedulerCallable
init|=
operator|new
name|SchedulerCallable
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|AtomicBoolean
name|isStopped
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|// Tracks total pending preemptions.
specifier|private
specifier|final
name|AtomicInteger
name|pendingPreemptions
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// Tracks pending preemptions per host, using the hostname || Always to be accessed inside a lock
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|MutableInt
argument_list|>
name|pendingPreemptionsPerHost
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|NodeBlacklistConf
name|nodeBlacklistConf
decl_stmt|;
specifier|private
specifier|final
name|LocalityDelayConf
name|localityDelayConf
decl_stmt|;
specifier|private
specifier|final
name|int
name|numSchedulableTasksPerNode
decl_stmt|;
comment|// when there are no live nodes in the cluster and this timeout elapses the query is failed
specifier|private
specifier|final
name|long
name|timeout
decl_stmt|;
specifier|private
specifier|final
name|Lock
name|timeoutLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ScheduledExecutorService
name|timeoutExecutor
decl_stmt|;
specifier|private
specifier|final
name|ScheduledExecutorService
name|scheduledLoggingExecutor
decl_stmt|;
specifier|private
specifier|final
name|SchedulerTimeoutMonitor
name|timeoutMonitor
decl_stmt|;
specifier|private
name|ScheduledFuture
argument_list|<
name|?
argument_list|>
name|timeoutFuture
decl_stmt|;
specifier|private
specifier|final
name|AtomicReference
argument_list|<
name|ScheduledFuture
argument_list|<
name|?
argument_list|>
argument_list|>
name|timeoutFutureRef
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|(
literal|null
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|AtomicInteger
name|assignedTaskCounter
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|LlapRegistryService
name|registry
init|=
operator|new
name|LlapRegistryService
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|TezAmRegistryImpl
name|amRegistry
decl_stmt|;
specifier|private
specifier|volatile
name|ListenableFuture
argument_list|<
name|Void
argument_list|>
name|nodeEnablerFuture
decl_stmt|;
specifier|private
specifier|volatile
name|ListenableFuture
argument_list|<
name|Void
argument_list|>
name|delayedTaskSchedulerFuture
decl_stmt|;
specifier|private
specifier|volatile
name|ListenableFuture
argument_list|<
name|Void
argument_list|>
name|schedulerFuture
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|private
specifier|final
name|AtomicInteger
name|dagCounter
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// Statistics to track allocations
comment|// All of stats variables are visible for testing.
annotation|@
name|VisibleForTesting
name|StatsPerDag
name|dagStats
init|=
operator|new
name|StatsPerDag
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|LlapTaskSchedulerMetrics
name|metrics
decl_stmt|;
specifier|private
specifier|final
name|JvmPauseMonitor
name|pauseMonitor
decl_stmt|;
specifier|private
specifier|final
name|Random
name|random
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
specifier|private
name|int
name|totalGuaranteed
init|=
literal|0
decl_stmt|,
name|unusedGuaranteed
init|=
literal|0
decl_stmt|;
specifier|private
name|LlapTaskCommunicator
name|communicator
decl_stmt|;
specifier|private
specifier|final
name|int
name|amPort
decl_stmt|;
specifier|private
specifier|final
name|String
name|serializedToken
decl_stmt|,
name|jobIdForToken
decl_stmt|;
comment|// We expect the DAGs to not be super large, so store full dependency set for each vertex to
comment|// avoid traversing the tree later. To save memory, this could be an array (of byte arrays?).
specifier|private
specifier|final
name|Object
name|outputsLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
name|TezDAGID
name|depsDagId
init|=
literal|null
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|transitiveOutputs
decl_stmt|;
specifier|public
name|LlapTaskSchedulerService
parameter_list|(
name|TaskSchedulerContext
name|taskSchedulerContext
parameter_list|)
block|{
name|this
argument_list|(
name|taskSchedulerContext
argument_list|,
operator|new
name|MonotonicClock
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// The fields that HS2 uses to give AM information about plugin endpoint.
comment|// Some of these will be removed when AM registry is implemented, as AM will generate and publish them.
comment|/** Whether to enable the endpoint. */
specifier|public
specifier|static
specifier|final
name|String
name|LLAP_PLUGIN_ENDPOINT_ENABLED
init|=
literal|"llap.plugin.endpoint.enabled"
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|public
name|LlapTaskSchedulerService
parameter_list|(
name|TaskSchedulerContext
name|taskSchedulerContext
parameter_list|,
name|Clock
name|clock
parameter_list|,
name|boolean
name|initMetrics
parameter_list|)
block|{
name|super
argument_list|(
name|taskSchedulerContext
argument_list|)
expr_stmt|;
name|this
operator|.
name|clock
operator|=
name|clock
expr_stmt|;
name|this
operator|.
name|amPort
operator|=
name|taskSchedulerContext
operator|.
name|getAppClientPort
argument_list|()
expr_stmt|;
name|this
operator|.
name|delayedTaskSchedulerCallable
operator|=
name|createDelayedTaskSchedulerCallable
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|conf
operator|=
name|TezUtils
operator|.
name|createConfFromUserPayload
argument_list|(
name|taskSchedulerContext
operator|.
name|getInitialUserPayload
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|TezUncheckedException
argument_list|(
literal|"Failed to parse user payload for "
operator|+
name|LlapTaskSchedulerService
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|LLAP_PLUGIN_ENDPOINT_ENABLED
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|JobTokenSecretManager
name|sm
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
comment|// Set up the security for plugin endpoint.
comment|// We will create the token and publish it in the AM registry.
comment|// Note: this application ID is bogus and is only needed for JobTokenSecretManager.
name|ApplicationId
name|id
init|=
name|ApplicationId
operator|.
name|newInstance
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|,
call|(
name|int
call|)
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|%
literal|100000
argument_list|)
argument_list|)
decl_stmt|;
name|Token
argument_list|<
name|JobTokenIdentifier
argument_list|>
name|token
init|=
name|createAmsToken
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|serializedToken
operator|=
name|serializeToken
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|jobIdForToken
operator|=
name|token
operator|.
name|getService
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
name|sm
operator|=
operator|new
name|JobTokenSecretManager
argument_list|()
expr_stmt|;
name|sm
operator|.
name|addTokenForJob
argument_list|(
name|jobIdForToken
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|serializedToken
operator|=
name|jobIdForToken
operator|=
literal|null
expr_stmt|;
block|}
name|pluginEndpoint
operator|=
operator|new
name|LlapPluginServerImpl
argument_list|(
name|sm
argument_list|,
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_PLUGIN_RPC_NUM_HANDLERS
argument_list|)
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|serializedToken
operator|=
name|jobIdForToken
operator|=
literal|null
expr_stmt|;
name|pluginEndpoint
operator|=
literal|null
expr_stmt|;
block|}
comment|// This is called once per AM, so we don't get the starting duck count here.
name|this
operator|.
name|containerFactory
operator|=
operator|new
name|ContainerFactory
argument_list|(
name|taskSchedulerContext
operator|.
name|getApplicationAttemptId
argument_list|()
argument_list|,
name|taskSchedulerContext
operator|.
name|getCustomClusterIdentifier
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO HIVE-13483 Get all of these properties from the registry. This will need to take care of different instances
comment|// publishing potentially different values when we support changing configurations dynamically.
comment|// For now, this can simply be fetched from a single registry instance.
name|this
operator|.
name|nodeBlacklistConf
operator|=
operator|new
name|NodeBlacklistConf
argument_list|(
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_TASK_SCHEDULER_NODE_REENABLE_MIN_TIMEOUT_MS
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
argument_list|,
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_TASK_SCHEDULER_NODE_REENABLE_MAX_TIMEOUT_MS
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
argument_list|,
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_TASK_SCHEDULER_NODE_DISABLE_BACK_OFF_FACTOR
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|numSchedulableTasksPerNode
operator|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_TASK_SCHEDULER_NUM_SCHEDULABLE_TASKS_PER_NODE
argument_list|)
expr_stmt|;
name|long
name|localityDelayMs
init|=
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_TASK_SCHEDULER_LOCALITY_DELAY
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
name|this
operator|.
name|localityDelayConf
operator|=
operator|new
name|LocalityDelayConf
argument_list|(
name|localityDelayMs
argument_list|)
expr_stmt|;
name|this
operator|.
name|timeoutMonitor
operator|=
operator|new
name|SchedulerTimeoutMonitor
argument_list|()
expr_stmt|;
name|this
operator|.
name|timeout
operator|=
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_DAEMON_TASK_SCHEDULER_TIMEOUT_SECONDS
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|this
operator|.
name|timeoutExecutor
operator|=
name|Executors
operator|.
name|newSingleThreadScheduledExecutor
argument_list|(
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
literal|"LlapTaskSchedulerTimeoutMonitor"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|timeoutFuture
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|scheduledLoggingExecutor
operator|=
name|Executors
operator|.
name|newSingleThreadScheduledExecutor
argument_list|(
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
literal|"LlapTaskSchedulerTimedLogThread"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|instanceId
init|=
name|HiveConf
operator|.
name|getTrimmedVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_DAEMON_SERVICE_HOSTS
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|instanceId
argument_list|,
name|ConfVars
operator|.
name|LLAP_DAEMON_SERVICE_HOSTS
operator|.
name|varname
operator|+
literal|" must be defined"
argument_list|)
expr_stmt|;
name|ExecutorService
name|executorServiceRaw
init|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|(
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
literal|"LlapSchedulerNodeEnabler"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|nodeEnabledExecutor
operator|=
name|MoreExecutors
operator|.
name|listeningDecorator
argument_list|(
name|executorServiceRaw
argument_list|)
expr_stmt|;
name|ExecutorService
name|delayedTaskSchedulerExecutorRaw
init|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
literal|1
argument_list|,
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
literal|"LlapSchedulerDelayedTaskHandler"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|delayedTaskSchedulerExecutor
operator|=
name|MoreExecutors
operator|.
name|listeningDecorator
argument_list|(
name|delayedTaskSchedulerExecutorRaw
argument_list|)
expr_stmt|;
name|ExecutorService
name|schedulerExecutorServiceRaw
init|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|(
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
literal|"LlapScheduler"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|schedulerExecutor
operator|=
name|MoreExecutors
operator|.
name|listeningDecorator
argument_list|(
name|schedulerExecutorServiceRaw
argument_list|)
expr_stmt|;
if|if
condition|(
name|initMetrics
operator|&&
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
name|ConfVars
operator|.
name|HIVE_IN_TEST
operator|.
name|varname
argument_list|,
literal|false
argument_list|)
condition|)
block|{
comment|// Initialize the metrics system
name|LlapMetricsSystem
operator|.
name|initialize
argument_list|(
literal|"LlapTaskScheduler"
argument_list|)
expr_stmt|;
name|this
operator|.
name|pauseMonitor
operator|=
operator|new
name|JvmPauseMonitor
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|pauseMonitor
operator|.
name|start
argument_list|()
expr_stmt|;
name|String
name|displayName
init|=
literal|"LlapTaskSchedulerMetrics-"
operator|+
name|MetricsUtils
operator|.
name|getHostName
argument_list|()
decl_stmt|;
name|String
name|sessionId
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"llap.daemon.metrics.sessionid"
argument_list|)
decl_stmt|;
comment|// TODO: Not sure about the use of this. Should we instead use workerIdentity as sessionId?
name|this
operator|.
name|metrics
operator|=
name|LlapTaskSchedulerMetrics
operator|.
name|create
argument_list|(
name|displayName
argument_list|,
name|sessionId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|metrics
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|pauseMonitor
operator|=
literal|null
expr_stmt|;
block|}
name|String
name|hostsString
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_DAEMON_SERVICE_HOSTS
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Running with configuration: hosts={}, numSchedulableTasksPerNode={}, "
operator|+
literal|"nodeBlacklistConf={}, localityConf={}"
argument_list|,
name|hostsString
argument_list|,
name|numSchedulableTasksPerNode
argument_list|,
name|nodeBlacklistConf
argument_list|,
name|localityDelayConf
argument_list|)
expr_stmt|;
name|this
operator|.
name|amRegistry
operator|=
name|TezAmRegistryImpl
operator|.
name|create
argument_list|(
name|conf
argument_list|,
literal|true
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|LlapTaskCommunicator
operator|.
name|pluginInitLock
init|)
block|{
name|LlapTaskCommunicator
name|peer
init|=
name|LlapTaskCommunicator
operator|.
name|instance
decl_stmt|;
if|if
condition|(
name|peer
operator|!=
literal|null
condition|)
block|{
comment|// We are the last to initialize.
name|this
operator|.
name|setTaskCommunicator
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|.
name|setScheduler
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|LlapTaskCommunicator
operator|.
name|instance
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|instance
operator|=
name|this
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|getDependencyInfo
parameter_list|(
name|TezDAGID
name|depsDagId
parameter_list|)
block|{
comment|// This logic assumes one dag at a time; if it was not the case it'd keep rewriting it.
synchronized|synchronized
init|(
name|outputsLock
init|)
block|{
if|if
condition|(
name|depsDagId
operator|==
name|this
operator|.
name|depsDagId
condition|)
return|return
name|transitiveOutputs
return|;
name|this
operator|.
name|depsDagId
operator|=
name|depsDagId
expr_stmt|;
if|if
condition|(
operator|!
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_TASK_SCHEDULER_PREEMPT_INDEPENDENT
argument_list|)
condition|)
block|{
name|this
operator|.
name|transitiveOutputs
operator|=
name|getTransitiveVertexOutputs
argument_list|(
name|getContext
argument_list|()
operator|.
name|getCurrentDagInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|transitiveOutputs
return|;
block|}
block|}
specifier|private
specifier|static
name|Map
argument_list|<
name|Integer
argument_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|getTransitiveVertexOutputs
parameter_list|(
name|DagInfo
name|info
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|info
operator|instanceof
name|DAG
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"DAG info is not a DAG - cannot derive dependencies"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|DAG
name|dag
init|=
operator|(
name|DAG
operator|)
name|info
decl_stmt|;
name|int
name|vc
init|=
name|dag
operator|.
name|getVertices
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// All the vertices belong to the same DAG, so we just use numbers.
name|Map
argument_list|<
name|Integer
argument_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|result
init|=
name|Maps
operator|.
name|newHashMapWithExpectedSize
argument_list|(
name|vc
argument_list|)
decl_stmt|;
name|LinkedList
argument_list|<
name|TezVertexID
argument_list|>
name|queue
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// We assume a DAG is a DAG, and that it's connected. Add direct dependencies.
for|for
control|(
name|Vertex
name|v
range|:
name|dag
operator|.
name|getVertices
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|Map
argument_list|<
name|Vertex
argument_list|,
name|Edge
argument_list|>
name|out
init|=
name|v
operator|.
name|getOutputVertices
argument_list|()
decl_stmt|;
if|if
condition|(
name|out
operator|==
literal|null
condition|)
block|{
name|result
operator|.
name|put
argument_list|(
name|v
operator|.
name|getVertexId
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|Sets
operator|.
name|newHashSet
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newHashSetWithExpectedSize
argument_list|(
name|vc
argument_list|)
decl_stmt|;
for|for
control|(
name|Vertex
name|outV
range|:
name|out
operator|.
name|keySet
argument_list|()
control|)
block|{
name|set
operator|.
name|add
argument_list|(
name|outV
operator|.
name|getVertexId
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|put
argument_list|(
name|v
operator|.
name|getVertexId
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|.
name|getOutputVerticesCount
argument_list|()
operator|==
literal|0
condition|)
block|{
name|queue
operator|.
name|add
argument_list|(
name|v
operator|.
name|getVertexId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|Set
argument_list|<
name|Integer
argument_list|>
name|processed
init|=
name|Sets
operator|.
name|newHashSetWithExpectedSize
argument_list|(
name|vc
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|queue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|TezVertexID
name|id
init|=
name|queue
operator|.
name|poll
argument_list|()
decl_stmt|;
if|if
condition|(
name|processed
operator|.
name|contains
argument_list|(
name|id
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
continue|continue;
comment|// Already processed. See backtracking.
name|Vertex
name|v
init|=
name|dag
operator|.
name|getVertex
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Vertex
argument_list|,
name|Edge
argument_list|>
name|out
init|=
name|v
operator|.
name|getOutputVertices
argument_list|()
decl_stmt|;
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
comment|// Check that all the outputs have been processed; if not, insert them into queue
comment|// before the current vertex and try again. It's possible e.g. in a structure like this:
comment|//   _1
comment|//  / 2
comment|// 3  4 where 1 may be added to the queue before 2
name|boolean
name|doBacktrack
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Vertex
name|outV
range|:
name|out
operator|.
name|keySet
argument_list|()
control|)
block|{
name|TezVertexID
name|outId
init|=
name|outV
operator|.
name|getVertexId
argument_list|()
decl_stmt|;
name|int
name|outNum
init|=
name|outId
operator|.
name|getId
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|processed
operator|.
name|contains
argument_list|(
name|outNum
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|doBacktrack
condition|)
block|{
name|queue
operator|.
name|addFirst
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|doBacktrack
operator|=
literal|true
expr_stmt|;
block|}
name|queue
operator|.
name|addFirst
argument_list|(
name|outId
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|doBacktrack
condition|)
continue|continue;
block|}
name|int
name|num
init|=
name|id
operator|.
name|getId
argument_list|()
decl_stmt|;
name|processed
operator|.
name|add
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|deps
init|=
name|result
operator|.
name|get
argument_list|(
name|num
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Vertex
argument_list|,
name|Edge
argument_list|>
name|in
init|=
name|v
operator|.
name|getInputVertices
argument_list|()
decl_stmt|;
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Vertex
name|inV
range|:
name|in
operator|.
name|keySet
argument_list|()
control|)
block|{
name|queue
operator|.
name|add
argument_list|(
name|inV
operator|.
name|getVertexId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Our outputs are the transitive outputs of our inputs.
name|result
operator|.
name|get
argument_list|(
name|inV
operator|.
name|getVertexId
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
operator|.
name|addAll
argument_list|(
name|deps
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
specifier|private
specifier|static
name|Token
argument_list|<
name|JobTokenIdentifier
argument_list|>
name|createAmsToken
parameter_list|(
name|ApplicationId
name|id
parameter_list|)
block|{
if|if
condition|(
operator|!
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
return|return
literal|null
return|;
name|JobTokenIdentifier
name|identifier
init|=
operator|new
name|JobTokenIdentifier
argument_list|(
operator|new
name|Text
argument_list|(
name|id
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|JobTokenSecretManager
name|jobTokenManager
init|=
operator|new
name|JobTokenSecretManager
argument_list|()
decl_stmt|;
name|Token
argument_list|<
name|JobTokenIdentifier
argument_list|>
name|sessionToken
init|=
operator|new
name|Token
argument_list|<>
argument_list|(
name|identifier
argument_list|,
name|jobTokenManager
argument_list|)
decl_stmt|;
name|sessionToken
operator|.
name|setService
argument_list|(
name|identifier
operator|.
name|getJobId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|sessionToken
return|;
block|}
specifier|private
specifier|static
name|String
name|serializeToken
parameter_list|(
name|Token
argument_list|<
name|JobTokenIdentifier
argument_list|>
name|token
parameter_list|)
block|{
name|byte
index|[]
name|bytes
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ByteArrayDataOutput
name|out
init|=
name|ByteStreams
operator|.
name|newDataOutput
argument_list|()
decl_stmt|;
name|token
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|out
operator|.
name|toByteArray
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// This shouldn't really happen on a byte array.
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|Base64
operator|.
name|encodeBase64String
argument_list|(
name|bytes
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
name|void
name|updateGuaranteedCount
parameter_list|(
name|int
name|newTotalGuaranteed
parameter_list|)
block|{
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|toUpdate
init|=
literal|null
decl_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// TODO: when this code is a little less hot, change most logs to debug.
comment|// We will determine what to do under lock and then do stuff outside of the lock.
comment|// The approach is state-based. We consider the task to have a duck when we have decided to
comment|// give it one; the sends below merely fix the discrepancy with the actual state. We may add the
comment|// ability to wait for LLAPs to positively ack the revokes in future.
comment|// The "procedural" approach requires that we track the ducks traveling on network,
comment|// concurrent terminations, etc. So, while more precise it's much more complex.
name|int
name|delta
init|=
name|newTotalGuaranteed
operator|-
name|totalGuaranteed
decl_stmt|;
name|WM_LOG
operator|.
name|info
argument_list|(
literal|"Received guaranteed tasks "
operator|+
name|newTotalGuaranteed
operator|+
literal|"; the delta to adjust by is "
operator|+
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
return|return;
name|totalGuaranteed
operator|=
name|newTotalGuaranteed
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setWmTotalGuaranteed
argument_list|(
name|totalGuaranteed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|unusedGuaranteed
operator|==
literal|0
condition|)
block|{
comment|// There may be speculative tasks waiting.
name|toUpdate
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|int
name|totalUpdated
init|=
name|distributeGuaranteed
argument_list|(
name|delta
argument_list|,
literal|null
argument_list|,
name|toUpdate
argument_list|)
decl_stmt|;
name|delta
operator|-=
name|totalUpdated
expr_stmt|;
name|WM_LOG
operator|.
name|info
argument_list|(
literal|"Distributed "
operator|+
name|totalUpdated
argument_list|)
expr_stmt|;
block|}
name|int
name|result
init|=
operator|(
name|unusedGuaranteed
operator|+=
name|delta
operator|)
decl_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setWmUnusedGuaranteed
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|WM_LOG
operator|.
name|info
argument_list|(
literal|"Setting unused to "
operator|+
name|result
operator|+
literal|" based on remaining delta "
operator|+
name|delta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
if|if
condition|(
name|delta
operator|<=
name|unusedGuaranteed
condition|)
block|{
comment|// Somebody took away our unwanted ducks.
name|int
name|result
init|=
operator|(
name|unusedGuaranteed
operator|-=
name|delta
operator|)
decl_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setWmUnusedGuaranteed
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|WM_LOG
operator|.
name|info
argument_list|(
literal|"Setting unused to "
operator|+
name|result
operator|+
literal|" based on full delta "
operator|+
name|delta
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|delta
operator|-=
name|unusedGuaranteed
expr_stmt|;
name|unusedGuaranteed
operator|=
literal|0
expr_stmt|;
name|toUpdate
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|int
name|totalUpdated
init|=
name|revokeGuaranteed
argument_list|(
name|delta
argument_list|,
literal|null
argument_list|,
name|toUpdate
argument_list|)
decl_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setWmUnusedGuaranteed
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|WM_LOG
operator|.
name|info
argument_list|(
literal|"Setting unused to 0; revoked "
operator|+
name|totalUpdated
operator|+
literal|" / "
operator|+
name|delta
argument_list|)
expr_stmt|;
comment|// We must be able to take away the requisite number; if we can't, where'd the ducks go?
if|if
condition|(
name|delta
operator|!=
name|totalUpdated
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Failed to revoke "
operator|+
name|delta
operator|+
literal|" guaranteed tasks locally"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|toUpdate
operator|==
literal|null
condition|)
return|return;
name|WM_LOG
operator|.
name|info
argument_list|(
literal|"Sending updates to "
operator|+
name|toUpdate
operator|.
name|size
argument_list|()
operator|+
literal|" tasks"
argument_list|)
expr_stmt|;
for|for
control|(
name|TaskInfo
name|ti
range|:
name|toUpdate
control|)
block|{
name|checkAndSendGuaranteedStateUpdate
argument_list|(
name|ti
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|protected
name|void
name|checkAndSendGuaranteedStateUpdate
parameter_list|(
name|TaskInfo
name|ti
parameter_list|)
block|{
name|boolean
name|newState
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|ti
init|)
block|{
assert|assert
name|ti
operator|.
name|isPendingUpdate
assert|;
if|if
condition|(
name|ti
operator|.
name|lastSetGuaranteed
operator|!=
literal|null
operator|&&
name|ti
operator|.
name|lastSetGuaranteed
operator|==
name|ti
operator|.
name|isGuaranteed
condition|)
block|{
name|ti
operator|.
name|requestedValue
operator|=
name|ti
operator|.
name|isGuaranteed
expr_stmt|;
name|setUpdateDoneUnderTiLock
argument_list|(
name|ti
argument_list|)
expr_stmt|;
name|WM_LOG
operator|.
name|info
argument_list|(
literal|"Not sending update to "
operator|+
name|ti
operator|.
name|attemptId
argument_list|)
expr_stmt|;
return|return;
comment|// Nothing to do - e.g. two messages have canceled each other before we could react.
block|}
name|newState
operator|=
name|ti
operator|.
name|isGuaranteed
expr_stmt|;
block|}
comment|// From this point on, the update is in motion - if someone changes the state again, that
comment|// would only apply after the callback for the current message.
name|sendUpdateMessageAsync
argument_list|(
name|ti
argument_list|,
name|newState
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|setUpdateStartedUnderTiLock
parameter_list|(
name|TaskInfo
name|ti
parameter_list|)
block|{
name|ti
operator|.
name|isPendingUpdate
operator|=
literal|true
expr_stmt|;
name|ti
operator|.
name|requestedValue
operator|=
name|ti
operator|.
name|isGuaranteed
expr_stmt|;
comment|// It's ok to update metrics for two tasks in parallel, but not for the same one.
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setWmPendingStarted
argument_list|(
name|ti
operator|.
name|requestedValue
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|setUpdateDoneUnderTiLock
parameter_list|(
name|TaskInfo
name|ti
parameter_list|)
block|{
name|ti
operator|.
name|isPendingUpdate
operator|=
literal|false
expr_stmt|;
comment|// It's ok to update metrics for two tasks in parallel, but not for the same one.
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setWmPendingDone
argument_list|(
name|ti
operator|.
name|requestedValue
argument_list|)
expr_stmt|;
block|}
name|ti
operator|.
name|lastSetGuaranteed
operator|=
name|ti
operator|.
name|requestedValue
expr_stmt|;
name|ti
operator|.
name|requestedValue
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
specifier|protected
name|void
name|handleUpdateResult
parameter_list|(
name|TaskInfo
name|ti
parameter_list|,
name|boolean
name|isOk
parameter_list|)
block|{
comment|// The update options for outside the lock - see below the synchronized block.
name|Boolean
name|newStateSameTask
init|=
literal|null
decl_stmt|,
name|newStateAnyTask
init|=
literal|null
decl_stmt|;
name|WM_LOG
operator|.
name|info
argument_list|(
literal|"Received response for "
operator|+
name|ti
operator|.
name|attemptId
operator|+
literal|", "
operator|+
name|isOk
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|ti
init|)
block|{
assert|assert
name|ti
operator|.
name|isPendingUpdate
assert|;
if|if
condition|(
name|ti
operator|.
name|isGuaranteed
operator|==
literal|null
condition|)
block|{
comment|// The task has been terminated and the duck accounted for based on local state.
comment|// Whatever we were doing is irrelevant. The metrics have also been updated.
name|ti
operator|.
name|isPendingUpdate
operator|=
literal|false
expr_stmt|;
name|ti
operator|.
name|requestedValue
operator|=
literal|null
expr_stmt|;
return|return;
block|}
name|boolean
name|requestedValue
init|=
name|ti
operator|.
name|requestedValue
decl_stmt|;
if|if
condition|(
name|isOk
condition|)
block|{
comment|// We have propagated the value to the task.
name|setUpdateDoneUnderTiLock
argument_list|(
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|requestedValue
operator|==
name|ti
operator|.
name|isGuaranteed
condition|)
return|return;
comment|// The state has changed during the update. Let's undo what we just did.
name|newStateSameTask
operator|=
name|ti
operator|.
name|isGuaranteed
expr_stmt|;
name|setUpdateStartedUnderTiLock
argument_list|(
name|ti
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setWmPendingFailed
argument_list|(
name|requestedValue
argument_list|)
expr_stmt|;
block|}
comment|// An error, or couldn't find the task - lastSetGuaranteed does not change. The logic here
comment|// does not account for one special case - we have updated the task, but the response was
comment|// lost and we have received a network error. The state could be inconsistent, making
comment|// a deadlock possible in extreme cases if not handled. This will be detected by heartbeat.
if|if
condition|(
name|requestedValue
operator|!=
name|ti
operator|.
name|isGuaranteed
condition|)
block|{
comment|// We failed to do something that was rendered irrelevant while we were failing.
name|ti
operator|.
name|isPendingUpdate
operator|=
literal|false
expr_stmt|;
name|ti
operator|.
name|requestedValue
operator|=
literal|null
expr_stmt|;
return|return;
block|}
comment|// We failed to update this task. Instead of retrying for this task, find another.
comment|// To change isGuaranteed and modify maps, we'd need the epic lock. So, we will not
comment|// update the pending state for now as we release this lock to take both.
name|newStateAnyTask
operator|=
name|requestedValue
expr_stmt|;
block|}
block|}
comment|// End of synchronized (ti)
if|if
condition|(
name|newStateSameTask
operator|!=
literal|null
condition|)
block|{
name|WM_LOG
operator|.
name|info
argument_list|(
literal|"Sending update to the same task in response handling "
operator|+
name|ti
operator|.
name|attemptId
operator|+
literal|", "
operator|+
name|newStateSameTask
argument_list|)
expr_stmt|;
comment|// We need to send the state update again (the state has changed since the last one).
name|sendUpdateMessageAsync
argument_list|(
name|ti
argument_list|,
name|newStateSameTask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newStateAnyTask
operator|==
literal|null
condition|)
return|return;
comment|// The update is failed and could be retried.
comment|// Instead of retrying with this task, we will try to pick a different suitable task.
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|toUpdate
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|ti
init|)
block|{
comment|// We have already updated the metrics for the failure; change the state.
name|ti
operator|.
name|isPendingUpdate
operator|=
literal|false
expr_stmt|;
name|ti
operator|.
name|requestedValue
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|newStateAnyTask
operator|!=
name|ti
operator|.
name|isGuaranteed
condition|)
block|{
comment|// The state has changed between this and previous check within this method.
comment|// The failed update was rendered irrelevant, so we just exit.
return|return;
block|}
name|WM_LOG
operator|.
name|info
argument_list|(
literal|"Sending update to a different task in response handling "
operator|+
name|ti
operator|.
name|attemptId
operator|+
literal|", "
operator|+
name|newStateAnyTask
argument_list|)
expr_stmt|;
comment|// First, "give up" on this task and put it back in the original list.
name|boolean
name|isRemoved
init|=
name|removeFromRunningTaskMap
argument_list|(
name|newStateAnyTask
condition|?
name|guaranteedTasks
else|:
name|speculativeTasks
argument_list|,
name|ti
operator|.
name|task
argument_list|,
name|ti
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isRemoved
condition|)
block|{
name|String
name|error
init|=
literal|"Couldn't find the task in the correct map after an update "
operator|+
name|ti
operator|.
name|task
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
name|error
argument_list|)
throw|;
block|}
name|ti
operator|.
name|isGuaranteed
operator|=
operator|!
name|newStateAnyTask
expr_stmt|;
comment|// Put into the map that this task was in before we decided to update it.
name|addToRunningTasksMap
argument_list|(
name|newStateAnyTask
condition|?
name|speculativeTasks
else|:
name|guaranteedTasks
argument_list|,
name|ti
argument_list|)
expr_stmt|;
block|}
comment|// Now try to pick another task to update - or potentially the same task.
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|newStateAnyTask
condition|)
block|{
name|count
operator|=
name|distributeGuaranteed
argument_list|(
literal|1
argument_list|,
name|ti
argument_list|,
name|toUpdate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|count
operator|=
name|revokeGuaranteed
argument_list|(
literal|1
argument_list|,
name|ti
argument_list|,
name|toUpdate
argument_list|)
expr_stmt|;
block|}
assert|assert
name|count
operator|==
literal|1
operator|&&
name|toUpdate
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
comment|// Must at least be able to return ti back.
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|checkAndSendGuaranteedStateUpdate
argument_list|(
name|toUpdate
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|initialize
parameter_list|()
block|{
name|registry
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pluginEndpoint
operator|!=
literal|null
condition|)
block|{
name|pluginEndpoint
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|start
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|pluginEndpoint
operator|!=
literal|null
condition|)
block|{
name|pluginEndpoint
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|scheduledLoggingExecutor
operator|.
name|schedule
argument_list|(
operator|new
name|Callable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|dagRunning
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stats for current dag: {}"
argument_list|,
name|dagStats
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|,
literal|10000L
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|nodeEnablerFuture
operator|=
name|nodeEnabledExecutor
operator|.
name|submit
argument_list|(
name|nodeEnablerCallable
argument_list|)
expr_stmt|;
name|Futures
operator|.
name|addCallback
argument_list|(
name|nodeEnablerFuture
argument_list|,
operator|new
name|LoggingFutureCallback
argument_list|(
literal|"NodeEnablerThread"
argument_list|,
name|LOG
argument_list|)
argument_list|)
expr_stmt|;
name|delayedTaskSchedulerFuture
operator|=
name|delayedTaskSchedulerExecutor
operator|.
name|submit
argument_list|(
name|delayedTaskSchedulerCallable
argument_list|)
expr_stmt|;
name|Futures
operator|.
name|addCallback
argument_list|(
name|delayedTaskSchedulerFuture
argument_list|,
operator|new
name|LoggingFutureCallback
argument_list|(
literal|"DelayedTaskSchedulerThread"
argument_list|,
name|LOG
argument_list|)
argument_list|)
expr_stmt|;
name|schedulerFuture
operator|=
name|schedulerExecutor
operator|.
name|submit
argument_list|(
name|schedulerCallable
argument_list|)
expr_stmt|;
name|Futures
operator|.
name|addCallback
argument_list|(
name|schedulerFuture
argument_list|,
operator|new
name|LoggingFutureCallback
argument_list|(
literal|"SchedulerThread"
argument_list|,
name|LOG
argument_list|)
argument_list|)
expr_stmt|;
name|registry
operator|.
name|start
argument_list|()
expr_stmt|;
name|registry
operator|.
name|registerStateChangeListener
argument_list|(
operator|new
name|NodeStateChangeListener
argument_list|()
argument_list|)
expr_stmt|;
name|activeInstances
operator|=
name|registry
operator|.
name|getInstances
argument_list|()
expr_stmt|;
for|for
control|(
name|LlapServiceInstance
name|inst
range|:
name|activeInstances
operator|.
name|getAll
argument_list|()
control|)
block|{
name|addNode
argument_list|(
operator|new
name|NodeInfo
argument_list|(
name|inst
argument_list|,
name|nodeBlacklistConf
argument_list|,
name|clock
argument_list|,
name|numSchedulableTasksPerNode
argument_list|,
name|metrics
argument_list|)
argument_list|,
name|inst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|amRegistry
operator|!=
literal|null
condition|)
block|{
name|amRegistry
operator|.
name|start
argument_list|()
expr_stmt|;
name|int
name|pluginPort
init|=
name|pluginEndpoint
operator|!=
literal|null
condition|?
name|pluginEndpoint
operator|.
name|getActualPort
argument_list|()
else|:
operator|-
literal|1
decl_stmt|;
name|amRegistry
operator|.
name|register
argument_list|(
name|amPort
argument_list|,
name|pluginPort
argument_list|,
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVESESSIONID
argument_list|)
argument_list|,
name|serializedToken
argument_list|,
name|jobIdForToken
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|protected
name|void
name|setServiceInstanceSet
parameter_list|(
name|LlapServiceInstanceSet
name|serviceInstanceSet
parameter_list|)
block|{
name|this
operator|.
name|activeInstances
operator|=
name|serviceInstanceSet
expr_stmt|;
block|}
specifier|private
class|class
name|NodeStateChangeListener
implements|implements
name|ServiceInstanceStateChangeListener
argument_list|<
name|LlapServiceInstance
argument_list|>
block|{
specifier|private
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|NodeStateChangeListener
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|onCreate
parameter_list|(
name|LlapServiceInstance
name|serviceInstance
parameter_list|,
name|int
name|ephSeqVersion
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Added node with identity: {} as a result of registry callback"
argument_list|,
name|serviceInstance
operator|.
name|getWorkerIdentity
argument_list|()
argument_list|)
expr_stmt|;
name|addNode
argument_list|(
operator|new
name|NodeInfo
argument_list|(
name|serviceInstance
argument_list|,
name|nodeBlacklistConf
argument_list|,
name|clock
argument_list|,
name|numSchedulableTasksPerNode
argument_list|,
name|metrics
argument_list|)
argument_list|,
name|serviceInstance
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onUpdate
parameter_list|(
name|LlapServiceInstance
name|serviceInstance
parameter_list|,
name|int
name|ephSeqVersion
parameter_list|)
block|{
comment|// Registry uses ephemeral sequential znodes that are never updated as of now.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected update for instance={}. Ignoring"
argument_list|,
name|serviceInstance
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onRemove
parameter_list|(
name|LlapServiceInstance
name|serviceInstance
parameter_list|,
name|int
name|ephSeqVersion
parameter_list|)
block|{
name|NodeReport
name|nodeReport
init|=
name|constructNodeReport
argument_list|(
name|serviceInstance
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Sending out nodeReport for onRemove: {}"
argument_list|,
name|nodeReport
argument_list|)
expr_stmt|;
name|getContext
argument_list|()
operator|.
name|nodesUpdated
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|nodeReport
argument_list|)
argument_list|)
expr_stmt|;
name|instanceToNodeMap
operator|.
name|remove
argument_list|(
name|serviceInstance
operator|.
name|getWorkerIdentity
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Removed node with identity: {} due to RegistryNotification. currentActiveInstances={}"
argument_list|,
name|serviceInstance
operator|.
name|getWorkerIdentity
argument_list|()
argument_list|,
name|activeInstances
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setClusterNodeCount
argument_list|(
name|activeInstances
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// if there are no more nodes. Signal timeout monitor to start timer
if|if
condition|(
name|activeInstances
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No node found. Signalling scheduler timeout monitor thread to start timer."
argument_list|)
expr_stmt|;
name|startTimeoutMonitor
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|startTimeoutMonitor
parameter_list|()
block|{
name|timeoutLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// If timer is null, start a new one.
comment|// If timer has completed during previous invocation, start a new one.
comment|// If timer already started and is not completed, leaving it running without resetting it.
if|if
condition|(
operator|(
name|timeoutFuture
operator|==
literal|null
operator|||
operator|(
name|timeoutFuture
operator|!=
literal|null
operator|&&
name|timeoutFuture
operator|.
name|isDone
argument_list|()
operator|)
operator|)
operator|&&
name|activeInstances
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|timeoutFuture
operator|=
name|timeoutExecutor
operator|.
name|schedule
argument_list|(
name|timeoutMonitor
argument_list|,
name|timeout
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|timeoutFutureRef
operator|.
name|set
argument_list|(
name|timeoutFuture
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Scheduled timeout monitor task to run after {} ms"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Timeout monitor task not started. Timeout future state: {}, #instances: {}"
argument_list|,
name|timeoutFuture
operator|==
literal|null
condition|?
literal|"null"
else|:
name|timeoutFuture
operator|.
name|isDone
argument_list|()
argument_list|,
name|activeInstances
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|timeoutLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|stopTimeoutMonitor
parameter_list|()
block|{
name|timeoutLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|timeoutFuture
operator|!=
literal|null
operator|&&
name|activeInstances
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|&&
name|timeoutFuture
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
condition|)
block|{
name|timeoutFutureRef
operator|.
name|set
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopped timeout monitor task"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Timeout monitor task not stopped. Timeout future state: {}, #instances: {}"
argument_list|,
name|timeoutFuture
operator|==
literal|null
condition|?
literal|"null"
else|:
name|timeoutFuture
operator|.
name|isDone
argument_list|()
argument_list|,
name|activeInstances
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|timeoutFuture
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
name|timeoutLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|isStopped
operator|.
name|getAndSet
argument_list|(
literal|true
argument_list|)
condition|)
block|{
name|scheduledLoggingExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|nodeEnablerCallable
operator|.
name|shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
name|nodeEnablerFuture
operator|!=
literal|null
condition|)
block|{
name|nodeEnablerFuture
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|nodeEnabledExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|timeoutExecutor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
name|timeoutFuture
operator|!=
literal|null
condition|)
block|{
name|timeoutFuture
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|timeoutFuture
operator|=
literal|null
expr_stmt|;
block|}
name|timeoutExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|delayedTaskSchedulerCallable
operator|.
name|shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
name|delayedTaskSchedulerFuture
operator|!=
literal|null
condition|)
block|{
name|delayedTaskSchedulerFuture
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|delayedTaskSchedulerExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|schedulerCallable
operator|.
name|shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
name|schedulerFuture
operator|!=
literal|null
condition|)
block|{
name|schedulerFuture
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|schedulerExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
if|if
condition|(
name|registry
operator|!=
literal|null
condition|)
block|{
name|registry
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|amRegistry
operator|!=
literal|null
condition|)
block|{
name|amRegistry
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|pluginEndpoint
operator|!=
literal|null
condition|)
block|{
name|pluginEndpoint
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|pauseMonitor
operator|!=
literal|null
condition|)
block|{
name|pauseMonitor
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|LlapMetricsSystem
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Resource
name|getTotalResources
parameter_list|()
block|{
name|int
name|memory
init|=
literal|0
decl_stmt|;
name|int
name|vcores
init|=
literal|0
decl_stmt|;
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|numInstancesFound
init|=
literal|0
decl_stmt|;
for|for
control|(
name|LlapServiceInstance
name|inst
range|:
name|activeInstances
operator|.
name|getAll
argument_list|()
control|)
block|{
name|Resource
name|r
init|=
name|inst
operator|.
name|getResource
argument_list|()
decl_stmt|;
name|memory
operator|+=
name|r
operator|.
name|getMemory
argument_list|()
expr_stmt|;
name|vcores
operator|+=
name|r
operator|.
name|getVirtualCores
argument_list|()
expr_stmt|;
name|numInstancesFound
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"GetTotalResources: numInstancesFound={}, totalMem={}, totalVcores={}"
argument_list|,
name|numInstancesFound
argument_list|,
name|memory
argument_list|,
name|vcores
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|Resource
operator|.
name|newInstance
argument_list|(
name|memory
argument_list|,
name|vcores
argument_list|)
return|;
block|}
comment|/**    * The difference between this and getTotalResources() is that this only gives currently free    * resource instances, while the other lists all the instances that may become available in a    * while.    */
annotation|@
name|Override
specifier|public
name|Resource
name|getAvailableResources
parameter_list|()
block|{
comment|// need a state store eventually for current state& measure backoffs
name|int
name|memory
init|=
literal|0
decl_stmt|;
name|int
name|vcores
init|=
literal|0
decl_stmt|;
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|numInstancesFound
init|=
literal|0
decl_stmt|;
for|for
control|(
name|LlapServiceInstance
name|inst
range|:
name|activeInstances
operator|.
name|getAll
argument_list|()
control|)
block|{
name|NodeInfo
name|nodeInfo
init|=
name|instanceToNodeMap
operator|.
name|get
argument_list|(
name|inst
operator|.
name|getWorkerIdentity
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeInfo
operator|!=
literal|null
operator|&&
operator|!
name|nodeInfo
operator|.
name|isDisabled
argument_list|()
condition|)
block|{
name|Resource
name|r
init|=
name|inst
operator|.
name|getResource
argument_list|()
decl_stmt|;
name|memory
operator|+=
name|r
operator|.
name|getMemory
argument_list|()
expr_stmt|;
name|vcores
operator|+=
name|r
operator|.
name|getVirtualCores
argument_list|()
expr_stmt|;
name|numInstancesFound
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"GetAvailableResources: numInstancesFound={}, totalMem={}, totalVcores={}"
argument_list|,
name|numInstancesFound
argument_list|,
name|memory
argument_list|,
name|vcores
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|Resource
operator|.
name|newInstance
argument_list|(
name|memory
argument_list|,
name|vcores
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getClusterNodeCount
parameter_list|()
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|activeInstances
operator|.
name|getAll
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|dagComplete
parameter_list|()
block|{
comment|// This is effectively DAG completed, and can be used to reset statistics being tracked.
name|LOG
operator|.
name|info
argument_list|(
literal|"DAG: "
operator|+
name|dagCounter
operator|.
name|get
argument_list|()
operator|+
literal|" completed. Scheduling stats: "
operator|+
name|dagStats
argument_list|)
expr_stmt|;
name|dagCounter
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrCompletedDagCount
argument_list|()
expr_stmt|;
block|}
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|dagRunning
operator|=
literal|false
expr_stmt|;
name|dagStats
operator|=
operator|new
name|StatsPerDag
argument_list|()
expr_stmt|;
name|int
name|pendingCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Priority
argument_list|,
name|List
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|entry
range|:
name|pendingTasks
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|pendingCount
operator|+=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
name|int
name|runningCount
init|=
literal|0
decl_stmt|;
comment|// We don't send messages to pending tasks with the flags; they should be killed elsewhere.
for|for
control|(
name|Entry
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|entry
range|:
name|guaranteedTasks
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
name|set
init|=
name|speculativeTasks
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|==
literal|null
condition|)
block|{
name|set
operator|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
expr_stmt|;
name|speculativeTasks
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|TaskInfo
name|info
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
synchronized|synchronized
init|(
name|info
init|)
block|{
name|info
operator|.
name|isGuaranteed
operator|=
literal|false
expr_stmt|;
block|}
name|set
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
name|guaranteedTasks
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|entry
range|:
name|speculativeTasks
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|runningCount
operator|+=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
name|totalGuaranteed
operator|=
name|unusedGuaranteed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setDagId
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// We remove the tasks above without state checks so just reset all metrics to 0.
name|metrics
operator|.
name|resetWmMetrics
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"DAG reset. Current knownTaskCount={}, pendingTaskCount={}, runningTaskCount={}"
argument_list|,
name|knownTasks
operator|.
name|size
argument_list|()
argument_list|,
name|pendingCount
argument_list|,
name|runningCount
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// TODO Cleanup pending tasks etc, so that the next dag is not affected.
block|}
annotation|@
name|Override
specifier|public
name|void
name|blacklistNode
parameter_list|(
name|NodeId
name|nodeId
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"BlacklistNode not supported"
argument_list|)
expr_stmt|;
comment|// TODO Disable blacklisting in Tez when using LLAP, until this is properly supported.
comment|// Blacklisting can cause containers to move to a terminating state, which can cause attempt to be marked as failed.
comment|// This becomes problematic when we set #allowedFailures to 0
comment|// TODO HIVE-13484 What happens when we try scheduling a task on a node that Tez at this point thinks is blacklisted.
block|}
annotation|@
name|Override
specifier|public
name|void
name|unblacklistNode
parameter_list|(
name|NodeId
name|nodeId
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"unBlacklistNode not supported"
argument_list|)
expr_stmt|;
comment|// TODO: See comments under blacklistNode.
block|}
annotation|@
name|Override
specifier|public
name|void
name|allocateTask
parameter_list|(
name|Object
name|task
parameter_list|,
name|Resource
name|capability
parameter_list|,
name|String
index|[]
name|hosts
parameter_list|,
name|String
index|[]
name|racks
parameter_list|,
name|Priority
name|priority
parameter_list|,
name|Object
name|containerSignature
parameter_list|,
name|Object
name|clientCookie
parameter_list|)
block|{
name|TezTaskAttemptID
name|id
init|=
name|getTaskAttemptId
argument_list|(
name|task
argument_list|)
decl_stmt|;
name|TaskInfo
name|taskInfo
init|=
operator|new
name|TaskInfo
argument_list|(
name|localityDelayConf
argument_list|,
name|clock
argument_list|,
name|task
argument_list|,
name|clientCookie
argument_list|,
name|priority
argument_list|,
name|capability
argument_list|,
name|hosts
argument_list|,
name|racks
argument_list|,
name|clock
operator|.
name|getTime
argument_list|()
argument_list|,
name|id
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Received allocateRequest. task={}, priority={}, capability={}, hosts={}"
argument_list|,
name|task
argument_list|,
name|priority
argument_list|,
name|capability
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|hosts
argument_list|)
argument_list|)
expr_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|dagRunning
operator|&&
name|metrics
operator|!=
literal|null
operator|&&
name|id
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setDagId
argument_list|(
name|id
operator|.
name|getTaskID
argument_list|()
operator|.
name|getVertexID
argument_list|()
operator|.
name|getDAGId
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|dagRunning
operator|=
literal|true
expr_stmt|;
name|dagStats
operator|.
name|registerTaskRequest
argument_list|(
name|hosts
argument_list|,
name|racks
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|addPendingTask
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
name|trySchedulingPendingTasks
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|allocateTask
parameter_list|(
name|Object
name|task
parameter_list|,
name|Resource
name|capability
parameter_list|,
name|ContainerId
name|containerId
parameter_list|,
name|Priority
name|priority
parameter_list|,
name|Object
name|containerSignature
parameter_list|,
name|Object
name|clientCookie
parameter_list|)
block|{
comment|// Container affinity can be implemented as Host affinity for LLAP. Not required until
comment|// 1:1 edges are used in Hive.
name|TezTaskAttemptID
name|id
init|=
name|getTaskAttemptId
argument_list|(
name|task
argument_list|)
decl_stmt|;
name|TaskInfo
name|taskInfo
init|=
operator|new
name|TaskInfo
argument_list|(
name|localityDelayConf
argument_list|,
name|clock
argument_list|,
name|task
argument_list|,
name|clientCookie
argument_list|,
name|priority
argument_list|,
name|capability
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|clock
operator|.
name|getTime
argument_list|()
argument_list|,
name|id
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Received allocateRequest. task={}, priority={}, capability={}, containerId={}"
argument_list|,
name|task
argument_list|,
name|priority
argument_list|,
name|capability
argument_list|,
name|containerId
argument_list|)
expr_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|dagRunning
operator|&&
name|metrics
operator|!=
literal|null
operator|&&
name|id
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setDagId
argument_list|(
name|id
operator|.
name|getTaskID
argument_list|()
operator|.
name|getVertexID
argument_list|()
operator|.
name|getDAGId
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|dagRunning
operator|=
literal|true
expr_stmt|;
name|dagStats
operator|.
name|registerTaskRequest
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|addPendingTask
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
name|trySchedulingPendingTasks
argument_list|()
expr_stmt|;
block|}
specifier|protected
name|TezTaskAttemptID
name|getTaskAttemptId
parameter_list|(
name|Object
name|task
parameter_list|)
block|{
comment|// TODO: why does Tez API use "Object" for this?
if|if
condition|(
name|task
operator|instanceof
name|TaskAttempt
condition|)
block|{
return|return
operator|(
operator|(
name|TaskAttempt
operator|)
name|task
operator|)
operator|.
name|getID
argument_list|()
return|;
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"LLAP plugin can only schedule task attempts"
argument_list|)
throw|;
block|}
comment|// This may be invoked before a container is ever assigned to a task. allocateTask... app decides
comment|// the task is no longer required, and asks for a de-allocation.
annotation|@
name|Override
specifier|public
name|boolean
name|deallocateTask
parameter_list|(
name|Object
name|task
parameter_list|,
name|boolean
name|taskSucceeded
parameter_list|,
name|TaskAttemptEndReason
name|endReason
parameter_list|,
name|String
name|diagnostics
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processing deallocateTask for task={}, taskSucceeded={}, endReason={}"
argument_list|,
name|task
argument_list|,
name|taskSucceeded
argument_list|,
name|endReason
argument_list|)
expr_stmt|;
block|}
name|boolean
name|isEarlyExit
init|=
literal|false
decl_stmt|;
name|TaskInfo
name|toUpdate
init|=
literal|null
decl_stmt|,
name|taskInfo
decl_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// Updating several local structures
try|try
block|{
name|taskInfo
operator|=
name|unregisterTask
argument_list|(
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|taskInfo
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not determine ContainerId for task: "
operator|+
name|task
operator|+
literal|" . Could have hit a race condition. Ignoring."
operator|+
literal|" The query may hang since this \"unknown\" container is now taking up a slot permanently"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|boolean
name|isGuaranteedFreed
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|taskInfo
init|)
block|{
if|if
condition|(
name|taskInfo
operator|.
name|isGuaranteed
operator|==
literal|null
condition|)
block|{
name|WM_LOG
operator|.
name|error
argument_list|(
literal|"Task appears to have been deallocated twice: "
operator|+
name|task
operator|+
literal|" There may be inconsistencies in guaranteed task counts."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setWmTaskFinished
argument_list|(
name|taskInfo
operator|.
name|isGuaranteed
argument_list|,
name|taskInfo
operator|.
name|isPendingUpdate
argument_list|)
expr_stmt|;
block|}
name|isGuaranteedFreed
operator|=
name|taskInfo
operator|.
name|isGuaranteed
expr_stmt|;
comment|// This tells the pending update (if any) that whatever it is doing is irrelevant,
comment|// and also makes sure we don't take the duck back twice if this is called twice.
name|taskInfo
operator|.
name|isGuaranteed
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// Do not put the unused duck back; we'd run the tasks below, then assign it by priority.
comment|// NOTE: this method MUST call distributeGuaranteedOnTaskCompletion before exiting.
if|if
condition|(
name|taskInfo
operator|.
name|containerId
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|taskInfo
operator|.
name|getState
argument_list|()
operator|==
name|TaskInfo
operator|.
name|State
operator|.
name|ASSIGNED
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Task: "
operator|+
name|task
operator|+
literal|" assigned, but could not find the corresponding containerId."
operator|+
literal|" The query may hang since this \"unknown\" container is now taking up a slot permanently"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignoring deallocate request for task "
operator|+
name|task
operator|+
literal|" which hasn't been assigned to a container"
argument_list|)
expr_stmt|;
name|removePendingTask
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isGuaranteedFreed
condition|)
block|{
name|toUpdate
operator|=
name|distributeGuaranteedOnTaskCompletion
argument_list|()
expr_stmt|;
name|isEarlyExit
operator|=
literal|true
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
name|NodeInfo
name|nodeInfo
init|=
name|taskInfo
operator|.
name|assignedNode
decl_stmt|;
assert|assert
name|nodeInfo
operator|!=
literal|null
assert|;
comment|//  endReason shows up as OTHER for CONTAINER_TIME_OUT
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing de-allocate request for task={}, state={}, endReason={}"
argument_list|,
name|taskInfo
operator|.
name|task
argument_list|,
name|taskInfo
operator|.
name|getState
argument_list|()
argument_list|,
name|endReason
argument_list|)
expr_stmt|;
comment|// Re-enable the node if preempted
if|if
condition|(
name|taskInfo
operator|.
name|getState
argument_list|()
operator|==
name|TaskInfo
operator|.
name|State
operator|.
name|PREEMPTED
condition|)
block|{
name|unregisterPendingPreemption
argument_list|(
name|taskInfo
operator|.
name|assignedNode
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
name|nodeInfo
operator|.
name|registerUnsuccessfulTaskEnd
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodeInfo
operator|.
name|isDisabled
argument_list|()
condition|)
block|{
comment|// Re-enable the node, if a task completed due to preemption. Capacity has become available,
comment|// and we may have been able to communicate with the node.
name|queueNodeForReEnablement
argument_list|(
name|nodeInfo
argument_list|)
expr_stmt|;
block|}
comment|// In case of success, trigger a scheduling run for pending tasks.
name|trySchedulingPendingTasks
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|taskSucceeded
condition|)
block|{
comment|// The node may have been blacklisted at this point - which means it may not be in the
comment|// activeNodeList.
name|nodeInfo
operator|.
name|registerTaskSuccess
argument_list|()
expr_stmt|;
if|if
condition|(
name|nodeInfo
operator|.
name|isDisabled
argument_list|()
condition|)
block|{
comment|// Re-enable the node. If a task succeeded, a slot may have become available.
comment|// Also reset commFailures since a task was able to communicate back and indicate success.
name|queueNodeForReEnablement
argument_list|(
name|nodeInfo
argument_list|)
expr_stmt|;
block|}
comment|// In case of success, trigger a scheduling run for pending tasks.
name|trySchedulingPendingTasks
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Task Failed
name|nodeInfo
operator|.
name|registerUnsuccessfulTaskEnd
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// TODO Include EXTERNAL_PREEMPTION in this list?
comment|// TODO HIVE-16134. Differentiate between EXTERNAL_PREEMPTION_WAITQUEU vs EXTERNAL_PREEMPTION_FINISHABLE?
if|if
condition|(
name|endReason
operator|!=
literal|null
operator|&&
name|EnumSet
operator|.
name|of
argument_list|(
name|TaskAttemptEndReason
operator|.
name|EXECUTOR_BUSY
argument_list|,
name|TaskAttemptEndReason
operator|.
name|COMMUNICATION_ERROR
argument_list|)
operator|.
name|contains
argument_list|(
name|endReason
argument_list|)
condition|)
block|{
if|if
condition|(
name|endReason
operator|==
name|TaskAttemptEndReason
operator|.
name|COMMUNICATION_ERROR
condition|)
block|{
name|dagStats
operator|.
name|registerCommFailure
argument_list|(
name|taskInfo
operator|.
name|assignedNode
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|endReason
operator|==
name|TaskAttemptEndReason
operator|.
name|EXECUTOR_BUSY
condition|)
block|{
name|dagStats
operator|.
name|registerTaskRejected
argument_list|(
name|taskInfo
operator|.
name|assignedNode
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|endReason
operator|!=
literal|null
operator|&&
name|endReason
operator|==
name|TaskAttemptEndReason
operator|.
name|NODE_FAILED
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Task {} ended on {} with a NODE_FAILED message."
operator|+
literal|" A message should come in from the registry to disable this node unless"
operator|+
literal|" this was a temporary communication failure"
argument_list|,
name|task
argument_list|,
name|nodeInfo
operator|.
name|toShortString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|boolean
name|commFailure
init|=
name|endReason
operator|!=
literal|null
operator|&&
name|endReason
operator|==
name|TaskAttemptEndReason
operator|.
name|COMMUNICATION_ERROR
decl_stmt|;
name|disableNode
argument_list|(
name|nodeInfo
argument_list|,
name|commFailure
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isGuaranteedFreed
condition|)
block|{
name|toUpdate
operator|=
name|distributeGuaranteedOnTaskCompletion
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|isEarlyExit
condition|)
block|{
comment|// Most of the method got skipped but we still need to handle the duck.
name|checkAndSendGuaranteedStateUpdate
argument_list|(
name|toUpdate
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|toUpdate
operator|!=
literal|null
condition|)
block|{
assert|assert
operator|!
name|isEarlyExit
assert|;
name|checkAndSendGuaranteedStateUpdate
argument_list|(
name|toUpdate
argument_list|)
expr_stmt|;
block|}
name|getContext
argument_list|()
operator|.
name|containerBeingReleased
argument_list|(
name|taskInfo
operator|.
name|containerId
argument_list|)
expr_stmt|;
name|getContext
argument_list|()
operator|.
name|containerCompleted
argument_list|(
name|taskInfo
operator|.
name|task
argument_list|,
name|ContainerStatus
operator|.
name|newInstance
argument_list|(
name|taskInfo
operator|.
name|containerId
argument_list|,
name|ContainerState
operator|.
name|COMPLETE
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
name|void
name|notifyStarted
parameter_list|(
name|TezTaskAttemptID
name|attemptId
parameter_list|)
block|{
name|TaskInfo
name|info
init|=
literal|null
decl_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|info
operator|=
name|tasksById
operator|.
name|get
argument_list|(
name|attemptId
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
name|WM_LOG
operator|.
name|warn
argument_list|(
literal|"Unknown task start notification "
operator|+
name|attemptId
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|handleUpdateResult
argument_list|(
name|info
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * A hacky way for communicator and scheduler to share per-task info. Scheduler should be able    * to include this with task allocation to be passed to the communicator, instead. TEZ-3866.    * @param attemptId Task attempt ID.    * @return The initial value of the guaranteed flag to send with the task.    */
name|boolean
name|isInitialGuaranteed
parameter_list|(
name|TezTaskAttemptID
name|attemptId
parameter_list|)
block|{
name|TaskInfo
name|info
init|=
literal|null
decl_stmt|;
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|info
operator|=
name|tasksById
operator|.
name|get
argument_list|(
name|attemptId
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
name|WM_LOG
operator|.
name|warn
argument_list|(
literal|"Status requested for an unknown task "
operator|+
name|attemptId
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
synchronized|synchronized
init|(
name|info
init|)
block|{
if|if
condition|(
name|info
operator|.
name|isGuaranteed
operator|==
literal|null
condition|)
return|return
literal|false
return|;
comment|// TODO: should never happen?
assert|assert
name|info
operator|.
name|lastSetGuaranteed
operator|==
literal|null
assert|;
name|info
operator|.
name|requestedValue
operator|=
name|info
operator|.
name|isGuaranteed
expr_stmt|;
return|return
name|info
operator|.
name|isGuaranteed
return|;
block|}
block|}
comment|// Must be called under the epic lock.
specifier|private
name|TaskInfo
name|distributeGuaranteedOnTaskCompletion
parameter_list|()
block|{
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|toUpdate
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|int
name|updatedCount
init|=
name|distributeGuaranteed
argument_list|(
literal|1
argument_list|,
literal|null
argument_list|,
name|toUpdate
argument_list|)
decl_stmt|;
assert|assert
name|updatedCount
operator|<=
literal|1
assert|;
if|if
condition|(
name|updatedCount
operator|==
literal|0
condition|)
block|{
name|int
name|result
init|=
operator|++
name|unusedGuaranteed
decl_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setWmUnusedGuaranteed
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|WM_LOG
operator|.
name|info
argument_list|(
literal|"Returning the unused duck; unused is now "
operator|+
name|result
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|toUpdate
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|null
return|;
assert|assert
name|toUpdate
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
return|return
name|toUpdate
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|deallocateContainer
parameter_list|(
name|ContainerId
name|containerId
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring deallocateContainer for containerId: {}"
argument_list|,
name|containerId
argument_list|)
expr_stmt|;
block|}
comment|// Containers are not being tracked for re-use.
comment|// This is safe to ignore since a deallocate task will come in.
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setShouldUnregister
parameter_list|()
block|{    }
annotation|@
name|Override
specifier|public
name|boolean
name|hasUnregistered
parameter_list|()
block|{
comment|// Nothing to do. No registration involved.
return|return
literal|true
return|;
block|}
comment|/**    * @param request the list of preferred hosts. null implies any host    * @return    */
specifier|private
name|SelectHostResult
name|selectHost
parameter_list|(
name|TaskInfo
name|request
parameter_list|)
block|{
name|String
index|[]
name|requestedHosts
init|=
name|request
operator|.
name|requestedHosts
decl_stmt|;
name|String
name|requestedHostsDebugStr
init|=
name|Arrays
operator|.
name|toString
argument_list|(
name|requestedHosts
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"selectingHost for task={} on hosts={}"
argument_list|,
name|request
operator|.
name|task
argument_list|,
name|requestedHostsDebugStr
argument_list|)
expr_stmt|;
block|}
name|long
name|schedulerAttemptTime
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// Read-lock. Not updating any stats at the moment.
try|try
block|{
name|boolean
name|shouldDelayForLocality
init|=
name|request
operator|.
name|shouldDelayForLocality
argument_list|(
name|schedulerAttemptTime
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"ShouldDelayForLocality={} for task={} on hosts={}"
argument_list|,
name|shouldDelayForLocality
argument_list|,
name|request
operator|.
name|task
argument_list|,
name|requestedHostsDebugStr
argument_list|)
expr_stmt|;
if|if
condition|(
name|requestedHosts
operator|!=
literal|null
operator|&&
name|requestedHosts
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|int
name|prefHostCount
init|=
operator|-
literal|1
decl_stmt|;
name|boolean
name|requestedHostsWillBecomeAvailable
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|host
range|:
name|requestedHosts
control|)
block|{
name|prefHostCount
operator|++
expr_stmt|;
comment|// Pick the first host always. Weak attempt at cache affinity.
name|Set
argument_list|<
name|LlapServiceInstance
argument_list|>
name|instances
init|=
name|activeInstances
operator|.
name|getByHost
argument_list|(
name|host
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|instances
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|LlapServiceInstance
name|inst
range|:
name|instances
control|)
block|{
name|NodeInfo
name|nodeInfo
init|=
name|instanceToNodeMap
operator|.
name|get
argument_list|(
name|inst
operator|.
name|getWorkerIdentity
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeInfo
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|nodeInfo
operator|.
name|canAcceptTask
argument_list|()
condition|)
block|{
comment|// Successfully scheduled.
name|LOG
operator|.
name|info
argument_list|(
literal|"Assigning {} when looking for {}."
operator|+
literal|" local=true FirstRequestedHost={}, #prefLocations={}"
argument_list|,
name|nodeInfo
operator|.
name|toShortString
argument_list|()
argument_list|,
name|host
argument_list|,
operator|(
name|prefHostCount
operator|==
literal|0
operator|)
argument_list|,
name|requestedHosts
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
operator|new
name|SelectHostResult
argument_list|(
name|nodeInfo
argument_list|)
return|;
block|}
else|else
block|{
comment|// The node cannot accept a task at the moment.
if|if
condition|(
name|shouldDelayForLocality
condition|)
block|{
comment|// Perform some checks on whether the node will become available or not.
if|if
condition|(
name|request
operator|.
name|shouldForceLocality
argument_list|()
condition|)
block|{
name|requestedHostsWillBecomeAvailable
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nodeInfo
operator|.
name|getEnableTime
argument_list|()
operator|>
name|request
operator|.
name|getLocalityDelayTimeout
argument_list|()
operator|&&
name|nodeInfo
operator|.
name|isDisabled
argument_list|()
operator|&&
name|nodeInfo
operator|.
name|hadCommFailure
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Host={} will not become available within requested timeout"
argument_list|,
name|nodeInfo
argument_list|)
expr_stmt|;
comment|// This node will likely be activated after the task timeout expires.
block|}
else|else
block|{
comment|// Worth waiting for the timeout.
name|requestedHostsWillBecomeAvailable
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Null NodeInfo when attempting to get host with worker {}, and host {}"
argument_list|,
name|inst
argument_list|,
name|host
argument_list|)
expr_stmt|;
comment|// Leave requestedHostWillBecomeAvailable as is. If some other host is found - delay,
comment|// else ends up allocating to a random host immediately.
block|}
block|}
block|}
block|}
comment|// Check if forcing the location is required.
if|if
condition|(
name|shouldDelayForLocality
condition|)
block|{
if|if
condition|(
name|requestedHostsWillBecomeAvailable
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Delaying local allocation for ["
operator|+
name|request
operator|.
name|task
operator|+
literal|"] when trying to allocate on ["
operator|+
name|requestedHostsDebugStr
operator|+
literal|"]"
operator|+
literal|". ScheduleAttemptTime="
operator|+
name|schedulerAttemptTime
operator|+
literal|", taskDelayTimeout="
operator|+
name|request
operator|.
name|getLocalityDelayTimeout
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|SELECT_HOST_RESULT_DELAYED_LOCALITY
return|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping local allocation for ["
operator|+
name|request
operator|.
name|task
operator|+
literal|"] when trying to allocate on ["
operator|+
name|requestedHostsDebugStr
operator|+
literal|"] since none of these hosts are part of the known list"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* fall through - miss in locality or no locality-requested */
name|Collection
argument_list|<
name|LlapServiceInstance
argument_list|>
name|instances
init|=
name|activeInstances
operator|.
name|getAllInstancesOrdered
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|NodeInfo
argument_list|>
name|allNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|instances
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|NodeInfo
argument_list|>
name|activeNodesWithFreeSlots
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|LlapServiceInstance
name|inst
range|:
name|instances
control|)
block|{
if|if
condition|(
name|inst
operator|instanceof
name|InactiveServiceInstance
condition|)
block|{
name|allNodes
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NodeInfo
name|nodeInfo
init|=
name|instanceToNodeMap
operator|.
name|get
argument_list|(
name|inst
operator|.
name|getWorkerIdentity
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeInfo
operator|==
literal|null
condition|)
block|{
name|allNodes
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allNodes
operator|.
name|add
argument_list|(
name|nodeInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodeInfo
operator|.
name|canAcceptTask
argument_list|()
condition|)
block|{
name|activeNodesWithFreeSlots
operator|.
name|add
argument_list|(
name|nodeInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|allNodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|SELECT_HOST_RESULT_DELAYED_RESOURCES
return|;
block|}
comment|// no locality-requested, randomly pick a node containing free slots
if|if
condition|(
name|requestedHosts
operator|==
literal|null
operator|||
name|requestedHosts
operator|.
name|length
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No-locality requested. Selecting a random host for task={}"
argument_list|,
name|request
operator|.
name|task
argument_list|)
expr_stmt|;
block|}
return|return
name|randomSelection
argument_list|(
name|activeNodesWithFreeSlots
argument_list|)
return|;
block|}
comment|// miss in locality request, try picking consistent location with fallback to random selection
specifier|final
name|String
name|firstRequestedHost
init|=
name|requestedHosts
index|[
literal|0
index|]
decl_stmt|;
name|int
name|requestedHostIdx
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|allNodes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|NodeInfo
name|nodeInfo
init|=
name|allNodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeInfo
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|nodeInfo
operator|.
name|getHost
argument_list|()
operator|.
name|equals
argument_list|(
name|firstRequestedHost
argument_list|)
condition|)
block|{
name|requestedHostIdx
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|// requested host died or unknown host requested, fallback to random selection.
comment|// TODO: At this point we don't know the slot number of the requested host, so can't rollover to next available
if|if
condition|(
name|requestedHostIdx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Requested node [{}] in consistent order does not exist. Falling back to random selection for "
operator|+
literal|"request {}"
argument_list|,
name|firstRequestedHost
argument_list|,
name|request
argument_list|)
expr_stmt|;
block|}
return|return
name|randomSelection
argument_list|(
name|activeNodesWithFreeSlots
argument_list|)
return|;
block|}
comment|// requested host is still alive but cannot accept task, pick the next available host in consistent order
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|allNodes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|NodeInfo
name|nodeInfo
init|=
name|allNodes
operator|.
name|get
argument_list|(
operator|(
name|i
operator|+
name|requestedHostIdx
operator|+
literal|1
operator|)
operator|%
name|allNodes
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// next node in consistent order died or does not have free slots, rollover to next
if|if
condition|(
name|nodeInfo
operator|==
literal|null
operator|||
operator|!
name|nodeInfo
operator|.
name|canAcceptTask
argument_list|()
condition|)
block|{
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Assigning {} in consistent order when looking for first requested host, from #hosts={},"
operator|+
literal|" requestedHosts={}"
argument_list|,
name|nodeInfo
operator|.
name|toShortString
argument_list|()
argument_list|,
name|allNodes
operator|.
name|size
argument_list|()
argument_list|,
operator|(
operator|(
name|requestedHosts
operator|==
literal|null
operator|||
name|requestedHosts
operator|.
name|length
operator|==
literal|0
operator|)
condition|?
literal|"null"
else|:
name|requestedHostsDebugStr
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|SelectHostResult
argument_list|(
name|nodeInfo
argument_list|)
return|;
block|}
block|}
return|return
name|SELECT_HOST_RESULT_DELAYED_RESOURCES
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|SelectHostResult
name|randomSelection
parameter_list|(
specifier|final
name|List
argument_list|<
name|NodeInfo
argument_list|>
name|nodesWithFreeSlots
parameter_list|)
block|{
if|if
condition|(
name|nodesWithFreeSlots
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|SELECT_HOST_RESULT_DELAYED_RESOURCES
return|;
block|}
name|NodeInfo
name|randomNode
init|=
name|nodesWithFreeSlots
operator|.
name|get
argument_list|(
name|random
operator|.
name|nextInt
argument_list|(
name|nodesWithFreeSlots
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Assigning {} when looking for any host, from #hosts={}, requestedHosts=null"
argument_list|,
name|randomNode
operator|.
name|toShortString
argument_list|()
argument_list|,
name|nodesWithFreeSlots
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|SelectHostResult
argument_list|(
name|randomNode
argument_list|)
return|;
block|}
specifier|private
name|void
name|addNode
parameter_list|(
name|NodeInfo
name|node
parameter_list|,
name|LlapServiceInstance
name|serviceInstance
parameter_list|)
block|{
comment|// we have just added a new node. Signal timeout monitor to reset timer
if|if
condition|(
name|activeInstances
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|&&
name|timeoutFutureRef
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"New node added. Signalling scheduler timeout monitor thread to stop timer."
argument_list|)
expr_stmt|;
name|stopTimeoutMonitor
argument_list|()
expr_stmt|;
block|}
name|NodeReport
name|nodeReport
init|=
name|constructNodeReport
argument_list|(
name|serviceInstance
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|getContext
argument_list|()
operator|.
name|nodesUpdated
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|nodeReport
argument_list|)
argument_list|)
expr_stmt|;
comment|// When the same node goes away and comes back... the old entry will be lost - which means
comment|// we don't know how many fragments we have actually scheduled on this node.
comment|// Replacing it is the right thing to do though, since we expect the AM to kill all the fragments running on the node, via timeouts.
comment|// De-allocate messages coming in from the old node are sent to the NodeInfo instance for the old node.
name|instanceToNodeMap
operator|.
name|put
argument_list|(
name|node
operator|.
name|getNodeIdentity
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setClusterNodeCount
argument_list|(
name|activeInstances
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Trigger scheduling since a new node became available.
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding new node: {}. TotalNodeCount={}. activeInstances.size={}"
argument_list|,
name|node
argument_list|,
name|instanceToNodeMap
operator|.
name|size
argument_list|()
argument_list|,
name|activeInstances
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|trySchedulingPendingTasks
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|reenableDisabledNode
parameter_list|(
name|NodeInfo
name|nodeInfo
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Attempting to re-enable node: "
operator|+
name|nodeInfo
operator|.
name|toShortString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|activeInstances
operator|.
name|getInstance
argument_list|(
name|nodeInfo
operator|.
name|getNodeIdentity
argument_list|()
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|nodeInfo
operator|.
name|enableNode
argument_list|()
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setDisabledNodeCount
argument_list|(
name|disabledNodesQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Not re-enabling node: {}, since it is not present in the RegistryActiveNodeList"
argument_list|,
name|nodeInfo
operator|.
name|toShortString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Updates relevant structures on the node, and fixes the position in the disabledNodeQueue    * to facilitate the actual re-enablement of the node.    * @param nodeInfo  the node to be re-enabled    */
specifier|private
name|void
name|queueNodeForReEnablement
parameter_list|(
specifier|final
name|NodeInfo
name|nodeInfo
parameter_list|)
block|{
if|if
condition|(
name|disabledNodesQueue
operator|.
name|remove
argument_list|(
name|nodeInfo
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Queueing node for re-enablement: {}"
argument_list|,
name|nodeInfo
operator|.
name|toShortString
argument_list|()
argument_list|)
expr_stmt|;
name|nodeInfo
operator|.
name|resetExpireInformation
argument_list|()
expr_stmt|;
name|disabledNodesQueue
operator|.
name|add
argument_list|(
name|nodeInfo
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|disableNode
parameter_list|(
name|NodeInfo
name|nodeInfo
parameter_list|,
name|boolean
name|isCommFailure
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|nodeInfo
operator|==
literal|null
operator|||
name|nodeInfo
operator|.
name|isDisabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|nodeInfo
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node: "
operator|+
name|nodeInfo
operator|.
name|toShortString
argument_list|()
operator|+
literal|" already disabled, or invalid. Not doing anything."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring disableNode invocation for null NodeInfo"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|nodeInfo
operator|.
name|disableNode
argument_list|(
name|isCommFailure
argument_list|)
expr_stmt|;
comment|// TODO: handle task to container map events in case of hard failures
name|disabledNodesQueue
operator|.
name|add
argument_list|(
name|nodeInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setDisabledNodeCount
argument_list|(
name|disabledNodesQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Trigger a scheduling run - in case there's some task which was waiting for this node to
comment|// become available.
name|trySchedulingPendingTasks
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|NodeReport
name|constructNodeReport
parameter_list|(
name|LlapServiceInstance
name|serviceInstance
parameter_list|,
name|boolean
name|healthy
parameter_list|)
block|{
name|NodeReport
name|nodeReport
init|=
name|NodeReport
operator|.
name|newInstance
argument_list|(
name|NodeId
operator|.
name|newInstance
argument_list|(
name|serviceInstance
operator|.
name|getHost
argument_list|()
argument_list|,
name|serviceInstance
operator|.
name|getRpcPort
argument_list|()
argument_list|)
argument_list|,
name|healthy
condition|?
name|NodeState
operator|.
name|RUNNING
else|:
name|NodeState
operator|.
name|LOST
argument_list|,
name|serviceInstance
operator|.
name|getServicesAddress
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|0l
argument_list|)
decl_stmt|;
return|return
name|nodeReport
return|;
block|}
specifier|private
name|void
name|addPendingTask
parameter_list|(
name|TaskInfo
name|taskInfo
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|tasksAtPriority
init|=
name|pendingTasks
operator|.
name|get
argument_list|(
name|taskInfo
operator|.
name|priority
argument_list|)
decl_stmt|;
if|if
condition|(
name|tasksAtPriority
operator|==
literal|null
condition|)
block|{
name|tasksAtPriority
operator|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
expr_stmt|;
name|pendingTasks
operator|.
name|put
argument_list|(
name|taskInfo
operator|.
name|priority
argument_list|,
name|tasksAtPriority
argument_list|)
expr_stmt|;
block|}
comment|// Delayed tasks will not kick in right now. That will happen in the scheduling loop.
name|tasksAtPriority
operator|.
name|add
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
name|knownTasks
operator|.
name|putIfAbsent
argument_list|(
name|taskInfo
operator|.
name|task
argument_list|,
name|taskInfo
argument_list|)
expr_stmt|;
name|tasksById
operator|.
name|put
argument_list|(
name|taskInfo
operator|.
name|attemptId
argument_list|,
name|taskInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrPendingTasksCount
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"PendingTasksInfo={}"
argument_list|,
name|constructPendingTaskCountsLogMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Remove a task from the pending list */
specifier|private
name|void
name|removePendingTask
parameter_list|(
name|TaskInfo
name|taskInfo
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|Priority
name|priority
init|=
name|taskInfo
operator|.
name|priority
decl_stmt|;
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|taskInfoList
init|=
name|pendingTasks
operator|.
name|get
argument_list|(
name|priority
argument_list|)
decl_stmt|;
if|if
condition|(
name|taskInfoList
operator|==
literal|null
operator|||
name|taskInfoList
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|taskInfoList
operator|.
name|remove
argument_list|(
name|taskInfo
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not find task: "
operator|+
name|taskInfo
operator|.
name|task
operator|+
literal|" in pending list, at priority: "
operator|+
name|priority
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Register a running task into the runningTasks structure */
annotation|@
name|VisibleForTesting
specifier|protected
name|void
name|registerRunningTask
parameter_list|(
name|TaskInfo
name|taskInfo
parameter_list|)
block|{
name|boolean
name|isGuaranteed
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|taskInfo
init|)
block|{
assert|assert
operator|!
name|taskInfo
operator|.
name|isPendingUpdate
assert|;
comment|// Update is included with the submit request; callback is via notifyStarted.
name|isGuaranteed
operator|=
name|taskInfo
operator|.
name|isGuaranteed
expr_stmt|;
name|taskInfo
operator|.
name|isPendingUpdate
operator|=
literal|true
expr_stmt|;
name|taskInfo
operator|.
name|requestedValue
operator|=
name|taskInfo
operator|.
name|isGuaranteed
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setWmTaskStarted
argument_list|(
name|taskInfo
operator|.
name|requestedValue
argument_list|)
expr_stmt|;
block|}
name|setUpdateStartedUnderTiLock
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
block|}
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|runningTasks
init|=
name|isGuaranteed
condition|?
name|guaranteedTasks
else|:
name|speculativeTasks
decl_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|WM_LOG
operator|.
name|info
argument_list|(
literal|"Registering "
operator|+
name|taskInfo
operator|.
name|attemptId
operator|+
literal|"; "
operator|+
name|taskInfo
operator|.
name|isGuaranteed
argument_list|)
expr_stmt|;
name|addToRunningTasksMap
argument_list|(
name|runningTasks
argument_list|,
name|taskInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|decrPendingTasksCount
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|protected
name|TaskInfo
name|getTaskInfo
parameter_list|(
name|Object
name|task
parameter_list|)
block|{
return|return
name|knownTasks
operator|.
name|get
argument_list|(
name|task
argument_list|)
return|;
block|}
comment|/* Unregister a task from the known and running structures */
specifier|private
name|TaskInfo
name|unregisterTask
parameter_list|(
name|Object
name|task
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|TaskInfo
name|taskInfo
init|=
name|knownTasks
operator|.
name|remove
argument_list|(
name|task
argument_list|)
decl_stmt|;
if|if
condition|(
name|taskInfo
operator|!=
literal|null
condition|)
block|{
name|tasksById
operator|.
name|remove
argument_list|(
name|taskInfo
operator|.
name|attemptId
argument_list|)
expr_stmt|;
name|WM_LOG
operator|.
name|info
argument_list|(
literal|"Unregistering "
operator|+
name|taskInfo
operator|.
name|attemptId
operator|+
literal|"; "
operator|+
name|taskInfo
operator|.
name|isGuaranteed
argument_list|)
expr_stmt|;
if|if
condition|(
name|taskInfo
operator|.
name|getState
argument_list|()
operator|==
name|TaskInfo
operator|.
name|State
operator|.
name|ASSIGNED
condition|)
block|{
comment|// Remove from the running list.
if|if
condition|(
operator|!
name|removeFromRunningTaskMap
argument_list|(
name|speculativeTasks
argument_list|,
name|task
argument_list|,
name|taskInfo
argument_list|)
operator|&&
operator|!
name|removeFromRunningTaskMap
argument_list|(
name|guaranteedTasks
argument_list|,
name|task
argument_list|,
name|taskInfo
argument_list|)
condition|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
literal|false
argument_list|,
literal|"runningTasks should contain an entry if the task"
operator|+
literal|" was in running state. Caused by task: {}"
argument_list|,
name|task
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not find TaskInfo for task: {}. Not removing it from the running set"
argument_list|,
name|task
argument_list|)
expr_stmt|;
block|}
return|return
name|taskInfo
return|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|addToRunningTasksMap
parameter_list|(
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|runningTasks
parameter_list|,
name|TaskInfo
name|taskInfo
parameter_list|)
block|{
name|int
name|priority
init|=
name|taskInfo
operator|.
name|priority
operator|.
name|getPriority
argument_list|()
decl_stmt|;
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
name|tasksAtpriority
init|=
name|runningTasks
operator|.
name|get
argument_list|(
name|priority
argument_list|)
decl_stmt|;
if|if
condition|(
name|tasksAtpriority
operator|==
literal|null
condition|)
block|{
name|tasksAtpriority
operator|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|TASK_INFO_COMPARATOR
argument_list|)
expr_stmt|;
name|runningTasks
operator|.
name|put
argument_list|(
name|priority
argument_list|,
name|tasksAtpriority
argument_list|)
expr_stmt|;
block|}
name|tasksAtpriority
operator|.
name|add
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|boolean
name|removeFromRunningTaskMap
parameter_list|(
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|runningTasks
parameter_list|,
name|Object
name|task
parameter_list|,
name|TaskInfo
name|taskInfo
parameter_list|)
block|{
name|int
name|priority
init|=
name|taskInfo
operator|.
name|priority
operator|.
name|getPriority
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|TaskInfo
argument_list|>
name|tasksAtPriority
init|=
name|runningTasks
operator|.
name|get
argument_list|(
name|priority
argument_list|)
decl_stmt|;
if|if
condition|(
name|tasksAtPriority
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|boolean
name|result
init|=
name|tasksAtPriority
operator|.
name|remove
argument_list|(
name|taskInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|tasksAtPriority
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|runningTasks
operator|.
name|remove
argument_list|(
name|priority
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|private
enum|enum
name|ScheduleResult
block|{
comment|// Successfully scheduled
name|SCHEDULED
block|,
comment|// Delayed to find a local match
name|DELAYED_LOCALITY
block|,
comment|// Delayed due to temporary resource availability
name|DELAYED_RESOURCES
block|,
comment|// Inadequate total resources - will never succeed / wait for new executors to become available
name|INADEQUATE_TOTAL_RESOURCES
block|,   }
annotation|@
name|VisibleForTesting
specifier|protected
name|void
name|schedulePendingTasks
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|Ref
argument_list|<
name|TaskInfo
argument_list|>
name|downgradedTask
init|=
operator|new
name|Ref
argument_list|<>
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ScheduleRun: {}"
argument_list|,
name|constructPendingTaskCountsLogMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|Priority
argument_list|,
name|List
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
argument_list|>
name|pendingIterator
init|=
name|pendingTasks
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Resource
name|totalResource
init|=
name|getTotalResources
argument_list|()
decl_stmt|;
while|while
condition|(
name|pendingIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|Priority
argument_list|,
name|List
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|entry
init|=
name|pendingIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|taskListAtPriority
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|TaskInfo
argument_list|>
name|taskIter
init|=
name|taskListAtPriority
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|boolean
name|scheduledAllAtPriority
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|taskIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// TODO Optimization: Add a check to see if there's any capacity available. No point in
comment|// walking through all active nodes, if they don't have potential capacity.
name|TaskInfo
name|taskInfo
init|=
name|taskIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|taskInfo
operator|.
name|getNumPreviousAssignAttempts
argument_list|()
operator|==
literal|1
condition|)
block|{
name|dagStats
operator|.
name|registerDelayedAllocation
argument_list|()
expr_stmt|;
block|}
name|taskInfo
operator|.
name|triedAssigningTask
argument_list|()
expr_stmt|;
name|ScheduleResult
name|scheduleResult
init|=
name|scheduleTask
argument_list|(
name|taskInfo
argument_list|,
name|totalResource
argument_list|,
name|downgradedTask
argument_list|)
decl_stmt|;
comment|// Note: we must handle downgradedTask after this. We do it at the end, outside the lock.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ScheduleResult for Task: {} = {}"
argument_list|,
name|taskInfo
argument_list|,
name|scheduleResult
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scheduleResult
operator|==
name|ScheduleResult
operator|.
name|SCHEDULED
condition|)
block|{
name|taskIter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|scheduleResult
operator|==
name|ScheduleResult
operator|.
name|INADEQUATE_TOTAL_RESOURCES
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Inadequate total resources before scheduling pending tasks."
operator|+
literal|" Signalling scheduler timeout monitor thread to start timer."
argument_list|)
expr_stmt|;
name|startTimeoutMonitor
argument_list|()
expr_stmt|;
comment|// TODO Nothing else should be done for this task. Move on.
block|}
comment|// Try pre-empting a task so that a higher priority task can take it's place.
comment|// Preempt only if there's no pending preemptions to avoid preempting twice for a task.
name|String
index|[]
name|potentialHosts
decl_stmt|;
if|if
condition|(
name|scheduleResult
operator|==
name|ScheduleResult
operator|.
name|DELAYED_LOCALITY
condition|)
block|{
comment|// Add the task to the delayed task queue if it does not already exist.
name|maybeAddToDelayedTaskQueue
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
comment|// Try preempting a lower priority task in any case.
comment|// preempt only on specific hosts, if no preemptions already exist on those.
name|potentialHosts
operator|=
name|taskInfo
operator|.
name|requestedHosts
expr_stmt|;
comment|//Protect against a bad location being requested.
if|if
condition|(
name|potentialHosts
operator|==
literal|null
operator|||
name|potentialHosts
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|potentialHosts
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// preempt on any host.
name|potentialHosts
operator|=
literal|null
expr_stmt|;
block|}
comment|// At this point we're dealing with all return types, except ScheduleResult.SCHEDULED.
if|if
condition|(
name|potentialHosts
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting to preempt on requested host for task={}, potentialHosts={}"
argument_list|,
name|taskInfo
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|potentialHosts
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Preempt on specific host
name|boolean
name|shouldPreempt
init|=
literal|true
decl_stmt|;
for|for
control|(
name|String
name|host
range|:
name|potentialHosts
control|)
block|{
comment|// Preempt only if there are no pending preemptions on the same host
comment|// When the premption registers, the request at the highest priority will be given the slot,
comment|// even if the initial preemption was caused by some other task.
comment|// TODO Maybe register which task the preemption was for, to avoid a bad non-local allocation.
name|MutableInt
name|pendingHostPreemptions
init|=
name|pendingPreemptionsPerHost
operator|.
name|get
argument_list|(
name|host
argument_list|)
decl_stmt|;
if|if
condition|(
name|pendingHostPreemptions
operator|!=
literal|null
operator|&&
name|pendingHostPreemptions
operator|.
name|intValue
argument_list|()
operator|>
literal|0
condition|)
block|{
name|shouldPreempt
operator|=
literal|false
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not preempting for task={}. Found an existing preemption request on host={}, pendingPreemptionCount={}"
argument_list|,
name|taskInfo
operator|.
name|task
argument_list|,
name|host
argument_list|,
name|pendingHostPreemptions
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|shouldPreempt
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting to preempt for {} on potential hosts={}. TotalPendingPreemptions={}"
argument_list|,
name|taskInfo
operator|.
name|task
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|potentialHosts
argument_list|)
argument_list|,
name|pendingPreemptions
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|preemptTasks
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getPriority
argument_list|()
argument_list|,
name|vertexNum
argument_list|(
name|taskInfo
argument_list|)
argument_list|,
literal|1
argument_list|,
name|potentialHosts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not preempting for {} on potential hosts={}. An existing preemption request exists"
argument_list|,
name|taskInfo
operator|.
name|task
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|potentialHosts
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// Either DELAYED_RESOURCES or DELAYED_LOCALITY with an unknown requested host.
comment|// Request for a preemption if there's none pending. If a single preemption is pending,
comment|// and this is the next task to be assigned, it will be assigned once that slot becomes available.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting to preempt on any host for task={}, pendingPreemptions={}"
argument_list|,
name|taskInfo
operator|.
name|task
argument_list|,
name|pendingPreemptions
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pendingPreemptions
operator|.
name|get
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting to preempt for task={}, priority={} on any available host"
argument_list|,
name|taskInfo
operator|.
name|task
argument_list|,
name|taskInfo
operator|.
name|priority
argument_list|)
expr_stmt|;
block|}
name|preemptTasks
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getPriority
argument_list|()
argument_list|,
name|vertexNum
argument_list|(
name|taskInfo
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping preemption since there are {} pending preemption request. For task={}"
argument_list|,
name|pendingPreemptions
operator|.
name|get
argument_list|()
argument_list|,
name|taskInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Since there was an allocation failure - don't try assigning tasks at the next priority.
name|scheduledAllAtPriority
operator|=
literal|false
expr_stmt|;
comment|// Don't break if this allocation failure was a result of a LOCALITY_DELAY. Others could still be allocated.
if|if
condition|(
name|scheduleResult
operator|!=
name|ScheduleResult
operator|.
name|DELAYED_LOCALITY
condition|)
block|{
break|break;
block|}
block|}
comment|// end of else - i.e. could not allocate
block|}
comment|// end of loop over pending tasks
if|if
condition|(
name|taskListAtPriority
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Remove the entry, if there's nothing left at the specific priority level
name|pendingIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|scheduledAllAtPriority
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unable to schedule all requests at priority={}. Skipping subsequent priority levels"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
comment|// Don't attempt scheduling for additional priorities
break|break;
block|}
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|downgradedTask
operator|.
name|value
operator|!=
literal|null
condition|)
block|{
name|WM_LOG
operator|.
name|info
argument_list|(
literal|"Downgrading "
operator|+
name|downgradedTask
operator|.
name|value
operator|.
name|attemptId
argument_list|)
expr_stmt|;
name|checkAndSendGuaranteedStateUpdate
argument_list|(
name|downgradedTask
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|int
name|vertexNum
parameter_list|(
name|TaskInfo
name|taskInfo
parameter_list|)
block|{
return|return
name|taskInfo
operator|.
name|getAttemptId
argument_list|()
operator|.
name|getTaskID
argument_list|()
operator|.
name|getVertexID
argument_list|()
operator|.
name|getId
argument_list|()
return|;
comment|// Sigh...
block|}
specifier|private
name|String
name|constructPendingTaskCountsLogMessage
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|totalCount
init|=
literal|0
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"numPriorityLevels="
argument_list|)
operator|.
name|append
argument_list|(
name|pendingTasks
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|". "
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|Priority
argument_list|,
name|List
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
argument_list|>
name|pendingIterator
init|=
name|pendingTasks
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|pendingIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|Priority
argument_list|,
name|List
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|entry
init|=
name|pendingIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|int
name|count
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|==
literal|null
condition|?
literal|0
else|:
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"[p="
argument_list|)
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|",c="
argument_list|)
operator|.
name|append
argument_list|(
name|count
argument_list|)
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
name|totalCount
operator|+=
name|count
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|". totalPendingTasks="
argument_list|)
operator|.
name|append
argument_list|(
name|totalCount
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|". delayedTaskQueueSize="
argument_list|)
operator|.
name|append
argument_list|(
name|delayedTaskQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|ScheduleResult
name|scheduleTask
parameter_list|(
name|TaskInfo
name|taskInfo
parameter_list|,
name|Resource
name|totalResource
parameter_list|,
name|Ref
argument_list|<
name|TaskInfo
argument_list|>
name|downgradedTask
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|totalResource
argument_list|,
literal|"totalResource can not be null"
argument_list|)
expr_stmt|;
comment|// If there's no memory available, fail
if|if
condition|(
name|totalResource
operator|.
name|getMemory
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return
name|SELECT_HOST_RESULT_INADEQUATE_TOTAL_CAPACITY
operator|.
name|scheduleResult
return|;
block|}
name|SelectHostResult
name|selectHostResult
init|=
name|selectHost
argument_list|(
name|taskInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectHostResult
operator|.
name|scheduleResult
operator|!=
name|ScheduleResult
operator|.
name|SCHEDULED
condition|)
block|{
return|return
name|selectHostResult
operator|.
name|scheduleResult
return|;
block|}
if|if
condition|(
name|unusedGuaranteed
operator|>
literal|0
condition|)
block|{
name|boolean
name|wasGuaranteed
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|taskInfo
init|)
block|{
assert|assert
operator|!
name|taskInfo
operator|.
name|isPendingUpdate
assert|;
comment|// No updates before it's running.
name|wasGuaranteed
operator|=
name|taskInfo
operator|.
name|isGuaranteed
expr_stmt|;
name|taskInfo
operator|.
name|isGuaranteed
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|wasGuaranteed
condition|)
block|{
comment|// This should never happen - we only schedule one attempt once.
name|WM_LOG
operator|.
name|error
argument_list|(
literal|"The task had guaranteed flag set before scheduling: "
operator|+
name|taskInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|result
init|=
operator|--
name|unusedGuaranteed
decl_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|setWmUnusedGuaranteed
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|WM_LOG
operator|.
name|info
argument_list|(
literal|"Using an unused duck for "
operator|+
name|taskInfo
operator|.
name|attemptId
operator|+
literal|"; unused is now "
operator|+
name|result
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// We could be scheduling a guaranteed task when a higher priority task cannot be
comment|// scheduled. Try to take a duck away from a lower priority task here.
if|if
condition|(
name|findGuaranteedToReallocate
argument_list|(
name|taskInfo
argument_list|,
name|downgradedTask
argument_list|)
condition|)
block|{
comment|// We are revoking another duck; don't wait. We could also give the duck
comment|// to this task in the callback instead.
synchronized|synchronized
init|(
name|taskInfo
init|)
block|{
assert|assert
operator|!
name|taskInfo
operator|.
name|isPendingUpdate
assert|;
comment|// No updates before it's running.
name|taskInfo
operator|.
name|isGuaranteed
operator|=
literal|true
expr_stmt|;
block|}
comment|// Note: after this, the caller MUST send the downgrade message to downgradedTask
comment|//       (outside of the writeLock, preferably), before exiting.
block|}
block|}
name|NodeInfo
name|nodeInfo
init|=
name|selectHostResult
operator|.
name|nodeInfo
decl_stmt|;
name|Container
name|container
init|=
name|containerFactory
operator|.
name|createContainer
argument_list|(
name|nodeInfo
operator|.
name|getResourcePerExecutor
argument_list|()
argument_list|,
name|taskInfo
operator|.
name|priority
argument_list|,
name|nodeInfo
operator|.
name|getHost
argument_list|()
argument_list|,
name|nodeInfo
operator|.
name|getRpcPort
argument_list|()
argument_list|,
name|nodeInfo
operator|.
name|getServiceAddress
argument_list|()
argument_list|)
decl_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// While updating local structures
comment|// Note: this is actually called under the epic writeLock in schedulePendingTasks
try|try
block|{
comment|// The canAccept part of this log message does not account for this allocation.
name|assignedTaskCounter
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Assigned #{}, task={} on node={}, to container={}"
argument_list|,
name|assignedTaskCounter
operator|.
name|get
argument_list|()
argument_list|,
name|taskInfo
argument_list|,
name|nodeInfo
operator|.
name|toShortString
argument_list|()
argument_list|,
name|container
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|dagStats
operator|.
name|registerTaskAllocated
argument_list|(
name|taskInfo
operator|.
name|requestedHosts
argument_list|,
name|taskInfo
operator|.
name|requestedRacks
argument_list|,
name|nodeInfo
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
name|taskInfo
operator|.
name|setAssignmentInfo
argument_list|(
name|nodeInfo
argument_list|,
name|container
operator|.
name|getId
argument_list|()
argument_list|,
name|clock
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
name|registerRunningTask
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
name|nodeInfo
operator|.
name|registerTaskScheduled
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|getContext
argument_list|()
operator|.
name|taskAllocated
argument_list|(
name|taskInfo
operator|.
name|task
argument_list|,
name|taskInfo
operator|.
name|clientCookie
argument_list|,
name|container
argument_list|)
expr_stmt|;
return|return
name|selectHostResult
operator|.
name|scheduleResult
return|;
block|}
comment|// Removes tasks from the runningList and sends out a preempt request to the system.
comment|// Subsequent tasks will be scheduled again once the de-allocate request for the preempted
comment|// task is processed.
specifier|private
name|void
name|preemptTasks
parameter_list|(
name|int
name|forPriority
parameter_list|,
name|int
name|forVertex
parameter_list|,
name|int
name|numTasksToPreempt
parameter_list|,
name|String
index|[]
name|potentialHosts
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|preemptHosts
init|=
literal|null
decl_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|preemptedTaskList
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// TODO: numTasksToPreempt is currently always 1.
name|preemptedTaskList
operator|=
name|preemptTasksFromMap
argument_list|(
name|speculativeTasks
argument_list|,
name|forPriority
argument_list|,
name|forVertex
argument_list|,
name|numTasksToPreempt
argument_list|,
name|potentialHosts
argument_list|,
name|preemptHosts
argument_list|,
name|preemptedTaskList
argument_list|)
expr_stmt|;
if|if
condition|(
name|preemptedTaskList
operator|!=
literal|null
condition|)
block|{
name|numTasksToPreempt
operator|-=
name|preemptedTaskList
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|numTasksToPreempt
operator|>
literal|0
condition|)
block|{
name|preemptedTaskList
operator|=
name|preemptTasksFromMap
argument_list|(
name|guaranteedTasks
argument_list|,
name|forPriority
argument_list|,
name|forVertex
argument_list|,
name|numTasksToPreempt
argument_list|,
name|potentialHosts
argument_list|,
name|preemptHosts
argument_list|,
name|preemptedTaskList
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// Send out the preempted request outside of the lock.
if|if
condition|(
name|preemptedTaskList
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|TaskInfo
name|taskInfo
range|:
name|preemptedTaskList
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Preempting task {}"
argument_list|,
name|taskInfo
argument_list|)
expr_stmt|;
name|getContext
argument_list|()
operator|.
name|preemptContainer
argument_list|(
name|taskInfo
operator|.
name|containerId
argument_list|)
expr_stmt|;
comment|// Preemption will finally be registered as a deallocateTask as a result of preemptContainer
comment|// That resets preemption info and allows additional tasks to be pre-empted if required.
block|}
block|}
comment|// The schedule loop will be triggered again when the deallocateTask request comes in for the
comment|// preempted task.
block|}
specifier|private
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|preemptTasksFromMap
parameter_list|(
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|runningTasks
parameter_list|,
name|int
name|forPriority
parameter_list|,
name|int
name|forVertex
parameter_list|,
name|int
name|numTasksToPreempt
parameter_list|,
name|String
index|[]
name|potentialHosts
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|preemptHosts
parameter_list|,
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|preemptedTaskList
parameter_list|)
block|{
name|NavigableMap
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|orderedMap
init|=
name|runningTasks
operator|.
name|descendingMap
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
argument_list|>
name|iterator
init|=
name|orderedMap
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|preemptedCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
operator|&&
name|preemptedCount
operator|<
name|numTasksToPreempt
condition|)
block|{
name|Entry
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|entryAtPriority
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryAtPriority
operator|.
name|getKey
argument_list|()
operator|>
name|forPriority
condition|)
block|{
if|if
condition|(
name|potentialHosts
operator|!=
literal|null
operator|&&
name|preemptHosts
operator|==
literal|null
condition|)
block|{
name|preemptHosts
operator|=
name|Sets
operator|.
name|newHashSet
argument_list|(
name|potentialHosts
argument_list|)
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|TaskInfo
argument_list|>
name|taskInfoIterator
init|=
name|entryAtPriority
operator|.
name|getValue
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|taskInfoIterator
operator|.
name|hasNext
argument_list|()
operator|&&
name|preemptedCount
operator|<
name|numTasksToPreempt
condition|)
block|{
name|TaskInfo
name|taskInfo
init|=
name|taskInfoIterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|preemptHosts
operator|!=
literal|null
operator|&&
operator|!
name|preemptHosts
operator|.
name|contains
argument_list|(
name|taskInfo
operator|.
name|assignedNode
operator|.
name|getHost
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
comment|// Not the right host.
block|}
name|Map
argument_list|<
name|Integer
argument_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|depInfo
init|=
name|getDependencyInfo
argument_list|(
name|taskInfo
operator|.
name|attemptId
operator|.
name|getTaskID
argument_list|()
operator|.
name|getVertexID
argument_list|()
operator|.
name|getDAGId
argument_list|()
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|vertexDepInfo
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|depInfo
operator|!=
literal|null
condition|)
block|{
name|vertexDepInfo
operator|=
name|depInfo
operator|.
name|get
argument_list|(
name|forVertex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|depInfo
operator|!=
literal|null
operator|&&
name|vertexDepInfo
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot find info for "
operator|+
name|forVertex
operator|+
literal|" "
operator|+
name|depInfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vertexDepInfo
operator|!=
literal|null
operator|&&
operator|!
name|vertexDepInfo
operator|.
name|contains
argument_list|(
name|vertexNum
argument_list|(
name|taskInfo
argument_list|)
argument_list|)
condition|)
block|{
comment|// Only preempt if the task being preempted is "below" us in the dag.
continue|continue;
block|}
comment|// Candidate for preemption.
name|preemptedCount
operator|++
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"preempting {} for task at priority {} with potentialHosts={}"
argument_list|,
name|taskInfo
argument_list|,
name|forPriority
argument_list|,
name|potentialHosts
operator|==
literal|null
condition|?
literal|""
else|:
name|Arrays
operator|.
name|toString
argument_list|(
name|potentialHosts
argument_list|)
argument_list|)
expr_stmt|;
name|taskInfo
operator|.
name|setPreemptedInfo
argument_list|(
name|clock
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|preemptedTaskList
operator|==
literal|null
condition|)
block|{
name|preemptedTaskList
operator|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|dagStats
operator|.
name|registerTaskPreempted
argument_list|(
name|taskInfo
operator|.
name|assignedNode
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
name|preemptedTaskList
operator|.
name|add
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
name|registerPendingPreemption
argument_list|(
name|taskInfo
operator|.
name|assignedNode
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
comment|// Remove from the runningTaskList
name|taskInfoIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
comment|// Remove entire priority level if it's been emptied.
if|if
condition|(
name|entryAtPriority
operator|.
name|getValue
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// No tasks qualify as preemptable
name|LOG
operator|.
name|debug
argument_list|(
literal|"No tasks qualify as killable to schedule tasks at priority {}. Current priority={}"
argument_list|,
name|forPriority
argument_list|,
name|entryAtPriority
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|preemptedTaskList
return|;
block|}
comment|// Note: this is called under the epic lock.
specifier|private
name|int
name|distributeGuaranteed
parameter_list|(
name|int
name|count
parameter_list|,
name|TaskInfo
name|failedUpdate
parameter_list|,
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|toUpdate
parameter_list|)
block|{
name|WM_LOG
operator|.
name|info
argument_list|(
literal|"Distributing "
operator|+
name|count
operator|+
literal|" among "
operator|+
name|speculativeTasks
operator|.
name|size
argument_list|()
operator|+
literal|" levels"
operator|+
operator|(
name|failedUpdate
operator|==
literal|null
condition|?
literal|""
else|:
literal|"; on failure"
operator|)
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
argument_list|>
name|iterator
init|=
name|speculativeTasks
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|remainingCount
init|=
name|count
decl_stmt|;
comment|// When done, handleUpdate.. may break the iterator, so the order of these checks is important.
while|while
condition|(
name|remainingCount
operator|>
literal|0
operator|&&
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|remainingCount
operator|=
name|handleUpdateForSinglePriorityLevel
argument_list|(
name|remainingCount
argument_list|,
name|iterator
argument_list|,
name|failedUpdate
argument_list|,
name|toUpdate
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|count
operator|-
name|remainingCount
return|;
block|}
comment|// Note: this is called under the epic lock.
specifier|private
name|int
name|revokeGuaranteed
parameter_list|(
name|int
name|count
parameter_list|,
name|TaskInfo
name|failedUpdate
parameter_list|,
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|toUpdate
parameter_list|)
block|{
name|WM_LOG
operator|.
name|info
argument_list|(
literal|"Revoking "
operator|+
name|count
operator|+
literal|" from "
operator|+
name|guaranteedTasks
operator|.
name|size
argument_list|()
operator|+
literal|" levels"
operator|+
operator|(
name|failedUpdate
operator|==
literal|null
condition|?
literal|""
else|:
literal|"; on failure"
operator|)
argument_list|)
expr_stmt|;
name|int
name|remainingCount
init|=
name|count
decl_stmt|;
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
argument_list|>
name|iterator
init|=
name|guaranteedTasks
operator|.
name|descendingMap
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
comment|// When done, handleUpdate.. may break the iterator, so the order of these checks is important.
while|while
condition|(
name|remainingCount
operator|>
literal|0
operator|&&
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|remainingCount
operator|=
name|handleUpdateForSinglePriorityLevel
argument_list|(
name|remainingCount
argument_list|,
name|iterator
argument_list|,
name|failedUpdate
argument_list|,
name|toUpdate
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
name|count
operator|-
name|remainingCount
return|;
block|}
comment|// Must be called under the epic lock.
specifier|private
name|boolean
name|findGuaranteedToReallocate
parameter_list|(
name|TaskInfo
name|candidate
parameter_list|,
name|Ref
argument_list|<
name|TaskInfo
argument_list|>
name|toUpdate
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
argument_list|>
name|iterator
init|=
name|guaranteedTasks
operator|.
name|descendingMap
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|entry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|int
name|priority
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
name|atPriority
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|priority
operator|<=
name|candidate
operator|.
name|priority
operator|.
name|getPriority
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
comment|// The tasks from now on are more important than the candidate.
block|}
name|TaskInfo
name|taskInfo
init|=
name|atPriority
operator|.
name|pollLast
argument_list|()
decl_stmt|;
if|if
condition|(
name|taskInfo
operator|!=
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|taskInfo
init|)
block|{
assert|assert
name|taskInfo
operator|.
name|isGuaranteed
assert|;
name|taskInfo
operator|.
name|isGuaranteed
operator|=
literal|false
expr_stmt|;
comment|// See the comment in handleUpdateForSinglePriorityLevel.
if|if
condition|(
operator|!
name|taskInfo
operator|.
name|isPendingUpdate
condition|)
block|{
name|setUpdateStartedUnderTiLock
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
name|toUpdate
operator|.
name|value
operator|=
name|taskInfo
expr_stmt|;
block|}
block|}
name|addToRunningTasksMap
argument_list|(
name|speculativeTasks
argument_list|,
name|taskInfo
argument_list|)
expr_stmt|;
block|}
comment|// Remove entire priority level if it's been emptied.
if|if
condition|(
name|atPriority
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|taskInfo
operator|!=
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|int
name|handleUpdateForSinglePriorityLevel
parameter_list|(
name|int
name|remainingCount
parameter_list|,
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
argument_list|>
name|iterator
parameter_list|,
name|TaskInfo
name|failedUpdate
parameter_list|,
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|toUpdate
parameter_list|,
name|boolean
name|newValue
parameter_list|)
block|{
name|Entry
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|entry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
name|atPriority
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|WM_LOG
operator|.
name|info
argument_list|(
literal|"At priority "
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|+
literal|" observing "
operator|+
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|TaskInfo
argument_list|>
name|atPriorityIter
init|=
name|newValue
condition|?
name|atPriority
operator|.
name|iterator
argument_list|()
else|:
name|atPriority
operator|.
name|descendingIterator
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|TreeSet
argument_list|<
name|TaskInfo
argument_list|>
argument_list|>
name|toMap
init|=
name|newValue
condition|?
name|guaranteedTasks
else|:
name|speculativeTasks
decl_stmt|,
name|fromMap
init|=
name|newValue
condition|?
name|speculativeTasks
else|:
name|guaranteedTasks
decl_stmt|;
while|while
condition|(
name|atPriorityIter
operator|.
name|hasNext
argument_list|()
operator|&&
name|remainingCount
operator|>
literal|0
condition|)
block|{
name|TaskInfo
name|taskInfo
init|=
name|atPriorityIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|taskInfo
operator|==
name|failedUpdate
condition|)
continue|continue;
name|atPriorityIter
operator|.
name|remove
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|taskInfo
init|)
block|{
assert|assert
name|taskInfo
operator|.
name|isGuaranteed
operator|!=
name|newValue
assert|;
name|taskInfo
operator|.
name|isGuaranteed
operator|=
name|newValue
expr_stmt|;
comment|// When we introduce a discrepancy to the state we give the task to an updater unless it
comment|// was already given to one.  If the updater is already doing stuff, it would handle the
comment|// changed state when it's done with whatever it's doing. The updater is not going to
comment|// give up until the discrepancies are eliminated.
if|if
condition|(
operator|!
name|taskInfo
operator|.
name|isPendingUpdate
condition|)
block|{
name|setUpdateStartedUnderTiLock
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
name|WM_LOG
operator|.
name|info
argument_list|(
literal|"Adding "
operator|+
name|taskInfo
operator|.
name|attemptId
operator|+
literal|" to update"
argument_list|)
expr_stmt|;
name|toUpdate
operator|.
name|add
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WM_LOG
operator|.
name|info
argument_list|(
literal|"Not adding "
operator|+
name|taskInfo
operator|.
name|attemptId
operator|+
literal|" to update - already pending"
argument_list|)
expr_stmt|;
block|}
block|}
name|addToRunningTasksMap
argument_list|(
name|toMap
argument_list|,
name|taskInfo
argument_list|)
expr_stmt|;
operator|--
name|remainingCount
expr_stmt|;
block|}
comment|// Remove entire priority level if it's been emptied.
comment|// We do this before checking failedUpdate because that might break the iterator.
if|if
condition|(
name|atPriority
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
comment|// We include failedUpdate only after looking at all the tasks at the same priority.
if|if
condition|(
name|failedUpdate
operator|!=
literal|null
operator|&&
name|entry
operator|.
name|getKey
argument_list|()
operator|==
name|failedUpdate
operator|.
name|priority
operator|.
name|getPriority
argument_list|()
operator|&&
name|remainingCount
operator|>
literal|0
condition|)
block|{
comment|// This will break the iterator. However, this is the last task we can add the way this currently
comment|// runs (only one duck is distributed when failedUpdate is present), so that should be ok.
name|removeFromRunningTaskMap
argument_list|(
name|fromMap
argument_list|,
name|failedUpdate
operator|.
name|task
argument_list|,
name|failedUpdate
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|failedUpdate
init|)
block|{
assert|assert
name|failedUpdate
operator|.
name|isGuaranteed
operator|!=
name|newValue
assert|;
name|failedUpdate
operator|.
name|isGuaranteed
operator|=
name|newValue
expr_stmt|;
name|setUpdateStartedUnderTiLock
argument_list|(
name|failedUpdate
argument_list|)
expr_stmt|;
block|}
name|WM_LOG
operator|.
name|info
argument_list|(
literal|"Adding failed "
operator|+
name|failedUpdate
operator|.
name|attemptId
operator|+
literal|" to update"
argument_list|)
expr_stmt|;
comment|// Do not check the state - this is coming from the updater under epic lock.
name|toUpdate
operator|.
name|add
argument_list|(
name|failedUpdate
argument_list|)
expr_stmt|;
name|addToRunningTasksMap
argument_list|(
name|toMap
argument_list|,
name|failedUpdate
argument_list|)
expr_stmt|;
operator|--
name|remainingCount
expr_stmt|;
block|}
return|return
name|remainingCount
return|;
block|}
specifier|private
name|void
name|registerPendingPreemption
parameter_list|(
name|String
name|host
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|pendingPreemptions
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrPendingPreemptionTasksCount
argument_list|()
expr_stmt|;
block|}
name|MutableInt
name|val
init|=
name|pendingPreemptionsPerHost
operator|.
name|get
argument_list|(
name|host
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
name|val
operator|=
operator|new
name|MutableInt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pendingPreemptionsPerHost
operator|.
name|put
argument_list|(
name|host
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|val
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|unregisterPendingPreemption
parameter_list|(
name|String
name|host
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|pendingPreemptions
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|decrPendingPreemptionTasksCount
argument_list|()
expr_stmt|;
block|}
name|MutableInt
name|val
init|=
name|pendingPreemptionsPerHost
operator|.
name|get
argument_list|(
name|host
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|.
name|decrement
argument_list|()
expr_stmt|;
comment|// Not bothering with removing the entry. There's a limited number of hosts, and a good
comment|// chance that the entry will make it back in when the AM is used for a long duration.
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|maybeAddToDelayedTaskQueue
parameter_list|(
name|TaskInfo
name|taskInfo
parameter_list|)
block|{
comment|// There's no point adding a task with forceLocality set - since that will never exit the queue.
comment|// Add other tasks if they are not already in the queue.
if|if
condition|(
operator|!
name|taskInfo
operator|.
name|shouldForceLocality
argument_list|()
operator|&&
operator|!
name|taskInfo
operator|.
name|isInDelayedQueue
argument_list|()
condition|)
block|{
name|taskInfo
operator|.
name|setInDelayedQueue
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|delayedTaskQueue
operator|.
name|add
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ------ Inner classes defined after this point ------
annotation|@
name|VisibleForTesting
class|class
name|DelayedTaskSchedulerCallable
implements|implements
name|Callable
argument_list|<
name|Void
argument_list|>
block|{
specifier|private
specifier|final
name|AtomicBoolean
name|isShutdown
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
block|{
while|while
condition|(
operator|!
name|isShutdown
operator|.
name|get
argument_list|()
operator|&&
operator|!
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
try|try
block|{
name|TaskInfo
name|taskInfo
init|=
name|getNextTask
argument_list|()
decl_stmt|;
name|taskInfo
operator|.
name|setInDelayedQueue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Tasks can exist in the delayed queue even after they have been scheduled.
comment|// Trigger scheduling only if the task is still in PENDING state.
name|processEvictedTask
argument_list|(
name|taskInfo
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isShutdown
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"DelayedTaskScheduler thread interrupted after shutdown"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"DelayedTaskScheduler thread interrupted before being shutdown"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"DelayedTaskScheduler thread interrupted without being shutdown"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|isShutdown
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
name|TaskInfo
name|getNextTask
parameter_list|()
throws|throws
name|InterruptedException
block|{
return|return
name|delayedTaskQueue
operator|.
name|take
argument_list|()
return|;
block|}
specifier|public
name|void
name|processEvictedTask
parameter_list|(
name|TaskInfo
name|taskInfo
parameter_list|)
block|{
if|if
condition|(
name|shouldScheduleTask
argument_list|(
name|taskInfo
argument_list|)
condition|)
block|{
name|trySchedulingPendingTasks
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|shouldScheduleTask
parameter_list|(
name|TaskInfo
name|taskInfo
parameter_list|)
block|{
return|return
name|taskInfo
operator|.
name|getState
argument_list|()
operator|==
name|TaskInfo
operator|.
name|State
operator|.
name|PENDING
return|;
block|}
block|}
annotation|@
name|VisibleForTesting
name|DelayedTaskSchedulerCallable
name|createDelayedTaskSchedulerCallable
parameter_list|()
block|{
return|return
operator|new
name|DelayedTaskSchedulerCallable
argument_list|()
return|;
block|}
specifier|private
class|class
name|NodeEnablerCallable
implements|implements
name|Callable
argument_list|<
name|Void
argument_list|>
block|{
specifier|private
specifier|final
name|AtomicBoolean
name|isShutdown
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|POLL_TIMEOUT
init|=
literal|10000L
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
block|{
while|while
condition|(
operator|!
name|isShutdown
operator|.
name|get
argument_list|()
operator|&&
operator|!
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
try|try
block|{
name|NodeInfo
name|nodeInfo
init|=
name|disabledNodesQueue
operator|.
name|poll
argument_list|(
name|POLL_TIMEOUT
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeInfo
operator|!=
literal|null
condition|)
block|{
comment|// A node became available. Enable the node and try scheduling.
name|reenableDisabledNode
argument_list|(
name|nodeInfo
argument_list|)
expr_stmt|;
name|trySchedulingPendingTasks
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isShutdown
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"NodeEnabler thread interrupted after shutdown"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"NodeEnabler thread interrupted without being shutdown"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"NodeEnabler thread interrupted without being shutdown"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|// Call this first, then send in an interrupt to the thread.
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|isShutdown
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|trySchedulingPendingTasks
parameter_list|()
block|{
name|scheduleLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|pendingScheduleInvocations
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|scheduleCondition
operator|.
name|signal
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|scheduleLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
class|class
name|SchedulerTimeoutMonitor
implements|implements
name|Runnable
block|{
specifier|private
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SchedulerTimeoutMonitor
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Reporting SERVICE_UNAVAILABLE error as no instances are running"
argument_list|)
expr_stmt|;
try|try
block|{
name|getContext
argument_list|()
operator|.
name|reportError
argument_list|(
name|ServicePluginErrorDefaults
operator|.
name|SERVICE_UNAVAILABLE
argument_list|,
literal|"No LLAP Daemons are running"
argument_list|,
name|getContext
argument_list|()
operator|.
name|getCurrentDagInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|DagInfo
name|currentDagInfo
init|=
name|getContext
argument_list|()
operator|.
name|getCurrentDagInfo
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception when reporting SERVICE_UNAVAILABLE error for dag: {}"
argument_list|,
name|currentDagInfo
operator|==
literal|null
condition|?
literal|""
else|:
name|currentDagInfo
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
class|class
name|SchedulerCallable
implements|implements
name|Callable
argument_list|<
name|Void
argument_list|>
block|{
specifier|private
name|AtomicBoolean
name|isShutdown
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|Exception
block|{
while|while
condition|(
operator|!
name|isShutdown
operator|.
name|get
argument_list|()
operator|&&
operator|!
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
name|scheduleLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
while|while
condition|(
operator|!
name|pendingScheduleInvocations
operator|.
name|get
argument_list|()
condition|)
block|{
name|scheduleCondition
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isShutdown
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Scheduler thread interrupted after shutdown"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Scheduler thread interrupted without being shutdown"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Scheduler thread interrupted without being shutdown"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|scheduleLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// Set pending to false since scheduling is about to run. Any triggers up to this point
comment|// will be handled in the next run.
comment|// A new request may come in right after this is set to false, but before the actual scheduling.
comment|// This will be handled in this run, but will cause an immediate run after, which is harmless.
comment|// This is mainly to handle a trySchedue request while in the middle of a run - since the event
comment|// which triggered it may not be processed for all tasks in the run.
name|pendingScheduleInvocations
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Schedule outside of the scheduleLock - which should only be used to wait on the condition.
try|try
block|{
name|schedulePendingTasks
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
if|if
condition|(
name|isShutdown
operator|.
name|get
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
comment|// We are good.
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Scheduler thread was interrupte without shutdown and will now exit"
argument_list|,
name|ie
argument_list|)
expr_stmt|;
throw|throw
name|ie
throw|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// TODO: we might as well kill the AM at this point. How do we do that from here?
name|LOG
operator|.
name|error
argument_list|(
literal|"Fatal error: scheduler thread has failed and will now exit"
argument_list|,
name|t
argument_list|)
expr_stmt|;
throw|throw
operator|(
name|t
operator|instanceof
name|Exception
operator|)
condition|?
operator|(
name|Exception
operator|)
name|t
else|:
operator|new
name|Exception
argument_list|(
name|t
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|// Call this first, then send in an interrupt to the thread.
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|isShutdown
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ------ Additional static classes defined after this point ------
annotation|@
name|VisibleForTesting
specifier|static
class|class
name|NodeInfo
implements|implements
name|Delayed
block|{
specifier|private
specifier|final
name|NodeBlacklistConf
name|blacklistConf
decl_stmt|;
specifier|final
name|LlapServiceInstance
name|serviceInstance
decl_stmt|;
specifier|private
specifier|final
name|Clock
name|clock
decl_stmt|;
name|long
name|expireTimeMillis
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|long
name|numSuccessfulTasks
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|numSuccessfulTasksAtLastBlacklist
init|=
operator|-
literal|1
decl_stmt|;
name|float
name|cumulativeBackoffFactor
init|=
literal|1.0f
decl_stmt|;
comment|// Indicates whether a node had a recent communication failure.
comment|// This is primarily for tracking and logging purposes for the moment.
comment|// TODO At some point, treat task rejection and communication failures differently.
specifier|private
name|boolean
name|hadCommFailure
init|=
literal|false
decl_stmt|;
comment|// Indicates whether a node is disabled - for whatever reason - commFailure, busy, etc.
specifier|private
name|boolean
name|disabled
init|=
literal|false
decl_stmt|;
specifier|private
name|int
name|numPreemptedTasks
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|numScheduledTasks
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|int
name|numSchedulableTasks
decl_stmt|;
specifier|private
specifier|final
name|LlapTaskSchedulerMetrics
name|metrics
decl_stmt|;
specifier|private
specifier|final
name|Resource
name|resourcePerExecutor
decl_stmt|;
specifier|private
specifier|final
name|String
name|shortStringBase
decl_stmt|;
comment|/**      * Create a NodeInfo bound to a service instance      *  @param serviceInstance         the associated serviceInstance      * @param blacklistConf           blacklist configuration      * @param clock                   clock to use to obtain timing information      * @param numSchedulableTasksConf number of schedulable tasks on the node. 0 represents auto *                                detect based on the serviceInstance, -1 indicates indicates      * @param metrics      */
name|NodeInfo
parameter_list|(
name|LlapServiceInstance
name|serviceInstance
parameter_list|,
name|NodeBlacklistConf
name|blacklistConf
parameter_list|,
name|Clock
name|clock
parameter_list|,
name|int
name|numSchedulableTasksConf
parameter_list|,
specifier|final
name|LlapTaskSchedulerMetrics
name|metrics
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|numSchedulableTasksConf
operator|>=
operator|-
literal|1
argument_list|,
literal|"NumSchedulableTasks must be>=-1"
argument_list|)
expr_stmt|;
name|this
operator|.
name|serviceInstance
operator|=
name|serviceInstance
expr_stmt|;
name|this
operator|.
name|blacklistConf
operator|=
name|blacklistConf
expr_stmt|;
name|this
operator|.
name|clock
operator|=
name|clock
expr_stmt|;
name|this
operator|.
name|metrics
operator|=
name|metrics
expr_stmt|;
name|int
name|numVcores
init|=
name|serviceInstance
operator|.
name|getResource
argument_list|()
operator|.
name|getVirtualCores
argument_list|()
decl_stmt|;
name|int
name|memoryPerInstance
init|=
name|serviceInstance
operator|.
name|getResource
argument_list|()
operator|.
name|getMemory
argument_list|()
decl_stmt|;
name|int
name|memoryPerExecutor
init|=
call|(
name|int
call|)
argument_list|(
name|memoryPerInstance
operator|/
operator|(
name|double
operator|)
name|numVcores
argument_list|)
decl_stmt|;
name|resourcePerExecutor
operator|=
name|Resource
operator|.
name|newInstance
argument_list|(
name|memoryPerExecutor
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|numSchedulableTasksConf
operator|==
literal|0
condition|)
block|{
name|int
name|pendingQueueuCapacity
init|=
literal|0
decl_stmt|;
name|String
name|pendingQueueCapacityString
init|=
name|serviceInstance
operator|.
name|getProperties
argument_list|()
operator|.
name|get
argument_list|(
name|ConfVars
operator|.
name|LLAP_DAEMON_TASK_SCHEDULER_WAIT_QUEUE_SIZE
operator|.
name|varname
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Setting up node: {} with available capacity={}, pendingQueueSize={}, memory={}"
argument_list|,
name|serviceInstance
argument_list|,
name|serviceInstance
operator|.
name|getResource
argument_list|()
operator|.
name|getVirtualCores
argument_list|()
argument_list|,
name|pendingQueueCapacityString
argument_list|,
name|serviceInstance
operator|.
name|getResource
argument_list|()
operator|.
name|getMemory
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pendingQueueCapacityString
operator|!=
literal|null
condition|)
block|{
name|pendingQueueuCapacity
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|pendingQueueCapacityString
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|numSchedulableTasks
operator|=
name|numVcores
operator|+
name|pendingQueueuCapacity
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|numSchedulableTasks
operator|=
name|numSchedulableTasksConf
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Setting up node: "
operator|+
name|serviceInstance
operator|+
literal|" with schedulableCapacity="
operator|+
name|this
operator|.
name|numSchedulableTasks
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrSchedulableTasksCount
argument_list|(
name|numSchedulableTasks
argument_list|)
expr_stmt|;
block|}
name|shortStringBase
operator|=
name|setupShortStringBase
argument_list|()
expr_stmt|;
block|}
name|String
name|getNodeIdentity
parameter_list|()
block|{
return|return
name|serviceInstance
operator|.
name|getWorkerIdentity
argument_list|()
return|;
block|}
name|String
name|getHost
parameter_list|()
block|{
return|return
name|serviceInstance
operator|.
name|getHost
argument_list|()
return|;
block|}
name|int
name|getRpcPort
parameter_list|()
block|{
return|return
name|serviceInstance
operator|.
name|getRpcPort
argument_list|()
return|;
block|}
name|String
name|getServiceAddress
parameter_list|()
block|{
return|return
name|serviceInstance
operator|.
name|getServicesAddress
argument_list|()
return|;
block|}
specifier|public
name|Resource
name|getResourcePerExecutor
parameter_list|()
block|{
return|return
name|resourcePerExecutor
return|;
block|}
name|void
name|resetExpireInformation
parameter_list|()
block|{
name|expireTimeMillis
operator|=
operator|-
literal|1
expr_stmt|;
name|hadCommFailure
operator|=
literal|false
expr_stmt|;
block|}
name|void
name|enableNode
parameter_list|()
block|{
name|resetExpireInformation
argument_list|()
expr_stmt|;
name|disabled
operator|=
literal|false
expr_stmt|;
block|}
name|void
name|disableNode
parameter_list|(
name|boolean
name|commFailure
parameter_list|)
block|{
name|long
name|duration
init|=
name|blacklistConf
operator|.
name|minDelay
decl_stmt|;
name|long
name|currentTime
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|this
operator|.
name|hadCommFailure
operator|=
name|commFailure
expr_stmt|;
name|disabled
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|numSuccessfulTasksAtLastBlacklist
operator|==
name|numSuccessfulTasks
condition|)
block|{
comment|// Relying on a task succeeding to reset the exponent.
comment|// There's no notifications on whether a task gets accepted or not. That would be ideal to
comment|// reset this.
name|cumulativeBackoffFactor
operator|=
name|cumulativeBackoffFactor
operator|*
name|blacklistConf
operator|.
name|backoffFactor
expr_stmt|;
block|}
else|else
block|{
comment|// Was able to execute something before the last blacklist. Reset the exponent.
name|cumulativeBackoffFactor
operator|=
literal|1.0f
expr_stmt|;
block|}
name|long
name|delayTime
init|=
call|(
name|long
call|)
argument_list|(
name|duration
operator|*
name|cumulativeBackoffFactor
argument_list|)
decl_stmt|;
if|if
condition|(
name|delayTime
operator|>
name|blacklistConf
operator|.
name|maxDelay
condition|)
block|{
name|delayTime
operator|=
name|blacklistConf
operator|.
name|maxDelay
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Disabling instance {} for {} milli-seconds. commFailure={}"
argument_list|,
name|toShortString
argument_list|()
argument_list|,
name|delayTime
argument_list|,
name|commFailure
argument_list|)
expr_stmt|;
block|}
name|expireTimeMillis
operator|=
name|currentTime
operator|+
name|delayTime
expr_stmt|;
name|numSuccessfulTasksAtLastBlacklist
operator|=
name|numSuccessfulTasks
expr_stmt|;
block|}
name|void
name|registerTaskScheduled
parameter_list|()
block|{
name|numScheduledTasks
operator|++
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrRunningTasksCount
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|decrSchedulableTasksCount
argument_list|()
expr_stmt|;
block|}
block|}
name|void
name|registerTaskSuccess
parameter_list|()
block|{
name|numSuccessfulTasks
operator|++
expr_stmt|;
name|numScheduledTasks
operator|--
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrSuccessfulTasksCount
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|decrRunningTasksCount
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|incrSchedulableTasksCount
argument_list|()
expr_stmt|;
block|}
block|}
name|void
name|registerUnsuccessfulTaskEnd
parameter_list|(
name|boolean
name|wasPreempted
parameter_list|)
block|{
name|numScheduledTasks
operator|--
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|decrRunningTasksCount
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|incrSchedulableTasksCount
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|wasPreempted
condition|)
block|{
name|numPreemptedTasks
operator|++
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrPreemptedTasksCount
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * @return the time at which this node will be re-enabled      */
name|long
name|getEnableTime
parameter_list|()
block|{
return|return
name|expireTimeMillis
return|;
block|}
specifier|public
name|boolean
name|isDisabled
parameter_list|()
block|{
return|return
name|disabled
return|;
block|}
name|boolean
name|hadCommFailure
parameter_list|()
block|{
return|return
name|hadCommFailure
return|;
block|}
name|boolean
name|_canAccepInternal
parameter_list|()
block|{
return|return
operator|!
name|hadCommFailure
operator|&&
operator|!
name|disabled
operator|&&
operator|(
name|numSchedulableTasks
operator|==
operator|-
literal|1
operator|||
operator|(
operator|(
name|numSchedulableTasks
operator|-
name|numScheduledTasks
operator|)
operator|>
literal|0
operator|)
operator|)
return|;
block|}
name|int
name|canAcceptCounter
init|=
literal|0
decl_stmt|;
comment|/* Returning true does not guarantee that the task will run, considering other queries     may be running in the system. Also depends upon the capacity usage configuration      */
name|boolean
name|canAcceptTask
parameter_list|()
block|{
name|boolean
name|result
init|=
name|_canAccepInternal
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|constructCanAcceptLogResult
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|canAcceptCounter
operator|==
literal|10000
condition|)
block|{
name|canAcceptCounter
operator|++
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|constructCanAcceptLogResult
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|canAcceptCounter
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
name|String
name|constructCanAcceptLogResult
parameter_list|(
name|boolean
name|result
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Node["
argument_list|)
operator|.
name|append
argument_list|(
name|serviceInstance
operator|.
name|getHost
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
operator|.
name|append
argument_list|(
name|serviceInstance
operator|.
name|getRpcPort
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|serviceInstance
operator|.
name|getWorkerIdentity
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"]: "
argument_list|)
operator|.
name|append
argument_list|(
literal|"canAcceptTask="
argument_list|)
operator|.
name|append
argument_list|(
name|result
argument_list|)
operator|.
name|append
argument_list|(
literal|", numScheduledTasks="
argument_list|)
operator|.
name|append
argument_list|(
name|numScheduledTasks
argument_list|)
operator|.
name|append
argument_list|(
literal|", numSchedulableTasks="
argument_list|)
operator|.
name|append
argument_list|(
name|numSchedulableTasks
argument_list|)
operator|.
name|append
argument_list|(
literal|", hadCommFailure="
argument_list|)
operator|.
name|append
argument_list|(
name|hadCommFailure
argument_list|)
operator|.
name|append
argument_list|(
literal|", disabled="
argument_list|)
operator|.
name|append
argument_list|(
name|disabled
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getDelay
parameter_list|(
name|TimeUnit
name|unit
parameter_list|)
block|{
return|return
name|unit
operator|.
name|convert
argument_list|(
name|expireTimeMillis
operator|-
name|clock
operator|.
name|getTime
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
name|Delayed
name|o
parameter_list|)
block|{
name|NodeInfo
name|other
init|=
operator|(
name|NodeInfo
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|other
operator|.
name|expireTimeMillis
operator|>
name|this
operator|.
name|expireTimeMillis
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|other
operator|.
name|expireTimeMillis
operator|<
name|this
operator|.
name|expireTimeMillis
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
specifier|private
name|String
name|setupShortStringBase
parameter_list|()
block|{
return|return
literal|"{"
operator|+
name|serviceInstance
operator|.
name|getHost
argument_list|()
operator|+
literal|":"
operator|+
name|serviceInstance
operator|.
name|getRpcPort
argument_list|()
operator|+
literal|", id="
operator|+
name|getNodeIdentity
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"NodeInfo{"
operator|+
literal|"instance="
operator|+
name|serviceInstance
operator|+
literal|", expireTimeMillis="
operator|+
name|expireTimeMillis
operator|+
literal|", numSuccessfulTasks="
operator|+
name|numSuccessfulTasks
operator|+
literal|", numSuccessfulTasksAtLastBlacklist="
operator|+
name|numSuccessfulTasksAtLastBlacklist
operator|+
literal|", cumulativeBackoffFactor="
operator|+
name|cumulativeBackoffFactor
operator|+
literal|", numSchedulableTasks="
operator|+
name|numSchedulableTasks
operator|+
literal|", numScheduledTasks="
operator|+
name|numScheduledTasks
operator|+
literal|", disabled="
operator|+
name|disabled
operator|+
literal|", commFailures="
operator|+
name|hadCommFailure
operator|+
literal|'}'
return|;
block|}
specifier|private
name|String
name|toShortString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", canAcceptTask="
argument_list|)
operator|.
name|append
argument_list|(
name|_canAccepInternal
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", st="
argument_list|)
operator|.
name|append
argument_list|(
name|numScheduledTasks
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", ac="
argument_list|)
operator|.
name|append
argument_list|(
operator|(
name|numSchedulableTasks
operator|-
name|numScheduledTasks
operator|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", commF="
argument_list|)
operator|.
name|append
argument_list|(
name|hadCommFailure
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", disabled="
argument_list|)
operator|.
name|append
argument_list|(
name|disabled
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
return|return
name|shortStringBase
operator|+
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|static
class|class
name|StatsPerDag
block|{
name|int
name|numRequestedAllocations
init|=
literal|0
decl_stmt|;
name|int
name|numRequestsWithLocation
init|=
literal|0
decl_stmt|;
name|int
name|numRequestsWithoutLocation
init|=
literal|0
decl_stmt|;
name|int
name|numTotalAllocations
init|=
literal|0
decl_stmt|;
name|int
name|numLocalAllocations
init|=
literal|0
decl_stmt|;
name|int
name|numNonLocalAllocations
init|=
literal|0
decl_stmt|;
name|int
name|numAllocationsNoLocalityRequest
init|=
literal|0
decl_stmt|;
name|int
name|numRejectedTasks
init|=
literal|0
decl_stmt|;
name|int
name|numCommFailures
init|=
literal|0
decl_stmt|;
name|int
name|numDelayedAllocations
init|=
literal|0
decl_stmt|;
name|int
name|numPreemptedTasks
init|=
literal|0
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
name|localityBasedNumAllocationsPerHost
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
name|numAllocationsPerHost
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumPreemptedTasks="
argument_list|)
operator|.
name|append
argument_list|(
name|numPreemptedTasks
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumRequestedAllocations="
argument_list|)
operator|.
name|append
argument_list|(
name|numRequestedAllocations
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumRequestsWithlocation="
argument_list|)
operator|.
name|append
argument_list|(
name|numRequestsWithLocation
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumLocalAllocations="
argument_list|)
operator|.
name|append
argument_list|(
name|numLocalAllocations
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumNonLocalAllocations="
argument_list|)
operator|.
name|append
argument_list|(
name|numNonLocalAllocations
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumTotalAllocations="
argument_list|)
operator|.
name|append
argument_list|(
name|numTotalAllocations
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumRequestsWithoutLocation="
argument_list|)
operator|.
name|append
argument_list|(
name|numRequestsWithoutLocation
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumRejectedTasks="
argument_list|)
operator|.
name|append
argument_list|(
name|numRejectedTasks
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumCommFailures="
argument_list|)
operator|.
name|append
argument_list|(
name|numCommFailures
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumDelayedAllocations="
argument_list|)
operator|.
name|append
argument_list|(
name|numDelayedAllocations
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"LocalityBasedAllocationsPerHost="
argument_list|)
operator|.
name|append
argument_list|(
name|localityBasedNumAllocationsPerHost
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"NumAllocationsPerHost="
argument_list|)
operator|.
name|append
argument_list|(
name|numAllocationsPerHost
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
name|void
name|registerTaskRequest
parameter_list|(
name|String
index|[]
name|requestedHosts
parameter_list|,
name|String
index|[]
name|requestedRacks
parameter_list|)
block|{
name|numRequestedAllocations
operator|++
expr_stmt|;
comment|// TODO Change after HIVE-9987. For now, there's no rack matching.
if|if
condition|(
name|requestedHosts
operator|!=
literal|null
operator|&&
name|requestedHosts
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|numRequestsWithLocation
operator|++
expr_stmt|;
block|}
else|else
block|{
name|numRequestsWithoutLocation
operator|++
expr_stmt|;
block|}
block|}
name|void
name|registerTaskAllocated
parameter_list|(
name|String
index|[]
name|requestedHosts
parameter_list|,
name|String
index|[]
name|requestedRacks
parameter_list|,
name|String
name|allocatedHost
parameter_list|)
block|{
comment|// TODO Change after HIVE-9987. For now, there's no rack matching.
if|if
condition|(
name|requestedHosts
operator|!=
literal|null
operator|&&
name|requestedHosts
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|requestedHostSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|requestedHosts
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|requestedHostSet
operator|.
name|contains
argument_list|(
name|allocatedHost
argument_list|)
condition|)
block|{
name|numLocalAllocations
operator|++
expr_stmt|;
name|_registerAllocationInHostMap
argument_list|(
name|allocatedHost
argument_list|,
name|localityBasedNumAllocationsPerHost
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|numNonLocalAllocations
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|numAllocationsNoLocalityRequest
operator|++
expr_stmt|;
block|}
name|numTotalAllocations
operator|++
expr_stmt|;
name|_registerAllocationInHostMap
argument_list|(
name|allocatedHost
argument_list|,
name|numAllocationsPerHost
argument_list|)
expr_stmt|;
block|}
comment|// TODO Track stats of rejections etc per host
name|void
name|registerTaskPreempted
parameter_list|(
name|String
name|host
parameter_list|)
block|{
name|numPreemptedTasks
operator|++
expr_stmt|;
block|}
name|void
name|registerCommFailure
parameter_list|(
name|String
name|host
parameter_list|)
block|{
name|numCommFailures
operator|++
expr_stmt|;
block|}
name|void
name|registerTaskRejected
parameter_list|(
name|String
name|host
parameter_list|)
block|{
name|numRejectedTasks
operator|++
expr_stmt|;
block|}
name|void
name|registerDelayedAllocation
parameter_list|()
block|{
name|numDelayedAllocations
operator|++
expr_stmt|;
block|}
specifier|private
name|void
name|_registerAllocationInHostMap
parameter_list|(
name|String
name|host
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
name|hostMap
parameter_list|)
block|{
name|AtomicInteger
name|val
init|=
name|hostMap
operator|.
name|get
argument_list|(
name|host
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
name|val
operator|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hostMap
operator|.
name|put
argument_list|(
name|host
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|val
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
comment|// TODO There needs to be a mechanism to figure out different attempts for the same task. Delays
comment|// could potentially be changed based on this.
annotation|@
name|VisibleForTesting
specifier|static
class|class
name|TaskInfo
implements|implements
name|Delayed
block|{
enum|enum
name|State
block|{
name|PENDING
block|,
name|ASSIGNED
block|,
name|PREEMPTED
block|}
comment|// IDs used to ensure two TaskInfos are different without using the underlying task instance.
comment|// Required for insertion into a TreeMap
specifier|static
specifier|final
name|AtomicLong
name|ID_GEN
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|long
name|uniqueId
decl_stmt|;
specifier|final
name|LocalityDelayConf
name|localityDelayConf
decl_stmt|;
specifier|final
name|Clock
name|clock
decl_stmt|;
specifier|final
name|Object
name|task
decl_stmt|;
specifier|final
name|Object
name|clientCookie
decl_stmt|;
specifier|final
name|Priority
name|priority
decl_stmt|;
specifier|final
name|Resource
name|capability
decl_stmt|;
specifier|final
name|String
index|[]
name|requestedHosts
decl_stmt|;
specifier|final
name|String
index|[]
name|requestedRacks
decl_stmt|;
specifier|final
name|long
name|requestTime
decl_stmt|;
specifier|final
name|long
name|localityDelayTimeout
decl_stmt|;
name|long
name|startTime
decl_stmt|;
name|long
name|preemptTime
decl_stmt|;
name|ContainerId
name|containerId
decl_stmt|;
name|NodeInfo
name|assignedNode
decl_stmt|;
specifier|private
name|State
name|state
init|=
name|State
operator|.
name|PENDING
decl_stmt|;
name|boolean
name|inDelayedQueue
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|TezTaskAttemptID
name|attemptId
decl_stmt|;
comment|// The state for guaranteed task tracking. Synchronized on 'this'.
comment|// In addition, "isGuaranteed" is only modified under the epic lock (because it involves
comment|// modifying the corresponding structures that contain the task objects, at the same time).
comment|/** Local state in the AM; true/false are what they say, null means terminated and irrelevant. */
specifier|private
name|Boolean
name|isGuaranteed
init|=
literal|false
decl_stmt|;
comment|/** The last state positively propagated to the task. Set by the updater. */
specifier|private
name|Boolean
name|lastSetGuaranteed
init|=
literal|null
decl_stmt|;
specifier|private
name|Boolean
name|requestedValue
init|=
literal|null
decl_stmt|;
comment|/** Whether there's an update in progress for this TaskInfo. */
specifier|private
name|boolean
name|isPendingUpdate
init|=
literal|false
decl_stmt|;
specifier|private
name|int
name|numAssignAttempts
init|=
literal|0
decl_stmt|;
comment|// TaskInfo instances for two different tasks will not be the same. Only a single instance should
comment|// ever be created for a taskAttempt
specifier|public
name|TaskInfo
parameter_list|(
name|LocalityDelayConf
name|localityDelayConf
parameter_list|,
name|Clock
name|clock
parameter_list|,
name|Object
name|task
parameter_list|,
name|Object
name|clientCookie
parameter_list|,
name|Priority
name|priority
parameter_list|,
name|Resource
name|capability
parameter_list|,
name|String
index|[]
name|hosts
parameter_list|,
name|String
index|[]
name|racks
parameter_list|,
name|long
name|requestTime
parameter_list|,
name|TezTaskAttemptID
name|id
parameter_list|)
block|{
name|this
operator|.
name|localityDelayConf
operator|=
name|localityDelayConf
expr_stmt|;
name|this
operator|.
name|clock
operator|=
name|clock
expr_stmt|;
name|this
operator|.
name|task
operator|=
name|task
expr_stmt|;
name|this
operator|.
name|clientCookie
operator|=
name|clientCookie
expr_stmt|;
name|this
operator|.
name|priority
operator|=
name|priority
expr_stmt|;
name|this
operator|.
name|capability
operator|=
name|capability
expr_stmt|;
name|this
operator|.
name|requestedHosts
operator|=
name|hosts
expr_stmt|;
name|this
operator|.
name|requestedRacks
operator|=
name|racks
expr_stmt|;
name|this
operator|.
name|requestTime
operator|=
name|requestTime
expr_stmt|;
if|if
condition|(
name|localityDelayConf
operator|.
name|getNodeLocalityDelay
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|localityDelayTimeout
operator|=
name|Long
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|localityDelayConf
operator|.
name|getNodeLocalityDelay
argument_list|()
operator|==
literal|0
condition|)
block|{
name|localityDelayTimeout
operator|=
literal|0L
expr_stmt|;
block|}
else|else
block|{
name|localityDelayTimeout
operator|=
name|requestTime
operator|+
name|localityDelayConf
operator|.
name|getNodeLocalityDelay
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|uniqueId
operator|=
name|ID_GEN
operator|.
name|getAndIncrement
argument_list|()
expr_stmt|;
name|this
operator|.
name|attemptId
operator|=
name|id
expr_stmt|;
block|}
comment|// TODO: these appear to always be called under write lock. Do they need sync?
specifier|synchronized
name|void
name|setAssignmentInfo
parameter_list|(
name|NodeInfo
name|nodeInfo
parameter_list|,
name|ContainerId
name|containerId
parameter_list|,
name|long
name|startTime
parameter_list|)
block|{
name|this
operator|.
name|assignedNode
operator|=
name|nodeInfo
expr_stmt|;
name|this
operator|.
name|containerId
operator|=
name|containerId
expr_stmt|;
name|this
operator|.
name|startTime
operator|=
name|startTime
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|State
operator|.
name|ASSIGNED
expr_stmt|;
block|}
specifier|synchronized
name|void
name|setPreemptedInfo
parameter_list|(
name|long
name|preemptTime
parameter_list|)
block|{
name|this
operator|.
name|state
operator|=
name|State
operator|.
name|PREEMPTED
expr_stmt|;
name|this
operator|.
name|preemptTime
operator|=
name|preemptTime
expr_stmt|;
block|}
specifier|synchronized
name|void
name|setInDelayedQueue
parameter_list|(
name|boolean
name|val
parameter_list|)
block|{
name|this
operator|.
name|inDelayedQueue
operator|=
name|val
expr_stmt|;
block|}
specifier|synchronized
name|void
name|triedAssigningTask
parameter_list|()
block|{
name|numAssignAttempts
operator|++
expr_stmt|;
block|}
specifier|synchronized
name|int
name|getNumPreviousAssignAttempts
parameter_list|()
block|{
return|return
name|numAssignAttempts
return|;
block|}
specifier|synchronized
name|State
name|getState
parameter_list|()
block|{
return|return
name|state
return|;
block|}
specifier|synchronized
name|boolean
name|isInDelayedQueue
parameter_list|()
block|{
return|return
name|inDelayedQueue
return|;
block|}
name|boolean
name|shouldDelayForLocality
parameter_list|(
name|long
name|schedulerAttemptTime
parameter_list|)
block|{
comment|// getDelay<=0 means the task will be evicted from the queue.
return|return
name|localityDelayTimeout
operator|>
name|schedulerAttemptTime
return|;
block|}
name|boolean
name|shouldForceLocality
parameter_list|()
block|{
return|return
name|localityDelayTimeout
operator|==
name|Long
operator|.
name|MAX_VALUE
return|;
block|}
name|long
name|getLocalityDelayTimeout
parameter_list|()
block|{
return|return
name|localityDelayTimeout
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|TaskInfo
name|taskInfo
init|=
operator|(
name|TaskInfo
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|uniqueId
operator|!=
name|taskInfo
operator|.
name|uniqueId
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|task
operator|.
name|equals
argument_list|(
name|taskInfo
operator|.
name|task
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|result
init|=
call|(
name|int
call|)
argument_list|(
name|uniqueId
operator|^
operator|(
name|uniqueId
operator|>>>
literal|32
operator|)
argument_list|)
decl_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
name|task
operator|.
name|hashCode
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"TaskInfo{"
operator|+
literal|"task="
operator|+
name|task
operator|+
literal|", priority="
operator|+
name|priority
operator|+
literal|", startTime="
operator|+
name|startTime
operator|+
literal|", containerId="
operator|+
name|containerId
operator|+
operator|(
name|assignedNode
operator|!=
literal|null
condition|?
literal|"assignedNode="
operator|+
name|assignedNode
operator|.
name|toShortString
argument_list|()
else|:
literal|""
operator|)
operator|+
literal|", uniqueId="
operator|+
name|uniqueId
operator|+
literal|", localityDelayTimeout="
operator|+
name|localityDelayTimeout
operator|+
literal|'}'
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getDelay
parameter_list|(
name|TimeUnit
name|unit
parameter_list|)
block|{
return|return
name|unit
operator|.
name|convert
argument_list|(
name|localityDelayTimeout
operator|-
name|clock
operator|.
name|getTime
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
name|Delayed
name|o
parameter_list|)
block|{
name|TaskInfo
name|other
init|=
operator|(
name|TaskInfo
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|other
operator|.
name|localityDelayTimeout
operator|>
name|this
operator|.
name|localityDelayTimeout
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|other
operator|.
name|localityDelayTimeout
operator|<
name|this
operator|.
name|localityDelayTimeout
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
annotation|@
name|VisibleForTesting
name|boolean
name|isGuaranteed
parameter_list|()
block|{
return|return
name|isGuaranteed
return|;
block|}
annotation|@
name|VisibleForTesting
name|boolean
name|getLastSetGuaranteed
parameter_list|()
block|{
return|return
name|lastSetGuaranteed
return|;
block|}
annotation|@
name|VisibleForTesting
name|boolean
name|isUpdateInProgress
parameter_list|()
block|{
return|return
name|isPendingUpdate
return|;
block|}
name|TezTaskAttemptID
name|getAttemptId
parameter_list|()
block|{
return|return
name|attemptId
return|;
block|}
block|}
comment|// Newer tasks first.
specifier|private
specifier|static
class|class
name|TaskStartComparator
implements|implements
name|Comparator
argument_list|<
name|TaskInfo
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|TaskInfo
name|o1
parameter_list|,
name|TaskInfo
name|o2
parameter_list|)
block|{
if|if
condition|(
name|o1
operator|.
name|startTime
operator|>
name|o2
operator|.
name|startTime
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|o1
operator|.
name|startTime
operator|<
name|o2
operator|.
name|startTime
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
comment|// Comparing on time is not sufficient since two may be created at the same time,
comment|// in which case inserting into a TreeSet/Map would break
if|if
condition|(
name|o1
operator|.
name|uniqueId
operator|>
name|o2
operator|.
name|uniqueId
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|o1
operator|.
name|uniqueId
operator|<
name|o2
operator|.
name|uniqueId
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
specifier|private
specifier|static
class|class
name|SelectHostResult
block|{
specifier|final
name|NodeInfo
name|nodeInfo
decl_stmt|;
specifier|final
name|ScheduleResult
name|scheduleResult
decl_stmt|;
name|SelectHostResult
parameter_list|(
name|NodeInfo
name|nodeInfo
parameter_list|)
block|{
name|this
operator|.
name|nodeInfo
operator|=
name|nodeInfo
expr_stmt|;
name|this
operator|.
name|scheduleResult
operator|=
name|ScheduleResult
operator|.
name|SCHEDULED
expr_stmt|;
block|}
name|SelectHostResult
parameter_list|(
name|ScheduleResult
name|scheduleResult
parameter_list|)
block|{
name|this
operator|.
name|nodeInfo
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|scheduleResult
operator|=
name|scheduleResult
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|SelectHostResult
name|SELECT_HOST_RESULT_INADEQUATE_TOTAL_CAPACITY
init|=
operator|new
name|SelectHostResult
argument_list|(
name|ScheduleResult
operator|.
name|INADEQUATE_TOTAL_RESOURCES
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|SelectHostResult
name|SELECT_HOST_RESULT_DELAYED_LOCALITY
init|=
operator|new
name|SelectHostResult
argument_list|(
name|ScheduleResult
operator|.
name|DELAYED_LOCALITY
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|SelectHostResult
name|SELECT_HOST_RESULT_DELAYED_RESOURCES
init|=
operator|new
name|SelectHostResult
argument_list|(
name|ScheduleResult
operator|.
name|DELAYED_RESOURCES
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
class|class
name|NodeBlacklistConf
block|{
specifier|private
specifier|final
name|long
name|minDelay
decl_stmt|;
specifier|private
specifier|final
name|long
name|maxDelay
decl_stmt|;
specifier|private
specifier|final
name|float
name|backoffFactor
decl_stmt|;
specifier|public
name|NodeBlacklistConf
parameter_list|(
name|long
name|minDelay
parameter_list|,
name|long
name|maxDelay
parameter_list|,
name|float
name|backoffFactor
parameter_list|)
block|{
name|this
operator|.
name|minDelay
operator|=
name|minDelay
expr_stmt|;
name|this
operator|.
name|maxDelay
operator|=
name|maxDelay
expr_stmt|;
name|this
operator|.
name|backoffFactor
operator|=
name|backoffFactor
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"NodeBlacklistConf{"
operator|+
literal|"minDelay="
operator|+
name|minDelay
operator|+
literal|", maxDelay="
operator|+
name|maxDelay
operator|+
literal|", backoffFactor="
operator|+
name|backoffFactor
operator|+
literal|'}'
return|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|static
specifier|final
class|class
name|LocalityDelayConf
block|{
specifier|private
specifier|final
name|long
name|nodeLocalityDelay
decl_stmt|;
specifier|public
name|LocalityDelayConf
parameter_list|(
name|long
name|nodeLocalityDelay
parameter_list|)
block|{
name|this
operator|.
name|nodeLocalityDelay
operator|=
name|nodeLocalityDelay
expr_stmt|;
block|}
specifier|public
name|long
name|getNodeLocalityDelay
parameter_list|()
block|{
return|return
name|nodeLocalityDelay
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"LocalityDelayConf{"
operator|+
literal|"nodeLocalityDelay="
operator|+
name|nodeLocalityDelay
operator|+
literal|'}'
return|;
block|}
block|}
specifier|public
name|void
name|updateQuery
parameter_list|(
name|UpdateQueryRequestProto
name|request
parameter_list|)
block|{
if|if
condition|(
name|request
operator|.
name|hasGuaranteedTaskCount
argument_list|()
condition|)
block|{
name|updateGuaranteedCount
argument_list|(
name|request
operator|.
name|getGuaranteedTaskCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|setTaskCommunicator
parameter_list|(
name|LlapTaskCommunicator
name|communicator
parameter_list|)
block|{
name|this
operator|.
name|communicator
operator|=
name|communicator
expr_stmt|;
block|}
specifier|protected
name|void
name|sendUpdateMessageAsync
parameter_list|(
name|TaskInfo
name|ti
parameter_list|,
name|boolean
name|newState
parameter_list|)
block|{
name|WM_LOG
operator|.
name|info
argument_list|(
literal|"Sending message to "
operator|+
name|ti
operator|.
name|attemptId
operator|+
literal|": "
operator|+
name|newState
argument_list|)
expr_stmt|;
name|communicator
operator|.
name|startUpdateGuaranteed
argument_list|(
name|ti
operator|.
name|attemptId
argument_list|,
name|ti
operator|.
name|assignedNode
argument_list|,
name|newState
argument_list|,
name|UPDATE_CALLBACK
argument_list|,
name|ti
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
name|int
name|getUnusedGuaranteedCount
parameter_list|()
block|{
return|return
name|unusedGuaranteed
return|;
block|}
comment|/**    * A direct call from communicator to scheduler to propagate data that cannot be passed via Tez.    */
specifier|public
name|void
name|taskInfoUpdated
parameter_list|(
name|TezTaskAttemptID
name|attemptId
parameter_list|,
name|boolean
name|isGuaranteed
parameter_list|)
block|{
name|TaskInfo
name|ti
init|=
literal|null
decl_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|ti
operator|=
name|tasksById
operator|.
name|get
argument_list|(
name|attemptId
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|==
literal|null
condition|)
block|{
name|WM_LOG
operator|.
name|warn
argument_list|(
literal|"Unknown task from heartbeat "
operator|+
name|attemptId
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|boolean
name|newState
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|ti
init|)
block|{
if|if
condition|(
name|ti
operator|.
name|isPendingUpdate
condition|)
return|return;
comment|// A pending update is not done.
if|if
condition|(
name|ti
operator|.
name|isGuaranteed
operator|==
literal|null
condition|)
return|return;
comment|// The task has terminated, out of date heartbeat.
if|if
condition|(
name|ti
operator|.
name|lastSetGuaranteed
operator|!=
literal|null
operator|&&
name|ti
operator|.
name|lastSetGuaranteed
operator|==
name|isGuaranteed
condition|)
block|{
return|return;
comment|// The heartbeat is consistent with what we have.
block|}
name|ti
operator|.
name|lastSetGuaranteed
operator|=
name|isGuaranteed
expr_stmt|;
if|if
condition|(
name|isGuaranteed
operator|==
name|ti
operator|.
name|isGuaranteed
condition|)
return|return;
comment|// Already consistent. Can happen w/null lSG.
comment|// There could be races here, e.g. heartbeat delivered us the old value just after we have
comment|// received a successful confirmation from the API, so we are about to overwrite the latter.
comment|// We could solve this by adding a version or smth like that; or by ignoring discrepancies
comment|// unless we have previously received an update error for this task; however, the only effect
comment|// right now are a few cheap redundant update calls; let's just do the simple thing.
name|newState
operator|=
name|ti
operator|.
name|isGuaranteed
expr_stmt|;
name|setUpdateStartedUnderTiLock
argument_list|(
name|ti
argument_list|)
expr_stmt|;
block|}
comment|// End of synchronized (ti)
name|WM_LOG
operator|.
name|info
argument_list|(
literal|"Sending an update based on inconsistent state from heartbeat for "
operator|+
name|attemptId
operator|+
literal|", "
operator|+
name|newState
argument_list|)
expr_stmt|;
name|sendUpdateMessageAsync
argument_list|(
name|ti
argument_list|,
name|newState
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

