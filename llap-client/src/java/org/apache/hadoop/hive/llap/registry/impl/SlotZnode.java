begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**    * Licensed to the Apache Software Foundation (ASF) under one    * or more contributor license agreements.  See the NOTICE file    * distributed with this work for additional information    * regarding copyright ownership.  The ASF licenses this file    * to you under the Apache License, Version 2.0 (the    * "License"); you may not use this file except in compliance    * with the License.  You may obtain a copy of the License at    *    *   http://www.apache.org/licenses/LICENSE-2.0    *    * Unless required by applicable law or agreed to in writing,    * software distributed under the License is distributed on an    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY    * KIND, either express or implied.  See the License for the    * specific language governing permissions and limitations    * under the License.    */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|registry
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|CuratorFramework
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|api
operator|.
name|BackgroundCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|api
operator|.
name|CuratorEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|state
operator|.
name|ConnectionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|state
operator|.
name|ConnectionStateListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|CreateMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|WatchedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Watcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Watcher
operator|.
name|Event
operator|.
name|EventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_comment
comment|/**  * We would have used the curator ephemeral node with some extra logic but it doesn't handle  * the EXISTS condition, which is crucial here; so we c/p parts of Curator and add our logic.  */
end_comment

begin_class
specifier|public
class|class
name|SlotZnode
implements|implements
name|Closeable
block|{
specifier|static
specifier|final
name|Charset
name|CHARSET
init|=
name|StandardCharsets
operator|.
name|UTF_8
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SlotZnode
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|AtomicReference
argument_list|<
name|CountDownLatch
argument_list|>
name|initialCreateLatch
init|=
operator|new
name|AtomicReference
argument_list|<
name|CountDownLatch
argument_list|>
argument_list|(
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|AtomicReference
argument_list|<
name|String
argument_list|>
name|nodePath
init|=
operator|new
name|AtomicReference
argument_list|<
name|String
argument_list|>
argument_list|(
literal|null
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Random
name|rdm
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|CuratorFramework
name|client
decl_stmt|;
specifier|private
specifier|final
name|String
name|basePath
decl_stmt|,
name|prefix
decl_stmt|,
name|workerPrefix
decl_stmt|,
name|dataStr
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|data
decl_stmt|;
specifier|private
name|int
name|currentSlot
decl_stmt|;
specifier|private
specifier|final
name|AtomicReference
argument_list|<
name|State
argument_list|>
name|state
init|=
operator|new
name|AtomicReference
argument_list|<
name|State
argument_list|>
argument_list|(
name|State
operator|.
name|LATENT
argument_list|)
decl_stmt|;
specifier|private
name|int
name|fallbackCount
init|=
literal|0
decl_stmt|;
comment|// Test-only counter.
specifier|private
specifier|final
name|BackgroundCallback
name|backgroundCallback
init|=
operator|new
name|BackgroundCallback
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|processResult
parameter_list|(
name|CuratorFramework
name|client
parameter_list|,
name|CuratorEvent
name|event
parameter_list|)
throws|throws
name|Exception
block|{
name|processCreateResult
argument_list|(
name|client
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|final
name|Watcher
name|watcher
init|=
operator|new
name|Watcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|process
parameter_list|(
name|WatchedEvent
name|event
parameter_list|)
block|{
name|processWatchedEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|final
name|BackgroundCallback
name|checkExistsCallback
init|=
operator|new
name|BackgroundCallback
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|processResult
parameter_list|(
name|CuratorFramework
name|client
parameter_list|,
name|CuratorEvent
name|event
parameter_list|)
throws|throws
name|Exception
block|{
name|processWatchResult
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|final
name|ConnectionStateListener
name|connectionStateListener
init|=
operator|new
name|ConnectionStateListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|stateChanged
parameter_list|(
name|CuratorFramework
name|client
parameter_list|,
name|ConnectionState
name|newState
parameter_list|)
block|{
name|processConnectionState
argument_list|(
name|newState
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
specifier|private
enum|enum
name|State
block|{
name|LATENT
block|,
name|INITIAL_SELECTION
block|,
name|AFTER_SELECTION
block|,
name|CLOSED
block|}
specifier|public
name|SlotZnode
parameter_list|(
name|CuratorFramework
name|client
parameter_list|,
name|String
name|basePath
parameter_list|,
name|String
name|prefix
parameter_list|,
name|String
name|workerPrefix
parameter_list|,
name|String
name|data
parameter_list|)
block|{
name|this
operator|.
name|client
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|client
argument_list|,
literal|"client cannot be null"
argument_list|)
expr_stmt|;
name|this
operator|.
name|basePath
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|basePath
argument_list|,
literal|"basePath cannot be null"
argument_list|)
expr_stmt|;
name|this
operator|.
name|prefix
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|prefix
argument_list|,
literal|"prefix cannot be null"
argument_list|)
expr_stmt|;
name|this
operator|.
name|workerPrefix
operator|=
name|workerPrefix
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|data
argument_list|,
literal|"data cannot be null"
argument_list|)
expr_stmt|;
name|this
operator|.
name|dataStr
operator|=
name|data
expr_stmt|;
name|this
operator|.
name|data
operator|=
name|data
operator|.
name|getBytes
argument_list|(
name|CHARSET
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|int
name|getFallbackCount
parameter_list|()
block|{
return|return
name|fallbackCount
return|;
block|}
specifier|private
name|void
name|chooseSlotToTake
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|slotToTake
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|allChildNodes
decl_stmt|;
try|try
block|{
name|allChildNodes
operator|=
name|client
operator|.
name|getChildren
argument_list|()
operator|.
name|forPath
argument_list|(
name|basePath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot list nodes to get slots; failing"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|TreeSet
argument_list|<
name|Integer
argument_list|>
name|slots
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|approxWorkerCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|child
range|:
name|allChildNodes
control|)
block|{
if|if
condition|(
operator|!
name|child
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
if|if
condition|(
name|child
operator|.
name|startsWith
argument_list|(
name|workerPrefix
argument_list|)
condition|)
block|{
operator|++
name|approxWorkerCount
expr_stmt|;
block|}
block|}
else|else
block|{
name|slots
operator|.
name|add
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|child
operator|.
name|substring
argument_list|(
name|prefix
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|slotIter
init|=
name|slots
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|slotToTake
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|slotIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|int
name|nextTaken
init|=
name|slotIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|slotToTake
operator|<
name|nextTaken
condition|)
break|break;
name|slotToTake
operator|=
name|nextTaken
operator|+
literal|1
expr_stmt|;
block|}
comment|// There may be a race for this slot so re-query after a delay with some probability.
if|if
condition|(
name|slotToTake
operator|!=
name|currentSlot
operator|||
operator|!
name|shouldFallBackOnCollision
argument_list|(
name|approxWorkerCount
argument_list|)
condition|)
break|break;
operator|++
name|fallbackCount
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|rdm
operator|.
name|nextInt
argument_list|(
literal|200
argument_list|)
argument_list|)
expr_stmt|;
comment|// arbitrary
block|}
name|currentSlot
operator|=
name|slotToTake
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Will attempt to take slot "
operator|+
name|currentSlot
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|shouldFallBackOnCollision
parameter_list|(
name|int
name|approxWorkerCount
parameter_list|)
block|{
comment|// Ideally, we'd want 1 worker to try for every slot; e.g. if there are 4 workers we want 3
comment|// to re-read, i.e. probability of falling back = 0.75, or 1/4< random([0,1)). However, we
comment|// make it slightly more probable (2.0x) to avoid too much re-reading. This is hand-wavy.
if|if
condition|(
name|approxWorkerCount
operator|==
literal|0
condition|)
return|return
literal|false
return|;
return|return
operator|(
literal|2.0f
operator|/
name|approxWorkerCount
operator|)
operator|<=
name|rdm
operator|.
name|nextDouble
argument_list|()
return|;
block|}
specifier|private
name|String
name|getSlotPath
parameter_list|(
name|int
name|slot
parameter_list|)
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%s/%s%010d"
argument_list|,
name|basePath
argument_list|,
name|prefix
argument_list|,
name|slot
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|start
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|Exception
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|state
operator|.
name|compareAndSet
argument_list|(
name|State
operator|.
name|LATENT
argument_list|,
name|State
operator|.
name|INITIAL_SELECTION
argument_list|)
argument_list|,
literal|"Already started"
argument_list|)
expr_stmt|;
name|CountDownLatch
name|localLatch
init|=
name|initialCreateLatch
operator|.
name|get
argument_list|()
decl_stmt|;
name|client
operator|.
name|getConnectionStateListenable
argument_list|()
operator|.
name|addListener
argument_list|(
name|connectionStateListener
argument_list|)
expr_stmt|;
name|chooseSlotToTake
argument_list|()
expr_stmt|;
name|startCreateCurrentNode
argument_list|()
expr_stmt|;
return|return
name|localLatch
operator|.
name|await
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|State
name|currentState
init|=
name|state
operator|.
name|getAndSet
argument_list|(
name|State
operator|.
name|CLOSED
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentState
operator|==
name|State
operator|.
name|CLOSED
operator|||
name|currentState
operator|==
name|State
operator|.
name|LATENT
condition|)
return|return;
name|client
operator|.
name|getConnectionStateListenable
argument_list|()
operator|.
name|removeListener
argument_list|(
name|connectionStateListener
argument_list|)
expr_stmt|;
name|String
name|localNodePath
init|=
name|nodePath
operator|.
name|getAndSet
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|localNodePath
operator|==
literal|null
condition|)
return|return;
try|try
block|{
name|client
operator|.
name|delete
argument_list|()
operator|.
name|guaranteed
argument_list|()
operator|.
name|forPath
argument_list|(
name|localNodePath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|ignore
parameter_list|)
block|{     }
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Deleting node: "
operator|+
name|localNodePath
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|public
name|int
name|getCurrentSlot
parameter_list|()
block|{
assert|assert
name|isActive
argument_list|()
assert|;
return|return
name|currentSlot
return|;
block|}
specifier|private
name|void
name|startCreateCurrentNode
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isActive
argument_list|()
condition|)
return|return;
name|String
name|createPath
init|=
literal|null
decl_stmt|;
try|try
block|{
name|createPath
operator|=
name|getSlotPath
argument_list|(
name|currentSlot
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Attempting to create "
operator|+
name|createPath
argument_list|)
expr_stmt|;
name|client
operator|.
name|create
argument_list|()
operator|.
name|withMode
argument_list|(
name|CreateMode
operator|.
name|EPHEMERAL
argument_list|)
operator|.
name|inBackground
argument_list|(
name|backgroundCallback
argument_list|)
operator|.
name|forPath
argument_list|(
name|createPath
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Creating node. Path: "
operator|+
name|createPath
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|watchNode
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|isActive
argument_list|()
condition|)
return|return;
name|String
name|localNodePath
init|=
name|nodePath
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|localNodePath
operator|==
literal|null
condition|)
return|return;
try|try
block|{
name|client
operator|.
name|checkExists
argument_list|()
operator|.
name|usingWatcher
argument_list|(
name|watcher
argument_list|)
operator|.
name|inBackground
argument_list|(
name|checkExistsCallback
argument_list|)
operator|.
name|forPath
argument_list|(
name|localNodePath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Watching node: "
operator|+
name|localNodePath
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
specifier|private
name|boolean
name|isActive
parameter_list|()
block|{
name|State
name|localState
init|=
name|state
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
operator|(
name|localState
operator|!=
name|State
operator|.
name|LATENT
operator|&&
name|localState
operator|!=
name|State
operator|.
name|CLOSED
operator|)
return|;
block|}
specifier|private
name|void
name|processWatchResult
parameter_list|(
name|CuratorEvent
name|event
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|event
operator|.
name|getResultCode
argument_list|()
operator|!=
name|KeeperException
operator|.
name|Code
operator|.
name|NONODE
operator|.
name|intValue
argument_list|()
condition|)
return|return;
name|LOG
operator|.
name|info
argument_list|(
literal|"Trying to reacquire because of the NONODE event"
argument_list|)
expr_stmt|;
name|startCreateCurrentNode
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|processConnectionState
parameter_list|(
name|ConnectionState
name|newState
parameter_list|)
block|{
if|if
condition|(
name|newState
operator|!=
name|ConnectionState
operator|.
name|RECONNECTED
condition|)
return|return;
name|LOG
operator|.
name|info
argument_list|(
literal|"Trying to reacquire because of the RECONNECTED event"
argument_list|)
expr_stmt|;
name|startCreateCurrentNode
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|processWatchedEvent
parameter_list|(
name|WatchedEvent
name|event
parameter_list|)
block|{
if|if
condition|(
name|event
operator|.
name|getType
argument_list|()
operator|!=
name|EventType
operator|.
name|NodeDeleted
condition|)
return|return;
name|String
name|localPath
init|=
name|nodePath
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|localPath
operator|==
literal|null
condition|)
return|return;
if|if
condition|(
operator|!
name|localPath
operator|.
name|equals
argument_list|(
name|event
operator|.
name|getPath
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignoring the NodeDeleted event for "
operator|+
name|event
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Trying to reacquire because of the NodeDeleted event"
argument_list|)
expr_stmt|;
name|startCreateCurrentNode
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|processCreateResult
parameter_list|(
name|CuratorFramework
name|client
parameter_list|,
name|CuratorEvent
name|event
parameter_list|)
throws|throws
name|Exception
block|{
name|boolean
name|doesExist
init|=
name|event
operator|.
name|getResultCode
argument_list|()
operator|==
name|KeeperException
operator|.
name|Code
operator|.
name|NODEEXISTS
operator|.
name|intValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|doesExist
operator|&&
name|event
operator|.
name|getResultCode
argument_list|()
operator|!=
name|KeeperException
operator|.
name|Code
operator|.
name|OK
operator|.
name|intValue
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Trying to reacquire due to create error: "
operator|+
name|event
argument_list|)
expr_stmt|;
block|}
name|startCreateCurrentNode
argument_list|()
expr_stmt|;
comment|// TODO: a pattern from Curator. Better error handling?
return|return;
block|}
name|State
name|localState
init|=
name|state
operator|.
name|get
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|localState
condition|)
block|{
case|case
name|CLOSED
case|:
case|case
name|LATENT
case|:
return|return;
case|case
name|INITIAL_SELECTION
case|:
if|if
condition|(
name|doesExist
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Slot "
operator|+
name|currentSlot
operator|+
literal|" was occupied"
argument_list|)
expr_stmt|;
name|chooseSlotToTake
argument_list|()
expr_stmt|;
comment|// Try another slot.
name|startCreateCurrentNode
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|handleCreatedNode
argument_list|(
name|event
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AFTER_SELECTION
case|:
if|if
condition|(
name|doesExist
condition|)
block|{
name|processExistsFromCreate
argument_list|(
name|client
argument_list|,
name|event
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|handleCreatedNode
argument_list|(
name|event
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unknown state "
operator|+
name|localState
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|processExistsFromCreate
parameter_list|(
name|CuratorFramework
name|client
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|Exception
block|{
name|byte
index|[]
name|actual
decl_stmt|;
try|try
block|{
name|actual
operator|=
name|client
operator|.
name|getData
argument_list|()
operator|.
name|forPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error getting data for the node; will retry creating"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|startCreateCurrentNode
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Arrays
operator|.
name|equals
argument_list|(
name|actual
argument_list|,
name|data
argument_list|)
condition|)
block|{
name|handleCreatedNode
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Data at {} is from a different node: {} (we are {})"
argument_list|,
name|path
argument_list|,
operator|new
name|String
argument_list|(
name|actual
argument_list|,
name|CHARSET
argument_list|)
argument_list|,
name|dataStr
argument_list|)
expr_stmt|;
block|}
name|nodePath
operator|.
name|getAndSet
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|chooseSlotToTake
argument_list|()
expr_stmt|;
comment|// Try another slot.
name|startCreateCurrentNode
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|handleCreatedNode
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|Exception
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|State
name|localState
init|=
name|state
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|localState
operator|==
name|State
operator|.
name|CLOSED
operator|||
name|localState
operator|==
name|State
operator|.
name|LATENT
condition|)
return|return;
if|if
condition|(
name|state
operator|.
name|compareAndSet
argument_list|(
name|localState
argument_list|,
name|State
operator|.
name|AFTER_SELECTION
argument_list|)
condition|)
break|break;
block|}
name|nodePath
operator|.
name|set
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|watchNode
argument_list|()
expr_stmt|;
name|CountDownLatch
name|localLatch
init|=
name|initialCreateLatch
operator|.
name|getAndSet
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|localLatch
operator|!=
literal|null
condition|)
block|{
name|localLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Acquired the slot znode {}{}"
argument_list|,
name|path
argument_list|,
name|localLatch
operator|!=
literal|null
condition|?
literal|"; this is the initial assignment"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|String
name|getActualPath
parameter_list|()
block|{
return|return
name|nodePath
operator|.
name|get
argument_list|()
return|;
block|}
block|}
end_class

end_unit

