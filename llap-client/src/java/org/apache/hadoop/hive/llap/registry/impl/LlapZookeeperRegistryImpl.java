begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed under the Apache License, Version 2.0 (the "License");  *  you may not use this file except in compliance with the License.  *  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|registry
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|AppConfigurationEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|CuratorFramework
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|CuratorFrameworkFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|api
operator|.
name|ACLProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|imps
operator|.
name|CuratorFrameworkState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|recipes
operator|.
name|cache
operator|.
name|ChildData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|recipes
operator|.
name|cache
operator|.
name|PathChildrenCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|recipes
operator|.
name|cache
operator|.
name|PathChildrenCacheEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|recipes
operator|.
name|cache
operator|.
name|PathChildrenCacheListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|recipes
operator|.
name|nodes
operator|.
name|PersistentEphemeralNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|retry
operator|.
name|ExponentialBackoffRetry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|utils
operator|.
name|CloseableUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|registry
operator|.
name|ServiceInstance
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|registry
operator|.
name|ServiceInstanceSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|registry
operator|.
name|ServiceInstanceStateChangeListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|registry
operator|.
name|ServiceRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryPathUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryTypeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryUtils
operator|.
name|ServiceRecordMarshal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|AddressTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|Endpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|ProtocolTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|ServiceRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SecurityUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authentication
operator|.
name|util
operator|.
name|KerberosUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|ZooDefs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|client
operator|.
name|ZooKeeperSaslClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|ACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Id
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_class
specifier|public
class|class
name|LlapZookeeperRegistryImpl
implements|implements
name|ServiceRegistry
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|LlapZookeeperRegistryImpl
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * IPC endpoint names.    */
specifier|private
specifier|static
specifier|final
name|String
name|IPC_SERVICES
init|=
literal|"services"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|IPC_MNG
init|=
literal|"llapmng"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|IPC_SHUFFLE
init|=
literal|"shuffle"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|IPC_LLAP
init|=
literal|"llap"
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|String
name|ROOT_NAMESPACE
init|=
literal|"llap"
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|String
name|USER_SCOPE_PATH_PREFIX
init|=
literal|"user-"
decl_stmt|;
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
specifier|private
specifier|final
name|CuratorFramework
name|zooKeeperClient
decl_stmt|;
specifier|private
specifier|final
name|String
name|pathPrefix
decl_stmt|,
name|userPathPrefix
decl_stmt|;
specifier|private
name|String
name|userNameFromPrincipal
decl_stmt|;
comment|// Only set when setting up the secure config for ZK.
specifier|private
name|PersistentEphemeralNode
name|znode
decl_stmt|;
specifier|private
name|String
name|znodePath
decl_stmt|;
comment|// unique identity for this instance
specifier|private
specifier|final
name|ServiceRecordMarshal
name|encoder
decl_stmt|;
comment|// to marshal/unmarshal znode data
comment|// to be used by clients of ServiceRegistry
specifier|private
name|DynamicServiceInstanceSet
name|instances
decl_stmt|;
specifier|private
name|PathChildrenCache
name|instancesCache
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|UUID
name|uniq
init|=
name|UUID
operator|.
name|randomUUID
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|UNIQUE_IDENTIFIER
init|=
literal|"llap.unique.id"
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|ServiceInstanceStateChangeListener
argument_list|>
name|stateChangeListeners
decl_stmt|;
comment|// get local hostname
specifier|private
specifier|static
specifier|final
name|String
name|hostname
decl_stmt|;
static|static
block|{
name|String
name|localhost
init|=
literal|"localhost"
decl_stmt|;
try|try
block|{
name|localhost
operator|=
name|InetAddress
operator|.
name|getLocalHost
argument_list|()
operator|.
name|getCanonicalHostName
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownHostException
name|uhe
parameter_list|)
block|{
comment|// ignore
block|}
name|hostname
operator|=
name|localhost
expr_stmt|;
block|}
comment|/**    * ACLProvider for providing appropriate ACLs to CuratorFrameworkFactory    */
specifier|private
specifier|final
name|ACLProvider
name|zooKeeperAclProvider
init|=
operator|new
name|ACLProvider
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|ACL
argument_list|>
name|getDefaultAcl
parameter_list|()
block|{
comment|// We always return something from getAclForPath so this should not happen.
name|LOG
operator|.
name|warn
argument_list|(
literal|"getDefaultAcl was called"
argument_list|)
expr_stmt|;
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|ZooDefs
operator|.
name|Ids
operator|.
name|OPEN_ACL_UNSAFE
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|ACL
argument_list|>
name|getAclForPath
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
operator|!
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
operator|||
name|path
operator|==
literal|null
operator|||
operator|!
name|path
operator|.
name|contains
argument_list|(
name|userPathPrefix
argument_list|)
condition|)
block|{
comment|// No security or the path is below the user path - full access.
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|ZooDefs
operator|.
name|Ids
operator|.
name|OPEN_ACL_UNSAFE
argument_list|)
return|;
block|}
comment|// Read all to the world
name|List
argument_list|<
name|ACL
argument_list|>
name|nodeAcls
init|=
operator|new
name|ArrayList
argument_list|<
name|ACL
argument_list|>
argument_list|(
name|ZooDefs
operator|.
name|Ids
operator|.
name|READ_ACL_UNSAFE
argument_list|)
decl_stmt|;
comment|// Create/Delete/Write/Admin to creator
name|nodeAcls
operator|.
name|addAll
argument_list|(
name|ZooDefs
operator|.
name|Ids
operator|.
name|CREATOR_ALL_ACL
argument_list|)
expr_stmt|;
return|return
name|nodeAcls
return|;
block|}
block|}
decl_stmt|;
specifier|public
name|LlapZookeeperRegistryImpl
parameter_list|(
name|String
name|instanceName
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
operator|new
name|Configuration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|conf
operator|.
name|addResource
argument_list|(
name|YarnConfiguration
operator|.
name|YARN_SITE_CONFIGURATION_FILE
argument_list|)
expr_stmt|;
name|String
name|zkEnsemble
init|=
name|getQuorumServers
argument_list|(
name|this
operator|.
name|conf
argument_list|)
decl_stmt|;
name|this
operator|.
name|encoder
operator|=
operator|new
name|RegistryUtils
operator|.
name|ServiceRecordMarshal
argument_list|()
expr_stmt|;
name|int
name|sessionTimeout
init|=
operator|(
name|int
operator|)
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_ZOOKEEPER_SESSION_TIMEOUT
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
name|int
name|baseSleepTime
init|=
operator|(
name|int
operator|)
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_ZOOKEEPER_CONNECTION_BASESLEEPTIME
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
name|int
name|maxRetries
init|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_ZOOKEEPER_CONNECTION_MAX_RETRIES
argument_list|)
decl_stmt|;
comment|// Create a CuratorFramework instance to be used as the ZooKeeper client
comment|// Use the zooKeeperAclProvider to create appropriate ACLs
name|this
operator|.
name|zooKeeperClient
operator|=
name|CuratorFrameworkFactory
operator|.
name|builder
argument_list|()
operator|.
name|connectString
argument_list|(
name|zkEnsemble
argument_list|)
operator|.
name|sessionTimeoutMs
argument_list|(
name|sessionTimeout
argument_list|)
operator|.
name|aclProvider
argument_list|(
name|zooKeeperAclProvider
argument_list|)
operator|.
name|namespace
argument_list|(
name|ROOT_NAMESPACE
argument_list|)
operator|.
name|retryPolicy
argument_list|(
operator|new
name|ExponentialBackoffRetry
argument_list|(
name|baseSleepTime
argument_list|,
name|maxRetries
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
comment|// sample path: /llap/hiveuser/hostname/workers/worker-0000000
comment|// worker-0000000 is the sequence number which will be retained until session timeout. If a
comment|// worker does not respond due to communication interruptions it will retain the same sequence
comment|// number when it returns back. If session timeout expires, the node will be deleted and new
comment|// addition of the same node (restart) will get next sequence number
name|this
operator|.
name|userPathPrefix
operator|=
name|USER_SCOPE_PATH_PREFIX
operator|+
name|RegistryUtils
operator|.
name|currentUser
argument_list|()
expr_stmt|;
name|this
operator|.
name|pathPrefix
operator|=
literal|"/"
operator|+
name|userPathPrefix
operator|+
literal|"/"
operator|+
name|instanceName
operator|+
literal|"/workers/worker-"
expr_stmt|;
name|this
operator|.
name|instancesCache
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|instances
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|stateChangeListeners
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Llap Zookeeper Registry is enabled with registryid: "
operator|+
name|instanceName
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the ensemble server addresses from the configuration. The format is: host1:port,    * host2:port..    *    * @param conf    **/
specifier|private
name|String
name|getQuorumServers
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|String
index|[]
name|hosts
init|=
name|conf
operator|.
name|getTrimmedStrings
argument_list|(
name|ConfVars
operator|.
name|HIVE_ZOOKEEPER_QUORUM
operator|.
name|varname
argument_list|)
decl_stmt|;
name|String
name|port
init|=
name|conf
operator|.
name|get
argument_list|(
name|ConfVars
operator|.
name|HIVE_ZOOKEEPER_CLIENT_PORT
operator|.
name|varname
argument_list|,
name|ConfVars
operator|.
name|HIVE_ZOOKEEPER_CLIENT_PORT
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
decl_stmt|;
name|StringBuilder
name|quorum
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hosts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|quorum
operator|.
name|append
argument_list|(
name|hosts
index|[
name|i
index|]
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hosts
index|[
name|i
index|]
operator|.
name|contains
argument_list|(
literal|":"
argument_list|)
condition|)
block|{
comment|// if the hostname doesn't contain a port, add the configured port to hostname
name|quorum
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|quorum
operator|.
name|append
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|hosts
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|quorum
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|quorum
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
name|Endpoint
name|getRpcEndpoint
parameter_list|()
block|{
specifier|final
name|int
name|rpcPort
init|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_DAEMON_RPC_PORT
argument_list|)
decl_stmt|;
return|return
name|RegistryTypeUtils
operator|.
name|ipcEndpoint
argument_list|(
name|IPC_LLAP
argument_list|,
operator|new
name|InetSocketAddress
argument_list|(
name|hostname
argument_list|,
name|rpcPort
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|Endpoint
name|getShuffleEndpoint
parameter_list|()
block|{
specifier|final
name|int
name|shufflePort
init|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_DAEMON_YARN_SHUFFLE_PORT
argument_list|)
decl_stmt|;
comment|// HTTP today, but might not be
return|return
name|RegistryTypeUtils
operator|.
name|inetAddrEndpoint
argument_list|(
name|IPC_SHUFFLE
argument_list|,
name|ProtocolTypes
operator|.
name|PROTOCOL_TCP
argument_list|,
name|hostname
argument_list|,
name|shufflePort
argument_list|)
return|;
block|}
specifier|public
name|Endpoint
name|getServicesEndpoint
parameter_list|()
block|{
specifier|final
name|int
name|servicePort
init|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_DAEMON_WEB_PORT
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|isSSL
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_DAEMON_WEB_SSL
argument_list|)
decl_stmt|;
specifier|final
name|String
name|scheme
init|=
name|isSSL
condition|?
literal|"https"
else|:
literal|"http"
decl_stmt|;
specifier|final
name|URL
name|serviceURL
decl_stmt|;
try|try
block|{
name|serviceURL
operator|=
operator|new
name|URL
argument_list|(
name|scheme
argument_list|,
name|hostname
argument_list|,
name|servicePort
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|RegistryTypeUtils
operator|.
name|webEndpoint
argument_list|(
name|IPC_SERVICES
argument_list|,
name|serviceURL
operator|.
name|toURI
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|MalformedURLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"llap service URI for "
operator|+
name|hostname
operator|+
literal|" is invalid"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|public
name|Endpoint
name|getMngEndpoint
parameter_list|()
block|{
return|return
name|RegistryTypeUtils
operator|.
name|ipcEndpoint
argument_list|(
name|IPC_MNG
argument_list|,
operator|new
name|InetSocketAddress
argument_list|(
name|hostname
argument_list|,
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_MANAGEMENT_RPC_PORT
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|register
parameter_list|()
throws|throws
name|IOException
block|{
name|ServiceRecord
name|srv
init|=
operator|new
name|ServiceRecord
argument_list|()
decl_stmt|;
name|Endpoint
name|rpcEndpoint
init|=
name|getRpcEndpoint
argument_list|()
decl_stmt|;
name|srv
operator|.
name|addInternalEndpoint
argument_list|(
name|rpcEndpoint
argument_list|)
expr_stmt|;
name|srv
operator|.
name|addInternalEndpoint
argument_list|(
name|getMngEndpoint
argument_list|()
argument_list|)
expr_stmt|;
name|srv
operator|.
name|addInternalEndpoint
argument_list|(
name|getShuffleEndpoint
argument_list|()
argument_list|)
expr_stmt|;
name|srv
operator|.
name|addExternalEndpoint
argument_list|(
name|getServicesEndpoint
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|kv
range|:
name|this
operator|.
name|conf
control|)
block|{
if|if
condition|(
name|kv
operator|.
name|getKey
argument_list|()
operator|.
name|startsWith
argument_list|(
name|HiveConf
operator|.
name|PREFIX_LLAP
argument_list|)
operator|||
name|kv
operator|.
name|getKey
argument_list|()
operator|.
name|startsWith
argument_list|(
name|HiveConf
operator|.
name|PREFIX_HIVE_LLAP
argument_list|)
condition|)
block|{
comment|// TODO: read this somewhere useful, like the task scheduler
name|srv
operator|.
name|set
argument_list|(
name|kv
operator|.
name|getKey
argument_list|()
argument_list|,
name|kv
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// restart sensitive instance id
name|srv
operator|.
name|set
argument_list|(
name|UNIQUE_IDENTIFIER
argument_list|,
name|uniq
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Create a znode under the rootNamespace parent for this instance of the server
try|try
block|{
comment|// PersistentEphemeralNode will make sure the ephemeral node created on server will be present
comment|// even under connection or session interruption (will automatically handle retries)
name|znode
operator|=
operator|new
name|PersistentEphemeralNode
argument_list|(
name|zooKeeperClient
argument_list|,
name|PersistentEphemeralNode
operator|.
name|Mode
operator|.
name|EPHEMERAL_SEQUENTIAL
argument_list|,
name|pathPrefix
argument_list|,
name|encoder
operator|.
name|toBytes
argument_list|(
name|srv
argument_list|)
argument_list|)
expr_stmt|;
comment|// start the creation of znode
name|znode
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// We'll wait for 120s for node creation
name|long
name|znodeCreationTimeout
init|=
literal|120
decl_stmt|;
if|if
condition|(
operator|!
name|znode
operator|.
name|waitForInitialCreate
argument_list|(
name|znodeCreationTimeout
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"Max znode creation wait time: "
operator|+
name|znodeCreationTimeout
operator|+
literal|"s exhausted"
argument_list|)
throw|;
block|}
name|znodePath
operator|=
name|znode
operator|.
name|getActualPath
argument_list|()
expr_stmt|;
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_VALIDATE_ACLS
argument_list|)
condition|)
block|{
name|checkAcls
argument_list|()
expr_stmt|;
block|}
comment|// Set a watch on the znode
if|if
condition|(
name|zooKeeperClient
operator|.
name|checkExists
argument_list|()
operator|.
name|forPath
argument_list|(
name|znodePath
argument_list|)
operator|==
literal|null
condition|)
block|{
comment|// No node exists, throw exception
throw|throw
operator|new
name|Exception
argument_list|(
literal|"Unable to create znode for this LLAP instance on ZooKeeper."
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Registered node. Created a znode on ZooKeeper for LLAP instance: rpc: {}, shuffle: {},"
operator|+
literal|" webui: {}, mgmt: {}, znodePath: {} "
argument_list|,
name|rpcEndpoint
argument_list|,
name|getShuffleEndpoint
argument_list|()
argument_list|,
name|getServicesEndpoint
argument_list|()
argument_list|,
name|getMngEndpoint
argument_list|()
argument_list|,
name|znodePath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to create a znode for this server instance"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|CloseableUtils
operator|.
name|closeQuietly
argument_list|(
name|znode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created zknode with path: {} service record: {}"
argument_list|,
name|znodePath
argument_list|,
name|srv
argument_list|)
expr_stmt|;
block|}
return|return
name|uniq
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|void
name|checkAcls
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
return|return;
name|String
name|pathToCheck
init|=
name|znodePath
decl_stmt|;
comment|// We are trying to check ACLs on the "workers" directory, which noone except us should be
comment|// able to write to. Higher-level directories shouldn't matter - we don't read them.
name|int
name|ix
init|=
name|pathToCheck
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|ix
operator|>
literal|0
condition|)
block|{
name|pathToCheck
operator|=
name|pathToCheck
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|ix
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|ACL
argument_list|>
name|acls
init|=
name|zooKeeperClient
operator|.
name|usingNamespace
argument_list|(
literal|null
argument_list|)
operator|.
name|getACL
argument_list|()
operator|.
name|forPath
argument_list|(
name|pathToCheck
argument_list|)
decl_stmt|;
if|if
condition|(
name|acls
operator|==
literal|null
operator|||
name|acls
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Can there be no ACLs? There's some access (to get ACLs), so assume it means free for all.
throw|throw
operator|new
name|SecurityException
argument_list|(
literal|"No ACLs on "
operator|+
name|pathToCheck
argument_list|)
throw|;
block|}
comment|// This could be brittle.
assert|assert
name|userNameFromPrincipal
operator|!=
literal|null
assert|;
name|Id
name|currentUser
init|=
operator|new
name|Id
argument_list|(
literal|"sasl"
argument_list|,
name|userNameFromPrincipal
argument_list|)
decl_stmt|;
for|for
control|(
name|ACL
name|acl
range|:
name|acls
control|)
block|{
if|if
condition|(
operator|(
name|acl
operator|.
name|getPerms
argument_list|()
operator|&
operator|~
name|ZooDefs
operator|.
name|Perms
operator|.
name|READ
operator|)
operator|==
literal|0
operator|||
name|currentUser
operator|.
name|equals
argument_list|(
name|acl
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
comment|// Read permission/no permissions, or the expected user.
block|}
throw|throw
operator|new
name|SecurityException
argument_list|(
literal|"The ACL "
operator|+
name|acl
operator|+
literal|" is unnacceptable for "
operator|+
name|pathToCheck
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|unregister
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Nothing for the zkCreate models
block|}
specifier|private
class|class
name|DynamicServiceInstance
implements|implements
name|ServiceInstance
block|{
specifier|private
specifier|final
name|ServiceRecord
name|srv
decl_stmt|;
specifier|private
name|boolean
name|alive
init|=
literal|true
decl_stmt|;
specifier|private
specifier|final
name|String
name|host
decl_stmt|;
specifier|private
specifier|final
name|int
name|rpcPort
decl_stmt|;
specifier|private
specifier|final
name|int
name|mngPort
decl_stmt|;
specifier|private
specifier|final
name|int
name|shufflePort
decl_stmt|;
specifier|private
specifier|final
name|String
name|serviceAddress
decl_stmt|;
specifier|public
name|DynamicServiceInstance
parameter_list|(
name|ServiceRecord
name|srv
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|srv
operator|=
name|srv
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Working with ServiceRecord: {}"
argument_list|,
name|srv
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Endpoint
name|shuffle
init|=
name|srv
operator|.
name|getInternalEndpoint
argument_list|(
name|IPC_SHUFFLE
argument_list|)
decl_stmt|;
specifier|final
name|Endpoint
name|rpc
init|=
name|srv
operator|.
name|getInternalEndpoint
argument_list|(
name|IPC_LLAP
argument_list|)
decl_stmt|;
specifier|final
name|Endpoint
name|mng
init|=
name|srv
operator|.
name|getInternalEndpoint
argument_list|(
name|IPC_MNG
argument_list|)
decl_stmt|;
specifier|final
name|Endpoint
name|services
init|=
name|srv
operator|.
name|getExternalEndpoint
argument_list|(
name|IPC_SERVICES
argument_list|)
decl_stmt|;
name|this
operator|.
name|host
operator|=
name|RegistryTypeUtils
operator|.
name|getAddressField
argument_list|(
name|rpc
operator|.
name|addresses
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|AddressTypes
operator|.
name|ADDRESS_HOSTNAME_FIELD
argument_list|)
expr_stmt|;
name|this
operator|.
name|rpcPort
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|RegistryTypeUtils
operator|.
name|getAddressField
argument_list|(
name|rpc
operator|.
name|addresses
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|AddressTypes
operator|.
name|ADDRESS_PORT_FIELD
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|mngPort
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|RegistryTypeUtils
operator|.
name|getAddressField
argument_list|(
name|mng
operator|.
name|addresses
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|AddressTypes
operator|.
name|ADDRESS_PORT_FIELD
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|shufflePort
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|RegistryTypeUtils
operator|.
name|getAddressField
argument_list|(
name|shuffle
operator|.
name|addresses
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|AddressTypes
operator|.
name|ADDRESS_PORT_FIELD
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|serviceAddress
operator|=
name|RegistryTypeUtils
operator|.
name|getAddressField
argument_list|(
name|services
operator|.
name|addresses
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|AddressTypes
operator|.
name|ADDRESS_URI
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getWorkerIdentity
parameter_list|()
block|{
return|return
name|srv
operator|.
name|get
argument_list|(
name|UNIQUE_IDENTIFIER
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getHost
parameter_list|()
block|{
return|return
name|host
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getRpcPort
parameter_list|()
block|{
return|return
name|rpcPort
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getShufflePort
parameter_list|()
block|{
return|return
name|shufflePort
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getServicesAddress
parameter_list|()
block|{
return|return
name|serviceAddress
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isAlive
parameter_list|()
block|{
return|return
name|alive
return|;
block|}
specifier|public
name|void
name|kill
parameter_list|()
block|{
comment|// May be possible to generate a notification back to the scheduler from here.
name|LOG
operator|.
name|info
argument_list|(
literal|"Killing service instance: "
operator|+
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|alive
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getProperties
parameter_list|()
block|{
return|return
name|srv
operator|.
name|attributes
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Resource
name|getResource
parameter_list|()
block|{
name|int
name|memory
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|srv
operator|.
name|get
argument_list|(
name|ConfVars
operator|.
name|LLAP_DAEMON_MEMORY_PER_INSTANCE_MB
operator|.
name|varname
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|vCores
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|srv
operator|.
name|get
argument_list|(
name|ConfVars
operator|.
name|LLAP_DAEMON_NUM_EXECUTORS
operator|.
name|varname
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|Resource
operator|.
name|newInstance
argument_list|(
name|memory
argument_list|,
name|vCores
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"DynamicServiceInstance [alive="
operator|+
name|alive
operator|+
literal|", host="
operator|+
name|host
operator|+
literal|":"
operator|+
name|rpcPort
operator|+
literal|" with resources="
operator|+
name|getResource
argument_list|()
operator|+
literal|", shufflePort="
operator|+
name|getShufflePort
argument_list|()
operator|+
literal|", servicesAddress="
operator|+
name|getServicesAddress
argument_list|()
operator|+
literal|", mgmtPort="
operator|+
name|getManagementPort
argument_list|()
operator|+
literal|"]"
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getManagementPort
parameter_list|()
block|{
return|return
name|mngPort
return|;
block|}
comment|// Relying on the identity hashCode and equality, since refreshing instances retains the old copy
comment|// of an already known instance.
block|}
specifier|private
class|class
name|DynamicServiceInstanceSet
implements|implements
name|ServiceInstanceSet
block|{
specifier|private
specifier|final
name|PathChildrenCache
name|instancesCache
decl_stmt|;
specifier|public
name|DynamicServiceInstanceSet
parameter_list|(
specifier|final
name|PathChildrenCache
name|cache
parameter_list|)
block|{
name|this
operator|.
name|instancesCache
operator|=
name|cache
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|ServiceInstance
argument_list|>
name|getAll
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|ServiceInstance
argument_list|>
name|instances
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ChildData
name|childData
range|:
name|instancesCache
operator|.
name|getCurrentData
argument_list|()
control|)
block|{
if|if
condition|(
name|childData
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|childData
operator|.
name|getData
argument_list|()
decl_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|ServiceRecord
name|srv
init|=
name|encoder
operator|.
name|fromBytes
argument_list|(
name|childData
operator|.
name|getPath
argument_list|()
argument_list|,
name|data
argument_list|)
decl_stmt|;
name|ServiceInstance
name|instance
init|=
operator|new
name|DynamicServiceInstance
argument_list|(
name|srv
argument_list|)
decl_stmt|;
name|instances
operator|.
name|put
argument_list|(
name|childData
operator|.
name|getPath
argument_list|()
argument_list|,
name|instance
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to decode data for zkpath: {}."
operator|+
literal|" Ignoring from current instances list.."
argument_list|,
name|childData
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|instances
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|ServiceInstance
argument_list|>
name|getAllInstancesOrdered
parameter_list|()
block|{
name|List
argument_list|<
name|ServiceInstance
argument_list|>
name|list
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|list
operator|.
name|addAll
argument_list|(
name|instances
operator|.
name|getAll
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|list
argument_list|,
operator|new
name|Comparator
argument_list|<
name|ServiceInstance
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|ServiceInstance
name|o1
parameter_list|,
name|ServiceInstance
name|o2
parameter_list|)
block|{
return|return
name|o2
operator|.
name|getWorkerIdentity
argument_list|()
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|getWorkerIdentity
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
annotation|@
name|Override
specifier|public
name|ServiceInstance
name|getInstance
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|ChildData
name|childData
init|=
name|instancesCache
operator|.
name|getCurrentData
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|childData
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|childData
operator|.
name|getData
argument_list|()
decl_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|ServiceRecord
name|srv
init|=
name|encoder
operator|.
name|fromBytes
argument_list|(
name|name
argument_list|,
name|data
argument_list|)
decl_stmt|;
name|ServiceInstance
name|instance
init|=
operator|new
name|DynamicServiceInstance
argument_list|(
name|srv
argument_list|)
decl_stmt|;
return|return
name|instance
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to decode data for zkpath: {}"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|ServiceInstance
argument_list|>
name|getByHost
parameter_list|(
name|String
name|host
parameter_list|)
block|{
name|Set
argument_list|<
name|ServiceInstance
argument_list|>
name|byHost
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ChildData
name|childData
range|:
name|instancesCache
operator|.
name|getCurrentData
argument_list|()
control|)
block|{
if|if
condition|(
name|childData
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|childData
operator|.
name|getData
argument_list|()
decl_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|ServiceRecord
name|srv
init|=
name|encoder
operator|.
name|fromBytes
argument_list|(
name|childData
operator|.
name|getPath
argument_list|()
argument_list|,
name|data
argument_list|)
decl_stmt|;
name|ServiceInstance
name|instance
init|=
operator|new
name|DynamicServiceInstance
argument_list|(
name|srv
argument_list|)
decl_stmt|;
if|if
condition|(
name|host
operator|.
name|equals
argument_list|(
name|instance
operator|.
name|getHost
argument_list|()
argument_list|)
condition|)
block|{
name|byHost
operator|.
name|add
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Locality comparing "
operator|+
name|host
operator|+
literal|" to "
operator|+
name|instance
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to decode data for zkpath: {}."
operator|+
literal|" Ignoring host from current instances list.."
argument_list|,
name|childData
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Returning "
operator|+
name|byHost
operator|.
name|size
argument_list|()
operator|+
literal|" hosts for locality allocation on "
operator|+
name|host
argument_list|)
expr_stmt|;
block|}
return|return
name|byHost
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|instancesCache
operator|.
name|getCurrentData
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
block|}
specifier|private
class|class
name|InstanceStateChangeListener
implements|implements
name|PathChildrenCacheListener
block|{
specifier|private
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|InstanceStateChangeListener
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|childEvent
parameter_list|(
specifier|final
name|CuratorFramework
name|client
parameter_list|,
specifier|final
name|PathChildrenCacheEvent
name|event
parameter_list|)
throws|throws
name|Exception
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|client
operator|!=
literal|null
operator|&&
name|client
operator|.
name|getState
argument_list|()
operator|==
name|CuratorFrameworkState
operator|.
name|STARTED
argument_list|,
literal|"client is not started"
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
operator|!
name|stateChangeListeners
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ServiceInstance
name|instance
init|=
literal|null
decl_stmt|;
name|ChildData
name|childData
init|=
name|event
operator|.
name|getData
argument_list|()
decl_stmt|;
if|if
condition|(
name|childData
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|childData
operator|.
name|getData
argument_list|()
decl_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|ServiceRecord
name|srv
init|=
name|encoder
operator|.
name|fromBytes
argument_list|(
name|event
operator|.
name|getData
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
name|data
argument_list|)
decl_stmt|;
name|instance
operator|=
operator|new
name|DynamicServiceInstance
argument_list|(
name|srv
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to decode data for zknode: {}."
operator|+
literal|" Dropping notification of type: {}"
argument_list|,
name|childData
operator|.
name|getPath
argument_list|()
argument_list|,
name|event
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// notify listeners of the new data
for|for
control|(
name|ServiceInstanceStateChangeListener
name|listener
range|:
name|stateChangeListeners
control|)
block|{
if|if
condition|(
name|event
operator|.
name|getType
argument_list|()
operator|==
name|PathChildrenCacheEvent
operator|.
name|Type
operator|.
name|CHILD_ADDED
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Added zknode {} to llap namespace. Notifying state change listener."
argument_list|,
name|event
operator|.
name|getData
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|listener
operator|.
name|onCreate
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|.
name|getType
argument_list|()
operator|==
name|PathChildrenCacheEvent
operator|.
name|Type
operator|.
name|CHILD_UPDATED
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Updated zknode {} in llap namespace. Notifying state change listener."
argument_list|,
name|event
operator|.
name|getData
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|listener
operator|.
name|onUpdate
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|.
name|getType
argument_list|()
operator|==
name|PathChildrenCacheEvent
operator|.
name|Type
operator|.
name|CHILD_REMOVED
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removed zknode {} from llap namespace. Notifying state change listener."
argument_list|,
name|event
operator|.
name|getData
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|listener
operator|.
name|onRemove
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|ServiceInstanceSet
name|getInstances
parameter_list|(
name|String
name|component
parameter_list|)
throws|throws
name|IOException
block|{
name|checkPathChildrenCache
argument_list|()
expr_stmt|;
comment|// lazily create instances
if|if
condition|(
name|instances
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|instances
operator|=
operator|new
name|DynamicServiceInstanceSet
argument_list|(
name|instancesCache
argument_list|)
expr_stmt|;
block|}
return|return
name|instances
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|registerStateChangeListener
parameter_list|(
specifier|final
name|ServiceInstanceStateChangeListener
name|listener
parameter_list|)
throws|throws
name|IOException
block|{
name|checkPathChildrenCache
argument_list|()
expr_stmt|;
name|this
operator|.
name|stateChangeListeners
operator|.
name|add
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|synchronized
name|void
name|checkPathChildrenCache
parameter_list|()
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|zooKeeperClient
operator|!=
literal|null
operator|&&
name|zooKeeperClient
operator|.
name|getState
argument_list|()
operator|==
name|CuratorFrameworkState
operator|.
name|STARTED
argument_list|,
literal|"client is not started"
argument_list|)
expr_stmt|;
comment|// lazily create PathChildrenCache
if|if
condition|(
name|instancesCache
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|instancesCache
operator|=
operator|new
name|PathChildrenCache
argument_list|(
name|zooKeeperClient
argument_list|,
name|RegistryPathUtils
operator|.
name|parentOf
argument_list|(
name|pathPrefix
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|instancesCache
operator|.
name|getListenable
argument_list|()
operator|.
name|addListener
argument_list|(
operator|new
name|InstanceStateChangeListener
argument_list|()
argument_list|,
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
literal|1
argument_list|,
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
literal|"StateChangeNotificationHandler"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|instancesCache
operator|.
name|start
argument_list|(
name|PathChildrenCache
operator|.
name|StartMode
operator|.
name|BUILD_INITIAL_CACHE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to start curator PathChildrenCache. Exception: {}"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|start
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|zooKeeperClient
operator|!=
literal|null
condition|)
block|{
name|setupZookeeperAuth
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|zooKeeperClient
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|// Init closeable utils in case register is not called (see HIVE-13322)
name|CloseableUtils
operator|.
name|class
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|stop
parameter_list|()
throws|throws
name|IOException
block|{
name|CloseableUtils
operator|.
name|closeQuietly
argument_list|(
name|znode
argument_list|)
expr_stmt|;
name|CloseableUtils
operator|.
name|closeQuietly
argument_list|(
name|instancesCache
argument_list|)
expr_stmt|;
name|CloseableUtils
operator|.
name|closeQuietly
argument_list|(
name|zooKeeperClient
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|setupZookeeperAuth
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"UGI security is enabled. Setting up ZK auth."
argument_list|)
expr_stmt|;
name|String
name|llapPrincipal
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_KERBEROS_PRINCIPAL
argument_list|)
decl_stmt|;
if|if
condition|(
name|llapPrincipal
operator|==
literal|null
operator|||
name|llapPrincipal
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Llap Kerberos principal is empty"
argument_list|)
throw|;
block|}
name|String
name|llapKeytab
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|LLAP_KERBEROS_KEYTAB_FILE
argument_list|)
decl_stmt|;
if|if
condition|(
name|llapKeytab
operator|==
literal|null
operator|||
name|llapKeytab
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Llap Kerberos keytab is empty"
argument_list|)
throw|;
block|}
comment|// Install the JAAS Configuration for the runtime
name|setZookeeperClientKerberosJaasConfig
argument_list|(
name|llapPrincipal
argument_list|,
name|llapKeytab
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"UGI security is not enabled. Skipping setting up ZK auth."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Dynamically sets up the JAAS configuration that uses kerberos    *    * @param principal    * @param keyTabFile    * @throws IOException    */
specifier|private
name|void
name|setZookeeperClientKerberosJaasConfig
parameter_list|(
name|String
name|principal
parameter_list|,
name|String
name|keyTabFile
parameter_list|)
throws|throws
name|IOException
block|{
comment|// ZooKeeper property name to pick the correct JAAS conf section
specifier|final
name|String
name|SASL_LOGIN_CONTEXT_NAME
init|=
literal|"LlapZooKeeperClient"
decl_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
name|ZooKeeperSaslClient
operator|.
name|LOGIN_CONTEXT_NAME_KEY
argument_list|,
name|SASL_LOGIN_CONTEXT_NAME
argument_list|)
expr_stmt|;
name|principal
operator|=
name|SecurityUtil
operator|.
name|getServerPrincipal
argument_list|(
name|principal
argument_list|,
literal|"0.0.0.0"
argument_list|)
expr_stmt|;
name|userNameFromPrincipal
operator|=
name|getUserNameFromPrincipal
argument_list|(
name|principal
argument_list|)
expr_stmt|;
name|JaasConfiguration
name|jaasConf
init|=
operator|new
name|JaasConfiguration
argument_list|(
name|SASL_LOGIN_CONTEXT_NAME
argument_list|,
name|principal
argument_list|,
name|keyTabFile
argument_list|)
decl_stmt|;
comment|// Install the Configuration in the runtime.
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
operator|.
name|setConfiguration
argument_list|(
name|jaasConf
argument_list|)
expr_stmt|;
block|}
specifier|private
name|String
name|getUserNameFromPrincipal
parameter_list|(
name|String
name|principal
parameter_list|)
block|{
comment|// Based on SecurityUtil.
name|String
index|[]
name|components
init|=
name|principal
operator|.
name|split
argument_list|(
literal|"[/@]"
argument_list|)
decl_stmt|;
return|return
operator|(
name|components
operator|==
literal|null
operator|||
name|components
operator|.
name|length
operator|!=
literal|3
operator|)
condition|?
name|principal
else|:
name|components
index|[
literal|0
index|]
return|;
block|}
comment|/**    * A JAAS configuration for ZooKeeper clients intended to use for SASL    * Kerberos.    */
specifier|private
specifier|static
class|class
name|JaasConfiguration
extends|extends
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
block|{
comment|// Current installed Configuration
specifier|private
specifier|final
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
name|baseConfig
init|=
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|String
name|loginContextName
decl_stmt|;
specifier|private
specifier|final
name|String
name|principal
decl_stmt|;
specifier|private
specifier|final
name|String
name|keyTabFile
decl_stmt|;
specifier|public
name|JaasConfiguration
parameter_list|(
name|String
name|llapLoginContextName
parameter_list|,
name|String
name|principal
parameter_list|,
name|String
name|keyTabFile
parameter_list|)
block|{
name|this
operator|.
name|loginContextName
operator|=
name|llapLoginContextName
expr_stmt|;
name|this
operator|.
name|principal
operator|=
name|principal
expr_stmt|;
name|this
operator|.
name|keyTabFile
operator|=
name|keyTabFile
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|AppConfigurationEntry
index|[]
name|getAppConfigurationEntry
parameter_list|(
name|String
name|appName
parameter_list|)
block|{
if|if
condition|(
name|loginContextName
operator|.
name|equals
argument_list|(
name|appName
argument_list|)
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|krbOptions
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|krbOptions
operator|.
name|put
argument_list|(
literal|"doNotPrompt"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|krbOptions
operator|.
name|put
argument_list|(
literal|"storeKey"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|krbOptions
operator|.
name|put
argument_list|(
literal|"useKeyTab"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|krbOptions
operator|.
name|put
argument_list|(
literal|"principal"
argument_list|,
name|principal
argument_list|)
expr_stmt|;
name|krbOptions
operator|.
name|put
argument_list|(
literal|"keyTab"
argument_list|,
name|keyTabFile
argument_list|)
expr_stmt|;
name|krbOptions
operator|.
name|put
argument_list|(
literal|"refreshKrb5Config"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|AppConfigurationEntry
name|llapZooKeeperClientEntry
init|=
operator|new
name|AppConfigurationEntry
argument_list|(
name|KerberosUtil
operator|.
name|getKrb5LoginModuleName
argument_list|()
argument_list|,
name|AppConfigurationEntry
operator|.
name|LoginModuleControlFlag
operator|.
name|REQUIRED
argument_list|,
name|krbOptions
argument_list|)
decl_stmt|;
return|return
operator|new
name|AppConfigurationEntry
index|[]
block|{
name|llapZooKeeperClientEntry
block|}
return|;
block|}
comment|// Try the base config
if|if
condition|(
name|baseConfig
operator|!=
literal|null
condition|)
block|{
return|return
name|baseConfig
operator|.
name|getAppConfigurationEntry
argument_list|(
name|appName
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
block|}
end_class

end_unit

