begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed under the Apache License, Version 2.0 (the "License");  *  you may not use this file except in compliance with the License.  *  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|registry
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|CuratorFramework
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|CuratorFrameworkFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|api
operator|.
name|ACLProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|imps
operator|.
name|CuratorFrameworkState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|recipes
operator|.
name|cache
operator|.
name|ChildData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|recipes
operator|.
name|cache
operator|.
name|PathChildrenCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|recipes
operator|.
name|cache
operator|.
name|PathChildrenCacheEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|recipes
operator|.
name|cache
operator|.
name|PathChildrenCacheListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|recipes
operator|.
name|nodes
operator|.
name|PersistentEphemeralNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|recipes
operator|.
name|nodes
operator|.
name|PersistentEphemeralNode
operator|.
name|Mode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|retry
operator|.
name|ExponentialBackoffRetry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|utils
operator|.
name|CloseableUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|LlapUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|registry
operator|.
name|ServiceInstance
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|registry
operator|.
name|ServiceInstanceStateChangeListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryUtils
operator|.
name|ServiceRecordMarshal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|ServiceRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
operator|.
name|InvalidACLException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
operator|.
name|NodeExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|ZooDefs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|ACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Id
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * This is currently used for implementation inheritance only; it doesn't provide a unified flow  * into which one can just plug a few abstract method implementations, because providing one with  * getInstance method is a huge pain involving lots of generics. Also, different registries may  * have slightly different usage patterns anyway and noone would use a registry without knowing  * what type it is. So, it's mostly a grab bag of methods used by ServiceInstanceSet and other  * parts of each implementation.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|ZkRegistryBase
parameter_list|<
name|InstanceType
extends|extends
name|ServiceInstance
parameter_list|>
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ZkRegistryBase
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|String
name|SASL_NAMESPACE
init|=
literal|"sasl"
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|String
name|UNSECURE_NAMESPACE
init|=
literal|"unsecure"
decl_stmt|;
specifier|static
specifier|final
name|String
name|UNIQUE_IDENTIFIER
init|=
literal|"registry.unique.id"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|UUID
name|uniq
init|=
name|UUID
operator|.
name|randomUUID
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|Configuration
name|conf
decl_stmt|;
specifier|protected
specifier|final
name|CuratorFramework
name|zooKeeperClient
decl_stmt|;
comment|// userPathPrefix is the path specific to the user for which ACLs should be restrictive.
comment|// workersPath is the directory path where all the worker znodes are located.
specifier|protected
specifier|final
name|String
name|workersPath
decl_stmt|;
specifier|private
specifier|final
name|String
name|userPathPrefix
decl_stmt|,
name|workerNodePrefix
decl_stmt|;
specifier|protected
specifier|final
name|ServiceRecordMarshal
name|encoder
decl_stmt|;
comment|// to marshal/unmarshal znode data
specifier|private
specifier|final
name|Set
argument_list|<
name|ServiceInstanceStateChangeListener
argument_list|<
name|InstanceType
argument_list|>
argument_list|>
name|stateChangeListeners
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|doCheckAcls
decl_stmt|;
comment|// Secure ZK is only set up by the registering service; anyone can read the registrations.
specifier|private
specifier|final
name|String
name|zkPrincipal
decl_stmt|,
name|zkKeytab
decl_stmt|,
name|saslLoginContextName
decl_stmt|;
specifier|private
name|String
name|userNameFromPrincipal
decl_stmt|;
comment|// Only set when setting up the secure config for ZK.
specifier|private
specifier|final
name|String
name|disableMessage
decl_stmt|;
specifier|private
specifier|final
name|Lock
name|instanceCacheLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|InstanceType
argument_list|>
argument_list|>
name|pathToInstanceCache
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|InstanceType
argument_list|>
argument_list|>
name|nodeToInstanceCache
decl_stmt|;
comment|// The registration znode.
specifier|private
name|PersistentEphemeralNode
name|znode
decl_stmt|;
specifier|private
name|String
name|znodePath
decl_stmt|;
comment|// unique identity for this instance
specifier|private
name|PathChildrenCache
name|instancesCache
decl_stmt|;
comment|// Created on demand.
comment|/** Local hostname. */
specifier|protected
specifier|static
specifier|final
name|String
name|hostname
decl_stmt|;
static|static
block|{
name|String
name|localhost
init|=
literal|"localhost"
decl_stmt|;
try|try
block|{
name|localhost
operator|=
name|InetAddress
operator|.
name|getLocalHost
argument_list|()
operator|.
name|getCanonicalHostName
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownHostException
name|uhe
parameter_list|)
block|{
comment|// ignore
block|}
name|hostname
operator|=
name|localhost
expr_stmt|;
block|}
comment|/**    * @param rootNs A single root namespace override. Not recommended.    * @param nsPrefix The namespace prefix to use with default namespaces.    * @param userScopePathPrefix The prefix to use for the user-specific part of the path.    * @param workerPrefix The prefix to use for each worker znode.    * @param zkSaslLoginContextName SASL login context name for ZK security; null if not needed.    * @param zkPrincipal ZK security principal.    * @param zkKeytab ZK security keytab.    * @param aclsConfig A config setting to use to determine if ACLs should be verified.    */
specifier|public
name|ZkRegistryBase
parameter_list|(
name|String
name|instanceName
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|String
name|rootNs
parameter_list|,
name|String
name|nsPrefix
parameter_list|,
name|String
name|userScopePathPrefix
parameter_list|,
name|String
name|workerPrefix
parameter_list|,
name|String
name|zkSaslLoginContextName
parameter_list|,
name|String
name|zkPrincipal
parameter_list|,
name|String
name|zkKeytab
parameter_list|,
name|ConfVars
name|aclsConfig
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
operator|new
name|Configuration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|saslLoginContextName
operator|=
name|zkSaslLoginContextName
expr_stmt|;
name|this
operator|.
name|zkPrincipal
operator|=
name|zkPrincipal
expr_stmt|;
name|this
operator|.
name|zkKeytab
operator|=
name|zkKeytab
expr_stmt|;
if|if
condition|(
name|aclsConfig
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|doCheckAcls
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|aclsConfig
argument_list|)
expr_stmt|;
name|this
operator|.
name|disableMessage
operator|=
literal|"Set "
operator|+
name|aclsConfig
operator|.
name|varname
operator|+
literal|" to false to disable ACL validation"
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|doCheckAcls
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|disableMessage
operator|=
literal|""
expr_stmt|;
block|}
name|this
operator|.
name|conf
operator|.
name|addResource
argument_list|(
name|YarnConfiguration
operator|.
name|YARN_SITE_CONFIGURATION_FILE
argument_list|)
expr_stmt|;
name|String
name|zkEnsemble
init|=
name|getQuorumServers
argument_list|(
name|this
operator|.
name|conf
argument_list|)
decl_stmt|;
name|this
operator|.
name|encoder
operator|=
operator|new
name|RegistryUtils
operator|.
name|ServiceRecordMarshal
argument_list|()
expr_stmt|;
name|int
name|sessionTimeout
init|=
operator|(
name|int
operator|)
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_ZOOKEEPER_SESSION_TIMEOUT
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
name|int
name|baseSleepTime
init|=
operator|(
name|int
operator|)
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_ZOOKEEPER_CONNECTION_BASESLEEPTIME
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
name|int
name|maxRetries
init|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_ZOOKEEPER_CONNECTION_MAX_RETRIES
argument_list|)
decl_stmt|;
comment|// sample path: /llap-sasl/hiveuser/hostname/workers/worker-0000000
comment|// worker-0000000 is the sequence number which will be retained until session timeout. If a
comment|// worker does not respond due to communication interruptions it will retain the same sequence
comment|// number when it returns back. If session timeout expires, the node will be deleted and new
comment|// addition of the same node (restart) will get next sequence number
name|this
operator|.
name|userPathPrefix
operator|=
name|userScopePathPrefix
operator|+
name|getZkPathUser
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|workerNodePrefix
operator|=
name|workerPrefix
expr_stmt|;
name|this
operator|.
name|workersPath
operator|=
literal|"/"
operator|+
name|userPathPrefix
operator|+
literal|"/"
operator|+
name|instanceName
operator|+
literal|"/workers"
expr_stmt|;
name|this
operator|.
name|instancesCache
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|stateChangeListeners
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|pathToInstanceCache
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|nodeToInstanceCache
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
specifier|final
name|boolean
name|isSecure
init|=
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
decl_stmt|;
name|ACLProvider
name|zooKeeperAclProvider
init|=
operator|new
name|ACLProvider
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|ACL
argument_list|>
name|getDefaultAcl
parameter_list|()
block|{
comment|// We always return something from getAclForPath so this should not happen.
name|LOG
operator|.
name|warn
argument_list|(
literal|"getDefaultAcl was called"
argument_list|)
expr_stmt|;
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|ZooDefs
operator|.
name|Ids
operator|.
name|OPEN_ACL_UNSAFE
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|ACL
argument_list|>
name|getAclForPath
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isSecure
operator|||
name|path
operator|==
literal|null
operator|||
operator|!
name|path
operator|.
name|contains
argument_list|(
name|userPathPrefix
argument_list|)
condition|)
block|{
comment|// No security or the path is below the user path - full access.
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|ZooDefs
operator|.
name|Ids
operator|.
name|OPEN_ACL_UNSAFE
argument_list|)
return|;
block|}
return|return
name|createSecureAcls
argument_list|()
return|;
block|}
block|}
decl_stmt|;
if|if
condition|(
name|rootNs
operator|==
literal|null
condition|)
block|{
name|rootNs
operator|=
name|nsPrefix
operator|+
operator|(
name|isSecure
condition|?
name|SASL_NAMESPACE
else|:
name|UNSECURE_NAMESPACE
operator|)
expr_stmt|;
comment|// The normal path.
block|}
comment|// Create a CuratorFramework instance to be used as the ZooKeeper client
comment|// Use the zooKeeperAclProvider to create appropriate ACLs
name|this
operator|.
name|zooKeeperClient
operator|=
name|CuratorFrameworkFactory
operator|.
name|builder
argument_list|()
operator|.
name|connectString
argument_list|(
name|zkEnsemble
argument_list|)
operator|.
name|sessionTimeoutMs
argument_list|(
name|sessionTimeout
argument_list|)
operator|.
name|aclProvider
argument_list|(
name|zooKeeperAclProvider
argument_list|)
operator|.
name|namespace
argument_list|(
name|rootNs
argument_list|)
operator|.
name|retryPolicy
argument_list|(
operator|new
name|ExponentialBackoffRetry
argument_list|(
name|baseSleepTime
argument_list|,
name|maxRetries
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|ACL
argument_list|>
name|createSecureAcls
parameter_list|()
block|{
comment|// Read all to the world
name|List
argument_list|<
name|ACL
argument_list|>
name|nodeAcls
init|=
operator|new
name|ArrayList
argument_list|<
name|ACL
argument_list|>
argument_list|(
name|ZooDefs
operator|.
name|Ids
operator|.
name|READ_ACL_UNSAFE
argument_list|)
decl_stmt|;
comment|// Create/Delete/Write/Admin to creator
name|nodeAcls
operator|.
name|addAll
argument_list|(
name|ZooDefs
operator|.
name|Ids
operator|.
name|CREATOR_ALL_ACL
argument_list|)
expr_stmt|;
return|return
name|nodeAcls
return|;
block|}
comment|/**    * Get the ensemble server addresses from the configuration. The format is: host1:port,    * host2:port..    *    * @param conf    **/
specifier|private
name|String
name|getQuorumServers
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|String
index|[]
name|hosts
init|=
name|conf
operator|.
name|getTrimmedStrings
argument_list|(
name|ConfVars
operator|.
name|HIVE_ZOOKEEPER_QUORUM
operator|.
name|varname
argument_list|)
decl_stmt|;
name|String
name|port
init|=
name|conf
operator|.
name|get
argument_list|(
name|ConfVars
operator|.
name|HIVE_ZOOKEEPER_CLIENT_PORT
operator|.
name|varname
argument_list|,
name|ConfVars
operator|.
name|HIVE_ZOOKEEPER_CLIENT_PORT
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
decl_stmt|;
name|StringBuilder
name|quorum
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hosts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|quorum
operator|.
name|append
argument_list|(
name|hosts
index|[
name|i
index|]
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hosts
index|[
name|i
index|]
operator|.
name|contains
argument_list|(
literal|":"
argument_list|)
condition|)
block|{
comment|// if the hostname doesn't contain a port, add the configured port to hostname
name|quorum
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|quorum
operator|.
name|append
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|hosts
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|quorum
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|quorum
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|protected
specifier|abstract
name|String
name|getZkPathUser
parameter_list|(
name|Configuration
name|conf
parameter_list|)
function_decl|;
specifier|protected
specifier|final
name|String
name|registerServiceRecord
parameter_list|(
name|ServiceRecord
name|srv
parameter_list|)
throws|throws
name|IOException
block|{
comment|// restart sensitive instance id
name|srv
operator|.
name|set
argument_list|(
name|UNIQUE_IDENTIFIER
argument_list|,
name|uniq
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Create a znode under the rootNamespace parent for this instance of the server
try|try
block|{
comment|// PersistentEphemeralNode will make sure the ephemeral node created on server will be present
comment|// even under connection or session interruption (will automatically handle retries)
name|znode
operator|=
operator|new
name|PersistentEphemeralNode
argument_list|(
name|zooKeeperClient
argument_list|,
name|Mode
operator|.
name|EPHEMERAL_SEQUENTIAL
argument_list|,
name|workersPath
operator|+
literal|"/"
operator|+
name|workerNodePrefix
argument_list|,
name|encoder
operator|.
name|toBytes
argument_list|(
name|srv
argument_list|)
argument_list|)
expr_stmt|;
comment|// start the creation of znodes
name|znode
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// We'll wait for 120s for node creation
name|long
name|znodeCreationTimeout
init|=
literal|120
decl_stmt|;
if|if
condition|(
operator|!
name|znode
operator|.
name|waitForInitialCreate
argument_list|(
name|znodeCreationTimeout
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"Max znode creation wait time: "
operator|+
name|znodeCreationTimeout
operator|+
literal|"s exhausted"
argument_list|)
throw|;
block|}
name|znodePath
operator|=
name|znode
operator|.
name|getActualPath
argument_list|()
expr_stmt|;
if|if
condition|(
name|doCheckAcls
condition|)
block|{
try|try
block|{
name|checkAndSetAcls
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error validating or setting ACLs. "
operator|+
name|disableMessage
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|zooKeeperClient
operator|.
name|checkExists
argument_list|()
operator|.
name|forPath
argument_list|(
name|znodePath
argument_list|)
operator|==
literal|null
condition|)
block|{
comment|// No node exists, throw exception
throw|throw
operator|new
name|Exception
argument_list|(
literal|"Unable to create znode for this instance on ZooKeeper."
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to create a znode for this server instance"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|CloseableUtils
operator|.
name|closeQuietly
argument_list|(
name|znode
argument_list|)
expr_stmt|;
throw|throw
operator|(
name|e
operator|instanceof
name|IOException
operator|)
condition|?
operator|(
name|IOException
operator|)
name|e
else|:
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|uniq
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|protected
specifier|final
name|void
name|initializeWithoutRegisteringInternal
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Create a znode under the rootNamespace parent for this instance of the server
try|try
block|{
try|try
block|{
name|zooKeeperClient
operator|.
name|create
argument_list|()
operator|.
name|creatingParentsIfNeeded
argument_list|()
operator|.
name|forPath
argument_list|(
name|workersPath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NodeExistsException
name|ex
parameter_list|)
block|{
comment|// Ignore - this is expected.
block|}
if|if
condition|(
name|doCheckAcls
condition|)
block|{
try|try
block|{
name|checkAndSetAcls
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error validating or setting ACLs. "
operator|+
name|disableMessage
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to create a parent znode for the registry"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|(
name|e
operator|instanceof
name|IOException
operator|)
condition|?
operator|(
name|IOException
operator|)
name|e
else|:
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|checkAndSetAcls
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
return|return;
comment|// We are trying to check ACLs on the "workers" directory, which noone except us should be
comment|// able to write to. Higher-level directories shouldn't matter - we don't read them.
name|String
name|pathToCheck
init|=
name|workersPath
decl_stmt|;
name|List
argument_list|<
name|ACL
argument_list|>
name|acls
init|=
name|zooKeeperClient
operator|.
name|getACL
argument_list|()
operator|.
name|forPath
argument_list|(
name|pathToCheck
argument_list|)
decl_stmt|;
if|if
condition|(
name|acls
operator|==
literal|null
operator|||
name|acls
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Can there be no ACLs? There's some access (to get ACLs), so assume it means free for all.
name|LOG
operator|.
name|warn
argument_list|(
literal|"No ACLs on "
operator|+
name|pathToCheck
operator|+
literal|"; setting up ACLs. "
operator|+
name|disableMessage
argument_list|)
expr_stmt|;
name|setUpAcls
argument_list|(
name|pathToCheck
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// This could be brittle.
assert|assert
name|userNameFromPrincipal
operator|!=
literal|null
assert|;
name|Id
name|currentUser
init|=
operator|new
name|Id
argument_list|(
literal|"sasl"
argument_list|,
name|userNameFromPrincipal
argument_list|)
decl_stmt|;
for|for
control|(
name|ACL
name|acl
range|:
name|acls
control|)
block|{
if|if
condition|(
operator|(
name|acl
operator|.
name|getPerms
argument_list|()
operator|&
operator|~
name|ZooDefs
operator|.
name|Perms
operator|.
name|READ
operator|)
operator|==
literal|0
operator|||
name|currentUser
operator|.
name|equals
argument_list|(
name|acl
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
comment|// Read permission/no permissions, or the expected user.
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"The ACL "
operator|+
name|acl
operator|+
literal|" is unnacceptable for "
operator|+
name|pathToCheck
operator|+
literal|"; setting up ACLs. "
operator|+
name|disableMessage
argument_list|)
expr_stmt|;
name|setUpAcls
argument_list|(
name|pathToCheck
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
specifier|private
name|void
name|setUpAcls
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|ACL
argument_list|>
name|acls
init|=
name|createSecureAcls
argument_list|()
decl_stmt|;
name|LinkedList
argument_list|<
name|String
argument_list|>
name|paths
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|paths
operator|.
name|add
argument_list|(
name|path
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|paths
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
name|currentPath
init|=
name|paths
operator|.
name|poll
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|children
init|=
name|zooKeeperClient
operator|.
name|getChildren
argument_list|()
operator|.
name|forPath
argument_list|(
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|children
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|child
range|:
name|children
control|)
block|{
name|paths
operator|.
name|add
argument_list|(
name|currentPath
operator|+
literal|"/"
operator|+
name|child
argument_list|)
expr_stmt|;
block|}
block|}
name|zooKeeperClient
operator|.
name|setACL
argument_list|()
operator|.
name|withACL
argument_list|(
name|acls
argument_list|)
operator|.
name|forPath
argument_list|(
name|currentPath
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|addToCache
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|host
parameter_list|,
name|InstanceType
name|instance
parameter_list|)
block|{
name|instanceCacheLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|putInCache
argument_list|(
name|path
argument_list|,
name|pathToInstanceCache
argument_list|,
name|instance
argument_list|)
expr_stmt|;
name|putInCache
argument_list|(
name|host
argument_list|,
name|nodeToInstanceCache
argument_list|,
name|instance
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|instanceCacheLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Added path={}, host={} instance={} to cache."
operator|+
literal|" pathToInstanceCache:size={}, nodeToInstanceCache:size={}"
argument_list|,
name|path
argument_list|,
name|host
argument_list|,
name|instance
argument_list|,
name|pathToInstanceCache
operator|.
name|size
argument_list|()
argument_list|,
name|nodeToInstanceCache
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|removeFromCache
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|host
parameter_list|)
block|{
name|instanceCacheLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|pathToInstanceCache
operator|.
name|remove
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|nodeToInstanceCache
operator|.
name|remove
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|instanceCacheLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removed path={}, host={} from cache."
operator|+
literal|" pathToInstanceCache:size={}, nodeToInstanceCache:size={}"
argument_list|,
name|path
argument_list|,
name|host
argument_list|,
name|pathToInstanceCache
operator|.
name|size
argument_list|()
argument_list|,
name|nodeToInstanceCache
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|putInCache
parameter_list|(
name|String
name|key
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|InstanceType
argument_list|>
argument_list|>
name|cache
parameter_list|,
name|InstanceType
name|instance
parameter_list|)
block|{
name|Set
argument_list|<
name|InstanceType
argument_list|>
name|instanceSet
init|=
name|cache
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|instanceSet
operator|==
literal|null
condition|)
block|{
name|instanceSet
operator|=
name|Sets
operator|.
name|newHashSet
argument_list|()
expr_stmt|;
name|cache
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|instanceSet
argument_list|)
expr_stmt|;
block|}
name|instanceSet
operator|.
name|add
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|final
name|void
name|populateCache
parameter_list|(
name|PathChildrenCache
name|instancesCache
parameter_list|,
name|boolean
name|doInvokeListeners
parameter_list|)
block|{
for|for
control|(
name|ChildData
name|childData
range|:
name|instancesCache
operator|.
name|getCurrentData
argument_list|()
control|)
block|{
name|byte
index|[]
name|data
init|=
name|getWorkerData
argument_list|(
name|childData
argument_list|,
name|workerNodePrefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
continue|continue;
name|String
name|nodeName
init|=
name|extractNodeName
argument_list|(
name|childData
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|nodeName
operator|.
name|startsWith
argument_list|(
name|workerNodePrefix
argument_list|)
condition|)
continue|continue;
name|int
name|ephSeqVersion
init|=
name|extractSeqNum
argument_list|(
name|nodeName
argument_list|)
decl_stmt|;
try|try
block|{
name|ServiceRecord
name|srv
init|=
name|encoder
operator|.
name|fromBytes
argument_list|(
name|childData
operator|.
name|getPath
argument_list|()
argument_list|,
name|data
argument_list|)
decl_stmt|;
name|InstanceType
name|instance
init|=
name|createServiceInstance
argument_list|(
name|srv
argument_list|)
decl_stmt|;
name|addToCache
argument_list|(
name|childData
operator|.
name|getPath
argument_list|()
argument_list|,
name|instance
operator|.
name|getHost
argument_list|()
argument_list|,
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|doInvokeListeners
condition|)
block|{
for|for
control|(
name|ServiceInstanceStateChangeListener
argument_list|<
name|InstanceType
argument_list|>
name|listener
range|:
name|stateChangeListeners
control|)
block|{
name|listener
operator|.
name|onCreate
argument_list|(
name|instance
argument_list|,
name|ephSeqVersion
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to decode data for zkpath: {}."
operator|+
literal|" Ignoring from current instances list.."
argument_list|,
name|childData
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|protected
specifier|abstract
name|InstanceType
name|createServiceInstance
parameter_list|(
name|ServiceRecord
name|srv
parameter_list|)
throws|throws
name|IOException
function_decl|;
specifier|protected
specifier|static
specifier|final
name|byte
index|[]
name|getWorkerData
parameter_list|(
name|ChildData
name|childData
parameter_list|,
name|String
name|workerNodePrefix
parameter_list|)
block|{
if|if
condition|(
name|childData
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|byte
index|[]
name|data
init|=
name|childData
operator|.
name|getData
argument_list|()
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
operator|!
name|extractNodeName
argument_list|(
name|childData
argument_list|)
operator|.
name|startsWith
argument_list|(
name|workerNodePrefix
argument_list|)
condition|)
return|return
literal|null
return|;
return|return
name|data
return|;
block|}
specifier|private
class|class
name|InstanceStateChangeListener
implements|implements
name|PathChildrenCacheListener
block|{
specifier|private
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|InstanceStateChangeListener
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|childEvent
parameter_list|(
specifier|final
name|CuratorFramework
name|client
parameter_list|,
specifier|final
name|PathChildrenCacheEvent
name|event
parameter_list|)
throws|throws
name|Exception
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|client
operator|!=
literal|null
operator|&&
name|client
operator|.
name|getState
argument_list|()
operator|==
name|CuratorFrameworkState
operator|.
name|STARTED
argument_list|,
literal|"client is not started"
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|ChildData
name|childData
init|=
name|event
operator|.
name|getData
argument_list|()
decl_stmt|;
if|if
condition|(
name|childData
operator|==
literal|null
condition|)
return|return;
name|String
name|nodeName
init|=
name|extractNodeName
argument_list|(
name|childData
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|nodeName
operator|.
name|startsWith
argument_list|(
name|workerNodePrefix
argument_list|)
condition|)
return|return;
name|LOG
operator|.
name|info
argument_list|(
literal|"{} for zknode {}"
argument_list|,
name|event
operator|.
name|getType
argument_list|()
argument_list|,
name|childData
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|InstanceType
name|instance
init|=
name|extractServiceInstance
argument_list|(
name|event
argument_list|,
name|childData
argument_list|)
decl_stmt|;
name|int
name|ephSeqVersion
init|=
name|extractSeqNum
argument_list|(
name|nodeName
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|event
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|CHILD_ADDED
case|:
name|addToCache
argument_list|(
name|childData
operator|.
name|getPath
argument_list|()
argument_list|,
name|instance
operator|.
name|getHost
argument_list|()
argument_list|,
name|instance
argument_list|)
expr_stmt|;
for|for
control|(
name|ServiceInstanceStateChangeListener
argument_list|<
name|InstanceType
argument_list|>
name|listener
range|:
name|stateChangeListeners
control|)
block|{
name|listener
operator|.
name|onCreate
argument_list|(
name|instance
argument_list|,
name|ephSeqVersion
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CHILD_UPDATED
case|:
name|addToCache
argument_list|(
name|childData
operator|.
name|getPath
argument_list|()
argument_list|,
name|instance
operator|.
name|getHost
argument_list|()
argument_list|,
name|instance
argument_list|)
expr_stmt|;
for|for
control|(
name|ServiceInstanceStateChangeListener
argument_list|<
name|InstanceType
argument_list|>
name|listener
range|:
name|stateChangeListeners
control|)
block|{
name|listener
operator|.
name|onUpdate
argument_list|(
name|instance
argument_list|,
name|ephSeqVersion
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CHILD_REMOVED
case|:
name|removeFromCache
argument_list|(
name|childData
operator|.
name|getPath
argument_list|()
argument_list|,
name|instance
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|ServiceInstanceStateChangeListener
argument_list|<
name|InstanceType
argument_list|>
name|listener
range|:
name|stateChangeListeners
control|)
block|{
name|listener
operator|.
name|onRemove
argument_list|(
name|instance
argument_list|,
name|ephSeqVersion
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|// Ignore all the other events; logged above.
block|}
block|}
block|}
block|}
comment|// The real implementation for the instanceset... instanceset has its own copy of the
comment|// ZK cache yet completely depends on the parent in every other aspect and is thus unneeded.
specifier|protected
specifier|final
name|int
name|sizeInternal
parameter_list|()
block|{
comment|// not using the path child cache here as there could be more than 1 path per host (worker and slot znodes)
return|return
name|nodeToInstanceCache
operator|.
name|size
argument_list|()
return|;
block|}
specifier|protected
specifier|final
name|Set
argument_list|<
name|InstanceType
argument_list|>
name|getByHostInternal
parameter_list|(
name|String
name|host
parameter_list|)
block|{
name|Set
argument_list|<
name|InstanceType
argument_list|>
name|byHost
init|=
name|nodeToInstanceCache
operator|.
name|get
argument_list|(
name|host
argument_list|)
decl_stmt|;
name|byHost
operator|=
operator|(
name|byHost
operator|==
literal|null
operator|)
condition|?
name|Sets
operator|.
expr|<
name|InstanceType
operator|>
name|newHashSet
argument_list|()
else|:
name|byHost
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Returning "
operator|+
name|byHost
operator|.
name|size
argument_list|()
operator|+
literal|" hosts for locality allocation on "
operator|+
name|host
argument_list|)
expr_stmt|;
block|}
return|return
name|byHost
return|;
block|}
specifier|protected
specifier|final
name|Collection
argument_list|<
name|InstanceType
argument_list|>
name|getAllInternal
parameter_list|()
block|{
name|Set
argument_list|<
name|InstanceType
argument_list|>
name|instances
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Set
argument_list|<
name|InstanceType
argument_list|>
name|instanceSet
range|:
name|pathToInstanceCache
operator|.
name|values
argument_list|()
control|)
block|{
name|instances
operator|.
name|addAll
argument_list|(
name|instanceSet
argument_list|)
expr_stmt|;
block|}
return|return
name|instances
return|;
block|}
specifier|private
specifier|static
name|String
name|extractNodeName
parameter_list|(
name|ChildData
name|childData
parameter_list|)
block|{
name|String
name|nodeName
init|=
name|childData
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|int
name|ix
init|=
name|nodeName
operator|.
name|lastIndexOf
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
if|if
condition|(
name|ix
operator|>=
literal|0
condition|)
block|{
name|nodeName
operator|=
name|nodeName
operator|.
name|substring
argument_list|(
name|ix
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|nodeName
return|;
block|}
specifier|private
name|InstanceType
name|extractServiceInstance
parameter_list|(
name|PathChildrenCacheEvent
name|event
parameter_list|,
name|ChildData
name|childData
parameter_list|)
block|{
name|byte
index|[]
name|data
init|=
name|childData
operator|.
name|getData
argument_list|()
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
return|return
literal|null
return|;
try|try
block|{
name|ServiceRecord
name|srv
init|=
name|encoder
operator|.
name|fromBytes
argument_list|(
name|event
operator|.
name|getData
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
name|data
argument_list|)
decl_stmt|;
return|return
name|createServiceInstance
argument_list|(
name|srv
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to decode data for zknode: {}."
operator|+
literal|" Dropping notification of type: {}"
argument_list|,
name|childData
operator|.
name|getPath
argument_list|()
argument_list|,
name|event
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
specifier|public
specifier|synchronized
name|void
name|registerStateChangeListener
parameter_list|(
name|ServiceInstanceStateChangeListener
argument_list|<
name|InstanceType
argument_list|>
name|listener
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureInstancesCache
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|stateChangeListeners
operator|.
name|add
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"resource"
argument_list|)
comment|// Bogus warnings despite closeQuietly.
specifier|protected
specifier|final
specifier|synchronized
name|PathChildrenCache
name|ensureInstancesCache
parameter_list|(
name|long
name|clusterReadyTimeoutMs
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|zooKeeperClient
operator|!=
literal|null
operator|&&
name|zooKeeperClient
operator|.
name|getState
argument_list|()
operator|==
name|CuratorFrameworkState
operator|.
name|STARTED
argument_list|,
literal|"client is not started"
argument_list|)
expr_stmt|;
comment|// lazily create PathChildrenCache
name|PathChildrenCache
name|instancesCache
init|=
name|this
operator|.
name|instancesCache
decl_stmt|;
if|if
condition|(
name|instancesCache
operator|!=
literal|null
condition|)
return|return
name|instancesCache
return|;
name|ExecutorService
name|tp
init|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
literal|1
argument_list|,
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
literal|"StateChangeNotificationHandler"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|startTimeNs
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|,
name|deltaNs
init|=
name|clusterReadyTimeoutMs
operator|*
literal|1000000L
decl_stmt|;
name|long
name|sleepTimeMs
init|=
name|Math
operator|.
name|min
argument_list|(
literal|16
argument_list|,
name|clusterReadyTimeoutMs
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|instancesCache
operator|=
operator|new
name|PathChildrenCache
argument_list|(
name|zooKeeperClient
argument_list|,
name|workersPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|instancesCache
operator|.
name|getListenable
argument_list|()
operator|.
name|addListener
argument_list|(
operator|new
name|InstanceStateChangeListener
argument_list|()
argument_list|,
name|tp
argument_list|)
expr_stmt|;
try|try
block|{
name|instancesCache
operator|.
name|start
argument_list|(
name|PathChildrenCache
operator|.
name|StartMode
operator|.
name|BUILD_INITIAL_CACHE
argument_list|)
expr_stmt|;
name|this
operator|.
name|instancesCache
operator|=
name|instancesCache
expr_stmt|;
return|return
name|instancesCache
return|;
block|}
catch|catch
parameter_list|(
name|InvalidACLException
name|e
parameter_list|)
block|{
comment|// PathChildrenCache tried to mkdir when the znode wasn't there, and failed.
name|CloseableUtils
operator|.
name|closeQuietly
argument_list|(
name|instancesCache
argument_list|)
expr_stmt|;
name|long
name|elapsedNs
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTimeNs
decl_stmt|;
if|if
condition|(
name|deltaNs
operator|==
literal|0
operator|||
name|deltaNs
operator|<=
name|elapsedNs
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to start curator PathChildrenCache"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"The cluster is not started yet (InvalidACL); will retry"
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|sleepTimeMs
argument_list|,
operator|(
name|deltaNs
operator|-
name|elapsedNs
operator|)
operator|/
literal|1000000L
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e1
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Interrupted while retrying the PathChildrenCache startup"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e1
argument_list|)
throw|;
block|}
name|sleepTimeMs
operator|=
name|sleepTimeMs
operator|<<
literal|1
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|CloseableUtils
operator|.
name|closeQuietly
argument_list|(
name|instancesCache
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to start curator PathChildrenCache"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
specifier|public
name|void
name|start
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|zooKeeperClient
operator|!=
literal|null
condition|)
block|{
name|String
name|principal
init|=
name|ZookeeperUtils
operator|.
name|setupZookeeperAuth
argument_list|(
name|conf
argument_list|,
name|saslLoginContextName
argument_list|,
name|zkPrincipal
argument_list|,
name|zkKeytab
argument_list|)
decl_stmt|;
if|if
condition|(
name|principal
operator|!=
literal|null
condition|)
block|{
name|userNameFromPrincipal
operator|=
name|LlapUtil
operator|.
name|getUserNameFromPrincipal
argument_list|(
name|principal
argument_list|)
expr_stmt|;
block|}
name|zooKeeperClient
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|// Init closeable utils in case register is not called (see HIVE-13322)
name|CloseableUtils
operator|.
name|class
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|stop
parameter_list|()
block|{
name|CloseableUtils
operator|.
name|closeQuietly
argument_list|(
name|znode
argument_list|)
expr_stmt|;
name|CloseableUtils
operator|.
name|closeQuietly
argument_list|(
name|instancesCache
argument_list|)
expr_stmt|;
name|CloseableUtils
operator|.
name|closeQuietly
argument_list|(
name|zooKeeperClient
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|final
name|Set
argument_list|<
name|InstanceType
argument_list|>
name|getInstancesByPath
parameter_list|(
name|String
name|path
parameter_list|)
block|{
return|return
name|pathToInstanceCache
operator|.
name|get
argument_list|(
name|path
argument_list|)
return|;
block|}
specifier|protected
specifier|final
name|String
name|getRegistrationZnodePath
parameter_list|()
block|{
return|return
name|znodePath
return|;
block|}
specifier|private
name|int
name|extractSeqNum
parameter_list|(
name|String
name|nodeName
parameter_list|)
block|{
comment|// Extract the sequence number of this ephemeral-sequential znode.
name|String
name|ephSeqVersionStr
init|=
name|nodeName
operator|.
name|substring
argument_list|(
name|workerNodePrefix
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|ephSeqVersionStr
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot parse "
operator|+
name|ephSeqVersionStr
operator|+
literal|" from "
operator|+
name|nodeName
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
end_class

end_unit

