begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Timestamp
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimeZone
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|TestCase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|HiveDecimal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableUtils
import|;
end_import

begin_class
specifier|public
class|class
name|TestTimestampWritable
extends|extends
name|TestCase
block|{
specifier|private
specifier|static
name|DateFormat
name|DATE_FORMAT
init|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"yyyy-MM-dd HH:mm:ss"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|HAS_DECIMAL_MASK
init|=
literal|0x80000000
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|MAX_ADDITIONAL_SECONDS_BITS
init|=
literal|0x418937
decl_stmt|;
specifier|private
specifier|static
name|long
name|MIN_FOUR_DIGIT_YEAR_MILLIS
init|=
name|parseToMillis
argument_list|(
literal|"0001-01-01 00:00:00"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|long
name|MAX_FOUR_DIGIT_YEAR_MILLIS
init|=
name|parseToMillis
argument_list|(
literal|"9999-01-01 00:00:00"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|int
name|BILLION
init|=
literal|1000
operator|*
literal|1000
operator|*
literal|1000
decl_stmt|;
specifier|private
specifier|static
name|long
name|getSeconds
parameter_list|(
name|Timestamp
name|ts
parameter_list|)
block|{
comment|// To compute seconds, we first subtract the milliseconds stored in the nanos field of the
comment|// Timestamp from the result of getTime().
name|long
name|seconds
init|=
operator|(
name|ts
operator|.
name|getTime
argument_list|()
operator|-
name|ts
operator|.
name|getNanos
argument_list|()
operator|/
literal|1000000
operator|)
operator|/
literal|1000
decl_stmt|;
comment|// It should also be possible to calculate this based on ts.getTime() only.
name|assertEquals
argument_list|(
name|seconds
argument_list|,
name|TimestampWritable
operator|.
name|millisToSeconds
argument_list|(
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|seconds
return|;
block|}
specifier|private
specifier|static
name|long
name|parseToMillis
parameter_list|(
name|String
name|s
parameter_list|)
block|{
try|try
block|{
return|return
name|DATE_FORMAT
operator|.
name|parse
argument_list|(
name|s
argument_list|)
operator|.
name|getTime
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|setUp
parameter_list|()
block|{
name|TimeZone
operator|.
name|setDefault
argument_list|(
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
literal|"UTC"
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|String
name|normalizeTimestampStr
parameter_list|(
name|String
name|timestampStr
parameter_list|)
block|{
if|if
condition|(
name|timestampStr
operator|.
name|endsWith
argument_list|(
literal|".0"
argument_list|)
condition|)
block|{
return|return
name|timestampStr
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|timestampStr
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
return|;
block|}
return|return
name|timestampStr
return|;
block|}
specifier|private
specifier|static
name|void
name|assertTSWEquals
parameter_list|(
name|TimestampWritable
name|expected
parameter_list|,
name|TimestampWritable
name|actual
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|normalizeTimestampStr
argument_list|(
name|expected
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|normalizeTimestampStr
argument_list|(
name|actual
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|actual
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expected
operator|.
name|getTimestamp
argument_list|()
argument_list|,
name|actual
operator|.
name|getTimestamp
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|TimestampWritable
name|deserializeFromBytes
parameter_list|(
name|byte
index|[]
name|tsBytes
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteArrayInputStream
name|bais
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|tsBytes
argument_list|)
decl_stmt|;
name|DataInputStream
name|dis
init|=
operator|new
name|DataInputStream
argument_list|(
name|bais
argument_list|)
decl_stmt|;
name|TimestampWritable
name|deserTSW
init|=
operator|new
name|TimestampWritable
argument_list|()
decl_stmt|;
name|deserTSW
operator|.
name|readFields
argument_list|(
name|dis
argument_list|)
expr_stmt|;
return|return
name|deserTSW
return|;
block|}
specifier|private
specifier|static
name|int
name|reverseNanos
parameter_list|(
name|int
name|nanos
parameter_list|)
block|{
if|if
condition|(
name|nanos
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|nanos
operator|<
literal|0
operator|||
name|nanos
operator|>=
literal|1000
operator|*
literal|1000
operator|*
literal|1000
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid nanosecond value: "
operator|+
name|nanos
argument_list|)
throw|;
block|}
name|int
name|x
init|=
name|nanos
decl_stmt|;
name|StringBuilder
name|reversed
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
name|reversed
operator|.
name|append
argument_list|(
call|(
name|char
call|)
argument_list|(
literal|'0'
operator|+
name|x
operator|%
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|/=
literal|10
expr_stmt|;
block|}
name|int
name|result
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|reversed
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|nanos
operator|<
literal|100
operator|*
literal|1000
operator|*
literal|1000
condition|)
block|{
name|result
operator|*=
literal|10
expr_stmt|;
name|nanos
operator|*=
literal|10
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|private
specifier|static
name|byte
index|[]
name|serializeToBytes
parameter_list|(
name|Writable
name|w
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|DataOutputStream
name|dos
init|=
operator|new
name|DataOutputStream
argument_list|(
name|baos
argument_list|)
decl_stmt|;
name|w
operator|.
name|write
argument_list|(
name|dos
argument_list|)
expr_stmt|;
return|return
name|baos
operator|.
name|toByteArray
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|Byte
argument_list|>
name|toList
parameter_list|(
name|byte
index|[]
name|a
parameter_list|)
block|{
name|List
argument_list|<
name|Byte
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|Byte
argument_list|>
argument_list|(
name|a
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|byte
name|b
range|:
name|a
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
comment|/**    * Pad the given byte array with the given number of bytes in the beginning. The padding bytes    * deterministically depend on the passed data.    */
specifier|private
specifier|static
name|byte
index|[]
name|padBytes
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
name|bytes
operator|.
name|length
operator|+
name|count
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
comment|// Fill the prefix bytes with deterministic data based on the actual meaningful data.
name|result
index|[
name|i
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|bytes
index|[
name|i
operator|%
name|bytes
operator|.
name|length
index|]
operator|*
literal|37
operator|+
literal|19
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
name|count
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
specifier|static
name|TimestampWritable
name|serializeDeserializeAndCheckTimestamp
parameter_list|(
name|Timestamp
name|ts
parameter_list|)
throws|throws
name|IOException
block|{
name|TimestampWritable
name|tsw
init|=
operator|new
name|TimestampWritable
argument_list|(
name|ts
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ts
argument_list|,
name|tsw
operator|.
name|getTimestamp
argument_list|()
argument_list|)
expr_stmt|;
name|byte
index|[]
name|tsBytes
init|=
name|serializeToBytes
argument_list|(
name|tsw
argument_list|)
decl_stmt|;
name|TimestampWritable
name|deserTSW
init|=
name|deserializeFromBytes
argument_list|(
name|tsBytes
argument_list|)
decl_stmt|;
name|assertTSWEquals
argument_list|(
name|tsw
argument_list|,
name|deserTSW
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ts
argument_list|,
name|deserTSW
operator|.
name|getTimestamp
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|tsBytes
operator|.
name|length
argument_list|,
name|tsw
operator|.
name|getTotalLength
argument_list|()
argument_list|)
expr_stmt|;
comment|// Also convert to/from binary-sortable representation.
name|int
name|binarySortableOffset
init|=
name|Math
operator|.
name|abs
argument_list|(
name|tsw
operator|.
name|hashCode
argument_list|()
argument_list|)
operator|%
literal|10
decl_stmt|;
name|byte
index|[]
name|binarySortableBytes
init|=
name|padBytes
argument_list|(
name|tsw
operator|.
name|getBinarySortable
argument_list|()
argument_list|,
name|binarySortableOffset
argument_list|)
decl_stmt|;
name|TimestampWritable
name|fromBinSort
init|=
operator|new
name|TimestampWritable
argument_list|()
decl_stmt|;
name|fromBinSort
operator|.
name|setBinarySortable
argument_list|(
name|binarySortableBytes
argument_list|,
name|binarySortableOffset
argument_list|)
expr_stmt|;
name|assertTSWEquals
argument_list|(
name|tsw
argument_list|,
name|fromBinSort
argument_list|)
expr_stmt|;
name|long
name|timeSeconds
init|=
name|ts
operator|.
name|getTime
argument_list|()
operator|/
literal|1000
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|timeSeconds
operator|&&
name|timeSeconds
operator|<=
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|assertEquals
argument_list|(
operator|new
name|Timestamp
argument_list|(
name|timeSeconds
operator|*
literal|1000
argument_list|)
argument_list|,
name|fromIntAndVInts
argument_list|(
operator|(
name|int
operator|)
name|timeSeconds
argument_list|,
literal|0
argument_list|)
operator|.
name|getTimestamp
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|nanos
init|=
name|reverseNanos
argument_list|(
name|ts
operator|.
name|getNanos
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ts
argument_list|,
name|fromIntAndVInts
argument_list|(
operator|(
name|int
operator|)
name|timeSeconds
operator||
operator|(
name|nanos
operator|!=
literal|0
condition|?
name|HAS_DECIMAL_MASK
else|:
literal|0
operator|)
argument_list|,
name|nanos
argument_list|)
operator|.
name|getTimestamp
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|ts
operator|.
name|getNanos
argument_list|()
argument_list|,
name|tsw
operator|.
name|getNanos
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|getSeconds
argument_list|(
name|ts
argument_list|)
argument_list|,
name|tsw
operator|.
name|getSeconds
argument_list|()
argument_list|)
expr_stmt|;
comment|// Test various set methods and copy constructors.
block|{
name|TimestampWritable
name|tsSet1
init|=
operator|new
name|TimestampWritable
argument_list|()
decl_stmt|;
comment|// make the offset non-zero to keep things interesting.
name|int
name|offset
init|=
name|Math
operator|.
name|abs
argument_list|(
name|ts
operator|.
name|hashCode
argument_list|()
operator|%
literal|32
argument_list|)
decl_stmt|;
name|byte
index|[]
name|shiftedBytes
init|=
name|padBytes
argument_list|(
name|tsBytes
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|tsSet1
operator|.
name|set
argument_list|(
name|shiftedBytes
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|assertTSWEquals
argument_list|(
name|tsw
argument_list|,
name|tsSet1
argument_list|)
expr_stmt|;
name|TimestampWritable
name|tswShiftedBytes
init|=
operator|new
name|TimestampWritable
argument_list|(
name|shiftedBytes
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|assertTSWEquals
argument_list|(
name|tsw
argument_list|,
name|tswShiftedBytes
argument_list|)
expr_stmt|;
name|assertTSWEquals
argument_list|(
name|tsw
argument_list|,
name|deserializeFromBytes
argument_list|(
name|serializeToBytes
argument_list|(
name|tswShiftedBytes
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|{
name|TimestampWritable
name|tsSet2
init|=
operator|new
name|TimestampWritable
argument_list|()
decl_stmt|;
name|tsSet2
operator|.
name|set
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|assertTSWEquals
argument_list|(
name|tsw
argument_list|,
name|tsSet2
argument_list|)
expr_stmt|;
block|}
block|{
name|TimestampWritable
name|tsSet3
init|=
operator|new
name|TimestampWritable
argument_list|()
decl_stmt|;
name|tsSet3
operator|.
name|set
argument_list|(
name|tsw
argument_list|)
expr_stmt|;
name|assertTSWEquals
argument_list|(
name|tsw
argument_list|,
name|tsSet3
argument_list|)
expr_stmt|;
block|}
block|{
name|TimestampWritable
name|tsSet4
init|=
operator|new
name|TimestampWritable
argument_list|()
decl_stmt|;
name|tsSet4
operator|.
name|set
argument_list|(
name|deserTSW
argument_list|)
expr_stmt|;
name|assertTSWEquals
argument_list|(
name|tsw
argument_list|,
name|tsSet4
argument_list|)
expr_stmt|;
block|}
name|double
name|expectedDbl
init|=
name|getSeconds
argument_list|(
name|ts
argument_list|)
operator|+
literal|1e-9d
operator|*
name|ts
operator|.
name|getNanos
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|tsw
operator|.
name|getDouble
argument_list|()
operator|-
name|expectedDbl
argument_list|)
operator|<
literal|1e-10d
argument_list|)
expr_stmt|;
return|return
name|deserTSW
return|;
block|}
specifier|private
specifier|static
name|int
name|randomNanos
parameter_list|(
name|Random
name|rand
parameter_list|,
name|int
name|decimalDigits
parameter_list|)
block|{
comment|// Only keep the most significant decimalDigits digits.
name|int
name|nanos
init|=
name|rand
operator|.
name|nextInt
argument_list|(
name|BILLION
argument_list|)
decl_stmt|;
return|return
name|nanos
operator|-
name|nanos
operator|%
operator|(
name|int
operator|)
name|Math
operator|.
name|pow
argument_list|(
literal|10
argument_list|,
literal|9
operator|-
name|decimalDigits
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|randomNanos
parameter_list|(
name|Random
name|rand
parameter_list|)
block|{
return|return
name|randomNanos
argument_list|(
name|rand
argument_list|,
name|rand
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|void
name|checkTimestampWithAndWithoutNanos
parameter_list|(
name|Timestamp
name|ts
parameter_list|,
name|int
name|nanos
parameter_list|)
throws|throws
name|IOException
block|{
name|serializeDeserializeAndCheckTimestamp
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|ts
operator|.
name|setNanos
argument_list|(
name|nanos
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|serializeDeserializeAndCheckTimestamp
argument_list|(
name|ts
argument_list|)
operator|.
name|getNanos
argument_list|()
argument_list|,
name|nanos
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|TimestampWritable
name|fromIntAndVInts
parameter_list|(
name|int
name|i
parameter_list|,
name|long
modifier|...
name|vints
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|DataOutputStream
name|dos
init|=
operator|new
name|DataOutputStream
argument_list|(
name|baos
argument_list|)
decl_stmt|;
name|dos
operator|.
name|writeInt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
name|HAS_DECIMAL_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|long
name|vi
range|:
name|vints
control|)
block|{
name|WritableUtils
operator|.
name|writeVLong
argument_list|(
name|dos
argument_list|,
name|vi
argument_list|)
expr_stmt|;
block|}
block|}
name|byte
index|[]
name|bytes
init|=
name|baos
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|TimestampWritable
name|tsw
init|=
name|deserializeFromBytes
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|toList
argument_list|(
name|bytes
argument_list|)
argument_list|,
name|toList
argument_list|(
name|serializeToBytes
argument_list|(
name|tsw
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tsw
return|;
block|}
specifier|public
name|void
name|testReverseNanos
parameter_list|()
block|{
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|reverseNanos
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|120000000
argument_list|,
name|reverseNanos
argument_list|(
literal|21
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|32100000
argument_list|,
name|reverseNanos
argument_list|(
literal|1230
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|reverseNanos
argument_list|(
literal|500000000
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|987654321
argument_list|,
name|reverseNanos
argument_list|(
literal|123456789
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|12345678
argument_list|,
name|reverseNanos
argument_list|(
literal|876543210
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test serializing and deserializing timestamps that can be represented by a number of seconds    * from 0 to 2147483647 since the UNIX epoch.    */
specifier|public
name|void
name|testTimestampsWithinPositiveIntRange
parameter_list|()
throws|throws
name|IOException
block|{
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|(
literal|294722773L
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10000
condition|;
operator|++
name|i
control|)
block|{
name|long
name|millis
init|=
operator|(
operator|(
name|long
operator|)
name|rand
operator|.
name|nextInt
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
operator|)
operator|*
literal|1000
decl_stmt|;
name|checkTimestampWithAndWithoutNanos
argument_list|(
operator|new
name|Timestamp
argument_list|(
name|millis
argument_list|)
argument_list|,
name|randomNanos
argument_list|(
name|rand
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|long
name|randomMillis
parameter_list|(
name|long
name|minMillis
parameter_list|,
name|long
name|maxMillis
parameter_list|,
name|Random
name|rand
parameter_list|)
block|{
return|return
name|minMillis
operator|+
call|(
name|long
call|)
argument_list|(
operator|(
name|maxMillis
operator|-
name|minMillis
operator|)
operator|*
name|rand
operator|.
name|nextDouble
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Test timestamps that don't necessarily fit between 1970 and 2038. This depends on HIVE-4525    * being fixed.    */
specifier|public
name|void
name|testTimestampsOutsidePositiveIntRange
parameter_list|()
throws|throws
name|IOException
block|{
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|(
literal|789149717L
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10000
condition|;
operator|++
name|i
control|)
block|{
name|long
name|millis
init|=
name|randomMillis
argument_list|(
name|MIN_FOUR_DIGIT_YEAR_MILLIS
argument_list|,
name|MAX_FOUR_DIGIT_YEAR_MILLIS
argument_list|,
name|rand
argument_list|)
decl_stmt|;
name|checkTimestampWithAndWithoutNanos
argument_list|(
operator|new
name|Timestamp
argument_list|(
name|millis
argument_list|)
argument_list|,
name|randomNanos
argument_list|(
name|rand
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|testTimestampsInFullRange
parameter_list|()
throws|throws
name|IOException
block|{
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|(
literal|2904974913L
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10000
condition|;
operator|++
name|i
control|)
block|{
name|checkTimestampWithAndWithoutNanos
argument_list|(
operator|new
name|Timestamp
argument_list|(
name|rand
operator|.
name|nextLong
argument_list|()
argument_list|)
argument_list|,
name|randomNanos
argument_list|(
name|rand
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|testToFromDouble
parameter_list|()
block|{
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|(
literal|294729777L
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|nanosPrecision
init|=
literal|0
init|;
name|nanosPrecision
operator|<=
literal|4
condition|;
operator|++
name|nanosPrecision
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10000
condition|;
operator|++
name|i
control|)
block|{
name|long
name|millis
init|=
name|randomMillis
argument_list|(
name|MIN_FOUR_DIGIT_YEAR_MILLIS
argument_list|,
name|MAX_FOUR_DIGIT_YEAR_MILLIS
argument_list|,
name|rand
argument_list|)
decl_stmt|;
name|Timestamp
name|ts
init|=
operator|new
name|Timestamp
argument_list|(
name|millis
argument_list|)
decl_stmt|;
name|int
name|nanos
init|=
name|randomNanos
argument_list|(
name|rand
argument_list|,
name|nanosPrecision
argument_list|)
decl_stmt|;
name|ts
operator|.
name|setNanos
argument_list|(
name|nanos
argument_list|)
expr_stmt|;
name|TimestampWritable
name|tsw
init|=
operator|new
name|TimestampWritable
argument_list|(
name|ts
argument_list|)
decl_stmt|;
name|double
name|asDouble
init|=
name|tsw
operator|.
name|getDouble
argument_list|()
decl_stmt|;
name|int
name|recoveredNanos
init|=
call|(
name|int
call|)
argument_list|(
name|Math
operator|.
name|round
argument_list|(
operator|(
name|asDouble
operator|-
name|Math
operator|.
name|floor
argument_list|(
name|asDouble
argument_list|)
operator|)
operator|*
name|Math
operator|.
name|pow
argument_list|(
literal|10
argument_list|,
name|nanosPrecision
argument_list|)
argument_list|)
operator|*
name|Math
operator|.
name|pow
argument_list|(
literal|10
argument_list|,
literal|9
operator|-
name|nanosPrecision
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Invalid nanosecond part recovered from %f"
argument_list|,
name|asDouble
argument_list|)
argument_list|,
name|nanos
argument_list|,
name|recoveredNanos
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ts
argument_list|,
name|TimestampWritable
operator|.
name|doubleToTimestamp
argument_list|(
name|asDouble
argument_list|)
argument_list|)
expr_stmt|;
comment|// decimalToTimestamp should be consistent with doubleToTimestamp for this level of
comment|// precision.
name|assertEquals
argument_list|(
name|ts
argument_list|,
name|TimestampWritable
operator|.
name|decimalToTimestamp
argument_list|(
operator|new
name|HiveDecimal
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|asDouble
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
name|HiveDecimal
name|timestampToDecimal
parameter_list|(
name|Timestamp
name|ts
parameter_list|)
block|{
name|BigDecimal
name|d
init|=
operator|new
name|BigDecimal
argument_list|(
name|getSeconds
argument_list|(
name|ts
argument_list|)
argument_list|)
decl_stmt|;
name|d
operator|=
name|d
operator|.
name|add
argument_list|(
operator|new
name|BigDecimal
argument_list|(
name|ts
operator|.
name|getNanos
argument_list|()
argument_list|)
operator|.
name|divide
argument_list|(
operator|new
name|BigDecimal
argument_list|(
name|BILLION
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|HiveDecimal
argument_list|(
name|d
argument_list|)
return|;
block|}
specifier|public
name|void
name|testDecimalToTimestampRandomly
parameter_list|()
block|{
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|(
literal|294729777L
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10000
condition|;
operator|++
name|i
control|)
block|{
name|Timestamp
name|ts
init|=
operator|new
name|Timestamp
argument_list|(
name|randomMillis
argument_list|(
name|MIN_FOUR_DIGIT_YEAR_MILLIS
argument_list|,
name|MAX_FOUR_DIGIT_YEAR_MILLIS
argument_list|,
name|rand
argument_list|)
argument_list|)
decl_stmt|;
name|ts
operator|.
name|setNanos
argument_list|(
name|randomNanos
argument_list|(
name|rand
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
comment|// full precision
name|assertEquals
argument_list|(
name|ts
argument_list|,
name|TimestampWritable
operator|.
name|decimalToTimestamp
argument_list|(
name|timestampToDecimal
argument_list|(
name|ts
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|testDecimalToTimestampCornerCases
parameter_list|()
block|{
name|Timestamp
name|ts
init|=
operator|new
name|Timestamp
argument_list|(
name|parseToMillis
argument_list|(
literal|"1969-03-04 05:44:33"
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
operator|%
literal|1000
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|nanos
range|:
operator|new
name|int
index|[]
block|{
literal|100000
block|,
literal|900000
block|,
literal|999100000
block|,
literal|999900000
block|}
control|)
block|{
name|ts
operator|.
name|setNanos
argument_list|(
name|nanos
argument_list|)
expr_stmt|;
name|HiveDecimal
name|d
init|=
name|timestampToDecimal
argument_list|(
name|ts
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ts
argument_list|,
name|TimestampWritable
operator|.
name|decimalToTimestamp
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ts
argument_list|,
name|TimestampWritable
operator|.
name|doubleToTimestamp
argument_list|(
name|d
operator|.
name|bigDecimalValue
argument_list|()
operator|.
name|doubleValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|testSerializationFormatDirectly
parameter_list|()
throws|throws
name|IOException
block|{
name|assertEquals
argument_list|(
literal|"1970-01-01 00:00:00"
argument_list|,
name|fromIntAndVInts
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"1970-01-01 00:00:01"
argument_list|,
name|fromIntAndVInts
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"1970-01-01 00:05:00"
argument_list|,
name|fromIntAndVInts
argument_list|(
literal|300
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"1970-01-01 02:00:00"
argument_list|,
name|fromIntAndVInts
argument_list|(
literal|7200
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"2000-01-02 03:04:05"
argument_list|,
name|fromIntAndVInts
argument_list|(
literal|946782245
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// This won't have a decimal part because the HAS_DECIMAL_MASK bit is not set.
name|assertEquals
argument_list|(
literal|"2000-01-02 03:04:05"
argument_list|,
name|fromIntAndVInts
argument_list|(
literal|946782245
argument_list|,
literal|3210
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"2000-01-02 03:04:05.0123"
argument_list|,
name|fromIntAndVInts
argument_list|(
literal|946782245
operator||
name|HAS_DECIMAL_MASK
argument_list|,
literal|3210
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"2038-01-19 03:14:07"
argument_list|,
name|fromIntAndVInts
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"2038-01-19 03:14:07.012345678"
argument_list|,
name|fromIntAndVInts
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
operator||
name|HAS_DECIMAL_MASK
argument_list|,
comment|// this is really just -1
literal|876543210
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Timestamps with a second VInt storing additional bits of the seconds field.
name|long
name|seconds
init|=
literal|253392390415L
decl_stmt|;
name|assertEquals
argument_list|(
literal|"9999-09-08 07:06:55"
argument_list|,
name|fromIntAndVInts
argument_list|(
call|(
name|int
call|)
argument_list|(
name|seconds
operator|&
literal|0x7fffffff
argument_list|)
operator||
operator|(
literal|1
operator|<<
literal|31
operator|)
argument_list|,
operator|-
literal|1L
argument_list|,
name|seconds
operator|>>
literal|31
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"9999-09-08 07:06:55.0123"
argument_list|,
name|fromIntAndVInts
argument_list|(
call|(
name|int
call|)
argument_list|(
name|seconds
operator|&
literal|0x7fffffff
argument_list|)
operator||
operator|(
literal|1
operator|<<
literal|31
operator|)
argument_list|,
operator|-
literal|3210
operator|-
literal|1
argument_list|,
name|seconds
operator|>>
literal|31
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|testMaxSize
parameter_list|()
block|{
comment|// This many bytes are necessary to store the reversed nanoseconds.
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
literal|999999999
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
operator|-
literal|2
operator|-
literal|999999999
argument_list|)
argument_list|)
expr_stmt|;
comment|// Bytes necessary to store extra bits of the second timestamp if storing a timestamp
comment|// before 1970 or after 2038.
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|Short
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|Short
operator|.
name|MIN_VALUE
argument_list|)
argument_list|)
expr_stmt|;
comment|// Test that MAX_ADDITIONAL_SECONDS_BITS is really the maximum value of the
comment|// additional bits (beyond 31 bits) of the seconds-since-epoch part of timestamp.
name|assertTrue
argument_list|(
operator|(
operator|(
operator|(
name|long
operator|)
name|MAX_ADDITIONAL_SECONDS_BITS
operator|)
operator|<<
literal|31
operator|)
operator|*
literal|1000
operator|<
name|Long
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
operator|(
operator|(
operator|(
name|double
operator|)
name|MAX_ADDITIONAL_SECONDS_BITS
operator|+
literal|1
operator|)
operator|*
operator|(
literal|1L
operator|<<
literal|31
operator|)
operator|)
operator|*
literal|1000
operator|>
name|Long
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
comment|// This is how many bytes we need to store those additonal bits as a VInt.
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|MAX_ADDITIONAL_SECONDS_BITS
argument_list|)
argument_list|)
expr_stmt|;
comment|// Therefore, the maximum total size of a serialized timestamp is 4 + 5 + 4 = 13.
block|}
specifier|public
name|void
name|testMillisToSeconds
parameter_list|()
block|{
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|TimestampWritable
operator|.
name|millisToSeconds
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|1
argument_list|,
name|TimestampWritable
operator|.
name|millisToSeconds
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|1
argument_list|,
name|TimestampWritable
operator|.
name|millisToSeconds
argument_list|(
operator|-
literal|999
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|1
argument_list|,
name|TimestampWritable
operator|.
name|millisToSeconds
argument_list|(
operator|-
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|2
argument_list|,
name|TimestampWritable
operator|.
name|millisToSeconds
argument_list|(
operator|-
literal|1001
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|2
argument_list|,
name|TimestampWritable
operator|.
name|millisToSeconds
argument_list|(
operator|-
literal|1999
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|2
argument_list|,
name|TimestampWritable
operator|.
name|millisToSeconds
argument_list|(
operator|-
literal|2000
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|3
argument_list|,
name|TimestampWritable
operator|.
name|millisToSeconds
argument_list|(
operator|-
literal|2001
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|99
argument_list|,
name|TimestampWritable
operator|.
name|millisToSeconds
argument_list|(
operator|-
literal|99000
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|100
argument_list|,
name|TimestampWritable
operator|.
name|millisToSeconds
argument_list|(
operator|-
literal|99001
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|100
argument_list|,
name|TimestampWritable
operator|.
name|millisToSeconds
argument_list|(
operator|-
literal|100000
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|TimestampWritable
operator|.
name|millisToSeconds
argument_list|(
literal|1500
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|19
argument_list|,
name|TimestampWritable
operator|.
name|millisToSeconds
argument_list|(
literal|19999
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|20
argument_list|,
name|TimestampWritable
operator|.
name|millisToSeconds
argument_list|(
literal|20000
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|int
name|compareEqualLengthByteArrays
parameter_list|(
name|byte
index|[]
name|a
parameter_list|,
name|byte
index|[]
name|b
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|a
operator|.
name|length
argument_list|,
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|a
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|a
index|[
name|i
index|]
operator|!=
name|b
index|[
name|i
index|]
condition|)
block|{
return|return
operator|(
name|a
index|[
name|i
index|]
operator|&
literal|0xff
operator|)
operator|-
operator|(
name|b
index|[
name|i
index|]
operator|&
literal|0xff
operator|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
specifier|private
specifier|static
name|int
name|normalizeComparisonResult
parameter_list|(
name|int
name|result
parameter_list|)
block|{
return|return
name|result
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
operator|(
name|result
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
specifier|public
name|void
name|testBinarySortable
parameter_list|()
block|{
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|(
literal|5972977L
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|TimestampWritable
argument_list|>
name|tswList
init|=
operator|new
name|ArrayList
argument_list|<
name|TimestampWritable
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|50
condition|;
operator|++
name|i
control|)
block|{
name|Timestamp
name|ts
init|=
operator|new
name|Timestamp
argument_list|(
name|rand
operator|.
name|nextLong
argument_list|()
argument_list|)
decl_stmt|;
name|ts
operator|.
name|setNanos
argument_list|(
name|randomNanos
argument_list|(
name|rand
argument_list|)
argument_list|)
expr_stmt|;
name|tswList
operator|.
name|add
argument_list|(
operator|new
name|TimestampWritable
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|TimestampWritable
name|tsw1
range|:
name|tswList
control|)
block|{
name|byte
index|[]
name|bs1
init|=
name|tsw1
operator|.
name|getBinarySortable
argument_list|()
decl_stmt|;
for|for
control|(
name|TimestampWritable
name|tsw2
range|:
name|tswList
control|)
block|{
name|byte
index|[]
name|bs2
init|=
name|tsw2
operator|.
name|getBinarySortable
argument_list|()
decl_stmt|;
name|int
name|binaryComparisonResult
init|=
name|normalizeComparisonResult
argument_list|(
name|compareEqualLengthByteArrays
argument_list|(
name|bs1
argument_list|,
name|bs2
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|comparisonResult
init|=
name|normalizeComparisonResult
argument_list|(
name|tsw1
operator|.
name|compareTo
argument_list|(
name|tsw2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|binaryComparisonResult
operator|!=
name|comparisonResult
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"TimestampWritables "
operator|+
name|tsw1
operator|+
literal|" and "
operator|+
name|tsw2
operator|+
literal|" compare as "
operator|+
name|comparisonResult
operator|+
literal|" using compareTo but as "
operator|+
name|binaryComparisonResult
operator|+
literal|" using "
operator|+
literal|"getBinarySortable"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

