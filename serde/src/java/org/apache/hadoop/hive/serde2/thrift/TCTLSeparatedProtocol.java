begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|thrift
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CharacterCodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|TException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|protocol
operator|.
name|TField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|protocol
operator|.
name|TList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|protocol
operator|.
name|TMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|protocol
operator|.
name|TMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|protocol
operator|.
name|TProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|protocol
operator|.
name|TProtocolFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|protocol
operator|.
name|TSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|protocol
operator|.
name|TStruct
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|protocol
operator|.
name|TType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|transport
operator|.
name|TTransport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|transport
operator|.
name|TTransportException
import|;
end_import

begin_comment
comment|/**  *   * An implementation of the Thrift Protocol for ctl separated records. This is  * not thrift compliant in that it doesn't write out field ids so things cannot  * actually be versioned.  */
end_comment

begin_class
specifier|public
class|class
name|TCTLSeparatedProtocol
extends|extends
name|TProtocol
implements|implements
name|ConfigurableTProtocol
implements|,
name|WriteNullsProtocol
implements|,
name|SkippableTProtocol
block|{
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TCTLSeparatedProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|static
name|byte
name|ORDERED_TYPE
init|=
operator|(
name|byte
operator|)
operator|-
literal|1
decl_stmt|;
comment|/**    * Factory for JSON protocol objects.    */
specifier|public
specifier|static
class|class
name|Factory
implements|implements
name|TProtocolFactory
block|{
specifier|public
name|TProtocol
name|getProtocol
parameter_list|(
name|TTransport
name|trans
parameter_list|)
block|{
return|return
operator|new
name|TCTLSeparatedProtocol
argument_list|(
name|trans
argument_list|)
return|;
block|}
block|}
comment|/**    * These are defaults, but for now leaving them like this.    */
specifier|protected
specifier|static
specifier|final
name|String
name|defaultPrimarySeparator
init|=
literal|"\001"
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|defaultSecondarySeparator
init|=
literal|"\002"
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|defaultRowSeparator
init|=
literal|"\n"
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|defaultMapSeparator
init|=
literal|"\003"
decl_stmt|;
comment|/**    * The separators for this instance.    */
specifier|protected
name|String
name|primarySeparator
decl_stmt|;
specifier|protected
name|String
name|secondarySeparator
decl_stmt|;
specifier|protected
name|String
name|rowSeparator
decl_stmt|;
specifier|protected
name|String
name|mapSeparator
decl_stmt|;
specifier|protected
name|Pattern
name|primaryPattern
decl_stmt|;
specifier|protected
name|Pattern
name|secondaryPattern
decl_stmt|;
specifier|protected
name|Pattern
name|mapPattern
decl_stmt|;
comment|/**    * The quote character when supporting quotes with ability to not split across    * quoted entries. Like csv. Note that escaping the quote is not currently    * supported.    */
specifier|protected
name|String
name|quote
decl_stmt|;
comment|/**    * Inspect the separators this instance is configured with.    */
specifier|public
name|String
name|getPrimarySeparator
parameter_list|()
block|{
return|return
name|primarySeparator
return|;
block|}
specifier|public
name|String
name|getSecondarySeparator
parameter_list|()
block|{
return|return
name|secondarySeparator
return|;
block|}
specifier|public
name|String
name|getRowSeparator
parameter_list|()
block|{
return|return
name|rowSeparator
return|;
block|}
specifier|public
name|String
name|getMapSeparator
parameter_list|()
block|{
return|return
name|mapSeparator
return|;
block|}
comment|/**    * The transport stream is tokenized on the row separator.    */
specifier|protected
name|SimpleTransportTokenizer
name|transportTokenizer
decl_stmt|;
comment|/**    * For a single row, the split on the primary separator.    */
specifier|protected
name|String
index|[]
name|columns
decl_stmt|;
comment|/**    * An index into what column we're on.    */
specifier|protected
name|int
name|index
decl_stmt|;
comment|/**    * For a single column, a split on the secondary separator.    */
specifier|protected
name|String
index|[]
name|fields
decl_stmt|;
comment|/**    * An index into what field within a column we're on.    */
specifier|protected
name|int
name|innerIndex
decl_stmt|;
comment|/**    * Is this the first field we're writing.    */
specifier|protected
name|boolean
name|firstField
decl_stmt|;
comment|/**    * Is this the first list/map/set field we're writing for the current element.    */
specifier|protected
name|boolean
name|firstInnerField
decl_stmt|;
comment|/**    * Are we writing a map and need to worry about k/v separator?    */
specifier|protected
name|boolean
name|isMap
decl_stmt|;
comment|/**    * For writes, on what element are we on so we know when to use normal list    * separator or for a map know when to use the k/v separator.    */
specifier|protected
name|long
name|elemIndex
decl_stmt|;
comment|/**    * Are we currently on the top-level columns or parsing a column itself.    */
specifier|protected
name|boolean
name|inner
decl_stmt|;
comment|/**    * For places where the separators are back to back, should we return a null    * or an empty string since it is ambiguous. This also applies to extra    * columns that are read but aren't in the current record.    */
specifier|protected
name|boolean
name|returnNulls
decl_stmt|;
comment|/**    * The transport being wrapped.    *     */
specifier|protected
specifier|final
name|TTransport
name|innerTransport
decl_stmt|;
comment|/**    * Strings used to lookup the various configurable paramaters of this    * protocol.    */
specifier|public
specifier|static
specifier|final
name|String
name|ReturnNullsKey
init|=
literal|"separators.return_nulls"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|BufferSizeKey
init|=
literal|"separators.buffer_size"
decl_stmt|;
comment|/**    * The size of the internal buffer to use.    */
specifier|protected
name|int
name|bufferSize
decl_stmt|;
comment|/**    * The string representing nulls in the serialized data. e.g., \N as in mysql.    */
specifier|protected
name|String
name|nullString
decl_stmt|;
comment|/**    * The nullString in UTF-8 bytes.    */
specifier|protected
name|Text
name|nullText
decl_stmt|;
comment|/**    * A convenience class for tokenizing a TTransport.    */
class|class
name|SimpleTransportTokenizer
block|{
name|TTransport
name|trans
decl_stmt|;
name|StringTokenizer
name|tokenizer
decl_stmt|;
specifier|final
name|String
name|separator
decl_stmt|;
name|byte
index|[]
name|buf
decl_stmt|;
specifier|public
name|SimpleTransportTokenizer
parameter_list|(
name|TTransport
name|trans
parameter_list|,
name|String
name|separator
parameter_list|,
name|int
name|buffer_length
parameter_list|)
block|{
name|this
operator|.
name|trans
operator|=
name|trans
expr_stmt|;
name|this
operator|.
name|separator
operator|=
name|separator
expr_stmt|;
name|buf
operator|=
operator|new
name|byte
index|[
name|buffer_length
index|]
expr_stmt|;
block|}
specifier|private
name|void
name|initialize
parameter_list|()
block|{
comment|// do not fill tokenizer until user requests since filling it could read
comment|// in data
comment|// not meant for this instantiation.
try|try
block|{
name|fillTokenizer
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to initialize tokenizer"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|fillTokenizer
parameter_list|()
block|{
try|try
block|{
name|int
name|length
init|=
name|trans
operator|.
name|read
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
block|{
name|tokenizer
operator|=
operator|new
name|StringTokenizer
argument_list|(
literal|""
argument_list|,
name|separator
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|String
name|row
decl_stmt|;
try|try
block|{
name|row
operator|=
name|Text
operator|.
name|decode
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CharacterCodingException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|tokenizer
operator|=
operator|new
name|StringTokenizer
argument_list|(
name|row
argument_list|,
name|separator
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TTransportException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|getType
argument_list|()
operator|==
name|TTransportException
operator|.
name|END_OF_FILE
condition|)
block|{
name|tokenizer
operator|=
operator|new
name|StringTokenizer
argument_list|(
literal|""
argument_list|,
name|separator
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|tokenizer
operator|=
literal|null
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|String
name|nextToken
parameter_list|()
throws|throws
name|EOFException
block|{
name|StringBuilder
name|ret
init|=
literal|null
decl_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|tokenizer
operator|==
literal|null
condition|)
block|{
name|fillTokenizer
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
operator|!
name|tokenizer
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|fillTokenizer
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
try|try
block|{
specifier|final
name|String
name|nextToken
init|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextToken
operator|.
name|equals
argument_list|(
name|separator
argument_list|)
condition|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
literal|null
condition|)
block|{
name|ret
operator|=
operator|new
name|StringBuilder
argument_list|(
name|nextToken
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|.
name|append
argument_list|(
name|nextToken
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|e
parameter_list|)
block|{
if|if
condition|(
name|ret
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
name|done
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// while ! done
specifier|final
name|String
name|theRet
init|=
name|ret
operator|==
literal|null
condition|?
literal|null
else|:
name|ret
operator|.
name|toString
argument_list|()
decl_stmt|;
return|return
name|theRet
return|;
block|}
block|}
empty_stmt|;
comment|/**    * The simple constructor which assumes ctl-a, ctl-b and '\n' separators and    * to return empty strings for empty fields.    *     * @param trans    *          - the ttransport to use as input or output    *     */
specifier|public
name|TCTLSeparatedProtocol
parameter_list|(
name|TTransport
name|trans
parameter_list|)
block|{
name|this
argument_list|(
name|trans
argument_list|,
name|defaultPrimarySeparator
argument_list|,
name|defaultSecondarySeparator
argument_list|,
name|defaultMapSeparator
argument_list|,
name|defaultRowSeparator
argument_list|,
literal|true
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
block|}
specifier|public
name|TCTLSeparatedProtocol
parameter_list|(
name|TTransport
name|trans
parameter_list|,
name|int
name|buffer_size
parameter_list|)
block|{
name|this
argument_list|(
name|trans
argument_list|,
name|defaultPrimarySeparator
argument_list|,
name|defaultSecondarySeparator
argument_list|,
name|defaultMapSeparator
argument_list|,
name|defaultRowSeparator
argument_list|,
literal|true
argument_list|,
name|buffer_size
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param trans    *          - the ttransport to use as input or output    * @param primarySeparator    *          the separator between columns (aka fields)    * @param secondarySeparator    *          the separator within a field for things like sets and maps and    *          lists    * @param mapSeparator    *          - the key/value separator    * @param rowSeparator    *          - the record separator    * @param returnNulls    *          - whether to return a null or an empty string for fields that seem    *          empty (ie two primary separators back to back)    */
specifier|public
name|TCTLSeparatedProtocol
parameter_list|(
name|TTransport
name|trans
parameter_list|,
name|String
name|primarySeparator
parameter_list|,
name|String
name|secondarySeparator
parameter_list|,
name|String
name|mapSeparator
parameter_list|,
name|String
name|rowSeparator
parameter_list|,
name|boolean
name|returnNulls
parameter_list|,
name|int
name|bufferSize
parameter_list|)
block|{
name|super
argument_list|(
name|trans
argument_list|)
expr_stmt|;
name|this
operator|.
name|returnNulls
operator|=
name|returnNulls
expr_stmt|;
name|this
operator|.
name|primarySeparator
operator|=
name|primarySeparator
expr_stmt|;
name|this
operator|.
name|secondarySeparator
operator|=
name|secondarySeparator
expr_stmt|;
name|this
operator|.
name|rowSeparator
operator|=
name|rowSeparator
expr_stmt|;
name|this
operator|.
name|mapSeparator
operator|=
name|mapSeparator
expr_stmt|;
name|innerTransport
operator|=
name|trans
expr_stmt|;
name|this
operator|.
name|bufferSize
operator|=
name|bufferSize
expr_stmt|;
name|nullString
operator|=
literal|"\\N"
expr_stmt|;
block|}
comment|/**    * Sets the internal separator patterns and creates the internal tokenizer.    */
specifier|protected
name|void
name|internalInitialize
parameter_list|()
block|{
comment|// in the future could allow users to specify a quote character that doesn't
comment|// need escaping but for now ...
specifier|final
name|String
name|primaryPatternString
init|=
name|quote
operator|==
literal|null
condition|?
name|primarySeparator
else|:
literal|"(?:^|"
operator|+
name|primarySeparator
operator|+
literal|")("
operator|+
name|quote
operator|+
literal|"(?:[^"
operator|+
name|quote
operator|+
literal|"]+|"
operator|+
name|quote
operator|+
name|quote
operator|+
literal|")*"
operator|+
name|quote
operator|+
literal|"|[^"
operator|+
name|primarySeparator
operator|+
literal|"]*)"
decl_stmt|;
if|if
condition|(
name|quote
operator|!=
literal|null
condition|)
block|{
name|stripSeparatorPrefix
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^"
operator|+
name|primarySeparator
argument_list|)
expr_stmt|;
name|stripQuotePrefix
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^"
operator|+
name|quote
argument_list|)
expr_stmt|;
name|stripQuotePostfix
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
name|quote
operator|+
literal|"$"
argument_list|)
expr_stmt|;
block|}
name|primaryPattern
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
name|primaryPatternString
argument_list|)
expr_stmt|;
name|secondaryPattern
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
name|secondarySeparator
argument_list|)
expr_stmt|;
name|mapPattern
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
name|secondarySeparator
operator|+
literal|"|"
operator|+
name|mapSeparator
argument_list|)
expr_stmt|;
name|nullText
operator|=
operator|new
name|Text
argument_list|(
name|nullString
argument_list|)
expr_stmt|;
name|transportTokenizer
operator|=
operator|new
name|SimpleTransportTokenizer
argument_list|(
name|innerTransport
argument_list|,
name|rowSeparator
argument_list|,
name|bufferSize
argument_list|)
expr_stmt|;
name|transportTokenizer
operator|.
name|initialize
argument_list|()
expr_stmt|;
block|}
comment|/**    * For quoted fields, strip away the quotes and also need something to strip    * away the control separator when using complex split method defined here.    */
specifier|protected
name|Pattern
name|stripSeparatorPrefix
decl_stmt|;
specifier|protected
name|Pattern
name|stripQuotePrefix
decl_stmt|;
specifier|protected
name|Pattern
name|stripQuotePostfix
decl_stmt|;
comment|/**    *     * Split the line based on a complex regex pattern.    *     * @param line    *          the current row    * @param p    *          the pattern for matching fields in the row    * @return List of Strings - not including the separator in them    */
specifier|protected
name|String
index|[]
name|complexSplit
parameter_list|(
name|String
name|line
parameter_list|,
name|Pattern
name|p
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Matcher
name|m
init|=
name|p
operator|.
name|matcher
argument_list|(
name|line
argument_list|)
decl_stmt|;
comment|// For each field
while|while
condition|(
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|match
init|=
name|m
operator|.
name|group
argument_list|()
decl_stmt|;
if|if
condition|(
name|match
operator|==
literal|null
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|match
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|match
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|stripSeparatorPrefix
operator|.
name|matcher
argument_list|(
name|match
argument_list|)
operator|.
name|find
argument_list|()
condition|)
block|{
name|match
operator|=
name|match
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stripQuotePrefix
operator|.
name|matcher
argument_list|(
name|match
argument_list|)
operator|.
name|find
argument_list|()
condition|)
block|{
name|match
operator|=
name|match
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stripQuotePostfix
operator|.
name|matcher
argument_list|(
name|match
argument_list|)
operator|.
name|find
argument_list|()
condition|)
block|{
name|match
operator|=
name|match
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|match
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|list
operator|.
name|add
argument_list|(
name|match
argument_list|)
expr_stmt|;
block|}
return|return
name|list
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|1
index|]
argument_list|)
return|;
block|}
specifier|protected
name|String
name|getByteValue
parameter_list|(
name|String
name|altValue
parameter_list|,
name|String
name|defaultVal
parameter_list|)
block|{
if|if
condition|(
name|altValue
operator|!=
literal|null
operator|&&
name|altValue
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|byte
index|[]
name|b
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|Byte
operator|.
name|valueOf
argument_list|(
name|altValue
argument_list|)
operator|.
name|byteValue
argument_list|()
expr_stmt|;
return|return
operator|new
name|String
argument_list|(
name|b
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
return|return
name|altValue
return|;
block|}
block|}
return|return
name|defaultVal
return|;
block|}
comment|/**    * Initialize the TProtocol.    *     * @param conf    *          System properties    * @param tbl    *          table properties    * @throws TException    */
specifier|public
name|void
name|initialize
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Properties
name|tbl
parameter_list|)
throws|throws
name|TException
block|{
name|primarySeparator
operator|=
name|getByteValue
argument_list|(
name|tbl
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|FIELD_DELIM
argument_list|)
argument_list|,
name|primarySeparator
argument_list|)
expr_stmt|;
name|secondarySeparator
operator|=
name|getByteValue
argument_list|(
name|tbl
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|COLLECTION_DELIM
argument_list|)
argument_list|,
name|secondarySeparator
argument_list|)
expr_stmt|;
name|rowSeparator
operator|=
name|getByteValue
argument_list|(
name|tbl
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|LINE_DELIM
argument_list|)
argument_list|,
name|rowSeparator
argument_list|)
expr_stmt|;
name|mapSeparator
operator|=
name|getByteValue
argument_list|(
name|tbl
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|MAPKEY_DELIM
argument_list|)
argument_list|,
name|mapSeparator
argument_list|)
expr_stmt|;
name|returnNulls
operator|=
name|Boolean
operator|.
name|valueOf
argument_list|(
name|tbl
operator|.
name|getProperty
argument_list|(
name|ReturnNullsKey
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|returnNulls
argument_list|)
argument_list|)
argument_list|)
operator|.
name|booleanValue
argument_list|()
expr_stmt|;
name|bufferSize
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|tbl
operator|.
name|getProperty
argument_list|(
name|BufferSizeKey
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|bufferSize
argument_list|)
argument_list|)
argument_list|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
name|nullString
operator|=
name|tbl
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|SERIALIZATION_NULL_FORMAT
argument_list|,
literal|"\\N"
argument_list|)
expr_stmt|;
name|quote
operator|=
name|tbl
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|QUOTE_CHAR
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|internalInitialize
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeMessageBegin
parameter_list|(
name|TMessage
name|message
parameter_list|)
throws|throws
name|TException
block|{   }
annotation|@
name|Override
specifier|public
name|void
name|writeMessageEnd
parameter_list|()
throws|throws
name|TException
block|{   }
annotation|@
name|Override
specifier|public
name|void
name|writeStructBegin
parameter_list|(
name|TStruct
name|struct
parameter_list|)
throws|throws
name|TException
block|{
name|firstField
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeStructEnd
parameter_list|()
throws|throws
name|TException
block|{
comment|// We don't write rowSeparatorByte because that should be handled by file
comment|// format.
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeFieldBegin
parameter_list|(
name|TField
name|field
parameter_list|)
throws|throws
name|TException
block|{
if|if
condition|(
operator|!
name|firstField
condition|)
block|{
name|internalWriteString
argument_list|(
name|primarySeparator
argument_list|)
expr_stmt|;
block|}
name|firstField
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeFieldEnd
parameter_list|()
throws|throws
name|TException
block|{   }
annotation|@
name|Override
specifier|public
name|void
name|writeFieldStop
parameter_list|()
block|{   }
annotation|@
name|Override
specifier|public
name|void
name|writeMapBegin
parameter_list|(
name|TMap
name|map
parameter_list|)
throws|throws
name|TException
block|{
comment|// nesting not allowed!
if|if
condition|(
name|map
operator|.
name|keyType
operator|==
name|TType
operator|.
name|STRUCT
operator|||
name|map
operator|.
name|keyType
operator|==
name|TType
operator|.
name|MAP
operator|||
name|map
operator|.
name|keyType
operator|==
name|TType
operator|.
name|LIST
operator|||
name|map
operator|.
name|keyType
operator|==
name|TType
operator|.
name|SET
condition|)
block|{
throw|throw
operator|new
name|TException
argument_list|(
literal|"Not implemented: nested structures"
argument_list|)
throw|;
block|}
comment|// nesting not allowed!
if|if
condition|(
name|map
operator|.
name|valueType
operator|==
name|TType
operator|.
name|STRUCT
operator|||
name|map
operator|.
name|valueType
operator|==
name|TType
operator|.
name|MAP
operator|||
name|map
operator|.
name|valueType
operator|==
name|TType
operator|.
name|LIST
operator|||
name|map
operator|.
name|valueType
operator|==
name|TType
operator|.
name|SET
condition|)
block|{
throw|throw
operator|new
name|TException
argument_list|(
literal|"Not implemented: nested structures"
argument_list|)
throw|;
block|}
name|firstInnerField
operator|=
literal|true
expr_stmt|;
name|isMap
operator|=
literal|true
expr_stmt|;
name|inner
operator|=
literal|true
expr_stmt|;
name|elemIndex
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeMapEnd
parameter_list|()
throws|throws
name|TException
block|{
name|isMap
operator|=
literal|false
expr_stmt|;
name|inner
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeListBegin
parameter_list|(
name|TList
name|list
parameter_list|)
throws|throws
name|TException
block|{
if|if
condition|(
name|list
operator|.
name|elemType
operator|==
name|TType
operator|.
name|STRUCT
operator|||
name|list
operator|.
name|elemType
operator|==
name|TType
operator|.
name|MAP
operator|||
name|list
operator|.
name|elemType
operator|==
name|TType
operator|.
name|LIST
operator|||
name|list
operator|.
name|elemType
operator|==
name|TType
operator|.
name|SET
condition|)
block|{
throw|throw
operator|new
name|TException
argument_list|(
literal|"Not implemented: nested structures"
argument_list|)
throw|;
block|}
name|firstInnerField
operator|=
literal|true
expr_stmt|;
name|inner
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeListEnd
parameter_list|()
throws|throws
name|TException
block|{
name|inner
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeSetBegin
parameter_list|(
name|TSet
name|set
parameter_list|)
throws|throws
name|TException
block|{
if|if
condition|(
name|set
operator|.
name|elemType
operator|==
name|TType
operator|.
name|STRUCT
operator|||
name|set
operator|.
name|elemType
operator|==
name|TType
operator|.
name|MAP
operator|||
name|set
operator|.
name|elemType
operator|==
name|TType
operator|.
name|LIST
operator|||
name|set
operator|.
name|elemType
operator|==
name|TType
operator|.
name|SET
condition|)
block|{
throw|throw
operator|new
name|TException
argument_list|(
literal|"Not implemented: nested structures"
argument_list|)
throw|;
block|}
name|firstInnerField
operator|=
literal|true
expr_stmt|;
name|inner
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeSetEnd
parameter_list|()
throws|throws
name|TException
block|{
name|inner
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeBool
parameter_list|(
name|boolean
name|b
parameter_list|)
throws|throws
name|TException
block|{
name|writeString
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// for writing out single byte
specifier|private
specifier|final
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|writeByte
parameter_list|(
name|byte
name|b
parameter_list|)
throws|throws
name|TException
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|b
expr_stmt|;
name|trans_
operator|.
name|write
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeI16
parameter_list|(
name|short
name|i16
parameter_list|)
throws|throws
name|TException
block|{
name|writeString
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|i16
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeI32
parameter_list|(
name|int
name|i32
parameter_list|)
throws|throws
name|TException
block|{
name|writeString
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|i32
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeI64
parameter_list|(
name|long
name|i64
parameter_list|)
throws|throws
name|TException
block|{
name|writeString
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|i64
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeDouble
parameter_list|(
name|double
name|dub
parameter_list|)
throws|throws
name|TException
block|{
name|writeString
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|dub
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Text
name|tmpText
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
specifier|public
name|void
name|internalWriteString
parameter_list|(
name|String
name|str
parameter_list|)
throws|throws
name|TException
block|{
if|if
condition|(
name|str
operator|!=
literal|null
condition|)
block|{
name|tmpText
operator|.
name|set
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|trans_
operator|.
name|write
argument_list|(
name|tmpText
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|tmpText
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|trans_
operator|.
name|write
argument_list|(
name|nullText
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|nullText
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeString
parameter_list|(
name|String
name|str
parameter_list|)
throws|throws
name|TException
block|{
if|if
condition|(
name|inner
condition|)
block|{
if|if
condition|(
operator|!
name|firstInnerField
condition|)
block|{
comment|// super hack city notice the mod plus only happens after firstfield
comment|// hit, so == 0 is right.
if|if
condition|(
name|isMap
operator|&&
name|elemIndex
operator|++
operator|%
literal|2
operator|==
literal|0
condition|)
block|{
name|internalWriteString
argument_list|(
name|mapSeparator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|internalWriteString
argument_list|(
name|secondarySeparator
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|firstInnerField
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|internalWriteString
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeBinary
parameter_list|(
name|ByteBuffer
name|bin
parameter_list|)
throws|throws
name|TException
block|{
throw|throw
operator|new
name|TException
argument_list|(
literal|"Ctl separated protocol cannot support writing Binary data!"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|TMessage
name|readMessageBegin
parameter_list|()
throws|throws
name|TException
block|{
return|return
operator|new
name|TMessage
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readMessageEnd
parameter_list|()
throws|throws
name|TException
block|{   }
annotation|@
name|Override
specifier|public
name|TStruct
name|readStructBegin
parameter_list|()
throws|throws
name|TException
block|{
assert|assert
operator|(
operator|!
name|inner
operator|)
assert|;
try|try
block|{
specifier|final
name|String
name|tmp
init|=
name|transportTokenizer
operator|.
name|nextToken
argument_list|()
decl_stmt|;
name|columns
operator|=
name|quote
operator|==
literal|null
condition|?
name|primaryPattern
operator|.
name|split
argument_list|(
name|tmp
argument_list|)
else|:
name|complexSplit
argument_list|(
name|tmp
argument_list|,
name|primaryPattern
argument_list|)
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
return|return
operator|new
name|TStruct
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|readStructEnd
parameter_list|()
throws|throws
name|TException
block|{
name|columns
operator|=
literal|null
expr_stmt|;
block|}
comment|/**    * Skip past the current field Just increments the field index counter.    */
specifier|public
name|void
name|skip
parameter_list|(
name|byte
name|type
parameter_list|)
block|{
if|if
condition|(
name|inner
condition|)
block|{
name|innerIndex
operator|++
expr_stmt|;
block|}
else|else
block|{
name|index
operator|++
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|TField
name|readFieldBegin
parameter_list|()
throws|throws
name|TException
block|{
assert|assert
operator|(
operator|!
name|inner
operator|)
assert|;
name|TField
name|f
init|=
operator|new
name|TField
argument_list|(
literal|""
argument_list|,
name|ORDERED_TYPE
argument_list|,
operator|(
name|short
operator|)
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|// slight hack to communicate to DynamicSerDe that the field ids are not
comment|// being set but things are ordered.
return|return
name|f
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readFieldEnd
parameter_list|()
throws|throws
name|TException
block|{
name|fields
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|TMap
name|readMapBegin
parameter_list|()
throws|throws
name|TException
block|{
assert|assert
operator|(
operator|!
name|inner
operator|)
assert|;
name|TMap
name|map
init|=
operator|new
name|TMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|columns
index|[
name|index
index|]
operator|==
literal|null
operator|||
name|columns
index|[
name|index
index|]
operator|.
name|equals
argument_list|(
name|nullString
argument_list|)
condition|)
block|{
name|index
operator|++
expr_stmt|;
if|if
condition|(
name|returnNulls
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|columns
index|[
name|index
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|index
operator|++
expr_stmt|;
block|}
else|else
block|{
name|fields
operator|=
name|mapPattern
operator|.
name|split
argument_list|(
name|columns
index|[
name|index
operator|++
index|]
argument_list|)
expr_stmt|;
name|map
operator|=
operator|new
name|TMap
argument_list|(
name|ORDERED_TYPE
argument_list|,
name|ORDERED_TYPE
argument_list|,
name|fields
operator|.
name|length
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
name|innerIndex
operator|=
literal|0
expr_stmt|;
name|inner
operator|=
literal|true
expr_stmt|;
name|isMap
operator|=
literal|true
expr_stmt|;
return|return
name|map
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readMapEnd
parameter_list|()
throws|throws
name|TException
block|{
name|inner
operator|=
literal|false
expr_stmt|;
name|isMap
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|TList
name|readListBegin
parameter_list|()
throws|throws
name|TException
block|{
assert|assert
operator|(
operator|!
name|inner
operator|)
assert|;
name|TList
name|list
init|=
operator|new
name|TList
argument_list|()
decl_stmt|;
if|if
condition|(
name|columns
index|[
name|index
index|]
operator|==
literal|null
operator|||
name|columns
index|[
name|index
index|]
operator|.
name|equals
argument_list|(
name|nullString
argument_list|)
condition|)
block|{
name|index
operator|++
expr_stmt|;
if|if
condition|(
name|returnNulls
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|columns
index|[
name|index
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|index
operator|++
expr_stmt|;
block|}
else|else
block|{
name|fields
operator|=
name|secondaryPattern
operator|.
name|split
argument_list|(
name|columns
index|[
name|index
operator|++
index|]
argument_list|)
expr_stmt|;
name|list
operator|=
operator|new
name|TList
argument_list|(
name|ORDERED_TYPE
argument_list|,
name|fields
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|innerIndex
operator|=
literal|0
expr_stmt|;
name|inner
operator|=
literal|true
expr_stmt|;
return|return
name|list
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readListEnd
parameter_list|()
throws|throws
name|TException
block|{
name|inner
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|TSet
name|readSetBegin
parameter_list|()
throws|throws
name|TException
block|{
assert|assert
operator|(
operator|!
name|inner
operator|)
assert|;
name|TSet
name|set
init|=
operator|new
name|TSet
argument_list|()
decl_stmt|;
if|if
condition|(
name|columns
index|[
name|index
index|]
operator|==
literal|null
operator|||
name|columns
index|[
name|index
index|]
operator|.
name|equals
argument_list|(
name|nullString
argument_list|)
condition|)
block|{
name|index
operator|++
expr_stmt|;
if|if
condition|(
name|returnNulls
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|columns
index|[
name|index
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|index
operator|++
expr_stmt|;
block|}
else|else
block|{
name|fields
operator|=
name|secondaryPattern
operator|.
name|split
argument_list|(
name|columns
index|[
name|index
operator|++
index|]
argument_list|)
expr_stmt|;
name|set
operator|=
operator|new
name|TSet
argument_list|(
name|ORDERED_TYPE
argument_list|,
name|fields
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|inner
operator|=
literal|true
expr_stmt|;
name|innerIndex
operator|=
literal|0
expr_stmt|;
return|return
name|set
return|;
block|}
specifier|protected
name|boolean
name|lastPrimitiveWasNullFlag
decl_stmt|;
specifier|public
name|boolean
name|lastPrimitiveWasNull
parameter_list|()
throws|throws
name|TException
block|{
return|return
name|lastPrimitiveWasNullFlag
return|;
block|}
specifier|public
name|void
name|writeNull
parameter_list|()
throws|throws
name|TException
block|{
name|writeString
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readSetEnd
parameter_list|()
throws|throws
name|TException
block|{
name|inner
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|readBool
parameter_list|()
throws|throws
name|TException
block|{
name|String
name|val
init|=
name|readString
argument_list|()
decl_stmt|;
name|lastPrimitiveWasNullFlag
operator|=
name|val
operator|==
literal|null
expr_stmt|;
return|return
name|val
operator|==
literal|null
operator|||
name|val
operator|.
name|isEmpty
argument_list|()
condition|?
literal|false
else|:
name|Boolean
operator|.
name|valueOf
argument_list|(
name|val
argument_list|)
operator|.
name|booleanValue
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
name|readByte
parameter_list|()
throws|throws
name|TException
block|{
name|String
name|val
init|=
name|readString
argument_list|()
decl_stmt|;
name|lastPrimitiveWasNullFlag
operator|=
name|val
operator|==
literal|null
expr_stmt|;
try|try
block|{
return|return
name|val
operator|==
literal|null
operator|||
name|val
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
name|Byte
operator|.
name|valueOf
argument_list|(
name|val
argument_list|)
operator|.
name|byteValue
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|lastPrimitiveWasNullFlag
operator|=
literal|true
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|short
name|readI16
parameter_list|()
throws|throws
name|TException
block|{
name|String
name|val
init|=
name|readString
argument_list|()
decl_stmt|;
name|lastPrimitiveWasNullFlag
operator|=
name|val
operator|==
literal|null
expr_stmt|;
try|try
block|{
return|return
name|val
operator|==
literal|null
operator|||
name|val
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
name|Short
operator|.
name|valueOf
argument_list|(
name|val
argument_list|)
operator|.
name|shortValue
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|lastPrimitiveWasNullFlag
operator|=
literal|true
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|readI32
parameter_list|()
throws|throws
name|TException
block|{
name|String
name|val
init|=
name|readString
argument_list|()
decl_stmt|;
name|lastPrimitiveWasNullFlag
operator|=
name|val
operator|==
literal|null
expr_stmt|;
try|try
block|{
return|return
name|val
operator|==
literal|null
operator|||
name|val
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
name|Integer
operator|.
name|valueOf
argument_list|(
name|val
argument_list|)
operator|.
name|intValue
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|lastPrimitiveWasNullFlag
operator|=
literal|true
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|long
name|readI64
parameter_list|()
throws|throws
name|TException
block|{
name|String
name|val
init|=
name|readString
argument_list|()
decl_stmt|;
name|lastPrimitiveWasNullFlag
operator|=
name|val
operator|==
literal|null
expr_stmt|;
try|try
block|{
return|return
name|val
operator|==
literal|null
operator|||
name|val
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
name|Long
operator|.
name|valueOf
argument_list|(
name|val
argument_list|)
operator|.
name|longValue
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|lastPrimitiveWasNullFlag
operator|=
literal|true
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|double
name|readDouble
parameter_list|()
throws|throws
name|TException
block|{
name|String
name|val
init|=
name|readString
argument_list|()
decl_stmt|;
name|lastPrimitiveWasNullFlag
operator|=
name|val
operator|==
literal|null
expr_stmt|;
try|try
block|{
return|return
name|val
operator|==
literal|null
operator|||
name|val
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
name|Double
operator|.
name|valueOf
argument_list|(
name|val
argument_list|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|lastPrimitiveWasNullFlag
operator|=
literal|true
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|readString
parameter_list|()
throws|throws
name|TException
block|{
name|String
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|inner
condition|)
block|{
name|ret
operator|=
name|columns
operator|!=
literal|null
operator|&&
name|index
operator|<
name|columns
operator|.
name|length
condition|?
name|columns
index|[
name|index
index|]
else|:
literal|null
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|fields
operator|!=
literal|null
operator|&&
name|innerIndex
operator|<
name|fields
operator|.
name|length
condition|?
name|fields
index|[
name|innerIndex
index|]
else|:
literal|null
expr_stmt|;
name|innerIndex
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|null
operator|||
name|ret
operator|.
name|equals
argument_list|(
name|nullString
argument_list|)
condition|)
block|{
return|return
name|returnNulls
condition|?
literal|null
else|:
literal|""
return|;
block|}
else|else
block|{
return|return
name|ret
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|ByteBuffer
name|readBinary
parameter_list|()
throws|throws
name|TException
block|{
throw|throw
operator|new
name|TException
argument_list|(
literal|"Not implemented for control separated data"
argument_list|)
throw|;
block|}
block|}
end_class

end_unit

