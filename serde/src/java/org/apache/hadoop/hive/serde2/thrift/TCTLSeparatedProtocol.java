begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|thrift
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|com
operator|.
name|facebook
operator|.
name|thrift
operator|.
name|TException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|facebook
operator|.
name|thrift
operator|.
name|transport
operator|.
name|*
import|;
end_import

begin_import
import|import
name|com
operator|.
name|facebook
operator|.
name|thrift
operator|.
name|*
import|;
end_import

begin_import
import|import
name|com
operator|.
name|facebook
operator|.
name|thrift
operator|.
name|protocol
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_comment
comment|/**  *  * An implementation of the Thrift Protocol for ctl separated  * records.  * This is not thrift compliant in that it doesn't write out field ids  * so things cannot actually be versioned.  */
end_comment

begin_class
specifier|public
class|class
name|TCTLSeparatedProtocol
extends|extends
name|TProtocol
implements|implements
name|ConfigurableTProtocol
block|{
specifier|final
specifier|static
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TCTLSeparatedProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Factory for JSON protocol objects    */
specifier|public
specifier|static
class|class
name|Factory
implements|implements
name|TProtocolFactory
block|{
specifier|public
name|TProtocol
name|getProtocol
parameter_list|(
name|TTransport
name|trans
parameter_list|)
block|{
return|return
operator|new
name|TCTLSeparatedProtocol
argument_list|(
name|trans
argument_list|)
return|;
block|}
block|}
comment|/**    * These are defaults, but for now leaving them like this    */
specifier|final
specifier|static
specifier|protected
name|byte
name|defaultPrimarySeparatorByte
init|=
literal|1
decl_stmt|;
specifier|final
specifier|static
specifier|protected
name|byte
name|defaultSecondarySeparatorByte
init|=
literal|2
decl_stmt|;
specifier|final
specifier|static
specifier|protected
name|byte
name|defaultRowSeparatorByte
init|=
operator|(
name|byte
operator|)
literal|'\n'
decl_stmt|;
specifier|final
specifier|static
specifier|protected
name|byte
name|defaultMapSeparatorByte
init|=
literal|3
decl_stmt|;
comment|/**    * The separators for this instance    */
specifier|protected
name|byte
name|primarySeparatorByte
decl_stmt|;
specifier|protected
name|byte
name|secondarySeparatorByte
decl_stmt|;
specifier|protected
name|byte
name|rowSeparatorByte
decl_stmt|;
specifier|protected
name|byte
name|mapSeparatorByte
decl_stmt|;
specifier|protected
name|Pattern
name|primaryPattern
decl_stmt|;
specifier|protected
name|Pattern
name|secondaryPattern
decl_stmt|;
specifier|protected
name|Pattern
name|mapPattern
decl_stmt|;
comment|/**    * Inspect the separators this instance is configured with.    */
specifier|public
name|byte
name|getPrimarySeparator
parameter_list|()
block|{
return|return
name|primarySeparatorByte
return|;
block|}
specifier|public
name|byte
name|getSecondarySeparator
parameter_list|()
block|{
return|return
name|secondarySeparatorByte
return|;
block|}
specifier|public
name|byte
name|getRowSeparator
parameter_list|()
block|{
return|return
name|rowSeparatorByte
return|;
block|}
specifier|public
name|byte
name|getMapSeparator
parameter_list|()
block|{
return|return
name|mapSeparatorByte
return|;
block|}
comment|/**    * The transport stream is tokenized on the row separator    */
specifier|protected
name|SimpleTransportTokenizer
name|transportTokenizer
decl_stmt|;
comment|/**    * For a single row, the split on the primary separator    */
specifier|protected
name|String
name|columns
index|[]
decl_stmt|;
comment|/**    * An index into what column we're on    */
specifier|protected
name|int
name|index
decl_stmt|;
comment|/**    * For a single column, a split on the secondary separator    */
specifier|protected
name|String
name|fields
index|[]
decl_stmt|;
comment|/**    * An index into what field within a column we're on    */
specifier|protected
name|int
name|innerIndex
decl_stmt|;
comment|/**    * Is this the first field we're writing    */
specifier|protected
name|boolean
name|firstField
decl_stmt|;
comment|/**    * Is this the first list/map/set field we're writing for the current element    */
specifier|protected
name|boolean
name|firstInnerField
decl_stmt|;
comment|/**    * Are we writing a map and need to worry about k/v separator?    */
specifier|protected
name|boolean
name|isMap
decl_stmt|;
comment|/**    * For writes, on what element are we on so we know when to use normal list separator or     * for a map know when to use the k/v separator    */
specifier|protected
name|long
name|elemIndex
decl_stmt|;
comment|/**    * Are we currently on the top-level columns or parsing a column itself    */
specifier|protected
name|boolean
name|inner
decl_stmt|;
comment|/**    * For places where the separators are back to back, should we return a null or an empty string since it is ambiguous.    * This also applies to extra columns that are read but aren't in the current record.    */
specifier|protected
name|boolean
name|returnNulls
decl_stmt|;
comment|/**    * The transport being wrapped.    *    */
specifier|final
specifier|protected
name|TTransport
name|innerTransport
decl_stmt|;
comment|/**    * Strings used to lookup the various configurable paramaters of this protocol.    */
specifier|public
specifier|final
specifier|static
name|String
name|ReturnNullsKey
init|=
literal|"separators.return_nulls"
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|String
name|BufferSizeKey
init|=
literal|"separators.buffer_size"
decl_stmt|;
comment|/**    * The size of the internal buffer to use.    */
specifier|protected
name|int
name|bufferSize
decl_stmt|;
comment|/**    * A convenience class for tokenizing a TTransport    */
class|class
name|SimpleTransportTokenizer
block|{
name|TTransport
name|trans
decl_stmt|;
name|StringTokenizer
name|tokenizer
decl_stmt|;
specifier|final
name|String
name|separator
decl_stmt|;
name|byte
name|buf
index|[]
decl_stmt|;
specifier|public
name|SimpleTransportTokenizer
parameter_list|(
name|TTransport
name|trans
parameter_list|,
name|byte
name|separator
parameter_list|,
name|int
name|buffer_length
parameter_list|)
block|{
name|this
operator|.
name|trans
operator|=
name|trans
expr_stmt|;
name|byte
index|[]
name|separators
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
name|separators
index|[
literal|0
index|]
operator|=
name|separator
expr_stmt|;
name|this
operator|.
name|separator
operator|=
operator|new
name|String
argument_list|(
name|separators
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|new
name|byte
index|[
name|buffer_length
index|]
expr_stmt|;
name|fillTokenizer
argument_list|()
expr_stmt|;
block|}
specifier|private
name|boolean
name|fillTokenizer
parameter_list|()
block|{
try|try
block|{
name|int
name|length
init|=
name|trans
operator|.
name|read
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
block|{
name|tokenizer
operator|=
operator|new
name|StringTokenizer
argument_list|(
literal|""
argument_list|,
name|separator
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|String
name|row
init|=
operator|new
name|String
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|tokenizer
operator|=
operator|new
name|StringTokenizer
argument_list|(
name|row
argument_list|,
operator|new
name|String
argument_list|(
name|separator
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TTransportException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|tokenizer
operator|=
literal|null
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|String
name|nextToken
parameter_list|()
throws|throws
name|EOFException
block|{
name|StringBuffer
name|ret
init|=
literal|null
decl_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
operator|!
name|tokenizer
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|fillTokenizer
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
try|try
block|{
specifier|final
name|String
name|nextToken
init|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextToken
operator|.
name|equals
argument_list|(
name|separator
argument_list|)
condition|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
literal|null
condition|)
block|{
name|ret
operator|=
operator|new
name|StringBuffer
argument_list|(
name|nextToken
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|.
name|append
argument_list|(
name|nextToken
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|e
parameter_list|)
block|{
if|if
condition|(
name|ret
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
name|done
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// while ! done
return|return
name|ret
operator|==
literal|null
condition|?
literal|null
else|:
name|ret
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
empty_stmt|;
comment|/**    * The simple constructor which assumes ctl-a, ctl-b and '\n' separators and to return empty strings for empty fields.    *    * @param trans - the ttransport to use as input or output    *    */
specifier|public
name|TCTLSeparatedProtocol
parameter_list|(
name|TTransport
name|trans
parameter_list|)
block|{
name|this
argument_list|(
name|trans
argument_list|,
name|defaultPrimarySeparatorByte
argument_list|,
name|defaultSecondarySeparatorByte
argument_list|,
name|defaultMapSeparatorByte
argument_list|,
name|defaultRowSeparatorByte
argument_list|,
literal|false
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
block|}
specifier|public
name|TCTLSeparatedProtocol
parameter_list|(
name|TTransport
name|trans
parameter_list|,
name|int
name|buffer_size
parameter_list|)
block|{
name|this
argument_list|(
name|trans
argument_list|,
name|defaultPrimarySeparatorByte
argument_list|,
name|defaultSecondarySeparatorByte
argument_list|,
name|defaultMapSeparatorByte
argument_list|,
name|defaultRowSeparatorByte
argument_list|,
literal|false
argument_list|,
name|buffer_size
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param trans - the ttransport to use as input or output    * @param primarySeparatorByte the separator between columns (aka fields)    * @param secondarySeparatorByte the separator within a field for things like sets and maps and lists    * @param mapSeparatorByte - the key/value separator    * @param rowSeparatorByte - the record separator    * @param returnNulls - whether to return a null or an empty string for fields that seem empty (ie two primary separators back to back)    */
specifier|public
name|TCTLSeparatedProtocol
parameter_list|(
name|TTransport
name|trans
parameter_list|,
name|byte
name|primarySeparatorByte
parameter_list|,
name|byte
name|secondarySeparatorByte
parameter_list|,
name|byte
name|mapSeparatorByte
parameter_list|,
name|byte
name|rowSeparatorByte
parameter_list|,
name|boolean
name|returnNulls
parameter_list|,
name|int
name|bufferSize
parameter_list|)
block|{
name|super
argument_list|(
name|trans
argument_list|)
expr_stmt|;
name|returnNulls
operator|=
name|returnNulls
expr_stmt|;
name|this
operator|.
name|primarySeparatorByte
operator|=
name|primarySeparatorByte
expr_stmt|;
name|this
operator|.
name|secondarySeparatorByte
operator|=
name|secondarySeparatorByte
expr_stmt|;
name|this
operator|.
name|rowSeparatorByte
operator|=
name|rowSeparatorByte
expr_stmt|;
name|this
operator|.
name|mapSeparatorByte
operator|=
name|mapSeparatorByte
expr_stmt|;
name|this
operator|.
name|innerTransport
operator|=
name|trans
expr_stmt|;
name|this
operator|.
name|bufferSize
operator|=
name|bufferSize
expr_stmt|;
name|internalInitialize
argument_list|()
expr_stmt|;
block|}
comment|/**    * Sets the internal separator patterns and creates the internal tokenizer.    */
specifier|protected
name|void
name|internalInitialize
parameter_list|()
block|{
name|byte
index|[]
name|primarySeparator
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
name|byte
index|[]
name|secondarySeparator
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
name|primarySeparator
index|[
literal|0
index|]
operator|=
name|primarySeparatorByte
expr_stmt|;
name|secondarySeparator
index|[
literal|0
index|]
operator|=
name|secondarySeparatorByte
expr_stmt|;
name|primaryPattern
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
operator|new
name|String
argument_list|(
name|primarySeparator
argument_list|)
argument_list|)
expr_stmt|;
name|secondaryPattern
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
operator|new
name|String
argument_list|(
name|secondarySeparator
argument_list|)
argument_list|)
expr_stmt|;
name|mapPattern
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\0"
operator|+
name|secondarySeparatorByte
operator|+
literal|"|\\0"
operator|+
name|mapSeparatorByte
argument_list|)
expr_stmt|;
name|transportTokenizer
operator|=
operator|new
name|SimpleTransportTokenizer
argument_list|(
name|innerTransport
argument_list|,
name|rowSeparatorByte
argument_list|,
name|bufferSize
argument_list|)
expr_stmt|;
block|}
comment|/**    * Initialize the TProtocol    * @param conf System properties    * @param tbl  table properties    * @throws TException    */
specifier|public
name|void
name|initialize
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Properties
name|tbl
parameter_list|)
throws|throws
name|TException
block|{
name|primarySeparatorByte
operator|=
name|Byte
operator|.
name|valueOf
argument_list|(
name|tbl
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|FIELD_DELIM
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|primarySeparatorByte
argument_list|)
argument_list|)
argument_list|)
operator|.
name|byteValue
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"collections delim=<"
operator|+
name|tbl
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|COLLECTION_DELIM
argument_list|)
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|secondarySeparatorByte
operator|=
name|Byte
operator|.
name|valueOf
argument_list|(
name|tbl
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|COLLECTION_DELIM
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|secondarySeparatorByte
argument_list|)
argument_list|)
argument_list|)
operator|.
name|byteValue
argument_list|()
expr_stmt|;
name|rowSeparatorByte
operator|=
name|Byte
operator|.
name|valueOf
argument_list|(
name|tbl
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|LINE_DELIM
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|rowSeparatorByte
argument_list|)
argument_list|)
argument_list|)
operator|.
name|byteValue
argument_list|()
expr_stmt|;
name|mapSeparatorByte
operator|=
name|Byte
operator|.
name|valueOf
argument_list|(
name|tbl
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|MAPKEY_DELIM
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|mapSeparatorByte
argument_list|)
argument_list|)
argument_list|)
operator|.
name|byteValue
argument_list|()
expr_stmt|;
name|returnNulls
operator|=
name|Boolean
operator|.
name|valueOf
argument_list|(
name|tbl
operator|.
name|getProperty
argument_list|(
name|ReturnNullsKey
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|returnNulls
argument_list|)
argument_list|)
argument_list|)
operator|.
name|booleanValue
argument_list|()
expr_stmt|;
name|bufferSize
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|tbl
operator|.
name|getProperty
argument_list|(
name|BufferSizeKey
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|bufferSize
argument_list|)
argument_list|)
argument_list|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
name|internalInitialize
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|writeMessageBegin
parameter_list|(
name|TMessage
name|message
parameter_list|)
throws|throws
name|TException
block|{   }
specifier|public
name|void
name|writeMessageEnd
parameter_list|()
throws|throws
name|TException
block|{   }
specifier|public
name|void
name|writeStructBegin
parameter_list|(
name|TStruct
name|struct
parameter_list|)
throws|throws
name|TException
block|{
name|firstField
operator|=
literal|true
expr_stmt|;
block|}
specifier|public
name|void
name|writeStructEnd
parameter_list|()
throws|throws
name|TException
block|{
comment|// We don't write rowSeparatorByte because that should be handled by file format.
block|}
specifier|public
name|void
name|writeFieldBegin
parameter_list|(
name|TField
name|field
parameter_list|)
throws|throws
name|TException
block|{
if|if
condition|(
operator|!
name|firstField
condition|)
block|{
name|writeByte
argument_list|(
name|primarySeparatorByte
argument_list|)
expr_stmt|;
block|}
name|firstField
operator|=
literal|false
expr_stmt|;
block|}
specifier|public
name|void
name|writeFieldEnd
parameter_list|()
throws|throws
name|TException
block|{   }
specifier|public
name|void
name|writeFieldStop
parameter_list|()
block|{   }
specifier|public
name|void
name|writeMapBegin
parameter_list|(
name|TMap
name|map
parameter_list|)
throws|throws
name|TException
block|{
comment|// nesting not allowed!
if|if
condition|(
name|map
operator|.
name|keyType
operator|==
name|TType
operator|.
name|STRUCT
operator|||
name|map
operator|.
name|keyType
operator|==
name|TType
operator|.
name|MAP
operator|||
name|map
operator|.
name|keyType
operator|==
name|TType
operator|.
name|LIST
operator|||
name|map
operator|.
name|keyType
operator|==
name|TType
operator|.
name|SET
condition|)
block|{
throw|throw
operator|new
name|TException
argument_list|(
literal|"Not implemented: nested structures"
argument_list|)
throw|;
block|}
comment|// nesting not allowed!
if|if
condition|(
name|map
operator|.
name|valueType
operator|==
name|TType
operator|.
name|STRUCT
operator|||
name|map
operator|.
name|valueType
operator|==
name|TType
operator|.
name|MAP
operator|||
name|map
operator|.
name|valueType
operator|==
name|TType
operator|.
name|LIST
operator|||
name|map
operator|.
name|valueType
operator|==
name|TType
operator|.
name|SET
condition|)
block|{
throw|throw
operator|new
name|TException
argument_list|(
literal|"Not implemented: nested structures"
argument_list|)
throw|;
block|}
name|firstInnerField
operator|=
literal|true
expr_stmt|;
name|isMap
operator|=
literal|true
expr_stmt|;
name|inner
operator|=
literal|true
expr_stmt|;
name|elemIndex
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|void
name|writeMapEnd
parameter_list|()
throws|throws
name|TException
block|{
name|isMap
operator|=
literal|false
expr_stmt|;
name|inner
operator|=
literal|false
expr_stmt|;
block|}
specifier|public
name|void
name|writeListBegin
parameter_list|(
name|TList
name|list
parameter_list|)
throws|throws
name|TException
block|{
if|if
condition|(
name|list
operator|.
name|elemType
operator|==
name|TType
operator|.
name|STRUCT
operator|||
name|list
operator|.
name|elemType
operator|==
name|TType
operator|.
name|MAP
operator|||
name|list
operator|.
name|elemType
operator|==
name|TType
operator|.
name|LIST
operator|||
name|list
operator|.
name|elemType
operator|==
name|TType
operator|.
name|SET
condition|)
block|{
throw|throw
operator|new
name|TException
argument_list|(
literal|"Not implemented: nested structures"
argument_list|)
throw|;
block|}
name|firstInnerField
operator|=
literal|true
expr_stmt|;
name|inner
operator|=
literal|true
expr_stmt|;
block|}
specifier|public
name|void
name|writeListEnd
parameter_list|()
throws|throws
name|TException
block|{
name|inner
operator|=
literal|false
expr_stmt|;
block|}
specifier|public
name|void
name|writeSetBegin
parameter_list|(
name|TSet
name|set
parameter_list|)
throws|throws
name|TException
block|{
if|if
condition|(
name|set
operator|.
name|elemType
operator|==
name|TType
operator|.
name|STRUCT
operator|||
name|set
operator|.
name|elemType
operator|==
name|TType
operator|.
name|MAP
operator|||
name|set
operator|.
name|elemType
operator|==
name|TType
operator|.
name|LIST
operator|||
name|set
operator|.
name|elemType
operator|==
name|TType
operator|.
name|SET
condition|)
block|{
throw|throw
operator|new
name|TException
argument_list|(
literal|"Not implemented: nested structures"
argument_list|)
throw|;
block|}
name|firstInnerField
operator|=
literal|true
expr_stmt|;
name|inner
operator|=
literal|true
expr_stmt|;
block|}
specifier|public
name|void
name|writeSetEnd
parameter_list|()
throws|throws
name|TException
block|{
name|inner
operator|=
literal|false
expr_stmt|;
block|}
specifier|public
name|void
name|writeBool
parameter_list|(
name|boolean
name|b
parameter_list|)
throws|throws
name|TException
block|{
name|writeString
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// for writing out single byte
specifier|private
name|byte
name|buf
index|[]
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
specifier|public
name|void
name|writeByte
parameter_list|(
name|byte
name|b
parameter_list|)
throws|throws
name|TException
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|b
expr_stmt|;
name|trans_
operator|.
name|write
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|writeI16
parameter_list|(
name|short
name|i16
parameter_list|)
throws|throws
name|TException
block|{
name|writeString
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|i16
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|writeI32
parameter_list|(
name|int
name|i32
parameter_list|)
throws|throws
name|TException
block|{
name|writeString
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|i32
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|writeI64
parameter_list|(
name|long
name|i64
parameter_list|)
throws|throws
name|TException
block|{
name|writeString
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|i64
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|writeDouble
parameter_list|(
name|double
name|dub
parameter_list|)
throws|throws
name|TException
block|{
name|writeString
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|dub
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|writeString
parameter_list|(
name|String
name|str
parameter_list|)
throws|throws
name|TException
block|{
if|if
condition|(
name|inner
condition|)
block|{
if|if
condition|(
operator|!
name|firstInnerField
condition|)
block|{
comment|// super hack city notice the mod plus only happens after firstfield hit, so == 0 is right.
if|if
condition|(
name|isMap
operator|&&
name|elemIndex
operator|++
operator|%
literal|2
operator|==
literal|0
condition|)
block|{
name|writeByte
argument_list|(
name|mapSeparatorByte
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeByte
argument_list|(
name|secondarySeparatorByte
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|firstInnerField
operator|=
literal|false
expr_stmt|;
block|}
block|}
specifier|final
name|byte
name|buf
index|[]
init|=
name|str
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|trans_
operator|.
name|write
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|writeBinary
parameter_list|(
name|byte
index|[]
name|bin
parameter_list|)
throws|throws
name|TException
block|{
throw|throw
operator|new
name|TException
argument_list|(
literal|"Ctl separated protocol cannot support writing Binary data!"
argument_list|)
throw|;
block|}
specifier|public
name|TMessage
name|readMessageBegin
parameter_list|()
throws|throws
name|TException
block|{
return|return
operator|new
name|TMessage
argument_list|()
return|;
block|}
specifier|public
name|void
name|readMessageEnd
parameter_list|()
throws|throws
name|TException
block|{   }
specifier|public
name|TStruct
name|readStructBegin
parameter_list|()
throws|throws
name|TException
block|{
assert|assert
operator|(
operator|!
name|inner
operator|)
assert|;
try|try
block|{
specifier|final
name|String
name|tmp
init|=
name|transportTokenizer
operator|.
name|nextToken
argument_list|()
decl_stmt|;
name|columns
operator|=
name|primaryPattern
operator|.
name|split
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
return|return
operator|new
name|TStruct
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|void
name|readStructEnd
parameter_list|()
throws|throws
name|TException
block|{
name|columns
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|TField
name|readFieldBegin
parameter_list|()
throws|throws
name|TException
block|{
assert|assert
operator|(
operator|!
name|inner
operator|)
assert|;
name|TField
name|f
init|=
operator|new
name|TField
argument_list|()
decl_stmt|;
comment|// slight hack to communicate to DynamicSerDe that the field ids are not being set but things are ordered.
name|f
operator|.
name|type
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|f
return|;
block|}
specifier|public
name|void
name|readFieldEnd
parameter_list|()
throws|throws
name|TException
block|{
name|fields
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|TMap
name|readMapBegin
parameter_list|()
throws|throws
name|TException
block|{
assert|assert
operator|(
operator|!
name|inner
operator|)
assert|;
name|TMap
name|map
init|=
operator|new
name|TMap
argument_list|()
decl_stmt|;
name|fields
operator|=
name|mapPattern
operator|.
name|split
argument_list|(
name|columns
index|[
name|index
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
operator|!=
literal|null
condition|)
block|{
name|map
operator|.
name|size
operator|=
name|fields
operator|.
name|length
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
name|map
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
name|innerIndex
operator|=
literal|0
expr_stmt|;
name|inner
operator|=
literal|true
expr_stmt|;
name|isMap
operator|=
literal|true
expr_stmt|;
return|return
name|map
return|;
block|}
specifier|public
name|void
name|readMapEnd
parameter_list|()
throws|throws
name|TException
block|{
name|inner
operator|=
literal|false
expr_stmt|;
name|isMap
operator|=
literal|false
expr_stmt|;
block|}
specifier|public
name|TList
name|readListBegin
parameter_list|()
throws|throws
name|TException
block|{
assert|assert
operator|(
operator|!
name|inner
operator|)
assert|;
name|TList
name|list
init|=
operator|new
name|TList
argument_list|()
decl_stmt|;
name|fields
operator|=
name|secondaryPattern
operator|.
name|split
argument_list|(
name|columns
index|[
name|index
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
operator|!=
literal|null
condition|)
block|{
name|list
operator|.
name|size
operator|=
name|fields
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|list
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
name|innerIndex
operator|=
literal|0
expr_stmt|;
name|inner
operator|=
literal|true
expr_stmt|;
return|return
name|list
return|;
block|}
specifier|public
name|void
name|readListEnd
parameter_list|()
throws|throws
name|TException
block|{
name|inner
operator|=
literal|false
expr_stmt|;
block|}
specifier|public
name|TSet
name|readSetBegin
parameter_list|()
throws|throws
name|TException
block|{
assert|assert
operator|(
operator|!
name|inner
operator|)
assert|;
name|TSet
name|set
init|=
operator|new
name|TSet
argument_list|()
decl_stmt|;
name|fields
operator|=
name|secondaryPattern
operator|.
name|split
argument_list|(
name|columns
index|[
name|index
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
operator|!=
literal|null
condition|)
block|{
name|set
operator|.
name|size
operator|=
name|fields
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|set
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
name|inner
operator|=
literal|true
expr_stmt|;
name|innerIndex
operator|=
literal|0
expr_stmt|;
return|return
name|set
return|;
block|}
specifier|public
name|void
name|readSetEnd
parameter_list|()
throws|throws
name|TException
block|{
name|inner
operator|=
literal|false
expr_stmt|;
block|}
specifier|public
name|boolean
name|readBool
parameter_list|()
throws|throws
name|TException
block|{
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|readString
argument_list|()
argument_list|)
operator|.
name|booleanValue
argument_list|()
return|;
block|}
specifier|public
name|byte
name|readByte
parameter_list|()
throws|throws
name|TException
block|{
return|return
name|Byte
operator|.
name|valueOf
argument_list|(
name|readString
argument_list|()
argument_list|)
operator|.
name|byteValue
argument_list|()
return|;
block|}
specifier|public
name|short
name|readI16
parameter_list|()
throws|throws
name|TException
block|{
return|return
name|Short
operator|.
name|valueOf
argument_list|(
name|readString
argument_list|()
argument_list|)
operator|.
name|shortValue
argument_list|()
return|;
block|}
specifier|public
name|int
name|readI32
parameter_list|()
throws|throws
name|TException
block|{
return|return
name|Integer
operator|.
name|valueOf
argument_list|(
name|readString
argument_list|()
argument_list|)
operator|.
name|intValue
argument_list|()
return|;
block|}
specifier|public
name|long
name|readI64
parameter_list|()
throws|throws
name|TException
block|{
return|return
name|Long
operator|.
name|valueOf
argument_list|(
name|readString
argument_list|()
argument_list|)
operator|.
name|longValue
argument_list|()
return|;
block|}
specifier|public
name|double
name|readDouble
parameter_list|()
throws|throws
name|TException
block|{
return|return
name|Double
operator|.
name|valueOf
argument_list|(
name|readString
argument_list|()
argument_list|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
specifier|protected
name|String
index|[]
name|curMapPair
decl_stmt|;
specifier|public
name|String
name|readString
parameter_list|()
throws|throws
name|TException
block|{
name|String
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|inner
condition|)
block|{
name|ret
operator|=
name|columns
operator|!=
literal|null
operator|&&
name|index
operator|<
name|columns
operator|.
name|length
condition|?
name|columns
index|[
name|index
operator|++
index|]
else|:
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|fields
operator|!=
literal|null
operator|&&
name|innerIndex
operator|<
name|fields
operator|.
name|length
condition|?
name|fields
index|[
name|innerIndex
operator|++
index|]
else|:
literal|null
expr_stmt|;
block|}
return|return
name|ret
operator|==
literal|null
operator|&&
operator|!
name|returnNulls
condition|?
literal|""
else|:
name|ret
return|;
block|}
specifier|public
name|byte
index|[]
name|readBinary
parameter_list|()
throws|throws
name|TException
block|{
throw|throw
operator|new
name|TException
argument_list|(
literal|"Not implemented for control separated data"
argument_list|)
throw|;
block|}
block|}
end_class

end_unit

