begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|teradata
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|HiveDecimal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|Timestamp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|ByteWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|DateWritableV2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|DoubleWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|HiveCharWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|HiveDecimalWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|HiveVarcharWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|ShortWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|TimestampWritableV2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|PrimitiveObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|serdeConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|AbstractSerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|BinaryObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|ByteObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|DateObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|DoubleObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|HiveCharObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|HiveDecimalObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|HiveVarcharObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|IntObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|LongObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|ShortObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|TimestampObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|CharTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|DecimalTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|PrimitiveTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|VarcharTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|BytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IntWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|String
operator|.
name|format
import|;
end_import

begin_comment
comment|/**  * https://cwiki.apache.org/confluence/display/Hive/TeradataBinarySerde.  * TeradataBinarySerde handles the serialization and deserialization of Teradata Binary Record  * passed from TeradataBinaryRecordReader.  *  * The Teradata Binary Record uses little-endian to handle the SHORT, INT, LONG, DOUBLE...  * We extend SwappedDataInputStream to handle these types and extend to handle the Teradata  * specific types like VARCHAR, CHAR, TIMESTAMP, DATE...  *  * Currently we support 11 Teradata data types: VARCHAR ,INTEGER, TIMESTAMP, FLOAT, DATE,  * BYTEINT, BIGINT, CHARACTER, DECIMAL, SMALLINT, VARBYTE.  * The mapping between Teradata data type and Hive data type is  * Teradata Data Type: Hive Data Type  * VARCHAR: VARCHAR,  * INTEGER: INT,  * TIMESTAMP: TIMESTAMP,  * FLOAT: DOUBLE,  * DATE: DATE,  * BYTEINT: TINYINT ,  * BIGINT: BIGINT,  * CHAR: CHAR,  * DECIMAL: DECIMAL,  * SMALLINT: SMALLINT,  * VARBYTE: BINARY.  *  * TeradataBinarySerde currently doesn't support complex types like MAP, ARRAY and STRUCT.  */
end_comment

begin_class
annotation|@
name|SerDeSpec
argument_list|(
name|schemaProps
operator|=
block|{
name|serdeConstants
operator|.
name|LIST_COLUMNS
block|,
name|serdeConstants
operator|.
name|LIST_COLUMN_TYPES
block|}
argument_list|)
specifier|public
class|class
name|TeradataBinarySerde
extends|extends
name|AbstractSerDe
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TeradataBinarySerde
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|TD_SCHEMA_LITERAL
init|=
literal|"teradata.schema.literal"
decl_stmt|;
specifier|private
name|StructObjectInspector
name|rowOI
decl_stmt|;
specifier|private
name|ArrayList
argument_list|<
name|Object
argument_list|>
name|row
decl_stmt|;
specifier|private
name|byte
index|[]
name|inForNull
decl_stmt|;
specifier|private
name|int
name|numCols
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|columnNames
decl_stmt|;
specifier|private
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|columnTypes
decl_stmt|;
specifier|private
name|TeradataBinaryDataOutputStream
name|out
decl_stmt|;
specifier|private
name|BytesWritable
name|serializeBytesWritable
decl_stmt|;
specifier|private
name|byte
index|[]
name|outForNull
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|TD_TIMESTAMP_PRECISION
init|=
literal|"teradata.timestamp.precision"
decl_stmt|;
specifier|private
name|int
name|timestampPrecision
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_TIMESTAMP_BYTE_NUM
init|=
literal|19
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|DEFAULT_TIMESTAMP_PRECISION
init|=
literal|"6"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|TD_CHAR_SET
init|=
literal|"teradata.char.charset"
decl_stmt|;
specifier|private
name|String
name|charCharset
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|DEFAULT_CHAR_CHARSET
init|=
literal|"UNICODE"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|CHARSET_TO_BYTE_NUM
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"LATIN"
argument_list|,
literal|2
argument_list|,
literal|"UNICODE"
argument_list|,
literal|3
argument_list|)
decl_stmt|;
comment|/**    * Initialize the HiveSerializer.    *    * @param conf    *          System properties. Can be null in compile time    * @param tbl    *          table properties    * @throws SerDeException    */
annotation|@
name|Override
specifier|public
name|void
name|initialize
parameter_list|(
annotation|@
name|Nullable
name|Configuration
name|conf
parameter_list|,
name|Properties
name|tbl
parameter_list|)
throws|throws
name|SerDeException
block|{
name|columnNames
operator|=
name|Arrays
operator|.
name|asList
argument_list|(
name|tbl
operator|.
name|getProperty
argument_list|(
name|serdeConstants
operator|.
name|LIST_COLUMNS
argument_list|)
operator|.
name|split
argument_list|(
literal|","
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|columnTypeProperty
init|=
name|tbl
operator|.
name|getProperty
argument_list|(
name|serdeConstants
operator|.
name|LIST_COLUMN_TYPES
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|serdeConstants
operator|.
name|LIST_COLUMN_TYPES
operator|+
literal|": "
operator|+
name|columnTypeProperty
argument_list|)
expr_stmt|;
if|if
condition|(
name|columnTypeProperty
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|columnTypes
operator|=
operator|new
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|columnTypes
operator|=
name|TypeInfoUtils
operator|.
name|getTypeInfosFromTypeString
argument_list|(
name|columnTypeProperty
argument_list|)
expr_stmt|;
block|}
assert|assert
name|columnNames
operator|.
name|size
argument_list|()
operator|==
name|columnTypes
operator|.
name|size
argument_list|()
assert|;
name|numCols
operator|=
name|columnNames
operator|.
name|size
argument_list|()
expr_stmt|;
comment|// get the configured teradata timestamp precision
comment|// you can configure to generate timestamp of different precision in the binary file generated by TPT/BTEQ
name|timestampPrecision
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|tbl
operator|.
name|getProperty
argument_list|(
name|TD_TIMESTAMP_PRECISION
argument_list|,
name|DEFAULT_TIMESTAMP_PRECISION
argument_list|)
argument_list|)
expr_stmt|;
comment|// get the configured teradata char charset
comment|// in TD, latin charset will have 2 bytes per char and unicode will have 3 bytes per char
name|charCharset
operator|=
name|tbl
operator|.
name|getProperty
argument_list|(
name|TD_CHAR_SET
argument_list|,
name|DEFAULT_CHAR_CHARSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHARSET_TO_BYTE_NUM
operator|.
name|containsKey
argument_list|(
name|charCharset
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SerDeException
argument_list|(
name|format
argument_list|(
literal|"%s isn't supported in Teradata Char Charset %s"
argument_list|,
name|charCharset
argument_list|,
name|CHARSET_TO_BYTE_NUM
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|// All columns have to be primitive.
comment|// Constructing the row ObjectInspector:
name|List
argument_list|<
name|ObjectInspector
argument_list|>
name|columnOIs
init|=
operator|new
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
argument_list|(
name|numCols
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numCols
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|columnTypes
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getCategory
argument_list|()
operator|!=
name|ObjectInspector
operator|.
name|Category
operator|.
name|PRIMITIVE
condition|)
block|{
throw|throw
operator|new
name|SerDeException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" only accepts primitive columns, but column["
operator|+
name|i
operator|+
literal|"] named "
operator|+
name|columnNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|+
literal|" has category "
operator|+
name|columnTypes
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getCategory
argument_list|()
argument_list|)
throw|;
block|}
name|columnOIs
operator|.
name|add
argument_list|(
name|TypeInfoUtils
operator|.
name|getStandardWritableObjectInspectorFromTypeInfo
argument_list|(
name|columnTypes
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rowOI
operator|=
name|ObjectInspectorFactory
operator|.
name|getStandardStructObjectInspector
argument_list|(
name|columnNames
argument_list|,
name|columnOIs
argument_list|)
expr_stmt|;
comment|// Constructing the row object and will be reused for all rows
name|row
operator|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|(
name|numCols
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numCols
condition|;
name|i
operator|++
control|)
block|{
name|row
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// Initialize vars related to Null Array which represents the null bitmap
name|int
name|byteNumForNullArray
init|=
operator|(
name|numCols
operator|/
literal|8
operator|)
operator|+
operator|(
operator|(
name|numCols
operator|%
literal|8
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|format
argument_list|(
literal|"The Null Bytes for each record will have %s bytes"
argument_list|,
name|byteNumForNullArray
argument_list|)
argument_list|)
expr_stmt|;
name|inForNull
operator|=
operator|new
name|byte
index|[
name|byteNumForNullArray
index|]
expr_stmt|;
name|out
operator|=
operator|new
name|TeradataBinaryDataOutputStream
argument_list|()
expr_stmt|;
name|serializeBytesWritable
operator|=
operator|new
name|BytesWritable
argument_list|()
expr_stmt|;
name|outForNull
operator|=
operator|new
name|byte
index|[
name|byteNumForNullArray
index|]
expr_stmt|;
block|}
comment|/**    * Returns the Writable class that would be returned by the serialize method.    * This is used to initialize SequenceFile header.    */
annotation|@
name|Override
specifier|public
name|Class
argument_list|<
name|?
extends|extends
name|Writable
argument_list|>
name|getSerializedClass
parameter_list|()
block|{
return|return
name|ByteWritable
operator|.
name|class
return|;
block|}
comment|/**    * Serialize an object by navigating inside the Object with the    * ObjectInspector. In most cases, the return value of this function will be    * constant since the function will reuse the Writable object. If the client    * wants to keep a copy of the Writable, the client needs to clone the    * returned value.     * @param obj    * @param objInspector    */
annotation|@
name|Override
specifier|public
name|Writable
name|serialize
parameter_list|(
name|Object
name|obj
parameter_list|,
name|ObjectInspector
name|objInspector
parameter_list|)
throws|throws
name|SerDeException
block|{
try|try
block|{
name|out
operator|.
name|reset
argument_list|()
expr_stmt|;
specifier|final
name|StructObjectInspector
name|outputRowOI
init|=
operator|(
name|StructObjectInspector
operator|)
name|objInspector
decl_stmt|;
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|fieldRefs
init|=
name|outputRowOI
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldRefs
operator|.
name|size
argument_list|()
operator|!=
name|numCols
condition|)
block|{
throw|throw
operator|new
name|SerDeException
argument_list|(
literal|"Cannot serialize the object because there are "
operator|+
name|fieldRefs
operator|.
name|size
argument_list|()
operator|+
literal|" fieldRefs but the table defined "
operator|+
name|numCols
operator|+
literal|" columns."
argument_list|)
throw|;
block|}
comment|// Fully refresh the Null Array to write into the out
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numCols
condition|;
name|i
operator|++
control|)
block|{
name|Object
name|objectForField
init|=
name|outputRowOI
operator|.
name|getStructFieldData
argument_list|(
name|obj
argument_list|,
name|fieldRefs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|objectForField
operator|==
literal|null
condition|)
block|{
name|outForNull
index|[
name|i
operator|/
literal|8
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|outForNull
index|[
name|i
operator|/
literal|8
index|]
operator||
operator|(
literal|0x01
operator|<<
operator|(
literal|7
operator|-
operator|(
name|i
operator|%
literal|8
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outForNull
index|[
name|i
operator|/
literal|8
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|outForNull
index|[
name|i
operator|/
literal|8
index|]
operator|&
operator|~
operator|(
literal|0x01
operator|<<
operator|(
literal|7
operator|-
operator|(
name|i
operator|%
literal|8
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|out
operator|.
name|write
argument_list|(
name|outForNull
argument_list|)
expr_stmt|;
comment|// serialize each field using FieldObjectInspector
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numCols
condition|;
name|i
operator|++
control|)
block|{
name|Object
name|objectForField
init|=
name|outputRowOI
operator|.
name|getStructFieldData
argument_list|(
name|obj
argument_list|,
name|fieldRefs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|serializeField
argument_list|(
name|objectForField
argument_list|,
name|fieldRefs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|,
name|columnTypes
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|serializeBytesWritable
operator|.
name|set
argument_list|(
name|out
operator|.
name|toByteArray
argument_list|()
argument_list|,
literal|0
argument_list|,
name|out
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|serializeBytesWritable
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SerDeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|serializeField
parameter_list|(
name|Object
name|objectForField
parameter_list|,
name|ObjectInspector
name|oi
parameter_list|,
name|TypeInfo
name|ti
parameter_list|)
throws|throws
name|IOException
throws|,
name|SerDeException
block|{
switch|switch
condition|(
name|oi
operator|.
name|getCategory
argument_list|()
condition|)
block|{
case|case
name|PRIMITIVE
case|:
name|PrimitiveObjectInspector
name|poi
init|=
operator|(
name|PrimitiveObjectInspector
operator|)
name|oi
decl_stmt|;
switch|switch
condition|(
name|poi
operator|.
name|getPrimitiveCategory
argument_list|()
condition|)
block|{
comment|// Teradata Type: BYTEINT
case|case
name|BYTE
case|:
name|ByteObjectInspector
name|boi
init|=
operator|(
name|ByteObjectInspector
operator|)
name|poi
decl_stmt|;
name|byte
name|b
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|objectForField
operator|!=
literal|null
condition|)
block|{
name|b
operator|=
name|boi
operator|.
name|get
argument_list|(
name|objectForField
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return;
comment|// Teradata Type: SMALLINT
case|case
name|SHORT
case|:
name|ShortObjectInspector
name|spoi
init|=
operator|(
name|ShortObjectInspector
operator|)
name|poi
decl_stmt|;
name|short
name|s
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|objectForField
operator|!=
literal|null
condition|)
block|{
name|s
operator|=
name|spoi
operator|.
name|get
argument_list|(
name|objectForField
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|writeShort
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
comment|// Teradata Type: INT
case|case
name|INT
case|:
name|IntObjectInspector
name|ioi
init|=
operator|(
name|IntObjectInspector
operator|)
name|poi
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|objectForField
operator|!=
literal|null
condition|)
block|{
name|i
operator|=
name|ioi
operator|.
name|get
argument_list|(
name|objectForField
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|writeInt
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return;
comment|// Teradata Type: BIGINT
case|case
name|LONG
case|:
name|LongObjectInspector
name|loi
init|=
operator|(
name|LongObjectInspector
operator|)
name|poi
decl_stmt|;
name|long
name|l
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|objectForField
operator|!=
literal|null
condition|)
block|{
name|l
operator|=
name|loi
operator|.
name|get
argument_list|(
name|objectForField
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|writeLong
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return;
comment|// Teradata Type: FLOAT
case|case
name|DOUBLE
case|:
name|DoubleObjectInspector
name|doi
init|=
operator|(
name|DoubleObjectInspector
operator|)
name|poi
decl_stmt|;
name|double
name|d
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|objectForField
operator|!=
literal|null
condition|)
block|{
name|d
operator|=
name|doi
operator|.
name|get
argument_list|(
name|objectForField
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|writeDouble
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return;
comment|// Teradata Type: VARCHAR
case|case
name|VARCHAR
case|:
name|HiveVarcharObjectInspector
name|hvoi
init|=
operator|(
name|HiveVarcharObjectInspector
operator|)
name|poi
decl_stmt|;
name|HiveVarcharWritable
name|hv
init|=
name|hvoi
operator|.
name|getPrimitiveWritableObject
argument_list|(
name|objectForField
argument_list|)
decl_stmt|;
comment|// assert the length of varchar record fits into the table definition
if|if
condition|(
name|hv
operator|!=
literal|null
condition|)
block|{
assert|assert
operator|(
operator|(
name|VarcharTypeInfo
operator|)
name|ti
operator|)
operator|.
name|getLength
argument_list|()
operator|>=
name|hv
operator|.
name|getHiveVarchar
argument_list|()
operator|.
name|getCharacterLength
argument_list|()
assert|;
block|}
name|out
operator|.
name|writeVarChar
argument_list|(
name|hv
argument_list|)
expr_stmt|;
return|return;
comment|// Teradata Type: TIMESTAMP
case|case
name|TIMESTAMP
case|:
name|TimestampObjectInspector
name|tsoi
init|=
operator|(
name|TimestampObjectInspector
operator|)
name|poi
decl_stmt|;
name|TimestampWritableV2
name|ts
init|=
name|tsoi
operator|.
name|getPrimitiveWritableObject
argument_list|(
name|objectForField
argument_list|)
decl_stmt|;
name|out
operator|.
name|writeTimestamp
argument_list|(
name|ts
argument_list|,
name|getTimeStampByteNum
argument_list|(
name|timestampPrecision
argument_list|)
argument_list|)
expr_stmt|;
return|return;
comment|// Teradata Type: DATE
case|case
name|DATE
case|:
name|DateObjectInspector
name|dtoi
init|=
operator|(
name|DateObjectInspector
operator|)
name|poi
decl_stmt|;
name|DateWritableV2
name|dw
init|=
name|dtoi
operator|.
name|getPrimitiveWritableObject
argument_list|(
name|objectForField
argument_list|)
decl_stmt|;
name|out
operator|.
name|writeDate
argument_list|(
name|dw
argument_list|)
expr_stmt|;
return|return;
comment|// Teradata Type: CHAR
case|case
name|CHAR
case|:
name|HiveCharObjectInspector
name|coi
init|=
operator|(
name|HiveCharObjectInspector
operator|)
name|poi
decl_stmt|;
name|HiveCharWritable
name|hc
init|=
name|coi
operator|.
name|getPrimitiveWritableObject
argument_list|(
name|objectForField
argument_list|)
decl_stmt|;
comment|// assert the length of char record fits into the table definition
if|if
condition|(
name|hc
operator|!=
literal|null
condition|)
block|{
assert|assert
operator|(
operator|(
name|CharTypeInfo
operator|)
name|ti
operator|)
operator|.
name|getLength
argument_list|()
operator|>=
name|hc
operator|.
name|getHiveChar
argument_list|()
operator|.
name|getCharacterLength
argument_list|()
assert|;
block|}
name|out
operator|.
name|writeChar
argument_list|(
name|hc
argument_list|,
name|getCharByteNum
argument_list|(
name|charCharset
argument_list|)
operator|*
operator|(
operator|(
name|CharTypeInfo
operator|)
name|ti
operator|)
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
return|return;
comment|// Teradata Type: DECIMAL
case|case
name|DECIMAL
case|:
name|DecimalTypeInfo
name|dtype
init|=
operator|(
name|DecimalTypeInfo
operator|)
name|ti
decl_stmt|;
name|int
name|precision
init|=
name|dtype
operator|.
name|precision
argument_list|()
decl_stmt|;
name|int
name|scale
init|=
name|dtype
operator|.
name|scale
argument_list|()
decl_stmt|;
name|HiveDecimalObjectInspector
name|hdoi
init|=
operator|(
name|HiveDecimalObjectInspector
operator|)
name|poi
decl_stmt|;
name|HiveDecimalWritable
name|hd
init|=
name|hdoi
operator|.
name|getPrimitiveWritableObject
argument_list|(
name|objectForField
argument_list|)
decl_stmt|;
comment|// assert the precision of decimal record fits into the table definition
if|if
condition|(
name|hd
operator|!=
literal|null
condition|)
block|{
assert|assert
operator|(
name|dtype
operator|.
name|getPrecision
argument_list|()
operator|>=
name|hd
operator|.
name|precision
argument_list|()
operator|)
assert|;
block|}
name|out
operator|.
name|writeDecimal
argument_list|(
name|hd
argument_list|,
name|getDecimalByteNum
argument_list|(
name|precision
argument_list|)
argument_list|,
name|scale
argument_list|)
expr_stmt|;
return|return;
comment|// Teradata Type: VARBYTE
case|case
name|BINARY
case|:
name|BinaryObjectInspector
name|bnoi
init|=
operator|(
name|BinaryObjectInspector
operator|)
name|poi
decl_stmt|;
name|BytesWritable
name|byw
init|=
name|bnoi
operator|.
name|getPrimitiveWritableObject
argument_list|(
name|objectForField
argument_list|)
decl_stmt|;
name|out
operator|.
name|writeVarByte
argument_list|(
name|byw
argument_list|)
expr_stmt|;
return|return;
default|default:
throw|throw
operator|new
name|SerDeException
argument_list|(
literal|"Unrecognized type: "
operator|+
name|poi
operator|.
name|getPrimitiveCategory
argument_list|()
argument_list|)
throw|;
block|}
comment|// Currently, serialization of complex types is not supported
case|case
name|LIST
case|:
case|case
name|MAP
case|:
case|case
name|STRUCT
case|:
default|default:
throw|throw
operator|new
name|SerDeException
argument_list|(
literal|"Unrecognized type: "
operator|+
name|oi
operator|.
name|getCategory
argument_list|()
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|SerDeStats
name|getSerDeStats
parameter_list|()
block|{
comment|// no support for statistics
return|return
literal|null
return|;
block|}
comment|/**    * Deserialize an object out of a Writable blob. In most cases, the return    * value of this function will be constant since the function will reuse the    * returned object. If the client wants to keep a copy of the object, the    * client needs to clone the returned value by calling    * ObjectInspectorUtils.getStandardObject().    *    * @param blob    *          The Writable object containing a serialized object    * @return A Java object representing the contents in the blob.    */
annotation|@
name|Override
specifier|public
name|Object
name|deserialize
parameter_list|(
name|Writable
name|blob
parameter_list|)
throws|throws
name|SerDeException
block|{
try|try
block|{
name|BytesWritable
name|data
init|=
operator|(
name|BytesWritable
operator|)
name|blob
decl_stmt|;
comment|// initialize the data to be the input stream
name|TeradataBinaryDataInputStream
name|in
init|=
operator|new
name|TeradataBinaryDataInputStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|data
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|getLength
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|numOfByteRead
init|=
name|in
operator|.
name|read
argument_list|(
name|inForNull
argument_list|)
decl_stmt|;
if|if
condition|(
name|inForNull
operator|.
name|length
operator|!=
literal|0
operator|&&
name|numOfByteRead
operator|!=
name|inForNull
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"not enough bytes for one object"
argument_list|)
throw|;
block|}
name|boolean
name|isNull
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numCols
condition|;
name|i
operator|++
control|)
block|{
comment|// get if the ith field is null or not
name|isNull
operator|=
operator|(
operator|(
name|inForNull
index|[
name|i
operator|/
literal|8
index|]
operator|&
operator|(
literal|128
operator|>>
operator|(
name|i
operator|%
literal|8
operator|)
operator|)
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|row
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|deserializeField
argument_list|(
name|in
argument_list|,
name|columnTypes
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|row
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|isNull
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//After deserializing all the fields, the input should be over in which case in.read will return -1
if|if
condition|(
name|in
operator|.
name|read
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"The inputstream has more after we deserialize all the fields - this is unexpected"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Catch thrown exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"This record has been polluted. We have reset all the row fields to be null"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numCols
condition|;
name|i
operator|++
control|)
block|{
name|row
operator|.
name|set
argument_list|(
name|i
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SerDeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SerDeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|row
return|;
block|}
specifier|private
name|Object
name|deserializeField
parameter_list|(
name|TeradataBinaryDataInputStream
name|in
parameter_list|,
name|TypeInfo
name|type
parameter_list|,
name|Object
name|reuse
parameter_list|,
name|boolean
name|isNull
parameter_list|)
throws|throws
name|IOException
throws|,
name|ParseException
throws|,
name|SerDeException
block|{
comment|// isNull:
comment|// In the Teradata Binary file, even the field is null (isNull=true),
comment|// thd data still has some default values to pad the record.
comment|// In this case, you cannot avoid reading the bytes even it is not used.
switch|switch
condition|(
name|type
operator|.
name|getCategory
argument_list|()
condition|)
block|{
case|case
name|PRIMITIVE
case|:
name|PrimitiveTypeInfo
name|ptype
init|=
operator|(
name|PrimitiveTypeInfo
operator|)
name|type
decl_stmt|;
switch|switch
condition|(
name|ptype
operator|.
name|getPrimitiveCategory
argument_list|()
condition|)
block|{
case|case
name|VARCHAR
case|:
comment|// Teradata Type: VARCHAR
name|String
name|st
init|=
name|in
operator|.
name|readVarchar
argument_list|()
decl_stmt|;
if|if
condition|(
name|isNull
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|HiveVarcharWritable
name|r
init|=
name|reuse
operator|==
literal|null
condition|?
operator|new
name|HiveVarcharWritable
argument_list|()
else|:
operator|(
name|HiveVarcharWritable
operator|)
name|reuse
decl_stmt|;
name|r
operator|.
name|set
argument_list|(
name|st
argument_list|,
operator|(
operator|(
name|VarcharTypeInfo
operator|)
name|type
operator|)
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|INT
case|:
comment|// Teradata Type: INT
name|int
name|i
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|isNull
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|IntWritable
name|r
init|=
name|reuse
operator|==
literal|null
condition|?
operator|new
name|IntWritable
argument_list|()
else|:
operator|(
name|IntWritable
operator|)
name|reuse
decl_stmt|;
name|r
operator|.
name|set
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|TIMESTAMP
case|:
comment|// Teradata Type: TIMESTAMP
name|Timestamp
name|ts
init|=
name|in
operator|.
name|readTimestamp
argument_list|(
name|getTimeStampByteNum
argument_list|(
name|timestampPrecision
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|isNull
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|TimestampWritableV2
name|r
init|=
name|reuse
operator|==
literal|null
condition|?
operator|new
name|TimestampWritableV2
argument_list|()
else|:
operator|(
name|TimestampWritableV2
operator|)
name|reuse
decl_stmt|;
name|r
operator|.
name|set
argument_list|(
name|ts
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|DOUBLE
case|:
comment|// Teradata Type: FLOAT
name|double
name|d
init|=
name|in
operator|.
name|readDouble
argument_list|()
decl_stmt|;
if|if
condition|(
name|isNull
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|DoubleWritable
name|r
init|=
name|reuse
operator|==
literal|null
condition|?
operator|new
name|DoubleWritable
argument_list|()
else|:
operator|(
name|DoubleWritable
operator|)
name|reuse
decl_stmt|;
name|r
operator|.
name|set
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|DATE
case|:
comment|// Teradata Type: DATE
name|Date
name|dt
init|=
name|in
operator|.
name|readDate
argument_list|()
decl_stmt|;
if|if
condition|(
name|isNull
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|DateWritableV2
name|r
init|=
name|reuse
operator|==
literal|null
condition|?
operator|new
name|DateWritableV2
argument_list|()
else|:
operator|(
name|DateWritableV2
operator|)
name|reuse
decl_stmt|;
name|r
operator|.
name|set
argument_list|(
name|dt
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|BYTE
case|:
comment|// Teradata Type: BYTEINT
name|byte
name|bt
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
if|if
condition|(
name|isNull
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|ByteWritable
name|r
init|=
name|reuse
operator|==
literal|null
condition|?
operator|new
name|ByteWritable
argument_list|()
else|:
operator|(
name|ByteWritable
operator|)
name|reuse
decl_stmt|;
name|r
operator|.
name|set
argument_list|(
name|bt
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|LONG
case|:
comment|// Teradata Type: BIGINT
name|long
name|l
init|=
name|in
operator|.
name|readLong
argument_list|()
decl_stmt|;
if|if
condition|(
name|isNull
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|LongWritable
name|r
init|=
name|reuse
operator|==
literal|null
condition|?
operator|new
name|LongWritable
argument_list|()
else|:
operator|(
name|LongWritable
operator|)
name|reuse
decl_stmt|;
name|r
operator|.
name|set
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|CHAR
case|:
comment|// Teradata Type: CHAR
name|CharTypeInfo
name|ctype
init|=
operator|(
name|CharTypeInfo
operator|)
name|type
decl_stmt|;
name|int
name|length
init|=
name|ctype
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|String
name|c
init|=
name|in
operator|.
name|readChar
argument_list|(
name|length
operator|*
name|getCharByteNum
argument_list|(
name|charCharset
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|isNull
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|HiveCharWritable
name|r
init|=
name|reuse
operator|==
literal|null
condition|?
operator|new
name|HiveCharWritable
argument_list|()
else|:
operator|(
name|HiveCharWritable
operator|)
name|reuse
decl_stmt|;
name|r
operator|.
name|set
argument_list|(
name|c
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|DECIMAL
case|:
comment|// Teradata Type: DECIMAL
name|DecimalTypeInfo
name|dtype
init|=
operator|(
name|DecimalTypeInfo
operator|)
name|type
decl_stmt|;
name|int
name|precision
init|=
name|dtype
operator|.
name|precision
argument_list|()
decl_stmt|;
name|int
name|scale
init|=
name|dtype
operator|.
name|scale
argument_list|()
decl_stmt|;
name|HiveDecimal
name|hd
init|=
name|in
operator|.
name|readDecimal
argument_list|(
name|scale
argument_list|,
name|getDecimalByteNum
argument_list|(
name|precision
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|isNull
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|HiveDecimalWritable
name|r
init|=
operator|(
name|reuse
operator|==
literal|null
condition|?
operator|new
name|HiveDecimalWritable
argument_list|()
else|:
operator|(
name|HiveDecimalWritable
operator|)
name|reuse
operator|)
decl_stmt|;
name|r
operator|.
name|set
argument_list|(
name|hd
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|SHORT
case|:
comment|// Teradata Type: SMALLINT
name|short
name|s
init|=
name|in
operator|.
name|readShort
argument_list|()
decl_stmt|;
if|if
condition|(
name|isNull
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|ShortWritable
name|r
init|=
name|reuse
operator|==
literal|null
condition|?
operator|new
name|ShortWritable
argument_list|()
else|:
operator|(
name|ShortWritable
operator|)
name|reuse
decl_stmt|;
name|r
operator|.
name|set
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|BINARY
case|:
comment|// Teradata Type: VARBYTE
name|byte
index|[]
name|content
init|=
name|in
operator|.
name|readVarbyte
argument_list|()
decl_stmt|;
if|if
condition|(
name|isNull
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|BytesWritable
name|r
init|=
operator|new
name|BytesWritable
argument_list|()
decl_stmt|;
name|r
operator|.
name|set
argument_list|(
name|content
argument_list|,
literal|0
argument_list|,
name|content
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
default|default:
throw|throw
operator|new
name|SerDeException
argument_list|(
literal|"Unrecognized type: "
operator|+
name|ptype
operator|.
name|getPrimitiveCategory
argument_list|()
argument_list|)
throw|;
block|}
comment|// Currently, deserialization of complex types is not supported
case|case
name|LIST
case|:
case|case
name|MAP
case|:
case|case
name|STRUCT
case|:
default|default:
throw|throw
operator|new
name|SerDeException
argument_list|(
literal|"Unsupported category: "
operator|+
name|type
operator|.
name|getCategory
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get the object inspector that can be used to navigate through the internal    * structure of the Object returned from deserialize(...).    */
annotation|@
name|Override
specifier|public
name|ObjectInspector
name|getObjectInspector
parameter_list|()
throws|throws
name|SerDeException
block|{
return|return
name|rowOI
return|;
block|}
specifier|private
name|int
name|getTimeStampByteNum
parameter_list|(
name|int
name|precision
parameter_list|)
block|{
if|if
condition|(
name|precision
operator|==
literal|0
condition|)
block|{
return|return
name|DEFAULT_TIMESTAMP_BYTE_NUM
return|;
block|}
else|else
block|{
return|return
name|precision
operator|+
literal|1
operator|+
name|DEFAULT_TIMESTAMP_BYTE_NUM
return|;
block|}
block|}
specifier|private
name|int
name|getCharByteNum
parameter_list|(
name|String
name|charset
parameter_list|)
throws|throws
name|SerDeException
block|{
if|if
condition|(
operator|!
name|CHARSET_TO_BYTE_NUM
operator|.
name|containsKey
argument_list|(
name|charCharset
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SerDeException
argument_list|(
name|format
argument_list|(
literal|"%s isn't supported in Teradata Char Charset %s"
argument_list|,
name|charCharset
argument_list|,
name|CHARSET_TO_BYTE_NUM
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
return|return
name|CHARSET_TO_BYTE_NUM
operator|.
name|get
argument_list|(
name|charset
argument_list|)
return|;
block|}
block|}
specifier|private
name|int
name|getDecimalByteNum
parameter_list|(
name|int
name|precision
parameter_list|)
throws|throws
name|SerDeException
block|{
if|if
condition|(
name|precision
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|SerDeException
argument_list|(
name|format
argument_list|(
literal|"the precision of Decimal should be bigger than 0. %d is illegal"
argument_list|,
name|precision
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|precision
operator|<=
literal|2
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|precision
operator|<=
literal|4
condition|)
block|{
return|return
literal|2
return|;
block|}
if|if
condition|(
name|precision
operator|<=
literal|9
condition|)
block|{
return|return
literal|4
return|;
block|}
if|if
condition|(
name|precision
operator|<=
literal|18
condition|)
block|{
return|return
literal|8
return|;
block|}
if|if
condition|(
name|precision
operator|<=
literal|38
condition|)
block|{
return|return
literal|16
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|format
argument_list|(
literal|"the precision of Decimal should be smaller than 39. %d is illegal"
argument_list|,
name|precision
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_class

end_unit

