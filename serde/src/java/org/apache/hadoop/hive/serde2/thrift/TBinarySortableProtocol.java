begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|thrift
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|TException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|protocol
operator|.
name|TField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|protocol
operator|.
name|TList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|protocol
operator|.
name|TMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|protocol
operator|.
name|TMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|protocol
operator|.
name|TProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|protocol
operator|.
name|TProtocolFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|protocol
operator|.
name|TSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|protocol
operator|.
name|TStruct
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|transport
operator|.
name|TTransport
import|;
end_import

begin_comment
comment|/**  * An implementation of the Thrift Protocol for binary sortable records.  *   * The data format: NULL: a single byte \0 NON-NULL Primitives: ALWAYS prepend a  * single byte \1, and then: Boolean: FALSE = \1, TRUE = \2 Byte: flip the  * sign-bit to make sure negative comes before positive Short: flip the sign-bit  * to make sure negative comes before positive Int: flip the sign-bit to make  * sure negative comes before positive Long: flip the sign-bit to make sure  * negative comes before positive Double: flip the sign-bit for positive double,  * and all bits for negative double values String: NULL-terminated UTF-8 string,  * with NULL escaped to \1 \1, and \1 escaped to \1 \2 NON-NULL Complex Types:  * Struct: first the single byte \1, and then one field by one field. List: size  * stored as Int (see above), then one element by one element. Map: size stored  * as Int (see above), then one key by one value, and then the next pair and so  * on. Binary: size stored as Int (see above), then the binary data in its  * original form  *   * Note that the relative order of list/map/binary will be based on the size  * first (and elements one by one if the sizes are equal).  *   * This protocol takes an additional parameter SERIALIZATION_SORT_ORDER which is  * a string containing only "+" and "-". The length of the string should equal  * to the number of fields in the top-level struct for serialization. "+" means  * the field should be sorted ascendingly, and "-" means descendingly. The sub  * fields in the same top-level field will have the same sort order.  *   * This is not thrift compliant in that it doesn't write out field ids so things  * cannot actually be versioned.  */
end_comment

begin_class
specifier|public
class|class
name|TBinarySortableProtocol
extends|extends
name|TProtocol
implements|implements
name|ConfigurableTProtocol
implements|,
name|WriteNullsProtocol
implements|,
name|WriteTextProtocol
block|{
specifier|final
specifier|static
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TBinarySortableProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|static
name|byte
name|ORDERED_TYPE
init|=
operator|(
name|byte
operator|)
operator|-
literal|1
decl_stmt|;
comment|/**    * Factory for TBinarySortableProtocol objects    */
specifier|public
specifier|static
class|class
name|Factory
implements|implements
name|TProtocolFactory
block|{
specifier|public
name|TProtocol
name|getProtocol
parameter_list|(
name|TTransport
name|trans
parameter_list|)
block|{
return|return
operator|new
name|TBinarySortableProtocol
argument_list|(
name|trans
argument_list|)
return|;
block|}
block|}
specifier|public
name|TBinarySortableProtocol
parameter_list|(
name|TTransport
name|trans
parameter_list|)
block|{
name|super
argument_list|(
name|trans
argument_list|)
expr_stmt|;
name|stackLevel
operator|=
literal|0
expr_stmt|;
block|}
comment|/**    * The stack level of the current field. Top-level fields have a stackLevel    * value of 1. Each nested struct/list/map will increase the stackLevel value    * by 1.    */
name|int
name|stackLevel
decl_stmt|;
comment|/**    * The field ID in the top level struct. This is used to determine whether    * this field should be sorted ascendingly or descendingly.    */
name|int
name|topLevelStructFieldID
decl_stmt|;
comment|/**    * A string that consists of only "+" and "-". It should have the same length    * as the number of fields in the top level struct. "+" means the    * corresponding field is sorted ascendingly and "-" means the corresponding    * field is sorted descendingly.    */
name|String
name|sortOrder
decl_stmt|;
comment|/**    * Whether the current field is sorted ascendingly. Always equals to    * sortOrder.charAt(topLevelStructFieldID) != '-'    */
name|boolean
name|ascending
decl_stmt|;
specifier|public
name|void
name|initialize
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Properties
name|tbl
parameter_list|)
throws|throws
name|TException
block|{
name|sortOrder
operator|=
name|tbl
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|SERIALIZATION_SORT_ORDER
argument_list|)
expr_stmt|;
if|if
condition|(
name|sortOrder
operator|==
literal|null
condition|)
block|{
name|sortOrder
operator|=
literal|""
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sortOrder
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|sortOrder
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'+'
operator|&&
name|c
operator|!=
literal|'-'
condition|)
block|{
throw|throw
operator|new
name|TException
argument_list|(
name|Constants
operator|.
name|SERIALIZATION_SORT_ORDER
operator|+
literal|" should be a string consists of only '+' and '-'!"
argument_list|)
throw|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Sort order is \""
operator|+
name|sortOrder
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeMessageBegin
parameter_list|(
name|TMessage
name|message
parameter_list|)
throws|throws
name|TException
block|{   }
annotation|@
name|Override
specifier|public
name|void
name|writeMessageEnd
parameter_list|()
throws|throws
name|TException
block|{   }
annotation|@
name|Override
specifier|public
name|void
name|writeStructBegin
parameter_list|(
name|TStruct
name|struct
parameter_list|)
throws|throws
name|TException
block|{
name|stackLevel
operator|++
expr_stmt|;
if|if
condition|(
name|stackLevel
operator|==
literal|1
condition|)
block|{
name|topLevelStructFieldID
operator|=
literal|0
expr_stmt|;
name|ascending
operator|=
operator|(
name|topLevelStructFieldID
operator|>=
name|sortOrder
operator|.
name|length
argument_list|()
operator|||
name|sortOrder
operator|.
name|charAt
argument_list|(
name|topLevelStructFieldID
argument_list|)
operator|!=
literal|'-'
operator|)
expr_stmt|;
block|}
else|else
block|{
name|writeRawBytes
argument_list|(
name|nonNullByte
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// If the struct is null and level> 1, DynamicSerDe will call
comment|// writeNull();
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeStructEnd
parameter_list|()
throws|throws
name|TException
block|{
name|stackLevel
operator|--
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeFieldBegin
parameter_list|(
name|TField
name|field
parameter_list|)
throws|throws
name|TException
block|{   }
annotation|@
name|Override
specifier|public
name|void
name|writeFieldEnd
parameter_list|()
throws|throws
name|TException
block|{
if|if
condition|(
name|stackLevel
operator|==
literal|1
condition|)
block|{
name|topLevelStructFieldID
operator|++
expr_stmt|;
name|ascending
operator|=
operator|(
name|topLevelStructFieldID
operator|>=
name|sortOrder
operator|.
name|length
argument_list|()
operator|||
name|sortOrder
operator|.
name|charAt
argument_list|(
name|topLevelStructFieldID
argument_list|)
operator|!=
literal|'-'
operator|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeFieldStop
parameter_list|()
block|{   }
annotation|@
name|Override
specifier|public
name|void
name|writeMapBegin
parameter_list|(
name|TMap
name|map
parameter_list|)
throws|throws
name|TException
block|{
name|stackLevel
operator|++
expr_stmt|;
if|if
condition|(
name|map
operator|==
literal|null
condition|)
block|{
name|writeRawBytes
argument_list|(
name|nonNullByte
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeI32
argument_list|(
name|map
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeMapEnd
parameter_list|()
throws|throws
name|TException
block|{
name|stackLevel
operator|--
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeListBegin
parameter_list|(
name|TList
name|list
parameter_list|)
throws|throws
name|TException
block|{
name|stackLevel
operator|++
expr_stmt|;
if|if
condition|(
name|list
operator|==
literal|null
condition|)
block|{
name|writeRawBytes
argument_list|(
name|nonNullByte
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeI32
argument_list|(
name|list
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeListEnd
parameter_list|()
throws|throws
name|TException
block|{
name|stackLevel
operator|--
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeSetBegin
parameter_list|(
name|TSet
name|set
parameter_list|)
throws|throws
name|TException
block|{
name|stackLevel
operator|++
expr_stmt|;
if|if
condition|(
name|set
operator|==
literal|null
condition|)
block|{
name|writeRawBytes
argument_list|(
name|nonNullByte
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeI32
argument_list|(
name|set
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeSetEnd
parameter_list|()
throws|throws
name|TException
block|{
name|stackLevel
operator|--
expr_stmt|;
block|}
name|byte
index|[]
name|rawBytesBuffer
decl_stmt|;
comment|// This method takes care of bit-flipping for descending order
comment|// Declare this method as final for performance reasons
specifier|final
specifier|private
name|void
name|writeRawBytes
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|begin
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|TException
block|{
if|if
condition|(
name|ascending
condition|)
block|{
name|trans_
operator|.
name|write
argument_list|(
name|bytes
argument_list|,
name|begin
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// For fields in descending order, do a bit flip first.
if|if
condition|(
name|rawBytesBuffer
operator|==
literal|null
operator|||
name|rawBytesBuffer
operator|.
name|length
operator|<
name|bytes
operator|.
name|length
condition|)
block|{
name|rawBytesBuffer
operator|=
operator|new
name|byte
index|[
name|bytes
operator|.
name|length
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|begin
init|;
name|i
operator|<
name|begin
operator|+
name|length
condition|;
name|i
operator|++
control|)
block|{
name|rawBytesBuffer
index|[
name|i
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|~
name|bytes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|trans_
operator|.
name|write
argument_list|(
name|rawBytesBuffer
argument_list|,
name|begin
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|final
name|byte
index|[]
name|bout
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|writeBool
parameter_list|(
name|boolean
name|b
parameter_list|)
throws|throws
name|TException
block|{
name|bout
index|[
literal|0
index|]
operator|=
operator|(
name|b
condition|?
operator|(
name|byte
operator|)
literal|2
else|:
operator|(
name|byte
operator|)
literal|1
operator|)
expr_stmt|;
name|writeRawBytes
argument_list|(
name|bout
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeByte
parameter_list|(
name|byte
name|b
parameter_list|)
throws|throws
name|TException
block|{
name|writeRawBytes
argument_list|(
name|nonNullByte
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// Make sure negative numbers comes before positive numbers
name|bout
index|[
literal|0
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|b
operator|^
literal|0x80
argument_list|)
expr_stmt|;
name|writeRawBytes
argument_list|(
name|bout
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|final
name|byte
index|[]
name|i16out
init|=
operator|new
name|byte
index|[
literal|2
index|]
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|writeI16
parameter_list|(
name|short
name|i16
parameter_list|)
throws|throws
name|TException
block|{
name|i16out
index|[
literal|0
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
operator|(
name|i16
operator|>>
literal|8
operator|)
operator|^
literal|0x80
operator|)
argument_list|)
expr_stmt|;
name|i16out
index|[
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|i16
operator|)
argument_list|)
expr_stmt|;
name|writeRawBytes
argument_list|(
name|nonNullByte
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|writeRawBytes
argument_list|(
name|i16out
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|final
name|byte
index|[]
name|i32out
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|writeI32
parameter_list|(
name|int
name|i32
parameter_list|)
throws|throws
name|TException
block|{
name|i32out
index|[
literal|0
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
operator|(
name|i32
operator|>>
literal|24
operator|)
operator|^
literal|0x80
operator|)
argument_list|)
expr_stmt|;
name|i32out
index|[
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|i32
operator|>>
literal|16
operator|)
argument_list|)
expr_stmt|;
name|i32out
index|[
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|i32
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
name|i32out
index|[
literal|3
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|i32
operator|)
argument_list|)
expr_stmt|;
name|writeRawBytes
argument_list|(
name|nonNullByte
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|writeRawBytes
argument_list|(
name|i32out
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|final
name|byte
index|[]
name|i64out
init|=
operator|new
name|byte
index|[
literal|8
index|]
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|writeI64
parameter_list|(
name|long
name|i64
parameter_list|)
throws|throws
name|TException
block|{
name|i64out
index|[
literal|0
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
operator|(
name|i64
operator|>>
literal|56
operator|)
operator|^
literal|0x80
operator|)
argument_list|)
expr_stmt|;
name|i64out
index|[
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|i64
operator|>>
literal|48
operator|)
argument_list|)
expr_stmt|;
name|i64out
index|[
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|i64
operator|>>
literal|40
operator|)
argument_list|)
expr_stmt|;
name|i64out
index|[
literal|3
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|i64
operator|>>
literal|32
operator|)
argument_list|)
expr_stmt|;
name|i64out
index|[
literal|4
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|i64
operator|>>
literal|24
operator|)
argument_list|)
expr_stmt|;
name|i64out
index|[
literal|5
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|i64
operator|>>
literal|16
operator|)
argument_list|)
expr_stmt|;
name|i64out
index|[
literal|6
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|i64
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
name|i64out
index|[
literal|7
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|i64
operator|)
argument_list|)
expr_stmt|;
name|writeRawBytes
argument_list|(
name|nonNullByte
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|writeRawBytes
argument_list|(
name|i64out
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeDouble
parameter_list|(
name|double
name|dub
parameter_list|)
throws|throws
name|TException
block|{
name|long
name|i64
init|=
name|Double
operator|.
name|doubleToLongBits
argument_list|(
name|dub
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|i64
operator|&
operator|(
literal|1L
operator|<<
literal|63
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// negative numbers, flip all bits
name|i64out
index|[
literal|0
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
operator|(
name|i64
operator|>>
literal|56
operator|)
operator|^
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|i64out
index|[
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
operator|(
name|i64
operator|>>
literal|48
operator|)
operator|^
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|i64out
index|[
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
operator|(
name|i64
operator|>>
literal|40
operator|)
operator|^
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|i64out
index|[
literal|3
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
operator|(
name|i64
operator|>>
literal|32
operator|)
operator|^
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|i64out
index|[
literal|4
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
operator|(
name|i64
operator|>>
literal|24
operator|)
operator|^
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|i64out
index|[
literal|5
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
operator|(
name|i64
operator|>>
literal|16
operator|)
operator|^
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|i64out
index|[
literal|6
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
operator|(
name|i64
operator|>>
literal|8
operator|)
operator|^
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|i64out
index|[
literal|7
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
operator|(
name|i64
operator|)
operator|^
literal|0xff
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// positive numbers, flip just the first bit
name|i64out
index|[
literal|0
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
operator|(
name|i64
operator|>>
literal|56
operator|)
operator|^
literal|0x80
operator|)
argument_list|)
expr_stmt|;
name|i64out
index|[
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|i64
operator|>>
literal|48
operator|)
argument_list|)
expr_stmt|;
name|i64out
index|[
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|i64
operator|>>
literal|40
operator|)
argument_list|)
expr_stmt|;
name|i64out
index|[
literal|3
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|i64
operator|>>
literal|32
operator|)
argument_list|)
expr_stmt|;
name|i64out
index|[
literal|4
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|i64
operator|>>
literal|24
operator|)
argument_list|)
expr_stmt|;
name|i64out
index|[
literal|5
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|i64
operator|>>
literal|16
operator|)
argument_list|)
expr_stmt|;
name|i64out
index|[
literal|6
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|i64
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
name|i64out
index|[
literal|7
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|i64
operator|)
argument_list|)
expr_stmt|;
block|}
name|writeRawBytes
argument_list|(
name|nonNullByte
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|writeRawBytes
argument_list|(
name|i64out
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
specifier|final
specifier|protected
name|byte
index|[]
name|nullByte
init|=
operator|new
name|byte
index|[]
block|{
literal|0
block|}
decl_stmt|;
specifier|final
specifier|protected
name|byte
index|[]
name|nonNullByte
init|=
operator|new
name|byte
index|[]
block|{
literal|1
block|}
decl_stmt|;
comment|/**    * The escaped byte sequence for the null byte. This cannot be changed alone    * without changing the readString() code.    */
specifier|final
specifier|protected
name|byte
index|[]
name|escapedNull
init|=
operator|new
name|byte
index|[]
block|{
literal|1
block|,
literal|1
block|}
decl_stmt|;
comment|/**    * The escaped byte sequence for the "\1" byte. This cannot be changed alone    * without changing the readString() code.    */
specifier|final
specifier|protected
name|byte
index|[]
name|escapedOne
init|=
operator|new
name|byte
index|[]
block|{
literal|1
block|,
literal|2
block|}
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|writeString
parameter_list|(
name|String
name|str
parameter_list|)
throws|throws
name|TException
block|{
name|byte
index|[]
name|dat
decl_stmt|;
try|try
block|{
name|dat
operator|=
name|str
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uex
parameter_list|)
block|{
throw|throw
operator|new
name|TException
argument_list|(
literal|"JVM DOES NOT SUPPORT UTF-8: "
operator|+
name|uex
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
name|writeTextBytes
argument_list|(
name|dat
argument_list|,
literal|0
argument_list|,
name|dat
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeBinary
parameter_list|(
name|byte
index|[]
name|bin
parameter_list|)
throws|throws
name|TException
block|{
if|if
condition|(
name|bin
operator|==
literal|null
condition|)
block|{
name|writeRawBytes
argument_list|(
name|nullByte
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeI32
argument_list|(
name|bin
operator|.
name|length
argument_list|)
expr_stmt|;
name|writeRawBytes
argument_list|(
name|bin
argument_list|,
literal|0
argument_list|,
name|bin
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|TMessage
name|readMessageBegin
parameter_list|()
throws|throws
name|TException
block|{
return|return
operator|new
name|TMessage
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readMessageEnd
parameter_list|()
throws|throws
name|TException
block|{   }
name|TStruct
name|tstruct
init|=
operator|new
name|TStruct
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|TStruct
name|readStructBegin
parameter_list|()
throws|throws
name|TException
block|{
name|stackLevel
operator|++
expr_stmt|;
if|if
condition|(
name|stackLevel
operator|==
literal|1
condition|)
block|{
name|topLevelStructFieldID
operator|=
literal|0
expr_stmt|;
name|ascending
operator|=
operator|(
name|topLevelStructFieldID
operator|>=
name|sortOrder
operator|.
name|length
argument_list|()
operator|||
name|sortOrder
operator|.
name|charAt
argument_list|(
name|topLevelStructFieldID
argument_list|)
operator|!=
literal|'-'
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// is this a null?
comment|// only read the is-null byte for level> 1 because the top-level struct
comment|// can never be null.
if|if
condition|(
name|readIsNull
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
return|return
name|tstruct
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readStructEnd
parameter_list|()
throws|throws
name|TException
block|{
name|stackLevel
operator|--
expr_stmt|;
block|}
name|TField
name|f
init|=
literal|null
decl_stmt|;
annotation|@
name|Override
specifier|public
name|TField
name|readFieldBegin
parameter_list|()
throws|throws
name|TException
block|{
comment|// slight hack to communicate to DynamicSerDe that the field ids are not
comment|// being set but things are ordered.
name|f
operator|=
operator|new
name|TField
argument_list|(
literal|""
argument_list|,
name|ORDERED_TYPE
argument_list|,
operator|(
name|short
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readFieldEnd
parameter_list|()
throws|throws
name|TException
block|{
if|if
condition|(
name|stackLevel
operator|==
literal|1
condition|)
block|{
name|topLevelStructFieldID
operator|++
expr_stmt|;
name|ascending
operator|=
operator|(
name|topLevelStructFieldID
operator|>=
name|sortOrder
operator|.
name|length
argument_list|()
operator|||
name|sortOrder
operator|.
name|charAt
argument_list|(
name|topLevelStructFieldID
argument_list|)
operator|!=
literal|'-'
operator|)
expr_stmt|;
block|}
block|}
specifier|private
name|TMap
name|tmap
init|=
literal|null
decl_stmt|;
comment|/**    * This method always return the same instance of TMap to avoid creating new    * instances. It is the responsibility of the caller to read the value before    * calling this method again.    */
annotation|@
name|Override
specifier|public
name|TMap
name|readMapBegin
parameter_list|()
throws|throws
name|TException
block|{
name|stackLevel
operator|++
expr_stmt|;
name|tmap
operator|=
operator|new
name|TMap
argument_list|(
name|ORDERED_TYPE
argument_list|,
name|ORDERED_TYPE
argument_list|,
name|readI32
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmap
operator|.
name|size
operator|==
literal|0
operator|&&
name|lastPrimitiveWasNull
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|tmap
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readMapEnd
parameter_list|()
throws|throws
name|TException
block|{
name|stackLevel
operator|--
expr_stmt|;
block|}
specifier|private
name|TList
name|tlist
init|=
literal|null
decl_stmt|;
comment|/**    * This method always return the same instance of TList to avoid creating new    * instances. It is the responsibility of the caller to read the value before    * calling this method again.    */
annotation|@
name|Override
specifier|public
name|TList
name|readListBegin
parameter_list|()
throws|throws
name|TException
block|{
name|stackLevel
operator|++
expr_stmt|;
name|tlist
operator|=
operator|new
name|TList
argument_list|(
name|ORDERED_TYPE
argument_list|,
name|readI32
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlist
operator|.
name|size
operator|==
literal|0
operator|&&
name|lastPrimitiveWasNull
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|tlist
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readListEnd
parameter_list|()
throws|throws
name|TException
block|{
name|stackLevel
operator|--
expr_stmt|;
block|}
specifier|private
name|TSet
name|set
init|=
literal|null
decl_stmt|;
comment|/**    * This method always return the same instance of TSet to avoid creating new    * instances. It is the responsibility of the caller to read the value before    * calling this method again.    */
annotation|@
name|Override
specifier|public
name|TSet
name|readSetBegin
parameter_list|()
throws|throws
name|TException
block|{
name|stackLevel
operator|++
expr_stmt|;
name|set
operator|=
operator|new
name|TSet
argument_list|(
name|ORDERED_TYPE
argument_list|,
name|readI32
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|.
name|size
operator|==
literal|0
operator|&&
name|lastPrimitiveWasNull
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|set
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readSetEnd
parameter_list|()
throws|throws
name|TException
block|{
name|stackLevel
operator|--
expr_stmt|;
block|}
comment|// This method takes care of bit-flipping for descending order
comment|// Make this method final to improve performance.
specifier|final
specifier|private
name|int
name|readRawAll
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|TException
block|{
name|int
name|bytes
init|=
name|trans_
operator|.
name|readAll
argument_list|(
name|buf
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ascending
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|off
init|;
name|i
operator|<
name|off
operator|+
name|bytes
condition|;
name|i
operator|++
control|)
block|{
name|buf
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
operator|~
name|buf
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
return|return
name|bytes
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|readBool
parameter_list|()
throws|throws
name|TException
block|{
name|readRawAll
argument_list|(
name|bin
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lastPrimitiveWasNull
operator|=
operator|(
name|bin
index|[
literal|0
index|]
operator|==
literal|0
operator|)
expr_stmt|;
return|return
name|lastPrimitiveWasNull
condition|?
literal|false
else|:
name|bin
index|[
literal|0
index|]
operator|==
literal|2
return|;
block|}
specifier|private
specifier|final
name|byte
index|[]
name|wasNull
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
specifier|final
specifier|public
name|boolean
name|readIsNull
parameter_list|()
throws|throws
name|TException
block|{
name|readRawAll
argument_list|(
name|wasNull
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lastPrimitiveWasNull
operator|=
operator|(
name|wasNull
index|[
literal|0
index|]
operator|==
literal|0
operator|)
expr_stmt|;
return|return
name|lastPrimitiveWasNull
return|;
block|}
specifier|private
specifier|final
name|byte
index|[]
name|bin
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
annotation|@
name|Override
specifier|public
name|byte
name|readByte
parameter_list|()
throws|throws
name|TException
block|{
if|if
condition|(
name|readIsNull
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
name|readRawAll
argument_list|(
name|bin
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
call|(
name|byte
call|)
argument_list|(
name|bin
index|[
literal|0
index|]
operator|^
literal|0x80
argument_list|)
return|;
block|}
specifier|private
specifier|final
name|byte
index|[]
name|i16rd
init|=
operator|new
name|byte
index|[
literal|2
index|]
decl_stmt|;
annotation|@
name|Override
specifier|public
name|short
name|readI16
parameter_list|()
throws|throws
name|TException
block|{
if|if
condition|(
name|readIsNull
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
name|readRawAll
argument_list|(
name|i16rd
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
call|(
name|short
call|)
argument_list|(
operator|(
operator|(
operator|(
name|i16rd
index|[
literal|0
index|]
operator|^
literal|0x80
operator|)
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|i16rd
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|)
argument_list|)
return|;
block|}
specifier|private
specifier|final
name|byte
index|[]
name|i32rd
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
annotation|@
name|Override
specifier|public
name|int
name|readI32
parameter_list|()
throws|throws
name|TException
block|{
if|if
condition|(
name|readIsNull
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
name|readRawAll
argument_list|(
name|i32rd
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|i32rd
index|[
literal|0
index|]
operator|^
literal|0x80
operator|)
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|i32rd
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|i32rd
index|[
literal|2
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|i32rd
index|[
literal|3
index|]
operator|&
literal|0xff
operator|)
operator|)
return|;
block|}
specifier|private
specifier|final
name|byte
index|[]
name|i64rd
init|=
operator|new
name|byte
index|[
literal|8
index|]
decl_stmt|;
annotation|@
name|Override
specifier|public
name|long
name|readI64
parameter_list|()
throws|throws
name|TException
block|{
if|if
condition|(
name|readIsNull
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
name|readRawAll
argument_list|(
name|i64rd
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|long
call|)
argument_list|(
operator|(
name|i64rd
index|[
literal|0
index|]
operator|^
literal|0x80
operator|)
operator|&
literal|0xff
argument_list|)
operator|<<
literal|56
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
name|i64rd
index|[
literal|1
index|]
operator|&
literal|0xff
argument_list|)
operator|<<
literal|48
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
name|i64rd
index|[
literal|2
index|]
operator|&
literal|0xff
argument_list|)
operator|<<
literal|40
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
name|i64rd
index|[
literal|3
index|]
operator|&
literal|0xff
argument_list|)
operator|<<
literal|32
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
name|i64rd
index|[
literal|4
index|]
operator|&
literal|0xff
argument_list|)
operator|<<
literal|24
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
name|i64rd
index|[
literal|5
index|]
operator|&
literal|0xff
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
name|i64rd
index|[
literal|6
index|]
operator|&
literal|0xff
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|i64rd
index|[
literal|7
index|]
operator|&
literal|0xff
operator|)
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|double
name|readDouble
parameter_list|()
throws|throws
name|TException
block|{
if|if
condition|(
name|readIsNull
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
name|readRawAll
argument_list|(
name|i64rd
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|long
name|v
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|i64rd
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// Positive number
name|v
operator|=
operator|(
call|(
name|long
call|)
argument_list|(
operator|(
name|i64rd
index|[
literal|0
index|]
operator|^
literal|0x80
operator|)
operator|&
literal|0xff
argument_list|)
operator|<<
literal|56
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
name|i64rd
index|[
literal|1
index|]
operator|&
literal|0xff
argument_list|)
operator|<<
literal|48
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
name|i64rd
index|[
literal|2
index|]
operator|&
literal|0xff
argument_list|)
operator|<<
literal|40
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
name|i64rd
index|[
literal|3
index|]
operator|&
literal|0xff
argument_list|)
operator|<<
literal|32
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
name|i64rd
index|[
literal|4
index|]
operator|&
literal|0xff
argument_list|)
operator|<<
literal|24
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
name|i64rd
index|[
literal|5
index|]
operator|&
literal|0xff
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
name|i64rd
index|[
literal|6
index|]
operator|&
literal|0xff
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|i64rd
index|[
literal|7
index|]
operator|&
literal|0xff
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// Negative number
name|v
operator|=
operator|(
call|(
name|long
call|)
argument_list|(
operator|(
name|i64rd
index|[
literal|0
index|]
operator|^
literal|0xff
operator|)
operator|&
literal|0xff
argument_list|)
operator|<<
literal|56
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
operator|(
name|i64rd
index|[
literal|1
index|]
operator|^
literal|0xff
operator|)
operator|&
literal|0xff
argument_list|)
operator|<<
literal|48
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
operator|(
name|i64rd
index|[
literal|2
index|]
operator|^
literal|0xff
operator|)
operator|&
literal|0xff
argument_list|)
operator|<<
literal|40
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
operator|(
name|i64rd
index|[
literal|3
index|]
operator|^
literal|0xff
operator|)
operator|&
literal|0xff
argument_list|)
operator|<<
literal|32
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
operator|(
name|i64rd
index|[
literal|4
index|]
operator|^
literal|0xff
operator|)
operator|&
literal|0xff
argument_list|)
operator|<<
literal|24
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
operator|(
name|i64rd
index|[
literal|5
index|]
operator|^
literal|0xff
operator|)
operator|&
literal|0xff
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
operator|(
name|i64rd
index|[
literal|6
index|]
operator|^
literal|0xff
operator|)
operator|&
literal|0xff
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|i64rd
index|[
literal|7
index|]
operator|^
literal|0xff
operator|)
operator|&
literal|0xff
operator|)
operator|)
expr_stmt|;
block|}
return|return
name|Double
operator|.
name|longBitsToDouble
argument_list|(
name|v
argument_list|)
return|;
block|}
specifier|private
name|byte
index|[]
name|stringBytes
init|=
operator|new
name|byte
index|[
literal|1000
index|]
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|readString
parameter_list|()
throws|throws
name|TException
block|{
if|if
condition|(
name|readIsNull
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|readRawAll
argument_list|(
name|bin
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bin
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
comment|// End of string.
break|break;
block|}
if|if
condition|(
name|bin
index|[
literal|0
index|]
operator|==
literal|1
condition|)
block|{
comment|// Escaped byte, unescape it.
name|readRawAll
argument_list|(
name|bin
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|bin
index|[
literal|0
index|]
operator|==
literal|1
operator|||
name|bin
index|[
literal|0
index|]
operator|==
literal|2
operator|)
assert|;
name|bin
index|[
literal|0
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|bin
index|[
literal|0
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|stringBytes
operator|.
name|length
condition|)
block|{
name|stringBytes
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|stringBytes
argument_list|,
name|stringBytes
operator|.
name|length
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
name|stringBytes
index|[
name|i
index|]
operator|=
name|bin
index|[
literal|0
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
try|try
block|{
name|String
name|r
init|=
operator|new
name|String
argument_list|(
name|stringBytes
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
literal|"UTF-8"
argument_list|)
decl_stmt|;
return|return
name|r
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uex
parameter_list|)
block|{
throw|throw
operator|new
name|TException
argument_list|(
literal|"JVM DOES NOT SUPPORT UTF-8: "
operator|+
name|uex
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|readBinary
parameter_list|()
throws|throws
name|TException
block|{
name|int
name|size
init|=
name|readI32
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastPrimitiveWasNull
condition|)
block|{
return|return
literal|null
return|;
block|}
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|size
index|]
decl_stmt|;
name|readRawAll
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|boolean
name|lastPrimitiveWasNull
decl_stmt|;
specifier|public
name|boolean
name|lastPrimitiveWasNull
parameter_list|()
throws|throws
name|TException
block|{
return|return
name|lastPrimitiveWasNull
return|;
block|}
specifier|public
name|void
name|writeNull
parameter_list|()
throws|throws
name|TException
block|{
name|writeRawBytes
argument_list|(
name|nullByte
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|void
name|writeTextBytes
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|TException
block|{
name|writeRawBytes
argument_list|(
name|nonNullByte
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|int
name|begin
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
name|start
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bytes
index|[
name|i
index|]
operator|==
literal|0
operator|||
name|bytes
index|[
name|i
index|]
operator|==
literal|1
condition|)
block|{
comment|// Write the first part of the array
if|if
condition|(
name|i
operator|>
name|begin
condition|)
block|{
name|writeRawBytes
argument_list|(
name|bytes
argument_list|,
name|begin
argument_list|,
name|i
operator|-
name|begin
argument_list|)
expr_stmt|;
block|}
comment|// Write the escaped byte.
if|if
condition|(
name|bytes
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|writeRawBytes
argument_list|(
name|escapedNull
argument_list|,
literal|0
argument_list|,
name|escapedNull
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeRawBytes
argument_list|(
name|escapedOne
argument_list|,
literal|0
argument_list|,
name|escapedOne
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|// Move the pointer to the next byte, since we have written
comment|// out the escaped byte in the block above already.
name|begin
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|// Write the remaining part of the array
if|if
condition|(
name|i
operator|>
name|begin
condition|)
block|{
name|writeRawBytes
argument_list|(
name|bytes
argument_list|,
name|begin
argument_list|,
name|i
operator|-
name|begin
argument_list|)
expr_stmt|;
block|}
comment|// Write the terminating NULL byte
name|writeRawBytes
argument_list|(
name|nullByte
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|writeText
parameter_list|(
name|Text
name|text
parameter_list|)
throws|throws
name|TException
block|{
name|writeTextBytes
argument_list|(
name|text
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|text
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

