begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|teradata
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|input
operator|.
name|SwappedDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|ArrayUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|HiveDecimal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|Timestamp
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|String
operator|.
name|format
import|;
end_import

begin_comment
comment|/**  * The TeradataBinaryDataInputStream is used to handle the Teradata binary format input for record.  * Since the TD binary format uses little-endian to handle the SHORT, INT, LONG, DOUBLE and etc.  * while the Hadoop uses big-endian,  * We extend SwappedDataInputStream to handle these types and extend to handle the Teradata  * specific types like VARCHAR, CHAR, TIMESTAMP, DATE...  */
end_comment

begin_class
specifier|public
class|class
name|TeradataBinaryDataInputStream
extends|extends
name|SwappedDataInputStream
block|{
specifier|private
specifier|static
specifier|final
name|int
name|DATE_STRING_LENGTH
init|=
literal|8
decl_stmt|;
comment|/**    * Instantiates a new Teradata binary data input stream.    *    * @param input the input    */
specifier|public
name|TeradataBinaryDataInputStream
parameter_list|(
name|InputStream
name|input
parameter_list|)
block|{
name|super
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
comment|/**    * Read VARCHAR(N).    * The representation of Varchar in Teradata binary format is:    * the first two bytes represent the length N of this varchar field,    * the next N bytes represent the content of this varchar field.    * To pad the null varchar, the length will be 0 and the content will be none.    *    * @return the string    * @throws IOException the io exception    */
specifier|public
name|String
name|readVarchar
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|varcharLength
init|=
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|byte
index|[]
name|varcharContent
init|=
operator|new
name|byte
index|[
name|varcharLength
index|]
decl_stmt|;
name|int
name|numOfBytesRead
init|=
name|in
operator|.
name|read
argument_list|(
name|varcharContent
argument_list|)
decl_stmt|;
if|if
condition|(
name|varcharContent
operator|.
name|length
operator|!=
literal|0
operator|&&
name|numOfBytesRead
operator|!=
name|varcharLength
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
name|format
argument_list|(
literal|"Fail to read the varchar. Expect %d bytes, get %d bytes"
argument_list|,
name|varcharLength
argument_list|,
name|numOfBytesRead
argument_list|)
argument_list|)
throw|;
block|}
comment|//force it to be UTF8 string
return|return
operator|new
name|String
argument_list|(
name|varcharContent
argument_list|,
literal|"UTF8"
argument_list|)
return|;
block|}
comment|/**    * Read TIMESTAMP(P).    * The representation of timestamp in Teradata binary format is:    * the byte number to read is based on the precision of timestamp,    * each byte represents one char and the timestamp is using string representation,    * eg: for TIMESTAMP(6), we need to read 26 bytes    * 31 39  31 31 2d 31 31 2d 31 31 20 31 39 3a 32 30 3a 32 31 2e 34 33 33 32 30 30    * will represent 1911-11-11 19:20:21.433200.    * the null timestamp will use space to pad.    *    * @param byteNum the byte number that will be read from inputstream    * @return the timestamp    * @throws IOException the io exception    */
specifier|public
name|Timestamp
name|readTimestamp
parameter_list|(
name|Integer
name|byteNum
parameter_list|)
throws|throws
name|IOException
block|{
comment|// yyyy-mm-dd hh:mm:ss
name|byte
index|[]
name|timestampContent
init|=
operator|new
name|byte
index|[
name|byteNum
index|]
decl_stmt|;
name|int
name|numOfBytesRead
init|=
name|in
operator|.
name|read
argument_list|(
name|timestampContent
argument_list|)
decl_stmt|;
if|if
condition|(
name|timestampContent
operator|.
name|length
operator|!=
literal|0
operator|&&
name|numOfBytesRead
operator|!=
name|byteNum
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
name|format
argument_list|(
literal|"Fail to read the timestamp. Expect %d bytes, get %d bytes"
argument_list|,
name|byteNum
argument_list|,
name|numOfBytesRead
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|timestampStr
init|=
operator|new
name|String
argument_list|(
name|timestampContent
argument_list|,
literal|"UTF8"
argument_list|)
decl_stmt|;
if|if
condition|(
name|timestampStr
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|Timestamp
operator|.
name|valueOf
argument_list|(
name|timestampStr
argument_list|)
return|;
block|}
comment|/**    * Read DATE.    * The representation of date in Teradata binary format is:    * The Date D is a int with 4 bytes using little endian,    * The representation is (D+19000000).ToString -&gt; YYYYMMDD,    * eg: Date 07 b2 01 00 -&gt; 111111 in little endian -&gt; 19111111 -&gt; 1911.11.11.    * the null date will use 0 to pad.    *    * @return the date    * @throws IOException the io exception    * @throws ParseException the parse exception    */
specifier|public
name|Date
name|readDate
parameter_list|()
throws|throws
name|IOException
throws|,
name|ParseException
block|{
name|int
name|di
init|=
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|di
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|dateString
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|di
operator|+
literal|19000000
argument_list|)
decl_stmt|;
if|if
condition|(
name|dateString
operator|.
name|length
argument_list|()
operator|<
name|DATE_STRING_LENGTH
condition|)
block|{
name|dateString
operator|=
name|StringUtils
operator|.
name|leftPad
argument_list|(
name|dateString
argument_list|,
name|DATE_STRING_LENGTH
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
block|}
name|Date
name|date
init|=
operator|new
name|Date
argument_list|()
decl_stmt|;
name|date
operator|.
name|setYear
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|dateString
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|date
operator|.
name|setMonth
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|dateString
operator|.
name|substring
argument_list|(
literal|4
argument_list|,
literal|6
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|date
operator|.
name|setDayOfMonth
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|dateString
operator|.
name|substring
argument_list|(
literal|6
argument_list|,
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|date
return|;
block|}
comment|/**    * Read CHAR(N).    * The representation of char in Teradata binary format is    * the byte number to read is based on the [charLength] * [bytePerChar]&lt;- totalLength,    * bytePerChar is decided by the charset: LATAIN charset is 2 bytes per char and UNICODE charset is 3 bytes per char.    * the null char will use space to pad.    *    * @param totalLength the total length    * @return the string    * @throws IOException the io exception    */
specifier|public
name|String
name|readChar
parameter_list|(
name|int
name|totalLength
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|charContent
init|=
operator|new
name|byte
index|[
name|totalLength
index|]
decl_stmt|;
name|int
name|numOfBytesRead
init|=
name|in
operator|.
name|read
argument_list|(
name|charContent
argument_list|)
decl_stmt|;
if|if
condition|(
name|charContent
operator|.
name|length
operator|!=
literal|0
operator|&&
name|numOfBytesRead
operator|!=
name|totalLength
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
name|format
argument_list|(
literal|"Fail to read the varchar. Expect %d bytes, get %d bytes"
argument_list|,
name|totalLength
argument_list|,
name|numOfBytesRead
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|new
name|String
argument_list|(
name|charContent
argument_list|,
literal|"UTF8"
argument_list|)
return|;
block|}
comment|/**    * Read DECIMAL(P, S).    * The representation of decimal in Teradata binary format is    * the byte number to read is decided solely by the precision(P),    * HiveDecimal is constructed through the byte array and scale.    * the null DECIMAL will use 0x00 to pad.    *    * @param scale the scale    * @param byteNum the byte num    * @return the hive decimal    * @throws IOException the io exception    */
specifier|public
name|HiveDecimal
name|readDecimal
parameter_list|(
name|int
name|scale
parameter_list|,
name|int
name|byteNum
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|decimalContent
init|=
operator|new
name|byte
index|[
name|byteNum
index|]
decl_stmt|;
name|int
name|numOfBytesRead
init|=
name|in
operator|.
name|read
argument_list|(
name|decimalContent
argument_list|)
decl_stmt|;
if|if
condition|(
name|decimalContent
operator|.
name|length
operator|!=
literal|0
operator|&&
name|numOfBytesRead
operator|!=
name|byteNum
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
name|format
argument_list|(
literal|"Fail to read the decimal. Expect %d bytes, get %d bytes"
argument_list|,
name|byteNum
argument_list|,
name|numOfBytesRead
argument_list|)
argument_list|)
throw|;
block|}
name|ArrayUtils
operator|.
name|reverse
argument_list|(
name|decimalContent
argument_list|)
expr_stmt|;
return|return
name|HiveDecimal
operator|.
name|create
argument_list|(
operator|new
name|BigInteger
argument_list|(
name|decimalContent
argument_list|)
argument_list|,
name|scale
argument_list|)
return|;
block|}
comment|/**    * Read VARBYTE(N).    * The representation of VARBYTE in Teradata binary format is:    * the first two bytes represent the length N of this varchar field    * the next N bytes represent the content of this varchar field.    * To pad the null varbyte, the length will be 0 and the content will be none.    *    * @return the byte [ ]    * @throws IOException the io exception    */
specifier|public
name|byte
index|[]
name|readVarbyte
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|varbyteLength
init|=
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|byte
index|[]
name|varbyteContent
init|=
operator|new
name|byte
index|[
name|varbyteLength
index|]
decl_stmt|;
name|int
name|numOfBytesRead
init|=
name|in
operator|.
name|read
argument_list|(
name|varbyteContent
argument_list|)
decl_stmt|;
if|if
condition|(
name|varbyteContent
operator|.
name|length
operator|!=
literal|0
operator|&&
name|numOfBytesRead
operator|!=
name|varbyteLength
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
name|format
argument_list|(
literal|"Fail to read the varbyte. Expect %d bytes, get %d bytes"
argument_list|,
name|varbyteLength
argument_list|,
name|numOfBytesRead
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|varbyteContent
return|;
block|}
block|}
end_class

end_unit

