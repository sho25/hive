begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|avro
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|avro
operator|.
name|Schema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|avro
operator|.
name|file
operator|.
name|DataFileStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|avro
operator|.
name|generic
operator|.
name|GenericDatumReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|avro
operator|.
name|generic
operator|.
name|GenericRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|avro
operator|.
name|io
operator|.
name|DatumReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|ClassUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|ByteArrayRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|LazyArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|LazyFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|LazyMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|LazyObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|LazyStruct
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|LazyUnion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|objectinspector
operator|.
name|LazyListObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|objectinspector
operator|.
name|LazyMapObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|objectinspector
operator|.
name|LazySimpleStructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|objectinspector
operator|.
name|LazyUnionObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|LazyObjectInspectorParameters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ListObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|MapObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StandardUnionObjectInspector
operator|.
name|StandardUnion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_comment
comment|/**  * Lazy objectinspector for avro serialization  * */
end_comment

begin_class
specifier|public
class|class
name|AvroLazyObjectInspector
extends|extends
name|LazySimpleStructObjectInspector
block|{
comment|/**    * Reader {@link Schema} for the avro data    * */
specifier|private
name|Schema
name|readerSchema
decl_stmt|;
comment|/**    * {@link AvroSchemaRetriever} to retrieve avro schema    * */
specifier|private
name|AvroSchemaRetriever
name|schemaRetriever
decl_stmt|;
comment|/**    * LOGGER    * */
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|AvroLazyObjectInspector
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Constructor    *    * @param structFieldNames fields within the given protobuf object    * @param structFieldObjectInspectors object inspectors for the fields    * @param structFieldComments comments for the given fields    * @param separator separator between different fields    * @param nullSequence sequence to represent null value    * @param lastColumnTakesRest whether the last column of the struct should take the rest of the    *          row if there are extra fields.    * @param escaped whether the data is escaped or not    * @param escapeChar if escaped is true, the escape character    * */
annotation|@
name|Deprecated
specifier|public
name|AvroLazyObjectInspector
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|structFieldNames
parameter_list|,
name|List
argument_list|<
name|ObjectInspector
argument_list|>
name|structFieldObjectInspectors
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|structFieldComments
parameter_list|,
name|byte
name|separator
parameter_list|,
name|Text
name|nullSequence
parameter_list|,
name|boolean
name|lastColumnTakesRest
parameter_list|,
name|boolean
name|escaped
parameter_list|,
name|byte
name|escapeChar
parameter_list|)
block|{
name|super
argument_list|(
name|structFieldNames
argument_list|,
name|structFieldObjectInspectors
argument_list|,
name|structFieldComments
argument_list|,
name|separator
argument_list|,
name|nullSequence
argument_list|,
name|lastColumnTakesRest
argument_list|,
name|escaped
argument_list|,
name|escapeChar
argument_list|)
expr_stmt|;
block|}
specifier|public
name|AvroLazyObjectInspector
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|structFieldNames
parameter_list|,
name|List
argument_list|<
name|ObjectInspector
argument_list|>
name|structFieldObjectInspectors
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|structFieldComments
parameter_list|,
name|byte
name|separator
parameter_list|,
name|LazyObjectInspectorParameters
name|lazyParams
parameter_list|)
block|{
name|super
argument_list|(
name|structFieldNames
argument_list|,
name|structFieldObjectInspectors
argument_list|,
name|structFieldComments
argument_list|,
name|separator
argument_list|,
name|lazyParams
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the reader schema for the {@link AvroLazyObjectInspector} to the given schema    * */
specifier|public
name|void
name|setReaderSchema
parameter_list|(
name|Schema
name|readerSchema
parameter_list|)
block|{
name|this
operator|.
name|readerSchema
operator|=
name|readerSchema
expr_stmt|;
block|}
comment|/**    * Set the {@link AvroSchemaRetriever} for the {@link AvroLazyObjectInspector} to the given class    *    * @param scheamRetrieverClass the schema retriever class to be set    * */
specifier|public
name|void
name|setSchemaRetriever
parameter_list|(
name|AvroSchemaRetriever
name|schemaRetriever
parameter_list|)
block|{
name|this
operator|.
name|schemaRetriever
operator|=
name|schemaRetriever
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
specifier|public
name|Object
name|getStructFieldData
parameter_list|(
name|Object
name|data
parameter_list|,
name|StructField
name|f
parameter_list|)
block|{
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|fieldID
init|=
name|f
operator|.
name|getFieldID
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Getting struct field data for field: ["
operator|+
name|f
operator|.
name|getFieldName
argument_list|()
operator|+
literal|"] on data ["
operator|+
name|data
operator|.
name|getClass
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|instanceof
name|LazyStruct
condition|)
block|{
name|LazyStruct
name|row
init|=
operator|(
name|LazyStruct
operator|)
name|data
decl_stmt|;
comment|// get the field out of struct
name|Object
name|rowField
init|=
name|row
operator|.
name|getField
argument_list|(
name|fieldID
argument_list|)
decl_stmt|;
if|if
condition|(
name|rowField
operator|instanceof
name|LazyStruct
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Deserializing struct ["
operator|+
name|rowField
operator|.
name|getClass
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
return|return
name|deserializeStruct
argument_list|(
name|rowField
argument_list|,
name|f
operator|.
name|getFieldName
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|rowField
operator|instanceof
name|LazyMap
condition|)
block|{
comment|// We have found a map. Systematically deserialize the values of the map and return back the
comment|// map
name|LazyMap
name|lazyMap
init|=
operator|(
name|LazyMap
operator|)
name|rowField
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|lazyMap
operator|.
name|getMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Object
name|_key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Object
name|_value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|_value
operator|instanceof
name|LazyStruct
condition|)
block|{
name|lazyMap
operator|.
name|getMap
argument_list|()
operator|.
name|put
argument_list|(
name|_key
argument_list|,
name|deserializeStruct
argument_list|(
name|_value
argument_list|,
name|f
operator|.
name|getFieldName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Returning a lazy map for field ["
operator|+
name|f
operator|.
name|getFieldName
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
return|return
name|lazyMap
return|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Returning ["
operator|+
name|rowField
operator|.
name|toString
argument_list|()
operator|+
literal|"] for field ["
operator|+
name|f
operator|.
name|getFieldName
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
comment|// Just return the object. We need no further operation on it
return|return
name|rowField
return|;
block|}
block|}
else|else
block|{
comment|// The Avro deserializer would deserialize our object and return back a list of object that
comment|// hive can operate on. Here we should be getting the same object back.
if|if
condition|(
operator|!
operator|(
name|data
operator|instanceof
name|List
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"data should be an instance of list"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
operator|(
name|fieldID
operator|<
operator|(
operator|(
name|List
argument_list|<
name|Object
argument_list|>
operator|)
name|data
operator|)
operator|.
name|size
argument_list|()
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// lookup the field corresponding to the given field ID and return
name|Object
name|field
init|=
operator|(
operator|(
name|List
argument_list|<
name|Object
argument_list|>
operator|)
name|data
operator|)
operator|.
name|get
argument_list|(
name|fieldID
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// convert to a lazy object and return
return|return
name|toLazyObject
argument_list|(
name|field
argument_list|,
name|f
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Object
argument_list|>
name|getStructFieldsDataAsList
parameter_list|(
name|Object
name|data
parameter_list|)
block|{
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|Object
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|(
name|fields
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|getStructFieldData
argument_list|(
name|data
argument_list|,
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Deserialize the given struct object    *    * @param struct the object to deserialize    * @param fieldName name of the field on which we are currently operating on    * @return a deserialized object can hive can further operate on    * @throws AvroObjectInspectorException if something goes wrong during deserialization    * */
specifier|private
name|Object
name|deserializeStruct
parameter_list|(
name|Object
name|struct
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
name|byte
index|[]
name|data
init|=
operator|(
operator|(
name|LazyStruct
operator|)
name|struct
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|AvroDeserializer
name|deserializer
init|=
operator|new
name|AvroDeserializer
argument_list|()
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|readerSchema
operator|==
literal|null
operator|&&
name|schemaRetriever
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"reader schema or schemaRetriever must be set for field ["
operator|+
name|fieldName
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|Schema
name|ws
init|=
literal|null
decl_stmt|;
name|Schema
name|rs
init|=
literal|null
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|AvroGenericRecordWritable
name|avroWritable
init|=
operator|new
name|AvroGenericRecordWritable
argument_list|()
decl_stmt|;
if|if
condition|(
name|readerSchema
operator|==
literal|null
condition|)
block|{
name|rs
operator|=
name|schemaRetriever
operator|.
name|retrieveReaderSchema
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|==
literal|null
condition|)
block|{
comment|// still nothing, Raise exception
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"A valid reader schema could not be retrieved either directly or from the schema retriever for field ["
operator|+
name|fieldName
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|ws
operator|=
name|schemaRetriever
operator|.
name|retrieveWriterSchema
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ws
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Null writer schema retrieved from schemaRetriever for field ["
operator|+
name|fieldName
operator|+
literal|"]"
argument_list|)
throw|;
block|}
comment|// adjust the data bytes according to any possible offset that was provided
name|offset
operator|=
name|schemaRetriever
operator|.
name|getOffset
argument_list|()
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|length
operator|<
name|offset
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Data size cannot be less than ["
operator|+
name|offset
operator|+
literal|"]. Found ["
operator|+
name|data
operator|.
name|length
operator|+
literal|"]"
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Retrieved writer Schema: "
operator|+
name|ws
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Retrieved reader Schema: "
operator|+
name|rs
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|avroWritable
operator|.
name|readFields
argument_list|(
name|data
argument_list|,
name|offset
argument_list|,
name|data
operator|.
name|length
argument_list|,
name|ws
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|AvroObjectInspectorException
argument_list|(
literal|"Error deserializing avro payload"
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// a reader schema was provided
if|if
condition|(
name|schemaRetriever
operator|!=
literal|null
condition|)
block|{
comment|// a schema retriever has been provided as well. Attempt to read the write schema from the
comment|// retriever
name|ws
operator|=
name|schemaRetriever
operator|.
name|retrieveWriterSchema
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ws
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Null writer schema retrieved from schemaRetriever for field ["
operator|+
name|fieldName
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// attempt retrieving the schema from the data
name|ws
operator|=
name|retrieveSchemaFromBytes
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
name|rs
operator|=
name|readerSchema
expr_stmt|;
try|try
block|{
name|avroWritable
operator|.
name|readFields
argument_list|(
name|data
argument_list|,
name|ws
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|AvroObjectInspectorException
argument_list|(
literal|"Error deserializing avro payload"
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
block|}
name|AvroObjectInspectorGenerator
name|oiGenerator
init|=
literal|null
decl_stmt|;
name|Object
name|deserializedObject
init|=
literal|null
decl_stmt|;
try|try
block|{
name|oiGenerator
operator|=
operator|new
name|AvroObjectInspectorGenerator
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|deserializedObject
operator|=
name|deserializer
operator|.
name|deserialize
argument_list|(
name|oiGenerator
operator|.
name|getColumnNames
argument_list|()
argument_list|,
name|oiGenerator
operator|.
name|getColumnTypes
argument_list|()
argument_list|,
name|avroWritable
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SerDeException
name|se
parameter_list|)
block|{
throw|throw
operator|new
name|AvroObjectInspectorException
argument_list|(
literal|"Error deserializing avro payload"
argument_list|,
name|se
argument_list|)
throw|;
block|}
return|return
name|deserializedObject
return|;
block|}
comment|/**    * Retrieve schema from the given bytes    *    * @return the retrieved {@link Schema schema}    * */
specifier|private
name|Schema
name|retrieveSchemaFromBytes
parameter_list|(
name|byte
index|[]
name|data
parameter_list|)
block|{
name|ByteArrayInputStream
name|bais
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|DatumReader
argument_list|<
name|GenericRecord
argument_list|>
name|reader
init|=
operator|new
name|GenericDatumReader
argument_list|<
name|GenericRecord
argument_list|>
argument_list|()
decl_stmt|;
name|Schema
name|schema
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// dfs is AutoCloseable
annotation|@
name|SuppressWarnings
argument_list|(
literal|"resource"
argument_list|)
name|DataFileStream
argument_list|<
name|GenericRecord
argument_list|>
name|dfs
init|=
operator|new
name|DataFileStream
argument_list|<
name|GenericRecord
argument_list|>
argument_list|(
name|bais
argument_list|,
name|reader
argument_list|)
decl_stmt|;
name|schema
operator|=
name|dfs
operator|.
name|getSchema
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|AvroObjectInspectorException
argument_list|(
literal|"An error occurred retrieving schema from bytes"
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
return|return
name|schema
return|;
block|}
comment|/**    * Converts the given field to a lazy object    *    * @param field to be converted to a lazy object    * @param fieldOI {@link ObjectInspector} for the given field    * @return returns the converted lazy object    * */
specifier|private
name|Object
name|toLazyObject
parameter_list|(
name|Object
name|field
parameter_list|,
name|ObjectInspector
name|fieldOI
parameter_list|)
block|{
if|if
condition|(
name|isPrimitive
argument_list|(
name|field
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|toLazyPrimitiveObject
argument_list|(
name|field
argument_list|,
name|fieldOI
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|fieldOI
operator|instanceof
name|LazyListObjectInspector
condition|)
block|{
return|return
name|toLazyListObject
argument_list|(
name|field
argument_list|,
name|fieldOI
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|field
operator|instanceof
name|StandardUnion
condition|)
block|{
return|return
name|toLazyUnionObject
argument_list|(
name|field
argument_list|,
name|fieldOI
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|fieldOI
operator|instanceof
name|LazyMapObjectInspector
condition|)
block|{
return|return
name|toLazyMapObject
argument_list|(
name|field
argument_list|,
name|fieldOI
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|field
return|;
block|}
block|}
comment|/**    * Convert the given object to a lazy object using the given {@link ObjectInspector}    *    * @param obj Object to be converted to a {@link LazyObject}    * @param oi ObjectInspector used for the conversion    * @return the created {@link LazyObject lazy object}    * */
specifier|private
name|LazyObject
argument_list|<
name|?
extends|extends
name|ObjectInspector
argument_list|>
name|toLazyPrimitiveObject
parameter_list|(
name|Object
name|obj
parameter_list|,
name|ObjectInspector
name|oi
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|LazyObject
argument_list|<
name|?
extends|extends
name|ObjectInspector
argument_list|>
name|lazyObject
init|=
name|LazyFactory
operator|.
name|createLazyObject
argument_list|(
name|oi
argument_list|)
decl_stmt|;
name|ByteArrayRef
name|ref
init|=
operator|new
name|ByteArrayRef
argument_list|()
decl_stmt|;
name|String
name|objAsString
init|=
name|obj
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
name|ref
operator|.
name|setData
argument_list|(
name|objAsString
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
comment|// initialize the lazy object
name|lazyObject
operator|.
name|init
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|,
name|ref
operator|.
name|getData
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|lazyObject
return|;
block|}
comment|/**    * Convert the given object to a lazy object using the given {@link ObjectInspector}    *    * @param obj Object to be converted to a {@link LazyObject}    * @param oi ObjectInspector used for the conversion    * @return the created {@link LazyObject lazy object}    * */
specifier|private
name|Object
name|toLazyListObject
parameter_list|(
name|Object
name|obj
parameter_list|,
name|ObjectInspector
name|objectInspector
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|?
argument_list|>
name|listObj
init|=
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|obj
decl_stmt|;
name|LazyArray
name|retList
init|=
operator|(
name|LazyArray
operator|)
name|LazyFactory
operator|.
name|createLazyObject
argument_list|(
name|objectInspector
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|lazyList
init|=
name|retList
operator|.
name|getList
argument_list|()
decl_stmt|;
name|ObjectInspector
name|listElementOI
init|=
operator|(
operator|(
name|ListObjectInspector
operator|)
name|objectInspector
operator|)
operator|.
name|getListElementObjectInspector
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|listObj
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|lazyList
operator|.
name|add
argument_list|(
name|toLazyObject
argument_list|(
name|listObj
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|listElementOI
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|retList
return|;
block|}
comment|/**    * Convert the given object to a lazy object using the given {@link ObjectInspector}    *    * @param obj Object to be converted to a {@link LazyObject}    * @param oi ObjectInspector used for the conversion    * @return the created {@link LazyObject lazy object}    * */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|private
name|Object
name|toLazyMapObject
parameter_list|(
name|Object
name|obj
parameter_list|,
name|ObjectInspector
name|objectInspector
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// avro guarantees that the key will be of type string. So we just need to worry about
comment|// deserializing the value here
name|LazyMap
name|lazyMap
init|=
operator|(
name|LazyMap
operator|)
name|LazyFactory
operator|.
name|createLazyObject
argument_list|(
name|objectInspector
argument_list|)
decl_stmt|;
name|Map
name|map
init|=
name|lazyMap
operator|.
name|getMap
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|origMap
init|=
operator|(
name|Map
operator|)
name|obj
decl_stmt|;
name|ObjectInspector
name|keyObjectInspector
init|=
operator|(
operator|(
name|MapObjectInspector
operator|)
name|objectInspector
operator|)
operator|.
name|getMapKeyObjectInspector
argument_list|()
decl_stmt|;
name|ObjectInspector
name|valueObjectInspector
init|=
operator|(
operator|(
name|MapObjectInspector
operator|)
name|objectInspector
operator|)
operator|.
name|getMapValueObjectInspector
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
name|entry
range|:
name|origMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Object
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|toLazyPrimitiveObject
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|keyObjectInspector
argument_list|)
argument_list|,
name|toLazyObject
argument_list|(
name|value
argument_list|,
name|valueObjectInspector
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|lazyMap
return|;
block|}
comment|/**    * Convert the given object to a lazy object using the given {@link ObjectInspector}    *    * @param obj Object to be converted to a {@link LazyObject}    * @param oi ObjectInspector used for the conversion    * @return the created {@link LazyObject lazy object}    * */
specifier|private
name|Object
name|toLazyUnionObject
parameter_list|(
name|Object
name|obj
parameter_list|,
name|ObjectInspector
name|objectInspector
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|objectInspector
operator|instanceof
name|LazyUnionObjectInspector
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid objectinspector found. Expected LazyUnionObjectInspector, Found "
operator|+
name|objectInspector
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
name|StandardUnion
name|standardUnion
init|=
operator|(
name|StandardUnion
operator|)
name|obj
decl_stmt|;
name|LazyUnionObjectInspector
name|lazyUnionOI
init|=
operator|(
name|LazyUnionObjectInspector
operator|)
name|objectInspector
decl_stmt|;
comment|// Grab the tag and the field
name|byte
name|tag
init|=
name|standardUnion
operator|.
name|getTag
argument_list|()
decl_stmt|;
name|Object
name|field
init|=
name|standardUnion
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|ObjectInspector
name|fieldOI
init|=
name|lazyUnionOI
operator|.
name|getObjectInspectors
argument_list|()
operator|.
name|get
argument_list|(
name|tag
argument_list|)
decl_stmt|;
comment|// convert to lazy object
name|Object
name|convertedObj
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|field
operator|!=
literal|null
condition|)
block|{
name|convertedObj
operator|=
name|toLazyObject
argument_list|(
name|field
argument_list|,
name|fieldOI
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|convertedObj
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|LazyUnion
argument_list|(
name|lazyUnionOI
argument_list|,
name|tag
argument_list|,
name|convertedObj
argument_list|)
return|;
block|}
comment|/**    * Determines if the given object is a primitive or a wrapper to a primitive. Note, even though a    *<code>String</code> may not be a primitive in the traditional sense, but it is considered one    * here as it is<i>not</i> a struct.    *    * @param clazz input class    * @return true, if the object is a primitive or a wrapper to a primitive, false otherwise.    * */
specifier|private
name|boolean
name|isPrimitive
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|)
block|{
return|return
name|clazz
operator|.
name|isPrimitive
argument_list|()
operator|||
name|ClassUtils
operator|.
name|wrapperToPrimitive
argument_list|(
name|clazz
argument_list|)
operator|!=
literal|null
operator|||
name|clazz
operator|.
name|getSimpleName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"String"
argument_list|)
return|;
block|}
block|}
end_class

end_unit

