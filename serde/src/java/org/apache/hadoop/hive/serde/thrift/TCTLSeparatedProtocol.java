begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|thrift
package|;
end_package

begin_import
import|import
name|com
operator|.
name|facebook
operator|.
name|thrift
operator|.
name|TException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|facebook
operator|.
name|thrift
operator|.
name|transport
operator|.
name|*
import|;
end_import

begin_import
import|import
name|com
operator|.
name|facebook
operator|.
name|thrift
operator|.
name|*
import|;
end_import

begin_import
import|import
name|com
operator|.
name|facebook
operator|.
name|thrift
operator|.
name|protocol
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  *  * An implementation of the Thrift Protocol for ctl separated  * records.  * This is not thrift compliant in that it doesn't write out field ids  * so things cannot actually be versioned.  */
end_comment

begin_class
specifier|public
class|class
name|TCTLSeparatedProtocol
extends|extends
name|TProtocol
block|{
comment|/**    * Factory for JSON protocol objects    */
specifier|public
specifier|static
class|class
name|Factory
implements|implements
name|TProtocolFactory
block|{
specifier|public
name|TProtocol
name|getProtocol
parameter_list|(
name|TTransport
name|trans
parameter_list|)
block|{
return|return
operator|new
name|TCTLSeparatedProtocol
argument_list|(
name|trans
argument_list|)
return|;
block|}
block|}
comment|/**    * These are defaults, but for now leaving them like this    */
specifier|final
specifier|static
specifier|protected
name|byte
name|defaultPrimarySeparatorChar_
init|=
literal|1
decl_stmt|;
specifier|final
specifier|static
specifier|protected
name|byte
name|defaultSecondarySeparatorChar_
init|=
literal|2
decl_stmt|;
specifier|final
specifier|static
specifier|protected
name|byte
name|defaultRowSeparatorChar_
init|=
operator|(
name|byte
operator|)
literal|'\n'
decl_stmt|;
comment|/**    * The separators for this instance    */
specifier|final
specifier|protected
name|byte
name|primarySeparatorChar_
decl_stmt|;
specifier|final
specifier|protected
name|byte
name|secondarySeparatorChar_
decl_stmt|;
specifier|final
specifier|protected
name|byte
name|rowSeparatorChar_
decl_stmt|;
specifier|final
specifier|protected
name|byte
name|primarySeparator_
index|[]
decl_stmt|;
specifier|final
specifier|protected
name|byte
name|secondarySeparator_
index|[]
decl_stmt|;
specifier|final
specifier|protected
name|byte
name|rowSeparator_
index|[]
decl_stmt|;
comment|/**    * The transport stream is tokenized on the row separator    */
specifier|protected
name|SimpleTransportTokenizer
name|transportTokenizer_
decl_stmt|;
comment|/**    * For a single row, the split on the primary separator    */
specifier|protected
name|String
name|columns_
index|[]
decl_stmt|;
comment|/**    * An index into what column we're on    */
specifier|protected
name|int
name|index_
decl_stmt|;
comment|/**    * For a single column, a split on the secondary separator    */
specifier|protected
name|String
name|fields_
index|[]
decl_stmt|;
comment|/**    * An index into what field within a column we're on    */
specifier|protected
name|int
name|innerIndex_
decl_stmt|;
comment|/**    * The current separator for writes    */
specifier|protected
name|byte
name|separator_
decl_stmt|;
comment|/**    * Are we currently on the top-level columns or parsing a column itself    */
specifier|protected
name|boolean
name|inner_
decl_stmt|;
comment|/**    * For places where the separators are back to back, should we return a null or an empty string since it is ambiguous.    * This also applies to extra columns that are read but aren't in the current record.    */
specifier|final
specifier|protected
name|boolean
name|returnNulls_
decl_stmt|;
comment|/**    * A convenience class for tokenizing a TTransport    */
class|class
name|SimpleTransportTokenizer
block|{
name|TTransport
name|trans_
decl_stmt|;
name|StringTokenizer
name|tokenizer_
decl_stmt|;
specifier|final
name|String
name|separator_
decl_stmt|;
name|byte
name|buf
index|[]
decl_stmt|;
specifier|public
name|SimpleTransportTokenizer
parameter_list|(
name|TTransport
name|trans
parameter_list|,
name|byte
name|separator
parameter_list|,
name|int
name|buffer_length
parameter_list|)
block|{
name|trans_
operator|=
name|trans
expr_stmt|;
name|byte
index|[]
name|separators
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
name|separators
index|[
literal|0
index|]
operator|=
name|separator
expr_stmt|;
name|separator_
operator|=
operator|new
name|String
argument_list|(
name|separators
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|new
name|byte
index|[
name|buffer_length
index|]
expr_stmt|;
name|fillTokenizer
argument_list|()
expr_stmt|;
block|}
specifier|private
name|boolean
name|fillTokenizer
parameter_list|()
block|{
try|try
block|{
name|int
name|length
init|=
name|trans_
operator|.
name|read
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
block|{
name|tokenizer_
operator|=
operator|new
name|StringTokenizer
argument_list|(
literal|""
argument_list|,
name|separator_
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|String
name|row
init|=
operator|new
name|String
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|tokenizer_
operator|=
operator|new
name|StringTokenizer
argument_list|(
name|row
argument_list|,
operator|new
name|String
argument_list|(
name|separator_
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TTransportException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|tokenizer_
operator|=
literal|null
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|String
name|nextToken
parameter_list|()
throws|throws
name|EOFException
block|{
name|StringBuffer
name|ret
init|=
literal|null
decl_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
operator|!
name|tokenizer_
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|fillTokenizer
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
try|try
block|{
specifier|final
name|String
name|nextToken
init|=
name|tokenizer_
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextToken
operator|.
name|equals
argument_list|(
name|separator_
argument_list|)
condition|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
literal|null
condition|)
block|{
name|ret
operator|=
operator|new
name|StringBuffer
argument_list|(
name|nextToken
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|.
name|append
argument_list|(
name|nextToken
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|e
parameter_list|)
block|{
if|if
condition|(
name|ret
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
name|done
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// while ! done
return|return
name|ret
operator|==
literal|null
condition|?
literal|null
else|:
name|ret
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
empty_stmt|;
comment|/**    * The simple constructor which assumes ctl-a, ctl-b and '\n' separators and to return empty strings for empty fields.    *    * @param trans - the ttransport to use as input or output    *    */
specifier|public
name|TCTLSeparatedProtocol
parameter_list|(
name|TTransport
name|trans
parameter_list|)
block|{
name|this
argument_list|(
name|trans
argument_list|,
name|defaultPrimarySeparatorChar_
argument_list|,
name|defaultSecondarySeparatorChar_
argument_list|,
name|defaultRowSeparatorChar_
argument_list|,
literal|false
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
block|}
specifier|public
name|TCTLSeparatedProtocol
parameter_list|(
name|TTransport
name|trans
parameter_list|,
name|int
name|buffer_size
parameter_list|)
block|{
name|this
argument_list|(
name|trans
argument_list|,
name|defaultPrimarySeparatorChar_
argument_list|,
name|defaultSecondarySeparatorChar_
argument_list|,
name|defaultRowSeparatorChar_
argument_list|,
literal|false
argument_list|,
name|buffer_size
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param trans - the ttransport to use as input or output    * @param primarySeparatorChar the separator between columns (aka fields)    * @param secondarySeparatorChar the separator within a field for things like sets and maps and lists    * @param rowSeparatorChar - the record separator    * @param returnNulls - whether to return a null or an empty string for fields that seem empty (ie two primary separators back to back)    */
specifier|public
name|TCTLSeparatedProtocol
parameter_list|(
name|TTransport
name|trans
parameter_list|,
name|byte
name|primarySeparatorChar
parameter_list|,
name|byte
name|secondarySeparatorChar
parameter_list|,
name|byte
name|rowSeparatorChar
parameter_list|,
name|boolean
name|returnNulls
parameter_list|,
name|int
name|buffer_length
parameter_list|)
block|{
name|super
argument_list|(
name|trans
argument_list|)
expr_stmt|;
name|returnNulls_
operator|=
name|returnNulls
expr_stmt|;
name|primarySeparatorChar_
operator|=
name|primarySeparatorChar
expr_stmt|;
name|secondarySeparatorChar_
operator|=
name|secondarySeparatorChar
expr_stmt|;
name|rowSeparatorChar_
operator|=
name|rowSeparatorChar
expr_stmt|;
name|primarySeparator_
operator|=
operator|new
name|byte
index|[
literal|1
index|]
expr_stmt|;
name|primarySeparator_
index|[
literal|0
index|]
operator|=
name|primarySeparatorChar_
expr_stmt|;
name|secondarySeparator_
operator|=
operator|new
name|byte
index|[
literal|1
index|]
expr_stmt|;
name|secondarySeparator_
index|[
literal|0
index|]
operator|=
name|secondarySeparatorChar_
expr_stmt|;
name|rowSeparator_
operator|=
operator|new
name|byte
index|[
literal|1
index|]
expr_stmt|;
name|rowSeparator_
index|[
literal|0
index|]
operator|=
name|rowSeparatorChar_
expr_stmt|;
name|transportTokenizer_
operator|=
operator|new
name|SimpleTransportTokenizer
argument_list|(
name|trans
argument_list|,
name|rowSeparatorChar
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|writeMessageBegin
parameter_list|(
name|TMessage
name|message
parameter_list|)
throws|throws
name|TException
block|{   }
specifier|public
name|void
name|writeMessageEnd
parameter_list|()
throws|throws
name|TException
block|{   }
specifier|public
name|void
name|writeStructBegin
parameter_list|(
name|TStruct
name|struct
parameter_list|)
throws|throws
name|TException
block|{
comment|// do nothing
block|}
specifier|public
name|void
name|writeStructEnd
parameter_list|()
throws|throws
name|TException
block|{
name|writeByte
argument_list|(
name|rowSeparatorChar_
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|writeFieldBegin
parameter_list|(
name|TField
name|field
parameter_list|)
throws|throws
name|TException
block|{
comment|// do nothing
block|}
specifier|public
name|void
name|writeFieldEnd
parameter_list|()
throws|throws
name|TException
block|{
name|writeByte
argument_list|(
name|separator_
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|writeFieldStop
parameter_list|()
block|{}
specifier|public
name|void
name|writeMapBegin
parameter_list|(
name|TMap
name|map
parameter_list|)
throws|throws
name|TException
block|{
if|if
condition|(
name|map
operator|.
name|keyType
operator|==
name|TType
operator|.
name|STRUCT
operator|||
name|map
operator|.
name|keyType
operator|==
name|TType
operator|.
name|MAP
operator|||
name|map
operator|.
name|keyType
operator|==
name|TType
operator|.
name|LIST
operator|||
name|map
operator|.
name|keyType
operator|==
name|TType
operator|.
name|SET
condition|)
block|{
throw|throw
operator|new
name|TException
argument_list|(
literal|"Not implemented: nested structures"
argument_list|)
throw|;
block|}
if|if
condition|(
name|map
operator|.
name|valueType
operator|==
name|TType
operator|.
name|STRUCT
operator|||
name|map
operator|.
name|valueType
operator|==
name|TType
operator|.
name|MAP
operator|||
name|map
operator|.
name|valueType
operator|==
name|TType
operator|.
name|LIST
operator|||
name|map
operator|.
name|valueType
operator|==
name|TType
operator|.
name|SET
condition|)
block|{
throw|throw
operator|new
name|TException
argument_list|(
literal|"Not implemented: nested structures"
argument_list|)
throw|;
block|}
name|separator_
operator|=
name|secondarySeparatorChar_
expr_stmt|;
block|}
specifier|public
name|void
name|writeMapEnd
parameter_list|()
throws|throws
name|TException
block|{
name|separator_
operator|=
name|primarySeparatorChar_
expr_stmt|;
block|}
specifier|public
name|void
name|writeListBegin
parameter_list|(
name|TList
name|list
parameter_list|)
throws|throws
name|TException
block|{
if|if
condition|(
name|list
operator|.
name|elemType
operator|==
name|TType
operator|.
name|STRUCT
operator|||
name|list
operator|.
name|elemType
operator|==
name|TType
operator|.
name|MAP
operator|||
name|list
operator|.
name|elemType
operator|==
name|TType
operator|.
name|LIST
operator|||
name|list
operator|.
name|elemType
operator|==
name|TType
operator|.
name|SET
condition|)
block|{
throw|throw
operator|new
name|TException
argument_list|(
literal|"Not implemented: nested structures"
argument_list|)
throw|;
block|}
name|separator_
operator|=
name|secondarySeparatorChar_
expr_stmt|;
block|}
specifier|public
name|void
name|writeListEnd
parameter_list|()
throws|throws
name|TException
block|{
name|separator_
operator|=
name|primarySeparatorChar_
expr_stmt|;
block|}
specifier|public
name|void
name|writeSetBegin
parameter_list|(
name|TSet
name|set
parameter_list|)
throws|throws
name|TException
block|{
if|if
condition|(
name|set
operator|.
name|elemType
operator|==
name|TType
operator|.
name|STRUCT
operator|||
name|set
operator|.
name|elemType
operator|==
name|TType
operator|.
name|MAP
operator|||
name|set
operator|.
name|elemType
operator|==
name|TType
operator|.
name|LIST
operator|||
name|set
operator|.
name|elemType
operator|==
name|TType
operator|.
name|SET
condition|)
block|{
throw|throw
operator|new
name|TException
argument_list|(
literal|"Not implemented: nested structures"
argument_list|)
throw|;
block|}
name|separator_
operator|=
name|secondarySeparatorChar_
expr_stmt|;
block|}
specifier|public
name|void
name|writeSetEnd
parameter_list|()
throws|throws
name|TException
block|{
name|separator_
operator|=
name|primarySeparatorChar_
expr_stmt|;
block|}
specifier|public
name|void
name|writeBool
parameter_list|(
name|boolean
name|b
parameter_list|)
throws|throws
name|TException
block|{
name|writeString
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|writeByte
parameter_list|(
name|byte
name|b
parameter_list|)
throws|throws
name|TException
block|{
name|writeString
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|writeI16
parameter_list|(
name|short
name|i16
parameter_list|)
throws|throws
name|TException
block|{
name|writeString
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|i16
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|writeI32
parameter_list|(
name|int
name|i32
parameter_list|)
throws|throws
name|TException
block|{
name|writeString
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|i32
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|writeI64
parameter_list|(
name|long
name|i64
parameter_list|)
throws|throws
name|TException
block|{
name|writeString
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|i64
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|writeDouble
parameter_list|(
name|double
name|dub
parameter_list|)
throws|throws
name|TException
block|{
name|writeString
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|dub
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|writeString
parameter_list|(
name|String
name|str
parameter_list|)
throws|throws
name|TException
block|{
specifier|final
name|byte
name|buf
index|[]
init|=
name|str
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|trans_
operator|.
name|write
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|writeBinary
parameter_list|(
name|byte
index|[]
name|bin
parameter_list|)
throws|throws
name|TException
block|{
throw|throw
operator|new
name|TException
argument_list|(
literal|"Ctl separated protocol cannot support writing Binary data!"
argument_list|)
throw|;
block|}
specifier|public
name|TMessage
name|readMessageBegin
parameter_list|()
throws|throws
name|TException
block|{
return|return
operator|new
name|TMessage
argument_list|()
return|;
comment|// xxx check on fields in here
block|}
specifier|public
name|void
name|readMessageEnd
parameter_list|()
throws|throws
name|TException
block|{   }
specifier|public
name|TStruct
name|readStructBegin
parameter_list|()
throws|throws
name|TException
block|{
try|try
block|{
specifier|final
name|String
name|tmp
init|=
name|transportTokenizer_
operator|.
name|nextToken
argument_list|()
decl_stmt|;
name|columns_
operator|=
name|tmp
operator|.
name|split
argument_list|(
operator|new
name|String
argument_list|(
name|primarySeparator_
argument_list|)
argument_list|)
expr_stmt|;
name|index_
operator|=
literal|0
expr_stmt|;
return|return
operator|new
name|TStruct
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|void
name|readStructEnd
parameter_list|()
throws|throws
name|TException
block|{
name|columns_
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|TField
name|readFieldBegin
parameter_list|()
throws|throws
name|TException
block|{
if|if
condition|(
operator|!
name|inner_
condition|)
block|{
if|if
condition|(
name|index_
operator|<
name|columns_
operator|.
name|length
condition|)
block|{
name|fields_
operator|=
name|columns_
index|[
name|index_
operator|++
index|]
operator|.
name|split
argument_list|(
operator|new
name|String
argument_list|(
name|secondarySeparator_
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fields_
operator|=
literal|null
expr_stmt|;
block|}
name|innerIndex_
operator|=
literal|0
expr_stmt|;
block|}
name|TField
name|f
init|=
operator|new
name|TField
argument_list|()
decl_stmt|;
name|f
operator|.
name|type
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|f
return|;
block|}
specifier|public
name|void
name|readFieldEnd
parameter_list|()
throws|throws
name|TException
block|{
name|fields_
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|TMap
name|readMapBegin
parameter_list|()
throws|throws
name|TException
block|{
name|TMap
name|map
init|=
operator|new
name|TMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields_
operator|!=
literal|null
condition|)
block|{
name|map
operator|.
name|size
operator|=
name|fields_
operator|.
name|length
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
name|map
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
name|inner_
operator|=
literal|true
expr_stmt|;
return|return
name|map
return|;
block|}
specifier|public
name|void
name|readMapEnd
parameter_list|()
throws|throws
name|TException
block|{
name|inner_
operator|=
literal|false
expr_stmt|;
block|}
specifier|public
name|TList
name|readListBegin
parameter_list|()
throws|throws
name|TException
block|{
name|TList
name|list
init|=
operator|new
name|TList
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields_
operator|!=
literal|null
condition|)
block|{
name|list
operator|.
name|size
operator|=
name|fields_
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|list
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
name|inner_
operator|=
literal|true
expr_stmt|;
return|return
name|list
return|;
block|}
specifier|public
name|void
name|readListEnd
parameter_list|()
throws|throws
name|TException
block|{
name|inner_
operator|=
literal|false
expr_stmt|;
block|}
specifier|public
name|TSet
name|readSetBegin
parameter_list|()
throws|throws
name|TException
block|{
name|TSet
name|set
init|=
operator|new
name|TSet
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields_
operator|!=
literal|null
condition|)
block|{
name|set
operator|.
name|size
operator|=
name|fields_
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|set
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
name|inner_
operator|=
literal|true
expr_stmt|;
return|return
name|set
return|;
block|}
specifier|public
name|void
name|readSetEnd
parameter_list|()
throws|throws
name|TException
block|{
name|inner_
operator|=
literal|false
expr_stmt|;
block|}
specifier|public
name|boolean
name|readBool
parameter_list|()
throws|throws
name|TException
block|{
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|readString
argument_list|()
argument_list|)
operator|.
name|booleanValue
argument_list|()
return|;
block|}
specifier|public
name|byte
name|readByte
parameter_list|()
throws|throws
name|TException
block|{
return|return
name|Byte
operator|.
name|valueOf
argument_list|(
name|readString
argument_list|()
argument_list|)
operator|.
name|byteValue
argument_list|()
return|;
block|}
specifier|public
name|short
name|readI16
parameter_list|()
throws|throws
name|TException
block|{
return|return
name|Short
operator|.
name|valueOf
argument_list|(
name|readString
argument_list|()
argument_list|)
operator|.
name|shortValue
argument_list|()
return|;
block|}
specifier|public
name|int
name|readI32
parameter_list|()
throws|throws
name|TException
block|{
return|return
name|Integer
operator|.
name|valueOf
argument_list|(
name|readString
argument_list|()
argument_list|)
operator|.
name|intValue
argument_list|()
return|;
block|}
specifier|public
name|long
name|readI64
parameter_list|()
throws|throws
name|TException
block|{
return|return
name|Long
operator|.
name|valueOf
argument_list|(
name|readString
argument_list|()
argument_list|)
operator|.
name|longValue
argument_list|()
return|;
block|}
specifier|public
name|double
name|readDouble
parameter_list|()
throws|throws
name|TException
block|{
return|return
name|Double
operator|.
name|valueOf
argument_list|(
name|readString
argument_list|()
argument_list|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
specifier|public
name|String
name|readString
parameter_list|()
throws|throws
name|TException
block|{
if|if
condition|(
name|fields_
operator|==
literal|null
condition|)
block|{
return|return
name|returnNulls_
condition|?
literal|null
else|:
literal|""
return|;
block|}
if|if
condition|(
name|innerIndex_
operator|<
name|fields_
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|returnNulls_
operator|&&
name|fields_
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|fields_
index|[
name|innerIndex_
operator|++
index|]
return|;
block|}
block|}
else|else
block|{
comment|// treat extra columns/strings as nulls
return|return
name|returnNulls_
condition|?
literal|null
else|:
literal|""
return|;
block|}
block|}
specifier|public
name|byte
index|[]
name|readBinary
parameter_list|()
throws|throws
name|TException
block|{
throw|throw
operator|new
name|TException
argument_list|(
literal|"Not implemented"
argument_list|)
throw|;
block|}
block|}
end_class

end_unit

