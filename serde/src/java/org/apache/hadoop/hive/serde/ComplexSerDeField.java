begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_comment
comment|/**  * Implementation of SerDeField that provides support for nested and indexed accesses  * Assumes that a class is composed of types - all of which can be handled by same SerDe  * family  *  */
end_comment

begin_class
specifier|public
class|class
name|ComplexSerDeField
implements|implements
name|SerDeField
block|{
specifier|public
specifier|static
specifier|final
name|Log
name|l4j
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
literal|"ComplexSerDeField"
argument_list|)
decl_stmt|;
comment|/**    * A complex field is a series of units. Each unit is a field    */
specifier|public
specifier|static
class|class
name|Unit
implements|implements
name|SerDeField
block|{
name|SerDeField
name|unitField
decl_stmt|;
comment|// List related state
name|boolean
name|isList
decl_stmt|;
name|boolean
name|isSlice
decl_stmt|;
name|int
name|lowIndex
decl_stmt|;
name|int
name|highIndex
decl_stmt|;
comment|// map related state
name|boolean
name|isMap
decl_stmt|;
name|String
name|keyString
decl_stmt|;
name|Object
name|keyValue
decl_stmt|;
specifier|public
name|Unit
parameter_list|()
block|{
name|unitField
operator|=
literal|null
expr_stmt|;
name|keyValue
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|void
name|init
parameter_list|(
name|SerDeField
name|h
parameter_list|,
name|String
name|sliceExpression
parameter_list|)
throws|throws
name|SerDeException
block|{
name|unitField
operator|=
name|h
expr_stmt|;
name|l4j
operator|.
name|debug
argument_list|(
literal|"Unit.init HF= "
operator|+
name|ReflectionSerDeField
operator|.
name|fieldToString
argument_list|(
name|unitField
argument_list|)
argument_list|)
expr_stmt|;
name|isList
operator|=
name|unitField
operator|.
name|isList
argument_list|()
expr_stmt|;
name|isSlice
operator|=
name|isList
expr_stmt|;
name|lowIndex
operator|=
literal|0
expr_stmt|;
name|highIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|isMap
operator|=
name|unitField
operator|.
name|isMap
argument_list|()
expr_stmt|;
if|if
condition|(
name|sliceExpression
operator|==
literal|null
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|isList
operator|&&
operator|!
name|isMap
condition|)
block|{
throw|throw
operator|new
name|SerDeException
argument_list|(
literal|"Trying to index type "
operator|+
name|unitField
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" which is neither list nor map"
argument_list|)
throw|;
block|}
try|try
block|{
if|if
condition|(
name|isList
condition|)
block|{
if|if
condition|(
name|sliceExpression
operator|.
name|indexOf
argument_list|(
literal|":"
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|isSlice
operator|=
literal|false
expr_stmt|;
name|lowIndex
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|sliceExpression
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
index|[]
name|lh
init|=
name|sliceExpression
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
if|if
condition|(
name|lh
operator|.
name|length
operator|>
literal|2
condition|)
block|{
throw|throw
operator|new
name|SerDeException
argument_list|(
literal|"Illegal list slice: "
operator|+
name|sliceExpression
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|lh
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
name|lowIndex
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|lh
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lh
index|[
literal|1
index|]
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
name|highIndex
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|lh
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|isMap
condition|)
block|{
name|keyString
operator|=
name|sliceExpression
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SerDeException
argument_list|(
literal|"Illegal slice expression "
operator|+
name|sliceExpression
argument_list|)
throw|;
block|}
block|}
specifier|public
name|Object
name|get
parameter_list|(
name|Object
name|o
parameter_list|)
throws|throws
name|SerDeException
block|{
name|Object
name|obj
init|=
name|unitField
operator|.
name|get
argument_list|(
name|o
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|isList
operator|&&
operator|!
name|isMap
operator|)
operator|||
operator|(
name|obj
operator|==
literal|null
operator|)
condition|)
block|{
return|return
name|obj
return|;
block|}
if|if
condition|(
name|isList
condition|)
block|{
if|if
condition|(
name|isSlice
operator|&&
operator|(
name|lowIndex
operator|==
literal|0
operator|)
operator|&&
operator|(
name|highIndex
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
name|obj
return|;
name|List
name|lst
init|=
operator|(
name|List
operator|)
name|obj
decl_stmt|;
name|int
name|realLow
init|=
operator|(
name|lowIndex
operator|>=
literal|0
operator|)
condition|?
name|lowIndex
else|:
name|lowIndex
operator|+
name|lst
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isSlice
condition|)
block|{
if|if
condition|(
operator|(
name|realLow
operator|<
literal|0
operator|)
operator|||
operator|(
name|realLow
operator|>=
name|lst
operator|.
name|size
argument_list|()
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|lst
operator|.
name|get
argument_list|(
name|realLow
argument_list|)
return|;
block|}
name|int
name|realHigh
init|=
operator|(
name|highIndex
operator|>=
literal|0
operator|)
condition|?
name|highIndex
else|:
name|highIndex
operator|+
name|lst
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// if the slice does not find anything - return an empty list
comment|// this is not the same as null - which can be taken to mean an
comment|// undefined member
if|if
condition|(
operator|(
name|realLow
operator|<
literal|0
operator|)
operator|||
operator|(
name|realLow
operator|>=
name|lst
operator|.
name|size
argument_list|()
operator|)
condition|)
block|{
return|return
operator|new
name|ArrayList
argument_list|(
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|realHigh
operator|<
literal|0
operator|)
operator|||
operator|(
name|realHigh
operator|>=
name|lst
operator|.
name|size
argument_list|()
operator|)
condition|)
block|{
return|return
operator|new
name|ArrayList
argument_list|(
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|realHigh
operator|<
name|realLow
condition|)
block|{
return|return
operator|new
name|ArrayList
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|ArrayList
name|ret
init|=
operator|new
name|ArrayList
argument_list|(
name|realHigh
operator|-
name|realLow
operator|+
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|realLow
init|;
name|i
operator|<=
name|realHigh
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|.
name|add
argument_list|(
name|lst
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
else|else
block|{
comment|//isMap
if|if
condition|(
name|keyString
operator|!=
literal|null
condition|)
block|{
return|return
operator|(
operator|(
name|Map
operator|)
name|obj
operator|)
operator|.
name|get
argument_list|(
name|keyString
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|obj
return|;
block|}
block|}
block|}
specifier|public
name|Class
name|getType
parameter_list|()
block|{
if|if
condition|(
name|isList
operator|&&
operator|!
name|isSlice
condition|)
block|{
return|return
name|unitField
operator|.
name|getListElementType
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|isMap
operator|&&
operator|(
name|keyString
operator|!=
literal|null
operator|)
condition|)
block|{
return|return
name|unitField
operator|.
name|getMapValueType
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|unitField
operator|.
name|getType
argument_list|()
return|;
block|}
block|}
specifier|public
name|boolean
name|isList
parameter_list|()
block|{
return|return
operator|(
name|isList
operator|&&
name|isSlice
operator|)
return|;
block|}
specifier|public
name|boolean
name|isPrimitive
parameter_list|()
block|{
if|if
condition|(
name|isList
operator|&&
operator|!
name|isSlice
condition|)
block|{
return|return
name|ReflectionSerDeField
operator|.
name|isClassPrimitive
argument_list|(
name|unitField
operator|.
name|getListElementType
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isMap
operator|&&
operator|(
name|keyString
operator|!=
literal|null
operator|)
condition|)
block|{
return|return
name|ReflectionSerDeField
operator|.
name|isClassPrimitive
argument_list|(
name|unitField
operator|.
name|getMapValueType
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|unitField
operator|.
name|isPrimitive
argument_list|()
return|;
block|}
block|}
specifier|public
name|boolean
name|isMap
parameter_list|()
block|{
return|return
operator|(
name|isMap
operator|&&
operator|(
name|keyString
operator|==
literal|null
operator|)
operator|)
return|;
block|}
specifier|public
name|Class
name|getListElementType
parameter_list|()
block|{
if|if
condition|(
name|isList
argument_list|()
condition|)
block|{
return|return
name|unitField
operator|.
name|getListElementType
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Not a list"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|Class
name|getMapKeyType
parameter_list|()
block|{
if|if
condition|(
name|isMap
argument_list|()
condition|)
block|{
return|return
name|unitField
operator|.
name|getMapKeyType
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Not a map"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|Class
name|getMapValueType
parameter_list|()
block|{
if|if
condition|(
name|isMap
argument_list|()
condition|)
block|{
return|return
name|unitField
operator|.
name|getMapValueType
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Not a map"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|String
name|getName
parameter_list|()
block|{
if|if
condition|(
name|isList
condition|)
block|{
return|return
operator|(
name|unitField
operator|.
name|getName
argument_list|()
operator|+
literal|"["
operator|+
operator|(
name|isSlice
condition|?
name|lowIndex
operator|+
literal|":"
operator|+
name|highIndex
else|:
name|lowIndex
operator|)
operator|+
literal|"]"
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|isMap
condition|)
block|{
return|return
operator|(
name|unitField
operator|.
name|getName
argument_list|()
operator|+
operator|(
operator|(
name|keyString
operator|!=
literal|null
operator|)
condition|?
literal|"["
operator|+
name|keyString
operator|+
literal|"]"
else|:
literal|""
operator|)
operator|)
return|;
block|}
else|else
block|{
return|return
name|unitField
operator|.
name|getName
argument_list|()
return|;
block|}
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ComplexSerDeField.Unit["
operator|+
literal|"isList="
operator|+
name|isList
operator|+
literal|",isSlice="
operator|+
name|isSlice
operator|+
literal|",lowIndex="
operator|+
name|lowIndex
operator|+
literal|",highIndex="
operator|+
name|highIndex
operator|+
literal|",isMap="
operator|+
name|isMap
operator|+
literal|",keyString="
operator|+
name|keyString
operator|+
literal|",keyValue="
operator|+
name|keyValue
operator|+
literal|"]"
return|;
block|}
block|}
comment|// end unit class
specifier|private
name|ArrayList
name|currentObjects
decl_stmt|,
name|nextObjects
decl_stmt|;
specifier|private
specifier|static
name|Pattern
name|sUnit
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"([^\\.\\[\\]]+?)?(\\[([^\\[\\]\\.]+?)\\])?"
argument_list|)
decl_stmt|;
specifier|protected
name|Unit
index|[]
name|unitArray
decl_stmt|;
specifier|protected
name|boolean
name|isList
decl_stmt|;
specifier|protected
name|boolean
name|isMap
decl_stmt|;
specifier|protected
name|boolean
name|isClove
decl_stmt|;
specifier|protected
name|boolean
name|isLength
decl_stmt|;
specifier|protected
name|String
name|fieldName
decl_stmt|;
specifier|public
name|ComplexSerDeField
parameter_list|(
name|SerDeField
name|parentField
parameter_list|,
name|String
name|fieldName
parameter_list|,
name|SerDe
name|classSD
parameter_list|)
throws|throws
name|SerDeException
block|{
name|this
operator|.
name|fieldName
operator|=
name|fieldName
expr_stmt|;
name|isMap
operator|=
name|isList
operator|=
name|isClove
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|fieldName
operator|.
name|startsWith
argument_list|(
literal|"#"
argument_list|)
condition|)
block|{
name|fieldName
operator|=
name|fieldName
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|isLength
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|isLength
operator|=
literal|false
expr_stmt|;
block|}
name|SerDeField
name|curField
init|=
name|parentField
decl_stmt|;
name|String
index|[]
name|component
init|=
name|fieldName
operator|.
name|split
argument_list|(
literal|"\\."
argument_list|)
decl_stmt|;
name|unitArray
operator|=
operator|new
name|Unit
index|[
name|component
operator|.
name|length
index|]
expr_stmt|;
name|int
name|firstListIndex
init|=
operator|-
literal|1
decl_stmt|;
name|l4j
operator|.
name|debug
argument_list|(
literal|"ComplexSerDeField: Parent="
operator|+
operator|(
operator|(
name|parentField
operator|!=
literal|null
operator|)
condition|?
name|parentField
operator|.
name|getName
argument_list|()
else|:
literal|""
operator|)
operator|+
literal|", Field="
operator|+
name|fieldName
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|component
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Matcher
name|m
init|=
name|sUnit
operator|.
name|matcher
argument_list|(
name|component
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|m
operator|.
name|matches
argument_list|()
condition|)
throw|throw
operator|new
name|SerDeException
argument_list|(
literal|"Illegal fieldName: "
operator|+
name|fieldName
argument_list|)
throw|;
name|String
name|cField
init|=
name|m
operator|.
name|group
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|String
name|cIndex
init|=
name|m
operator|.
name|group
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|unitArray
index|[
name|i
index|]
operator|=
operator|new
name|Unit
argument_list|()
expr_stmt|;
if|if
condition|(
name|cField
operator|!=
literal|null
condition|)
block|{
name|curField
operator|=
name|classSD
operator|.
name|getFieldFromExpression
argument_list|(
name|curField
argument_list|,
name|cField
argument_list|)
expr_stmt|;
block|}
name|unitArray
index|[
name|i
index|]
operator|.
name|init
argument_list|(
name|curField
argument_list|,
name|cIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|unitArray
index|[
name|i
index|]
operator|.
name|isList
argument_list|()
condition|)
block|{
name|isList
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|firstListIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|firstListIndex
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|(
name|component
operator|.
name|length
operator|-
literal|1
operator|)
condition|)
block|{
name|isClove
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|unitArray
index|[
name|i
index|]
operator|.
name|isMap
argument_list|()
condition|)
block|{
name|isMap
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|(
name|component
operator|.
name|length
operator|-
literal|1
operator|)
condition|)
throw|throw
operator|new
name|SerDeException
argument_list|(
literal|"Trying to nest within map field: "
operator|+
name|cField
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|unitArray
index|[
name|i
index|]
operator|.
name|isPrimitive
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|!=
operator|(
name|component
operator|.
name|length
operator|-
literal|1
operator|)
condition|)
throw|throw
operator|new
name|SerDeException
argument_list|(
literal|"Trying to nest within primitive field: "
operator|+
name|cField
argument_list|)
throw|;
block|}
name|l4j
operator|.
name|debug
argument_list|(
literal|"Unit="
operator|+
name|ReflectionSerDeField
operator|.
name|fieldToString
argument_list|(
name|unitArray
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|// next time when we pass the field to the SerDe - we will pass the unit field.
name|curField
operator|=
name|unitArray
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|isLength
operator|&&
operator|!
name|isList
condition|)
block|{
throw|throw
operator|new
name|SerDeException
argument_list|(
literal|"Cannot get length of non-list type: "
operator|+
name|this
operator|.
name|fieldName
argument_list|)
throw|;
block|}
name|currentObjects
operator|=
operator|new
name|ArrayList
argument_list|()
expr_stmt|;
name|nextObjects
operator|=
operator|new
name|ArrayList
argument_list|()
expr_stmt|;
block|}
specifier|private
name|Object
name|getScalar
parameter_list|(
name|Object
name|obj
parameter_list|)
throws|throws
name|SerDeException
block|{
name|Object
name|curObj
init|=
name|obj
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|unitArray
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|curObj
operator|=
name|unitArray
index|[
name|i
index|]
operator|.
name|get
argument_list|(
name|curObj
argument_list|)
expr_stmt|;
if|if
condition|(
name|curObj
operator|==
literal|null
condition|)
return|return
literal|null
return|;
block|}
return|return
name|curObj
return|;
block|}
specifier|public
name|Object
name|get
parameter_list|(
name|Object
name|obj
parameter_list|)
throws|throws
name|SerDeException
block|{
if|if
condition|(
operator|!
name|isList
condition|)
block|{
return|return
name|getScalar
argument_list|(
name|obj
argument_list|)
return|;
block|}
name|List
name|ret
decl_stmt|;
if|if
condition|(
name|isClove
condition|)
block|{
comment|// a clove is a pattern where only the last element in the dotted notation is
comment|// a list and there is no slice desired on the list. in this case, the field
comment|// lookup algorithm simplifies to that of a scalar.
name|ret
operator|=
operator|(
name|List
operator|)
name|getScalar
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
operator|(
name|List
operator|)
name|getList
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isLength
condition|)
block|{
if|if
condition|(
name|ret
operator|==
literal|null
condition|)
block|{
return|return
name|Integer
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
return|;
block|}
return|return
name|Integer
operator|.
name|valueOf
argument_list|(
name|ret
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|ret
return|;
block|}
block|}
specifier|private
name|Object
name|getList
parameter_list|(
name|Object
name|obj
parameter_list|)
throws|throws
name|SerDeException
block|{
name|currentObjects
operator|.
name|clear
argument_list|()
expr_stmt|;
name|nextObjects
operator|.
name|clear
argument_list|()
expr_stmt|;
name|currentObjects
operator|.
name|add
argument_list|(
name|obj
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|unitArray
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Iterator
name|iter
init|=
name|currentObjects
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Object
name|oneObj
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|Object
name|childObj
init|=
name|unitArray
index|[
name|i
index|]
operator|.
name|get
argument_list|(
name|oneObj
argument_list|)
decl_stmt|;
if|if
condition|(
name|childObj
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
name|unitArray
index|[
name|i
index|]
operator|.
name|isList
argument_list|()
condition|)
block|{
name|Iterator
name|childIter
init|=
operator|(
operator|(
name|AbstractList
operator|)
name|childObj
operator|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|childIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|nextObjects
operator|.
name|add
argument_list|(
name|childIter
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|nextObjects
operator|.
name|add
argument_list|(
name|childObj
argument_list|)
expr_stmt|;
block|}
block|}
name|currentObjects
operator|.
name|clear
argument_list|()
expr_stmt|;
name|ArrayList
name|tmp
init|=
name|currentObjects
decl_stmt|;
name|currentObjects
operator|=
name|nextObjects
expr_stmt|;
name|nextObjects
operator|=
name|tmp
expr_stmt|;
block|}
return|return
name|currentObjects
return|;
block|}
specifier|public
name|Class
name|getType
parameter_list|()
block|{
if|if
condition|(
name|isLength
condition|)
block|{
return|return
name|Integer
operator|.
name|class
return|;
block|}
else|else
block|{
if|if
condition|(
name|isList
condition|)
return|return
name|List
operator|.
name|class
return|;
comment|// Type of nested expression is the type of the leaf component
return|return
name|unitArray
index|[
name|unitArray
operator|.
name|length
operator|-
literal|1
index|]
operator|.
name|getType
argument_list|()
return|;
block|}
block|}
specifier|public
name|Class
name|getListElementType
parameter_list|()
block|{
if|if
condition|(
name|isList
argument_list|()
condition|)
block|{
if|if
condition|(
name|unitArray
index|[
name|unitArray
operator|.
name|length
operator|-
literal|1
index|]
operator|.
name|isList
argument_list|()
condition|)
block|{
comment|// Either the leaf elements are themselves lists - in which case
comment|// the final element type are the elements in the leaf lists
return|return
operator|(
name|unitArray
index|[
name|unitArray
operator|.
name|length
operator|-
literal|1
index|]
operator|.
name|getListElementType
argument_list|()
operator|)
return|;
block|}
else|else
block|{
comment|// or the list is composed of elements of the type of the leaf nodes
return|return
operator|(
name|unitArray
index|[
name|unitArray
operator|.
name|length
operator|-
literal|1
index|]
operator|.
name|getType
argument_list|()
operator|)
return|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Not a list field "
argument_list|)
throw|;
block|}
block|}
specifier|public
name|Class
name|getMapKeyType
parameter_list|()
block|{
if|if
condition|(
name|isMap
argument_list|()
condition|)
block|{
return|return
operator|(
name|unitArray
index|[
name|unitArray
operator|.
name|length
operator|-
literal|1
index|]
operator|.
name|getMapKeyType
argument_list|()
operator|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Not a map field "
argument_list|)
throw|;
block|}
block|}
specifier|public
name|Class
name|getMapValueType
parameter_list|()
block|{
if|if
condition|(
name|isMap
argument_list|()
condition|)
block|{
return|return
operator|(
name|unitArray
index|[
name|unitArray
operator|.
name|length
operator|-
literal|1
index|]
operator|.
name|getMapValueType
argument_list|()
operator|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Not a map field "
argument_list|)
throw|;
block|}
block|}
specifier|public
name|boolean
name|isList
parameter_list|()
block|{
return|return
operator|(
name|isList
operator|&&
operator|!
name|isLength
operator|)
return|;
block|}
specifier|public
name|boolean
name|isMap
parameter_list|()
block|{
return|return
operator|(
name|isMap
operator|&&
operator|!
name|isLength
operator|)
return|;
block|}
specifier|public
name|boolean
name|isPrimitive
parameter_list|()
block|{
if|if
condition|(
name|isLength
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|isList
operator|||
name|isMap
condition|)
return|return
literal|false
return|;
comment|// Whether primitive or not depends on type of the leaf component
return|return
name|unitArray
index|[
name|unitArray
operator|.
name|length
operator|-
literal|1
index|]
operator|.
name|isPrimitive
argument_list|()
return|;
block|}
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|this
operator|.
name|fieldName
return|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ComplexSerDeField["
operator|+
literal|"unitArray="
operator|+
name|unitArray
operator|+
literal|",isList="
operator|+
name|isList
operator|+
literal|",isMap="
operator|+
name|isMap
operator|+
literal|",isClove="
operator|+
name|isClove
operator|+
literal|",isLength="
operator|+
name|isLength
operator|+
literal|",fieldName="
operator|+
name|this
operator|.
name|fieldName
operator|+
literal|"]"
return|;
block|}
specifier|private
specifier|static
name|Pattern
name|metachars
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|".*[\\.#\\[\\]].*"
argument_list|)
decl_stmt|;
specifier|public
specifier|static
name|boolean
name|isComplexExpression
parameter_list|(
name|String
name|exp
parameter_list|)
block|{
name|Matcher
name|m
init|=
name|metachars
operator|.
name|matcher
argument_list|(
name|exp
argument_list|)
decl_stmt|;
return|return
operator|(
name|m
operator|.
name|matches
argument_list|()
operator|)
return|;
block|}
block|}
end_class

end_unit

