begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Timestamp
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|BooleanColumnStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|RecordReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|TypeDescription
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|ColumnStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|CompressionCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|DataReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|DateColumnStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|DecimalColumnStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|DoubleColumnStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|IntegerColumnStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|OrcConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|StringColumnStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|StripeInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|TimestampColumnStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|io
operator|.
name|DiskRange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|io
operator|.
name|DiskRangeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|io
operator|.
name|DiskRangeList
operator|.
name|CreateHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|HiveDecimal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizedRowBatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|BloomFilterIO
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|sarg
operator|.
name|PredicateLeaf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|sarg
operator|.
name|SearchArgument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|sarg
operator|.
name|SearchArgument
operator|.
name|TruthValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|DateWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|HiveDecimalWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|util
operator|.
name|TimestampUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|OrcProto
import|;
end_import

begin_class
specifier|public
class|class
name|RecordReaderImpl
implements|implements
name|RecordReader
block|{
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|RecordReaderImpl
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|boolean
name|isLogDebugEnabled
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Object
name|UNKNOWN_VALUE
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|Path
name|path
decl_stmt|;
specifier|private
specifier|final
name|long
name|firstRow
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|StripeInformation
argument_list|>
name|stripes
init|=
operator|new
name|ArrayList
argument_list|<
name|StripeInformation
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|OrcProto
operator|.
name|StripeFooter
name|stripeFooter
decl_stmt|;
specifier|private
specifier|final
name|long
name|totalRowCount
decl_stmt|;
specifier|private
specifier|final
name|CompressionCodec
name|codec
decl_stmt|;
specifier|protected
specifier|final
name|TypeDescription
name|schema
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|OrcProto
operator|.
name|Type
argument_list|>
name|types
decl_stmt|;
specifier|private
specifier|final
name|int
name|bufferSize
decl_stmt|;
specifier|private
specifier|final
name|SchemaEvolution
name|evolution
decl_stmt|;
specifier|private
specifier|final
name|boolean
index|[]
name|included
decl_stmt|;
specifier|private
specifier|final
name|long
name|rowIndexStride
decl_stmt|;
specifier|private
name|long
name|rowInStripe
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|currentStripe
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|long
name|rowBaseInStripe
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|rowCountInStripe
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|StreamName
argument_list|,
name|InStream
argument_list|>
name|streams
init|=
operator|new
name|HashMap
argument_list|<
name|StreamName
argument_list|,
name|InStream
argument_list|>
argument_list|()
decl_stmt|;
name|DiskRangeList
name|bufferChunks
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|TreeReaderFactory
operator|.
name|TreeReader
name|reader
decl_stmt|;
specifier|private
specifier|final
name|OrcProto
operator|.
name|RowIndex
index|[]
name|indexes
decl_stmt|;
specifier|private
specifier|final
name|OrcProto
operator|.
name|BloomFilterIndex
index|[]
name|bloomFilterIndices
decl_stmt|;
specifier|private
specifier|final
name|SargApplier
name|sargApp
decl_stmt|;
comment|// an array about which row groups aren't skipped
specifier|private
name|boolean
index|[]
name|includedRowGroups
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|DataReader
name|dataReader
decl_stmt|;
comment|/**    * Given a list of column names, find the given column and return the index.    *    * @param columnNames the list of potential column names    * @param columnName  the column name to look for    * @param rootColumn  offset the result with the rootColumn    * @return the column number or -1 if the column wasn't found    */
specifier|static
name|int
name|findColumns
parameter_list|(
name|String
index|[]
name|columnNames
parameter_list|,
name|String
name|columnName
parameter_list|,
name|int
name|rootColumn
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columnNames
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|columnName
operator|.
name|equals
argument_list|(
name|columnNames
index|[
name|i
index|]
argument_list|)
condition|)
block|{
return|return
name|i
operator|+
name|rootColumn
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * Find the mapping from predicate leaves to columns.    * @param sargLeaves the search argument that we need to map    * @param columnNames the names of the columns    * @param rootColumn the offset of the top level row, which offsets the    *                   result    * @return an array mapping the sarg leaves to concrete column numbers    */
specifier|public
specifier|static
name|int
index|[]
name|mapSargColumnsToOrcInternalColIdx
parameter_list|(
name|List
argument_list|<
name|PredicateLeaf
argument_list|>
name|sargLeaves
parameter_list|,
name|String
index|[]
name|columnNames
parameter_list|,
name|int
name|rootColumn
parameter_list|)
block|{
name|int
index|[]
name|result
init|=
operator|new
name|int
index|[
name|sargLeaves
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|result
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|result
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|String
name|colName
init|=
name|sargLeaves
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getColumnName
argument_list|()
decl_stmt|;
name|result
index|[
name|i
index|]
operator|=
name|findColumns
argument_list|(
name|columnNames
argument_list|,
name|colName
argument_list|,
name|rootColumn
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|protected
name|RecordReaderImpl
parameter_list|(
name|ReaderImpl
name|fileReader
parameter_list|,
name|Reader
operator|.
name|Options
name|options
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|included
operator|=
name|options
operator|.
name|getInclude
argument_list|()
expr_stmt|;
name|included
index|[
literal|0
index|]
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|options
operator|.
name|getSchema
argument_list|()
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Reader schema not provided -- using file schema "
operator|+
name|fileReader
operator|.
name|getSchema
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|evolution
operator|=
operator|new
name|SchemaEvolution
argument_list|(
name|fileReader
operator|.
name|getSchema
argument_list|()
argument_list|,
name|included
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Now that we are creating a record reader for a file, validate that the schema to read
comment|// is compatible with the file schema.
comment|//
name|evolution
operator|=
operator|new
name|SchemaEvolution
argument_list|(
name|fileReader
operator|.
name|getSchema
argument_list|()
argument_list|,
name|options
operator|.
name|getSchema
argument_list|()
argument_list|,
name|included
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
name|evolution
operator|.
name|hasConversion
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ORC file "
operator|+
name|fileReader
operator|.
name|path
operator|.
name|toString
argument_list|()
operator|+
literal|" has data type conversion --\n"
operator|+
literal|"reader schema: "
operator|+
name|options
operator|.
name|getSchema
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|"\n"
operator|+
literal|"file schema:   "
operator|+
name|fileReader
operator|.
name|getSchema
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|schema
operator|=
name|evolution
operator|.
name|getReaderSchema
argument_list|()
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|fileReader
operator|.
name|path
expr_stmt|;
name|this
operator|.
name|codec
operator|=
name|fileReader
operator|.
name|codec
expr_stmt|;
name|this
operator|.
name|types
operator|=
name|fileReader
operator|.
name|types
expr_stmt|;
name|this
operator|.
name|bufferSize
operator|=
name|fileReader
operator|.
name|bufferSize
expr_stmt|;
name|this
operator|.
name|rowIndexStride
operator|=
name|fileReader
operator|.
name|rowIndexStride
expr_stmt|;
name|SearchArgument
name|sarg
init|=
name|options
operator|.
name|getSearchArgument
argument_list|()
decl_stmt|;
if|if
condition|(
name|sarg
operator|!=
literal|null
operator|&&
name|rowIndexStride
operator|!=
literal|0
condition|)
block|{
name|sargApp
operator|=
operator|new
name|SargApplier
argument_list|(
name|sarg
argument_list|,
name|options
operator|.
name|getColumnNames
argument_list|()
argument_list|,
name|rowIndexStride
argument_list|,
name|included
operator|.
name|length
argument_list|,
name|evolution
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sargApp
operator|=
literal|null
expr_stmt|;
block|}
name|long
name|rows
init|=
literal|0
decl_stmt|;
name|long
name|skippedRows
init|=
literal|0
decl_stmt|;
name|long
name|offset
init|=
name|options
operator|.
name|getOffset
argument_list|()
decl_stmt|;
name|long
name|maxOffset
init|=
name|options
operator|.
name|getMaxOffset
argument_list|()
decl_stmt|;
for|for
control|(
name|StripeInformation
name|stripe
range|:
name|fileReader
operator|.
name|getStripes
argument_list|()
control|)
block|{
name|long
name|stripeStart
init|=
name|stripe
operator|.
name|getOffset
argument_list|()
decl_stmt|;
if|if
condition|(
name|offset
operator|>
name|stripeStart
condition|)
block|{
name|skippedRows
operator|+=
name|stripe
operator|.
name|getNumberOfRows
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stripeStart
operator|<
name|maxOffset
condition|)
block|{
name|this
operator|.
name|stripes
operator|.
name|add
argument_list|(
name|stripe
argument_list|)
expr_stmt|;
name|rows
operator|+=
name|stripe
operator|.
name|getNumberOfRows
argument_list|()
expr_stmt|;
block|}
block|}
name|Boolean
name|zeroCopy
init|=
name|options
operator|.
name|getUseZeroCopy
argument_list|()
decl_stmt|;
if|if
condition|(
name|zeroCopy
operator|==
literal|null
condition|)
block|{
name|zeroCopy
operator|=
name|OrcConf
operator|.
name|USE_ZEROCOPY
operator|.
name|getBoolean
argument_list|(
name|fileReader
operator|.
name|conf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|.
name|getDataReader
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|dataReader
operator|=
name|options
operator|.
name|getDataReader
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|dataReader
operator|=
name|RecordReaderUtils
operator|.
name|createDefaultDataReader
argument_list|(
name|DataReaderProperties
operator|.
name|builder
argument_list|()
operator|.
name|withBufferSize
argument_list|(
name|bufferSize
argument_list|)
operator|.
name|withCompression
argument_list|(
name|fileReader
operator|.
name|compressionKind
argument_list|)
operator|.
name|withFileSystem
argument_list|(
name|fileReader
operator|.
name|fileSystem
argument_list|)
operator|.
name|withPath
argument_list|(
name|fileReader
operator|.
name|path
argument_list|)
operator|.
name|withTypeCount
argument_list|(
name|types
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|withZeroCopy
argument_list|(
name|zeroCopy
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|dataReader
operator|.
name|open
argument_list|()
expr_stmt|;
name|firstRow
operator|=
name|skippedRows
expr_stmt|;
name|totalRowCount
operator|=
name|rows
expr_stmt|;
name|Boolean
name|skipCorrupt
init|=
name|options
operator|.
name|getSkipCorruptRecords
argument_list|()
decl_stmt|;
if|if
condition|(
name|skipCorrupt
operator|==
literal|null
condition|)
block|{
name|skipCorrupt
operator|=
name|OrcConf
operator|.
name|SKIP_CORRUPT_DATA
operator|.
name|getBoolean
argument_list|(
name|fileReader
operator|.
name|conf
argument_list|)
expr_stmt|;
block|}
name|reader
operator|=
name|TreeReaderFactory
operator|.
name|createTreeReader
argument_list|(
name|evolution
operator|.
name|getReaderSchema
argument_list|()
argument_list|,
name|evolution
argument_list|,
name|included
argument_list|,
name|skipCorrupt
argument_list|)
expr_stmt|;
name|indexes
operator|=
operator|new
name|OrcProto
operator|.
name|RowIndex
index|[
name|types
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|bloomFilterIndices
operator|=
operator|new
name|OrcProto
operator|.
name|BloomFilterIndex
index|[
name|types
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|advanceToNextRow
argument_list|(
name|reader
argument_list|,
literal|0L
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
specifier|final
class|class
name|PositionProviderImpl
implements|implements
name|PositionProvider
block|{
specifier|private
specifier|final
name|OrcProto
operator|.
name|RowIndexEntry
name|entry
decl_stmt|;
specifier|private
name|int
name|index
decl_stmt|;
specifier|public
name|PositionProviderImpl
parameter_list|(
name|OrcProto
operator|.
name|RowIndexEntry
name|entry
parameter_list|)
block|{
name|this
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|public
name|PositionProviderImpl
parameter_list|(
name|OrcProto
operator|.
name|RowIndexEntry
name|entry
parameter_list|,
name|int
name|startPos
parameter_list|)
block|{
name|this
operator|.
name|entry
operator|=
name|entry
expr_stmt|;
name|this
operator|.
name|index
operator|=
name|startPos
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getNext
parameter_list|()
block|{
return|return
name|entry
operator|.
name|getPositions
argument_list|(
name|index
operator|++
argument_list|)
return|;
block|}
block|}
specifier|public
name|OrcProto
operator|.
name|StripeFooter
name|readStripeFooter
parameter_list|(
name|StripeInformation
name|stripe
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dataReader
operator|.
name|readStripeFooter
argument_list|(
name|stripe
argument_list|)
return|;
block|}
enum|enum
name|Location
block|{
name|BEFORE
block|,
name|MIN
block|,
name|MIDDLE
block|,
name|MAX
block|,
name|AFTER
block|}
comment|/**    * Given a point and min and max, determine if the point is before, at the    * min, in the middle, at the max, or after the range.    * @param point the point to test    * @param min the minimum point    * @param max the maximum point    * @param<T> the type of the comparision    * @return the location of the point    */
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Location
name|compareToRange
parameter_list|(
name|Comparable
argument_list|<
name|T
argument_list|>
name|point
parameter_list|,
name|T
name|min
parameter_list|,
name|T
name|max
parameter_list|)
block|{
name|int
name|minCompare
init|=
name|point
operator|.
name|compareTo
argument_list|(
name|min
argument_list|)
decl_stmt|;
if|if
condition|(
name|minCompare
operator|<
literal|0
condition|)
block|{
return|return
name|Location
operator|.
name|BEFORE
return|;
block|}
elseif|else
if|if
condition|(
name|minCompare
operator|==
literal|0
condition|)
block|{
return|return
name|Location
operator|.
name|MIN
return|;
block|}
name|int
name|maxCompare
init|=
name|point
operator|.
name|compareTo
argument_list|(
name|max
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxCompare
operator|>
literal|0
condition|)
block|{
return|return
name|Location
operator|.
name|AFTER
return|;
block|}
elseif|else
if|if
condition|(
name|maxCompare
operator|==
literal|0
condition|)
block|{
return|return
name|Location
operator|.
name|MAX
return|;
block|}
return|return
name|Location
operator|.
name|MIDDLE
return|;
block|}
comment|/**    * Get the maximum value out of an index entry.    * @param index    *          the index entry    * @return the object for the maximum value or null if there isn't one    */
specifier|static
name|Object
name|getMax
parameter_list|(
name|ColumnStatistics
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|instanceof
name|IntegerColumnStatistics
condition|)
block|{
return|return
operator|(
operator|(
name|IntegerColumnStatistics
operator|)
name|index
operator|)
operator|.
name|getMaximum
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|index
operator|instanceof
name|DoubleColumnStatistics
condition|)
block|{
return|return
operator|(
operator|(
name|DoubleColumnStatistics
operator|)
name|index
operator|)
operator|.
name|getMaximum
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|index
operator|instanceof
name|StringColumnStatistics
condition|)
block|{
return|return
operator|(
operator|(
name|StringColumnStatistics
operator|)
name|index
operator|)
operator|.
name|getMaximum
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|index
operator|instanceof
name|DateColumnStatistics
condition|)
block|{
return|return
operator|(
operator|(
name|DateColumnStatistics
operator|)
name|index
operator|)
operator|.
name|getMaximum
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|index
operator|instanceof
name|DecimalColumnStatistics
condition|)
block|{
return|return
operator|(
operator|(
name|DecimalColumnStatistics
operator|)
name|index
operator|)
operator|.
name|getMaximum
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|index
operator|instanceof
name|TimestampColumnStatistics
condition|)
block|{
return|return
operator|(
operator|(
name|TimestampColumnStatistics
operator|)
name|index
operator|)
operator|.
name|getMaximum
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|index
operator|instanceof
name|BooleanColumnStatistics
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|BooleanColumnStatistics
operator|)
name|index
operator|)
operator|.
name|getTrueCount
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
name|Boolean
operator|.
name|TRUE
return|;
block|}
else|else
block|{
return|return
name|Boolean
operator|.
name|FALSE
return|;
block|}
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Get the minimum value out of an index entry.    * @param index    *          the index entry    * @return the object for the minimum value or null if there isn't one    */
specifier|static
name|Object
name|getMin
parameter_list|(
name|ColumnStatistics
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|instanceof
name|IntegerColumnStatistics
condition|)
block|{
return|return
operator|(
operator|(
name|IntegerColumnStatistics
operator|)
name|index
operator|)
operator|.
name|getMinimum
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|index
operator|instanceof
name|DoubleColumnStatistics
condition|)
block|{
return|return
operator|(
operator|(
name|DoubleColumnStatistics
operator|)
name|index
operator|)
operator|.
name|getMinimum
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|index
operator|instanceof
name|StringColumnStatistics
condition|)
block|{
return|return
operator|(
operator|(
name|StringColumnStatistics
operator|)
name|index
operator|)
operator|.
name|getMinimum
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|index
operator|instanceof
name|DateColumnStatistics
condition|)
block|{
return|return
operator|(
operator|(
name|DateColumnStatistics
operator|)
name|index
operator|)
operator|.
name|getMinimum
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|index
operator|instanceof
name|DecimalColumnStatistics
condition|)
block|{
return|return
operator|(
operator|(
name|DecimalColumnStatistics
operator|)
name|index
operator|)
operator|.
name|getMinimum
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|index
operator|instanceof
name|TimestampColumnStatistics
condition|)
block|{
return|return
operator|(
operator|(
name|TimestampColumnStatistics
operator|)
name|index
operator|)
operator|.
name|getMinimum
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|index
operator|instanceof
name|BooleanColumnStatistics
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|BooleanColumnStatistics
operator|)
name|index
operator|)
operator|.
name|getFalseCount
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
name|Boolean
operator|.
name|FALSE
return|;
block|}
else|else
block|{
return|return
name|Boolean
operator|.
name|TRUE
return|;
block|}
block|}
else|else
block|{
return|return
name|UNKNOWN_VALUE
return|;
comment|// null is not safe here
block|}
block|}
comment|/**    * Evaluate a predicate with respect to the statistics from the column    * that is referenced in the predicate.    * @param statsProto the statistics for the column mentioned in the predicate    * @param predicate the leaf predicate we need to evaluation    * @param bloomFilter    * @return the set of truth values that may be returned for the given    *   predicate.    */
specifier|static
name|TruthValue
name|evaluatePredicateProto
parameter_list|(
name|OrcProto
operator|.
name|ColumnStatistics
name|statsProto
parameter_list|,
name|PredicateLeaf
name|predicate
parameter_list|,
name|OrcProto
operator|.
name|BloomFilter
name|bloomFilter
parameter_list|)
block|{
name|ColumnStatistics
name|cs
init|=
name|ColumnStatisticsImpl
operator|.
name|deserialize
argument_list|(
name|statsProto
argument_list|)
decl_stmt|;
name|Object
name|minValue
init|=
name|getMin
argument_list|(
name|cs
argument_list|)
decl_stmt|;
name|Object
name|maxValue
init|=
name|getMax
argument_list|(
name|cs
argument_list|)
decl_stmt|;
name|BloomFilterIO
name|bf
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|bloomFilter
operator|!=
literal|null
condition|)
block|{
name|bf
operator|=
operator|new
name|BloomFilterIO
argument_list|(
name|bloomFilter
argument_list|)
expr_stmt|;
block|}
return|return
name|evaluatePredicateRange
argument_list|(
name|predicate
argument_list|,
name|minValue
argument_list|,
name|maxValue
argument_list|,
name|cs
operator|.
name|hasNull
argument_list|()
argument_list|,
name|bf
argument_list|)
return|;
block|}
comment|/**    * Evaluate a predicate with respect to the statistics from the column    * that is referenced in the predicate.    * @param stats the statistics for the column mentioned in the predicate    * @param predicate the leaf predicate we need to evaluation    * @return the set of truth values that may be returned for the given    *   predicate.    */
specifier|public
specifier|static
name|TruthValue
name|evaluatePredicate
parameter_list|(
name|ColumnStatistics
name|stats
parameter_list|,
name|PredicateLeaf
name|predicate
parameter_list|,
name|BloomFilterIO
name|bloomFilter
parameter_list|)
block|{
name|Object
name|minValue
init|=
name|getMin
argument_list|(
name|stats
argument_list|)
decl_stmt|;
name|Object
name|maxValue
init|=
name|getMax
argument_list|(
name|stats
argument_list|)
decl_stmt|;
return|return
name|evaluatePredicateRange
argument_list|(
name|predicate
argument_list|,
name|minValue
argument_list|,
name|maxValue
argument_list|,
name|stats
operator|.
name|hasNull
argument_list|()
argument_list|,
name|bloomFilter
argument_list|)
return|;
block|}
specifier|static
name|TruthValue
name|evaluatePredicateRange
parameter_list|(
name|PredicateLeaf
name|predicate
parameter_list|,
name|Object
name|min
parameter_list|,
name|Object
name|max
parameter_list|,
name|boolean
name|hasNull
parameter_list|,
name|BloomFilterIO
name|bloomFilter
parameter_list|)
block|{
comment|// if we didn't have any values, everything must have been null
if|if
condition|(
name|min
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|predicate
operator|.
name|getOperator
argument_list|()
operator|==
name|PredicateLeaf
operator|.
name|Operator
operator|.
name|IS_NULL
condition|)
block|{
return|return
name|TruthValue
operator|.
name|YES
return|;
block|}
else|else
block|{
return|return
name|TruthValue
operator|.
name|NULL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|min
operator|==
name|UNKNOWN_VALUE
condition|)
block|{
return|return
name|TruthValue
operator|.
name|YES_NO_NULL
return|;
block|}
name|TruthValue
name|result
decl_stmt|;
name|Object
name|baseObj
init|=
name|predicate
operator|.
name|getLiteral
argument_list|()
decl_stmt|;
try|try
block|{
comment|// Predicate object and stats objects are converted to the type of the predicate object.
name|Object
name|minValue
init|=
name|getBaseObjectForComparison
argument_list|(
name|predicate
operator|.
name|getType
argument_list|()
argument_list|,
name|min
argument_list|)
decl_stmt|;
name|Object
name|maxValue
init|=
name|getBaseObjectForComparison
argument_list|(
name|predicate
operator|.
name|getType
argument_list|()
argument_list|,
name|max
argument_list|)
decl_stmt|;
name|Object
name|predObj
init|=
name|getBaseObjectForComparison
argument_list|(
name|predicate
operator|.
name|getType
argument_list|()
argument_list|,
name|baseObj
argument_list|)
decl_stmt|;
name|result
operator|=
name|evaluatePredicateMinMax
argument_list|(
name|predicate
argument_list|,
name|predObj
argument_list|,
name|minValue
argument_list|,
name|maxValue
argument_list|,
name|hasNull
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldEvaluateBloomFilter
argument_list|(
name|predicate
argument_list|,
name|result
argument_list|,
name|bloomFilter
argument_list|)
condition|)
block|{
name|result
operator|=
name|evaluatePredicateBloomFilter
argument_list|(
name|predicate
argument_list|,
name|predObj
argument_list|,
name|bloomFilter
argument_list|,
name|hasNull
argument_list|)
expr_stmt|;
block|}
comment|// in case failed conversion, return the default YES_NO_NULL truth value
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isWarnEnabled
argument_list|()
condition|)
block|{
specifier|final
name|String
name|statsType
init|=
name|min
operator|==
literal|null
condition|?
operator|(
name|max
operator|==
literal|null
condition|?
literal|"null"
else|:
name|max
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|)
else|:
name|min
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
decl_stmt|;
specifier|final
name|String
name|predicateType
init|=
name|baseObj
operator|==
literal|null
condition|?
literal|"null"
else|:
name|baseObj
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
decl_stmt|;
specifier|final
name|String
name|reason
init|=
name|e
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" when evaluating predicate."
operator|+
literal|" Skipping ORC PPD."
operator|+
literal|" Exception: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
operator|+
literal|" StatsType: "
operator|+
name|statsType
operator|+
literal|" PredicateType: "
operator|+
name|predicateType
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|reason
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|reason
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|predicate
operator|.
name|getOperator
argument_list|()
operator|.
name|equals
argument_list|(
name|PredicateLeaf
operator|.
name|Operator
operator|.
name|NULL_SAFE_EQUALS
argument_list|)
operator|||
operator|!
name|hasNull
condition|)
block|{
name|result
operator|=
name|TruthValue
operator|.
name|YES_NO
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|TruthValue
operator|.
name|YES_NO_NULL
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
specifier|private
specifier|static
name|boolean
name|shouldEvaluateBloomFilter
parameter_list|(
name|PredicateLeaf
name|predicate
parameter_list|,
name|TruthValue
name|result
parameter_list|,
name|BloomFilterIO
name|bloomFilter
parameter_list|)
block|{
comment|// evaluate bloom filter only when
comment|// 1) Bloom filter is available
comment|// 2) Min/Max evaluation yield YES or MAYBE
comment|// 3) Predicate is EQUALS or IN list
if|if
condition|(
name|bloomFilter
operator|!=
literal|null
operator|&&
name|result
operator|!=
name|TruthValue
operator|.
name|NO_NULL
operator|&&
name|result
operator|!=
name|TruthValue
operator|.
name|NO
operator|&&
operator|(
name|predicate
operator|.
name|getOperator
argument_list|()
operator|.
name|equals
argument_list|(
name|PredicateLeaf
operator|.
name|Operator
operator|.
name|EQUALS
argument_list|)
operator|||
name|predicate
operator|.
name|getOperator
argument_list|()
operator|.
name|equals
argument_list|(
name|PredicateLeaf
operator|.
name|Operator
operator|.
name|NULL_SAFE_EQUALS
argument_list|)
operator|||
name|predicate
operator|.
name|getOperator
argument_list|()
operator|.
name|equals
argument_list|(
name|PredicateLeaf
operator|.
name|Operator
operator|.
name|IN
argument_list|)
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
specifier|static
name|TruthValue
name|evaluatePredicateMinMax
parameter_list|(
name|PredicateLeaf
name|predicate
parameter_list|,
name|Object
name|predObj
parameter_list|,
name|Object
name|minValue
parameter_list|,
name|Object
name|maxValue
parameter_list|,
name|boolean
name|hasNull
parameter_list|)
block|{
name|Location
name|loc
decl_stmt|;
switch|switch
condition|(
name|predicate
operator|.
name|getOperator
argument_list|()
condition|)
block|{
case|case
name|NULL_SAFE_EQUALS
case|:
name|loc
operator|=
name|compareToRange
argument_list|(
operator|(
name|Comparable
operator|)
name|predObj
argument_list|,
name|minValue
argument_list|,
name|maxValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
name|Location
operator|.
name|BEFORE
operator|||
name|loc
operator|==
name|Location
operator|.
name|AFTER
condition|)
block|{
return|return
name|TruthValue
operator|.
name|NO
return|;
block|}
else|else
block|{
return|return
name|TruthValue
operator|.
name|YES_NO
return|;
block|}
case|case
name|EQUALS
case|:
name|loc
operator|=
name|compareToRange
argument_list|(
operator|(
name|Comparable
operator|)
name|predObj
argument_list|,
name|minValue
argument_list|,
name|maxValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|minValue
operator|.
name|equals
argument_list|(
name|maxValue
argument_list|)
operator|&&
name|loc
operator|==
name|Location
operator|.
name|MIN
condition|)
block|{
return|return
name|hasNull
condition|?
name|TruthValue
operator|.
name|YES_NULL
else|:
name|TruthValue
operator|.
name|YES
return|;
block|}
elseif|else
if|if
condition|(
name|loc
operator|==
name|Location
operator|.
name|BEFORE
operator|||
name|loc
operator|==
name|Location
operator|.
name|AFTER
condition|)
block|{
return|return
name|hasNull
condition|?
name|TruthValue
operator|.
name|NO_NULL
else|:
name|TruthValue
operator|.
name|NO
return|;
block|}
else|else
block|{
return|return
name|hasNull
condition|?
name|TruthValue
operator|.
name|YES_NO_NULL
else|:
name|TruthValue
operator|.
name|YES_NO
return|;
block|}
case|case
name|LESS_THAN
case|:
name|loc
operator|=
name|compareToRange
argument_list|(
operator|(
name|Comparable
operator|)
name|predObj
argument_list|,
name|minValue
argument_list|,
name|maxValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
name|Location
operator|.
name|AFTER
condition|)
block|{
return|return
name|hasNull
condition|?
name|TruthValue
operator|.
name|YES_NULL
else|:
name|TruthValue
operator|.
name|YES
return|;
block|}
elseif|else
if|if
condition|(
name|loc
operator|==
name|Location
operator|.
name|BEFORE
operator|||
name|loc
operator|==
name|Location
operator|.
name|MIN
condition|)
block|{
return|return
name|hasNull
condition|?
name|TruthValue
operator|.
name|NO_NULL
else|:
name|TruthValue
operator|.
name|NO
return|;
block|}
else|else
block|{
return|return
name|hasNull
condition|?
name|TruthValue
operator|.
name|YES_NO_NULL
else|:
name|TruthValue
operator|.
name|YES_NO
return|;
block|}
case|case
name|LESS_THAN_EQUALS
case|:
name|loc
operator|=
name|compareToRange
argument_list|(
operator|(
name|Comparable
operator|)
name|predObj
argument_list|,
name|minValue
argument_list|,
name|maxValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
name|Location
operator|.
name|AFTER
operator|||
name|loc
operator|==
name|Location
operator|.
name|MAX
condition|)
block|{
return|return
name|hasNull
condition|?
name|TruthValue
operator|.
name|YES_NULL
else|:
name|TruthValue
operator|.
name|YES
return|;
block|}
elseif|else
if|if
condition|(
name|loc
operator|==
name|Location
operator|.
name|BEFORE
condition|)
block|{
return|return
name|hasNull
condition|?
name|TruthValue
operator|.
name|NO_NULL
else|:
name|TruthValue
operator|.
name|NO
return|;
block|}
else|else
block|{
return|return
name|hasNull
condition|?
name|TruthValue
operator|.
name|YES_NO_NULL
else|:
name|TruthValue
operator|.
name|YES_NO
return|;
block|}
case|case
name|IN
case|:
if|if
condition|(
name|minValue
operator|.
name|equals
argument_list|(
name|maxValue
argument_list|)
condition|)
block|{
comment|// for a single value, look through to see if that value is in the
comment|// set
for|for
control|(
name|Object
name|arg
range|:
name|predicate
operator|.
name|getLiteralList
argument_list|()
control|)
block|{
name|predObj
operator|=
name|getBaseObjectForComparison
argument_list|(
name|predicate
operator|.
name|getType
argument_list|()
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|loc
operator|=
name|compareToRange
argument_list|(
operator|(
name|Comparable
operator|)
name|predObj
argument_list|,
name|minValue
argument_list|,
name|maxValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
name|Location
operator|.
name|MIN
condition|)
block|{
return|return
name|hasNull
condition|?
name|TruthValue
operator|.
name|YES_NULL
else|:
name|TruthValue
operator|.
name|YES
return|;
block|}
block|}
return|return
name|hasNull
condition|?
name|TruthValue
operator|.
name|NO_NULL
else|:
name|TruthValue
operator|.
name|NO
return|;
block|}
else|else
block|{
comment|// are all of the values outside of the range?
for|for
control|(
name|Object
name|arg
range|:
name|predicate
operator|.
name|getLiteralList
argument_list|()
control|)
block|{
name|predObj
operator|=
name|getBaseObjectForComparison
argument_list|(
name|predicate
operator|.
name|getType
argument_list|()
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|loc
operator|=
name|compareToRange
argument_list|(
operator|(
name|Comparable
operator|)
name|predObj
argument_list|,
name|minValue
argument_list|,
name|maxValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
name|Location
operator|.
name|MIN
operator|||
name|loc
operator|==
name|Location
operator|.
name|MIDDLE
operator|||
name|loc
operator|==
name|Location
operator|.
name|MAX
condition|)
block|{
return|return
name|hasNull
condition|?
name|TruthValue
operator|.
name|YES_NO_NULL
else|:
name|TruthValue
operator|.
name|YES_NO
return|;
block|}
block|}
return|return
name|hasNull
condition|?
name|TruthValue
operator|.
name|NO_NULL
else|:
name|TruthValue
operator|.
name|NO
return|;
block|}
case|case
name|BETWEEN
case|:
name|List
argument_list|<
name|Object
argument_list|>
name|args
init|=
name|predicate
operator|.
name|getLiteralList
argument_list|()
decl_stmt|;
name|Object
name|predObj1
init|=
name|getBaseObjectForComparison
argument_list|(
name|predicate
operator|.
name|getType
argument_list|()
argument_list|,
name|args
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|loc
operator|=
name|compareToRange
argument_list|(
operator|(
name|Comparable
operator|)
name|predObj1
argument_list|,
name|minValue
argument_list|,
name|maxValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
name|Location
operator|.
name|BEFORE
operator|||
name|loc
operator|==
name|Location
operator|.
name|MIN
condition|)
block|{
name|Object
name|predObj2
init|=
name|getBaseObjectForComparison
argument_list|(
name|predicate
operator|.
name|getType
argument_list|()
argument_list|,
name|args
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|Location
name|loc2
init|=
name|compareToRange
argument_list|(
operator|(
name|Comparable
operator|)
name|predObj2
argument_list|,
name|minValue
argument_list|,
name|maxValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|loc2
operator|==
name|Location
operator|.
name|AFTER
operator|||
name|loc2
operator|==
name|Location
operator|.
name|MAX
condition|)
block|{
return|return
name|hasNull
condition|?
name|TruthValue
operator|.
name|YES_NULL
else|:
name|TruthValue
operator|.
name|YES
return|;
block|}
elseif|else
if|if
condition|(
name|loc2
operator|==
name|Location
operator|.
name|BEFORE
condition|)
block|{
return|return
name|hasNull
condition|?
name|TruthValue
operator|.
name|NO_NULL
else|:
name|TruthValue
operator|.
name|NO
return|;
block|}
else|else
block|{
return|return
name|hasNull
condition|?
name|TruthValue
operator|.
name|YES_NO_NULL
else|:
name|TruthValue
operator|.
name|YES_NO
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|loc
operator|==
name|Location
operator|.
name|AFTER
condition|)
block|{
return|return
name|hasNull
condition|?
name|TruthValue
operator|.
name|NO_NULL
else|:
name|TruthValue
operator|.
name|NO
return|;
block|}
else|else
block|{
return|return
name|hasNull
condition|?
name|TruthValue
operator|.
name|YES_NO_NULL
else|:
name|TruthValue
operator|.
name|YES_NO
return|;
block|}
case|case
name|IS_NULL
case|:
comment|// min = null condition above handles the all-nulls YES case
return|return
name|hasNull
condition|?
name|TruthValue
operator|.
name|YES_NO
else|:
name|TruthValue
operator|.
name|NO
return|;
default|default:
return|return
name|hasNull
condition|?
name|TruthValue
operator|.
name|YES_NO_NULL
else|:
name|TruthValue
operator|.
name|YES_NO
return|;
block|}
block|}
specifier|private
specifier|static
name|TruthValue
name|evaluatePredicateBloomFilter
parameter_list|(
name|PredicateLeaf
name|predicate
parameter_list|,
specifier|final
name|Object
name|predObj
parameter_list|,
name|BloomFilterIO
name|bloomFilter
parameter_list|,
name|boolean
name|hasNull
parameter_list|)
block|{
switch|switch
condition|(
name|predicate
operator|.
name|getOperator
argument_list|()
condition|)
block|{
case|case
name|NULL_SAFE_EQUALS
case|:
comment|// null safe equals does not return *_NULL variant. So set hasNull to false
return|return
name|checkInBloomFilter
argument_list|(
name|bloomFilter
argument_list|,
name|predObj
argument_list|,
literal|false
argument_list|)
return|;
case|case
name|EQUALS
case|:
return|return
name|checkInBloomFilter
argument_list|(
name|bloomFilter
argument_list|,
name|predObj
argument_list|,
name|hasNull
argument_list|)
return|;
case|case
name|IN
case|:
for|for
control|(
name|Object
name|arg
range|:
name|predicate
operator|.
name|getLiteralList
argument_list|()
control|)
block|{
comment|// if atleast one value in IN list exist in bloom filter, qualify the row group/stripe
name|Object
name|predObjItem
init|=
name|getBaseObjectForComparison
argument_list|(
name|predicate
operator|.
name|getType
argument_list|()
argument_list|,
name|arg
argument_list|)
decl_stmt|;
name|TruthValue
name|result
init|=
name|checkInBloomFilter
argument_list|(
name|bloomFilter
argument_list|,
name|predObjItem
argument_list|,
name|hasNull
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|TruthValue
operator|.
name|YES_NO_NULL
operator|||
name|result
operator|==
name|TruthValue
operator|.
name|YES_NO
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
return|return
name|hasNull
condition|?
name|TruthValue
operator|.
name|NO_NULL
else|:
name|TruthValue
operator|.
name|NO
return|;
default|default:
return|return
name|hasNull
condition|?
name|TruthValue
operator|.
name|YES_NO_NULL
else|:
name|TruthValue
operator|.
name|YES_NO
return|;
block|}
block|}
specifier|private
specifier|static
name|TruthValue
name|checkInBloomFilter
parameter_list|(
name|BloomFilterIO
name|bf
parameter_list|,
name|Object
name|predObj
parameter_list|,
name|boolean
name|hasNull
parameter_list|)
block|{
name|TruthValue
name|result
init|=
name|hasNull
condition|?
name|TruthValue
operator|.
name|NO_NULL
else|:
name|TruthValue
operator|.
name|NO
decl_stmt|;
if|if
condition|(
name|predObj
operator|instanceof
name|Long
condition|)
block|{
if|if
condition|(
name|bf
operator|.
name|testLong
argument_list|(
operator|(
operator|(
name|Long
operator|)
name|predObj
operator|)
operator|.
name|longValue
argument_list|()
argument_list|)
condition|)
block|{
name|result
operator|=
name|TruthValue
operator|.
name|YES_NO_NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|predObj
operator|instanceof
name|Double
condition|)
block|{
if|if
condition|(
name|bf
operator|.
name|testDouble
argument_list|(
operator|(
operator|(
name|Double
operator|)
name|predObj
operator|)
operator|.
name|doubleValue
argument_list|()
argument_list|)
condition|)
block|{
name|result
operator|=
name|TruthValue
operator|.
name|YES_NO_NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|predObj
operator|instanceof
name|String
operator|||
name|predObj
operator|instanceof
name|Text
operator|||
name|predObj
operator|instanceof
name|HiveDecimalWritable
operator|||
name|predObj
operator|instanceof
name|BigDecimal
condition|)
block|{
if|if
condition|(
name|bf
operator|.
name|testString
argument_list|(
name|predObj
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|result
operator|=
name|TruthValue
operator|.
name|YES_NO_NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|predObj
operator|instanceof
name|Timestamp
condition|)
block|{
if|if
condition|(
name|bf
operator|.
name|testLong
argument_list|(
operator|(
operator|(
name|Timestamp
operator|)
name|predObj
operator|)
operator|.
name|getTime
argument_list|()
argument_list|)
condition|)
block|{
name|result
operator|=
name|TruthValue
operator|.
name|YES_NO_NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|predObj
operator|instanceof
name|Date
condition|)
block|{
if|if
condition|(
name|bf
operator|.
name|testLong
argument_list|(
name|DateWritable
operator|.
name|dateToDays
argument_list|(
operator|(
name|Date
operator|)
name|predObj
argument_list|)
argument_list|)
condition|)
block|{
name|result
operator|=
name|TruthValue
operator|.
name|YES_NO_NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// if the predicate object is null and if hasNull says there are no nulls then return NO
if|if
condition|(
name|predObj
operator|==
literal|null
operator|&&
operator|!
name|hasNull
condition|)
block|{
name|result
operator|=
name|TruthValue
operator|.
name|NO
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|TruthValue
operator|.
name|YES_NO_NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|==
name|TruthValue
operator|.
name|YES_NO_NULL
operator|&&
operator|!
name|hasNull
condition|)
block|{
name|result
operator|=
name|TruthValue
operator|.
name|YES_NO
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Bloom filter evaluation: "
operator|+
name|result
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|private
specifier|static
name|Object
name|getBaseObjectForComparison
parameter_list|(
name|PredicateLeaf
operator|.
name|Type
name|type
parameter_list|,
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BOOLEAN
case|:
if|if
condition|(
name|obj
operator|instanceof
name|Boolean
condition|)
block|{
return|return
name|obj
return|;
block|}
else|else
block|{
comment|// will only be true if the string conversion yields "true", all other values are
comment|// considered false
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|obj
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
case|case
name|DATE
case|:
if|if
condition|(
name|obj
operator|instanceof
name|Date
condition|)
block|{
return|return
name|obj
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|String
condition|)
block|{
return|return
name|Date
operator|.
name|valueOf
argument_list|(
operator|(
name|String
operator|)
name|obj
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Timestamp
condition|)
block|{
return|return
name|DateWritable
operator|.
name|timeToDate
argument_list|(
operator|(
operator|(
name|Timestamp
operator|)
name|obj
operator|)
operator|.
name|getTime
argument_list|()
operator|/
literal|1000L
argument_list|)
return|;
block|}
comment|// always string, but prevent the comparison to numbers (are they days/seconds/milliseconds?)
break|break;
case|case
name|DECIMAL
case|:
if|if
condition|(
name|obj
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|new
name|HiveDecimalWritable
argument_list|(
operator|(
operator|(
name|Boolean
operator|)
name|obj
operator|)
operator|.
name|booleanValue
argument_list|()
condition|?
name|HiveDecimal
operator|.
name|ONE
else|:
name|HiveDecimal
operator|.
name|ZERO
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Integer
condition|)
block|{
return|return
operator|new
name|HiveDecimalWritable
argument_list|(
operator|(
operator|(
name|Integer
operator|)
name|obj
operator|)
operator|.
name|intValue
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|new
name|HiveDecimalWritable
argument_list|(
operator|(
operator|(
name|Long
operator|)
name|obj
operator|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Float
operator|||
name|obj
operator|instanceof
name|Double
operator|||
name|obj
operator|instanceof
name|String
condition|)
block|{
return|return
operator|new
name|HiveDecimalWritable
argument_list|(
name|obj
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|BigDecimal
condition|)
block|{
return|return
operator|new
name|HiveDecimalWritable
argument_list|(
name|HiveDecimal
operator|.
name|create
argument_list|(
operator|(
name|BigDecimal
operator|)
name|obj
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|HiveDecimal
condition|)
block|{
return|return
operator|new
name|HiveDecimalWritable
argument_list|(
operator|(
name|HiveDecimal
operator|)
name|obj
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|HiveDecimalWritable
condition|)
block|{
return|return
name|obj
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Timestamp
condition|)
block|{
return|return
operator|new
name|HiveDecimalWritable
argument_list|(
name|Double
operator|.
name|toString
argument_list|(
name|TimestampUtils
operator|.
name|getDouble
argument_list|(
operator|(
name|Timestamp
operator|)
name|obj
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|FLOAT
case|:
if|if
condition|(
name|obj
operator|instanceof
name|Number
condition|)
block|{
comment|// widening conversion
return|return
operator|(
operator|(
name|Number
operator|)
name|obj
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|HiveDecimal
condition|)
block|{
return|return
operator|(
operator|(
name|HiveDecimal
operator|)
name|obj
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|String
condition|)
block|{
return|return
name|Double
operator|.
name|valueOf
argument_list|(
name|obj
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Timestamp
condition|)
block|{
return|return
name|TimestampUtils
operator|.
name|getDouble
argument_list|(
operator|(
name|Timestamp
operator|)
name|obj
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|HiveDecimal
condition|)
block|{
return|return
operator|(
operator|(
name|HiveDecimal
operator|)
name|obj
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|BigDecimal
condition|)
block|{
return|return
operator|(
operator|(
name|BigDecimal
operator|)
name|obj
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
break|break;
case|case
name|LONG
case|:
if|if
condition|(
name|obj
operator|instanceof
name|Number
condition|)
block|{
comment|// widening conversion
return|return
operator|(
operator|(
name|Number
operator|)
name|obj
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|HiveDecimal
condition|)
block|{
return|return
operator|(
operator|(
name|HiveDecimal
operator|)
name|obj
operator|)
operator|.
name|longValue
argument_list|()
return|;
comment|// TODO: lossy conversion!
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|String
condition|)
block|{
return|return
name|Long
operator|.
name|valueOf
argument_list|(
name|obj
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
break|break;
case|case
name|STRING
case|:
if|if
condition|(
name|obj
operator|!=
literal|null
condition|)
block|{
return|return
operator|(
name|obj
operator|.
name|toString
argument_list|()
operator|)
return|;
block|}
break|break;
case|case
name|TIMESTAMP
case|:
if|if
condition|(
name|obj
operator|instanceof
name|Timestamp
condition|)
block|{
return|return
name|obj
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Integer
condition|)
block|{
return|return
operator|new
name|Timestamp
argument_list|(
operator|(
operator|(
name|Number
operator|)
name|obj
operator|)
operator|.
name|longValue
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Float
condition|)
block|{
return|return
name|TimestampUtils
operator|.
name|doubleToTimestamp
argument_list|(
operator|(
operator|(
name|Float
operator|)
name|obj
operator|)
operator|.
name|doubleValue
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Double
condition|)
block|{
return|return
name|TimestampUtils
operator|.
name|doubleToTimestamp
argument_list|(
operator|(
operator|(
name|Double
operator|)
name|obj
operator|)
operator|.
name|doubleValue
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|HiveDecimal
condition|)
block|{
return|return
name|TimestampUtils
operator|.
name|decimalToTimestamp
argument_list|(
operator|(
name|HiveDecimal
operator|)
name|obj
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|HiveDecimalWritable
condition|)
block|{
return|return
name|TimestampUtils
operator|.
name|decimalToTimestamp
argument_list|(
operator|(
operator|(
name|HiveDecimalWritable
operator|)
name|obj
operator|)
operator|.
name|getHiveDecimal
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Date
condition|)
block|{
return|return
operator|new
name|Timestamp
argument_list|(
operator|(
operator|(
name|Date
operator|)
name|obj
operator|)
operator|.
name|getTime
argument_list|()
argument_list|)
return|;
block|}
comment|// float/double conversion to timestamp is interpreted as seconds whereas integer conversion
comment|// to timestamp is interpreted as milliseconds by default. The integer to timestamp casting
comment|// is also config driven. The filter operator changes its promotion based on config:
comment|// "int.timestamp.conversion.in.seconds". Disable PPD for integer cases.
break|break;
default|default:
break|break;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"ORC SARGS could not convert from %s to %s"
argument_list|,
name|obj
operator|==
literal|null
condition|?
literal|"(null)"
else|:
name|obj
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|type
argument_list|)
argument_list|)
throw|;
block|}
specifier|public
specifier|static
class|class
name|SargApplier
block|{
specifier|public
specifier|final
specifier|static
name|boolean
index|[]
name|READ_ALL_RGS
init|=
literal|null
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|boolean
index|[]
name|READ_NO_RGS
init|=
operator|new
name|boolean
index|[
literal|0
index|]
decl_stmt|;
specifier|private
specifier|final
name|SearchArgument
name|sarg
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|PredicateLeaf
argument_list|>
name|sargLeaves
decl_stmt|;
specifier|private
specifier|final
name|int
index|[]
name|filterColumns
decl_stmt|;
specifier|private
specifier|final
name|long
name|rowIndexStride
decl_stmt|;
comment|// same as the above array, but indices are set to true
specifier|private
specifier|final
name|boolean
index|[]
name|sargColumns
decl_stmt|;
specifier|private
name|SchemaEvolution
name|evolution
decl_stmt|;
specifier|public
name|SargApplier
parameter_list|(
name|SearchArgument
name|sarg
parameter_list|,
name|String
index|[]
name|columnNames
parameter_list|,
name|long
name|rowIndexStride
parameter_list|,
name|int
name|includedCount
parameter_list|,
specifier|final
name|SchemaEvolution
name|evolution
parameter_list|)
block|{
name|this
operator|.
name|sarg
operator|=
name|sarg
expr_stmt|;
name|sargLeaves
operator|=
name|sarg
operator|.
name|getLeaves
argument_list|()
expr_stmt|;
name|filterColumns
operator|=
name|mapSargColumnsToOrcInternalColIdx
argument_list|(
name|sargLeaves
argument_list|,
name|columnNames
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|rowIndexStride
operator|=
name|rowIndexStride
expr_stmt|;
comment|// included will not be null, row options will fill the array with trues if null
name|sargColumns
operator|=
operator|new
name|boolean
index|[
name|includedCount
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
range|:
name|filterColumns
control|)
block|{
comment|// filter columns may have -1 as index which could be partition column in SARG.
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|sargColumns
index|[
name|i
index|]
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|this
operator|.
name|evolution
operator|=
name|evolution
expr_stmt|;
block|}
comment|/**      * Pick the row groups that we need to load from the current stripe.      *      * @return an array with a boolean for each row group or null if all of the      * row groups must be read.      * @throws IOException      */
specifier|public
name|boolean
index|[]
name|pickRowGroups
parameter_list|(
name|StripeInformation
name|stripe
parameter_list|,
name|OrcProto
operator|.
name|RowIndex
index|[]
name|indexes
parameter_list|,
name|OrcProto
operator|.
name|BloomFilterIndex
index|[]
name|bloomFilterIndices
parameter_list|,
name|boolean
name|returnNone
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|rowsInStripe
init|=
name|stripe
operator|.
name|getNumberOfRows
argument_list|()
decl_stmt|;
name|int
name|groupsInStripe
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|rowsInStripe
operator|+
name|rowIndexStride
operator|-
literal|1
operator|)
operator|/
name|rowIndexStride
argument_list|)
decl_stmt|;
name|boolean
index|[]
name|result
init|=
operator|new
name|boolean
index|[
name|groupsInStripe
index|]
decl_stmt|;
comment|// TODO: avoid alloc?
name|TruthValue
index|[]
name|leafValues
init|=
operator|new
name|TruthValue
index|[
name|sargLeaves
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|boolean
name|hasSelected
init|=
literal|false
decl_stmt|,
name|hasSkipped
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|rowGroup
init|=
literal|0
init|;
name|rowGroup
operator|<
name|result
operator|.
name|length
condition|;
operator|++
name|rowGroup
control|)
block|{
for|for
control|(
name|int
name|pred
init|=
literal|0
init|;
name|pred
operator|<
name|leafValues
operator|.
name|length
condition|;
operator|++
name|pred
control|)
block|{
name|int
name|columnIx
init|=
name|filterColumns
index|[
name|pred
index|]
decl_stmt|;
if|if
condition|(
name|columnIx
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|indexes
index|[
name|columnIx
index|]
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Index is not populated for "
operator|+
name|columnIx
argument_list|)
throw|;
block|}
name|OrcProto
operator|.
name|RowIndexEntry
name|entry
init|=
name|indexes
index|[
name|columnIx
index|]
operator|.
name|getEntry
argument_list|(
name|rowGroup
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"RG is not populated for "
operator|+
name|columnIx
operator|+
literal|" rg "
operator|+
name|rowGroup
argument_list|)
throw|;
block|}
name|OrcProto
operator|.
name|ColumnStatistics
name|stats
init|=
name|entry
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
name|OrcProto
operator|.
name|BloomFilter
name|bf
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|bloomFilterIndices
operator|!=
literal|null
operator|&&
name|bloomFilterIndices
index|[
name|columnIx
index|]
operator|!=
literal|null
condition|)
block|{
name|bf
operator|=
name|bloomFilterIndices
index|[
name|columnIx
index|]
operator|.
name|getBloomFilter
argument_list|(
name|rowGroup
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|evolution
operator|!=
literal|null
operator|&&
name|evolution
operator|.
name|isPPDSafeConversion
argument_list|(
name|columnIx
argument_list|)
condition|)
block|{
name|leafValues
index|[
name|pred
index|]
operator|=
name|evaluatePredicateProto
argument_list|(
name|stats
argument_list|,
name|sargLeaves
operator|.
name|get
argument_list|(
name|pred
argument_list|)
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|leafValues
index|[
name|pred
index|]
operator|=
name|TruthValue
operator|.
name|YES_NO_NULL
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Stats = "
operator|+
name|stats
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Setting "
operator|+
name|sargLeaves
operator|.
name|get
argument_list|(
name|pred
argument_list|)
operator|+
literal|" to "
operator|+
name|leafValues
index|[
name|pred
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// the column is a virtual column
name|leafValues
index|[
name|pred
index|]
operator|=
name|TruthValue
operator|.
name|YES_NO_NULL
expr_stmt|;
block|}
block|}
name|result
index|[
name|rowGroup
index|]
operator|=
name|sarg
operator|.
name|evaluate
argument_list|(
name|leafValues
argument_list|)
operator|.
name|isNeeded
argument_list|()
expr_stmt|;
name|hasSelected
operator|=
name|hasSelected
operator|||
name|result
index|[
name|rowGroup
index|]
expr_stmt|;
name|hasSkipped
operator|=
name|hasSkipped
operator|||
operator|(
operator|!
name|result
index|[
name|rowGroup
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Row group "
operator|+
operator|(
name|rowIndexStride
operator|*
name|rowGroup
operator|)
operator|+
literal|" to "
operator|+
operator|(
name|rowIndexStride
operator|*
operator|(
name|rowGroup
operator|+
literal|1
operator|)
operator|-
literal|1
operator|)
operator|+
literal|" is "
operator|+
operator|(
name|result
index|[
name|rowGroup
index|]
condition|?
literal|""
else|:
literal|"not "
operator|)
operator|+
literal|"included."
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|hasSkipped
condition|?
operator|(
operator|(
name|hasSelected
operator|||
operator|!
name|returnNone
operator|)
condition|?
name|result
else|:
name|READ_NO_RGS
operator|)
else|:
name|READ_ALL_RGS
return|;
block|}
block|}
comment|/**    * Pick the row groups that we need to load from the current stripe.    *    * @return an array with a boolean for each row group or null if all of the    * row groups must be read.    * @throws IOException    */
specifier|protected
name|boolean
index|[]
name|pickRowGroups
parameter_list|()
throws|throws
name|IOException
block|{
comment|// if we don't have a sarg or indexes, we read everything
if|if
condition|(
name|sargApp
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|readRowIndex
argument_list|(
name|currentStripe
argument_list|,
name|included
argument_list|,
name|sargApp
operator|.
name|sargColumns
argument_list|)
expr_stmt|;
return|return
name|sargApp
operator|.
name|pickRowGroups
argument_list|(
name|stripes
operator|.
name|get
argument_list|(
name|currentStripe
argument_list|)
argument_list|,
name|indexes
argument_list|,
name|bloomFilterIndices
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|private
name|void
name|clearStreams
parameter_list|()
block|{
comment|// explicit close of all streams to de-ref ByteBuffers
for|for
control|(
name|InStream
name|is
range|:
name|streams
operator|.
name|values
argument_list|()
control|)
block|{
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bufferChunks
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|dataReader
operator|.
name|isTrackingDiskRanges
argument_list|()
condition|)
block|{
for|for
control|(
name|DiskRangeList
name|range
init|=
name|bufferChunks
init|;
name|range
operator|!=
literal|null
condition|;
name|range
operator|=
name|range
operator|.
name|next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|range
operator|instanceof
name|BufferChunk
operator|)
condition|)
block|{
continue|continue;
block|}
name|dataReader
operator|.
name|releaseBuffer
argument_list|(
operator|(
operator|(
name|BufferChunk
operator|)
name|range
operator|)
operator|.
name|getChunk
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|bufferChunks
operator|=
literal|null
expr_stmt|;
name|streams
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Read the current stripe into memory.    *    * @throws IOException    */
specifier|private
name|void
name|readStripe
parameter_list|()
throws|throws
name|IOException
block|{
name|StripeInformation
name|stripe
init|=
name|beginReadStripe
argument_list|()
decl_stmt|;
name|includedRowGroups
operator|=
name|pickRowGroups
argument_list|()
expr_stmt|;
comment|// move forward to the first unskipped row
if|if
condition|(
name|includedRowGroups
operator|!=
literal|null
condition|)
block|{
while|while
condition|(
name|rowInStripe
operator|<
name|rowCountInStripe
operator|&&
operator|!
name|includedRowGroups
index|[
call|(
name|int
call|)
argument_list|(
name|rowInStripe
operator|/
name|rowIndexStride
argument_list|)
index|]
condition|)
block|{
name|rowInStripe
operator|=
name|Math
operator|.
name|min
argument_list|(
name|rowCountInStripe
argument_list|,
name|rowInStripe
operator|+
name|rowIndexStride
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if we haven't skipped the whole stripe, read the data
if|if
condition|(
name|rowInStripe
operator|<
name|rowCountInStripe
condition|)
block|{
comment|// if we aren't projecting columns or filtering rows, just read it all
if|if
condition|(
name|included
operator|==
literal|null
operator|&&
name|includedRowGroups
operator|==
literal|null
condition|)
block|{
name|readAllDataStreams
argument_list|(
name|stripe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|readPartialDataStreams
argument_list|(
name|stripe
argument_list|)
expr_stmt|;
block|}
name|reader
operator|.
name|startStripe
argument_list|(
name|streams
argument_list|,
name|stripeFooter
argument_list|)
expr_stmt|;
comment|// if we skipped the first row group, move the pointers forward
if|if
condition|(
name|rowInStripe
operator|!=
literal|0
condition|)
block|{
name|seekToRowEntry
argument_list|(
name|reader
argument_list|,
call|(
name|int
call|)
argument_list|(
name|rowInStripe
operator|/
name|rowIndexStride
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|StripeInformation
name|beginReadStripe
parameter_list|()
throws|throws
name|IOException
block|{
name|StripeInformation
name|stripe
init|=
name|stripes
operator|.
name|get
argument_list|(
name|currentStripe
argument_list|)
decl_stmt|;
name|stripeFooter
operator|=
name|readStripeFooter
argument_list|(
name|stripe
argument_list|)
expr_stmt|;
name|clearStreams
argument_list|()
expr_stmt|;
comment|// setup the position in the stripe
name|rowCountInStripe
operator|=
name|stripe
operator|.
name|getNumberOfRows
argument_list|()
expr_stmt|;
name|rowInStripe
operator|=
literal|0
expr_stmt|;
name|rowBaseInStripe
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|currentStripe
condition|;
operator|++
name|i
control|)
block|{
name|rowBaseInStripe
operator|+=
name|stripes
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getNumberOfRows
argument_list|()
expr_stmt|;
block|}
comment|// reset all of the indexes
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|indexes
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|indexes
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|stripe
return|;
block|}
specifier|private
name|void
name|readAllDataStreams
parameter_list|(
name|StripeInformation
name|stripe
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|start
init|=
name|stripe
operator|.
name|getIndexLength
argument_list|()
decl_stmt|;
name|long
name|end
init|=
name|start
operator|+
name|stripe
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
comment|// explicitly trigger 1 big read
name|DiskRangeList
name|toRead
init|=
operator|new
name|DiskRangeList
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
decl_stmt|;
name|bufferChunks
operator|=
name|dataReader
operator|.
name|readFileData
argument_list|(
name|toRead
argument_list|,
name|stripe
operator|.
name|getOffset
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|OrcProto
operator|.
name|Stream
argument_list|>
name|streamDescriptions
init|=
name|stripeFooter
operator|.
name|getStreamsList
argument_list|()
decl_stmt|;
name|createStreams
argument_list|(
name|streamDescriptions
argument_list|,
name|bufferChunks
argument_list|,
literal|null
argument_list|,
name|codec
argument_list|,
name|bufferSize
argument_list|,
name|streams
argument_list|)
expr_stmt|;
block|}
comment|/**    * Plan the ranges of the file that we need to read given the list of    * columns and row groups.    *    * @param streamList        the list of streams available    * @param indexes           the indexes that have been loaded    * @param includedColumns   which columns are needed    * @param includedRowGroups which row groups are needed    * @param isCompressed      does the file have generic compression    * @param encodings         the encodings for each column    * @param types             the types of the columns    * @param compressionSize   the compression block size    * @return the list of disk ranges that will be loaded    */
specifier|static
name|DiskRangeList
name|planReadPartialDataStreams
parameter_list|(
name|List
argument_list|<
name|OrcProto
operator|.
name|Stream
argument_list|>
name|streamList
parameter_list|,
name|OrcProto
operator|.
name|RowIndex
index|[]
name|indexes
parameter_list|,
name|boolean
index|[]
name|includedColumns
parameter_list|,
name|boolean
index|[]
name|includedRowGroups
parameter_list|,
name|boolean
name|isCompressed
parameter_list|,
name|List
argument_list|<
name|OrcProto
operator|.
name|ColumnEncoding
argument_list|>
name|encodings
parameter_list|,
name|List
argument_list|<
name|OrcProto
operator|.
name|Type
argument_list|>
name|types
parameter_list|,
name|int
name|compressionSize
parameter_list|,
name|boolean
name|doMergeBuffers
parameter_list|)
block|{
name|long
name|offset
init|=
literal|0
decl_stmt|;
comment|// figure out which columns have a present stream
name|boolean
index|[]
name|hasNull
init|=
name|RecordReaderUtils
operator|.
name|findPresentStreamsByColumn
argument_list|(
name|streamList
argument_list|,
name|types
argument_list|)
decl_stmt|;
name|CreateHelper
name|list
init|=
operator|new
name|CreateHelper
argument_list|()
decl_stmt|;
for|for
control|(
name|OrcProto
operator|.
name|Stream
name|stream
range|:
name|streamList
control|)
block|{
name|long
name|length
init|=
name|stream
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|int
name|column
init|=
name|stream
operator|.
name|getColumn
argument_list|()
decl_stmt|;
name|OrcProto
operator|.
name|Stream
operator|.
name|Kind
name|streamKind
init|=
name|stream
operator|.
name|getKind
argument_list|()
decl_stmt|;
comment|// since stream kind is optional, first check if it exists
if|if
condition|(
name|stream
operator|.
name|hasKind
argument_list|()
operator|&&
operator|(
name|StreamName
operator|.
name|getArea
argument_list|(
name|streamKind
argument_list|)
operator|==
name|StreamName
operator|.
name|Area
operator|.
name|DATA
operator|)
operator|&&
operator|(
name|column
operator|<
name|includedColumns
operator|.
name|length
operator|&&
name|includedColumns
index|[
name|column
index|]
operator|)
condition|)
block|{
comment|// if we aren't filtering or it is a dictionary, load it.
if|if
condition|(
name|includedRowGroups
operator|==
literal|null
operator|||
name|RecordReaderUtils
operator|.
name|isDictionary
argument_list|(
name|streamKind
argument_list|,
name|encodings
operator|.
name|get
argument_list|(
name|column
argument_list|)
argument_list|)
condition|)
block|{
name|RecordReaderUtils
operator|.
name|addEntireStreamToRanges
argument_list|(
name|offset
argument_list|,
name|length
argument_list|,
name|list
argument_list|,
name|doMergeBuffers
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RecordReaderUtils
operator|.
name|addRgFilteredStreamToRanges
argument_list|(
name|stream
argument_list|,
name|includedRowGroups
argument_list|,
name|isCompressed
argument_list|,
name|indexes
index|[
name|column
index|]
argument_list|,
name|encodings
operator|.
name|get
argument_list|(
name|column
argument_list|)
argument_list|,
name|types
operator|.
name|get
argument_list|(
name|column
argument_list|)
argument_list|,
name|compressionSize
argument_list|,
name|hasNull
index|[
name|column
index|]
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|list
argument_list|,
name|doMergeBuffers
argument_list|)
expr_stmt|;
block|}
block|}
name|offset
operator|+=
name|length
expr_stmt|;
block|}
return|return
name|list
operator|.
name|extract
argument_list|()
return|;
block|}
name|void
name|createStreams
parameter_list|(
name|List
argument_list|<
name|OrcProto
operator|.
name|Stream
argument_list|>
name|streamDescriptions
parameter_list|,
name|DiskRangeList
name|ranges
parameter_list|,
name|boolean
index|[]
name|includeColumn
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|Map
argument_list|<
name|StreamName
argument_list|,
name|InStream
argument_list|>
name|streams
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|streamOffset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|OrcProto
operator|.
name|Stream
name|streamDesc
range|:
name|streamDescriptions
control|)
block|{
name|int
name|column
init|=
name|streamDesc
operator|.
name|getColumn
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|includeColumn
operator|!=
literal|null
operator|&&
operator|(
name|column
operator|<
name|included
operator|.
name|length
operator|&&
operator|!
name|includeColumn
index|[
name|column
index|]
operator|)
operator|)
operator|||
name|streamDesc
operator|.
name|hasKind
argument_list|()
operator|&&
operator|(
name|StreamName
operator|.
name|getArea
argument_list|(
name|streamDesc
operator|.
name|getKind
argument_list|()
argument_list|)
operator|!=
name|StreamName
operator|.
name|Area
operator|.
name|DATA
operator|)
condition|)
block|{
name|streamOffset
operator|+=
name|streamDesc
operator|.
name|getLength
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|List
argument_list|<
name|DiskRange
argument_list|>
name|buffers
init|=
name|RecordReaderUtils
operator|.
name|getStreamBuffers
argument_list|(
name|ranges
argument_list|,
name|streamOffset
argument_list|,
name|streamDesc
operator|.
name|getLength
argument_list|()
argument_list|)
decl_stmt|;
name|StreamName
name|name
init|=
operator|new
name|StreamName
argument_list|(
name|column
argument_list|,
name|streamDesc
operator|.
name|getKind
argument_list|()
argument_list|)
decl_stmt|;
name|streams
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|InStream
operator|.
name|create
argument_list|(
name|name
operator|.
name|toString
argument_list|()
argument_list|,
name|buffers
argument_list|,
name|streamDesc
operator|.
name|getLength
argument_list|()
argument_list|,
name|codec
argument_list|,
name|bufferSize
argument_list|)
argument_list|)
expr_stmt|;
name|streamOffset
operator|+=
name|streamDesc
operator|.
name|getLength
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|readPartialDataStreams
parameter_list|(
name|StripeInformation
name|stripe
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|OrcProto
operator|.
name|Stream
argument_list|>
name|streamList
init|=
name|stripeFooter
operator|.
name|getStreamsList
argument_list|()
decl_stmt|;
name|DiskRangeList
name|toRead
init|=
name|planReadPartialDataStreams
argument_list|(
name|streamList
argument_list|,
name|indexes
argument_list|,
name|included
argument_list|,
name|includedRowGroups
argument_list|,
name|codec
operator|!=
literal|null
argument_list|,
name|stripeFooter
operator|.
name|getColumnsList
argument_list|()
argument_list|,
name|types
argument_list|,
name|bufferSize
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"chunks = "
operator|+
name|RecordReaderUtils
operator|.
name|stringifyDiskRanges
argument_list|(
name|toRead
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bufferChunks
operator|=
name|dataReader
operator|.
name|readFileData
argument_list|(
name|toRead
argument_list|,
name|stripe
operator|.
name|getOffset
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"merge = "
operator|+
name|RecordReaderUtils
operator|.
name|stringifyDiskRanges
argument_list|(
name|bufferChunks
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|createStreams
argument_list|(
name|streamList
argument_list|,
name|bufferChunks
argument_list|,
name|included
argument_list|,
name|codec
argument_list|,
name|bufferSize
argument_list|,
name|streams
argument_list|)
expr_stmt|;
block|}
comment|/**    * Read the next stripe until we find a row that we don't skip.    *    * @throws IOException    */
specifier|private
name|void
name|advanceStripe
parameter_list|()
throws|throws
name|IOException
block|{
name|rowInStripe
operator|=
name|rowCountInStripe
expr_stmt|;
while|while
condition|(
name|rowInStripe
operator|>=
name|rowCountInStripe
operator|&&
name|currentStripe
operator|<
name|stripes
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|currentStripe
operator|+=
literal|1
expr_stmt|;
name|readStripe
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Skip over rows that we aren't selecting, so that the next row is    * one that we will read.    *    * @param nextRow the row we want to go to    * @throws IOException    */
specifier|private
name|boolean
name|advanceToNextRow
parameter_list|(
name|TreeReaderFactory
operator|.
name|TreeReader
name|reader
parameter_list|,
name|long
name|nextRow
parameter_list|,
name|boolean
name|canAdvanceStripe
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|nextRowInStripe
init|=
name|nextRow
operator|-
name|rowBaseInStripe
decl_stmt|;
comment|// check for row skipping
if|if
condition|(
name|rowIndexStride
operator|!=
literal|0
operator|&&
name|includedRowGroups
operator|!=
literal|null
operator|&&
name|nextRowInStripe
operator|<
name|rowCountInStripe
condition|)
block|{
name|int
name|rowGroup
init|=
call|(
name|int
call|)
argument_list|(
name|nextRowInStripe
operator|/
name|rowIndexStride
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|includedRowGroups
index|[
name|rowGroup
index|]
condition|)
block|{
while|while
condition|(
name|rowGroup
operator|<
name|includedRowGroups
operator|.
name|length
operator|&&
operator|!
name|includedRowGroups
index|[
name|rowGroup
index|]
condition|)
block|{
name|rowGroup
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rowGroup
operator|>=
name|includedRowGroups
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|canAdvanceStripe
condition|)
block|{
name|advanceStripe
argument_list|()
expr_stmt|;
block|}
return|return
name|canAdvanceStripe
return|;
block|}
name|nextRowInStripe
operator|=
name|Math
operator|.
name|min
argument_list|(
name|rowCountInStripe
argument_list|,
name|rowGroup
operator|*
name|rowIndexStride
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nextRowInStripe
operator|>=
name|rowCountInStripe
condition|)
block|{
if|if
condition|(
name|canAdvanceStripe
condition|)
block|{
name|advanceStripe
argument_list|()
expr_stmt|;
block|}
return|return
name|canAdvanceStripe
return|;
block|}
if|if
condition|(
name|nextRowInStripe
operator|!=
name|rowInStripe
condition|)
block|{
if|if
condition|(
name|rowIndexStride
operator|!=
literal|0
condition|)
block|{
name|int
name|rowGroup
init|=
call|(
name|int
call|)
argument_list|(
name|nextRowInStripe
operator|/
name|rowIndexStride
argument_list|)
decl_stmt|;
name|seekToRowEntry
argument_list|(
name|reader
argument_list|,
name|rowGroup
argument_list|)
expr_stmt|;
name|reader
operator|.
name|skipRows
argument_list|(
name|nextRowInStripe
operator|-
name|rowGroup
operator|*
name|rowIndexStride
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reader
operator|.
name|skipRows
argument_list|(
name|nextRowInStripe
operator|-
name|rowInStripe
argument_list|)
expr_stmt|;
block|}
name|rowInStripe
operator|=
name|nextRowInStripe
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|nextBatch
parameter_list|(
name|VectorizedRowBatch
name|batch
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
if|if
condition|(
name|rowInStripe
operator|>=
name|rowCountInStripe
condition|)
block|{
name|currentStripe
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|currentStripe
operator|>=
name|stripes
operator|.
name|size
argument_list|()
condition|)
block|{
name|batch
operator|.
name|size
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
name|readStripe
argument_list|()
expr_stmt|;
block|}
name|int
name|batchSize
init|=
name|computeBatchSize
argument_list|(
name|batch
operator|.
name|getMaxSize
argument_list|()
argument_list|)
decl_stmt|;
name|rowInStripe
operator|+=
name|batchSize
expr_stmt|;
name|reader
operator|.
name|setVectorColumnCount
argument_list|(
name|batch
operator|.
name|getDataColumnCount
argument_list|()
argument_list|)
expr_stmt|;
name|reader
operator|.
name|nextBatch
argument_list|(
name|batch
argument_list|,
name|batchSize
argument_list|)
expr_stmt|;
name|batch
operator|.
name|selectedInUse
operator|=
literal|false
expr_stmt|;
name|batch
operator|.
name|size
operator|=
name|batchSize
expr_stmt|;
name|advanceToNextRow
argument_list|(
name|reader
argument_list|,
name|rowInStripe
operator|+
name|rowBaseInStripe
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|batch
operator|.
name|size
operator|!=
literal|0
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Rethrow exception with file name in log message
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error reading file: "
operator|+
name|path
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|int
name|computeBatchSize
parameter_list|(
name|long
name|targetBatchSize
parameter_list|)
block|{
specifier|final
name|int
name|batchSize
decl_stmt|;
comment|// In case of PPD, batch size should be aware of row group boundaries. If only a subset of row
comment|// groups are selected then marker position is set to the end of range (subset of row groups
comment|// within strip). Batch size computed out of marker position makes sure that batch size is
comment|// aware of row group boundary and will not cause overflow when reading rows
comment|// illustration of this case is here https://issues.apache.org/jira/browse/HIVE-6287
if|if
condition|(
name|rowIndexStride
operator|!=
literal|0
operator|&&
name|includedRowGroups
operator|!=
literal|null
operator|&&
name|rowInStripe
operator|<
name|rowCountInStripe
condition|)
block|{
name|int
name|startRowGroup
init|=
call|(
name|int
call|)
argument_list|(
name|rowInStripe
operator|/
name|rowIndexStride
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|includedRowGroups
index|[
name|startRowGroup
index|]
condition|)
block|{
while|while
condition|(
name|startRowGroup
operator|<
name|includedRowGroups
operator|.
name|length
operator|&&
operator|!
name|includedRowGroups
index|[
name|startRowGroup
index|]
condition|)
block|{
name|startRowGroup
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|int
name|endRowGroup
init|=
name|startRowGroup
decl_stmt|;
while|while
condition|(
name|endRowGroup
operator|<
name|includedRowGroups
operator|.
name|length
operator|&&
name|includedRowGroups
index|[
name|endRowGroup
index|]
condition|)
block|{
name|endRowGroup
operator|+=
literal|1
expr_stmt|;
block|}
specifier|final
name|long
name|markerPosition
init|=
operator|(
name|endRowGroup
operator|*
name|rowIndexStride
operator|)
operator|<
name|rowCountInStripe
condition|?
operator|(
name|endRowGroup
operator|*
name|rowIndexStride
operator|)
else|:
name|rowCountInStripe
decl_stmt|;
name|batchSize
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|targetBatchSize
argument_list|,
operator|(
name|markerPosition
operator|-
name|rowInStripe
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isLogDebugEnabled
operator|&&
name|batchSize
operator|<
name|targetBatchSize
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"markerPosition: "
operator|+
name|markerPosition
operator|+
literal|" batchSize: "
operator|+
name|batchSize
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|batchSize
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|targetBatchSize
argument_list|,
operator|(
name|rowCountInStripe
operator|-
name|rowInStripe
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|batchSize
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|clearStreams
argument_list|()
expr_stmt|;
name|dataReader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getRowNumber
parameter_list|()
block|{
return|return
name|rowInStripe
operator|+
name|rowBaseInStripe
operator|+
name|firstRow
return|;
block|}
comment|/**    * Return the fraction of rows that have been read from the selected.    * section of the file    *    * @return fraction between 0.0 and 1.0 of rows consumed    */
annotation|@
name|Override
specifier|public
name|float
name|getProgress
parameter_list|()
block|{
return|return
operator|(
operator|(
name|float
operator|)
name|rowBaseInStripe
operator|+
name|rowInStripe
operator|)
operator|/
name|totalRowCount
return|;
block|}
specifier|private
name|int
name|findStripe
parameter_list|(
name|long
name|rowNumber
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stripes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|StripeInformation
name|stripe
init|=
name|stripes
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|stripe
operator|.
name|getNumberOfRows
argument_list|()
operator|>
name|rowNumber
condition|)
block|{
return|return
name|i
return|;
block|}
name|rowNumber
operator|-=
name|stripe
operator|.
name|getNumberOfRows
argument_list|()
expr_stmt|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Seek after the end of reader range"
argument_list|)
throw|;
block|}
specifier|public
name|OrcIndex
name|readRowIndex
parameter_list|(
name|int
name|stripeIndex
parameter_list|,
name|boolean
index|[]
name|included
parameter_list|,
name|boolean
index|[]
name|sargColumns
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|readRowIndex
argument_list|(
name|stripeIndex
argument_list|,
name|included
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|sargColumns
argument_list|)
return|;
block|}
specifier|public
name|OrcIndex
name|readRowIndex
parameter_list|(
name|int
name|stripeIndex
parameter_list|,
name|boolean
index|[]
name|included
parameter_list|,
name|OrcProto
operator|.
name|RowIndex
index|[]
name|indexes
parameter_list|,
name|OrcProto
operator|.
name|BloomFilterIndex
index|[]
name|bloomFilterIndex
parameter_list|,
name|boolean
index|[]
name|sargColumns
parameter_list|)
throws|throws
name|IOException
block|{
name|StripeInformation
name|stripe
init|=
name|stripes
operator|.
name|get
argument_list|(
name|stripeIndex
argument_list|)
decl_stmt|;
name|OrcProto
operator|.
name|StripeFooter
name|stripeFooter
init|=
literal|null
decl_stmt|;
comment|// if this is the current stripe, use the cached objects.
if|if
condition|(
name|stripeIndex
operator|==
name|currentStripe
condition|)
block|{
name|stripeFooter
operator|=
name|this
operator|.
name|stripeFooter
expr_stmt|;
name|indexes
operator|=
name|indexes
operator|==
literal|null
condition|?
name|this
operator|.
name|indexes
else|:
name|indexes
expr_stmt|;
name|bloomFilterIndex
operator|=
name|bloomFilterIndex
operator|==
literal|null
condition|?
name|this
operator|.
name|bloomFilterIndices
else|:
name|bloomFilterIndex
expr_stmt|;
name|sargColumns
operator|=
name|sargColumns
operator|==
literal|null
condition|?
operator|(
name|sargApp
operator|==
literal|null
condition|?
literal|null
else|:
name|sargApp
operator|.
name|sargColumns
operator|)
else|:
name|sargColumns
expr_stmt|;
block|}
return|return
name|dataReader
operator|.
name|readRowIndex
argument_list|(
name|stripe
argument_list|,
name|stripeFooter
argument_list|,
name|included
argument_list|,
name|indexes
argument_list|,
name|sargColumns
argument_list|,
name|bloomFilterIndex
argument_list|)
return|;
block|}
specifier|private
name|void
name|seekToRowEntry
parameter_list|(
name|TreeReaderFactory
operator|.
name|TreeReader
name|reader
parameter_list|,
name|int
name|rowEntry
parameter_list|)
throws|throws
name|IOException
block|{
name|PositionProvider
index|[]
name|index
init|=
operator|new
name|PositionProvider
index|[
name|indexes
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|indexes
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|indexes
index|[
name|i
index|]
operator|!=
literal|null
condition|)
block|{
name|index
index|[
name|i
index|]
operator|=
operator|new
name|PositionProviderImpl
argument_list|(
name|indexes
index|[
name|i
index|]
operator|.
name|getEntry
argument_list|(
name|rowEntry
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|reader
operator|.
name|seek
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|seekToRow
parameter_list|(
name|long
name|rowNumber
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|rowNumber
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Seek to a negative row number "
operator|+
name|rowNumber
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|rowNumber
operator|<
name|firstRow
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Seek before reader range "
operator|+
name|rowNumber
argument_list|)
throw|;
block|}
comment|// convert to our internal form (rows from the beginning of slice)
name|rowNumber
operator|-=
name|firstRow
expr_stmt|;
comment|// move to the right stripe
name|int
name|rightStripe
init|=
name|findStripe
argument_list|(
name|rowNumber
argument_list|)
decl_stmt|;
if|if
condition|(
name|rightStripe
operator|!=
name|currentStripe
condition|)
block|{
name|currentStripe
operator|=
name|rightStripe
expr_stmt|;
name|readStripe
argument_list|()
expr_stmt|;
block|}
name|readRowIndex
argument_list|(
name|currentStripe
argument_list|,
name|included
argument_list|,
name|sargApp
operator|==
literal|null
condition|?
literal|null
else|:
name|sargApp
operator|.
name|sargColumns
argument_list|)
expr_stmt|;
comment|// if we aren't to the right row yet, advance in the stripe.
name|advanceToNextRow
argument_list|(
name|reader
argument_list|,
name|rowNumber
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
specifier|final
name|String
name|TRANSLATED_SARG_SEPARATOR
init|=
literal|"_"
decl_stmt|;
specifier|public
specifier|static
name|String
name|encodeTranslatedSargColumn
parameter_list|(
name|int
name|rootColumn
parameter_list|,
name|Integer
name|indexInSourceTable
parameter_list|)
block|{
return|return
name|rootColumn
operator|+
name|TRANSLATED_SARG_SEPARATOR
operator|+
operator|(
operator|(
name|indexInSourceTable
operator|==
literal|null
operator|)
condition|?
operator|-
literal|1
else|:
name|indexInSourceTable
operator|)
return|;
block|}
specifier|public
specifier|static
name|int
index|[]
name|mapTranslatedSargColumns
parameter_list|(
name|List
argument_list|<
name|OrcProto
operator|.
name|Type
argument_list|>
name|types
parameter_list|,
name|List
argument_list|<
name|PredicateLeaf
argument_list|>
name|sargLeaves
parameter_list|)
block|{
name|int
index|[]
name|result
init|=
operator|new
name|int
index|[
name|sargLeaves
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|OrcProto
operator|.
name|Type
name|lastRoot
init|=
literal|null
decl_stmt|;
comment|// Root will be the same for everyone as of now.
name|String
name|lastRootStr
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|result
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|String
index|[]
name|rootAndIndex
init|=
name|sargLeaves
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getColumnName
argument_list|()
operator|.
name|split
argument_list|(
name|TRANSLATED_SARG_SEPARATOR
argument_list|)
decl_stmt|;
assert|assert
name|rootAndIndex
operator|.
name|length
operator|==
literal|2
assert|;
name|String
name|rootStr
init|=
name|rootAndIndex
index|[
literal|0
index|]
decl_stmt|,
name|indexStr
init|=
name|rootAndIndex
index|[
literal|1
index|]
decl_stmt|;
name|int
name|index
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|indexStr
argument_list|)
decl_stmt|;
comment|// First, check if the column even maps to anything.
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|result
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
assert|assert
name|index
operator|>=
literal|0
assert|;
comment|// Then, find the root type if needed.
if|if
condition|(
operator|!
name|rootStr
operator|.
name|equals
argument_list|(
name|lastRootStr
argument_list|)
condition|)
block|{
name|lastRoot
operator|=
name|types
operator|.
name|get
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|rootStr
argument_list|)
argument_list|)
expr_stmt|;
name|lastRootStr
operator|=
name|rootStr
expr_stmt|;
block|}
comment|// Subtypes of the root types correspond, in order, to the columns in the table schema
comment|// (disregarding schema evolution that doesn't presently work). Get the index for the
comment|// corresponding subtype.
name|result
index|[
name|i
index|]
operator|=
name|lastRoot
operator|.
name|getSubtypes
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
end_class

end_unit

