begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_comment
comment|/**  * HiveDecimal is a decimal data type with a maximum precision and scale.  *<p>  * It is the Hive DECIMAL data type.  *<p>  * The scale is the number of fractional decimal digits.  The digits after the dot.  It is limited  * to 38 (MAX_SCALE).  *<p>  * The precision is the integer (or whole-number) decimal digits plus fractional decimal digits.  * It is limited to a total of 38 digits (MAX_PRECISION).  *<p>  * Hive syntax for declaring DECIMAL has 3 forms:  *<p>  * {@code  *       DECIMAL                            // Use the default precision/scale.}  *<p>  * {@code  *       DECIMAL(precision)                 // Use the default scale.}  *<p>  * {@code  *       DECIMAL(precision, scale)}  * }  *<p>  * The declared scale must be&lt;= precision.  *<p>  * Use DECIMAL instead of DOUBLE when exact numeric accuracy is required.  Not all decimal numbers  * (radix 10) are exactly representable in the binary (radix 2 based) floating point type DOUBLE and  * cause accuracy anomalies (i.e. wrong results).  See the Internet for more details.  *<p>  * HiveDecimal is implemented as a classic Java immutable object.  All operations on HiveDecimal  * that produce a different value will create a new HiveDecimal object.  *<p>  * Decimals are physically stored without any extra leading or trailing zeroes.  The scale of  * a decimal is the number of non-trailing zero fractional digits.  *<p>  * Math operations on decimals typically cause the scale to change as a result of the math and  * from trailing fractional digit elimination.  *<p>  * Typically, Hive, when it wants to make sure a result decimal fits in the column decimal's  * precision/scale it calls enforcePrecisionScale.  That method will scale down or trim off  * result fractional digits if necessary with rounding when the column has a smaller scale.  * And, it will also indicate overflow when the decimal has exceeded the column's maximum precision.  *<p>  * NOTE: When Hive gets ready to serialize a decimal into text or binary, it usually sometimes  * wants trailing fractional zeroes.  See the special notes for toFormatString and  * bigIntegerBytesScaled for details.  *<p>  * ------------------------------------- Version 2 ------------------------------------------------  *<p>  * This is the 2nd major version of HiveDecimal called V2.  The previous version has been  * renamed to HiveDecimalV1 and is kept as a test and behavior reference.  *<p>  * For good performance we do not represent the decimal using a BigDecimal object like the previous  * version V1 did.  Using Java objects to represent our decimal incurs too high a penalty  * for memory allocations and general logic.  *<p>  * The original V1 public methods and fields are annotated with @HiveDecimalVersionV1; new public  * methods and fields are annotated with @HiveDecimalVersionV2.  *  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|HiveDecimal
extends|extends
name|FastHiveDecimal
implements|implements
name|Comparable
argument_list|<
name|HiveDecimal
argument_list|>
block|{
comment|/*    * IMPLEMENTATION NOTE:    *    We implement HiveDecimal with the mutable FastHiveDecimal class.  That class uses    *    protected on all its methods so they will not be visible in the HiveDecimal class.    *    *    So even if one casts to FastHiveDecimal, you shouldn't be able to violate the immutability    *    of a HiveDecimal class.    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
specifier|static
specifier|final
name|int
name|MAX_PRECISION
init|=
literal|38
decl_stmt|;
annotation|@
name|HiveDecimalVersionV1
specifier|public
specifier|static
specifier|final
name|int
name|MAX_SCALE
init|=
literal|38
decl_stmt|;
comment|/**    * Default precision/scale when user doesn't specify in the column metadata, such as    * decimal and decimal(8).    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
specifier|static
specifier|final
name|int
name|USER_DEFAULT_PRECISION
init|=
literal|10
decl_stmt|;
annotation|@
name|HiveDecimalVersionV1
specifier|public
specifier|static
specifier|final
name|int
name|USER_DEFAULT_SCALE
init|=
literal|0
decl_stmt|;
comment|/**    *  Default precision/scale when system is not able to determine them, such as in case    *  of a non-generic udf.    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
specifier|static
specifier|final
name|int
name|SYSTEM_DEFAULT_PRECISION
init|=
literal|38
decl_stmt|;
annotation|@
name|HiveDecimalVersionV1
specifier|public
specifier|static
specifier|final
name|int
name|SYSTEM_DEFAULT_SCALE
init|=
literal|18
decl_stmt|;
comment|/**    * Common values.    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
specifier|static
specifier|final
name|HiveDecimal
name|ZERO
init|=
name|HiveDecimal
operator|.
name|create
argument_list|(
literal|0
argument_list|)
decl_stmt|;
annotation|@
name|HiveDecimalVersionV1
specifier|public
specifier|static
specifier|final
name|HiveDecimal
name|ONE
init|=
name|HiveDecimal
operator|.
name|create
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|/**    * ROUND_FLOOR:    *<p>    *   Round towards negative infinity.    *<p>    *   The Hive function is FLOOR.    *<p>    *   Positive numbers: The round fraction is thrown away.    *<p>    *       (Example here rounds at scale 0)    *       Value        FLOOR    *        0.3           0    *        2             2    *        2.1           2    *<p>    *   Negative numbers: If there is a round fraction, throw it away and subtract 1.    *<p>    *       (Example here rounds at scale 0)    *       Value        FLOOR    *       -0.3           -1    *       -2             -2    *       -2.1           -3    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
specifier|static
specifier|final
name|int
name|ROUND_FLOOR
init|=
name|BigDecimal
operator|.
name|ROUND_FLOOR
decl_stmt|;
comment|/**    * ROUND_CEILING:    *<p>    *   Round towards positive infinity.    *<p>    *   The Hive function is CEILING.    *<p>    *   Positive numbers: If there is a round fraction, throw it away and add 1    *<p>    *       (Example here rounds at scale 0)    *       Value        CEILING    *        0.3           1    *        2             2    *        2.1           3    *<p>    *   Negative numbers: The round fraction is thrown away.    *<p>    *       (Example here rounds at scale 0)    *       Value        CEILING    *       -0.3           0    *       -2             -2    *       -2.1           -2    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
specifier|static
specifier|final
name|int
name|ROUND_CEILING
init|=
name|BigDecimal
operator|.
name|ROUND_CEILING
decl_stmt|;
comment|/**    * ROUND_HALF_UP:    *<p>    *   Round towards "nearest neighbor" unless both neighbors are equidistant then round up.    *<p>    *   The Hive function is ROUND.    *<p>    *   For result, throw away round fraction.  If the round fraction is&gt;= 0.5, then add 1 when    *   positive and subtract 1 when negative.  So, the sign is irrelevant.    *<p>    *      (Example here rounds at scale 0)    *       Value        ROUND                  Value        ROUND    *       0.3           0                     -0.3           0    *       2             2                     -2            -2    *       2.1           2                     -2.1          -2    *       2.49          2                     -2.49         -2    *       2.5           3                     -2.5          -3    *    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
specifier|static
specifier|final
name|int
name|ROUND_HALF_UP
init|=
name|BigDecimal
operator|.
name|ROUND_HALF_UP
decl_stmt|;
comment|/**    * ROUND_HALF_EVEN:    *   Round towards the "nearest neighbor" unless both neighbors are equidistant, then round    *   towards the even neighbor.    *<p>    *   The Hive function is BROUND.    *<p>    *   Known as Bankerâ€™s Rounding.    *<p>    *   When you add values rounded with ROUND_HALF_UP you have a bias that grows as you add more    *   numbers.  Banker's Rounding is a way to minimize that bias.  It rounds toward the nearest    *   even number when the fraction is 0.5 exactly.  In table below, notice that 2.5 goes DOWN to    *   2 (even) but 3.5 goes UP to 4 (even), etc.    *<p>    *   So, the sign is irrelevant.    *<p>    *       (Example here rounds at scale 0)    *       Value        BROUND                  Value        BROUND    *        0.49          0                     -0.49          0    *        0.5           0                     -0.5           0    *        0.51          1                     -0.51         -1    *        1.5           2                     -1.5          -2    *        2.5           2                     -2.5          -2    *        2.51          3                     -2.51         -3    *        3.5           4                     -3.5          -4    *        4.5           4                     -4.5          -4    *        4.51          5                     -4.51         -5    *    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
specifier|static
specifier|final
name|int
name|ROUND_HALF_EVEN
init|=
name|BigDecimal
operator|.
name|ROUND_HALF_EVEN
decl_stmt|;
comment|//-----------------------------------------------------------------------------------------------
comment|// Constructors are marked private; use create methods.
comment|//-----------------------------------------------------------------------------------------------
specifier|private
name|HiveDecimal
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
specifier|private
name|HiveDecimal
parameter_list|(
name|HiveDecimal
name|dec
parameter_list|)
block|{
name|super
argument_list|(
name|dec
argument_list|)
expr_stmt|;
block|}
specifier|private
name|HiveDecimal
parameter_list|(
name|FastHiveDecimal
name|fastDec
parameter_list|)
block|{
name|super
argument_list|(
name|fastDec
argument_list|)
expr_stmt|;
block|}
specifier|private
name|HiveDecimal
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|FastHiveDecimal
name|fastDec
parameter_list|)
block|{
name|super
argument_list|(
name|fastSignum
argument_list|,
name|fastDec
argument_list|)
expr_stmt|;
block|}
specifier|private
name|HiveDecimal
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|)
block|{
name|super
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|)
expr_stmt|;
block|}
comment|//-----------------------------------------------------------------------------------------------
comment|// Create methods.
comment|//-----------------------------------------------------------------------------------------------
comment|/**    * Create a HiveDecimal from a FastHiveDecimal object. Used by HiveDecimalWritable.    * @param fastDec the value to set    * @return new hive decimal    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
specifier|static
name|HiveDecimal
name|createFromFast
parameter_list|(
name|FastHiveDecimal
name|fastDec
parameter_list|)
block|{
return|return
operator|new
name|HiveDecimal
argument_list|(
name|fastDec
argument_list|)
return|;
block|}
comment|/**    * Create a HiveDecimal from BigDecimal object.    *    * A BigDecimal object has a decimal scale.    *    * We will have overflow if BigDecimal's integer part exceed MAX_PRECISION digits or    * 99,999,999,999,999,999,999,999,999,999,999,999,999 or 10^38 - 1.    *    * When the BigDecimal value's precision exceeds MAX_PRECISION and there are fractional digits    * because of scale&gt; 0, then lower digits are trimmed off with rounding to meet the    * MAX_PRECISION requirement.    *    * Also, BigDecimal supports negative scale -- which means multiplying the value by 10^abs(scale).    * And, BigDecimal allows for a non-zero scale for zero.  We normalize that so zero always has    * scale 0.    *    * @param bigDecimal the value to set    * @return  The HiveDecimal with the BigDecimal's value adjusted down to a maximum precision.    *          Otherwise, null is returned for overflow.    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
specifier|static
name|HiveDecimal
name|create
parameter_list|(
name|BigDecimal
name|bigDecimal
parameter_list|)
block|{
return|return
name|create
argument_list|(
name|bigDecimal
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Same as the above create method, except fractional digit rounding can be turned off.    * @param bigDecimal the value to set    * @param allowRounding  True requires all of the bigDecimal value be converted to the decimal    *                       without loss of precision.    * @return    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
specifier|static
name|HiveDecimal
name|create
parameter_list|(
name|BigDecimal
name|bigDecimal
parameter_list|,
name|boolean
name|allowRounding
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|fastSetFromBigDecimal
argument_list|(
name|bigDecimal
argument_list|,
name|allowRounding
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Creates a HiveDecimal from a BigInteger's value with a scale of 0.    *    * We will have overflow if BigInteger exceed MAX_PRECISION digits or    * 99,999,999,999,999,999,999,999,999,999,999,999,999 or 10^38 - 1.    *    * @param bigInteger the value to set    * @return  A HiveDecimal object with the exact BigInteger's value.    *          Otherwise, null is returned on overflow.    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
specifier|static
name|HiveDecimal
name|create
parameter_list|(
name|BigInteger
name|bigInteger
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|fastSetFromBigInteger
argument_list|(
name|bigInteger
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Creates a HiveDecimal from a BigInteger's value with a specified scale.    *    * We will have overflow if BigInteger exceed MAX_PRECISION digits or    * 99,999,999,999,999,999,999,999,999,999,999,999,999 or 10^38 - 1.    *    * The resulting decimal will have fractional digits when the specified scale is greater than 0.    *    * When the BigInteger's value's precision exceeds MAX_PRECISION and there are fractional digits    * because of scale&gt; 0, then lower digits are trimmed off with rounding to meet the    * MAX_PRECISION requirement.    *    * @param bigInteger the value to set    * @param scale the scale to set    * @return  A HiveDecimal object with the BigInteger's value adjusted for scale.    *          Otherwise, null is returned on overflow.    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
specifier|static
name|HiveDecimal
name|create
parameter_list|(
name|BigInteger
name|bigInteger
parameter_list|,
name|int
name|scale
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|fastSetFromBigIntegerAndScale
argument_list|(
name|bigInteger
argument_list|,
name|scale
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Create a HiveDecimal by parsing a whole string.    *    * We support parsing a decimal with an exponent because the previous version    * (i.e. OldHiveDecimal) uses the BigDecimal parser and was able to.    *    * @param string the string to parse    * @return a new hive decimal    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
specifier|static
name|HiveDecimal
name|create
parameter_list|(
name|String
name|string
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|fastSetFromString
argument_list|(
name|string
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Same as the method above, except blanks before and after are tolerated.    * @param string the string to parse    * @param trimBlanks  True specifies leading and trailing blanks are to be ignored.    * @return a new hive decimal    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
specifier|static
name|HiveDecimal
name|create
parameter_list|(
name|String
name|string
parameter_list|,
name|boolean
name|trimBlanks
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|fastSetFromString
argument_list|(
name|string
argument_list|,
name|trimBlanks
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Create a HiveDecimal by parsing the characters in a whole byte array.    *    * Same rules as create(String string) above.    *    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
specifier|static
name|HiveDecimal
name|create
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|fastSetFromBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Same as the method above, except blanks before and after are tolerated.    *    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
specifier|static
name|HiveDecimal
name|create
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|boolean
name|trimBlanks
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|fastSetFromBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|,
name|trimBlanks
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * This method takes in digits only UTF-8 characters, a sign flag, and a scale and returns    * a decimal.    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
specifier|static
name|HiveDecimal
name|create
parameter_list|(
name|boolean
name|isNegative
parameter_list|,
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|scale
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|fastSetFromDigitsOnlyBytesAndScale
argument_list|(
name|isNegative
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|,
name|scale
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|isNegative
condition|)
block|{
name|result
operator|.
name|fastNegate
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|HiveDecimalVersionV2
specifier|public
specifier|static
name|HiveDecimal
name|create
parameter_list|(
name|boolean
name|isNegative
parameter_list|,
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|scale
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|fastSetFromDigitsOnlyBytesAndScale
argument_list|(
name|isNegative
argument_list|,
name|bytes
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|scale
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Create a HiveDecimal by parsing the characters in a slice of a byte array.    *    * Same rules as create(String string) above.    *    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
specifier|static
name|HiveDecimal
name|create
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|fastSetFromBytes
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Same as the method above, except blanks before and after are tolerated.    *    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
specifier|static
name|HiveDecimal
name|create
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|trimBlanks
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|fastSetFromBytes
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|trimBlanks
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Create a HiveDecimal object from an int.    *    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
specifier|static
name|HiveDecimal
name|create
parameter_list|(
name|int
name|intValue
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
name|result
operator|.
name|fastSetFromInt
argument_list|(
name|intValue
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Create a HiveDecimal object from a long.    *    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
specifier|static
name|HiveDecimal
name|create
parameter_list|(
name|long
name|longValue
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
name|result
operator|.
name|fastSetFromLong
argument_list|(
name|longValue
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Create a HiveDecimal object from a long with a specified scale.    *    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
specifier|static
name|HiveDecimal
name|create
parameter_list|(
name|long
name|longValue
parameter_list|,
name|int
name|scale
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|fastSetFromLongAndScale
argument_list|(
name|longValue
argument_list|,
name|scale
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Create a HiveDecimal object from a float.    *<p>    * This method is equivalent to HiveDecimal.create(Float.toString(floatValue))    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
specifier|static
name|HiveDecimal
name|create
parameter_list|(
name|float
name|floatValue
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|fastSetFromFloat
argument_list|(
name|floatValue
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Create a HiveDecimal object from a double.    *<p>    * This method is equivalent to HiveDecimal.create(Double.toString(doubleValue))    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
specifier|static
name|HiveDecimal
name|create
parameter_list|(
name|double
name|doubleValue
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|fastSetFromDouble
argument_list|(
name|doubleValue
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|//-----------------------------------------------------------------------------------------------
comment|// Serialization methods.
comment|//-----------------------------------------------------------------------------------------------
comment|// The byte length of the scratch byte array that needs to be passed to serializationUtilsRead.
annotation|@
name|HiveDecimalVersionV2
specifier|public
specifier|static
specifier|final
name|int
name|SCRATCH_BUFFER_LEN_SERIALIZATION_UTILS_READ
init|=
name|FAST_SCRATCH_BUFFER_LEN_SERIALIZATION_UTILS_READ
decl_stmt|;
comment|/**    * Deserialize data written in the format used by the SerializationUtils methods    * readBigInteger/writeBigInteger and create a decimal using the supplied scale.    *<p>    * ORC uses those SerializationUtils methods for its serialization.    *<p>    * A scratch bytes array is necessary to do the binary to decimal conversion for better    * performance.  Pass a SCRATCH_BUFFER_LEN_SERIALIZATION_UTILS_READ byte array for scratchBytes.    *<p>    * @return The deserialized decimal or null if the conversion failed.    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
specifier|static
name|HiveDecimal
name|serializationUtilsRead
parameter_list|(
name|InputStream
name|inputStream
parameter_list|,
name|int
name|scale
parameter_list|,
name|byte
index|[]
name|scratchBytes
parameter_list|)
throws|throws
name|IOException
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|fastSerializationUtilsRead
argument_list|(
name|inputStream
argument_list|,
name|scale
argument_list|,
name|scratchBytes
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Convert bytes in the format used by BigInteger's toByteArray format (and accepted by its    * constructor) into a decimal using the specified scale.    *<p>    * Our bigIntegerBytes methods create bytes in this format, too.    *<p>    * This method is designed for high performance and does not create an actual BigInteger during    * binary to decimal conversion.    *    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
specifier|static
name|HiveDecimal
name|createFromBigIntegerBytesAndScale
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|scale
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|fastSetFromBigIntegerBytesAndScale
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|,
name|scale
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|HiveDecimalVersionV2
specifier|public
specifier|static
name|HiveDecimal
name|createFromBigIntegerBytesAndScale
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|scale
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|fastSetFromBigIntegerBytesAndScale
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|scale
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|// The length of the long array that needs to be passed to serializationUtilsWrite.
annotation|@
name|HiveDecimalVersionV2
specifier|public
specifier|static
specifier|final
name|int
name|SCRATCH_LONGS_LEN
init|=
name|FAST_SCRATCH_LONGS_LEN
decl_stmt|;
comment|/**    * Serialize this decimal's BigInteger equivalent unscaled value using the format that the    * SerializationUtils methods readBigInteger/writeBigInteger use.    *<p>    * ORC uses those SerializationUtils methods for its serialization.    *<p>    * Scratch objects necessary to do the decimal to binary conversion without actually creating a    * BigInteger object are passed for better performance.    *<p>    * Allocate scratchLongs with SCRATCH_LONGS_LEN longs.    *    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
name|boolean
name|serializationUtilsWrite
parameter_list|(
name|OutputStream
name|outputStream
parameter_list|,
name|long
index|[]
name|scratchLongs
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fastSerializationUtilsWrite
argument_list|(
name|outputStream
argument_list|,
name|scratchLongs
argument_list|)
return|;
block|}
comment|// The length of the scratch byte array that needs to be passed to bigIntegerBytes, etc.
annotation|@
name|HiveDecimalVersionV2
specifier|public
specifier|static
specifier|final
name|int
name|SCRATCH_BUFFER_LEN_BIG_INTEGER_BYTES
init|=
name|FAST_SCRATCH_BUFFER_LEN_BIG_INTEGER_BYTES
decl_stmt|;
comment|/**    * Return binary representation of this decimal's BigInteger equivalent unscaled value using    * the format that the BigInteger's toByteArray method returns (and the BigInteger constructor    * accepts).    *<p>    * Used by LazyBinary, Avro, and Parquet serialization.    *<p>    * Scratch objects necessary to do the decimal to binary conversion without actually creating a    * BigInteger object are passed for better performance.    *<p>    * Allocate scratchLongs with SCRATCH_LONGS_LEN longs.    * And, allocate buffer with SCRATCH_BUFFER_LEN_BIG_INTEGER_BYTES bytes.    *<p>    * @param scratchLongs    * @param buffer    * @return The number of bytes used for the binary result in buffer.  Otherwise, 0 if the    *         conversion failed.    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
name|int
name|bigIntegerBytes
parameter_list|(
name|long
index|[]
name|scratchLongs
parameter_list|,
name|byte
index|[]
name|buffer
parameter_list|)
block|{
return|return
name|fastBigIntegerBytes
argument_list|(
name|scratchLongs
argument_list|,
name|buffer
argument_list|)
return|;
block|}
annotation|@
name|HiveDecimalVersionV2
specifier|public
name|byte
index|[]
name|bigIntegerBytes
parameter_list|()
block|{
name|long
index|[]
name|scratchLongs
init|=
operator|new
name|long
index|[
name|SCRATCH_LONGS_LEN
index|]
decl_stmt|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
name|SCRATCH_BUFFER_LEN_BIG_INTEGER_BYTES
index|]
decl_stmt|;
specifier|final
name|int
name|byteLength
init|=
name|fastBigIntegerBytes
argument_list|(
name|scratchLongs
argument_list|,
name|buffer
argument_list|)
decl_stmt|;
return|return
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|byteLength
argument_list|)
return|;
block|}
comment|/**    * Convert decimal to BigInteger binary bytes with a serialize scale, similar to the formatScale    * for toFormatString.  It adds trailing zeroes the (emulated) BigInteger toByteArray result    * when a serializeScale is greater than current scale.  Or, rounds if scale is less than    * current scale.    *<p>    * Used by Avro and Parquet serialization.    *<p>    * This emulates the OldHiveDecimal setScale AND THEN OldHiveDecimal getInternalStorage() behavior.    *    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
name|int
name|bigIntegerBytesScaled
parameter_list|(
name|int
name|serializeScale
parameter_list|,
name|long
index|[]
name|scratchLongs
parameter_list|,
name|byte
index|[]
name|buffer
parameter_list|)
block|{
return|return
name|fastBigIntegerBytesScaled
argument_list|(
name|serializeScale
argument_list|,
name|scratchLongs
argument_list|,
name|buffer
argument_list|)
return|;
block|}
annotation|@
name|HiveDecimalVersionV2
specifier|public
name|byte
index|[]
name|bigIntegerBytesScaled
parameter_list|(
name|int
name|serializeScale
parameter_list|)
block|{
name|long
index|[]
name|scratchLongs
init|=
operator|new
name|long
index|[
name|SCRATCH_LONGS_LEN
index|]
decl_stmt|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
name|SCRATCH_BUFFER_LEN_BIG_INTEGER_BYTES
index|]
decl_stmt|;
name|int
name|byteLength
init|=
name|fastBigIntegerBytesScaled
argument_list|(
name|serializeScale
argument_list|,
name|scratchLongs
argument_list|,
name|buffer
argument_list|)
decl_stmt|;
return|return
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|byteLength
argument_list|)
return|;
block|}
comment|//-----------------------------------------------------------------------------------------------
comment|// Convert to string/UTF-8 ASCII bytes methods.
comment|//-----------------------------------------------------------------------------------------------
comment|/**    * Return a string representation of the decimal.    *<p>    * It is the equivalent of calling bigDecimalValue().toPlainString -- it does not add exponent    * notation -- but is much faster.    *<p>    * NOTE: If setScale(int serializationScale) was used to create the decimal object, then trailing    * fractional digits will be added to display to the serializationScale.  Or, the display may    * get rounded.  See the comments for that method.    *    */
annotation|@
name|HiveDecimalVersionV1
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|fastSerializationScale
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Use the serialization scale and format the string with trailing zeroes (or
comment|// round the decimal) if necessary.
return|return
name|fastToFormatString
argument_list|(
name|fastSerializationScale
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|fastToString
argument_list|()
return|;
block|}
block|}
annotation|@
name|HiveDecimalVersionV2
specifier|public
name|String
name|toString
parameter_list|(
name|byte
index|[]
name|scratchBuffer
parameter_list|)
block|{
if|if
condition|(
name|fastSerializationScale
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Use the serialization scale and format the string with trailing zeroes (or
comment|// round the decimal) if necessary.
return|return
name|fastToFormatString
argument_list|(
name|fastSerializationScale
argument_list|()
argument_list|,
name|scratchBuffer
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|fastToString
argument_list|(
name|scratchBuffer
argument_list|)
return|;
block|}
block|}
comment|/**    * Return a string representation of the decimal using the specified scale.    *<p>    * This method is designed to ALWAYS SUCCEED (unless the newScale parameter is out of range).    *<p>    * Is does the equivalent of a setScale(int newScale).  So, more than 38 digits may be returned.    * See that method for more details on how this can happen.    *<p>    * @param formatScale The number of digits after the decimal point    * @return The scaled decimal representation string representation.    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|String
name|toFormatString
parameter_list|(
name|int
name|formatScale
parameter_list|)
block|{
return|return
name|fastToFormatString
argument_list|(
name|formatScale
argument_list|)
return|;
block|}
annotation|@
name|HiveDecimalVersionV2
specifier|public
name|String
name|toFormatString
parameter_list|(
name|int
name|formatScale
parameter_list|,
name|byte
index|[]
name|scratchBuffer
parameter_list|)
block|{
return|return
name|fastToFormatString
argument_list|(
name|formatScale
argument_list|,
name|scratchBuffer
argument_list|)
return|;
block|}
annotation|@
name|HiveDecimalVersionV2
specifier|public
name|String
name|toDigitsOnlyString
parameter_list|()
block|{
return|return
name|fastToDigitsOnlyString
argument_list|()
return|;
block|}
comment|// The length of the scratch buffer that needs to be passed to toBytes, toFormatBytes,
comment|// toDigitsOnlyBytes.
annotation|@
name|HiveDecimalVersionV2
specifier|public
specifier|final
specifier|static
name|int
name|SCRATCH_BUFFER_LEN_TO_BYTES
init|=
name|FAST_SCRATCH_BUFFER_LEN_TO_BYTES
decl_stmt|;
comment|/**    * Decimal to ASCII bytes conversion.    *<p>    * The scratch buffer will contain the result afterwards.  It should be    * SCRATCH_BUFFER_LEN_TO_BYTES bytes long.    *<p>    * The result is produced at the end of the scratch buffer, so the return value is the byte    * index of the first byte.  The byte slice is [byteIndex:SCRATCH_BUFFER_LEN_TO_BYTES-1].    *    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
name|int
name|toBytes
parameter_list|(
name|byte
index|[]
name|scratchBuffer
parameter_list|)
block|{
return|return
name|fastToBytes
argument_list|(
name|scratchBuffer
argument_list|)
return|;
block|}
comment|/**    * This is the serialization version of decimal to string conversion.    *<p>    * It adds trailing zeroes when the formatScale is greater than the current scale.  Or, it    * does round if the formatScale is less than the current scale.    *<p>    * Note that you can get more than 38 (MAX_PRECISION) digits in the output with this method.    *    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
name|int
name|toFormatBytes
parameter_list|(
name|int
name|formatScale
parameter_list|,
name|byte
index|[]
name|scratchBuffer
parameter_list|)
block|{
return|return
name|fastToFormatBytes
argument_list|(
name|formatScale
argument_list|,
name|scratchBuffer
argument_list|)
return|;
block|}
comment|/**    * Convert decimal to just the digits -- no dot.    *<p>    * Currently used by BinarySortable serialization.    *<p>    * A faster way to get just the digits than calling unscaledValue.toString().getBytes().    *    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
name|int
name|toDigitsOnlyBytes
parameter_list|(
name|byte
index|[]
name|scratchBuffer
parameter_list|)
block|{
return|return
name|fastToDigitsOnlyBytes
argument_list|(
name|scratchBuffer
argument_list|)
return|;
block|}
comment|//-----------------------------------------------------------------------------------------------
comment|// Comparison methods.
comment|//-----------------------------------------------------------------------------------------------
annotation|@
name|HiveDecimalVersionV1
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
name|HiveDecimal
name|dec
parameter_list|)
block|{
return|return
name|fastCompareTo
argument_list|(
name|dec
argument_list|)
return|;
block|}
comment|/**    * Hash code based on (new) decimal representation.    *<p>    * Faster than hashCode().    *<p>    * Used by map join and other Hive internal purposes where performance is important.    *<p>    * IMPORTANT: See comments for hashCode(), too.    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
name|int
name|newFasterHashCode
parameter_list|()
block|{
return|return
name|fastNewFasterHashCode
argument_list|()
return|;
block|}
comment|/**    * This is returns original hash code as returned by HiveDecimalV1.    *<p>    * We need this when the HiveDecimalV1 hash code has been exposed and and written or affected    * how data is written.    *<p>    * This method supports compatibility.    *<p>    * Examples: bucketing, Hive hash() function, and Hive statistics.    *<p>    * NOTE: It is necessary to create a BigDecimal object and use its hash code, so this method is    *       slow.    */
annotation|@
name|HiveDecimalVersionV1
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|fastHashCode
argument_list|()
return|;
block|}
comment|/**    * Are two decimal content (values) equal?    *<p>    * @param obj   The 2nd decimal.    * @return  When obj is null or not class HiveDecimal, the return is false.    *          Otherwise, returns true when the decimal values are exactly equal.    */
annotation|@
name|HiveDecimalVersionV1
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
literal|null
operator|||
name|obj
operator|.
name|getClass
argument_list|()
operator|!=
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|fastEquals
argument_list|(
operator|(
name|HiveDecimal
operator|)
name|obj
argument_list|)
return|;
block|}
comment|//-----------------------------------------------------------------------------------------------
comment|// Attribute methods.
comment|//-----------------------------------------------------------------------------------------------
comment|/**    * Returns the scale of the decimal.  Range 0 .. MAX_SCALE.    *    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|int
name|scale
parameter_list|()
block|{
return|return
name|fastScale
argument_list|()
return|;
block|}
comment|/**    * Returns the number of integer digits in the decimal.    *<p>    * When the integer portion is zero, this method returns 0.    *    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
name|int
name|integerDigitCount
parameter_list|()
block|{
return|return
name|fastIntegerDigitCount
argument_list|()
return|;
block|}
comment|/**    * Returns the number of digits (integer and fractional) in the number, which is equivalent    * to SQL decimal precision.    *<p>    * Note that this method is different from rawPrecision(), which returns the number of digits    * ignoring the scale.  Note that rawPrecision returns 0 when the value is 0.    *    *     Decimal            precision              rawPrecision    *        0                    1                         0    *        1                    1                         1    *       -7                    1                         1    *       0.1                   1                         1    *       0.04                  2                         1    *       0.00380               5                         3    *     104.0009                7                         7    *<p>    * If you just want the actual number of digits, use rawPrecision().    *    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|int
name|precision
parameter_list|()
block|{
return|return
name|fastSqlPrecision
argument_list|()
return|;
block|}
comment|// See comments for sqlPrecision.
annotation|@
name|HiveDecimalVersionV2
specifier|public
name|int
name|rawPrecision
parameter_list|()
block|{
return|return
name|fastRawPrecision
argument_list|()
return|;
block|}
comment|/**    * Get the sign of the decimal.    *<p>    * @return 0 if the decimal is equal to 0, -1 if less than zero, and 1 if greater than 0    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|int
name|signum
parameter_list|()
block|{
return|return
name|fastSignum
argument_list|()
return|;
block|}
comment|//-----------------------------------------------------------------------------------------------
comment|// Value conversion methods.
comment|//-----------------------------------------------------------------------------------------------
comment|/**    * Is the decimal value a byte? Range -128            to      127.    *                                    Byte.MIN_VALUE          Byte.MAX_VALUE    *<p>    * Emulates testing for no value corruption:    *      bigDecimalValue().setScale(0).equals(BigDecimal.valueOf(bigDecimalValue().byteValue()))    *<p>    * NOTE: Fractional digits are ignored in the test since byteValue() will    *       remove them (round down).    *<p>    * @return True when byteValue() will return a correct byte.    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
name|boolean
name|isByte
parameter_list|()
block|{
return|return
name|fastIsByte
argument_list|()
return|;
block|}
comment|/**    * A byte variation of longValue()    *<p>    * This method will return a corrupted value unless isByte() is true.    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|byte
name|byteValue
parameter_list|()
block|{
return|return
name|fastByteValueClip
argument_list|()
return|;
block|}
comment|/**    * Is the decimal value a short? Range -32,768         to     32,767.    *                                     Short.MIN_VALUE        Short.MAX_VALUE    *<p>    * Emulates testing for no value corruption:    *      bigDecimalValue().setScale(0).equals(BigDecimal.valueOf(bigDecimalValue().shortValue()))    *<p>    * NOTE: Fractional digits are ignored in the test since shortValue() will    *       remove them (round down).    *<p>    * @return True when shortValue() will return a correct short.    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
name|boolean
name|isShort
parameter_list|()
block|{
return|return
name|fastIsShort
argument_list|()
return|;
block|}
comment|/**    * A short variation of longValue().    *<p>    * This method will return a corrupted value unless isShort() is true.    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|short
name|shortValue
parameter_list|()
block|{
return|return
name|fastShortValueClip
argument_list|()
return|;
block|}
comment|/**    * Is the decimal value a int? Range -2,147,483,648     to   2,147,483,647.    *                                   Integer.MIN_VALUE       Integer.MAX_VALUE    *<p>    * Emulates testing for no value corruption:    *      bigDecimalValue().setScale(0).equals(BigDecimal.valueOf(bigDecimalValue().intValue()))    *<p>    * NOTE: Fractional digits are ignored in the test since intValue() will    *       remove them (round down).    *<p>    * @return True when intValue() will return a correct int.    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
name|boolean
name|isInt
parameter_list|()
block|{
return|return
name|fastIsInt
argument_list|()
return|;
block|}
comment|/**    * An int variation of longValue().    *<p>    * This method will return a corrupted value unless isInt() is true.    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|int
name|intValue
parameter_list|()
block|{
return|return
name|fastIntValueClip
argument_list|()
return|;
block|}
comment|/**    * Is the decimal value a long? Range -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.    *                                    Long.MIN_VALUE                Long.MAX_VALUE    *<p>    * Emulates testing for no value corruption:    *      bigDecimalValue().setScale(0).equals(BigDecimal.valueOf(bigDecimalValue().longValue()))    *<p>    * NOTE: Fractional digits are ignored in the test since longValue() will    *       remove them (round down).    *<p>    * @return True when longValue() will return a correct long.    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
name|boolean
name|isLong
parameter_list|()
block|{
return|return
name|fastIsLong
argument_list|()
return|;
block|}
comment|/**    * Return the long value of a decimal.    *<p>    * This method will return a corrupted value unless isLong() is true.    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|long
name|longValue
parameter_list|()
block|{
return|return
name|fastLongValueClip
argument_list|()
return|;
block|}
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|long
name|longValueExact
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isLong
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|()
throw|;
block|}
return|return
name|fastLongValueClip
argument_list|()
return|;
block|}
comment|/**    * Return a float representing the decimal.  Due the limitations of float, some values will not    * be accurate.    *    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|float
name|floatValue
parameter_list|()
block|{
return|return
name|fastFloatValue
argument_list|()
return|;
block|}
comment|/**    * Return a double representing the decimal.  Due the limitations of double, some values will not    * be accurate.    *    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|double
name|doubleValue
parameter_list|()
block|{
return|return
name|fastDoubleValue
argument_list|()
return|;
block|}
comment|/**    * Return a BigDecimal representing the decimal.  The BigDecimal class is able to accurately    * represent the decimal.    *    * NOTE: We are not representing our decimal as BigDecimal now as OldHiveDecimal did, so this    * is now slower.    *    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|BigDecimal
name|bigDecimalValue
parameter_list|()
block|{
return|return
name|fastBigDecimalValue
argument_list|()
return|;
block|}
comment|/**    * Get a BigInteger representing the decimal's digits without a dot.    *<p>    * @return Returns a signed BigInteger.    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|BigInteger
name|unscaledValue
parameter_list|()
block|{
return|return
name|fastBigIntegerValue
argument_list|()
return|;
block|}
comment|/**    * Return a decimal with only the fractional digits.    *<p>    * Zero is returned when there are no fractional digits (i.e. scale is 0).    *    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
name|HiveDecimal
name|fractionPortion
parameter_list|()
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
name|result
operator|.
name|fastFractionPortion
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Return a decimal with only the integer digits.    *<p>    * Any fractional digits are removed.  E.g. 2.083 scale 3 returns as 2 scale 0.    *    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
name|HiveDecimal
name|integerPortion
parameter_list|()
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
name|result
operator|.
name|fastIntegerPortion
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|//-----------------------------------------------------------------------------------------------
comment|// Math methods.
comment|//-----------------------------------------------------------------------------------------------
comment|/**    * Add the current decimal and another decimal and return the result.    *    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|HiveDecimal
name|add
parameter_list|(
name|HiveDecimal
name|dec
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fastAdd
argument_list|(
name|dec
argument_list|,
name|result
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Subtract from the current decimal another decimal and return the result.    *    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|HiveDecimal
name|subtract
parameter_list|(
name|HiveDecimal
name|dec
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fastSubtract
argument_list|(
name|dec
argument_list|,
name|result
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Multiply two decimals.    *<p>    * NOTE: Overflow Determination for Multiply    *<p>    *   OldDecimal.multiply performs the multiply with BigDecimal but DOES NOT ALLOW ROUNDING    *   (i.e. no throwing away lower fractional digits).    *<p>    *   CONSIDER: Allowing rounding.  This would eliminate cases today where we return null for    *             the multiplication result.    *<p>    * IMPLEMENTATION NOTE: HiveDecimalV1 code does this:    *<p>    * return create(bd.multiply(dec.bd), false);    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|HiveDecimal
name|multiply
parameter_list|(
name|HiveDecimal
name|dec
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fastMultiply
argument_list|(
name|dec
argument_list|,
name|result
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Multiplies a decimal by a power of 10.    *<p>    * The decimal 19350 scale 0 will return 193.5 scale 1 when power is -2 (negative).    *<p>    * The decimal 1.000923 scale 6 will return 10009.23 scale 2 when power is 4 (positive).    *<p>    * @param power    * @return Returns a HiveDecimal whose value is value * 10^power.    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|HiveDecimal
name|scaleByPowerOfTen
parameter_list|(
name|int
name|power
parameter_list|)
block|{
if|if
condition|(
name|power
operator|==
literal|0
operator|||
name|fastSignum
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// No change for multiply by 10^0 or value 0.
return|return
name|this
return|;
block|}
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fastScaleByPowerOfTen
argument_list|(
name|power
argument_list|,
name|result
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Take the absolute value of a decimal.    *<p>    * @return When the decimal is negative, returns a new HiveDecimal with the positive value.    *         Otherwise, returns the current 0 or positive value object;    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|HiveDecimal
name|abs
parameter_list|()
block|{
if|if
condition|(
name|fastSignum
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
name|this
return|;
block|}
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|result
operator|.
name|fastAbs
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Reverse the sign of a decimal.    *<p>    * @return Returns a new decimal with the sign flipped.  When the value is 0, the current    * object is returned.    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|HiveDecimal
name|negate
parameter_list|()
block|{
if|if
condition|(
name|fastSignum
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|this
return|;
block|}
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|result
operator|.
name|fastNegate
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|//-----------------------------------------------------------------------------------------------
comment|// Rounding / setScale methods.
comment|//-----------------------------------------------------------------------------------------------
comment|/**    * DEPRECATED for V2.    *<p>    * Create a decimal from another decimal whose only change is it is MARKED and will display /    * serialize with a specified scale that will add trailing zeroes (or round) if necessary.    *<p>    * After display / serialization, the MARKED object is typically thrown away.    *<p>    * A MARKED decimal ONLY affects these 2 methods since these were the only ways setScale was    * used in the old code.    *<p>    *    toString    *    unscaleValue    *<p>    * This method has been deprecated because has poor performance by creating a throw away object.    *<p>    * For setScale(scale).toString() use toFormatString(scale) instead.    * For setScale(scale).unscaledValue().toByteArray() use V2 bigIntegerBytesScaled(scale) instead.    *<p>    * For better performance, use the V2 form of toFormatString that takes a scratch buffer,    * or even better use toFormatBytes.    *<p>    * And, use the form of bigIntegerBytesScaled that takes scratch objects for better performance.    *    */
annotation|@
name|Deprecated
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|HiveDecimal
name|setScale
parameter_list|(
name|int
name|serializationScale
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|result
operator|.
name|fastSetSerializationScale
argument_list|(
name|serializationScale
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Do decimal rounding and return the result.    *<p>    * When the roundingPoint is 0 or positive, we round away lower fractional digits if the    * roundingPoint is less than current scale.  In this case, we will round the result using the    * specified rounding mode.    *<p>    * When the roundingPoint is negative, the rounding will occur within the integer digits.  Integer    * digits below the roundPoint will be cleared.  If the rounding occurred, a one will be added    * just above the roundingPoint.  Note this may cause overflow.    *<p>    * No effect when the roundingPoint equals the current scale.  The current object is returned.    *<p>    * The name setScale is taken from BigDecimal.setScale -- a better name would have been round.    *    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|HiveDecimal
name|setScale
parameter_list|(
name|int
name|roundingPoint
parameter_list|,
name|int
name|roundingMode
parameter_list|)
block|{
if|if
condition|(
name|fastScale
argument_list|()
operator|==
name|roundingPoint
condition|)
block|{
comment|// No change.
return|return
name|this
return|;
block|}
comment|// Even if we are just setting the scale when newScale is greater than the current scale,
comment|// we need a new object to obey our immutable behavior.
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fastRound
argument_list|(
name|roundingPoint
argument_list|,
name|roundingMode
argument_list|,
name|result
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Return the result of decimal^exponent    *<p>    * CONSIDER: Currently, negative exponent is not supported.    * CONSIDER: Does anybody use this method?    *    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|HiveDecimal
name|pow
parameter_list|(
name|int
name|exponent
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fastPow
argument_list|(
name|exponent
argument_list|,
name|result
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Divides this decimal by another decimal and returns a new decimal with the result.    *    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|HiveDecimal
name|divide
parameter_list|(
name|HiveDecimal
name|divisor
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fastDivide
argument_list|(
name|divisor
argument_list|,
name|result
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Divides this decimal by another decimal and returns a new decimal with the remainder of the    * division.    *<p>    * value is (decimal % divisor)    *<p>    * The remainder is equivalent to BigDecimal:    *    bigDecimalValue().subtract(bigDecimalValue().divideToIntegralValue(divisor).multiply(divisor))    *    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
name|HiveDecimal
name|remainder
parameter_list|(
name|HiveDecimal
name|divisor
parameter_list|)
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fastRemainder
argument_list|(
name|divisor
argument_list|,
name|result
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|//-----------------------------------------------------------------------------------------------
comment|// Precision/scale enforcement methods.
comment|//-----------------------------------------------------------------------------------------------
comment|/**    * Determine if a decimal fits within a specified maxPrecision and maxScale, and round    * off fractional digits if necessary to make the decimal fit.    *<p>    * The relationship between the enforcement maxPrecision and maxScale is restricted. The    * specified maxScale must be less than or equal to the maxPrecision.    *<p>    * Normally, decimals that result from creation operation, arithmetic operations, etc are    * "free range" up to MAX_PRECISION and MAX_SCALE.  Each operation checks if the result decimal    * is beyond MAX_PRECISION and MAX_SCALE.  If so the result decimal is rounded off using    * ROUND_HALF_UP.  If the round digit is 5 or more, one is added to the lowest remaining digit.    * The round digit is the digit just below the round point. Result overflow can occur if a    * result decimal's integer portion exceeds MAX_PRECISION.    *<p>    * This method supports enforcing to a declared Hive DECIMAL's precision/scale.    * E.g. DECIMAL(10,4)    *<p>    * Here are the enforcement/rounding checks of this method:    *<p>    *   1) Maximum integer digits = maxPrecision - maxScale    *<p>    *      If the decimal's integer digit count exceeds this, the decimal does not fit (overflow).    *<p>    *   2) If decimal's scale is greater than maxScale, then excess fractional digits are    *      rounded off.  When rounding increases the remaining decimal, it may exceed the    *      limits and overflow.    *<p>    * @param dec    * @param maxPrecision    * @param maxScale    * @return The original decimal if no adjustment is necessary.    *         A rounded off decimal if adjustment was necessary.    *         Otherwise, null if the decimal doesn't fit within maxPrecision / maxScale or rounding    *         caused a result that exceeds the specified limits or MAX_PRECISION integer digits.    */
annotation|@
name|HiveDecimalVersionV1
specifier|public
specifier|static
name|HiveDecimal
name|enforcePrecisionScale
parameter_list|(
name|HiveDecimal
name|dec
parameter_list|,
name|int
name|maxPrecision
parameter_list|,
name|int
name|maxScale
parameter_list|)
block|{
if|if
condition|(
name|maxPrecision
argument_list|<
literal|1
operator|||
name|maxPrecision
argument_list|>
name|MAX_PRECISION
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|STRING_ENFORCE_PRECISION_OUT_OF_RANGE
argument_list|)
throw|;
block|}
if|if
condition|(
name|maxScale
argument_list|<
literal|0
operator|||
name|maxScale
argument_list|>
name|HiveDecimal
operator|.
name|MAX_SCALE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|STRING_ENFORCE_SCALE_OUT_OF_RANGE
argument_list|)
throw|;
block|}
if|if
condition|(
name|maxPrecision
operator|<
name|maxScale
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|STRING_ENFORCE_SCALE_LESS_THAN_EQUAL_PRECISION
argument_list|)
throw|;
block|}
if|if
condition|(
name|dec
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|FastCheckPrecisionScaleStatus
name|status
init|=
name|dec
operator|.
name|fastCheckPrecisionScale
argument_list|(
name|maxPrecision
argument_list|,
name|maxScale
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|NO_CHANGE
case|:
return|return
name|dec
return|;
case|case
name|OVERFLOW
case|:
return|return
literal|null
return|;
case|case
name|UPDATE_SCALE_DOWN
case|:
block|{
name|HiveDecimal
name|result
init|=
operator|new
name|HiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dec
operator|.
name|fastUpdatePrecisionScale
argument_list|(
name|maxPrecision
argument_list|,
name|maxScale
argument_list|,
name|status
argument_list|,
name|result
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown fast decimal check precision and scale status "
operator|+
name|status
argument_list|)
throw|;
block|}
block|}
comment|//-----------------------------------------------------------------------------------------------
comment|// Validation methods.
comment|//-----------------------------------------------------------------------------------------------
comment|/**    * Throws an exception if the current decimal value is invalid.    */
annotation|@
name|HiveDecimalVersionV2
specifier|public
name|void
name|validate
parameter_list|()
block|{
if|if
condition|(
operator|!
name|fastIsValid
argument_list|()
condition|)
block|{
name|fastRaiseInvalidException
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

