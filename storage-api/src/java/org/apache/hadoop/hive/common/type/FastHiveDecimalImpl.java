begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|RoundingMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_comment
comment|/**  *    This class is a companion to the FastHiveDecimal class that separates the essential of code  *    out of FastHiveDecimal into static methods in this class so that they can be used directly  *    by vectorization to implement decimals by storing the fast0, fast1, and fast2 longs and  *    the fastSignum, fastScale, etc ints in the DecimalColumnVector class.  */
end_comment

begin_class
specifier|public
class|class
name|FastHiveDecimalImpl
extends|extends
name|FastHiveDecimal
block|{
comment|/**    * Representation of fast decimals.    *    * We use 3 long words to store the 38 digits of fast decimals and and 3 integers for sign,    * integer digit count, and scale.    *    * The lower and middle long words store 16 decimal digits each; the high long word has    * 6 decimal digits; total 38 decimal digits.    *    * We do not try and represent fast decimal value as an unsigned 128 bit binary number in 2 longs.    * There are several important reasons for this.    *    * The effort to represent an unsigned 128 integer in 2 Java signed longs is very difficult,    * error prone, hard to debug, and not worth the effort.    *    * The focus here is on reusing memory (i.e. with HiveDecimalWritable) as often as possible.    * Reusing memory is good for grouping of fast decimal objects and related objects in CPU cache    * lines for fast memory access and eliminating the cost of allocating temporary objects and    * reducing the global cost of garbage collection.    *    * In other words, we are focused on avoiding the poor performance of Java general immutable    * objects.    *    * Reducing memory size or being concerned about the memory size of using 3 longs vs. 2 longs    * for 128 unsigned bits is not the focus here.    *    * Besides focusing on reusing memory, storing a limited number (16) decimal digits in the longs    * rather than compacting the value into all binary bits of 2 longs has a surprising benefit.    *    * One big part of implementing decimals turns out to be manipulating decimal digits.    *    * For example, rounding a decimal involves trimming off lower digits or clearing lower digits.    * Since radix 10 digits cannot be masked with binary masks, we use division and multiplication    * using powers of 10.  We can easily manipulate the decimal digits in a long word using simple    * integer multiplication / division without doing emulated 128 binary bit multiplication /    * division (e.g. the defunct Decimal128 class).    *    * For example, say we want to scale (round) down the fraction digits of a decimal.    *    *      final long divideFactor = powerOfTenTable[scaleDown];    *      final long multiplyFactor = powerOfTenTable[LONGWORD_DECIMAL_DIGITS - scaleDown];    *    *      result0 =    *          fast0 / divideFactor    *        + ((fast1 % divideFactor) * multiplyFactor);    *      result1 =    *          fast1 / divideFactor    *        + ((fast2 % divideFactor) * multiplyFactor);    *      result2 =    *          fast2 / divideFactor;    *    * It also turns out to do addition and subtraction of decimals with different scales can involve    * overlap using more than 3 long words.  Manipulating extra words is a natural extension of    * the existing techniques.    *    * Why is the decimal digits representation easier to debug?  You can see the decimal digits in    * the 3 long words and do not have to convert binary words to decimal to see the value.    *    * 16 decimal digits for a long was choose so that an int can have 1/2 or 8 decimal digits during    * multiplication of int half words so intermediate multiplication results do not overflow a long.    * And, so addition overflow is well below the sign bit of a long.    */
comment|// Code Sections:
comment|//   Initialize (fastSetFrom*).
comment|//   Take Integer or Fractional Portion.
comment|//   Binary to Decimal Conversion.
comment|//   Decimal to Binary Conversion.r
comment|//   Emulate SerializationUtils Deserialization used by ORC.
comment|//   Emulate SerializationUtils Serialization used by ORC.
comment|//   Emulate BigInteger Deserialization used by LazyBinary and others.
comment|//   Emulate BigInteger Serialization used by LazyBinary and others.
comment|//   Decimal to Integer Conversion.
comment|//   Decimal to Non-Integer Conversion.
comment|//   Decimal Comparison.
comment|//   Decimal Rounding.
comment|//   Decimal Scale Up/Down.
comment|//   Decimal Precision / Trailing Zeroes.
comment|//   Decimal Addition / Subtraction.
comment|//   Decimal Multiply.
comment|//   Decimal Division / Remainder.
comment|//   Decimal String Formatting.
comment|//   Decimal Validation.
comment|//   Decimal Debugging.
specifier|private
specifier|static
specifier|final
name|long
index|[]
name|powerOfTenTable
init|=
block|{
literal|1L
block|,
comment|// 0
literal|10L
block|,
literal|100L
block|,
literal|1000L
block|,
literal|10000L
block|,
literal|100000L
block|,
literal|1000000L
block|,
literal|10000000L
block|,
literal|100000000L
block|,
comment|// 8
literal|1000000000L
block|,
literal|10000000000L
block|,
literal|100000000000L
block|,
literal|1000000000000L
block|,
literal|10000000000000L
block|,
literal|100000000000000L
block|,
literal|1000000000000000L
block|,
literal|10000000000000000L
comment|// 16
block|}
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|MAX_DECIMAL_DIGITS
init|=
literal|38
decl_stmt|;
comment|/**    * Int: 8 decimal digits.  An even number and 1/2 of MAX_LONGWORD_DECIMAL.    */
specifier|private
specifier|static
specifier|final
name|int
name|INTWORD_DECIMAL_DIGITS
init|=
literal|8
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|MAX_INTWORD_DECIMAL
init|=
operator|(
name|int
operator|)
name|powerOfTenTable
index|[
name|INTWORD_DECIMAL_DIGITS
index|]
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|MULTIPLER_INTWORD_DECIMAL
init|=
operator|(
name|int
operator|)
name|powerOfTenTable
index|[
name|INTWORD_DECIMAL_DIGITS
index|]
decl_stmt|;
comment|/**    * Long: 16 decimal digits.  An even number and twice MAX_INTWORD_DECIMAL.    */
specifier|private
specifier|static
specifier|final
name|int
name|LONGWORD_DECIMAL_DIGITS
init|=
literal|16
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|MAX_LONGWORD_DECIMAL
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
index|]
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|MULTIPLER_LONGWORD_DECIMAL
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
index|]
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|TWO_X_LONGWORD_DECIMAL_DIGITS
init|=
literal|2
operator|*
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|THREE_X_LONGWORD_DECIMAL_DIGITS
init|=
literal|3
operator|*
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|FOUR_X_LONGWORD_DECIMAL_DIGITS
init|=
literal|4
operator|*
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
comment|// 38 decimal maximum - 32 digits in 2 lower longs (6 digits here).
specifier|private
specifier|static
specifier|final
name|int
name|HIGHWORD_DECIMAL_DIGITS
init|=
name|MAX_DECIMAL_DIGITS
operator|-
name|TWO_X_LONGWORD_DECIMAL_DIGITS
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|MAX_HIGHWORD_DECIMAL
init|=
name|powerOfTenTable
index|[
name|HIGHWORD_DECIMAL_DIGITS
index|]
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|static
name|long
name|HIGHWORD_DIVIDE_FACTOR
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|HIGHWORD_DECIMAL_DIGITS
index|]
decl_stmt|;
specifier|private
specifier|static
name|long
name|HIGHWORD_MULTIPLY_FACTOR
init|=
name|powerOfTenTable
index|[
name|HIGHWORD_DECIMAL_DIGITS
index|]
decl_stmt|;
comment|// 38 * 2 or 76 full decimal maximum - (64 + 8) digits in 4 lower longs (4 digits here).
specifier|private
specifier|static
specifier|final
name|long
name|FULL_MAX_HIGHWORD_DECIMAL
init|=
name|powerOfTenTable
index|[
name|MAX_DECIMAL_DIGITS
operator|*
literal|2
operator|-
operator|(
name|FOUR_X_LONGWORD_DECIMAL_DIGITS
operator|+
name|INTWORD_DECIMAL_DIGITS
operator|)
index|]
operator|-
literal|1
decl_stmt|;
comment|/**    * BigInteger constants.    */
specifier|private
specifier|static
specifier|final
name|BigInteger
name|BIG_INTEGER_TWO
init|=
name|BigInteger
operator|.
name|valueOf
argument_list|(
literal|2
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|BigInteger
name|BIG_INTEGER_FIVE
init|=
name|BigInteger
operator|.
name|valueOf
argument_list|(
literal|5
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|BigInteger
name|BIG_INTEGER_TEN
init|=
name|BigInteger
operator|.
name|valueOf
argument_list|(
literal|10
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|BigInteger
name|BIG_INTEGER_MAX_DECIMAL
init|=
name|BIG_INTEGER_TEN
operator|.
name|pow
argument_list|(
name|MAX_DECIMAL_DIGITS
argument_list|)
operator|.
name|subtract
argument_list|(
name|BigInteger
operator|.
name|ONE
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|BigInteger
name|BIG_INTEGER_MAX_LONGWORD_DECIMAL
init|=
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|MAX_LONGWORD_DECIMAL
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|BigInteger
name|BIG_INTEGER_LONGWORD_MULTIPLIER
init|=
name|BigInteger
operator|.
name|ONE
operator|.
name|add
argument_list|(
name|BIG_INTEGER_MAX_LONGWORD_DECIMAL
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|BigInteger
name|BIG_INTEGER_LONGWORD_MULTIPLIER_2X
init|=
name|BIG_INTEGER_LONGWORD_MULTIPLIER
operator|.
name|multiply
argument_list|(
name|BIG_INTEGER_LONGWORD_MULTIPLIER
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|BigInteger
name|BIG_INTEGER_LONGWORD_MULTIPLIER_3X
init|=
name|BIG_INTEGER_LONGWORD_MULTIPLIER_2X
operator|.
name|multiply
argument_list|(
name|BIG_INTEGER_LONGWORD_MULTIPLIER
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|BigInteger
name|BIG_INTEGER_LONGWORD_MULTIPLIER_4X
init|=
name|BIG_INTEGER_LONGWORD_MULTIPLIER_3X
operator|.
name|multiply
argument_list|(
name|BIG_INTEGER_LONGWORD_MULTIPLIER
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|BigInteger
name|BIG_INTEGER_MAX_HIGHWORD_DECIMAL
init|=
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|MAX_HIGHWORD_DECIMAL
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|BigInteger
name|BIG_INTEGER_HIGHWORD_MULTIPLIER
init|=
name|BigInteger
operator|.
name|ONE
operator|.
name|add
argument_list|(
name|BIG_INTEGER_MAX_HIGHWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// UTF-8 byte constants used by string/UTF-8 bytes to decimal and decimal to String/UTF-8 byte
comment|// conversion.
comment|// There is only one blank in UTF-8.
specifier|private
specifier|final
specifier|static
name|byte
name|BYTE_BLANK
init|=
operator|(
name|byte
operator|)
literal|' '
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|byte
name|BYTE_DIGIT_ZERO
init|=
operator|(
name|byte
operator|)
literal|'0'
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|byte
name|BYTE_DIGIT_NINE
init|=
operator|(
name|byte
operator|)
literal|'9'
decl_stmt|;
comment|// Decimal point.
specifier|private
specifier|final
specifier|static
name|byte
name|BYTE_DOT
init|=
operator|(
name|byte
operator|)
literal|'.'
decl_stmt|;
comment|// Sign.
specifier|private
specifier|final
specifier|static
name|byte
name|BYTE_MINUS
init|=
operator|(
name|byte
operator|)
literal|'-'
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|byte
name|BYTE_PLUS
init|=
operator|(
name|byte
operator|)
literal|'+'
decl_stmt|;
comment|// Exponent E or e.
specifier|private
specifier|final
specifier|static
name|byte
name|BYTE_EXPONENT_LOWER
init|=
operator|(
name|byte
operator|)
literal|'e'
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|byte
name|BYTE_EXPONENT_UPPER
init|=
operator|(
name|byte
operator|)
literal|'E'
decl_stmt|;
comment|//************************************************************************************************
comment|// Initialize (fastSetFrom*).
comment|/*    * All of the fastSetFrom* methods require the caller to pass a fastResult parameter has been    * reset for better performance.    */
specifier|private
specifier|static
name|void
name|doRaiseSetFromBytesInvalid
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
specifier|final
name|int
name|end
init|=
name|offset
operator|+
name|length
decl_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid fast decimal \""
operator|+
operator|new
name|String
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|end
argument_list|)
operator|+
literal|"\""
operator|+
literal|" fastSignum "
operator|+
name|fastResult
operator|.
name|fastSignum
operator|+
literal|" fast0 "
operator|+
name|fastResult
operator|.
name|fast0
operator|+
literal|" fast1 "
operator|+
name|fastResult
operator|.
name|fast1
operator|+
literal|" fast2 "
operator|+
name|fastResult
operator|.
name|fast2
operator|+
literal|" fastIntegerDigitCount "
operator|+
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|+
literal|" fastScale "
operator|+
name|fastResult
operator|.
name|fastScale
operator|+
literal|" stack trace: "
operator|+
name|getStackTraceAsSingleLine
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getStackTrace
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|/**    * Scan a byte array slice for a decimal number in UTF-8 bytes.    *    * Syntax:    *   [+|-][integerPortion][.[fractionalDigits]][{E|e}[+|-]exponent]    *                                                  // Where at least one integer or fractional    *                                                  // digit is required...    *    * We handle too many fractional digits by doing rounding ROUND_HALF_UP.    *    * NOTE: The fastSetFromBytes method requires the caller to pass a fastResult parameter has been    * reset for better performance.    *    * @param fastResult  True if the byte array slice was successfully converted to a decimal.    * @return    */
specifier|public
specifier|static
name|boolean
name|fastSetFromBytes
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|trimBlanks
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
specifier|final
name|int
name|bytesLength
init|=
name|bytes
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|offset
operator|>=
name|bytesLength
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|end
init|=
name|offset
operator|+
name|length
decl_stmt|;
if|if
condition|(
name|end
operator|<=
name|offset
operator|||
name|end
operator|>
name|bytesLength
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// We start here with at least one byte.
name|int
name|index
init|=
name|offset
decl_stmt|;
if|if
condition|(
name|trimBlanks
condition|)
block|{
while|while
condition|(
name|bytes
index|[
name|index
index|]
operator|==
name|BYTE_BLANK
condition|)
block|{
if|if
condition|(
operator|++
name|index
operator|>=
name|end
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
comment|// Started with a few ideas from BigDecimal(char[] in, int offset, int len) constructor...
comment|// But soon became very fast decimal specific.
name|boolean
name|isNegative
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|bytes
index|[
name|index
index|]
operator|==
name|BYTE_MINUS
condition|)
block|{
name|isNegative
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|++
name|index
operator|>=
name|end
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|bytes
index|[
name|index
index|]
operator|==
name|BYTE_PLUS
condition|)
block|{
if|if
condition|(
operator|++
name|index
operator|>=
name|end
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|int
name|precision
init|=
literal|0
decl_stmt|;
comment|// We fill starting with highest digit in highest longword (HIGHWORD_DECIMAL_DIGITS) and
comment|// move down.  At end will will shift everything down if necessary.
name|int
name|longWordIndex
init|=
literal|0
decl_stmt|;
comment|// Where 0 is the highest longword; 1 is middle longword, etc.
name|int
name|digitNum
init|=
name|HIGHWORD_DECIMAL_DIGITS
decl_stmt|;
name|long
name|multiplier
init|=
name|powerOfTenTable
index|[
name|HIGHWORD_DECIMAL_DIGITS
operator|-
literal|1
index|]
decl_stmt|;
name|int
name|digitValue
init|=
literal|0
decl_stmt|;
name|long
name|longWord
init|=
literal|0
decl_stmt|;
name|long
name|fast0
init|=
literal|0
decl_stmt|;
name|long
name|fast1
init|=
literal|0
decl_stmt|;
name|long
name|fast2
init|=
literal|0
decl_stmt|;
name|byte
name|work
decl_stmt|;
comment|// Parse integer portion.
name|boolean
name|haveInteger
init|=
literal|false
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|work
operator|=
name|bytes
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|work
argument_list|<
name|BYTE_DIGIT_ZERO
operator|||
name|work
argument_list|>
name|BYTE_DIGIT_NINE
condition|)
block|{
break|break;
block|}
name|haveInteger
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|precision
operator|==
literal|0
operator|&&
name|work
operator|==
name|BYTE_DIGIT_ZERO
condition|)
block|{
comment|// Ignore leading zeroes.
if|if
condition|(
operator|++
name|index
operator|>=
name|end
condition|)
block|{
break|break;
block|}
continue|continue;
block|}
name|digitValue
operator|=
name|work
operator|-
name|BYTE_DIGIT_ZERO
expr_stmt|;
if|if
condition|(
name|digitNum
operator|==
literal|0
condition|)
block|{
comment|// Integer parsing move to next lower longword.
comment|// Save previous longword.
if|if
condition|(
name|longWordIndex
operator|==
literal|0
condition|)
block|{
name|fast2
operator|=
name|longWord
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|longWordIndex
operator|==
literal|1
condition|)
block|{
name|fast1
operator|=
name|longWord
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|longWordIndex
operator|==
literal|2
condition|)
block|{
comment|// We have filled HiveDecimal.MAX_PRECISION digits and have no more room in our limit precision
comment|// fast decimal.
return|return
literal|false
return|;
block|}
name|longWordIndex
operator|++
expr_stmt|;
comment|// The middle and lowest longwords highest digit number is LONGWORD_DECIMAL_DIGITS.
name|digitNum
operator|=
name|LONGWORD_DECIMAL_DIGITS
expr_stmt|;
name|multiplier
operator|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
literal|1
index|]
expr_stmt|;
name|longWord
operator|=
literal|0
expr_stmt|;
block|}
name|longWord
operator|+=
name|digitValue
operator|*
name|multiplier
expr_stmt|;
name|multiplier
operator|/=
literal|10
expr_stmt|;
name|digitNum
operator|--
expr_stmt|;
name|precision
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|index
operator|>=
name|end
condition|)
block|{
break|break;
block|}
block|}
comment|// At this point we may have parsed an integer.
comment|// Try to eat a dot now since it could be the end.  We remember if we saw a dot so we can
comment|// do error checking later and detect just a dot.
name|boolean
name|sawDot
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|index
operator|<
name|end
operator|&&
name|bytes
index|[
name|index
index|]
operator|==
name|BYTE_DOT
condition|)
block|{
name|sawDot
operator|=
literal|true
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
comment|// Try to eat trailing blank padding.
if|if
condition|(
name|trimBlanks
operator|&&
name|index
operator|<
name|end
operator|&&
name|bytes
index|[
name|index
index|]
operator|==
name|BYTE_BLANK
condition|)
block|{
name|index
operator|++
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|end
operator|&&
name|bytes
index|[
name|index
index|]
operator|==
name|BYTE_BLANK
condition|)
block|{
name|index
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|<
name|end
condition|)
block|{
comment|// Junk after trailing blank padding.
return|return
literal|false
return|;
block|}
comment|// Otherwise, fall through and process the what we saw before possible trailing blanks.
block|}
comment|// Any more input?
if|if
condition|(
name|index
operator|>=
name|end
condition|)
block|{
comment|// We hit the end after getting optional integer and optional dot and optional blank padding.
if|if
condition|(
operator|!
name|haveInteger
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|precision
operator|==
literal|0
condition|)
block|{
comment|// We just had leading zeroes (and possibly a dot and trailing blanks).
comment|// Value is 0.
return|return
literal|true
return|;
block|}
comment|// Save last longword.
if|if
condition|(
name|longWordIndex
operator|==
literal|0
condition|)
block|{
name|fast2
operator|=
name|longWord
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|longWordIndex
operator|==
literal|1
condition|)
block|{
name|fast1
operator|=
name|longWord
expr_stmt|;
block|}
else|else
block|{
name|fast0
operator|=
name|longWord
expr_stmt|;
block|}
name|fastResult
operator|.
name|fastSignum
operator|=
operator|(
name|isNegative
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
expr_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|precision
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
literal|0
expr_stmt|;
specifier|final
name|int
name|scaleDown
init|=
name|HiveDecimal
operator|.
name|MAX_PRECISION
operator|-
name|precision
decl_stmt|;
if|if
condition|(
name|scaleDown
operator|>
literal|0
condition|)
block|{
name|doFastScaleDown
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scaleDown
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fast0
operator|=
name|fast0
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|fast1
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|fast2
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|// We have more input but did we start with something valid?
if|if
condition|(
operator|!
name|haveInteger
operator|&&
operator|!
name|sawDot
condition|)
block|{
comment|// Must have one of those at this point.
return|return
literal|false
return|;
block|}
name|int
name|integerDigitCount
init|=
name|precision
decl_stmt|;
name|int
name|nonTrailingZeroScale
init|=
literal|0
decl_stmt|;
name|boolean
name|roundingNecessary
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|sawDot
condition|)
block|{
comment|// Parse fraction portion.
while|while
condition|(
literal|true
condition|)
block|{
name|work
operator|=
name|bytes
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|work
argument_list|<
name|BYTE_DIGIT_ZERO
operator|||
name|work
argument_list|>
name|BYTE_DIGIT_NINE
condition|)
block|{
if|if
condition|(
operator|!
name|haveInteger
condition|)
block|{
comment|// Naked dot.
return|return
literal|false
return|;
block|}
break|break;
block|}
name|digitValue
operator|=
name|work
operator|-
name|BYTE_DIGIT_ZERO
expr_stmt|;
if|if
condition|(
name|digitNum
operator|==
literal|0
condition|)
block|{
comment|// Fraction digit parsing move to next lower longword.
comment|// Save previous longword.
if|if
condition|(
name|longWordIndex
operator|==
literal|0
condition|)
block|{
name|fast2
operator|=
name|longWord
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|longWordIndex
operator|==
literal|1
condition|)
block|{
name|fast1
operator|=
name|longWord
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|longWordIndex
operator|==
literal|2
condition|)
block|{
comment|// We have filled HiveDecimal.MAX_PRECISION digits and have no more room in our limit precision
comment|// fast decimal.  However, since we are processing fractional digits, we do rounding.
comment|// away.
if|if
condition|(
name|digitValue
operator|>=
literal|5
condition|)
block|{
name|roundingNecessary
operator|=
literal|true
expr_stmt|;
block|}
comment|// Scan through any remaining digits...
while|while
condition|(
operator|++
name|index
operator|<
name|end
condition|)
block|{
name|work
operator|=
name|bytes
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|work
argument_list|<
name|BYTE_DIGIT_ZERO
operator|||
name|work
argument_list|>
name|BYTE_DIGIT_NINE
condition|)
block|{
break|break;
block|}
block|}
break|break;
block|}
name|longWordIndex
operator|++
expr_stmt|;
name|digitNum
operator|=
name|LONGWORD_DECIMAL_DIGITS
expr_stmt|;
name|multiplier
operator|=
name|powerOfTenTable
index|[
name|digitNum
operator|-
literal|1
index|]
expr_stmt|;
name|longWord
operator|=
literal|0
expr_stmt|;
block|}
name|longWord
operator|+=
name|digitValue
operator|*
name|multiplier
expr_stmt|;
name|multiplier
operator|/=
literal|10
expr_stmt|;
name|digitNum
operator|--
expr_stmt|;
name|precision
operator|++
expr_stmt|;
if|if
condition|(
name|digitValue
operator|!=
literal|0
condition|)
block|{
name|nonTrailingZeroScale
operator|=
name|precision
operator|-
name|integerDigitCount
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|index
operator|>=
name|end
condition|)
block|{
break|break;
block|}
block|}
block|}
name|boolean
name|haveExponent
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|index
operator|<
name|end
operator|&&
operator|(
name|bytes
index|[
name|index
index|]
operator|==
name|BYTE_EXPONENT_UPPER
operator|||
name|bytes
index|[
name|index
index|]
operator|==
name|BYTE_EXPONENT_LOWER
operator|)
condition|)
block|{
name|haveExponent
operator|=
literal|true
expr_stmt|;
name|index
operator|++
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|end
condition|)
block|{
comment|// More required.
return|return
literal|false
return|;
block|}
block|}
comment|// At this point we have a number.  Save it in fastResult.  Round it.  If we have an exponent,
comment|// we will do a power 10 operation on fastResult.
comment|// Save last longword.
if|if
condition|(
name|longWordIndex
operator|==
literal|0
condition|)
block|{
name|fast2
operator|=
name|longWord
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|longWordIndex
operator|==
literal|1
condition|)
block|{
name|fast1
operator|=
name|longWord
expr_stmt|;
block|}
else|else
block|{
name|fast0
operator|=
name|longWord
expr_stmt|;
block|}
name|int
name|trailingZeroesScale
init|=
name|precision
operator|-
name|integerDigitCount
decl_stmt|;
if|if
condition|(
name|integerDigitCount
operator|==
literal|0
operator|&&
name|nonTrailingZeroScale
operator|==
literal|0
condition|)
block|{
comment|// Zero(es).
block|}
else|else
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
operator|(
name|isNegative
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
expr_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|integerDigitCount
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
name|nonTrailingZeroScale
expr_stmt|;
specifier|final
name|int
name|trailingZeroCount
init|=
name|trailingZeroesScale
operator|-
name|fastResult
operator|.
name|fastScale
decl_stmt|;
specifier|final
name|int
name|scaleDown
init|=
name|HiveDecimal
operator|.
name|MAX_PRECISION
operator|-
name|precision
operator|+
name|trailingZeroCount
decl_stmt|;
if|if
condition|(
name|scaleDown
operator|>
literal|0
condition|)
block|{
name|doFastScaleDown
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scaleDown
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fast0
operator|=
name|fast0
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|fast1
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|fast2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|roundingNecessary
condition|)
block|{
if|if
condition|(
name|fastResult
operator|.
name|fastSignum
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
operator|(
name|isNegative
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
expr_stmt|;
name|fastResult
operator|.
name|fast0
operator|=
literal|1
expr_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
literal|0
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
name|HiveDecimal
operator|.
name|MAX_SCALE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|fastAdd
argument_list|(
name|fastResult
operator|.
name|fastSignum
argument_list|,
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
name|fastResult
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastResult
operator|.
name|fastScale
argument_list|,
name|fastResult
operator|.
name|fastSignum
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|trailingZeroesScale
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|haveExponent
condition|)
block|{
comment|// Try to eat trailing blank padding.
if|if
condition|(
name|trimBlanks
operator|&&
name|index
operator|<
name|end
operator|&&
name|bytes
index|[
name|index
index|]
operator|==
name|BYTE_BLANK
condition|)
block|{
name|index
operator|++
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|end
operator|&&
name|bytes
index|[
name|index
index|]
operator|==
name|BYTE_BLANK
condition|)
block|{
name|index
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|index
operator|<
name|end
condition|)
block|{
comment|// Junk after trailing blank padding.
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|// At this point, we have seen the exponent letter E or e and have decimal information as:
comment|//     isNegative, precision, integerDigitCount, nonTrailingZeroScale, and
comment|//     fast0, fast1, fast2.
comment|//
comment|// After we determine the exponent, we will do appropriate scaling and fill in fastResult.
name|boolean
name|isExponentNegative
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|bytes
index|[
name|index
index|]
operator|==
name|BYTE_MINUS
condition|)
block|{
name|isExponentNegative
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|++
name|index
operator|>=
name|end
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|bytes
index|[
name|index
index|]
operator|==
name|BYTE_PLUS
condition|)
block|{
if|if
condition|(
operator|++
name|index
operator|>=
name|end
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|long
name|exponent
init|=
literal|0
decl_stmt|;
name|multiplier
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|work
operator|=
name|bytes
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|work
argument_list|<
name|BYTE_DIGIT_ZERO
operator|||
name|work
argument_list|>
name|BYTE_DIGIT_NINE
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|multiplier
operator|>
literal|10
condition|)
block|{
comment|// Power of ten way beyond our precision/scale...
return|return
literal|false
return|;
block|}
name|digitValue
operator|=
name|work
operator|-
name|BYTE_DIGIT_ZERO
expr_stmt|;
if|if
condition|(
name|digitValue
operator|!=
literal|0
operator|||
name|exponent
operator|!=
literal|0
condition|)
block|{
name|exponent
operator|=
name|exponent
operator|*
literal|10
operator|+
name|digitValue
expr_stmt|;
name|multiplier
operator|*=
literal|10
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|index
operator|>=
name|end
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|isExponentNegative
condition|)
block|{
name|exponent
operator|=
operator|-
name|exponent
expr_stmt|;
block|}
comment|// Try to eat trailing blank padding.
if|if
condition|(
name|trimBlanks
operator|&&
name|index
operator|<
name|end
operator|&&
name|bytes
index|[
name|index
index|]
operator|==
name|BYTE_BLANK
condition|)
block|{
name|index
operator|++
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|end
operator|&&
name|bytes
index|[
name|index
index|]
operator|==
name|BYTE_BLANK
condition|)
block|{
name|index
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|index
operator|<
name|end
condition|)
block|{
comment|// Junk after exponent.
return|return
literal|false
return|;
block|}
if|if
condition|(
name|integerDigitCount
operator|==
literal|0
operator|&&
name|nonTrailingZeroScale
operator|==
literal|0
condition|)
block|{
comment|// Zero(es).
return|return
literal|true
return|;
block|}
if|if
condition|(
name|exponent
operator|==
literal|0
condition|)
block|{
comment|// No effect since 10^0 = 1.
block|}
else|else
block|{
comment|// We for these input with exponents, we have at this point an intermediate decimal,
comment|// an exponent power, and a result:
comment|//
comment|//                     intermediate
comment|//   input               decimal      exponent        result
comment|// 701E+1            701 scale 0        +1            7010 scale 0
comment|// 3E+4              3 scale 0          +4               3 scale 0
comment|// 3.223E+9          3.223 scale 3      +9      3223000000 scale 0
comment|// 0.009E+10         0.009 scale 4      +10       90000000 scale 0
comment|// 0.3221E-2         0.3221 scale 4     -2               0.003221 scale 6
comment|// 0.00223E-20       0.00223 scale 5    -20              0.0000000000000000000000223 scale 25
comment|//
if|if
condition|(
operator|!
name|fastScaleByPowerOfTen
argument_list|(
name|fastResult
argument_list|,
operator|(
name|int
operator|)
name|exponent
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
specifier|final
name|int
name|trailingZeroCount
init|=
name|fastTrailingDecimalZeroCount
argument_list|(
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
name|fastResult
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastResult
operator|.
name|fastScale
argument_list|)
decl_stmt|;
if|if
condition|(
name|trailingZeroCount
operator|>
literal|0
condition|)
block|{
name|doFastScaleDown
argument_list|(
name|fastResult
argument_list|,
name|trailingZeroCount
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|-=
name|trailingZeroCount
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Scans a byte array slice for UNSIGNED RAW DIGITS ONLY in UTF-8 (ASCII) characters    * and forms a decimal from the digits and a sign and scale.    *    * Designed for BinarySortable serialization format that separates the sign and scale    * from the raw digits.    *    * NOTE: The fastSetFromDigitsOnlyBytesAndScale method requires the caller to pass a fastResult    * parameter has been reset for better performance.    *    * @return True if the sign, digits, and scale were successfully converted to a decimal.    */
specifier|public
specifier|static
name|boolean
name|fastSetFromDigitsOnlyBytesAndScale
parameter_list|(
name|boolean
name|isNegative
parameter_list|,
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|scale
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
specifier|final
name|int
name|bytesLength
init|=
name|bytes
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|offset
operator|>=
name|bytesLength
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|end
init|=
name|offset
operator|+
name|length
decl_stmt|;
if|if
condition|(
name|end
operator|<=
name|offset
operator|||
name|end
operator|>
name|bytesLength
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// We start here with at least one byte.
name|int
name|index
init|=
name|offset
decl_stmt|;
comment|// A stripped down version of fastSetFromBytes.
name|int
name|precision
init|=
literal|0
decl_stmt|;
comment|// We fill starting with highest digit in highest longword (HIGHWORD_DECIMAL_DIGITS) and
comment|// move down.  At end will will shift everything down if necessary.
name|int
name|longWordIndex
init|=
literal|0
decl_stmt|;
comment|// Where 0 is the highest longword; 1 is middle longword, etc.
name|int
name|digitNum
init|=
name|HIGHWORD_DECIMAL_DIGITS
decl_stmt|;
name|long
name|multiplier
init|=
name|powerOfTenTable
index|[
name|HIGHWORD_DECIMAL_DIGITS
operator|-
literal|1
index|]
decl_stmt|;
name|int
name|digitValue
decl_stmt|;
name|long
name|longWord
init|=
literal|0
decl_stmt|;
name|long
name|fast0
init|=
literal|0
decl_stmt|;
name|long
name|fast1
init|=
literal|0
decl_stmt|;
name|long
name|fast2
init|=
literal|0
decl_stmt|;
name|byte
name|work
decl_stmt|;
comment|// Parse digits.
name|boolean
name|haveInteger
init|=
literal|false
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|work
operator|=
name|bytes
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|work
argument_list|<
name|BYTE_DIGIT_ZERO
operator|||
name|work
argument_list|>
name|BYTE_DIGIT_NINE
condition|)
block|{
if|if
condition|(
operator|!
name|haveInteger
condition|)
block|{
return|return
literal|false
return|;
block|}
break|break;
block|}
name|haveInteger
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|precision
operator|==
literal|0
operator|&&
name|work
operator|==
name|BYTE_DIGIT_ZERO
condition|)
block|{
comment|// Ignore leading zeroes.
if|if
condition|(
operator|++
name|index
operator|>=
name|end
condition|)
block|{
break|break;
block|}
continue|continue;
block|}
name|digitValue
operator|=
name|work
operator|-
name|BYTE_DIGIT_ZERO
expr_stmt|;
if|if
condition|(
name|digitNum
operator|==
literal|0
condition|)
block|{
comment|// Integer parsing move to next lower longword.
comment|// Save previous longword.
if|if
condition|(
name|longWordIndex
operator|==
literal|0
condition|)
block|{
name|fast2
operator|=
name|longWord
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|longWordIndex
operator|==
literal|1
condition|)
block|{
name|fast1
operator|=
name|longWord
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|longWordIndex
operator|==
literal|2
condition|)
block|{
comment|// We have filled HiveDecimal.MAX_PRECISION digits and have no more room in our limit precision
comment|// fast decimal.
return|return
literal|false
return|;
block|}
name|longWordIndex
operator|++
expr_stmt|;
comment|// The middle and lowest longwords highest digit number is LONGWORD_DECIMAL_DIGITS.
name|digitNum
operator|=
name|LONGWORD_DECIMAL_DIGITS
expr_stmt|;
name|multiplier
operator|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
literal|1
index|]
expr_stmt|;
name|longWord
operator|=
literal|0
expr_stmt|;
block|}
name|longWord
operator|+=
name|digitValue
operator|*
name|multiplier
expr_stmt|;
name|multiplier
operator|/=
literal|10
expr_stmt|;
name|digitNum
operator|--
expr_stmt|;
name|precision
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|index
operator|>=
name|end
condition|)
block|{
break|break;
block|}
block|}
comment|// Just an digits?
if|if
condition|(
name|index
operator|<
name|end
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|precision
operator|==
literal|0
condition|)
block|{
comment|// We just had leading zeroes.
comment|// Value is 0.
return|return
literal|true
return|;
block|}
comment|// Save last longword.
if|if
condition|(
name|longWordIndex
operator|==
literal|0
condition|)
block|{
name|fast2
operator|=
name|longWord
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|longWordIndex
operator|==
literal|1
condition|)
block|{
name|fast1
operator|=
name|longWord
expr_stmt|;
block|}
else|else
block|{
name|fast0
operator|=
name|longWord
expr_stmt|;
block|}
name|fastResult
operator|.
name|fastSignum
operator|=
operator|(
name|isNegative
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
expr_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|precision
operator|-
name|scale
argument_list|)
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
name|scale
expr_stmt|;
specifier|final
name|int
name|scaleDown
init|=
name|HiveDecimal
operator|.
name|MAX_PRECISION
operator|-
name|precision
decl_stmt|;
if|if
condition|(
name|scaleDown
operator|>
literal|0
condition|)
block|{
name|doFastScaleDown
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scaleDown
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fast0
operator|=
name|fast0
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|fast1
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|fast2
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Scale down a BigInteger by a power of 10 and round off if necessary using ROUND_HALF_UP.    * @return The scaled and rounded BigInteger.    */
specifier|private
specifier|static
name|BigInteger
name|doBigIntegerScaleDown
parameter_list|(
name|BigInteger
name|unscaledValue
parameter_list|,
name|int
name|scaleDown
parameter_list|)
block|{
name|BigInteger
index|[]
name|quotientAndRemainder
init|=
name|unscaledValue
operator|.
name|divideAndRemainder
argument_list|(
name|BigInteger
operator|.
name|TEN
operator|.
name|pow
argument_list|(
name|scaleDown
argument_list|)
argument_list|)
decl_stmt|;
name|BigInteger
name|quotient
init|=
name|quotientAndRemainder
index|[
literal|0
index|]
decl_stmt|;
name|BigInteger
name|round
init|=
name|quotientAndRemainder
index|[
literal|1
index|]
operator|.
name|divide
argument_list|(
name|BigInteger
operator|.
name|TEN
operator|.
name|pow
argument_list|(
name|scaleDown
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|round
operator|.
name|compareTo
argument_list|(
name|BIG_INTEGER_FIVE
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|quotient
operator|=
name|quotient
operator|.
name|add
argument_list|(
name|BigInteger
operator|.
name|ONE
argument_list|)
expr_stmt|;
block|}
return|return
name|quotient
return|;
block|}
comment|/**    * Create a fast decimal from a BigDecimal.    *    * NOTE: The fastSetFromBigDecimal method requires the caller to pass a fastResult    * parameter has been reset for better performance.    *    * @return True if the BigDecimal could be converted to our decimal representation.    */
specifier|public
specifier|static
name|boolean
name|fastSetFromBigDecimal
parameter_list|(
name|BigDecimal
name|bigDecimal
parameter_list|,
name|boolean
name|allowRounding
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
comment|// We trim the trailing zero fraction digits so we don't cause unnecessary precision
comment|// overflow later.
if|if
condition|(
name|bigDecimal
operator|.
name|signum
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bigDecimal
operator|.
name|scale
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|// For some strange reason BigDecimal 0 can have a scale.  We do not support that.
name|bigDecimal
operator|=
name|BigDecimal
operator|.
name|ZERO
expr_stmt|;
block|}
block|}
else|else
block|{
name|BigDecimal
name|bigDecimalStripped
init|=
name|bigDecimal
operator|.
name|stripTrailingZeros
argument_list|()
decl_stmt|;
name|int
name|stripTrailingZerosScale
init|=
name|bigDecimalStripped
operator|.
name|scale
argument_list|()
decl_stmt|;
comment|// System.out.println("FAST_SET_FROM_BIG_DECIMAL bigDecimal " + bigDecimal);
comment|// System.out.println("FAST_SET_FROM_BIG_DECIMAL bigDecimalStripped " + bigDecimalStripped);
comment|// System.out.println("FAST_SET_FROM_BIG_DECIMAL stripTrailingZerosScale " + stripTrailingZerosScale);
if|if
condition|(
name|stripTrailingZerosScale
operator|<
literal|0
condition|)
block|{
comment|// The trailing zeroes extend into the integer part -- we only want to eliminate the
comment|// fractional zero digits.
name|bigDecimal
operator|=
name|bigDecimal
operator|.
name|setScale
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Ok, use result with some or all fractional digits stripped.
name|bigDecimal
operator|=
name|bigDecimalStripped
expr_stmt|;
block|}
block|}
comment|// System.out.println("FAST_SET_FROM_BIG_DECIMAL adjusted for zeroes/scale " + bigDecimal + " scale " + bigDecimal.scale());
name|BigInteger
name|unscaledValue
init|=
name|bigDecimal
operator|.
name|unscaledValue
argument_list|()
decl_stmt|;
comment|// System.out.println("FAST_SET_FROM_BIG_DECIMAL unscaledValue " + unscaledValue + " length " + unscaledValue.toString().length());
specifier|final
name|int
name|scale
init|=
name|bigDecimal
operator|.
name|scale
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|allowRounding
condition|)
block|{
if|if
condition|(
name|scale
argument_list|<
literal|0
operator|||
name|scale
argument_list|>
name|HiveDecimal
operator|.
name|MAX_SCALE
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// The digits must fit without rounding.
if|if
condition|(
operator|!
name|fastSetFromBigInteger
argument_list|(
name|unscaledValue
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fastResult
operator|.
name|fastSignum
operator|!=
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|-
name|scale
argument_list|)
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
name|scale
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|// This method will scale down and round to fit, if necessary.
if|if
condition|(
operator|!
name|fastSetFromBigInteger
argument_list|(
name|unscaledValue
argument_list|,
name|scale
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Scan a String for a decimal number in UTF-8 characters.    *    * NOTE: The fastSetFromString method requires the caller to pass a fastResult    * parameter has been reset for better performance.    *    * @return True if the String was successfully converted to a decimal.    */
specifier|public
specifier|static
name|boolean
name|fastSetFromString
parameter_list|(
name|String
name|string
parameter_list|,
name|boolean
name|trimBlanks
parameter_list|,
name|FastHiveDecimal
name|result
parameter_list|)
block|{
name|byte
index|[]
name|bytes
init|=
name|string
operator|.
name|getBytes
argument_list|()
decl_stmt|;
return|return
name|fastSetFromBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|,
name|trimBlanks
argument_list|,
name|result
argument_list|)
return|;
block|}
comment|/**    * Creates a scale 0 fast decimal from an int.    *    * NOTE: The fastSetFromString method requires the caller to pass a fastResult    * parameter has been reset for better performance.    *    */
specifier|public
specifier|static
name|void
name|fastSetFromInt
parameter_list|(
name|int
name|intValue
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
if|if
condition|(
name|intValue
operator|==
literal|0
condition|)
block|{
comment|// Zero special case.
return|return;
block|}
if|if
condition|(
name|intValue
operator|>
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
operator|-
literal|1
expr_stmt|;
name|intValue
operator|=
name|Math
operator|.
name|abs
argument_list|(
name|intValue
argument_list|)
expr_stmt|;
block|}
comment|// 10 digit int is all in lowest 16 decimal digit longword.
comment|// Since we are creating with scale 0, no fraction digits to zero trim.
name|fastResult
operator|.
name|fast0
operator|=
name|intValue
operator|&
literal|0xFFFFFFFFL
expr_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|fastLongWordPrecision
argument_list|(
name|fastResult
operator|.
name|fast0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a scale 0 fast decimal from a long.    *    * NOTE: The fastSetFromLong method requires the caller to pass a fastResult    * parameter has been reset for better performance.    *    */
specifier|public
specifier|static
name|void
name|fastSetFromLong
parameter_list|(
name|long
name|longValue
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
if|if
condition|(
name|longValue
operator|==
literal|0
condition|)
block|{
comment|// Zero special case.
return|return;
block|}
comment|// Handle minimum integer case that doesn't have abs().
if|if
condition|(
name|longValue
operator|==
name|Long
operator|.
name|MIN_VALUE
condition|)
block|{
comment|// Split -9,223,372,036,854,775,808 into 16 digit middle and lowest longwords by hand.
name|fastResult
operator|.
name|fastSignum
operator|=
operator|-
literal|1
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
literal|922L
expr_stmt|;
name|fastResult
operator|.
name|fast0
operator|=
literal|3372036854775808L
expr_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
literal|19
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|longValue
operator|>
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
operator|-
literal|1
expr_stmt|;
name|longValue
operator|=
name|Math
operator|.
name|abs
argument_list|(
name|longValue
argument_list|)
expr_stmt|;
block|}
comment|// Split into 16 digit middle and lowest longwords remainder / division.
name|fastResult
operator|.
name|fast1
operator|=
name|longValue
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|fastResult
operator|.
name|fast0
operator|=
name|longValue
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
if|if
condition|(
name|fastResult
operator|.
name|fast1
operator|!=
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|LONGWORD_DECIMAL_DIGITS
operator|+
name|fastLongWordPrecision
argument_list|(
name|fastResult
operator|.
name|fast1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|fastLongWordPrecision
argument_list|(
name|fastResult
operator|.
name|fast0
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/**    * Creates a fast decimal from a long with a specified scale.    *    * NOTE: The fastSetFromLongAndScale method requires the caller to pass a fastResult    * parameter has been reset for better performance.    *    */
specifier|public
specifier|static
name|boolean
name|fastSetFromLongAndScale
parameter_list|(
name|long
name|longValue
parameter_list|,
name|int
name|scale
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
if|if
condition|(
name|scale
argument_list|<
literal|0
operator|||
name|scale
argument_list|>
name|HiveDecimal
operator|.
name|MAX_SCALE
condition|)
block|{
return|return
literal|false
return|;
block|}
name|fastSetFromLong
argument_list|(
name|longValue
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|scale
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|fastScaleByPowerOfTen
argument_list|(
name|fastResult
argument_list|,
operator|-
name|scale
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Creates fast decimal from a float.    *    * NOTE: The fastSetFromFloat method requires the caller to pass a fastResult    * parameter has been reset for better performance.    *    */
specifier|public
specifier|static
name|boolean
name|fastSetFromFloat
parameter_list|(
name|float
name|floatValue
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
name|String
name|floatString
init|=
name|Float
operator|.
name|toString
argument_list|(
name|floatValue
argument_list|)
decl_stmt|;
return|return
name|fastSetFromString
argument_list|(
name|floatString
argument_list|,
literal|false
argument_list|,
name|fastResult
argument_list|)
return|;
block|}
comment|/**    * Creates fast decimal from a double.    *    * NOTE: The fastSetFromDouble method requires the caller to pass a fastResult    * parameter has been reset for better performance.    *    */
specifier|public
specifier|static
name|boolean
name|fastSetFromDouble
parameter_list|(
name|double
name|doubleValue
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
name|String
name|doubleString
init|=
name|Double
operator|.
name|toString
argument_list|(
name|doubleValue
argument_list|)
decl_stmt|;
return|return
name|fastSetFromString
argument_list|(
name|doubleString
argument_list|,
literal|false
argument_list|,
name|fastResult
argument_list|)
return|;
block|}
comment|/**    * Creates a fast decimal from a BigInteger with scale 0.    *    * For efficiency, we assume that fastResult is fastReset.  This method does not set the    * fastScale field.    *    * NOTE: The fastSetFromBigInteger method requires the caller to pass a fastResult    * parameter has been reset for better performance.    *    * @return Return true if the BigInteger value fit within HiveDecimal.MAX_PRECISION.  Otherwise,    *         false for overflow.    */
specifier|public
specifier|static
name|boolean
name|fastSetFromBigInteger
parameter_list|(
name|BigInteger
name|bigInteger
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
specifier|final
name|int
name|signum
init|=
name|bigInteger
operator|.
name|signum
argument_list|()
decl_stmt|;
if|if
condition|(
name|signum
operator|==
literal|0
condition|)
block|{
comment|// Zero special case.
return|return
literal|true
return|;
block|}
name|fastResult
operator|.
name|fastSignum
operator|=
name|signum
expr_stmt|;
if|if
condition|(
name|signum
operator|==
operator|-
literal|1
condition|)
block|{
name|bigInteger
operator|=
name|bigInteger
operator|.
name|negate
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bigInteger
operator|.
name|compareTo
argument_list|(
name|BIG_INTEGER_LONGWORD_MULTIPLIER
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// Fits in one longword.
name|fastResult
operator|.
name|fast0
operator|=
name|bigInteger
operator|.
name|longValue
argument_list|()
expr_stmt|;
if|if
condition|(
name|fastResult
operator|.
name|fast0
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|fastLongWordPrecision
argument_list|(
name|fastResult
operator|.
name|fast0
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
name|BigInteger
index|[]
name|quotientAndRemainder
init|=
name|bigInteger
operator|.
name|divideAndRemainder
argument_list|(
name|BIG_INTEGER_LONGWORD_MULTIPLIER
argument_list|)
decl_stmt|;
name|fastResult
operator|.
name|fast0
operator|=
name|quotientAndRemainder
index|[
literal|1
index|]
operator|.
name|longValue
argument_list|()
expr_stmt|;
name|BigInteger
name|quotient
init|=
name|quotientAndRemainder
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|quotient
operator|.
name|compareTo
argument_list|(
name|BIG_INTEGER_LONGWORD_MULTIPLIER
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// Fits in two longwords.
name|fastResult
operator|.
name|fast1
operator|=
name|quotient
operator|.
name|longValue
argument_list|()
expr_stmt|;
if|if
condition|(
name|fastResult
operator|.
name|fast0
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast1
operator|==
literal|0
condition|)
block|{
comment|// The special case zero logic at the beginning should have caught this.
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected"
argument_list|)
throw|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|LONGWORD_DECIMAL_DIGITS
operator|+
name|fastLongWordPrecision
argument_list|(
name|fastResult
operator|.
name|fast1
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|// Uses all 3 decimal longs.
name|quotientAndRemainder
operator|=
name|quotient
operator|.
name|divideAndRemainder
argument_list|(
name|BIG_INTEGER_LONGWORD_MULTIPLIER
argument_list|)
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|quotientAndRemainder
index|[
literal|1
index|]
operator|.
name|longValue
argument_list|()
expr_stmt|;
name|quotient
operator|=
name|quotientAndRemainder
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|quotient
operator|.
name|compareTo
argument_list|(
name|BIG_INTEGER_HIGHWORD_MULTIPLIER
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|// Overflow.
return|return
literal|false
return|;
block|}
name|fastResult
operator|.
name|fast2
operator|=
name|quotient
operator|.
name|longValue
argument_list|()
expr_stmt|;
if|if
condition|(
name|fastResult
operator|.
name|fast0
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast1
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast2
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|TWO_X_LONGWORD_DECIMAL_DIGITS
operator|+
name|fastHighWordPrecision
argument_list|(
name|fastResult
operator|.
name|fast2
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Creates a fast decimal from a BigInteger with a specified scale.    *    * NOTE: The fastSetFromBigInteger method requires the caller to pass a fastResult    * parameter has been reset for better performance.    *    * @return True if the BigInteger and scale were successfully converted to a decimal.    */
specifier|public
specifier|static
name|boolean
name|fastSetFromBigInteger
parameter_list|(
name|BigInteger
name|bigInteger
parameter_list|,
name|int
name|scale
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
if|if
condition|(
name|scale
operator|<
literal|0
condition|)
block|{
comment|// Multiply by 10^(-scale) to normalize.  We do not use negative scale in our representation.
comment|//
comment|// Example:
comment|//    4.172529E+20 has a negative scale -20 since scale is number of digits below the dot.
comment|//    417252900000000000000 normalized as scale 0.
comment|//
name|bigInteger
operator|=
name|bigInteger
operator|.
name|multiply
argument_list|(
name|BIG_INTEGER_TEN
operator|.
name|pow
argument_list|(
operator|-
name|scale
argument_list|)
argument_list|)
expr_stmt|;
name|scale
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|signum
init|=
name|bigInteger
operator|.
name|signum
argument_list|()
decl_stmt|;
if|if
condition|(
name|signum
operator|==
literal|0
condition|)
block|{
comment|// Zero.
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|signum
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Normalize to positive.
name|bigInteger
operator|=
name|bigInteger
operator|.
name|negate
argument_list|()
expr_stmt|;
block|}
comment|// A slow way to get the number of decimal digits.
name|int
name|precision
init|=
name|bigInteger
operator|.
name|toString
argument_list|()
operator|.
name|length
argument_list|()
decl_stmt|;
comment|// System.out.println("FAST_SET_FROM_BIG_INTEGER adjusted bigInteger " + bigInteger + " precision " + precision);
name|int
name|integerDigitCount
init|=
name|precision
operator|-
name|scale
decl_stmt|;
comment|// System.out.println("FAST_SET_FROM_BIG_INTEGER integerDigitCount " + integerDigitCount + " scale " + scale);
name|int
name|maxScale
decl_stmt|;
if|if
condition|(
name|integerDigitCount
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|integerDigitCount
operator|>
name|HiveDecimal
operator|.
name|MAX_PRECISION
condition|)
block|{
return|return
literal|false
return|;
block|}
name|maxScale
operator|=
name|HiveDecimal
operator|.
name|MAX_SCALE
operator|-
name|integerDigitCount
expr_stmt|;
block|}
else|else
block|{
name|maxScale
operator|=
name|HiveDecimal
operator|.
name|MAX_SCALE
expr_stmt|;
block|}
comment|// System.out.println("FAST_SET_FROM_BIG_INTEGER maxScale " + maxScale);
if|if
condition|(
name|scale
operator|>
name|maxScale
condition|)
block|{
comment|// A larger scale is ok -- we will knock off lower digits and round.
specifier|final
name|int
name|trimAwayCount
init|=
name|scale
operator|-
name|maxScale
decl_stmt|;
comment|// System.out.println("FAST_SET_FROM_BIG_INTEGER trimAwayCount " + trimAwayCount);
if|if
condition|(
name|trimAwayCount
operator|>
literal|1
condition|)
block|{
comment|// First, throw away digits below round digit.
name|BigInteger
name|bigIntegerThrowAwayBelowRoundDigitDivisor
init|=
name|BIG_INTEGER_TEN
operator|.
name|pow
argument_list|(
name|trimAwayCount
operator|-
literal|1
argument_list|)
decl_stmt|;
name|bigInteger
operator|=
name|bigInteger
operator|.
name|divide
argument_list|(
name|bigIntegerThrowAwayBelowRoundDigitDivisor
argument_list|)
expr_stmt|;
block|}
comment|// System.out.println("FAST_SET_FROM_BIG_INTEGER with round digit bigInteger " + bigInteger + " length " + bigInteger.toString().length());
name|BigInteger
index|[]
name|quotientAndRemainder
init|=
name|bigInteger
operator|.
name|divideAndRemainder
argument_list|(
name|BIG_INTEGER_TEN
argument_list|)
decl_stmt|;
comment|// System.out.println("FAST_SET_FROM_BIG_INTEGER quotientAndRemainder " + Arrays.toString(quotientAndRemainder));
name|BigInteger
name|quotient
init|=
name|quotientAndRemainder
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|quotientAndRemainder
index|[
literal|1
index|]
operator|.
name|intValue
argument_list|()
operator|>=
literal|5
condition|)
block|{
if|if
condition|(
name|quotient
operator|.
name|equals
argument_list|(
name|BIG_INTEGER_MAX_DECIMAL
argument_list|)
condition|)
block|{
comment|// 38 9's digits.
comment|// System.out.println("FAST_SET_FROM_BIG_INTEGER quotient is BIG_INTEGER_MAX_DECIMAL");
if|if
condition|(
name|maxScale
operator|==
literal|0
condition|)
block|{
comment|// No room above for rounding.
return|return
literal|false
return|;
block|}
comment|// System.out.println("FAST_SET_FROM_BIG_INTEGER reached here... scale " + scale + " maxScale " + maxScale);
comment|// Rounding results in 10^N.
name|bigInteger
operator|=
name|BIG_INTEGER_TEN
operator|.
name|pow
argument_list|(
name|integerDigitCount
argument_list|)
expr_stmt|;
name|maxScale
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// Round up.
name|bigInteger
operator|=
name|quotient
operator|.
name|add
argument_list|(
name|BigInteger
operator|.
name|ONE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// No rounding.
name|bigInteger
operator|=
name|quotient
expr_stmt|;
block|}
name|scale
operator|=
name|maxScale
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fastSetFromBigInteger
argument_list|(
name|bigInteger
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fastResult
operator|.
name|fast0
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast1
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast2
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
name|signum
expr_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|-
name|scale
argument_list|)
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
name|scale
expr_stmt|;
specifier|final
name|int
name|trailingZeroCount
init|=
name|fastTrailingDecimalZeroCount
argument_list|(
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
name|fastResult
operator|.
name|fastIntegerDigitCount
argument_list|,
name|scale
argument_list|)
decl_stmt|;
if|if
condition|(
name|trailingZeroCount
operator|>
literal|0
condition|)
block|{
name|doFastScaleDown
argument_list|(
name|fastResult
argument_list|,
name|trailingZeroCount
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|-=
name|trailingZeroCount
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|//************************************************************************************************
comment|// Take Integer or Fractional Portion.
comment|/**    * Creates fast decimal from the fraction portion of a fast decimal.    *    * NOTE: The fastFractionPortion method requires the caller to pass a fastResult    * parameter has been reset for better performance.    */
specifier|public
specifier|static
name|void
name|fastFractionPortion
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
if|if
condition|(
name|fastSignum
operator|==
literal|0
operator|||
name|fastScale
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// Clear integer portion; keep fraction.
comment|// Adjust all longs using power 10 division/remainder.
name|long
name|result0
decl_stmt|;
name|long
name|result1
decl_stmt|;
name|long
name|result2
decl_stmt|;
if|if
condition|(
name|fastScale
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Part of lowest word survives.
specifier|final
name|long
name|clearFactor
init|=
name|powerOfTenTable
index|[
name|fastScale
index|]
decl_stmt|;
name|result0
operator|=
name|fast0
operator|%
name|clearFactor
expr_stmt|;
name|result1
operator|=
literal|0
expr_stmt|;
name|result2
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fastScale
operator|<
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Throw away lowest word.
specifier|final
name|int
name|adjustedScaleDown
init|=
name|fastScale
operator|-
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
specifier|final
name|long
name|clearFactor
init|=
name|powerOfTenTable
index|[
name|adjustedScaleDown
index|]
decl_stmt|;
name|result0
operator|=
name|fast0
expr_stmt|;
name|result1
operator|=
name|fast1
operator|%
name|clearFactor
expr_stmt|;
name|result2
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// Throw away middle and lowest words.
specifier|final
name|int
name|adjustedScaleDown
init|=
name|fastScale
operator|-
literal|2
operator|*
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
specifier|final
name|long
name|clearFactor
init|=
name|powerOfTenTable
index|[
name|adjustedScaleDown
index|]
decl_stmt|;
name|result0
operator|=
name|fast0
expr_stmt|;
name|result1
operator|=
name|fast1
expr_stmt|;
name|result2
operator|=
name|fast2
operator|%
name|clearFactor
expr_stmt|;
block|}
if|if
condition|(
name|result0
operator|==
literal|0
operator|&&
name|result1
operator|==
literal|0
operator|&&
name|result2
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastSet
argument_list|(
name|fastSignum
argument_list|,
name|result0
argument_list|,
name|result1
argument_list|,
name|result2
argument_list|,
comment|/* fastIntegerDigitCount */
literal|0
argument_list|,
name|fastScale
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Creates fast decimal from the integer portion.    *    * NOTE: The fastFractionPortion method requires the caller to pass a fastResult    * parameter has been reset for better performance.    */
specifier|public
specifier|static
name|void
name|fastIntegerPortion
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
if|if
condition|(
name|fastSignum
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fastScale
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSet
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|)
expr_stmt|;
block|}
comment|// Scale down no rounding to clear fraction.
name|fastResult
operator|.
name|fastSignum
operator|=
name|fastSignum
expr_stmt|;
name|doFastScaleDown
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastScale
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|fastIntegerDigitCount
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
literal|0
expr_stmt|;
block|}
comment|//************************************************************************************************
comment|// Binary to Decimal Conversion.
comment|/**    * Convert 3 binary words of N bits each to a fast decimal (scale 0).    *    * The 3 binary words highWord, middleWord, and lowerWord form a large binary value:    *    *    highWord * 2^(M+L) + middleWord * 2^L + lowerWord.    *    * Where L is the number of bits in the lower word; M is the number of bits in the middle word.    * We let L and M be different to support the SerializationUtil serialization where the lower    * word is 62 bits and the remaining words are 63 bits...    *    * The fast decimal middleWordMultiplier is 2^L.    * The fast decimal highWordMultiplier is 2^(M+L).    *    * @return True if the conversion of the 3 binary words to decimal was successful.    */
specifier|public
specifier|static
name|boolean
name|doBinaryToDecimalConversion
parameter_list|(
name|long
name|lowerWord
parameter_list|,
name|long
name|middleWord
parameter_list|,
name|long
name|highWord
parameter_list|,
name|FastHiveDecimal
name|middleWordMultiplier
parameter_list|,
name|FastHiveDecimal
name|highWordMultiplier
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
comment|/*      * Challenge: How to do the math to get this raw binary back to our decimal form.      *      * Briefly, for the middle and upper binary words, convert the middle/upper word into a decimal      * long words and then multiply those by the binary word's power of 2.      *      * And, add the multiply results into the result decimal longwords.      *      */
name|long
name|result0
init|=
name|lowerWord
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|long
name|result1
init|=
name|lowerWord
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|long
name|result2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|middleWord
operator|!=
literal|0
operator|||
name|highWord
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|highWord
operator|==
literal|0
condition|)
block|{
comment|// Form result from lower and middle words.
if|if
condition|(
operator|!
name|fastMultiply5x5HalfWords
argument_list|(
name|middleWord
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
argument_list|,
name|middleWord
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
argument_list|,
literal|0
argument_list|,
name|middleWordMultiplier
operator|.
name|fast0
argument_list|,
name|middleWordMultiplier
operator|.
name|fast1
argument_list|,
name|middleWordMultiplier
operator|.
name|fast2
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|long
name|calc0
init|=
name|result0
operator|+
name|fastResult
operator|.
name|fast0
decl_stmt|;
name|result0
operator|=
name|calc0
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|calc1
init|=
name|calc0
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
operator|+
name|result1
operator|+
name|fastResult
operator|.
name|fast1
decl_stmt|;
name|result1
operator|=
name|calc1
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|result2
operator|=
name|calc1
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
operator|+
name|fastResult
operator|.
name|fast2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|middleWord
operator|==
literal|0
condition|)
block|{
comment|// Form result from lower and high words.
if|if
condition|(
operator|!
name|fastMultiply5x5HalfWords
argument_list|(
name|highWord
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
argument_list|,
name|highWord
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
argument_list|,
literal|0
argument_list|,
name|highWordMultiplier
operator|.
name|fast0
argument_list|,
name|highWordMultiplier
operator|.
name|fast1
argument_list|,
name|highWordMultiplier
operator|.
name|fast2
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|long
name|calc0
init|=
name|result0
operator|+
name|fastResult
operator|.
name|fast0
decl_stmt|;
name|result0
operator|=
name|calc0
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|calc1
init|=
name|calc0
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
operator|+
name|result1
operator|+
name|fastResult
operator|.
name|fast1
decl_stmt|;
name|result1
operator|=
name|calc1
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|result2
operator|=
name|calc1
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
operator|+
name|fastResult
operator|.
name|fast2
expr_stmt|;
block|}
else|else
block|{
comment|// Form result from lower, middle, and middle words.
if|if
condition|(
operator|!
name|fastMultiply5x5HalfWords
argument_list|(
name|middleWord
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
argument_list|,
name|middleWord
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
argument_list|,
literal|0
argument_list|,
name|middleWordMultiplier
operator|.
name|fast0
argument_list|,
name|middleWordMultiplier
operator|.
name|fast1
argument_list|,
name|middleWordMultiplier
operator|.
name|fast2
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|long
name|middleResult0
init|=
name|fastResult
operator|.
name|fast0
decl_stmt|;
name|long
name|middleResult1
init|=
name|fastResult
operator|.
name|fast1
decl_stmt|;
name|long
name|middleResult2
init|=
name|fastResult
operator|.
name|fast2
decl_stmt|;
if|if
condition|(
operator|!
name|fastMultiply5x5HalfWords
argument_list|(
name|highWord
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
argument_list|,
name|highWord
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
argument_list|,
literal|0
argument_list|,
name|highWordMultiplier
operator|.
name|fast0
argument_list|,
name|highWordMultiplier
operator|.
name|fast1
argument_list|,
name|highWordMultiplier
operator|.
name|fast2
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|long
name|calc0
init|=
name|result0
operator|+
name|middleResult0
operator|+
name|fastResult
operator|.
name|fast0
decl_stmt|;
name|result0
operator|=
name|calc0
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|long
name|calc1
init|=
name|calc0
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
operator|+
name|result1
operator|+
name|middleResult1
operator|+
name|fastResult
operator|.
name|fast1
decl_stmt|;
name|result1
operator|=
name|calc1
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|result2
operator|=
name|calc1
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
operator|+
name|middleResult2
operator|+
name|fastResult
operator|.
name|fast2
expr_stmt|;
block|}
block|}
comment|// Let caller set negative sign if necessary.
if|if
condition|(
name|result2
operator|!=
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|TWO_X_LONGWORD_DECIMAL_DIGITS
operator|+
name|fastHighWordPrecision
argument_list|(
name|result2
argument_list|)
expr_stmt|;
name|fastResult
operator|.
name|fastSignum
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result1
operator|!=
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|LONGWORD_DECIMAL_DIGITS
operator|+
name|fastHighWordPrecision
argument_list|(
name|result1
argument_list|)
expr_stmt|;
name|fastResult
operator|.
name|fastSignum
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result0
operator|!=
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|fastHighWordPrecision
argument_list|(
name|result0
argument_list|)
expr_stmt|;
name|fastResult
operator|.
name|fastSignum
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
literal|0
expr_stmt|;
name|fastResult
operator|.
name|fastSignum
operator|=
literal|0
expr_stmt|;
block|}
name|fastResult
operator|.
name|fast0
operator|=
name|result0
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|result1
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|result2
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|//************************************************************************************************
comment|// Decimal to Binary Conversion.
comment|/**    * A helper method that produces a single binary word remainder from a fast decimal (and    * quotient).    *    * The fast decimal is longwords of 16 digits each and we need binary words of 2^N.  Since    * we are in decimal form, we have do work to get to convert to binary form.    *    * We effectively need to produce on big binary value (i.e. greater than 64 bits since    * HiveDecimal needs 128 bits of binary which Java does not provide primitive support for)    * from the decimal long words and get the lower N binary bit remainder.    *    * We could try and do decimal division by 2^N to get the (integer) quotient, multiply the    * quotient by 2^N decimal, and finally do a decimal subtract that from the original decimal.    * The resulting decimal can be used to easily get the binary remainder.    *    * However, currently, we do not have fast decimal division.    *    * The "trick" we do here is to remember from your Algebra in school than multiplication and    * division are inverses of each other.    *    * So instead of doing decimal division by 2^N we multiply by the inverse: 2^-N.    *    * We produce 1 binary word (remainder) and a decimal quotient for the higher portion.    *    * So, the parameters are:    *    *   The input decimal (dividendFast0, dividendFast1, and dividendFast2) that will produce a    *   single binary word remainder and decimal quotient.    *    *   The fast decimal inverse of 2^N = 2^-N (fastInverseConst).    *    *   Where in the inverse multiplication result (quotientIntegerWordNum and    *   quotientIntegerDigitNum) to find the quotient integer decimal portion.    *    *   The fast decimal multiplier for converting the quotient integer to the larger number to    *   subtract from the input decimal to get the remainder.    *    *   And, the scratch longs where to store the result remainder word (index 3) and result quotient    *   decimal longwords (indices 0 .. 2).    *    * @return True if the results were produced without overflow.    */
specifier|public
specifier|static
name|boolean
name|doDecimalToBinaryDivisionRemainder
parameter_list|(
name|long
name|dividendFast0
parameter_list|,
name|long
name|dividendFast1
parameter_list|,
name|long
name|dividendFast2
parameter_list|,
name|FastHiveDecimal
name|fastInverseConst
parameter_list|,
name|int
name|quotientIntegerWordNum
parameter_list|,
name|int
name|quotientIntegerDigitNum
parameter_list|,
name|FastHiveDecimal
name|fastMultiplierConst
parameter_list|,
name|long
index|[]
name|scratchLongs
parameter_list|)
block|{
comment|// Multiply by inverse (2^-N) to do the 2^N division.
if|if
condition|(
operator|!
name|fastMultiply5x6HalfWords
argument_list|(
name|dividendFast0
argument_list|,
name|dividendFast1
argument_list|,
name|dividendFast2
argument_list|,
name|fastInverseConst
operator|.
name|fast0
argument_list|,
name|fastInverseConst
operator|.
name|fast1
argument_list|,
name|fastInverseConst
operator|.
name|fast2
argument_list|,
name|scratchLongs
argument_list|)
condition|)
block|{
comment|// Overflow.
return|return
literal|false
return|;
block|}
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|quotientIntegerDigitNum
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|quotientIntegerDigitNum
index|]
decl_stmt|;
comment|// Extract the integer portion to get the quotient.
name|long
name|quotientFast0
init|=
name|scratchLongs
index|[
name|quotientIntegerWordNum
index|]
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|scratchLongs
index|[
name|quotientIntegerWordNum
operator|+
literal|1
index|]
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
decl_stmt|;
name|long
name|quotientFast1
init|=
name|scratchLongs
index|[
name|quotientIntegerWordNum
operator|+
literal|1
index|]
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|scratchLongs
index|[
name|quotientIntegerWordNum
operator|+
literal|2
index|]
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
decl_stmt|;
name|long
name|quotientFast2
init|=
name|scratchLongs
index|[
name|quotientIntegerWordNum
operator|+
literal|2
index|]
operator|/
name|divideFactor
decl_stmt|;
comment|// Multiply the integer quotient back out so we can subtract it from the original to get
comment|// the remainder.
if|if
condition|(
operator|!
name|fastMultiply5x6HalfWords
argument_list|(
name|quotientFast0
argument_list|,
name|quotientFast1
argument_list|,
name|quotientFast2
argument_list|,
name|fastMultiplierConst
operator|.
name|fast0
argument_list|,
name|fastMultiplierConst
operator|.
name|fast1
argument_list|,
name|fastMultiplierConst
operator|.
name|fast2
argument_list|,
name|scratchLongs
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|long
name|quotientMultiplied0
init|=
name|scratchLongs
index|[
literal|0
index|]
decl_stmt|;
name|long
name|quotientMultiplied1
init|=
name|scratchLongs
index|[
literal|1
index|]
decl_stmt|;
name|long
name|quotientMultiplied2
init|=
name|scratchLongs
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|doSubtractSameScaleNoUnderflow
argument_list|(
name|dividendFast0
argument_list|,
name|dividendFast1
argument_list|,
name|dividendFast2
argument_list|,
name|quotientMultiplied0
argument_list|,
name|quotientMultiplied1
argument_list|,
name|quotientMultiplied2
argument_list|,
name|scratchLongs
argument_list|)
condition|)
block|{
comment|// Underflow.
return|return
literal|false
return|;
block|}
name|long
name|remainderBinaryWord
init|=
name|scratchLongs
index|[
literal|1
index|]
operator|*
name|MULTIPLER_LONGWORD_DECIMAL
operator|+
name|scratchLongs
index|[
literal|0
index|]
decl_stmt|;
comment|// Pack the output into the scratch longs.
name|scratchLongs
index|[
literal|0
index|]
operator|=
name|quotientFast0
expr_stmt|;
name|scratchLongs
index|[
literal|1
index|]
operator|=
name|quotientFast1
expr_stmt|;
name|scratchLongs
index|[
literal|2
index|]
operator|=
name|quotientFast2
expr_stmt|;
name|scratchLongs
index|[
literal|3
index|]
operator|=
name|remainderBinaryWord
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Convert a fast decimal into 3 binary words of N bits each.    *     * The 3 binary words will form a large binary value that is the unsigned unscaled decimal value:    *    *    highWord * 2^(M+L) + middleWord * 2^L + lowerWord.    *    * Where L is the number of bits in the lower word; M is the number of bits in the middle word.    * We let L and M be different to support the SerializationUtil serialization where the lower    * word is 62 bits and the remaining words are 63 bits...    *    * The fast decimal is longwords of 16 digits each and we need binary words of 2^N.  Since    * we are in decimal form, we have do work to get to convert to binary form.    *    * See the comments for doDecimalToBinaryDivisionRemainder for details on the parameters.    *    * The lowerWord is produced by calling doDecimalToBinaryDivisionRemainder.  The quotient from    * that is passed to doDecimalToBinaryDivisionRemainder to produce the middleWord.  The final    * quotient is used to produce the highWord.    *    * @return True if the 3 binary words were produced without overflow.  Overflow is not expected.    */
specifier|private
specifier|static
name|boolean
name|doDecimalToBinaryConversion
parameter_list|(
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|FastHiveDecimal
name|fastInverseConst
parameter_list|,
name|int
name|quotientIntegerWordNum
parameter_list|,
name|int
name|quotientIntegerDigitNum
parameter_list|,
name|FastHiveDecimal
name|fastMultiplierConst
parameter_list|,
name|long
index|[]
name|scratchLongs
parameter_list|)
block|{
name|long
name|lowerBinaryWord
decl_stmt|;
name|long
name|middleBinaryWord
init|=
literal|0
decl_stmt|;
name|long
name|highBinaryWord
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fastCompareTo
argument_list|(
literal|1
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|fastMultiplierConst
operator|.
name|fast0
argument_list|,
name|fastMultiplierConst
operator|.
name|fast1
argument_list|,
name|fastMultiplierConst
operator|.
name|fast2
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// Optimize: whole decimal fits in one binary word.
name|lowerBinaryWord
operator|=
name|fast1
operator|*
name|MULTIPLER_LONGWORD_DECIMAL
operator|+
name|fast0
expr_stmt|;
block|}
else|else
block|{
comment|// Do division/remainder to get lower binary word; quotient will either be middle decimal
comment|// or be both high and middle decimal that requires another division/remainder.
if|if
condition|(
operator|!
name|doDecimalToBinaryDivisionRemainder
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastInverseConst
argument_list|,
name|quotientIntegerWordNum
argument_list|,
name|quotientIntegerDigitNum
argument_list|,
name|fastMultiplierConst
argument_list|,
name|scratchLongs
argument_list|)
condition|)
block|{
comment|// Overflow.
return|return
literal|false
return|;
block|}
comment|// Unpack the output.
name|long
name|quotientFast0
init|=
name|scratchLongs
index|[
literal|0
index|]
decl_stmt|;
name|long
name|quotientFast1
init|=
name|scratchLongs
index|[
literal|1
index|]
decl_stmt|;
name|long
name|quotientFast2
init|=
name|scratchLongs
index|[
literal|2
index|]
decl_stmt|;
name|lowerBinaryWord
operator|=
name|scratchLongs
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|fastCompareTo
argument_list|(
literal|1
argument_list|,
name|quotientFast0
argument_list|,
name|quotientFast1
argument_list|,
name|quotientFast2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|fastMultiplierConst
operator|.
name|fast0
argument_list|,
name|fastMultiplierConst
operator|.
name|fast1
argument_list|,
name|fastMultiplierConst
operator|.
name|fast2
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// Optimize: whole decimal fits in two binary words.
name|middleBinaryWord
operator|=
name|quotientFast1
operator|*
name|MULTIPLER_LONGWORD_DECIMAL
operator|+
name|quotientFast0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|doDecimalToBinaryDivisionRemainder
argument_list|(
name|quotientFast0
argument_list|,
name|quotientFast1
argument_list|,
name|quotientFast2
argument_list|,
name|fastInverseConst
argument_list|,
name|quotientIntegerWordNum
argument_list|,
name|quotientIntegerDigitNum
argument_list|,
name|fastMultiplierConst
argument_list|,
name|scratchLongs
argument_list|)
condition|)
block|{
comment|// Overflow.
return|return
literal|false
return|;
block|}
name|highBinaryWord
operator|=
name|scratchLongs
index|[
literal|1
index|]
operator|*
name|MULTIPLER_LONGWORD_DECIMAL
operator|+
name|scratchLongs
index|[
literal|0
index|]
expr_stmt|;
name|middleBinaryWord
operator|=
name|scratchLongs
index|[
literal|3
index|]
expr_stmt|;
block|}
block|}
name|scratchLongs
index|[
literal|0
index|]
operator|=
name|lowerBinaryWord
expr_stmt|;
name|scratchLongs
index|[
literal|1
index|]
operator|=
name|middleBinaryWord
expr_stmt|;
name|scratchLongs
index|[
literal|2
index|]
operator|=
name|highBinaryWord
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|//************************************************************************************************
comment|// Emulate SerializationUtils Deserialization used by ORC.
comment|/*    * fastSerializationUtilsRead lower word is 62 bits (the lower bit is used as the sign and is    * removed).  So, we need a multiplier 2^62    *    *    2^62 =    *      4611686018427387904 or    *      4,611,686,018,427,387,904 or    *      461,1686018427387904 (16 digit comma'd)    */
specifier|private
specifier|static
name|FastHiveDecimal
name|FAST_HIVE_DECIMAL_TWO_POWER_62
init|=
operator|new
name|FastHiveDecimal
argument_list|(
literal|1
argument_list|,
literal|1686018427387904L
argument_list|,
literal|461L
argument_list|,
literal|0
argument_list|,
literal|19
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/*    * fastSerializationUtilsRead middle word is 63 bits. So, we need a multiplier 2^63     *    *    2^63 =    *      9223372036854775808 (Long.MAX_VALUE) or    *      9,223,372,036,854,775,808 or    *      922,3372036854775808 (16 digit comma'd)    */
specifier|private
specifier|static
name|FastHiveDecimal
name|FAST_HIVE_DECIMAL_TWO_POWER_63
init|=
operator|new
name|FastHiveDecimal
argument_list|(
literal|1
argument_list|,
literal|3372036854775808L
argument_list|,
literal|922L
argument_list|,
literal|0
argument_list|,
literal|19
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/*    * fastSerializationUtilsRead high word multiplier:    *    *    Multiply by 2^(62 + 63)                      -- 38 digits or 3 decimal words.    *    *    (2^62)*(2^63) =    *      42535295865117307932921825928971026432 or    *     (12345678901234567890123456789012345678)    *     (         1         2         3        )    *      42,535,295,865,117,307,932,921,825,928,971,026,432 or    *      425352,9586511730793292,1825928971026432  (16 digit comma'd)    */
specifier|private
specifier|static
name|FastHiveDecimal
name|FAST_HIVE_DECIMAL_TWO_POWER_125
init|=
operator|new
name|FastHiveDecimal
argument_list|(
literal|1
argument_list|,
literal|1825928971026432L
argument_list|,
literal|9586511730793292L
argument_list|,
literal|425352L
argument_list|,
literal|38
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/*    * Inverse of 2^63 = 2^-63.  Please see comments for doDecimalToBinaryDivisionRemainder.    *    * Multiply by 1/2^63 = 1.08420217248550443400745280086994171142578125e-19 to divide by 2^63.    * As 16 digit comma'd 1084202172485,5044340074528008,6994171142578125    *    * Scale down: 63 = 44 fraction digits + 19 (negative exponent or number of zeros after dot).    *    * 3*16 (48) + 15 --> 63 down shift.    */
specifier|private
specifier|static
name|FastHiveDecimal
name|FAST_HIVE_DECIMAL_TWO_POWER_63_INVERSE
init|=
operator|new
name|FastHiveDecimal
argument_list|(
literal|1
argument_list|,
literal|6994171142578125L
argument_list|,
literal|5044340074528008L
argument_list|,
literal|1084202172485L
argument_list|,
literal|45
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/*    * Where in the inverse multiplication result to find the quotient integer decimal portion.    *    * Please see comments for doDecimalToBinaryDivisionRemainder.    */
specifier|private
specifier|static
specifier|final
name|int
name|SERIALIZATION_UTILS_WRITE_QUOTIENT_INTEGER_WORD_NUM
init|=
literal|3
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|SERIALIZATION_UTILS_WRITE_QUOTIENT_INTEGER_DIGIT_NUM
init|=
literal|15
decl_stmt|;
comment|/**    * Deserialize data written in the format used by the SerializationUtils methods    * readBigInteger/writeBigInteger and create a decimal using the supplied scale.    *    * ORC uses those SerializationUtils methods for its serialization.    *    * A scratch bytes array is necessary to do the binary to decimal conversion for better    * performance.  Pass a FAST_SCRATCH_BUFFER_LEN_SERIALIZATION_UTILS_READ byte array for    * scratchBytes.    *    * @return The deserialized decimal or null if the conversion failed.    */
specifier|public
specifier|static
name|boolean
name|fastSerializationUtilsRead
parameter_list|(
name|InputStream
name|inputStream
parameter_list|,
name|int
name|scale
parameter_list|,
name|byte
index|[]
name|scratchBytes
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
throws|throws
name|IOException
throws|,
name|EOFException
block|{
comment|// Following a suggestion from Gopal, quickly read in the bytes from the stream.
comment|// CONSIDER: Have ORC read the whole input stream into a big byte array with one call to
comment|// the read(byte[] b, int off, int len) method and then let this method read from the big
comment|// byte array.
name|int
name|readCount
init|=
literal|0
decl_stmt|;
name|int
name|input
decl_stmt|;
do|do
block|{
name|input
operator|=
name|inputStream
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|input
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"Reading BigInteger past EOF from "
operator|+
name|inputStream
argument_list|)
throw|;
block|}
name|scratchBytes
index|[
name|readCount
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|input
expr_stmt|;
block|}
do|while
condition|(
name|input
operator|>=
literal|0x80
condition|)
do|;
comment|/*      * Determine the 3 binary words like what SerializationUtils.readBigInteger does.      */
name|long
name|lowerWord63
init|=
literal|0
decl_stmt|;
name|long
name|middleWord63
init|=
literal|0
decl_stmt|;
name|long
name|highWord63
init|=
literal|0
decl_stmt|;
name|long
name|work
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|readIndex
init|=
literal|0
decl_stmt|;
name|long
name|b
decl_stmt|;
do|do
block|{
name|b
operator|=
name|scratchBytes
index|[
name|readIndex
operator|++
index|]
expr_stmt|;
name|work
operator||=
operator|(
literal|0x7f
operator|&
name|b
operator|)
operator|<<
operator|(
name|offset
operator|%
literal|63
operator|)
expr_stmt|;
name|offset
operator|+=
literal|7
expr_stmt|;
comment|// if we've read 63 bits, roll them into the result
if|if
condition|(
name|offset
operator|==
literal|63
condition|)
block|{
name|lowerWord63
operator|=
name|work
expr_stmt|;
name|work
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|%
literal|63
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|offset
operator|==
literal|126
condition|)
block|{
name|middleWord63
operator|=
name|work
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|==
literal|189
condition|)
block|{
name|highWord63
operator|=
name|work
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"Reading more than 3 words of BigInteger"
argument_list|)
throw|;
block|}
name|work
operator|=
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
name|readIndex
operator|<
name|readCount
condition|)
do|;
if|if
condition|(
name|work
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|offset
operator|<
literal|63
condition|)
block|{
name|lowerWord63
operator|=
name|work
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|<
literal|126
condition|)
block|{
name|middleWord63
operator|=
name|work
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|<
literal|189
condition|)
block|{
name|highWord63
operator|=
name|work
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"Reading more than 3 words of BigInteger"
argument_list|)
throw|;
block|}
block|}
comment|// Grab sign bit and shift it away.
name|boolean
name|isNegative
init|=
operator|(
operator|(
name|lowerWord63
operator|&
literal|0x1
operator|)
operator|!=
literal|0
operator|)
decl_stmt|;
name|lowerWord63
operator|>>=
literal|1
expr_stmt|;
comment|/*      * Use common binary to decimal conversion method we share with fastSetFromBigIntegerBytes.      */
if|if
condition|(
operator|!
name|doBinaryToDecimalConversion
argument_list|(
name|lowerWord63
argument_list|,
name|middleWord63
argument_list|,
name|highWord63
argument_list|,
name|FAST_HIVE_DECIMAL_TWO_POWER_62
argument_list|,
name|FAST_HIVE_DECIMAL_TWO_POWER_125
argument_list|,
comment|// 2^(62 + 63)
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|isNegative
condition|)
block|{
comment|// Adjust negative result, again doing what SerializationUtils.readBigInteger does.
if|if
condition|(
operator|!
name|doAddSameScaleSameSign
argument_list|(
comment|/* resultSignum */
literal|1
argument_list|,
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|fastResult
operator|.
name|fast0
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast1
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast2
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
operator|(
name|isNegative
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
expr_stmt|;
specifier|final
name|int
name|rawPrecision
init|=
name|fastRawPrecision
argument_list|(
name|fastResult
argument_list|)
decl_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|rawPrecision
operator|-
name|scale
argument_list|)
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
name|scale
expr_stmt|;
comment|/*        * Just in case we deserialize a decimal with trailing zeroes...        */
specifier|final
name|int
name|resultTrailingZeroCount
init|=
name|fastTrailingDecimalZeroCount
argument_list|(
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
name|fastResult
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastResult
operator|.
name|fastScale
argument_list|)
decl_stmt|;
if|if
condition|(
name|resultTrailingZeroCount
operator|>
literal|0
condition|)
block|{
name|doFastScaleDown
argument_list|(
name|fastResult
argument_list|,
name|resultTrailingZeroCount
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|-=
name|resultTrailingZeroCount
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|//************************************************************************************************
comment|// Emulate SerializationUtils Serialization used by ORC.
comment|/**    * Write the value of this decimal just like SerializationUtils.writeBigInteger.  It header    * comments are:    *    *     Write the arbitrarily sized signed BigInteger in vint format.    *    *     Signed integers are encoded using the low bit as the sign bit using zigzag    *     encoding.    *    *     Each byte uses the low 7 bits for data and the high bit for stop/continue.    *    *     Bytes are stored LSB first.    *    * NOTE:    *    SerializationUtils.writeBigInteger sometimes pads the result with extra zeroes due to    *    BigInteger.bitLength -- we do not emulate that.  SerializationUtils.readBigInteger will    *    produce the same result for both.    *    * @return True if the decimal was successfully serialized into the output stream.    */
specifier|public
specifier|static
name|boolean
name|fastSerializationUtilsWrite
parameter_list|(
name|OutputStream
name|outputStream
parameter_list|,
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|long
index|[]
name|scratchLongs
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|isNegative
init|=
operator|(
name|fastSignum
operator|==
operator|-
literal|1
operator|)
decl_stmt|;
comment|/*      * The sign is encoded as the least significant bit.      *      * We need to adjust our decimal before conversion to binary.      *      * Positive:      *   Multiply by 2.      *      * Negative:      *   Logic in SerializationUtils.writeBigInteger does a negate on the BigInteger. We      *   do not have to since FastHiveDecimal stores the numbers unsigned in fast0, fast1,      *   and fast2.  We do need to subtract one though.      *      *   And then multiply by 2 and add in the 1 sign bit.      *      *   CONSIDER: This could be combined.      */
name|long
name|adjust0
decl_stmt|;
name|long
name|adjust1
decl_stmt|;
name|long
name|adjust2
decl_stmt|;
if|if
condition|(
name|isNegative
condition|)
block|{
comment|// Subtract 1.
name|long
name|r0
init|=
name|fast0
operator|-
literal|1
decl_stmt|;
name|long
name|r1
decl_stmt|;
if|if
condition|(
name|r0
operator|<
literal|0
condition|)
block|{
name|adjust0
operator|=
name|r0
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r1
operator|=
name|fast1
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|adjust0
operator|=
name|r0
expr_stmt|;
name|r1
operator|=
name|fast1
expr_stmt|;
block|}
if|if
condition|(
name|r1
operator|<
literal|0
condition|)
block|{
name|adjust1
operator|=
name|r1
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|adjust2
operator|=
name|fast2
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|adjust1
operator|=
name|r1
expr_stmt|;
name|adjust2
operator|=
name|fast2
expr_stmt|;
block|}
if|if
condition|(
name|adjust2
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Now multiply by 2 and add 1 sign bit.
name|r0
operator|=
name|adjust0
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
name|adjust0
operator|=
name|r0
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r1
operator|=
name|adjust1
operator|*
literal|2
operator|+
name|r0
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|adjust1
operator|=
name|r1
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|adjust2
operator|=
name|adjust2
operator|*
literal|2
operator|+
name|r1
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
block|}
else|else
block|{
comment|// Multiply by 2 to make room for 0 sign bit.
name|long
name|r0
init|=
name|fast0
operator|*
literal|2
decl_stmt|;
name|adjust0
operator|=
name|r0
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r1
init|=
name|fast1
operator|*
literal|2
operator|+
name|r0
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|adjust1
operator|=
name|r1
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|adjust2
operator|=
name|fast2
operator|*
literal|2
operator|+
name|r1
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
block|}
comment|/*      * Use common decimal to binary conversion method we share with fastBigIntegerBytes.      */
if|if
condition|(
operator|!
name|doDecimalToBinaryConversion
argument_list|(
name|adjust0
argument_list|,
name|adjust1
argument_list|,
name|adjust2
argument_list|,
name|FAST_HIVE_DECIMAL_TWO_POWER_63_INVERSE
argument_list|,
name|SERIALIZATION_UTILS_WRITE_QUOTIENT_INTEGER_WORD_NUM
argument_list|,
name|SERIALIZATION_UTILS_WRITE_QUOTIENT_INTEGER_DIGIT_NUM
argument_list|,
name|FAST_HIVE_DECIMAL_TWO_POWER_63
argument_list|,
name|scratchLongs
argument_list|)
condition|)
block|{
comment|// Overflow.
return|return
literal|false
return|;
block|}
name|long
name|lowerWord63
init|=
name|scratchLongs
index|[
literal|0
index|]
decl_stmt|;
name|long
name|middleWord63
init|=
name|scratchLongs
index|[
literal|1
index|]
decl_stmt|;
name|long
name|highWord63
init|=
name|scratchLongs
index|[
literal|2
index|]
decl_stmt|;
name|int
name|wordCount
decl_stmt|;
if|if
condition|(
name|highWord63
operator|!=
literal|0
condition|)
block|{
name|wordCount
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|middleWord63
operator|!=
literal|0
condition|)
block|{
name|wordCount
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|wordCount
operator|=
literal|1
expr_stmt|;
block|}
comment|// Write out the first 63 bits worth of data.
name|long
name|lowBits
init|=
name|lowerWord63
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
operator|++
name|i
control|)
block|{
comment|// If this is the last byte, leave the high bit off
if|if
condition|(
name|wordCount
operator|==
literal|1
operator|&&
operator|(
name|lowBits
operator|&
operator|~
literal|0x7f
operator|)
operator|==
literal|0
condition|)
block|{
name|outputStream
operator|.
name|write
argument_list|(
operator|(
name|byte
operator|)
name|lowBits
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|outputStream
operator|.
name|write
argument_list|(
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
name|lowBits
operator|&
literal|0x7f
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|lowBits
operator|>>>=
literal|7
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wordCount
operator|<=
literal|1
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Expecting write word count> 1"
argument_list|)
throw|;
block|}
name|lowBits
operator|=
name|middleWord63
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
operator|++
name|i
control|)
block|{
comment|// If this is the last byte, leave the high bit off
if|if
condition|(
name|wordCount
operator|==
literal|2
operator|&&
operator|(
name|lowBits
operator|&
operator|~
literal|0x7f
operator|)
operator|==
literal|0
condition|)
block|{
name|outputStream
operator|.
name|write
argument_list|(
operator|(
name|byte
operator|)
name|lowBits
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|outputStream
operator|.
name|write
argument_list|(
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
name|lowBits
operator|&
literal|0x7f
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|lowBits
operator|>>>=
literal|7
expr_stmt|;
block|}
block|}
name|lowBits
operator|=
name|highWord63
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
operator|++
name|i
control|)
block|{
comment|// If this is the last byte, leave the high bit off
if|if
condition|(
operator|(
name|lowBits
operator|&
operator|~
literal|0x7f
operator|)
operator|==
literal|0
condition|)
block|{
name|outputStream
operator|.
name|write
argument_list|(
operator|(
name|byte
operator|)
name|lowBits
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|outputStream
operator|.
name|write
argument_list|(
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
name|lowBits
operator|&
literal|0x7f
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|lowBits
operator|>>>=
literal|7
expr_stmt|;
block|}
block|}
comment|// Should not get here.
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected"
argument_list|)
throw|;
block|}
comment|//************************************************************************************************
comment|// Emulate BigInteger deserialization used by LazyBinary and others.
comment|/*    * fastSetFromBigIntegerBytes word size we choose is 56 bits to stay below the 64 bit sign bit:    * So, we need a multiplier 2^56    *    *    2^56 =    *      72057594037927936 or    *      72,057,594,037,927,936 or    *      7,2057594037927936  (16 digit comma'd)    */
specifier|private
specifier|static
name|FastHiveDecimal
name|FAST_HIVE_DECIMAL_TWO_POWER_56
init|=
operator|new
name|FastHiveDecimal
argument_list|(
literal|1
argument_list|,
literal|2057594037927936L
argument_list|,
literal|7L
argument_list|,
literal|0
argument_list|,
literal|17
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/*    * fastSetFromBigIntegerBytes high word multiplier is 2^(56 + 56)    *    *    (2^56)*(2^56) =    *      5192296858534827628530496329220096 or    *     (1234567890123456789012345678901234)    *     (         1         2         3    )    *      5,192,296,858,534,827,628,530,496,329,220,096 or    *      51,9229685853482762,8530496329220096  (16 digit comma'd)    */
specifier|private
specifier|static
name|FastHiveDecimal
name|FAST_HIVE_DECIMAL_TWO_POWER_112
init|=
operator|new
name|FastHiveDecimal
argument_list|(
literal|1
argument_list|,
literal|8530496329220096L
argument_list|,
literal|9229685853482762L
argument_list|,
literal|51L
argument_list|,
literal|34
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// Multiply by 1/2^56 or 1.387778780781445675529539585113525390625e-17 to divide by 2^56.
comment|// As 16 digit comma'd 13877787,8078144567552953,9585113525390625
comment|//
comment|// Scale down: 56 = 39 fraction digits + 17 (negative exponent or number of zeros after dot).
comment|//
comment|// 3*16 (48) + 8 --> 56 down shift.
comment|//
specifier|private
specifier|static
name|FastHiveDecimal
name|FAST_HIVE_DECIMAL_TWO_POWER_56_INVERSE
init|=
operator|new
name|FastHiveDecimal
argument_list|(
literal|1
argument_list|,
literal|9585113525390625L
argument_list|,
literal|8078144567552953L
argument_list|,
literal|13877787L
argument_list|,
literal|40
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/*    * Where in the inverse multiplication result to find the quotient integer decimal portion.    *    * Please see comments for doDecimalToBinaryDivisionRemainder.    */
specifier|private
specifier|static
specifier|final
name|int
name|BIG_INTEGER_BYTES_QUOTIENT_INTEGER_WORD_NUM
init|=
literal|3
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|BIG_INTEGER_BYTES_QUOTIENT_INTEGER_DIGIT_NUM
init|=
literal|8
decl_stmt|;
specifier|private
specifier|static
name|int
name|INITIAL_SHIFT
init|=
literal|48
decl_stmt|;
comment|// 56 bits minus 1 byte.
comment|// Long masks and values.
specifier|private
specifier|static
name|long
name|LONG_56_BIT_MASK
init|=
literal|0xFFFFFFFFFFFFFFL
decl_stmt|;
specifier|private
specifier|static
name|long
name|LONG_TWO_TO_56_POWER
init|=
name|LONG_56_BIT_MASK
operator|+
literal|1L
decl_stmt|;
specifier|private
specifier|static
name|long
name|LONG_BYTE_MASK
init|=
literal|0xFFL
decl_stmt|;
specifier|private
specifier|static
name|long
name|LONG_BYTE_HIGH_BIT_MASK
init|=
literal|0x80L
decl_stmt|;
comment|// Byte values.
specifier|private
specifier|static
name|byte
name|BYTE_ALL_BITS
init|=
operator|(
name|byte
operator|)
literal|0xFF
decl_stmt|;
comment|/**    * Convert bytes in the format used by BigInteger's toByteArray format (and accepted by its    * constructor) into a decimal using the specified scale.    *    * Our bigIntegerBytes methods create bytes in this format, too.    *    * This method is designed for high performance and does not create an actual BigInteger during    * binary to decimal conversion.    *    * @return    */
specifier|public
specifier|static
name|boolean
name|fastSetFromBigIntegerBytesAndScale
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|scale
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
specifier|final
name|int
name|bytesLength
init|=
name|bytes
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|offset
operator|>=
name|bytesLength
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|end
init|=
name|offset
operator|+
name|length
decl_stmt|;
if|if
condition|(
name|end
operator|<=
name|offset
operator|||
name|end
operator|>
name|bytesLength
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|startOffset
init|=
name|offset
decl_stmt|;
comment|// Roughly based on BigInteger code.
name|boolean
name|isNegative
init|=
operator|(
name|bytes
index|[
name|offset
index|]
operator|<
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|isNegative
condition|)
block|{
comment|// Find first non-sign (0xff) byte of input.
while|while
condition|(
name|offset
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|bytes
index|[
name|offset
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
break|break;
block|}
name|offset
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|>
name|end
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
comment|// Strip leading zeroes -- although there shouldn't be any for a decimal.
while|while
condition|(
name|offset
operator|<
name|end
operator|&&
name|bytes
index|[
name|offset
index|]
operator|==
literal|0
condition|)
block|{
name|offset
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|>=
name|end
condition|)
block|{
comment|// Zero.
return|return
literal|true
return|;
block|}
block|}
name|long
name|lowerWord56
init|=
literal|0
decl_stmt|;
name|long
name|middleWord56
init|=
literal|0
decl_stmt|;
name|long
name|highWord56
init|=
literal|0
decl_stmt|;
name|int
name|reverseIndex
init|=
name|end
decl_stmt|;
name|long
name|work
decl_stmt|;
name|int
name|shift
decl_stmt|;
specifier|final
name|int
name|lowestCount
init|=
name|Math
operator|.
name|min
argument_list|(
name|reverseIndex
operator|-
name|offset
argument_list|,
literal|7
argument_list|)
decl_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lowestCount
condition|;
name|i
operator|++
control|)
block|{
name|work
operator|=
name|bytes
index|[
operator|--
name|reverseIndex
index|]
operator|&
literal|0xFF
expr_stmt|;
name|lowerWord56
operator||=
name|work
operator|<<
name|shift
expr_stmt|;
name|shift
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|reverseIndex
operator|<=
name|offset
condition|)
block|{
if|if
condition|(
name|isNegative
condition|)
block|{
name|lowerWord56
operator|=
operator|~
name|lowerWord56
operator|&
operator|(
operator|(
literal|1L
operator|<<
name|shift
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Go on to middle word.
specifier|final
name|int
name|middleCount
init|=
name|Math
operator|.
name|min
argument_list|(
name|reverseIndex
operator|-
name|offset
argument_list|,
literal|7
argument_list|)
decl_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|middleCount
condition|;
name|i
operator|++
control|)
block|{
name|work
operator|=
name|bytes
index|[
operator|--
name|reverseIndex
index|]
operator|&
literal|0xFF
expr_stmt|;
name|middleWord56
operator||=
name|work
operator|<<
name|shift
expr_stmt|;
name|shift
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|reverseIndex
operator|<=
name|offset
condition|)
block|{
if|if
condition|(
name|isNegative
condition|)
block|{
name|lowerWord56
operator|=
operator|~
name|lowerWord56
operator|&
name|LONG_56_BIT_MASK
expr_stmt|;
name|middleWord56
operator|=
operator|~
name|middleWord56
operator|&
operator|(
operator|(
literal|1L
operator|<<
name|shift
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Go on to high word.
specifier|final
name|int
name|highCount
init|=
name|Math
operator|.
name|min
argument_list|(
name|reverseIndex
operator|-
name|offset
argument_list|,
literal|7
argument_list|)
decl_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|highCount
condition|;
name|i
operator|++
control|)
block|{
name|work
operator|=
name|bytes
index|[
operator|--
name|reverseIndex
index|]
operator|&
literal|0xFF
expr_stmt|;
name|highWord56
operator||=
name|work
operator|<<
name|shift
expr_stmt|;
name|shift
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|isNegative
condition|)
block|{
comment|// We only need to apply negation to all 3 words when there are 3 words, etc.
name|lowerWord56
operator|=
operator|~
name|lowerWord56
operator|&
name|LONG_56_BIT_MASK
expr_stmt|;
name|middleWord56
operator|=
operator|~
name|middleWord56
operator|&
name|LONG_56_BIT_MASK
expr_stmt|;
name|highWord56
operator|=
operator|~
name|highWord56
operator|&
operator|(
operator|(
literal|1L
operator|<<
name|shift
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|doBinaryToDecimalConversion
argument_list|(
name|lowerWord56
argument_list|,
name|middleWord56
argument_list|,
name|highWord56
argument_list|,
name|FAST_HIVE_DECIMAL_TWO_POWER_56
argument_list|,
name|FAST_HIVE_DECIMAL_TWO_POWER_112
argument_list|,
comment|// 2^(56 + 56)
name|fastResult
argument_list|)
condition|)
block|{
comment|// Overflow.  Use slower alternate.
return|return
name|doAlternateSetFromBigIntegerBytesAndScale
argument_list|(
name|bytes
argument_list|,
name|startOffset
argument_list|,
name|length
argument_list|,
name|scale
argument_list|,
name|fastResult
argument_list|)
return|;
block|}
comment|// System.out.println("fastSetFromBigIntegerBytesAndScale fast0 " + fastResult.fast0 + " fast1 " + fastResult.fast1 + " fast2 " + fastResult.fast2);
if|if
condition|(
name|isNegative
condition|)
block|{
if|if
condition|(
operator|!
name|doAddSameScaleSameSign
argument_list|(
comment|/* resultSignum */
literal|1
argument_list|,
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
comment|// Overflow.  Use slower alternate.
return|return
name|doAlternateSetFromBigIntegerBytesAndScale
argument_list|(
name|bytes
argument_list|,
name|startOffset
argument_list|,
name|length
argument_list|,
name|scale
argument_list|,
name|fastResult
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|fastResult
operator|.
name|fast0
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast1
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast2
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
operator|(
name|isNegative
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
name|scale
expr_stmt|;
specifier|final
name|int
name|rawPrecision
init|=
name|fastRawPrecision
argument_list|(
name|fastResult
argument_list|)
decl_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|rawPrecision
operator|-
name|scale
argument_list|)
expr_stmt|;
comment|/*        * Just in case we deserialize a decimal with trailing zeroes...        */
specifier|final
name|int
name|resultTrailingZeroCount
init|=
name|fastTrailingDecimalZeroCount
argument_list|(
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
name|fastResult
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastResult
operator|.
name|fastScale
argument_list|)
decl_stmt|;
if|if
condition|(
name|resultTrailingZeroCount
operator|>
literal|0
condition|)
block|{
name|doFastScaleDown
argument_list|(
name|fastResult
argument_list|,
name|resultTrailingZeroCount
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|-=
name|resultTrailingZeroCount
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * When fastSetFromBigIntegerBytesAndScale can handle the input because it is too large,    * we fall back to this.    */
specifier|private
specifier|static
name|boolean
name|doAlternateSetFromBigIntegerBytesAndScale
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|scale
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
name|byte
index|[]
name|byteArray
init|=
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|offset
operator|+
name|length
argument_list|)
decl_stmt|;
name|BigInteger
name|bigInteger
init|=
operator|new
name|BigInteger
argument_list|(
name|byteArray
argument_list|)
decl_stmt|;
comment|// System.out.println("doAlternateSetFromBigIntegerBytesAndScale bigInteger " + bigInteger);
name|BigDecimal
name|bigDecimal
init|=
operator|new
name|BigDecimal
argument_list|(
name|bigInteger
argument_list|,
name|scale
argument_list|)
decl_stmt|;
comment|// System.out.println("doAlternateSetFromBigIntegerBytesAndScale bigDecimal " + bigDecimal);
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
return|return
name|fastSetFromBigDecimal
argument_list|(
name|bigDecimal
argument_list|,
literal|true
argument_list|,
name|fastResult
argument_list|)
return|;
block|}
comment|//************************************************************************************************
comment|// Emulate BigInteger serialization used by LazyBinary, Avro, Parquet, and possibly others.
specifier|public
specifier|static
name|int
name|fastBigIntegerBytes
parameter_list|(
specifier|final
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|fastSerializeScale
parameter_list|,
name|long
index|[]
name|scratchLongs
parameter_list|,
name|byte
index|[]
name|buffer
parameter_list|)
block|{
if|if
condition|(
name|fastSerializeScale
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
name|fastBigIntegerBytesScaled
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|,
name|fastSerializeScale
argument_list|,
name|scratchLongs
argument_list|,
name|buffer
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|fastBigIntegerBytesUnscaled
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scratchLongs
argument_list|,
name|buffer
argument_list|)
return|;
block|}
block|}
comment|/**    * Return binary representation of this decimal's BigInteger equivalent unscaled value using    * the format that the BigInteger's toByteArray method returns (and the BigInteger constructor    * accepts).    *    * Used by LazyBinary, Avro, and Parquet serialization.    *    * Scratch objects necessary to do the decimal to binary conversion without actually creating a    * BigInteger object are passed for better performance.    *    * Allocate scratchLongs with SCRATCH_LONGS_LEN longs.    * And, allocate buffer with SCRATCH_BUFFER_LEN_BIG_INTEGER_BYTES bytes.    * @return The number of bytes used for the binary result in buffer.  Otherwise, 0 if the    *         conversion failed.    */
specifier|public
specifier|static
name|int
name|fastBigIntegerBytesUnscaled
parameter_list|(
specifier|final
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|long
index|[]
name|scratchLongs
parameter_list|,
name|byte
index|[]
name|buffer
parameter_list|)
block|{
comment|/*      * Algorithm:      * 1) Convert decimal to three 56-bit words (three is enough for the decimal since we      *    represent the decimal with trailing zeroes trimmed).      * 2) Skip leading zeroes in the words.      * 3) Once we find real data (i.e. a non-zero byte), add a sign byte to buffer if necessary.      * 4) Add bytes from the (rest of) 56-bit words.      * 5) Return byte count.      */
if|if
condition|(
name|fastSignum
operator|==
literal|0
condition|)
block|{
name|buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
name|boolean
name|isNegative
init|=
operator|(
name|fastSignum
operator|==
operator|-
literal|1
operator|)
decl_stmt|;
comment|/*      * Use common conversion method we share with fastSerializationUtilsWrite.      */
if|if
condition|(
operator|!
name|doDecimalToBinaryConversion
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|FAST_HIVE_DECIMAL_TWO_POWER_56_INVERSE
argument_list|,
name|BIG_INTEGER_BYTES_QUOTIENT_INTEGER_WORD_NUM
argument_list|,
name|BIG_INTEGER_BYTES_QUOTIENT_INTEGER_DIGIT_NUM
argument_list|,
name|FAST_HIVE_DECIMAL_TWO_POWER_56
argument_list|,
name|scratchLongs
argument_list|)
condition|)
block|{
comment|// Overflow.  This is not expected.
return|return
literal|0
return|;
block|}
name|int
name|byteIndex
init|=
literal|0
decl_stmt|;
name|long
name|word0
init|=
name|scratchLongs
index|[
literal|0
index|]
decl_stmt|;
name|long
name|word1
init|=
name|scratchLongs
index|[
literal|1
index|]
decl_stmt|;
name|long
name|word2
init|=
name|scratchLongs
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|isNegative
condition|)
block|{
comment|// Positive number.
name|long
name|longWork
init|=
literal|0
decl_stmt|;
name|int
name|shift
init|=
name|INITIAL_SHIFT
decl_stmt|;
if|if
condition|(
name|word2
operator|!=
literal|0L
condition|)
block|{
comment|// Skip leading zeroes in word2.
while|while
condition|(
literal|true
condition|)
block|{
name|longWork
operator|=
operator|(
name|word2
operator|>>
name|shift
operator|)
operator|&
name|LONG_BYTE_MASK
expr_stmt|;
if|if
condition|(
name|longWork
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected #1"
argument_list|)
throw|;
block|}
name|shift
operator|-=
name|Byte
operator|.
name|SIZE
expr_stmt|;
block|}
comment|// Now that we have found real data, emit sign byte if necessary.
if|if
condition|(
operator|(
name|longWork
operator|&
name|LONG_BYTE_HIGH_BIT_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// Add sign byte since high bit is on.
name|buffer
index|[
name|byteIndex
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
literal|0
expr_stmt|;
block|}
comment|// Emit the rest of word2
while|while
condition|(
literal|true
condition|)
block|{
name|buffer
index|[
name|byteIndex
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|longWork
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|shift
operator|-=
name|Byte
operator|.
name|SIZE
expr_stmt|;
name|longWork
operator|=
operator|(
name|word2
operator|>>
name|shift
operator|)
operator|&
name|LONG_BYTE_MASK
expr_stmt|;
block|}
name|shift
operator|=
name|INITIAL_SHIFT
expr_stmt|;
block|}
if|if
condition|(
name|byteIndex
operator|==
literal|0
operator|&&
name|word1
operator|==
literal|0L
condition|)
block|{
comment|// Skip word1, also.
block|}
else|else
block|{
if|if
condition|(
name|byteIndex
operator|==
literal|0
condition|)
block|{
comment|// Skip leading zeroes in word1.
while|while
condition|(
literal|true
condition|)
block|{
name|longWork
operator|=
operator|(
name|word1
operator|>>
name|shift
operator|)
operator|&
name|LONG_BYTE_MASK
expr_stmt|;
if|if
condition|(
name|longWork
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected #2"
argument_list|)
throw|;
block|}
name|shift
operator|-=
name|Byte
operator|.
name|SIZE
expr_stmt|;
block|}
comment|// Now that we have found real data, emit sign byte if necessary.
if|if
condition|(
operator|(
name|longWork
operator|&
name|LONG_BYTE_HIGH_BIT_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// Add sign byte since high bit is on.
name|buffer
index|[
name|byteIndex
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|longWork
operator|=
operator|(
name|word1
operator|>>
name|shift
operator|)
operator|&
name|LONG_BYTE_MASK
expr_stmt|;
block|}
comment|// Emit the rest of word1
while|while
condition|(
literal|true
condition|)
block|{
name|buffer
index|[
name|byteIndex
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|longWork
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|shift
operator|-=
name|Byte
operator|.
name|SIZE
expr_stmt|;
name|longWork
operator|=
operator|(
name|word1
operator|>>
name|shift
operator|)
operator|&
name|LONG_BYTE_MASK
expr_stmt|;
block|}
name|shift
operator|=
name|INITIAL_SHIFT
expr_stmt|;
block|}
if|if
condition|(
name|byteIndex
operator|==
literal|0
condition|)
block|{
comment|// Skip leading zeroes in word0.
while|while
condition|(
literal|true
condition|)
block|{
name|longWork
operator|=
operator|(
name|word0
operator|>>
name|shift
operator|)
operator|&
name|LONG_BYTE_MASK
expr_stmt|;
if|if
condition|(
name|longWork
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
block|{
comment|// All zeroes -- we should have handled this earlier.
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected #3"
argument_list|)
throw|;
block|}
name|shift
operator|-=
name|Byte
operator|.
name|SIZE
expr_stmt|;
block|}
comment|// Now that we have found real data, emit sign byte if necessary.
if|if
condition|(
operator|(
name|longWork
operator|&
name|LONG_BYTE_HIGH_BIT_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// Add sign byte since high bit is on.
name|buffer
index|[
name|byteIndex
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|longWork
operator|=
operator|(
name|word0
operator|>>
name|shift
operator|)
operator|&
name|LONG_BYTE_MASK
expr_stmt|;
block|}
comment|// Emit the rest of word0.
while|while
condition|(
literal|true
condition|)
block|{
name|buffer
index|[
name|byteIndex
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|longWork
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|shift
operator|-=
name|Byte
operator|.
name|SIZE
expr_stmt|;
name|longWork
operator|=
operator|(
name|word0
operator|>>
name|shift
operator|)
operator|&
name|LONG_BYTE_MASK
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Negative number.
comment|// Subtract 1 for two's compliment adjustment.
name|word0
operator|--
expr_stmt|;
if|if
condition|(
name|word0
operator|<
literal|0
condition|)
block|{
name|word0
operator|+=
name|LONG_TWO_TO_56_POWER
expr_stmt|;
name|word1
operator|--
expr_stmt|;
if|if
condition|(
name|word1
operator|<
literal|0
condition|)
block|{
name|word1
operator|+=
name|LONG_TWO_TO_56_POWER
expr_stmt|;
name|word2
operator|--
expr_stmt|;
if|if
condition|(
name|word2
operator|<
literal|0
condition|)
block|{
comment|// Underflow.
return|return
literal|0
return|;
block|}
block|}
block|}
name|long
name|longWork
init|=
literal|0
decl_stmt|;
name|int
name|shift
init|=
name|INITIAL_SHIFT
decl_stmt|;
if|if
condition|(
name|word2
operator|!=
literal|0L
condition|)
block|{
comment|// Skip leading zeroes in word2.
while|while
condition|(
literal|true
condition|)
block|{
name|longWork
operator|=
operator|(
name|word2
operator|>>
name|shift
operator|)
operator|&
name|LONG_BYTE_MASK
expr_stmt|;
if|if
condition|(
name|longWork
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected #1"
argument_list|)
throw|;
block|}
name|shift
operator|-=
name|Byte
operator|.
name|SIZE
expr_stmt|;
block|}
comment|// Now that we have found real data, emit sign byte if necessary and do negative fixup.
name|longWork
operator|=
operator|(
operator|~
name|longWork
operator|&
name|LONG_BYTE_MASK
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|longWork
operator|)
operator|&
name|LONG_BYTE_HIGH_BIT_MASK
operator|)
operator|==
literal|0
condition|)
block|{
comment|// Add sign byte since high bit is off.
name|buffer
index|[
name|byteIndex
operator|++
index|]
operator|=
name|BYTE_ALL_BITS
expr_stmt|;
block|}
comment|// Invert words.
name|word2
operator|=
operator|~
name|word2
expr_stmt|;
name|word1
operator|=
operator|~
name|word1
expr_stmt|;
name|word0
operator|=
operator|~
name|word0
expr_stmt|;
comment|// Emit the rest of word2
while|while
condition|(
literal|true
condition|)
block|{
name|buffer
index|[
name|byteIndex
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|longWork
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|shift
operator|-=
name|Byte
operator|.
name|SIZE
expr_stmt|;
name|longWork
operator|=
operator|(
name|word2
operator|>>
name|shift
operator|)
operator|&
name|LONG_BYTE_MASK
expr_stmt|;
block|}
name|shift
operator|=
name|INITIAL_SHIFT
expr_stmt|;
block|}
if|if
condition|(
name|byteIndex
operator|==
literal|0
operator|&&
name|word1
operator|==
literal|0L
condition|)
block|{
comment|// Skip word1, also.
block|}
else|else
block|{
if|if
condition|(
name|byteIndex
operator|==
literal|0
condition|)
block|{
comment|// Skip leading zeroes in word1.
while|while
condition|(
literal|true
condition|)
block|{
name|longWork
operator|=
operator|(
name|word1
operator|>>
name|shift
operator|)
operator|&
name|LONG_BYTE_MASK
expr_stmt|;
if|if
condition|(
name|longWork
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected #2"
argument_list|)
throw|;
block|}
name|shift
operator|-=
name|Byte
operator|.
name|SIZE
expr_stmt|;
block|}
comment|// Now that we have found real data, emit sign byte if necessary and do negative fixup.
name|longWork
operator|=
operator|(
operator|~
name|longWork
operator|&
name|LONG_BYTE_MASK
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|longWork
operator|&
name|LONG_BYTE_HIGH_BIT_MASK
operator|)
operator|==
literal|0
condition|)
block|{
comment|// Add sign byte since high bit is off.
name|buffer
index|[
name|byteIndex
operator|++
index|]
operator|=
name|BYTE_ALL_BITS
expr_stmt|;
block|}
comment|// Invert words.
name|word1
operator|=
operator|~
name|word1
expr_stmt|;
name|word0
operator|=
operator|~
name|word0
expr_stmt|;
block|}
else|else
block|{
name|longWork
operator|=
operator|(
name|word1
operator|>>
name|shift
operator|)
operator|&
name|LONG_BYTE_MASK
expr_stmt|;
block|}
comment|// Emit the rest of word1
while|while
condition|(
literal|true
condition|)
block|{
name|buffer
index|[
name|byteIndex
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|longWork
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|shift
operator|-=
name|Byte
operator|.
name|SIZE
expr_stmt|;
name|longWork
operator|=
operator|(
name|word1
operator|>>
name|shift
operator|)
operator|&
name|LONG_BYTE_MASK
expr_stmt|;
block|}
name|shift
operator|=
name|INITIAL_SHIFT
expr_stmt|;
block|}
if|if
condition|(
name|byteIndex
operator|==
literal|0
condition|)
block|{
comment|// Skip leading zeroes in word0.
while|while
condition|(
literal|true
condition|)
block|{
name|longWork
operator|=
operator|(
name|word0
operator|>>
name|shift
operator|)
operator|&
name|LONG_BYTE_MASK
expr_stmt|;
if|if
condition|(
name|longWork
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
block|{
comment|// All zeroes.
comment|// -1 special case.  Unsigned magnitude 1 - two's compliment adjustment 1 = 0.
name|buffer
index|[
literal|0
index|]
operator|=
name|BYTE_ALL_BITS
expr_stmt|;
return|return
literal|1
return|;
block|}
name|shift
operator|-=
name|Byte
operator|.
name|SIZE
expr_stmt|;
block|}
comment|// Now that we have found real data, emit sign byte if necessary and do negative fixup.
name|longWork
operator|=
operator|(
operator|~
name|longWork
operator|&
name|LONG_BYTE_MASK
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|longWork
operator|&
name|LONG_BYTE_HIGH_BIT_MASK
operator|)
operator|==
literal|0
condition|)
block|{
comment|// Add sign byte since high bit is off.
name|buffer
index|[
name|byteIndex
operator|++
index|]
operator|=
name|BYTE_ALL_BITS
expr_stmt|;
block|}
comment|// Invert words.
name|word0
operator|=
operator|~
name|word0
expr_stmt|;
block|}
else|else
block|{
name|longWork
operator|=
operator|(
name|word0
operator|>>
name|shift
operator|)
operator|&
name|LONG_BYTE_MASK
expr_stmt|;
block|}
comment|// Emit the rest of word0.
while|while
condition|(
literal|true
condition|)
block|{
name|buffer
index|[
name|byteIndex
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|longWork
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|shift
operator|-=
name|Byte
operator|.
name|SIZE
expr_stmt|;
name|longWork
operator|=
operator|(
name|word0
operator|>>
name|shift
operator|)
operator|&
name|LONG_BYTE_MASK
expr_stmt|;
block|}
block|}
return|return
name|byteIndex
return|;
block|}
comment|/**    * Convert decimal to BigInteger binary bytes with a serialize scale, similar to the formatScale    * for toFormatString.  It adds trailing zeroes when a serializeScale is greater than current    * scale.  Or, rounds if scale is less than current scale.    *    * Used by Avro and Parquet serialization.    *    * This emulates the OldHiveDecimal setScale / OldHiveDecimal getInternalStorage() behavior.    *    * @param serializeScale    * @param scratchLongs    * @param buffer    * @return    */
specifier|public
specifier|static
name|int
name|fastBigIntegerBytesScaled
parameter_list|(
specifier|final
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|serializeScale
parameter_list|,
name|long
index|[]
name|scratchLongs
parameter_list|,
name|byte
index|[]
name|buffer
parameter_list|)
block|{
comment|// Normally, trailing fractional digits are removed.  But to emulate the
comment|// OldHiveDecimal setScale and OldHiveDecimalWritable internalStorage, we need to trailing zeroes
comment|// here.
comment|//
comment|// NOTE: This can cause a decimal that has too many decimal digits (because of trailing zeroes)
comment|//       for us to represent.  In that case, we punt and convert with a BigInteger alternate
comment|//       code.
if|if
condition|(
name|fastSignum
operator|==
literal|0
operator|||
name|serializeScale
operator|==
name|fastScale
condition|)
block|{
return|return
name|fastBigIntegerBytesUnscaled
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scratchLongs
argument_list|,
name|buffer
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|serializeScale
operator|>
name|fastScale
condition|)
block|{
specifier|final
name|int
name|scaleUp
init|=
name|serializeScale
operator|-
name|fastScale
decl_stmt|;
specifier|final
name|int
name|maxScale
init|=
name|HiveDecimal
operator|.
name|MAX_SCALE
operator|-
name|fastIntegerDigitCount
decl_stmt|;
if|if
condition|(
name|serializeScale
operator|>
name|maxScale
condition|)
block|{
comment|// We cannot to scaled up decimals that cannot be represented.
comment|// Instead, we use a BigInteger instead.
name|BigInteger
name|bigInteger
init|=
name|fastBigIntegerValueUnscaled
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|)
decl_stmt|;
name|BigInteger
name|bigIntegerScaled
init|=
name|bigInteger
operator|.
name|multiply
argument_list|(
name|BIG_INTEGER_TEN
operator|.
name|pow
argument_list|(
name|scaleUp
argument_list|)
argument_list|)
decl_stmt|;
name|byte
index|[]
name|bigIntegerBytesScaled
init|=
name|bigIntegerScaled
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
specifier|final
name|int
name|length
init|=
name|bigIntegerBytesScaled
operator|.
name|length
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|bigIntegerBytesScaled
argument_list|,
literal|0
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
name|FastHiveDecimal
name|fastTemp
init|=
operator|new
name|FastHiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fastScaleUp
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scaleUp
argument_list|,
name|fastTemp
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected"
argument_list|)
throw|;
block|}
return|return
name|fastBigIntegerBytesUnscaled
argument_list|(
name|fastSignum
argument_list|,
name|fastTemp
operator|.
name|fast0
argument_list|,
name|fastTemp
operator|.
name|fast1
argument_list|,
name|fastTemp
operator|.
name|fast2
argument_list|,
name|scratchLongs
argument_list|,
name|buffer
argument_list|)
return|;
block|}
else|else
block|{
comment|// serializeScale< fastScale.
name|FastHiveDecimal
name|fastTemp
init|=
operator|new
name|FastHiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fastRound
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|,
name|serializeScale
argument_list|,
name|BigDecimal
operator|.
name|ROUND_HALF_UP
argument_list|,
name|fastTemp
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|fastBigIntegerBytesUnscaled
argument_list|(
name|fastSignum
argument_list|,
name|fastTemp
operator|.
name|fast0
argument_list|,
name|fastTemp
operator|.
name|fast1
argument_list|,
name|fastTemp
operator|.
name|fast2
argument_list|,
name|scratchLongs
argument_list|,
name|buffer
argument_list|)
return|;
block|}
block|}
comment|//************************************************************************************************
comment|// Decimal to Integer conversion.
specifier|private
specifier|static
specifier|final
name|int
name|MAX_BYTE_DIGITS
init|=
literal|3
decl_stmt|;
specifier|private
specifier|static
name|FastHiveDecimal
name|FASTHIVEDECIMAL_MIN_BYTE_VALUE_MINUS_ONE
init|=
operator|new
name|FastHiveDecimal
argument_list|(
operator|(
name|long
operator|)
name|Byte
operator|.
name|MIN_VALUE
operator|-
literal|1L
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|FastHiveDecimal
name|FASTHIVEDECIMAL_MAX_BYTE_VALUE_PLUS_ONE
init|=
operator|new
name|FastHiveDecimal
argument_list|(
operator|(
name|long
operator|)
name|Byte
operator|.
name|MAX_VALUE
operator|+
literal|1L
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|MAX_SHORT_DIGITS
init|=
literal|5
decl_stmt|;
specifier|private
specifier|static
name|FastHiveDecimal
name|FASTHIVEDECIMAL_MIN_SHORT_VALUE_MINUS_ONE
init|=
operator|new
name|FastHiveDecimal
argument_list|(
operator|(
name|long
operator|)
name|Short
operator|.
name|MIN_VALUE
operator|-
literal|1L
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|FastHiveDecimal
name|FASTHIVEDECIMAL_MAX_SHORT_VALUE_PLUS_ONE
init|=
operator|new
name|FastHiveDecimal
argument_list|(
operator|(
name|long
operator|)
name|Short
operator|.
name|MAX_VALUE
operator|+
literal|1L
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|MAX_INT_DIGITS
init|=
literal|10
decl_stmt|;
specifier|private
specifier|static
name|FastHiveDecimal
name|FASTHIVEDECIMAL_MIN_INT_VALUE_MINUS_ONE
init|=
operator|new
name|FastHiveDecimal
argument_list|(
operator|(
name|long
operator|)
name|Integer
operator|.
name|MIN_VALUE
operator|-
literal|1L
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|FastHiveDecimal
name|FASTHIVEDECIMAL_MAX_INT_VALUE_PLUS_ONE
init|=
operator|new
name|FastHiveDecimal
argument_list|(
operator|(
name|long
operator|)
name|Integer
operator|.
name|MAX_VALUE
operator|+
literal|1L
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|FastHiveDecimal
name|FASTHIVEDECIMAL_MIN_LONG_VALUE
init|=
operator|new
name|FastHiveDecimal
argument_list|(
name|Long
operator|.
name|MIN_VALUE
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|FastHiveDecimal
name|FASTHIVEDECIMAL_MAX_LONG_VALUE
init|=
operator|new
name|FastHiveDecimal
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|MAX_LONG_DIGITS
init|=
name|FASTHIVEDECIMAL_MAX_LONG_VALUE
operator|.
name|fastIntegerDigitCount
decl_stmt|;
specifier|private
specifier|static
name|FastHiveDecimal
name|FASTHIVEDECIMAL_MIN_LONG_VALUE_MINUS_ONE
init|=
operator|new
name|FastHiveDecimal
argument_list|(
literal|"-9223372036854775809"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|FastHiveDecimal
name|FASTHIVEDECIMAL_MAX_LONG_VALUE_PLUS_ONE
init|=
operator|new
name|FastHiveDecimal
argument_list|(
literal|"9223372036854775808"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|BigInteger
name|BIG_INTEGER_UNSIGNED_BYTE_MAX_VALUE
init|=
name|BIG_INTEGER_TWO
operator|.
name|pow
argument_list|(
name|Byte
operator|.
name|SIZE
argument_list|)
operator|.
name|subtract
argument_list|(
name|BigInteger
operator|.
name|ONE
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|BigInteger
name|BIG_INTEGER_UNSIGNED_SHORT_MAX_VALUE
init|=
name|BIG_INTEGER_TWO
operator|.
name|pow
argument_list|(
name|Short
operator|.
name|SIZE
argument_list|)
operator|.
name|subtract
argument_list|(
name|BigInteger
operator|.
name|ONE
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|BigInteger
name|BIG_INTEGER_UNSIGNED_INT_MAX_VALUE
init|=
name|BIG_INTEGER_TWO
operator|.
name|pow
argument_list|(
name|Integer
operator|.
name|SIZE
argument_list|)
operator|.
name|subtract
argument_list|(
name|BigInteger
operator|.
name|ONE
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|BigInteger
name|BIG_INTEGER_UNSIGNED_LONG_MAX_VALUE
init|=
name|BIG_INTEGER_TWO
operator|.
name|pow
argument_list|(
name|Long
operator|.
name|SIZE
argument_list|)
operator|.
name|subtract
argument_list|(
name|BigInteger
operator|.
name|ONE
argument_list|)
decl_stmt|;
comment|/**    * Is the decimal value a byte? Range -128            to      127.    *                                    Byte.MIN_VALUE          Byte.MAX_VALUE    *    * Emulates testing for no value corruption:    *      bigDecimalValue().setScale(0).equals(BigDecimal.valueOf(bigDecimalValue().byteValue()))    *    * NOTE: Fractional digits are ignored in the test since fastByteValueClip() will    *       remove them (round down).    *    * @return True when fastByteValueClip() will return a correct byte.    */
specifier|public
specifier|static
name|boolean
name|fastIsByte
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|)
block|{
if|if
condition|(
name|fastIntegerDigitCount
operator|<
name|MAX_BYTE_DIGITS
condition|)
block|{
comment|// Definitely a byte; most bytes fall here
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|fastIntegerDigitCount
operator|>
name|MAX_BYTE_DIGITS
condition|)
block|{
comment|// Definitely not a byte.
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|fastScale
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fast1
operator|!=
literal|0
operator|||
name|fast2
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fastSignum
operator|==
literal|1
condition|)
block|{
return|return
operator|(
name|fast0
operator|<=
name|Byte
operator|.
name|MAX_VALUE
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
operator|-
name|fast0
operator|>=
name|Byte
operator|.
name|MIN_VALUE
operator|)
return|;
block|}
block|}
else|else
block|{
comment|// We need to work a little harder for our comparison.  Note we round down for
comment|// integer conversion so anything below the next min/max will work.
if|if
condition|(
name|fastSignum
operator|==
literal|1
condition|)
block|{
return|return
operator|(
name|fastCompareTo
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastScale
argument_list|,
name|FASTHIVEDECIMAL_MAX_BYTE_VALUE_PLUS_ONE
argument_list|)
operator|<
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|fastCompareTo
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastScale
argument_list|,
name|FASTHIVEDECIMAL_MIN_BYTE_VALUE_MINUS_ONE
argument_list|)
operator|>
literal|0
operator|)
return|;
block|}
block|}
block|}
comment|// We use "Clip" in the name because this method will return a corrupted value when
comment|// fastIsByte returns false.
specifier|public
specifier|static
name|byte
name|fastByteValueClip
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|)
block|{
if|if
condition|(
name|fastScale
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fast1
operator|==
literal|0
operator|&&
name|fast2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fastSignum
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|fast0
operator|<=
name|Byte
operator|.
name|MAX_VALUE
condition|)
block|{
return|return
operator|(
name|byte
operator|)
name|fast0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|-
name|fast0
operator|>=
name|Byte
operator|.
name|MIN_VALUE
condition|)
block|{
return|return
operator|(
name|byte
operator|)
operator|-
name|fast0
return|;
block|}
empty_stmt|;
block|}
block|}
comment|// SLOW: Do remainder with BigInteger.
name|BigInteger
name|bigInteger
init|=
name|fastBigIntegerValueUnscaled
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|)
decl_stmt|;
return|return
name|bigInteger
operator|.
name|remainder
argument_list|(
name|BIG_INTEGER_UNSIGNED_BYTE_MAX_VALUE
argument_list|)
operator|.
name|byteValue
argument_list|()
return|;
block|}
else|else
block|{
comment|// Adjust all longs using power 10 division/remainder.
name|long
name|result0
decl_stmt|;
name|long
name|result1
decl_stmt|;
name|long
name|result2
decl_stmt|;
if|if
condition|(
name|fastScale
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Part of lowest word survives.
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|fastScale
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|fastScale
index|]
decl_stmt|;
name|result0
operator|=
name|fast0
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result1
operator|=
name|fast1
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result2
operator|=
name|fast2
operator|/
name|divideFactor
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fastScale
operator|<
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Throw away lowest word.
specifier|final
name|int
name|adjustedScaleDown
init|=
name|fastScale
operator|-
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|adjustedScaleDown
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|adjustedScaleDown
index|]
decl_stmt|;
name|result0
operator|=
name|fast1
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result1
operator|=
name|fast2
operator|/
name|divideFactor
expr_stmt|;
name|result2
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// Throw away middle and lowest words.
specifier|final
name|int
name|adjustedScaleDown
init|=
name|fastScale
operator|-
literal|2
operator|*
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
name|result0
operator|=
name|fast2
operator|/
name|powerOfTenTable
index|[
name|adjustedScaleDown
index|]
expr_stmt|;
name|result1
operator|=
literal|0
expr_stmt|;
name|result2
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|result1
operator|==
literal|0
operator|&&
name|result2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fastSignum
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|result0
operator|<=
name|Byte
operator|.
name|MAX_VALUE
condition|)
block|{
return|return
operator|(
name|byte
operator|)
name|result0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|-
name|result0
operator|>=
name|Byte
operator|.
name|MIN_VALUE
condition|)
block|{
return|return
operator|(
name|byte
operator|)
operator|-
name|result0
return|;
block|}
empty_stmt|;
block|}
block|}
comment|// SLOW: Do remainder with BigInteger.
name|BigInteger
name|bigInteger
init|=
name|fastBigIntegerValueUnscaled
argument_list|(
name|fastSignum
argument_list|,
name|result0
argument_list|,
name|result1
argument_list|,
name|result2
argument_list|)
decl_stmt|;
return|return
name|bigInteger
operator|.
name|remainder
argument_list|(
name|BIG_INTEGER_UNSIGNED_BYTE_MAX_VALUE
argument_list|)
operator|.
name|byteValue
argument_list|()
return|;
block|}
block|}
comment|/**     * @return True when shortValue() will return a correct short.    */
comment|/**    * Is the decimal value a short? Range -32,768         to     32,767.    *                                     Short.MIN_VALUE        Short.MAX_VALUE    *    * Emulates testing for no value corruption:    *      bigDecimalValue().setScale(0).equals(BigDecimal.valueOf(bigDecimalValue().shortValue()))    *    * NOTE: Fractional digits are ignored in the test since fastShortValueClip() will    *       remove them (round down).    *    * @return True when fastShortValueClip() will return a correct short.    */
specifier|public
specifier|static
name|boolean
name|fastIsShort
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|)
block|{
if|if
condition|(
name|fastIntegerDigitCount
operator|<
name|MAX_SHORT_DIGITS
condition|)
block|{
comment|// Definitely a short; most shorts fall here
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|fastIntegerDigitCount
operator|>
name|MAX_SHORT_DIGITS
condition|)
block|{
comment|// Definitely not a short.
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|fastScale
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fast1
operator|!=
literal|0
operator|||
name|fast2
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fastSignum
operator|==
literal|1
condition|)
block|{
return|return
operator|(
name|fast0
operator|<=
name|Short
operator|.
name|MAX_VALUE
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
operator|-
name|fast0
operator|>=
name|Short
operator|.
name|MIN_VALUE
operator|)
return|;
block|}
block|}
else|else
block|{
comment|// We need to work a little harder for our comparison.  Note we round down for
comment|// integer conversion so anything below the next min/max will work.
if|if
condition|(
name|fastSignum
operator|==
literal|1
condition|)
block|{
return|return
operator|(
name|fastCompareTo
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastScale
argument_list|,
name|FASTHIVEDECIMAL_MAX_SHORT_VALUE_PLUS_ONE
argument_list|)
operator|<
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|fastCompareTo
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastScale
argument_list|,
name|FASTHIVEDECIMAL_MIN_SHORT_VALUE_MINUS_ONE
argument_list|)
operator|>
literal|0
operator|)
return|;
block|}
block|}
block|}
comment|// We use "Clip" in the name because this method will return a corrupted value when
comment|// fastIsShort returns false.
specifier|public
specifier|static
name|short
name|fastShortValueClip
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|)
block|{
if|if
condition|(
name|fastScale
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fast1
operator|==
literal|0
operator|&&
name|fast2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fastSignum
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|fast0
operator|<=
name|Short
operator|.
name|MAX_VALUE
condition|)
block|{
return|return
operator|(
name|short
operator|)
name|fast0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|-
name|fast0
operator|>=
name|Short
operator|.
name|MIN_VALUE
condition|)
block|{
return|return
operator|(
name|short
operator|)
operator|-
name|fast0
return|;
block|}
empty_stmt|;
block|}
block|}
comment|// SLOW: Do remainder with BigInteger.
name|BigInteger
name|bigInteger
init|=
name|fastBigIntegerValueUnscaled
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|)
decl_stmt|;
return|return
name|bigInteger
operator|.
name|remainder
argument_list|(
name|BIG_INTEGER_UNSIGNED_SHORT_MAX_VALUE
argument_list|)
operator|.
name|shortValue
argument_list|()
return|;
block|}
else|else
block|{
comment|// Adjust all longs using power 10 division/remainder.
name|long
name|result0
decl_stmt|;
name|long
name|result1
decl_stmt|;
name|long
name|result2
decl_stmt|;
if|if
condition|(
name|fastScale
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Part of lowest word survives.
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|fastScale
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|fastScale
index|]
decl_stmt|;
name|result0
operator|=
name|fast0
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result1
operator|=
name|fast1
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result2
operator|=
name|fast2
operator|/
name|divideFactor
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fastScale
operator|<
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Throw away lowest word.
specifier|final
name|int
name|adjustedScaleDown
init|=
name|fastScale
operator|-
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|adjustedScaleDown
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|adjustedScaleDown
index|]
decl_stmt|;
name|result0
operator|=
name|fast1
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result1
operator|=
name|fast2
operator|/
name|divideFactor
expr_stmt|;
name|result2
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// Throw away middle and lowest words.
specifier|final
name|int
name|adjustedScaleDown
init|=
name|fastScale
operator|-
literal|2
operator|*
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
name|result0
operator|=
name|fast2
operator|/
name|powerOfTenTable
index|[
name|adjustedScaleDown
index|]
expr_stmt|;
name|result1
operator|=
literal|0
expr_stmt|;
name|result2
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|result1
operator|==
literal|0
operator|&&
name|result2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fastSignum
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|result0
operator|<=
name|Short
operator|.
name|MAX_VALUE
condition|)
block|{
return|return
operator|(
name|short
operator|)
name|result0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|-
name|result0
operator|>=
name|Short
operator|.
name|MIN_VALUE
condition|)
block|{
return|return
operator|(
name|short
operator|)
operator|-
name|result0
return|;
block|}
empty_stmt|;
block|}
block|}
comment|// SLOW: Do remainder with BigInteger.
name|BigInteger
name|bigInteger
init|=
name|fastBigIntegerValueUnscaled
argument_list|(
name|fastSignum
argument_list|,
name|result0
argument_list|,
name|result1
argument_list|,
name|result2
argument_list|)
decl_stmt|;
return|return
name|bigInteger
operator|.
name|remainder
argument_list|(
name|BIG_INTEGER_UNSIGNED_SHORT_MAX_VALUE
argument_list|)
operator|.
name|shortValue
argument_list|()
return|;
block|}
block|}
comment|/**    * Is the decimal value a int? Range -2,147,483,648     to   2,147,483,647.    *                                   Integer.MIN_VALUE       Integer.MAX_VALUE    *    * Emulates testing for no value corruption:    *      bigDecimalValue().setScale(0).equals(BigDecimal.valueOf(bigDecimalValue().intValue()))    *    * NOTE: Fractional digits are ignored in the test since fastIntValueClip() will    *       remove them (round down).    *    * @return True when fastIntValueClip() will return a correct int.    */
specifier|public
specifier|static
name|boolean
name|fastIsInt
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|)
block|{
if|if
condition|(
name|fastIntegerDigitCount
operator|<
name|MAX_INT_DIGITS
condition|)
block|{
comment|// Definitely a int; most ints fall here
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|fastIntegerDigitCount
operator|>
name|MAX_INT_DIGITS
condition|)
block|{
comment|// Definitely not an int.
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|fastScale
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fast1
operator|!=
literal|0
operator|||
name|fast2
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fastSignum
operator|==
literal|1
condition|)
block|{
return|return
operator|(
name|fast0
operator|<=
name|Integer
operator|.
name|MAX_VALUE
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
operator|-
name|fast0
operator|>=
name|Integer
operator|.
name|MIN_VALUE
operator|)
return|;
block|}
block|}
else|else
block|{
comment|// We need to work a little harder for our comparison.  Note we round down for
comment|// integer conversion so anything below the next min/max will work.
if|if
condition|(
name|fastSignum
operator|==
literal|1
condition|)
block|{
return|return
operator|(
name|fastCompareTo
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastScale
argument_list|,
name|FASTHIVEDECIMAL_MAX_INT_VALUE_PLUS_ONE
argument_list|)
operator|<
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|fastCompareTo
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastScale
argument_list|,
name|FASTHIVEDECIMAL_MIN_INT_VALUE_MINUS_ONE
argument_list|)
operator|>
literal|0
operator|)
return|;
block|}
block|}
block|}
comment|// We use "Clip" in the name because this method will return a corrupted value when
comment|// fastIsInt returns false.
specifier|public
specifier|static
name|int
name|fastIntValueClip
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|)
block|{
if|if
condition|(
name|fastScale
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fast1
operator|==
literal|0
operator|&&
name|fast2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fastSignum
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|fast0
operator|<=
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
return|return
operator|(
name|int
operator|)
name|fast0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|-
name|fast0
operator|>=
name|Integer
operator|.
name|MIN_VALUE
condition|)
block|{
return|return
operator|(
name|int
operator|)
operator|-
name|fast0
return|;
block|}
empty_stmt|;
block|}
block|}
comment|// SLOW: Do remainder with BigInteger.
name|BigInteger
name|bigInteger
init|=
name|fastBigIntegerValueUnscaled
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|)
decl_stmt|;
return|return
name|bigInteger
operator|.
name|remainder
argument_list|(
name|BIG_INTEGER_UNSIGNED_INT_MAX_VALUE
argument_list|)
operator|.
name|intValue
argument_list|()
return|;
block|}
else|else
block|{
comment|// Adjust all longs using power 10 division/remainder.
name|long
name|result0
decl_stmt|;
name|long
name|result1
decl_stmt|;
name|long
name|result2
decl_stmt|;
if|if
condition|(
name|fastScale
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Part of lowest word survives.
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|fastScale
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|fastScale
index|]
decl_stmt|;
name|result0
operator|=
name|fast0
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result1
operator|=
name|fast1
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result2
operator|=
name|fast2
operator|/
name|divideFactor
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fastScale
operator|<
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Throw away lowest word.
specifier|final
name|int
name|adjustedScaleDown
init|=
name|fastScale
operator|-
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|adjustedScaleDown
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|adjustedScaleDown
index|]
decl_stmt|;
name|result0
operator|=
name|fast1
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result1
operator|=
name|fast2
operator|/
name|divideFactor
expr_stmt|;
name|result2
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// Throw away middle and lowest words.
specifier|final
name|int
name|adjustedScaleDown
init|=
name|fastScale
operator|-
literal|2
operator|*
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
name|result0
operator|=
name|fast2
operator|/
name|powerOfTenTable
index|[
name|adjustedScaleDown
index|]
expr_stmt|;
name|result1
operator|=
literal|0
expr_stmt|;
name|result2
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|result1
operator|==
literal|0
operator|&&
name|result2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fastSignum
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|result0
operator|<=
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
return|return
operator|(
name|int
operator|)
name|result0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|-
name|result0
operator|>=
name|Integer
operator|.
name|MIN_VALUE
condition|)
block|{
return|return
operator|(
name|int
operator|)
operator|-
name|result0
return|;
block|}
empty_stmt|;
block|}
block|}
comment|// SLOW: Do remainder with BigInteger.
name|BigInteger
name|bigInteger
init|=
name|fastBigIntegerValueUnscaled
argument_list|(
name|fastSignum
argument_list|,
name|result0
argument_list|,
name|result1
argument_list|,
name|result2
argument_list|)
decl_stmt|;
return|return
name|bigInteger
operator|.
name|remainder
argument_list|(
name|BIG_INTEGER_UNSIGNED_INT_MAX_VALUE
argument_list|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
comment|/**    * Is the decimal value a long? Range -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.    *                                    Long.MIN_VALUE                Long.MAX_VALUE    *    * Emulates testing for no value corruption:    *      bigDecimalValue().setScale(0).equals(BigDecimal.valueOf(bigDecimalValue().longValue()))    *    * NOTE: Fractional digits are ignored in the test since fastLongValueClip() will    *       remove them (round down).    *    * @return True when fastLongValueClip() will return a correct long.    */
specifier|public
specifier|static
name|boolean
name|fastIsLong
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|)
block|{
if|if
condition|(
name|fastIntegerDigitCount
operator|<
name|MAX_LONG_DIGITS
condition|)
block|{
comment|// Definitely a long; most longs fall here
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|fastIntegerDigitCount
operator|>
name|MAX_LONG_DIGITS
condition|)
block|{
comment|// Definitely not a long.
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|fastScale
operator|==
literal|0
condition|)
block|{
comment|// From the above checks, we know fast2 is zero.
if|if
condition|(
name|fastSignum
operator|==
literal|1
condition|)
block|{
name|FastHiveDecimal
name|max
init|=
name|FASTHIVEDECIMAL_MAX_LONG_VALUE
decl_stmt|;
if|if
condition|(
name|fast1
operator|>
name|max
operator|.
name|fast1
operator|||
operator|(
name|fast1
operator|==
name|max
operator|.
name|fast1
operator|&&
name|fast0
operator|>
name|max
operator|.
name|fast0
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
else|else
block|{
name|FastHiveDecimal
name|min
init|=
name|FASTHIVEDECIMAL_MIN_LONG_VALUE
decl_stmt|;
if|if
condition|(
name|fast1
operator|>
name|min
operator|.
name|fast1
operator|||
operator|(
name|fast1
operator|==
name|min
operator|.
name|fast1
operator|&&
name|fast0
operator|>
name|min
operator|.
name|fast0
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
else|else
block|{
comment|// We need to work a little harder for our comparison.  Note we round down for
comment|// integer conversion so anything below the next min/max will work.
if|if
condition|(
name|fastSignum
operator|==
literal|1
condition|)
block|{
return|return
operator|(
name|fastCompareTo
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastScale
argument_list|,
name|FASTHIVEDECIMAL_MAX_LONG_VALUE_PLUS_ONE
argument_list|)
operator|<
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|fastCompareTo
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastScale
argument_list|,
name|FASTHIVEDECIMAL_MIN_LONG_VALUE_MINUS_ONE
argument_list|)
operator|>
literal|0
operator|)
return|;
block|}
block|}
block|}
comment|// We use "Clip" in the name because this method will return a corrupted value when
comment|// fastIsLong returns false.
specifier|public
specifier|static
name|long
name|fastLongValueClip
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|)
block|{
if|if
condition|(
name|fastSignum
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fastScale
operator|==
literal|0
condition|)
block|{
comment|// Do first comparison as unsigned.
if|if
condition|(
name|fastCompareTo
argument_list|(
literal|1
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastScale
argument_list|,
name|FASTHIVEDECIMAL_MAX_LONG_VALUE
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|fastSignum
operator|==
literal|1
condition|)
block|{
return|return
name|fast1
operator|*
name|MULTIPLER_LONGWORD_DECIMAL
operator|+
name|fast0
return|;
block|}
else|else
block|{
return|return
operator|-
operator|(
name|fast1
operator|*
name|MULTIPLER_LONGWORD_DECIMAL
operator|+
name|fast0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|fastEquals
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastScale
argument_list|,
name|FASTHIVEDECIMAL_MIN_LONG_VALUE
argument_list|)
condition|)
block|{
return|return
name|Long
operator|.
name|MIN_VALUE
return|;
block|}
else|else
block|{
comment|// SLOW: Do remainder with BigInteger.
name|BigInteger
name|bigInteger
init|=
name|fastBigIntegerValueUnscaled
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|)
decl_stmt|;
return|return
name|bigInteger
operator|.
name|remainder
argument_list|(
name|BIG_INTEGER_UNSIGNED_LONG_MAX_VALUE
argument_list|)
operator|.
name|longValue
argument_list|()
return|;
block|}
block|}
else|else
block|{
comment|// Adjust all longs using power 10 division/remainder.
name|long
name|result0
decl_stmt|;
name|long
name|result1
decl_stmt|;
name|long
name|result2
decl_stmt|;
if|if
condition|(
name|fastScale
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Part of lowest word survives.
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|fastScale
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|fastScale
index|]
decl_stmt|;
name|result0
operator|=
name|fast0
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result1
operator|=
name|fast1
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result2
operator|=
name|fast2
operator|/
name|divideFactor
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fastScale
operator|<
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Throw away lowest word.
specifier|final
name|int
name|adjustedScaleDown
init|=
name|fastScale
operator|-
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|adjustedScaleDown
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|adjustedScaleDown
index|]
decl_stmt|;
name|result0
operator|=
name|fast1
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result1
operator|=
name|fast2
operator|/
name|divideFactor
expr_stmt|;
name|result2
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// Throw away middle and lowest words.
specifier|final
name|int
name|adjustedScaleDown
init|=
name|fastScale
operator|-
literal|2
operator|*
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
name|result0
operator|=
name|fast2
operator|/
name|powerOfTenTable
index|[
name|adjustedScaleDown
index|]
expr_stmt|;
name|result1
operator|=
literal|0
expr_stmt|;
name|result2
operator|=
literal|0
expr_stmt|;
block|}
comment|// Do first comparison as UNSIGNED.
if|if
condition|(
name|fastCompareTo
argument_list|(
literal|1
argument_list|,
name|result0
argument_list|,
name|result1
argument_list|,
name|result2
argument_list|,
comment|/* fastScale */
literal|0
argument_list|,
name|FASTHIVEDECIMAL_MAX_LONG_VALUE
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|fastSignum
operator|==
literal|1
condition|)
block|{
return|return
name|result1
operator|*
name|MULTIPLER_LONGWORD_DECIMAL
operator|+
name|result0
return|;
block|}
else|else
block|{
return|return
operator|-
operator|(
name|result1
operator|*
name|MULTIPLER_LONGWORD_DECIMAL
operator|+
name|result0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|fastEquals
argument_list|(
name|fastSignum
argument_list|,
name|result0
argument_list|,
name|result1
argument_list|,
name|result2
argument_list|,
comment|/* fastScale */
literal|0
argument_list|,
name|FASTHIVEDECIMAL_MIN_LONG_VALUE
argument_list|)
condition|)
block|{
comment|// SIGNED comparison to Long.MIN_VALUE decimal.
return|return
name|Long
operator|.
name|MIN_VALUE
return|;
block|}
else|else
block|{
comment|// SLOW: Do remainder with BigInteger.
name|BigInteger
name|bigInteger
init|=
name|fastBigIntegerValueUnscaled
argument_list|(
name|fastSignum
argument_list|,
name|result0
argument_list|,
name|result1
argument_list|,
name|result2
argument_list|)
decl_stmt|;
return|return
name|bigInteger
operator|.
name|remainder
argument_list|(
name|BIG_INTEGER_UNSIGNED_LONG_MAX_VALUE
argument_list|)
operator|.
name|longValue
argument_list|()
return|;
block|}
block|}
block|}
comment|//************************************************************************************************
comment|// Decimal to Non-Integer conversion.
specifier|public
specifier|static
name|float
name|fastFloatValue
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|)
block|{
if|if
condition|(
name|fastSignum
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|BigDecimal
name|bigDecimal
init|=
name|fastBigDecimalValue
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|)
decl_stmt|;
return|return
name|bigDecimal
operator|.
name|floatValue
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|double
name|fastDoubleValue
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|)
block|{
if|if
condition|(
name|fastSignum
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|// CONSIDER: Looked at the possibility of faster decimal to double conversion by using some
comment|//           of their lower level logic that extracts the various parts out of a double.
comment|//           The difficulty is Java's rounding rules are byzantine.
name|BigDecimal
name|bigDecimal
init|=
name|fastBigDecimalValue
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|)
decl_stmt|;
return|return
name|bigDecimal
operator|.
name|doubleValue
argument_list|()
return|;
block|}
comment|/**    * Get a BigInteger representing the decimal's digits without a dot.    *    * @return Returns a signed BigInteger.    */
specifier|public
specifier|static
name|BigInteger
name|fastBigIntegerValue
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|fastSerializationScale
parameter_list|)
block|{
if|if
condition|(
name|fastSerializationScale
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
name|fastBigIntegerValueScaled
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|,
name|fastSerializationScale
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|fastBigIntegerValueUnscaled
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
name|BigInteger
name|fastBigIntegerValueUnscaled
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|)
block|{
if|if
condition|(
name|fastSignum
operator|==
literal|0
condition|)
block|{
return|return
name|BigInteger
operator|.
name|ZERO
return|;
block|}
name|BigInteger
name|result
decl_stmt|;
if|if
condition|(
name|fast2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fast1
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|fast0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|fast0
argument_list|)
operator|.
name|add
argument_list|(
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|fast1
argument_list|)
operator|.
name|multiply
argument_list|(
name|BIG_INTEGER_LONGWORD_MULTIPLIER
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|result
operator|=
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|fast0
argument_list|)
operator|.
name|add
argument_list|(
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|fast1
argument_list|)
operator|.
name|multiply
argument_list|(
name|BIG_INTEGER_LONGWORD_MULTIPLIER
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|fast2
argument_list|)
operator|.
name|multiply
argument_list|(
name|BIG_INTEGER_LONGWORD_MULTIPLIER_2X
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fastSignum
operator|==
literal|1
condition|?
name|result
else|:
name|result
operator|.
name|negate
argument_list|()
operator|)
return|;
block|}
specifier|public
specifier|static
name|BigInteger
name|fastBigIntegerValueScaled
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|fastSerializationScale
parameter_list|)
block|{
comment|// Use the serialization scale and create a BigInteger with trailing zeroes (or
comment|// round the decimal) if necessary.
comment|//
comment|// Since we are emulating old behavior and recommending the use of HiveDecimal.bigIntegerBytesScaled
comment|// instead just do it the slow way.  Get the BigDecimal.setScale value and return the
comment|// BigInteger.
comment|//
name|BigDecimal
name|bigDecimal
init|=
name|fastBigDecimalValue
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|)
decl_stmt|;
name|bigDecimal
operator|=
name|bigDecimal
operator|.
name|setScale
argument_list|(
name|fastSerializationScale
argument_list|,
name|RoundingMode
operator|.
name|HALF_UP
argument_list|)
expr_stmt|;
return|return
name|bigDecimal
operator|.
name|unscaledValue
argument_list|()
return|;
block|}
comment|/**    * Return a BigDecimal representing the decimal.  The BigDecimal class is able to accurately    * represent the decimal.    *    * NOTE: We are not representing our decimal as BigDecimal now as OldHiveDecimal did, so this    * is now slower.    *    * @return    */
specifier|public
specifier|static
name|BigDecimal
name|fastBigDecimalValue
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|)
block|{
name|BigInteger
name|unscaledValue
init|=
name|fastBigIntegerValueUnscaled
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|)
decl_stmt|;
return|return
operator|new
name|BigDecimal
argument_list|(
name|unscaledValue
argument_list|,
name|fastScale
argument_list|)
return|;
block|}
comment|//************************************************************************************************
comment|// Decimal Comparison.
specifier|public
specifier|static
name|int
name|fastCompareTo
parameter_list|(
name|int
name|leftSignum
parameter_list|,
name|long
name|leftFast0
parameter_list|,
name|long
name|leftFast1
parameter_list|,
name|long
name|leftFast2
parameter_list|,
name|int
name|leftScale
parameter_list|,
name|FastHiveDecimal
name|fastRight
parameter_list|)
block|{
return|return
name|fastCompareTo
argument_list|(
name|leftSignum
argument_list|,
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
name|leftScale
argument_list|,
name|fastRight
operator|.
name|fastSignum
argument_list|,
name|fastRight
operator|.
name|fast0
argument_list|,
name|fastRight
operator|.
name|fast1
argument_list|,
name|fastRight
operator|.
name|fast2
argument_list|,
name|fastRight
operator|.
name|fastScale
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|doCompareToSameScale
parameter_list|(
name|int
name|signum
parameter_list|,
name|long
name|leftFast0
parameter_list|,
name|long
name|leftFast1
parameter_list|,
name|long
name|leftFast2
parameter_list|,
name|long
name|rightFast0
parameter_list|,
name|long
name|rightFast1
parameter_list|,
name|long
name|rightFast2
parameter_list|)
block|{
if|if
condition|(
name|leftFast0
operator|==
name|rightFast0
operator|&&
name|leftFast1
operator|==
name|rightFast1
operator|&&
name|leftFast2
operator|==
name|rightFast2
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|leftFast2
operator|<
name|rightFast2
condition|)
block|{
return|return
operator|-
name|signum
return|;
block|}
elseif|else
if|if
condition|(
name|leftFast2
operator|>
name|rightFast2
condition|)
block|{
return|return
name|signum
return|;
block|}
if|if
condition|(
name|leftFast1
operator|<
name|rightFast1
condition|)
block|{
return|return
operator|-
name|signum
return|;
block|}
elseif|else
if|if
condition|(
name|leftFast1
operator|>
name|rightFast1
condition|)
block|{
return|return
name|signum
return|;
block|}
return|return
operator|(
name|leftFast0
operator|<
name|rightFast0
condition|?
operator|-
name|signum
else|:
name|signum
operator|)
return|;
block|}
specifier|public
specifier|static
name|int
name|fastCompareTo
parameter_list|(
name|int
name|leftSignum
parameter_list|,
name|long
name|leftFast0
parameter_list|,
name|long
name|leftFast1
parameter_list|,
name|long
name|leftFast2
parameter_list|,
name|int
name|leftScale
parameter_list|,
name|int
name|rightSignum
parameter_list|,
name|long
name|rightFast0
parameter_list|,
name|long
name|rightFast1
parameter_list|,
name|long
name|rightFast2
parameter_list|,
name|int
name|rightScale
parameter_list|)
block|{
if|if
condition|(
name|leftSignum
operator|==
literal|0
operator|&&
name|rightSignum
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|// Optimization copied from BigDecimal.
name|int
name|signDiff
init|=
name|leftSignum
operator|-
name|rightSignum
decl_stmt|;
if|if
condition|(
name|signDiff
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|signDiff
operator|>
literal|0
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
block|}
comment|// We are here when the left and right are non-zero and have the same sign.
if|if
condition|(
name|leftScale
operator|==
name|rightScale
condition|)
block|{
return|return
name|doCompareToSameScale
argument_list|(
name|leftSignum
argument_list|,
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
name|rightFast0
argument_list|,
name|rightFast1
argument_list|,
name|rightFast2
argument_list|)
return|;
block|}
else|else
block|{
comment|// How do we handle different scales?
comment|// We at least know they are not equal.  The one with the larger scale has non-zero digits
comment|// below the other's scale (since the scale does not include trailing zeroes).
comment|// For comparison purposes, we can scale away those digits.  And, we can not scale up since
comment|// that could overflow.
comment|// Use modified portions of doFastScaleDown code here since we do not want to allocate a
comment|// temporary FastHiveDecimal object.
name|long
name|compare0
decl_stmt|;
name|long
name|compare1
decl_stmt|;
name|long
name|compare2
decl_stmt|;
name|int
name|scaleDown
decl_stmt|;
if|if
condition|(
name|leftScale
operator|<
name|rightScale
condition|)
block|{
comment|// Scale down right and compare.
name|scaleDown
operator|=
name|rightScale
operator|-
name|leftScale
expr_stmt|;
comment|// Adjust all longs using power 10 division/remainder.
if|if
condition|(
name|scaleDown
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Part of lowest word survives.
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|scaleDown
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|scaleDown
index|]
decl_stmt|;
name|compare0
operator|=
name|rightFast0
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|rightFast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|compare1
operator|=
name|rightFast1
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|rightFast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|compare2
operator|=
name|rightFast2
operator|/
name|divideFactor
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scaleDown
operator|<
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Throw away lowest word.
specifier|final
name|int
name|adjustedScaleDown
init|=
name|scaleDown
operator|-
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|adjustedScaleDown
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|adjustedScaleDown
index|]
decl_stmt|;
name|compare0
operator|=
name|rightFast1
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|rightFast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|compare1
operator|=
name|rightFast2
operator|/
name|divideFactor
expr_stmt|;
name|compare2
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// Throw away middle and lowest words.
specifier|final
name|int
name|adjustedScaleDown
init|=
name|scaleDown
operator|-
name|TWO_X_LONGWORD_DECIMAL_DIGITS
decl_stmt|;
name|compare0
operator|=
name|rightFast2
operator|/
name|powerOfTenTable
index|[
name|adjustedScaleDown
index|]
expr_stmt|;
name|compare1
operator|=
literal|0
expr_stmt|;
name|compare2
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|leftFast0
operator|==
name|compare0
operator|&&
name|leftFast1
operator|==
name|compare1
operator|&&
name|leftFast2
operator|==
name|compare2
condition|)
block|{
comment|// Return less than because of right's digits below left's scale.
return|return
operator|-
name|leftSignum
return|;
block|}
if|if
condition|(
name|leftFast2
operator|<
name|compare2
condition|)
block|{
return|return
operator|-
name|leftSignum
return|;
block|}
elseif|else
if|if
condition|(
name|leftFast2
operator|>
name|compare2
condition|)
block|{
return|return
name|leftSignum
return|;
block|}
if|if
condition|(
name|leftFast1
operator|<
name|compare1
condition|)
block|{
return|return
operator|-
name|leftSignum
return|;
block|}
elseif|else
if|if
condition|(
name|leftFast1
operator|>
name|compare1
condition|)
block|{
return|return
name|leftSignum
return|;
block|}
return|return
operator|(
name|leftFast0
operator|<
name|compare0
condition|?
operator|-
name|leftSignum
else|:
name|leftSignum
operator|)
return|;
block|}
else|else
block|{
comment|// Scale down left and compare.
name|scaleDown
operator|=
name|leftScale
operator|-
name|rightScale
expr_stmt|;
comment|// Adjust all longs using power 10 division/remainder.
if|if
condition|(
name|scaleDown
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Part of lowest word survives.
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|scaleDown
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|scaleDown
index|]
decl_stmt|;
name|compare1
operator|=
name|leftFast1
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|leftFast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|compare0
operator|=
name|leftFast0
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|leftFast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|compare2
operator|=
name|leftFast2
operator|/
name|divideFactor
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scaleDown
operator|<
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Throw away lowest word.
specifier|final
name|int
name|adjustedScaleDown
init|=
name|scaleDown
operator|-
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|adjustedScaleDown
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|adjustedScaleDown
index|]
decl_stmt|;
name|compare0
operator|=
name|leftFast1
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|leftFast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|compare1
operator|=
name|leftFast2
operator|/
name|divideFactor
expr_stmt|;
name|compare2
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// Throw away middle and lowest words.
specifier|final
name|int
name|adjustedScaleDown
init|=
name|scaleDown
operator|-
literal|2
operator|*
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
name|compare0
operator|=
name|leftFast2
operator|/
name|powerOfTenTable
index|[
name|adjustedScaleDown
index|]
expr_stmt|;
name|compare1
operator|=
literal|0
expr_stmt|;
name|compare2
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|compare0
operator|==
name|rightFast0
operator|&&
name|compare1
operator|==
name|rightFast1
operator|&&
name|compare2
operator|==
name|rightFast2
condition|)
block|{
comment|// Return greater than because of left's digits below right's scale.
return|return
name|leftSignum
return|;
block|}
if|if
condition|(
name|compare2
operator|<
name|rightFast2
condition|)
block|{
return|return
operator|-
name|leftSignum
return|;
block|}
elseif|else
if|if
condition|(
name|compare2
operator|>
name|rightFast2
condition|)
block|{
return|return
name|leftSignum
return|;
block|}
if|if
condition|(
name|compare1
operator|<
name|rightFast1
condition|)
block|{
return|return
operator|-
name|leftSignum
return|;
block|}
elseif|else
if|if
condition|(
name|compare1
operator|>
name|rightFast1
condition|)
block|{
return|return
name|leftSignum
return|;
block|}
return|return
operator|(
name|compare0
operator|<
name|rightFast0
condition|?
operator|-
name|leftSignum
else|:
name|leftSignum
operator|)
return|;
block|}
block|}
block|}
specifier|public
specifier|static
name|boolean
name|fastEquals
parameter_list|(
name|int
name|leftSignum
parameter_list|,
name|long
name|leftFast0
parameter_list|,
name|long
name|leftFast1
parameter_list|,
name|long
name|leftFast2
parameter_list|,
name|int
name|leftScale
parameter_list|,
name|FastHiveDecimal
name|fastRight
parameter_list|)
block|{
if|if
condition|(
name|leftSignum
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|fastRight
operator|.
name|fastSignum
operator|==
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|leftSignum
operator|!=
name|fastRight
operator|.
name|fastSignum
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|leftScale
operator|!=
name|fastRight
operator|.
name|fastScale
condition|)
block|{
comment|// We know they are not equal because the one with the larger scale has non-zero digits
comment|// below the other's scale (since the scale does not include trailing zeroes).
return|return
literal|false
return|;
block|}
return|return
operator|(
name|leftFast0
operator|==
name|fastRight
operator|.
name|fast0
operator|&&
name|leftFast1
operator|==
name|fastRight
operator|.
name|fast1
operator|&&
name|leftFast2
operator|==
name|fastRight
operator|.
name|fast2
operator|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|fastEquals
parameter_list|(
name|int
name|leftSignum
parameter_list|,
name|long
name|leftFast0
parameter_list|,
name|long
name|leftFast1
parameter_list|,
name|long
name|leftFast2
parameter_list|,
name|int
name|leftScale
parameter_list|,
name|int
name|rightSignum
parameter_list|,
name|long
name|rightFast0
parameter_list|,
name|long
name|rightFast1
parameter_list|,
name|long
name|rightFast2
parameter_list|,
name|int
name|rightScale
parameter_list|)
block|{
if|if
condition|(
name|leftSignum
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|rightSignum
operator|==
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|leftSignum
operator|!=
name|rightSignum
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|leftScale
operator|!=
name|rightScale
condition|)
block|{
comment|// We know they are not equal because the one with the larger scale has non-zero digits
comment|// below the other's scale (since the scale does not include trailing zeroes).
return|return
literal|false
return|;
block|}
return|return
operator|(
name|leftFast0
operator|==
name|rightFast0
operator|&&
name|leftFast1
operator|==
name|rightFast1
operator|&&
name|leftFast2
operator|==
name|rightFast2
operator|)
return|;
block|}
specifier|private
specifier|static
name|int
name|doCalculateNewFasterHashCode
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|)
block|{
name|long
name|longHashCode
decl_stmt|;
name|long
name|key
init|=
name|fast0
decl_stmt|;
comment|// Hash code logic from calculateLongHashCode.
name|key
operator|=
operator|(
operator|~
name|key
operator|)
operator|+
operator|(
name|key
operator|<<
literal|21
operator|)
expr_stmt|;
comment|// key = (key<< 21) - key - 1;
name|key
operator|=
name|key
operator|^
operator|(
name|key
operator|>>>
literal|24
operator|)
expr_stmt|;
name|key
operator|=
operator|(
name|key
operator|+
operator|(
name|key
operator|<<
literal|3
operator|)
operator|)
operator|+
operator|(
name|key
operator|<<
literal|8
operator|)
expr_stmt|;
comment|// key * 265
name|key
operator|=
name|key
operator|^
operator|(
name|key
operator|>>>
literal|14
operator|)
expr_stmt|;
name|key
operator|=
operator|(
name|key
operator|+
operator|(
name|key
operator|<<
literal|2
operator|)
operator|)
operator|+
operator|(
name|key
operator|<<
literal|4
operator|)
expr_stmt|;
comment|// key * 21
name|key
operator|=
name|key
operator|^
operator|(
name|key
operator|>>>
literal|28
operator|)
expr_stmt|;
name|key
operator|=
name|key
operator|+
operator|(
name|key
operator|<<
literal|31
operator|)
expr_stmt|;
name|longHashCode
operator|=
name|key
expr_stmt|;
name|key
operator|=
name|fast1
expr_stmt|;
name|key
operator|=
operator|(
operator|~
name|key
operator|)
operator|+
operator|(
name|key
operator|<<
literal|21
operator|)
expr_stmt|;
comment|// key = (key<< 21) - key - 1;
name|key
operator|=
name|key
operator|^
operator|(
name|key
operator|>>>
literal|24
operator|)
expr_stmt|;
name|key
operator|=
operator|(
name|key
operator|+
operator|(
name|key
operator|<<
literal|3
operator|)
operator|)
operator|+
operator|(
name|key
operator|<<
literal|8
operator|)
expr_stmt|;
comment|// key * 265
name|key
operator|=
name|key
operator|^
operator|(
name|key
operator|>>>
literal|14
operator|)
expr_stmt|;
name|key
operator|=
operator|(
name|key
operator|+
operator|(
name|key
operator|<<
literal|2
operator|)
operator|)
operator|+
operator|(
name|key
operator|<<
literal|4
operator|)
expr_stmt|;
comment|// key * 21
name|key
operator|=
name|key
operator|^
operator|(
name|key
operator|>>>
literal|28
operator|)
expr_stmt|;
name|key
operator|=
name|key
operator|+
operator|(
name|key
operator|<<
literal|31
operator|)
expr_stmt|;
name|longHashCode
operator|^=
name|key
expr_stmt|;
name|key
operator|=
name|fast2
expr_stmt|;
name|key
operator|=
operator|(
operator|~
name|key
operator|)
operator|+
operator|(
name|key
operator|<<
literal|21
operator|)
expr_stmt|;
comment|// key = (key<< 21) - key - 1;
name|key
operator|=
name|key
operator|^
operator|(
name|key
operator|>>>
literal|24
operator|)
expr_stmt|;
name|key
operator|=
operator|(
name|key
operator|+
operator|(
name|key
operator|<<
literal|3
operator|)
operator|)
operator|+
operator|(
name|key
operator|<<
literal|8
operator|)
expr_stmt|;
comment|// key * 265
name|key
operator|=
name|key
operator|^
operator|(
name|key
operator|>>>
literal|14
operator|)
expr_stmt|;
name|key
operator|=
operator|(
name|key
operator|+
operator|(
name|key
operator|<<
literal|2
operator|)
operator|)
operator|+
operator|(
name|key
operator|<<
literal|4
operator|)
expr_stmt|;
comment|// key * 21
name|key
operator|=
name|key
operator|^
operator|(
name|key
operator|>>>
literal|28
operator|)
expr_stmt|;
name|key
operator|=
name|key
operator|+
operator|(
name|key
operator|<<
literal|31
operator|)
expr_stmt|;
name|longHashCode
operator|^=
name|key
expr_stmt|;
name|key
operator|=
name|fastSignum
expr_stmt|;
name|key
operator|=
operator|(
operator|~
name|key
operator|)
operator|+
operator|(
name|key
operator|<<
literal|21
operator|)
expr_stmt|;
comment|// key = (key<< 21) - key - 1;
name|key
operator|=
name|key
operator|^
operator|(
name|key
operator|>>>
literal|24
operator|)
expr_stmt|;
name|key
operator|=
operator|(
name|key
operator|+
operator|(
name|key
operator|<<
literal|3
operator|)
operator|)
operator|+
operator|(
name|key
operator|<<
literal|8
operator|)
expr_stmt|;
comment|// key * 265
name|key
operator|=
name|key
operator|^
operator|(
name|key
operator|>>>
literal|14
operator|)
expr_stmt|;
name|key
operator|=
operator|(
name|key
operator|+
operator|(
name|key
operator|<<
literal|2
operator|)
operator|)
operator|+
operator|(
name|key
operator|<<
literal|4
operator|)
expr_stmt|;
comment|// key * 21
name|key
operator|=
name|key
operator|^
operator|(
name|key
operator|>>>
literal|28
operator|)
expr_stmt|;
name|key
operator|=
name|key
operator|+
operator|(
name|key
operator|<<
literal|31
operator|)
expr_stmt|;
name|longHashCode
operator|^=
name|key
expr_stmt|;
name|key
operator|=
name|fastIntegerDigitCount
expr_stmt|;
name|key
operator|=
operator|(
operator|~
name|key
operator|)
operator|+
operator|(
name|key
operator|<<
literal|21
operator|)
expr_stmt|;
comment|// key = (key<< 21) - key - 1;
name|key
operator|=
name|key
operator|^
operator|(
name|key
operator|>>>
literal|24
operator|)
expr_stmt|;
name|key
operator|=
operator|(
name|key
operator|+
operator|(
name|key
operator|<<
literal|3
operator|)
operator|)
operator|+
operator|(
name|key
operator|<<
literal|8
operator|)
expr_stmt|;
comment|// key * 265
name|key
operator|=
name|key
operator|^
operator|(
name|key
operator|>>>
literal|14
operator|)
expr_stmt|;
name|key
operator|=
operator|(
name|key
operator|+
operator|(
name|key
operator|<<
literal|2
operator|)
operator|)
operator|+
operator|(
name|key
operator|<<
literal|4
operator|)
expr_stmt|;
comment|// key * 21
name|key
operator|=
name|key
operator|^
operator|(
name|key
operator|>>>
literal|28
operator|)
expr_stmt|;
name|key
operator|=
name|key
operator|+
operator|(
name|key
operator|<<
literal|31
operator|)
expr_stmt|;
name|longHashCode
operator|^=
name|key
expr_stmt|;
name|key
operator|=
name|fastScale
expr_stmt|;
name|key
operator|=
operator|(
operator|~
name|key
operator|)
operator|+
operator|(
name|key
operator|<<
literal|21
operator|)
expr_stmt|;
comment|// key = (key<< 21) - key - 1;
name|key
operator|=
name|key
operator|^
operator|(
name|key
operator|>>>
literal|24
operator|)
expr_stmt|;
name|key
operator|=
operator|(
name|key
operator|+
operator|(
name|key
operator|<<
literal|3
operator|)
operator|)
operator|+
operator|(
name|key
operator|<<
literal|8
operator|)
expr_stmt|;
comment|// key * 265
name|key
operator|=
name|key
operator|^
operator|(
name|key
operator|>>>
literal|14
operator|)
expr_stmt|;
name|key
operator|=
operator|(
name|key
operator|+
operator|(
name|key
operator|<<
literal|2
operator|)
operator|)
operator|+
operator|(
name|key
operator|<<
literal|4
operator|)
expr_stmt|;
comment|// key * 21
name|key
operator|=
name|key
operator|^
operator|(
name|key
operator|>>>
literal|28
operator|)
expr_stmt|;
name|key
operator|=
name|key
operator|+
operator|(
name|key
operator|<<
literal|31
operator|)
expr_stmt|;
name|longHashCode
operator|^=
name|key
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|longHashCode
return|;
block|}
specifier|private
specifier|static
specifier|final
name|int
name|ZERO_NEW_FASTER_HASH_CODE
init|=
name|doCalculateNewFasterHashCode
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/**    * Hash code based on (new) decimal representation.    *    * Faster than fastHashCode().    *    * Used by map join and other Hive internal purposes where performance is important.    *    * IMPORTANT: See comments for fastHashCode(), too.    */
specifier|public
specifier|static
name|int
name|fastNewFasterHashCode
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|)
block|{
if|if
condition|(
name|fastSignum
operator|==
literal|0
condition|)
block|{
return|return
name|ZERO_NEW_FASTER_HASH_CODE
return|;
block|}
name|int
name|hashCode
init|=
name|doCalculateNewFasterHashCode
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|)
decl_stmt|;
return|return
name|hashCode
return|;
block|}
comment|/**    * This is the original hash code as returned by OldHiveDecimal.    *    * We need this when the OldHiveDecimal hash code has been exposed and and written or affected    * how data is written.    *    * This method supports compatibility.    *    * Examples: bucketing and the Hive hash() function.    *    * NOTE: It is necessary to create a BigDecimal object and use its hash code, so this method is    *       slow.    * @return    */
specifier|public
specifier|static
name|int
name|fastHashCode
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|)
block|{
comment|// OldHiveDecimal returns the hash code of its internal BigDecimal.  Our TestHiveDecimal
comment|// verifies the OldHiveDecimal.bigDecimalValue() matches (new) HiveDecimal.bigDecimalValue().
name|BigDecimal
name|bigDecimal
init|=
name|fastBigDecimalValue
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|)
decl_stmt|;
return|return
name|bigDecimal
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|//************************************************************************************************
comment|// Decimal Math.
specifier|public
specifier|static
name|boolean
name|fastScaleByPowerOfTen
parameter_list|(
name|FastHiveDecimal
name|fastDec
parameter_list|,
name|int
name|power
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
return|return
name|fastScaleByPowerOfTen
argument_list|(
name|fastDec
operator|.
name|fastSignum
argument_list|,
name|fastDec
operator|.
name|fast0
argument_list|,
name|fastDec
operator|.
name|fast1
argument_list|,
name|fastDec
operator|.
name|fast2
argument_list|,
name|fastDec
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastDec
operator|.
name|fastScale
argument_list|,
name|power
argument_list|,
name|fastResult
argument_list|)
return|;
block|}
comment|// NOTE: power can be positive or negative.
comment|// NOTE: e.g. power = 2 is effectively multiply by 10^2
comment|// NOTE:      and power = -3 is multiply by 10^-3
specifier|public
specifier|static
name|boolean
name|fastScaleByPowerOfTen
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|power
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
if|if
condition|(
name|fastSignum
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|power
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSet
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|)
expr_stmt|;
comment|/*       if (!fastResult.fastIsValid()) {         fastResult.fastRaiseInvalidException();       }       */
return|return
literal|true
return|;
block|}
specifier|final
name|int
name|absPower
init|=
name|Math
operator|.
name|abs
argument_list|(
name|power
argument_list|)
decl_stmt|;
if|if
condition|(
name|power
operator|>
literal|0
condition|)
block|{
name|int
name|integerRoom
decl_stmt|;
name|int
name|fractionalRoom
decl_stmt|;
if|if
condition|(
name|fastIntegerDigitCount
operator|>
literal|0
condition|)
block|{
comment|// Is there integer room above?
name|integerRoom
operator|=
name|HiveDecimal
operator|.
name|MAX_PRECISION
operator|-
name|fastIntegerDigitCount
expr_stmt|;
if|if
condition|(
name|integerRoom
operator|<
name|power
condition|)
block|{
return|return
literal|false
return|;
block|}
name|fastResult
operator|.
name|fastSignum
operator|=
name|fastSignum
expr_stmt|;
if|if
condition|(
name|fastScale
operator|<=
name|power
condition|)
block|{
comment|// All fractional digits become integer digits.
specifier|final
name|int
name|scaleUp
init|=
name|power
operator|-
name|fastScale
decl_stmt|;
if|if
condition|(
name|scaleUp
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fastScaleUp
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scaleUp
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|fastResult
operator|.
name|fast0
operator|=
name|fast0
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|fast1
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|fast2
expr_stmt|;
block|}
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|fastIntegerDigitCount
operator|+
name|fastScale
operator|+
name|scaleUp
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// Only a scale adjustment is needed.
name|fastResult
operator|.
name|fastSet
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
operator|+
name|power
argument_list|,
name|fastScale
operator|-
name|power
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// How much can the fraction be moved up?
specifier|final
name|int
name|rawPrecision
init|=
name|fastRawPrecision
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|)
decl_stmt|;
specifier|final
name|int
name|zeroesBelowDot
init|=
name|fastScale
operator|-
name|rawPrecision
decl_stmt|;
comment|// Our limit is max precision integer digits + "leading" zeros below the dot.
comment|// E.g. 0.00021 has 3 zeroes below the dot.
comment|//
if|if
condition|(
name|power
operator|>
name|HiveDecimal
operator|.
name|MAX_PRECISION
operator|+
name|zeroesBelowDot
condition|)
block|{
comment|// Fractional part powered up too high.
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|newIntegerDigitCount
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|power
operator|-
name|zeroesBelowDot
argument_list|)
decl_stmt|;
if|if
condition|(
name|newIntegerDigitCount
operator|>
name|rawPrecision
condition|)
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
name|fastSignum
expr_stmt|;
specifier|final
name|int
name|scaleUp
init|=
name|newIntegerDigitCount
operator|-
name|rawPrecision
decl_stmt|;
if|if
condition|(
operator|!
name|fastScaleUp
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scaleUp
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected"
argument_list|)
throw|;
block|}
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|newIntegerDigitCount
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|int
name|newScale
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|fastScale
operator|-
name|power
argument_list|)
decl_stmt|;
name|fastResult
operator|.
name|fastSet
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|newIntegerDigitCount
argument_list|,
name|newScale
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|fastScale
operator|+
name|absPower
operator|<=
name|HiveDecimal
operator|.
name|MAX_SCALE
condition|)
block|{
comment|// Negative power with range -- adjust the scale.
specifier|final
name|int
name|newScale
init|=
name|fastScale
operator|+
name|absPower
decl_stmt|;
specifier|final
name|int
name|newIntegerDigitCount
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|fastIntegerDigitCount
operator|-
name|absPower
argument_list|)
decl_stmt|;
specifier|final
name|int
name|trailingZeroCount
init|=
name|fastTrailingDecimalZeroCount
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|newIntegerDigitCount
argument_list|,
name|newScale
argument_list|)
decl_stmt|;
if|if
condition|(
name|trailingZeroCount
operator|>
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
name|fastSignum
expr_stmt|;
name|doFastScaleDown
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|trailingZeroCount
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
name|newScale
operator|-
name|trailingZeroCount
expr_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|newIntegerDigitCount
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastSet
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|newIntegerDigitCount
argument_list|,
name|newScale
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// fastScale + absPower> HiveDecimal.MAX_SCALE
comment|// Look at getting rid of fractional digits that will now be below HiveDecimal.MAX_SCALE.
specifier|final
name|int
name|scaleDown
init|=
name|fastScale
operator|+
name|absPower
operator|-
name|HiveDecimal
operator|.
name|MAX_SCALE
decl_stmt|;
if|if
condition|(
name|scaleDown
operator|<
name|HiveDecimal
operator|.
name|MAX_SCALE
condition|)
block|{
if|if
condition|(
operator|!
name|fastRoundFractionalHalfUp
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scaleDown
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
comment|// Overflow.
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fastResult
operator|.
name|fastSignum
operator|!=
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastScale
operator|=
name|HiveDecimal
operator|.
name|MAX_SCALE
expr_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|fastRawPrecision
argument_list|(
name|fastResult
argument_list|)
operator|-
name|fastResult
operator|.
name|fastScale
argument_list|)
expr_stmt|;
specifier|final
name|int
name|trailingZeroCount
init|=
name|fastTrailingDecimalZeroCount
argument_list|(
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
name|fastResult
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastResult
operator|.
name|fastScale
argument_list|)
decl_stmt|;
if|if
condition|(
name|trailingZeroCount
operator|>
literal|0
condition|)
block|{
name|doFastScaleDown
argument_list|(
name|fastResult
argument_list|,
name|trailingZeroCount
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|-=
name|trailingZeroCount
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// All precision has been lost -- result is 0.
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*     if (!fastResult.fastIsValid()) {       fastResult.fastRaiseInvalidException();     }     */
return|return
literal|true
return|;
block|}
comment|//************************************************************************************************
comment|// Decimal Rounding.
specifier|public
specifier|static
name|boolean
name|doFastRound
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|roundPower
parameter_list|,
name|int
name|roundingMode
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
if|if
condition|(
name|fastSignum
operator|==
literal|0
condition|)
block|{
comment|// Zero result.
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|fastScale
operator|==
name|roundPower
condition|)
block|{
comment|// The roundPower same as scale means all zeroes below round point.
name|fastResult
operator|.
name|fastSet
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|)
expr_stmt|;
comment|/*       if (!fastResult.fastIsValid()) {         fastResult.fastRaiseInvalidException();       }       */
return|return
literal|true
return|;
block|}
if|if
condition|(
name|roundPower
operator|>
name|fastScale
condition|)
block|{
comment|// We pretend to add trailing zeroes, EVEN WHEN it would exceed the HiveDecimal.MAX_PRECISION.
comment|// Copy current value; do not change current scale.
name|fastResult
operator|.
name|fastSet
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|)
expr_stmt|;
comment|/*       if (!fastResult.fastIsValid()) {         fastResult.fastRaiseInvalidException();       }       */
block|}
elseif|else
if|if
condition|(
name|roundPower
operator|<
literal|0
condition|)
block|{
comment|// roundPower< 0
comment|//
comment|// Negative scale means we start rounding integer digits.
comment|//
comment|// The result will integer result will have at least abs(roundPower) trailing digits.
comment|//
comment|// Examples where the 'r's show the rounding digits:
comment|//
comment|//      round(12500, -3) = 13000           // BigDecimal.ROUND_HALF_UP
comment|//              rrr
comment|//
comment|// Or,  ceiling(12400.8302, -2) = 12500     // BigDecimal.ROUND_CEILING
comment|//                 rr rrrr
comment|//
comment|// Notice that any fractional digits will be gone in the result.
comment|//
switch|switch
condition|(
name|roundingMode
condition|)
block|{
case|case
name|BigDecimal
operator|.
name|ROUND_DOWN
case|:
if|if
condition|(
operator|!
name|fastRoundIntegerDown
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|,
name|roundPower
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
break|break;
case|case
name|BigDecimal
operator|.
name|ROUND_UP
case|:
if|if
condition|(
operator|!
name|fastRoundIntegerUp
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|,
name|roundPower
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
break|break;
case|case
name|BigDecimal
operator|.
name|ROUND_FLOOR
case|:
comment|// Round towards negative infinity.
if|if
condition|(
name|fastSignum
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|fastRoundIntegerDown
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|,
name|roundPower
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|fastRoundIntegerUp
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|,
name|roundPower
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fastResult
operator|.
name|fast2
operator|>
name|MAX_HIGHWORD_DECIMAL
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
break|break;
case|case
name|BigDecimal
operator|.
name|ROUND_CEILING
case|:
comment|// Round towards positive infinity.
if|if
condition|(
name|fastSignum
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|fastRoundIntegerUp
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|,
name|roundPower
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fastResult
operator|.
name|fast2
operator|>
name|MAX_HIGHWORD_DECIMAL
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|fastRoundIntegerDown
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|,
name|roundPower
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
break|break;
case|case
name|BigDecimal
operator|.
name|ROUND_HALF_UP
case|:
if|if
condition|(
operator|!
name|fastRoundIntegerHalfUp
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|,
name|roundPower
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fastResult
operator|.
name|fast2
operator|>
name|MAX_HIGHWORD_DECIMAL
condition|)
block|{
return|return
literal|false
return|;
block|}
break|break;
case|case
name|BigDecimal
operator|.
name|ROUND_HALF_EVEN
case|:
if|if
condition|(
operator|!
name|fastRoundIntegerHalfEven
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|,
name|roundPower
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fastResult
operator|.
name|fast2
operator|>
name|MAX_HIGHWORD_DECIMAL
condition|)
block|{
return|return
literal|false
return|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unsupported rounding mode "
operator|+
name|roundingMode
argument_list|)
throw|;
block|}
comment|// The fastRoundInteger* methods remove all fractional digits, set fastIntegerDigitCount, and
comment|// set fastScale to 0.
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// roundPower< fastScale
comment|// Do rounding of fractional digits.
specifier|final
name|int
name|scaleDown
init|=
name|fastScale
operator|-
name|roundPower
decl_stmt|;
switch|switch
condition|(
name|roundingMode
condition|)
block|{
case|case
name|BigDecimal
operator|.
name|ROUND_DOWN
case|:
name|fastRoundFractionalDown
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scaleDown
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
break|break;
case|case
name|BigDecimal
operator|.
name|ROUND_UP
case|:
if|if
condition|(
operator|!
name|fastRoundFractionalUp
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scaleDown
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
break|break;
case|case
name|BigDecimal
operator|.
name|ROUND_FLOOR
case|:
comment|// Round towards negative infinity.
if|if
condition|(
name|fastSignum
operator|==
literal|1
condition|)
block|{
name|fastRoundFractionalDown
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scaleDown
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|fastRoundFractionalUp
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scaleDown
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
break|break;
case|case
name|BigDecimal
operator|.
name|ROUND_CEILING
case|:
comment|// Round towards positive infinity.
if|if
condition|(
name|fastSignum
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|fastRoundFractionalUp
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scaleDown
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
name|fastRoundFractionalDown
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scaleDown
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BigDecimal
operator|.
name|ROUND_HALF_UP
case|:
if|if
condition|(
operator|!
name|fastRoundFractionalHalfUp
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scaleDown
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
break|break;
case|case
name|BigDecimal
operator|.
name|ROUND_HALF_EVEN
case|:
if|if
condition|(
operator|!
name|fastRoundFractionalHalfEven
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scaleDown
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unsupported rounding mode "
operator|+
name|roundingMode
argument_list|)
throw|;
block|}
if|if
condition|(
name|fastResult
operator|.
name|fastSignum
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastScale
operator|=
literal|0
expr_stmt|;
comment|/*         if (!fastResult.fastIsValid()) {           fastResult.fastRaiseInvalidException();         }         */
block|}
else|else
block|{
specifier|final
name|int
name|rawPrecision
init|=
name|fastRawPrecision
argument_list|(
name|fastResult
argument_list|)
decl_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|rawPrecision
operator|-
name|roundPower
argument_list|)
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
name|roundPower
expr_stmt|;
comment|// Trim trailing zeroes and re-adjust scale.
specifier|final
name|int
name|trailingZeroCount
init|=
name|fastTrailingDecimalZeroCount
argument_list|(
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
name|fastResult
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastResult
operator|.
name|fastScale
argument_list|)
decl_stmt|;
if|if
condition|(
name|trailingZeroCount
operator|>
literal|0
condition|)
block|{
name|doFastScaleDown
argument_list|(
name|fastResult
argument_list|,
name|trailingZeroCount
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|-=
name|trailingZeroCount
expr_stmt|;
comment|/*           if (!fastResult.fastIsValid()) {             fastResult.fastRaiseInvalidException();           }           */
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|public
specifier|static
name|boolean
name|fastRound
parameter_list|(
name|FastHiveDecimal
name|fastDec
parameter_list|,
name|int
name|newScale
parameter_list|,
name|int
name|roundingMode
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
return|return
name|fastRound
argument_list|(
name|fastDec
operator|.
name|fastSignum
argument_list|,
name|fastDec
operator|.
name|fast0
argument_list|,
name|fastDec
operator|.
name|fast1
argument_list|,
name|fastDec
operator|.
name|fast2
argument_list|,
name|fastDec
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastDec
operator|.
name|fastScale
argument_list|,
name|newScale
argument_list|,
name|roundingMode
argument_list|,
name|fastResult
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|fastRound
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|newScale
parameter_list|,
name|int
name|roundingMode
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
return|return
name|doFastRound
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|,
name|newScale
argument_list|,
name|roundingMode
argument_list|,
name|fastResult
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isRoundPortionAllZeroes
parameter_list|(
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|roundingPoint
parameter_list|)
block|{
name|boolean
name|isRoundPortionAllZeroes
decl_stmt|;
if|if
condition|(
name|roundingPoint
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Lowest word gets integer rounding.
comment|// Factor includes scale.
specifier|final
name|long
name|roundPointFactor
init|=
name|powerOfTenTable
index|[
name|roundingPoint
index|]
decl_stmt|;
name|isRoundPortionAllZeroes
operator|=
operator|(
name|fast0
operator|%
name|roundPointFactor
operator|==
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|roundingPoint
operator|<
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Middle word gets integer rounding.
specifier|final
name|int
name|adjustedRoundingPoint
init|=
name|roundingPoint
operator|-
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
if|if
condition|(
name|adjustedRoundingPoint
operator|==
literal|0
condition|)
block|{
name|isRoundPortionAllZeroes
operator|=
operator|(
name|fast0
operator|==
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// Factor includes scale.
specifier|final
name|long
name|roundPointFactor
init|=
name|powerOfTenTable
index|[
name|adjustedRoundingPoint
index|]
decl_stmt|;
specifier|final
name|long
name|roundPortion
init|=
name|fast1
operator|%
name|roundPointFactor
decl_stmt|;
name|isRoundPortionAllZeroes
operator|=
operator|(
name|fast0
operator|==
literal|0
operator|&&
name|roundPortion
operator|==
literal|0
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// High word gets integer rounding.
specifier|final
name|int
name|adjustedRoundingPoint
init|=
name|roundingPoint
operator|-
name|TWO_X_LONGWORD_DECIMAL_DIGITS
decl_stmt|;
if|if
condition|(
name|adjustedRoundingPoint
operator|==
literal|0
condition|)
block|{
name|isRoundPortionAllZeroes
operator|=
operator|(
name|fast0
operator|==
literal|0
operator|&&
name|fast1
operator|==
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// Factor includes scale.
specifier|final
name|long
name|roundPointFactor
init|=
name|powerOfTenTable
index|[
name|adjustedRoundingPoint
index|]
decl_stmt|;
specifier|final
name|long
name|roundPortion
init|=
name|fast2
operator|%
name|roundPointFactor
decl_stmt|;
name|isRoundPortionAllZeroes
operator|=
operator|(
name|fast0
operator|==
literal|0
operator|&&
name|fast1
operator|==
literal|0
operator|&&
name|roundPortion
operator|==
literal|0
operator|)
expr_stmt|;
block|}
block|}
return|return
name|isRoundPortionAllZeroes
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isRoundPortionHalfUp
parameter_list|(
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|roundingPoint
parameter_list|)
block|{
name|boolean
name|isRoundPortionHalfUp
decl_stmt|;
if|if
condition|(
name|roundingPoint
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Lowest word gets integer rounding.
comment|// Divide down just before round point to get round digit.
specifier|final
name|long
name|withRoundDigit
init|=
name|fast0
operator|/
name|powerOfTenTable
index|[
name|roundingPoint
operator|-
literal|1
index|]
decl_stmt|;
specifier|final
name|long
name|roundDigit
init|=
name|withRoundDigit
operator|%
literal|10
decl_stmt|;
name|isRoundPortionHalfUp
operator|=
operator|(
name|roundDigit
operator|>=
literal|5
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|roundingPoint
operator|<
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Middle word gets integer rounding.
specifier|final
name|int
name|adjustedRoundingPoint
init|=
name|roundingPoint
operator|-
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
name|long
name|roundDigit
decl_stmt|;
if|if
condition|(
name|adjustedRoundingPoint
operator|==
literal|0
condition|)
block|{
comment|// Grab round digit from lowest word.
name|roundDigit
operator|=
name|fast0
operator|/
operator|(
name|MULTIPLER_LONGWORD_DECIMAL
operator|/
literal|10
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// Divide down just before scaleDown to get round digit.
specifier|final
name|long
name|withRoundDigit
init|=
name|fast1
operator|/
name|powerOfTenTable
index|[
name|adjustedRoundingPoint
operator|-
literal|1
index|]
decl_stmt|;
name|roundDigit
operator|=
name|withRoundDigit
operator|%
literal|10
expr_stmt|;
block|}
name|isRoundPortionHalfUp
operator|=
operator|(
name|roundDigit
operator|>=
literal|5
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// High word gets integer rounding.
specifier|final
name|int
name|adjustedRoundingPoint
init|=
name|roundingPoint
operator|-
name|TWO_X_LONGWORD_DECIMAL_DIGITS
decl_stmt|;
name|long
name|roundDigit
decl_stmt|;
if|if
condition|(
name|adjustedRoundingPoint
operator|==
literal|0
condition|)
block|{
comment|// Grab round digit from middle word.
name|roundDigit
operator|=
name|fast1
operator|/
operator|(
name|MULTIPLER_LONGWORD_DECIMAL
operator|/
literal|10
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// Divide down just before scaleDown to get round digit.
specifier|final
name|long
name|withRoundDigit
init|=
name|fast2
operator|/
name|powerOfTenTable
index|[
name|adjustedRoundingPoint
operator|-
literal|1
index|]
decl_stmt|;
name|roundDigit
operator|=
name|withRoundDigit
operator|%
literal|10
expr_stmt|;
block|}
name|isRoundPortionHalfUp
operator|=
operator|(
name|roundDigit
operator|>=
literal|5
operator|)
expr_stmt|;
block|}
return|return
name|isRoundPortionHalfUp
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isRoundPortionHalfEven
parameter_list|(
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|roundingPoint
parameter_list|)
block|{
name|boolean
name|isRoundPortionHalfEven
decl_stmt|;
if|if
condition|(
name|roundingPoint
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Lowest word gets integer rounding.
comment|// Divide down just before scaleDown to get round digit.
specifier|final
name|long
name|roundDivisor
init|=
name|powerOfTenTable
index|[
name|roundingPoint
operator|-
literal|1
index|]
decl_stmt|;
specifier|final
name|long
name|withRoundDigit
init|=
name|fast0
operator|/
name|roundDivisor
decl_stmt|;
specifier|final
name|long
name|roundDigit
init|=
name|withRoundDigit
operator|%
literal|10
decl_stmt|;
specifier|final
name|long
name|fast0Scaled
init|=
name|withRoundDigit
operator|/
literal|10
decl_stmt|;
if|if
condition|(
name|roundDigit
operator|>
literal|5
condition|)
block|{
name|isRoundPortionHalfEven
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|roundDigit
operator|==
literal|5
condition|)
block|{
name|boolean
name|exactlyOneHalf
decl_stmt|;
if|if
condition|(
name|roundingPoint
operator|-
literal|1
operator|==
literal|0
condition|)
block|{
comment|// Fraction below 0.5 is implicitly 0.
name|exactlyOneHalf
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|exactlyOneHalf
operator|=
operator|(
name|fast0
operator|%
name|roundDivisor
operator|==
literal|0
operator|)
expr_stmt|;
block|}
comment|// When fraction is exactly 0.5 and lowest new digit is odd, go towards even.
if|if
condition|(
name|exactlyOneHalf
condition|)
block|{
name|isRoundPortionHalfEven
operator|=
operator|(
name|fast0Scaled
operator|%
literal|2
operator|==
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|isRoundPortionHalfEven
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|isRoundPortionHalfEven
operator|=
literal|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|roundingPoint
operator|<
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Middle word gets integer rounding.
specifier|final
name|int
name|adjustedRoundingPoint
init|=
name|roundingPoint
operator|-
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
name|long
name|roundDigit
decl_stmt|;
name|long
name|fast1Scaled
decl_stmt|;
if|if
condition|(
name|adjustedRoundingPoint
operator|==
literal|0
condition|)
block|{
comment|// Grab round digit from lowest word.
specifier|final
name|long
name|roundDivisor
init|=
name|MULTIPLER_LONGWORD_DECIMAL
operator|/
literal|10
decl_stmt|;
name|roundDigit
operator|=
name|fast0
operator|/
name|roundDivisor
expr_stmt|;
name|fast1Scaled
operator|=
name|fast1
expr_stmt|;
if|if
condition|(
name|roundDigit
operator|>
literal|5
condition|)
block|{
name|isRoundPortionHalfEven
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|roundDigit
operator|==
literal|5
condition|)
block|{
name|boolean
name|exactlyOneHalf
init|=
operator|(
name|fast0
operator|%
name|roundDivisor
operator|==
literal|0
operator|)
decl_stmt|;
comment|// When fraction is exactly 0.5 and lowest new digit is odd, go towards even.
if|if
condition|(
name|exactlyOneHalf
condition|)
block|{
name|isRoundPortionHalfEven
operator|=
operator|(
name|fast1Scaled
operator|%
literal|2
operator|==
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|isRoundPortionHalfEven
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|isRoundPortionHalfEven
operator|=
literal|false
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Divide down just before scaleDown to get round digit.
specifier|final
name|long
name|roundDivisor
init|=
name|powerOfTenTable
index|[
name|adjustedRoundingPoint
operator|-
literal|1
index|]
decl_stmt|;
specifier|final
name|long
name|withRoundDigit
init|=
name|fast1
operator|/
name|roundDivisor
decl_stmt|;
name|roundDigit
operator|=
name|withRoundDigit
operator|%
literal|10
expr_stmt|;
name|fast1Scaled
operator|=
name|withRoundDigit
operator|/
literal|10
expr_stmt|;
if|if
condition|(
name|roundDigit
operator|>
literal|5
condition|)
block|{
name|isRoundPortionHalfEven
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|roundDigit
operator|==
literal|5
condition|)
block|{
name|boolean
name|exactlyOneHalf
decl_stmt|;
if|if
condition|(
name|adjustedRoundingPoint
operator|-
literal|1
operator|==
literal|0
condition|)
block|{
comment|// Just examine the lower word.
name|exactlyOneHalf
operator|=
operator|(
name|fast0
operator|==
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|exactlyOneHalf
operator|=
operator|(
name|fast0
operator|==
literal|0
operator|&&
name|fast1
operator|%
name|roundDivisor
operator|==
literal|0
operator|)
expr_stmt|;
block|}
comment|// When fraction is exactly 0.5 and lowest new digit is odd, go towards even.
if|if
condition|(
name|exactlyOneHalf
condition|)
block|{
name|isRoundPortionHalfEven
operator|=
operator|(
name|fast1Scaled
operator|%
literal|2
operator|==
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|isRoundPortionHalfEven
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|isRoundPortionHalfEven
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// High word gets integer rounding.
specifier|final
name|int
name|adjustedRoundingPoint
init|=
name|roundingPoint
operator|-
name|TWO_X_LONGWORD_DECIMAL_DIGITS
decl_stmt|;
name|long
name|roundDigit
decl_stmt|;
name|long
name|fast2Scaled
decl_stmt|;
if|if
condition|(
name|adjustedRoundingPoint
operator|==
literal|0
condition|)
block|{
comment|// Grab round digit from middle word.
specifier|final
name|long
name|roundDivisor
init|=
name|MULTIPLER_LONGWORD_DECIMAL
operator|/
literal|10
decl_stmt|;
name|roundDigit
operator|=
name|fast1
operator|/
name|roundDivisor
expr_stmt|;
name|fast2Scaled
operator|=
name|fast2
expr_stmt|;
if|if
condition|(
name|roundDigit
operator|>
literal|5
condition|)
block|{
name|isRoundPortionHalfEven
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|roundDigit
operator|==
literal|5
condition|)
block|{
name|boolean
name|exactlyOneHalf
init|=
operator|(
name|fast1
operator|%
name|roundDivisor
operator|==
literal|0
operator|&&
name|fast0
operator|==
literal|0
operator|)
decl_stmt|;
comment|// When fraction is exactly 0.5 and lowest new digit is odd, go towards even.
if|if
condition|(
name|exactlyOneHalf
condition|)
block|{
name|isRoundPortionHalfEven
operator|=
operator|(
name|fast2Scaled
operator|%
literal|2
operator|==
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|isRoundPortionHalfEven
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|isRoundPortionHalfEven
operator|=
literal|false
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Divide down just before scaleDown to get round digit.
specifier|final
name|long
name|roundDivisor
init|=
name|powerOfTenTable
index|[
name|adjustedRoundingPoint
operator|-
literal|1
index|]
decl_stmt|;
specifier|final
name|long
name|withRoundDigit
init|=
name|fast2
operator|/
name|roundDivisor
decl_stmt|;
name|roundDigit
operator|=
name|withRoundDigit
operator|%
literal|10
expr_stmt|;
name|fast2Scaled
operator|=
name|withRoundDigit
operator|/
literal|10
expr_stmt|;
if|if
condition|(
name|roundDigit
operator|>
literal|5
condition|)
block|{
name|isRoundPortionHalfEven
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|roundDigit
operator|==
literal|5
condition|)
block|{
name|boolean
name|exactlyOneHalf
decl_stmt|;
if|if
condition|(
name|adjustedRoundingPoint
operator|-
literal|1
operator|==
literal|0
condition|)
block|{
comment|// Just examine the middle and lower words.
name|exactlyOneHalf
operator|=
operator|(
name|fast1
operator|==
literal|0
operator|&&
name|fast0
operator|==
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|exactlyOneHalf
operator|=
operator|(
name|fast2
operator|%
name|roundDivisor
operator|==
literal|0
operator|&&
name|fast1
operator|==
literal|0
operator|&&
name|fast0
operator|==
literal|0
operator|)
expr_stmt|;
block|}
comment|// When fraction is exactly 0.5 and lowest new digit is odd, go towards even.
if|if
condition|(
name|exactlyOneHalf
condition|)
block|{
name|isRoundPortionHalfEven
operator|=
operator|(
name|fast2Scaled
operator|%
literal|2
operator|==
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|isRoundPortionHalfEven
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|isRoundPortionHalfEven
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
return|return
name|isRoundPortionHalfEven
return|;
block|}
specifier|private
specifier|static
name|void
name|doClearRoundIntegerPortionAndAddOne
parameter_list|(
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|absRoundPower
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
name|long
name|result0
decl_stmt|;
name|long
name|result1
decl_stmt|;
name|long
name|result2
decl_stmt|;
if|if
condition|(
name|absRoundPower
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Lowest word gets integer rounding.
comment|// Clear rounding portion in lower longword and add 1 at right scale (roundMultiplyFactor).
specifier|final
name|long
name|roundFactor
init|=
name|powerOfTenTable
index|[
name|absRoundPower
index|]
decl_stmt|;
specifier|final
name|long
name|r0
init|=
operator|(
operator|(
name|fast0
operator|/
name|roundFactor
operator|)
operator|*
name|roundFactor
operator|)
operator|+
name|roundFactor
decl_stmt|;
name|result0
operator|=
name|r0
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r1
init|=
name|fast1
operator|+
name|r0
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|result1
operator|=
name|r1
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|result2
operator|=
name|fast2
operator|+
name|r1
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|absRoundPower
operator|<
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Middle word gets integer rounding; lower longword is cleared.
specifier|final
name|int
name|adjustedAbsPower
init|=
name|absRoundPower
operator|-
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
comment|// Clear rounding portion in middle longword and add 1 at right scale (roundMultiplyFactor);
comment|// lower longword result is 0;
specifier|final
name|long
name|roundFactor
init|=
name|powerOfTenTable
index|[
name|adjustedAbsPower
index|]
decl_stmt|;
name|result0
operator|=
literal|0
expr_stmt|;
specifier|final
name|long
name|r1
init|=
operator|(
operator|(
name|fast1
operator|/
name|roundFactor
operator|)
operator|*
name|roundFactor
operator|)
operator|+
name|roundFactor
decl_stmt|;
name|result1
operator|=
name|r1
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|result2
operator|=
name|fast2
operator|+
name|r1
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
block|}
else|else
block|{
comment|// High word gets integer rounding; middle and lower longwords are cleared.
specifier|final
name|int
name|adjustedAbsPower
init|=
name|absRoundPower
operator|-
name|TWO_X_LONGWORD_DECIMAL_DIGITS
decl_stmt|;
comment|// Clear rounding portion in high longword and add 1 at right scale (roundMultiplyFactor);
comment|// middle and lower longwords result is 0;
specifier|final
name|long
name|roundFactor
init|=
name|powerOfTenTable
index|[
name|adjustedAbsPower
index|]
decl_stmt|;
name|result0
operator|=
literal|0
expr_stmt|;
name|result1
operator|=
literal|0
expr_stmt|;
name|result2
operator|=
operator|(
operator|(
name|fast2
operator|/
name|roundFactor
operator|)
operator|*
name|roundFactor
operator|)
operator|+
name|roundFactor
expr_stmt|;
block|}
name|fastResult
operator|.
name|fast0
operator|=
name|result0
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|result1
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|result2
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|doClearRoundIntegerPortion
parameter_list|(
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|absRoundPower
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
name|long
name|result0
decl_stmt|;
name|long
name|result1
decl_stmt|;
name|long
name|result2
decl_stmt|;
if|if
condition|(
name|absRoundPower
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Lowest word gets integer rounding.
comment|// Clear rounding portion in lower longword and add 1 at right scale (roundMultiplyFactor).
specifier|final
name|long
name|roundFactor
init|=
name|powerOfTenTable
index|[
name|absRoundPower
index|]
decl_stmt|;
comment|// final long roundMultiplyFactor = powerOfTenTable[LONGWORD_DECIMAL_DIGITS - absRoundPower];
name|result0
operator|=
operator|(
operator|(
name|fast0
operator|/
name|roundFactor
operator|)
operator|*
name|roundFactor
operator|)
expr_stmt|;
name|result1
operator|=
name|fast1
expr_stmt|;
name|result2
operator|=
name|fast2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|absRoundPower
operator|<
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Middle word gets integer rounding; lower longword is cleared.
specifier|final
name|int
name|adjustedAbsPower
init|=
name|absRoundPower
operator|-
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
comment|// Clear rounding portion in middle longword and add 1 at right scale (roundMultiplyFactor);
comment|// lower longword result is 0;
specifier|final
name|long
name|roundFactor
init|=
name|powerOfTenTable
index|[
name|adjustedAbsPower
index|]
decl_stmt|;
name|result0
operator|=
literal|0
expr_stmt|;
name|result1
operator|=
operator|(
operator|(
name|fast1
operator|/
name|roundFactor
operator|)
operator|*
name|roundFactor
operator|)
expr_stmt|;
name|result2
operator|=
name|fast2
expr_stmt|;
block|}
else|else
block|{
comment|// High word gets integer rounding; middle and lower longwords are cleared.
specifier|final
name|int
name|adjustedAbsPower
init|=
name|absRoundPower
operator|-
name|TWO_X_LONGWORD_DECIMAL_DIGITS
decl_stmt|;
comment|// Clear rounding portion in high longword and add 1 at right scale (roundMultiplyFactor);
comment|// middle and lower longwords result is 0;
specifier|final
name|long
name|roundFactor
init|=
name|powerOfTenTable
index|[
name|adjustedAbsPower
index|]
decl_stmt|;
name|result0
operator|=
literal|0
expr_stmt|;
name|result1
operator|=
literal|0
expr_stmt|;
name|result2
operator|=
operator|(
operator|(
name|fast2
operator|/
name|roundFactor
operator|)
operator|*
name|roundFactor
operator|)
expr_stmt|;
block|}
name|fastResult
operator|.
name|fast0
operator|=
name|result0
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|result1
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|result2
expr_stmt|;
block|}
comment|/**    * Fast decimal integer part rounding ROUND_UP.    *    * ceiling(12400.8302, -2) = 12500     // E.g. Positive case FAST_ROUND_CEILING    *            rr rrrr    *    */
specifier|public
specifier|static
name|boolean
name|fastRoundIntegerUp
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|roundPower
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
comment|/*      * Basic algorithm:      *      * 1. Determine if rounding part is non-zero for rounding.      * 2. Scale away fractional digits if present.      * 3. If rounding, clear integer rounding portion and add 1.      *      */
if|if
condition|(
name|roundPower
operator|>=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Expecting roundPower< 0 (roundPower "
operator|+
name|roundPower
operator|+
literal|")"
argument_list|)
throw|;
block|}
specifier|final
name|int
name|absRoundPower
init|=
operator|-
name|roundPower
decl_stmt|;
if|if
condition|(
name|fastIntegerDigitCount
operator|<
name|absRoundPower
condition|)
block|{
comment|// Above decimal.
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|roundingPoint
init|=
name|absRoundPower
operator|+
name|fastScale
decl_stmt|;
if|if
condition|(
name|roundingPoint
operator|>
name|HiveDecimal
operator|.
name|MAX_PRECISION
condition|)
block|{
comment|// Value becomes null for rounding beyond.
return|return
literal|false
return|;
block|}
comment|// First, determine whether rounding is necessary based on rounding point, which is inside
comment|// integer part.  And, get rid of any fractional digits.  The result scale will be 0.
comment|//
name|boolean
name|isRoundPortionAllZeroes
init|=
name|isRoundPortionAllZeroes
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|roundingPoint
argument_list|)
decl_stmt|;
comment|// If necessary, divide and multiply to get rid of fractional digits.
if|if
condition|(
name|fastScale
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fast0
operator|=
name|fast0
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|fast1
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|fast2
expr_stmt|;
block|}
else|else
block|{
name|doFastScaleDown
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
comment|/* scaleDown */
name|fastScale
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
block|}
comment|// The fractional digits are gone; when rounding, clear remaining round digits and add 1.
if|if
condition|(
operator|!
name|isRoundPortionAllZeroes
condition|)
block|{
name|doClearRoundIntegerPortionAndAddOne
argument_list|(
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
name|absRoundPower
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fastResult
operator|.
name|fast0
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast1
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast2
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
literal|0
expr_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
literal|0
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
name|fastSignum
expr_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|fastRawPrecision
argument_list|(
name|fastResult
argument_list|)
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Fast decimal scale down by factor of 10 with rounding ROUND_DOWN.    *    * The fraction being scaled away is thrown away.    *    * The signum will be updated if the result is 0, otherwise the original sign is unchanged.    */
specifier|public
specifier|static
name|boolean
name|fastRoundIntegerDown
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|roundPower
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
comment|/*      * Basic algorithm:      *      * 1. Scale away fractional digits if present.      * 2. Clear integer rounding portion.      *      */
if|if
condition|(
name|roundPower
operator|>=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Expecting roundPower< 0 (roundPower "
operator|+
name|roundPower
operator|+
literal|")"
argument_list|)
throw|;
block|}
specifier|final
name|int
name|absRoundPower
init|=
operator|-
name|roundPower
decl_stmt|;
if|if
condition|(
name|fastIntegerDigitCount
operator|<
name|absRoundPower
condition|)
block|{
comment|// Zero result.
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|final
name|int
name|roundingPoint
init|=
name|absRoundPower
operator|+
name|fastScale
decl_stmt|;
if|if
condition|(
name|roundingPoint
operator|>
name|HiveDecimal
operator|.
name|MAX_PRECISION
condition|)
block|{
comment|// Value becomes zero for rounding beyond.
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// If necessary, divide and multiply to get rid of fractional digits.
if|if
condition|(
name|fastScale
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fast0
operator|=
name|fast0
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|fast1
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|fast2
expr_stmt|;
block|}
else|else
block|{
name|doFastScaleDown
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
comment|/* scaleDown */
name|fastScale
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
block|}
comment|// The fractional digits are gone; clear remaining round digits.
name|doClearRoundIntegerPortion
argument_list|(
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
name|absRoundPower
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|fastResult
operator|.
name|fast0
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast1
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast2
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
literal|0
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
literal|0
expr_stmt|;
name|fastResult
operator|.
name|fastSignum
operator|=
name|fastSignum
expr_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|fastRawPrecision
argument_list|(
name|fastResult
argument_list|)
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Fast decimal scale down by factor of 10 with rounding ROUND_HALF_UP.    *    * When the fraction being scaled away is>= 0.5, the add 1.    *    */
specifier|public
specifier|static
name|boolean
name|fastRoundIntegerHalfUp
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|roundPower
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
comment|/*      * Basic algorithm:      *      * 1. Determine if rounding digit is>= 5 for rounding.      * 2. Scale away fractional digits if present.      * 3. If rounding, clear integer rounding portion and add 1.      *      */
if|if
condition|(
name|roundPower
operator|>=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Expecting roundPower< 0 (roundPower "
operator|+
name|roundPower
operator|+
literal|")"
argument_list|)
throw|;
block|}
specifier|final
name|int
name|absRoundPower
init|=
operator|-
name|roundPower
decl_stmt|;
if|if
condition|(
name|fastIntegerDigitCount
operator|<
name|absRoundPower
condition|)
block|{
comment|// Zero result.
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|final
name|int
name|roundingPoint
init|=
name|absRoundPower
operator|+
name|fastScale
decl_stmt|;
if|if
condition|(
name|roundingPoint
operator|>
name|HiveDecimal
operator|.
name|MAX_PRECISION
condition|)
block|{
comment|// Value becomes zero for rounding beyond.
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// First, determine whether rounding is necessary based on rounding point, which is inside
comment|// integer part.  And, get rid of any fractional digits.  The result scale will be 0.
comment|//
name|boolean
name|isRoundPortionHalfUp
init|=
name|isRoundPortionHalfUp
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|roundingPoint
argument_list|)
decl_stmt|;
comment|// If necessary, divide and multiply to get rid of fractional digits.
if|if
condition|(
name|fastScale
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fast0
operator|=
name|fast0
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|fast1
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|fast2
expr_stmt|;
block|}
else|else
block|{
name|doFastScaleDown
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
comment|/* scaleDown */
name|fastScale
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
block|}
comment|// The fractional digits are gone; when rounding, clear remaining round digits and add 1.
if|if
condition|(
name|isRoundPortionHalfUp
condition|)
block|{
name|doClearRoundIntegerPortionAndAddOne
argument_list|(
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
name|absRoundPower
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doClearRoundIntegerPortion
argument_list|(
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
name|absRoundPower
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fastResult
operator|.
name|fast0
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast1
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast2
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
literal|0
expr_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
literal|0
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
name|fastSignum
expr_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|fastRawPrecision
argument_list|(
name|fastResult
argument_list|)
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Fast decimal scale down by factor of 10 with rounding ROUND_HALF_EVEN.    *    * When the fraction being scaled away is exactly 0.5, then round and add 1 only if aaa.    * When fraction is not exactly 0.5, then if fraction> 0.5 then add 1.    * Otherwise, throw away fraction.    *    * The signum will be updated if the result is 0, otherwise the original sign is unchanged.    */
specifier|public
specifier|static
name|boolean
name|fastRoundIntegerHalfEven
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|roundPower
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
comment|/*      * Basic algorithm:      *      * 1. Determine if rounding part meets banker's rounding rules for rounding.      * 2. Scale away fractional digits if present.      * 3. If rounding, clear integer rounding portion and add 1.      *      */
if|if
condition|(
name|roundPower
operator|>=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Expecting roundPower< 0 (roundPower "
operator|+
name|roundPower
operator|+
literal|")"
argument_list|)
throw|;
block|}
specifier|final
name|int
name|absRoundPower
init|=
operator|-
name|roundPower
decl_stmt|;
if|if
condition|(
name|fastIntegerDigitCount
operator|<
name|absRoundPower
condition|)
block|{
comment|// Zero result.
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
block|}
specifier|final
name|int
name|roundingPoint
init|=
name|absRoundPower
operator|+
name|fastScale
decl_stmt|;
if|if
condition|(
name|roundingPoint
operator|>
name|HiveDecimal
operator|.
name|MAX_PRECISION
condition|)
block|{
comment|// Value becomes zero for rounding beyond.
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// First, determine whether rounding is necessary based on rounding point, which is inside
comment|// integer part.  And, get rid of any fractional digits.  The result scale will be 0.
comment|//
name|boolean
name|isRoundPortionHalfEven
init|=
name|isRoundPortionHalfEven
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|roundingPoint
argument_list|)
decl_stmt|;
comment|// If necessary, divide and multiply to get rid of fractional digits.
if|if
condition|(
name|fastScale
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fast0
operator|=
name|fast0
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|fast1
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|fast2
expr_stmt|;
block|}
else|else
block|{
name|doFastScaleDown
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
comment|/* scaleDown */
name|fastScale
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
block|}
comment|// The fractional digits are gone; when rounding, clear remaining round digits and add 1.
if|if
condition|(
name|isRoundPortionHalfEven
condition|)
block|{
name|doClearRoundIntegerPortionAndAddOne
argument_list|(
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
name|absRoundPower
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doClearRoundIntegerPortion
argument_list|(
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
name|absRoundPower
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fastResult
operator|.
name|fast0
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast1
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast2
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
literal|0
expr_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
literal|0
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
name|fastSignum
expr_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|fastRawPrecision
argument_list|(
name|fastResult
argument_list|)
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Fast decimal scale down by factor of 10 and do not allow rounding.    *    * When the fraction being scaled away is non-zero, return false.    *    * The signum will be updated if the result is 0, otherwise the original sign is unchanged.    */
specifier|public
specifier|static
name|boolean
name|fastScaleDownNoRound
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|scaleDown
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
if|if
condition|(
name|scaleDown
operator|<
literal|1
operator|||
name|scaleDown
operator|>=
name|THREE_X_LONGWORD_DECIMAL_DIGITS
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Expecting scaleDown> 0 and scaleDown< 3*16 - 1 (scaleDown "
operator|+
name|scaleDown
operator|+
literal|")"
argument_list|)
throw|;
block|}
comment|// Adjust all longs using power 10 division/remainder.
name|long
name|result0
decl_stmt|;
name|long
name|result1
decl_stmt|;
name|long
name|result2
decl_stmt|;
if|if
condition|(
name|scaleDown
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Part of lowest word survives.
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|scaleDown
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|scaleDown
index|]
decl_stmt|;
specifier|final
name|long
name|throwAwayFraction
init|=
name|fast0
operator|%
name|divideFactor
decl_stmt|;
if|if
condition|(
name|throwAwayFraction
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|result0
operator|=
name|fast0
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result1
operator|=
name|fast1
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result2
operator|=
name|fast2
operator|/
name|divideFactor
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scaleDown
operator|<
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Throw away lowest word.
specifier|final
name|int
name|adjustedScaleDown
init|=
name|scaleDown
operator|-
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|adjustedScaleDown
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|adjustedScaleDown
index|]
decl_stmt|;
name|boolean
name|isThrowAwayFractionZero
decl_stmt|;
if|if
condition|(
name|adjustedScaleDown
operator|==
literal|0
condition|)
block|{
name|isThrowAwayFractionZero
operator|=
operator|(
name|fast0
operator|==
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|long
name|throwAwayFraction
init|=
name|fast1
operator|%
name|divideFactor
decl_stmt|;
name|isThrowAwayFractionZero
operator|=
operator|(
name|throwAwayFraction
operator|==
literal|0
operator|&&
name|fast0
operator|==
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isThrowAwayFractionZero
condition|)
block|{
return|return
literal|false
return|;
block|}
name|result0
operator|=
name|fast1
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result1
operator|=
name|fast2
operator|/
name|divideFactor
expr_stmt|;
name|result2
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// Throw away middle and lowest words.
specifier|final
name|int
name|adjustedScaleDown
init|=
name|scaleDown
operator|-
literal|2
operator|*
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|adjustedScaleDown
index|]
decl_stmt|;
name|boolean
name|isThrowAwayFractionZero
decl_stmt|;
if|if
condition|(
name|adjustedScaleDown
operator|==
literal|0
condition|)
block|{
name|isThrowAwayFractionZero
operator|=
operator|(
name|fast0
operator|==
literal|0
operator|&&
name|fast1
operator|==
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|long
name|throwAwayFraction
init|=
name|fast2
operator|%
name|divideFactor
decl_stmt|;
name|isThrowAwayFractionZero
operator|=
operator|(
name|throwAwayFraction
operator|==
literal|0
operator|&&
name|fast0
operator|==
literal|0
operator|&&
name|fast1
operator|==
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isThrowAwayFractionZero
condition|)
block|{
return|return
literal|false
return|;
block|}
name|result0
operator|=
name|fast2
operator|/
name|divideFactor
expr_stmt|;
name|result1
operator|=
literal|0
expr_stmt|;
name|result2
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|result0
operator|==
literal|0
operator|&&
name|result1
operator|==
literal|0
operator|&&
name|result2
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
name|fastSignum
expr_stmt|;
name|fastResult
operator|.
name|fast0
operator|=
name|result0
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|result1
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|result2
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Fast decimal scale down by factor of 10 with rounding ROUND_UP.    *    * When the fraction being scaled away is non-zero, the add 1.    *    */
specifier|public
specifier|static
name|boolean
name|fastRoundFractionalUp
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|scaleDown
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
if|if
condition|(
name|scaleDown
argument_list|<
literal|1
operator|||
name|scaleDown
argument_list|>
name|HiveDecimal
operator|.
name|MAX_SCALE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Expecting scaleDown> 0 and scaleDown< "
operator|+
name|HiveDecimal
operator|.
name|MAX_SCALE
operator|+
literal|" (scaleDown "
operator|+
name|scaleDown
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|scaleDown
operator|==
name|HiveDecimal
operator|.
name|MAX_SCALE
condition|)
block|{
comment|// Examine all digits being thrown away to determine if result is 0 or 1.
if|if
condition|(
name|fast0
operator|==
literal|0
operator|&&
name|fast1
operator|==
literal|0
operator|&&
name|fast2
operator|==
literal|0
condition|)
block|{
comment|// Zero result.
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastSet
argument_list|(
name|fastSignum
argument_list|,
comment|/* fast0 */
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* fastIntegerDigitCount */
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
name|boolean
name|isRoundPortionAllZeroes
init|=
name|isRoundPortionAllZeroes
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scaleDown
argument_list|)
decl_stmt|;
name|doFastScaleDown
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scaleDown
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isRoundPortionAllZeroes
condition|)
block|{
specifier|final
name|long
name|r0
init|=
name|fastResult
operator|.
name|fast0
operator|+
literal|1
decl_stmt|;
name|fastResult
operator|.
name|fast0
operator|=
name|r0
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r1
init|=
name|fastResult
operator|.
name|fast1
operator|+
name|r0
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|r1
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|fastResult
operator|.
name|fast2
operator|+
name|r1
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
block|}
if|if
condition|(
name|fastResult
operator|.
name|fast0
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast1
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast2
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
literal|0
expr_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
literal|0
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
name|fastSignum
expr_stmt|;
block|}
return|return
operator|(
name|fastResult
operator|.
name|fast2
operator|<=
name|MAX_HIGHWORD_DECIMAL
operator|)
return|;
block|}
comment|/**    * Fast decimal scale down by factor of 10 with rounding ROUND_DOWN.    *    * The fraction being scaled away is thrown away.    *    */
specifier|public
specifier|static
name|void
name|fastRoundFractionalDown
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|scaleDown
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
if|if
condition|(
name|scaleDown
argument_list|<
literal|1
operator|||
name|scaleDown
argument_list|>
name|HiveDecimal
operator|.
name|MAX_SCALE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Expecting scaleDown> 0 and scaleDown< 38 (scaleDown "
operator|+
name|scaleDown
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|scaleDown
operator|==
name|HiveDecimal
operator|.
name|MAX_SCALE
condition|)
block|{
comment|// Complete fractional digits shear off.  Zero result.
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
return|return;
block|}
name|doFastScaleDown
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scaleDown
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|fastResult
operator|.
name|fast0
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast1
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast2
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
literal|0
expr_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
literal|0
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
name|fastSignum
expr_stmt|;
block|}
block|}
comment|/**    * Fast decimal scale down by factor of 10 with rounding ROUND_HALF_UP.    *    * When the fraction being scaled away is>= 0.5, the add 1.    *    */
specifier|public
specifier|static
name|boolean
name|fastRoundFractionalHalfUp
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|scaleDown
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
if|if
condition|(
name|fastSignum
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unexpected zero value"
argument_list|)
throw|;
block|}
if|if
condition|(
name|scaleDown
argument_list|<
literal|1
operator|||
name|scaleDown
argument_list|>
name|HiveDecimal
operator|.
name|MAX_SCALE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Expecting scaleDown> 0 and scaleDown< 38 (scaleDown "
operator|+
name|scaleDown
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|scaleDown
operator|==
name|HiveDecimal
operator|.
name|MAX_SCALE
condition|)
block|{
comment|// Check highest digit for rounding.
specifier|final
name|long
name|roundDigit
init|=
name|fast2
operator|/
name|powerOfTenTable
index|[
name|HIGHWORD_DECIMAL_DIGITS
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|roundDigit
operator|<
literal|5
condition|)
block|{
comment|// Zero result.
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastSet
argument_list|(
name|fastSignum
argument_list|,
comment|/* fast0 */
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* fastIntegerDigitCount */
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
name|boolean
name|isRoundPortionHalfUp
init|=
name|isRoundPortionHalfUp
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scaleDown
argument_list|)
decl_stmt|;
name|doFastScaleDown
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scaleDown
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|isRoundPortionHalfUp
condition|)
block|{
specifier|final
name|long
name|r0
init|=
name|fastResult
operator|.
name|fast0
operator|+
literal|1
decl_stmt|;
name|fastResult
operator|.
name|fast0
operator|=
name|r0
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r1
init|=
name|fastResult
operator|.
name|fast1
operator|+
name|r0
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|r1
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|fastResult
operator|.
name|fast2
operator|+
name|r1
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
block|}
if|if
condition|(
name|fastResult
operator|.
name|fast0
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast1
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast2
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
literal|0
expr_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
literal|0
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
name|fastSignum
expr_stmt|;
block|}
return|return
operator|(
name|fastResult
operator|.
name|fast2
operator|<=
name|MAX_HIGHWORD_DECIMAL
operator|)
return|;
block|}
comment|/**    * Fast decimal scale down by factor of 10 with rounding ROUND_HALF_UP.    *    * When the fraction being scaled away is>= 0.5, the add 1.    *    */
specifier|public
specifier|static
name|boolean
name|fastRoundFractionalHalfUp5Words
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|long
name|fast3
parameter_list|,
name|long
name|fast4
parameter_list|,
name|int
name|scaleDown
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
comment|// Adjust all longs using power 10 division/remainder.
name|long
name|result0
decl_stmt|;
name|long
name|result1
decl_stmt|;
name|long
name|result2
decl_stmt|;
name|long
name|result3
decl_stmt|;
name|long
name|result4
decl_stmt|;
if|if
condition|(
name|scaleDown
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Part of lowest word survives.
comment|// Divide down just before scaleDown to get round digit.
specifier|final
name|long
name|withRoundDigit
init|=
name|fast0
operator|/
name|powerOfTenTable
index|[
name|scaleDown
operator|-
literal|1
index|]
decl_stmt|;
specifier|final
name|long
name|roundDigit
init|=
name|withRoundDigit
operator|%
literal|10
decl_stmt|;
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|scaleDown
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|scaleDown
index|]
decl_stmt|;
if|if
condition|(
name|roundDigit
operator|<
literal|5
condition|)
block|{
name|result0
operator|=
name|withRoundDigit
operator|/
literal|10
operator|+
operator|(
operator|(
name|fast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result1
operator|=
name|fast1
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result2
operator|=
operator|+
name|fast2
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast3
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result3
operator|=
name|fast3
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast4
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result4
operator|=
name|fast4
operator|/
name|divideFactor
expr_stmt|;
block|}
else|else
block|{
comment|// Add rounding and handle carry.
specifier|final
name|long
name|r0
init|=
name|withRoundDigit
operator|/
literal|10
operator|+
operator|(
operator|(
name|fast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
operator|+
literal|1
decl_stmt|;
name|result0
operator|=
name|r0
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r1
init|=
name|fast1
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
operator|+
name|r0
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|result1
operator|=
name|r1
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r2
init|=
name|fast2
operator|/
name|divideFactor
operator|+
operator|+
operator|(
operator|(
name|fast3
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
operator|+
name|r1
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|result2
operator|=
name|r2
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r3
init|=
name|fast3
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast4
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
operator|+
name|r2
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|result3
operator|=
name|r3
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|result4
operator|=
name|fast4
operator|/
name|divideFactor
operator|+
name|r3
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|scaleDown
operator|<
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Throw away lowest word.
specifier|final
name|int
name|adjustedScaleDown
init|=
name|scaleDown
operator|-
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
name|long
name|roundDigit
decl_stmt|;
name|long
name|fast1Scaled
decl_stmt|;
if|if
condition|(
name|adjustedScaleDown
operator|==
literal|0
condition|)
block|{
comment|// Grab round digit from lowest word.
name|roundDigit
operator|=
name|fast0
operator|/
operator|(
name|MULTIPLER_LONGWORD_DECIMAL
operator|/
literal|10
operator|)
expr_stmt|;
name|fast1Scaled
operator|=
name|fast1
expr_stmt|;
block|}
else|else
block|{
comment|// Divide down just before scaleDown to get round digit.
specifier|final
name|long
name|withRoundDigit
init|=
name|fast1
operator|/
name|powerOfTenTable
index|[
name|adjustedScaleDown
operator|-
literal|1
index|]
decl_stmt|;
name|roundDigit
operator|=
name|withRoundDigit
operator|%
literal|10
expr_stmt|;
name|fast1Scaled
operator|=
name|withRoundDigit
operator|/
literal|10
expr_stmt|;
block|}
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|adjustedScaleDown
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|adjustedScaleDown
index|]
decl_stmt|;
if|if
condition|(
name|roundDigit
operator|<
literal|5
condition|)
block|{
name|result0
operator|=
name|fast1Scaled
operator|+
operator|(
operator|(
name|fast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result1
operator|=
name|fast2
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast3
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result2
operator|=
name|fast3
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast4
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result3
operator|=
name|fast4
operator|/
name|divideFactor
expr_stmt|;
block|}
else|else
block|{
comment|// Add rounding and handle carry.
specifier|final
name|long
name|r0
init|=
name|fast1Scaled
operator|+
operator|(
operator|(
name|fast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
operator|+
literal|1
decl_stmt|;
name|result0
operator|=
name|r0
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r1
init|=
name|fast2
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast3
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
operator|+
name|r0
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|result1
operator|=
name|r1
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r2
init|=
name|fast3
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast4
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
operator|+
name|r1
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|result2
operator|=
name|r2
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|result3
operator|=
name|fast4
operator|/
name|divideFactor
operator|+
name|r2
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
block|}
name|result4
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// Throw away middle and lowest words.
specifier|final
name|int
name|adjustedScaleDown
init|=
name|scaleDown
operator|-
literal|2
operator|*
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
name|long
name|roundDigit
decl_stmt|;
name|long
name|fast2Scaled
decl_stmt|;
if|if
condition|(
name|adjustedScaleDown
operator|==
literal|0
condition|)
block|{
comment|// Grab round digit from middle word.
name|roundDigit
operator|=
name|fast1
operator|/
operator|(
name|MULTIPLER_LONGWORD_DECIMAL
operator|/
literal|10
operator|)
expr_stmt|;
name|fast2Scaled
operator|=
name|fast2
expr_stmt|;
block|}
else|else
block|{
comment|// Divide down just before scaleDown to get round digit.
specifier|final
name|long
name|withRoundDigit
init|=
name|fast2
operator|/
name|powerOfTenTable
index|[
name|adjustedScaleDown
operator|-
literal|1
index|]
decl_stmt|;
name|roundDigit
operator|=
name|withRoundDigit
operator|%
literal|10
expr_stmt|;
name|fast2Scaled
operator|=
name|withRoundDigit
operator|/
literal|10
expr_stmt|;
block|}
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|adjustedScaleDown
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|adjustedScaleDown
index|]
decl_stmt|;
if|if
condition|(
name|roundDigit
operator|<
literal|5
condition|)
block|{
name|result0
operator|=
name|fast2Scaled
operator|+
operator|(
operator|(
name|fast3
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result1
operator|=
name|fast3
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast4
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result2
operator|=
name|fast4
operator|/
name|divideFactor
expr_stmt|;
block|}
else|else
block|{
comment|// Add rounding.
specifier|final
name|long
name|r0
init|=
name|fast2Scaled
operator|+
operator|(
operator|(
name|fast3
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
operator|+
literal|1
decl_stmt|;
name|result0
operator|=
name|r0
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r1
init|=
name|fast3
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast4
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
operator|+
name|r0
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|result1
operator|=
name|r1
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|result2
operator|=
name|fast4
operator|/
name|divideFactor
operator|+
name|r1
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
block|}
name|result3
operator|=
literal|0
expr_stmt|;
name|result4
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|result4
operator|!=
literal|0
operator|||
name|result3
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected overflow into result3 or result4"
argument_list|)
throw|;
block|}
if|if
condition|(
name|result0
operator|==
literal|0
operator|&&
name|result1
operator|==
literal|0
operator|&&
name|result2
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
block|}
name|fastResult
operator|.
name|fastSignum
operator|=
name|fastSignum
expr_stmt|;
name|fastResult
operator|.
name|fast0
operator|=
name|result0
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|result1
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|result2
expr_stmt|;
return|return
operator|(
name|result2
operator|<=
name|MAX_HIGHWORD_DECIMAL
operator|)
return|;
block|}
comment|/**    * Fast decimal scale down by factor of 10 with rounding ROUND_HALF_EVEN.    *    * When the fraction being scaled away is exactly 0.5, then round and add 1 only if aaa.    * When fraction is not exactly 0.5, then if fraction> 0.5 then add 1.    * Otherwise, throw away fraction.    *    */
specifier|public
specifier|static
name|boolean
name|fastRoundFractionalHalfEven
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|scaleDown
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
if|if
condition|(
name|scaleDown
argument_list|<
literal|1
operator|||
name|scaleDown
argument_list|>
name|HiveDecimal
operator|.
name|MAX_SCALE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Expecting scaleDown> 0 and scaleDown< 38 (scaleDown "
operator|+
name|scaleDown
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|scaleDown
operator|==
name|HiveDecimal
operator|.
name|MAX_SCALE
condition|)
block|{
comment|// Check for rounding.
specifier|final
name|long
name|roundDivisor
init|=
name|powerOfTenTable
index|[
name|HIGHWORD_DECIMAL_DIGITS
operator|-
literal|1
index|]
decl_stmt|;
specifier|final
name|long
name|withRoundDigit
init|=
name|fast2
operator|/
name|roundDivisor
decl_stmt|;
specifier|final
name|long
name|roundDigit
init|=
name|withRoundDigit
operator|%
literal|10
decl_stmt|;
specifier|final
name|long
name|fast2Scaled
init|=
name|withRoundDigit
operator|/
literal|10
decl_stmt|;
name|boolean
name|shouldRound
decl_stmt|;
if|if
condition|(
name|roundDigit
operator|>
literal|5
condition|)
block|{
name|shouldRound
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|roundDigit
operator|==
literal|5
condition|)
block|{
name|boolean
name|exactlyOneHalf
init|=
operator|(
name|fast2Scaled
operator|==
literal|0
operator|&&
name|fast1
operator|==
literal|0
operator|&&
name|fast0
operator|==
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|exactlyOneHalf
condition|)
block|{
comment|// Round to even 0.
name|shouldRound
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|shouldRound
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|shouldRound
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|shouldRound
condition|)
block|{
comment|// Zero result.
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastSet
argument_list|(
name|fastSignum
argument_list|,
comment|/* fast0 */
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* fastIntegerDigitCount */
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
name|boolean
name|isRoundPortionHalfEven
init|=
name|isRoundPortionHalfEven
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scaleDown
argument_list|)
decl_stmt|;
name|doFastScaleDown
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|scaleDown
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|isRoundPortionHalfEven
condition|)
block|{
specifier|final
name|long
name|r0
init|=
name|fastResult
operator|.
name|fast0
operator|+
literal|1
decl_stmt|;
name|fastResult
operator|.
name|fast0
operator|=
name|r0
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r1
init|=
name|fastResult
operator|.
name|fast1
operator|+
name|r0
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|r1
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|fastResult
operator|.
name|fast2
operator|+
name|r1
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
block|}
if|if
condition|(
name|fastResult
operator|.
name|fast0
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast1
operator|==
literal|0
operator|&&
name|fastResult
operator|.
name|fast2
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
literal|0
expr_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
literal|0
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
name|fastSignum
expr_stmt|;
block|}
return|return
operator|(
name|fastResult
operator|.
name|fast2
operator|<=
name|MAX_HIGHWORD_DECIMAL
operator|)
return|;
block|}
specifier|public
specifier|static
name|void
name|doFastScaleDown
parameter_list|(
name|FastHiveDecimal
name|fastDec
parameter_list|,
name|int
name|scaleDown
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
name|doFastScaleDown
argument_list|(
name|fastDec
operator|.
name|fast0
argument_list|,
name|fastDec
operator|.
name|fast1
argument_list|,
name|fastDec
operator|.
name|fast2
argument_list|,
name|scaleDown
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
block|}
comment|//************************************************************************************************
comment|// Decimal Scale Up/Down.
comment|/**    * Fast decimal scale down by factor of 10 with NO rounding.    *    * The signum will be updated if the result is 0, otherwise the original sign is unchanged.    */
specifier|public
specifier|static
name|void
name|doFastScaleDown
parameter_list|(
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|scaleDown
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
comment|// Adjust all longs using power 10 division/remainder.
name|long
name|result0
decl_stmt|;
name|long
name|result1
decl_stmt|;
name|long
name|result2
decl_stmt|;
if|if
condition|(
name|scaleDown
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Part of lowest word survives.
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|scaleDown
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|scaleDown
index|]
decl_stmt|;
name|result0
operator|=
name|fast0
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result1
operator|=
name|fast1
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result2
operator|=
name|fast2
operator|/
name|divideFactor
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scaleDown
operator|<
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Throw away lowest word.
specifier|final
name|int
name|adjustedScaleDown
init|=
name|scaleDown
operator|-
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|adjustedScaleDown
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|adjustedScaleDown
index|]
decl_stmt|;
name|result0
operator|=
name|fast1
operator|/
name|divideFactor
operator|+
operator|(
operator|(
name|fast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|)
expr_stmt|;
name|result1
operator|=
name|fast2
operator|/
name|divideFactor
expr_stmt|;
name|result2
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// Throw away middle and lowest words.
specifier|final
name|int
name|adjustedScaleDown
init|=
name|scaleDown
operator|-
literal|2
operator|*
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
name|result0
operator|=
name|fast2
operator|/
name|powerOfTenTable
index|[
name|adjustedScaleDown
index|]
expr_stmt|;
name|result1
operator|=
literal|0
expr_stmt|;
name|result2
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|result0
operator|==
literal|0
operator|&&
name|result1
operator|==
literal|0
operator|&&
name|result2
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
literal|0
expr_stmt|;
block|}
name|fastResult
operator|.
name|fast0
operator|=
name|result0
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|result1
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|result2
expr_stmt|;
block|}
specifier|public
specifier|static
name|boolean
name|fastScaleUp
parameter_list|(
name|FastHiveDecimal
name|fastDec
parameter_list|,
name|int
name|scaleUp
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
return|return
name|fastScaleUp
argument_list|(
name|fastDec
operator|.
name|fast0
argument_list|,
name|fastDec
operator|.
name|fast1
argument_list|,
name|fastDec
operator|.
name|fast2
argument_list|,
name|scaleUp
argument_list|,
name|fastResult
argument_list|)
return|;
block|}
comment|/**    * Fast decimal scale up by factor of 10.    */
specifier|public
specifier|static
name|boolean
name|fastScaleUp
parameter_list|(
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|scaleUp
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
if|if
condition|(
name|scaleUp
operator|<
literal|1
operator|||
name|scaleUp
operator|>=
name|HiveDecimal
operator|.
name|MAX_SCALE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Expecting scaleUp> 0 and scaleUp< 38"
argument_list|)
throw|;
block|}
name|long
name|result0
decl_stmt|;
name|long
name|result1
decl_stmt|;
name|long
name|result2
decl_stmt|;
comment|// Each range checks for overflow first, then moves digits.
if|if
condition|(
name|scaleUp
operator|<
name|HIGHWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Need to check if there are overflow digits in the high word.
specifier|final
name|long
name|overflowFactor
init|=
name|powerOfTenTable
index|[
name|HIGHWORD_DECIMAL_DIGITS
operator|-
name|scaleUp
index|]
decl_stmt|;
if|if
condition|(
name|fast2
operator|/
name|overflowFactor
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|scaleUp
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|scaleUp
index|]
decl_stmt|;
name|result2
operator|=
name|fast2
operator|*
name|multiplyFactor
operator|+
name|fast1
operator|/
name|divideFactor
expr_stmt|;
name|result1
operator|=
operator|(
name|fast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|+
name|fast0
operator|/
name|divideFactor
expr_stmt|;
name|result0
operator|=
operator|(
name|fast0
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scaleUp
operator|<
name|HIGHWORD_DECIMAL_DIGITS
operator|+
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// High word must be zero.  Check for overflow digits in middle word.
if|if
condition|(
name|fast2
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|adjustedScaleUp
init|=
name|scaleUp
operator|-
name|HIGHWORD_DECIMAL_DIGITS
decl_stmt|;
specifier|final
name|int
name|middleDigits
init|=
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|adjustedScaleUp
decl_stmt|;
specifier|final
name|long
name|overflowFactor
init|=
name|powerOfTenTable
index|[
name|middleDigits
index|]
decl_stmt|;
if|if
condition|(
name|fast1
operator|/
name|overflowFactor
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|middleDigits
operator|<
name|HIGHWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Must fill high word from both middle and lower longs.
specifier|final
name|int
name|highWordMoreDigits
init|=
name|HIGHWORD_DECIMAL_DIGITS
operator|-
name|middleDigits
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|highWordMoreDigits
index|]
decl_stmt|;
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|highWordMoreDigits
index|]
decl_stmt|;
name|result2
operator|=
name|fast1
operator|*
name|multiplyFactor
operator|+
name|fast0
operator|/
name|divideFactor
expr_stmt|;
name|result1
operator|=
operator|(
name|fast0
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
expr_stmt|;
name|result0
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|middleDigits
operator|==
name|HIGHWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Fill high long from middle long, and middle long from lower long.
name|result2
operator|=
name|fast1
expr_stmt|;
name|result1
operator|=
name|fast0
expr_stmt|;
name|result0
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// Fill high long from some of middle long.
specifier|final
name|int
name|keepMiddleDigits
init|=
name|middleDigits
operator|-
name|HIGHWORD_DECIMAL_DIGITS
decl_stmt|;
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|keepMiddleDigits
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|keepMiddleDigits
index|]
decl_stmt|;
name|result2
operator|=
name|fast1
operator|/
name|divideFactor
expr_stmt|;
name|result1
operator|=
operator|(
name|fast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|+
name|fast0
operator|/
name|divideFactor
expr_stmt|;
name|result0
operator|=
operator|(
name|fast0
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// High and middle word must be zero.  Check for overflow digits in lower word.
if|if
condition|(
name|fast2
operator|!=
literal|0
operator|||
name|fast1
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|adjustedScaleUp
init|=
name|scaleUp
operator|-
name|HIGHWORD_DECIMAL_DIGITS
operator|-
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
specifier|final
name|int
name|lowerDigits
init|=
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|adjustedScaleUp
decl_stmt|;
specifier|final
name|long
name|overflowFactor
init|=
name|powerOfTenTable
index|[
name|lowerDigits
index|]
decl_stmt|;
if|if
condition|(
name|fast0
operator|/
name|overflowFactor
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|lowerDigits
operator|<
name|HIGHWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Must fill high word from both middle and lower longs.
specifier|final
name|int
name|highWordMoreDigits
init|=
name|HIGHWORD_DECIMAL_DIGITS
operator|-
name|lowerDigits
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|highWordMoreDigits
index|]
decl_stmt|;
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|highWordMoreDigits
index|]
decl_stmt|;
name|result2
operator|=
name|fast0
operator|*
name|multiplyFactor
expr_stmt|;
name|result1
operator|=
literal|0
expr_stmt|;
name|result0
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lowerDigits
operator|==
name|HIGHWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Fill high long from lower long.
name|result2
operator|=
name|fast0
expr_stmt|;
name|result1
operator|=
literal|0
expr_stmt|;
name|result0
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// Fill high long and middle from some of lower long.
specifier|final
name|int
name|keepLowerDigits
init|=
name|lowerDigits
operator|-
name|HIGHWORD_DECIMAL_DIGITS
decl_stmt|;
specifier|final
name|long
name|keepLowerDivideFactor
init|=
name|powerOfTenTable
index|[
name|keepLowerDigits
index|]
decl_stmt|;
specifier|final
name|long
name|keepLowerMultiplyFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|keepLowerDigits
index|]
decl_stmt|;
name|result2
operator|=
name|fast0
operator|/
name|keepLowerDivideFactor
expr_stmt|;
name|result1
operator|=
operator|(
name|fast0
operator|%
name|keepLowerDivideFactor
operator|)
operator|*
name|keepLowerMultiplyFactor
expr_stmt|;
name|result0
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result0
operator|==
literal|0
operator|&&
name|result1
operator|==
literal|0
operator|&&
name|result2
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
literal|0
expr_stmt|;
block|}
name|fastResult
operator|.
name|fast0
operator|=
name|result0
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|result1
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|result2
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|//************************************************************************************************
comment|// Decimal Precision / Trailing Zeroes.
specifier|public
specifier|static
name|int
name|fastLongWordTrailingZeroCount
parameter_list|(
name|long
name|longWord
parameter_list|)
block|{
if|if
condition|(
name|longWord
operator|==
literal|0
condition|)
block|{
return|return
name|LONGWORD_DECIMAL_DIGITS
return|;
block|}
name|long
name|factor
init|=
literal|10
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|longWord
operator|%
name|factor
operator|!=
literal|0
condition|)
block|{
return|return
name|i
return|;
block|}
name|factor
operator|*=
literal|10
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
specifier|public
specifier|static
name|int
name|fastHighWordTrailingZeroCount
parameter_list|(
name|long
name|longWord
parameter_list|)
block|{
if|if
condition|(
name|longWord
operator|==
literal|0
condition|)
block|{
return|return
name|HIGHWORD_DECIMAL_DIGITS
return|;
block|}
name|long
name|factor
init|=
literal|10
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|HIGHWORD_DECIMAL_DIGITS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|longWord
operator|%
name|factor
operator|!=
literal|0
condition|)
block|{
return|return
name|i
return|;
block|}
name|factor
operator|*=
literal|10
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
specifier|public
specifier|static
name|int
name|fastLongWordPrecision
parameter_list|(
name|long
name|longWord
parameter_list|)
block|{
if|if
condition|(
name|longWord
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|// Search like binary search to minimize comparisons.
if|if
condition|(
name|longWord
operator|>
literal|99999999L
condition|)
block|{
if|if
condition|(
name|longWord
operator|>
literal|999999999999L
condition|)
block|{
if|if
condition|(
name|longWord
operator|>
literal|99999999999999L
condition|)
block|{
if|if
condition|(
name|longWord
operator|>
literal|999999999999999L
condition|)
block|{
return|return
literal|16
return|;
block|}
else|else
block|{
return|return
literal|15
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|longWord
operator|>
literal|9999999999999L
condition|)
block|{
return|return
literal|14
return|;
block|}
else|else
block|{
return|return
literal|13
return|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|longWord
operator|>
literal|9999999999L
condition|)
block|{
if|if
condition|(
name|longWord
operator|>
literal|99999999999L
condition|)
block|{
return|return
literal|12
return|;
block|}
else|else
block|{
return|return
literal|11
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|longWord
operator|>
literal|999999999L
condition|)
block|{
return|return
literal|10
return|;
block|}
else|else
block|{
return|return
literal|9
return|;
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|longWord
operator|>
literal|9999L
condition|)
block|{
if|if
condition|(
name|longWord
operator|>
literal|999999L
condition|)
block|{
if|if
condition|(
name|longWord
operator|>
literal|9999999L
condition|)
block|{
return|return
literal|8
return|;
block|}
else|else
block|{
return|return
literal|7
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|longWord
operator|>
literal|99999L
condition|)
block|{
return|return
literal|6
return|;
block|}
else|else
block|{
return|return
literal|5
return|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|longWord
operator|>
literal|99L
condition|)
block|{
if|if
condition|(
name|longWord
operator|>
literal|999L
condition|)
block|{
return|return
literal|4
return|;
block|}
else|else
block|{
return|return
literal|3
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|longWord
operator|>
literal|9L
condition|)
block|{
return|return
literal|2
return|;
block|}
else|else
block|{
return|return
literal|1
return|;
block|}
block|}
block|}
block|}
block|}
specifier|public
specifier|static
name|int
name|fastHighWordPrecision
parameter_list|(
name|long
name|longWord
parameter_list|)
block|{
if|if
condition|(
name|longWord
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|// 6 highword digits.
if|if
condition|(
name|longWord
operator|>
literal|999L
condition|)
block|{
if|if
condition|(
name|longWord
operator|>
literal|9999L
condition|)
block|{
if|if
condition|(
name|longWord
operator|>
literal|99999L
condition|)
block|{
return|return
literal|6
return|;
block|}
else|else
block|{
return|return
literal|5
return|;
block|}
block|}
else|else
block|{
return|return
literal|4
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|longWord
operator|>
literal|99L
condition|)
block|{
return|return
literal|3
return|;
block|}
else|else
block|{
if|if
condition|(
name|longWord
operator|>
literal|9L
condition|)
block|{
return|return
literal|2
return|;
block|}
else|else
block|{
return|return
literal|1
return|;
block|}
block|}
block|}
block|}
specifier|public
specifier|static
name|int
name|fastSqlPrecision
parameter_list|(
name|FastHiveDecimal
name|fastDec
parameter_list|)
block|{
return|return
name|fastSqlPrecision
argument_list|(
name|fastDec
operator|.
name|fastSignum
argument_list|,
name|fastDec
operator|.
name|fast0
argument_list|,
name|fastDec
operator|.
name|fast1
argument_list|,
name|fastDec
operator|.
name|fast2
argument_list|,
name|fastDec
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastDec
operator|.
name|fastScale
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|fastSqlPrecision
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|)
block|{
if|if
condition|(
name|fastSignum
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
specifier|final
name|int
name|rawPrecision
init|=
name|fastRawPrecision
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|)
decl_stmt|;
if|if
condition|(
name|rawPrecision
operator|<
name|fastScale
condition|)
block|{
comment|// This can happen for numbers less than 0.1
comment|// For 0.001234: rawPrecision=4, scale=6
comment|// In this case, we'll set the type to have the same precision as the scale.
return|return
name|fastScale
return|;
block|}
return|return
name|rawPrecision
return|;
block|}
specifier|public
specifier|static
name|int
name|fastRawPrecision
parameter_list|(
name|FastHiveDecimal
name|fastDec
parameter_list|)
block|{
return|return
name|fastRawPrecision
argument_list|(
name|fastDec
operator|.
name|fastSignum
argument_list|,
name|fastDec
operator|.
name|fast0
argument_list|,
name|fastDec
operator|.
name|fast1
argument_list|,
name|fastDec
operator|.
name|fast2
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|fastRawPrecision
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|)
block|{
if|if
condition|(
name|fastSignum
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|precision
decl_stmt|;
if|if
condition|(
name|fast2
operator|!=
literal|0
condition|)
block|{
comment|// 6 highword digits.
name|precision
operator|=
name|TWO_X_LONGWORD_DECIMAL_DIGITS
operator|+
name|fastHighWordPrecision
argument_list|(
name|fast2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fast1
operator|!=
literal|0
condition|)
block|{
comment|// Check fast1.
name|precision
operator|=
name|LONGWORD_DECIMAL_DIGITS
operator|+
name|fastLongWordPrecision
argument_list|(
name|fast1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Check fast0.
name|precision
operator|=
name|fastLongWordPrecision
argument_list|(
name|fast0
argument_list|)
expr_stmt|;
block|}
return|return
name|precision
return|;
block|}
comment|// Determine if all digits below a power is zero.
comment|// The lowest digit is power = 0.
specifier|public
specifier|static
name|boolean
name|isAllZeroesBelow
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|power
parameter_list|)
block|{
if|if
condition|(
name|power
argument_list|<
literal|0
operator|||
name|power
argument_list|>
name|HiveDecimal
operator|.
name|MAX_SCALE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Expecting power>= 0 and power<= 38"
argument_list|)
throw|;
block|}
if|if
condition|(
name|fastSignum
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|power
operator|>=
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
if|if
condition|(
name|fast0
operator|!=
literal|0
operator|||
name|fast1
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|adjustedPower
init|=
name|power
operator|-
name|TWO_X_LONGWORD_DECIMAL_DIGITS
decl_stmt|;
if|if
condition|(
name|adjustedPower
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
name|long
name|remainder
init|=
name|fast2
operator|%
name|powerOfTenTable
index|[
name|adjustedPower
index|]
decl_stmt|;
return|return
operator|(
name|remainder
operator|==
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|power
operator|>=
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
if|if
condition|(
name|fast0
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|adjustedPower
init|=
name|power
operator|-
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
if|if
condition|(
name|adjustedPower
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
name|long
name|remainder
init|=
name|fast1
operator|%
name|powerOfTenTable
index|[
name|adjustedPower
index|]
decl_stmt|;
return|return
operator|(
name|remainder
operator|==
literal|0
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|power
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
name|long
name|remainder
init|=
name|fast0
operator|%
name|powerOfTenTable
index|[
name|power
index|]
decl_stmt|;
return|return
operator|(
name|remainder
operator|==
literal|0
operator|)
return|;
block|}
block|}
specifier|public
specifier|static
name|boolean
name|fastExceedsPrecision
parameter_list|(
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
if|if
condition|(
name|precision
operator|<=
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|precision
operator|>=
name|HiveDecimal
operator|.
name|MAX_PRECISION
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|precisionLessOne
init|=
name|precision
operator|-
literal|1
decl_stmt|;
comment|// 0 (lowest), 1 (middle), or 2 (high).
name|int
name|wordNum
init|=
name|precisionLessOne
operator|/
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
name|int
name|digitInWord
init|=
name|precisionLessOne
operator|%
name|LONGWORD_DECIMAL_DIGITS
decl_stmt|;
specifier|final
name|long
name|overLimitInWord
init|=
name|powerOfTenTable
index|[
name|digitInWord
operator|+
literal|1
index|]
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|wordNum
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|digitInWord
operator|<
name|LONGWORD_DECIMAL_DIGITS
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|fast0
operator|>
name|overLimitInWord
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
operator|(
name|fast1
operator|!=
literal|0
operator|||
name|fast2
operator|!=
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|wordNum
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|digitInWord
operator|<
name|LONGWORD_DECIMAL_DIGITS
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|fast1
operator|>
name|overLimitInWord
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
operator|(
name|fast2
operator|!=
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|// We've eliminated the highest digit already with HiveDecimal.MAX_PRECISION check above.
return|return
operator|(
name|fast2
operator|>
name|overLimitInWord
operator|)
return|;
block|}
block|}
specifier|public
specifier|static
name|int
name|fastTrailingDecimalZeroCount
parameter_list|(
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|)
block|{
if|if
condition|(
name|fastScale
argument_list|<
literal|0
operator|||
name|fastScale
argument_list|>
name|HiveDecimal
operator|.
name|MAX_SCALE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Expecting scale>= 0 and scale<= 38"
argument_list|)
throw|;
block|}
if|if
condition|(
name|fastScale
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
specifier|final
name|int
name|lowerLongwordDigits
init|=
name|Math
operator|.
name|min
argument_list|(
name|fastScale
argument_list|,
name|LONGWORD_DECIMAL_DIGITS
argument_list|)
decl_stmt|;
if|if
condition|(
name|lowerLongwordDigits
operator|<
name|LONGWORD_DECIMAL_DIGITS
operator|||
name|fast0
operator|!=
literal|0
condition|)
block|{
name|long
name|factor
init|=
literal|10
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lowerLongwordDigits
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fast0
operator|%
name|factor
operator|!=
literal|0
condition|)
block|{
return|return
name|i
return|;
block|}
name|factor
operator|*=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|lowerLongwordDigits
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
return|return
name|fastScale
return|;
block|}
block|}
if|if
condition|(
name|fastScale
operator|==
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
return|return
name|fastScale
return|;
block|}
specifier|final
name|int
name|middleLongwordDigits
init|=
name|Math
operator|.
name|min
argument_list|(
name|fastScale
operator|-
name|LONGWORD_DECIMAL_DIGITS
argument_list|,
name|LONGWORD_DECIMAL_DIGITS
argument_list|)
decl_stmt|;
if|if
condition|(
name|middleLongwordDigits
operator|<
name|LONGWORD_DECIMAL_DIGITS
operator|||
name|fast1
operator|!=
literal|0
condition|)
block|{
name|long
name|factor
init|=
literal|10
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|middleLongwordDigits
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fast1
operator|%
name|factor
operator|!=
literal|0
condition|)
block|{
return|return
name|LONGWORD_DECIMAL_DIGITS
operator|+
name|i
return|;
block|}
name|factor
operator|*=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|middleLongwordDigits
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
return|return
name|fastScale
return|;
block|}
block|}
if|if
condition|(
name|fastScale
operator|==
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
return|return
name|fastScale
return|;
block|}
specifier|final
name|int
name|highLongwordDigits
init|=
name|fastScale
operator|-
name|TWO_X_LONGWORD_DECIMAL_DIGITS
decl_stmt|;
if|if
condition|(
name|highLongwordDigits
operator|<
name|HIGHWORD_DECIMAL_DIGITS
operator|||
name|fast2
operator|!=
literal|0
condition|)
block|{
name|long
name|factor
init|=
literal|10
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|highLongwordDigits
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fast2
operator|%
name|factor
operator|!=
literal|0
condition|)
block|{
return|return
name|TWO_X_LONGWORD_DECIMAL_DIGITS
operator|+
name|i
return|;
block|}
name|factor
operator|*=
literal|10
expr_stmt|;
block|}
block|}
return|return
name|fastScale
return|;
block|}
specifier|public
specifier|static
name|FastCheckPrecisionScaleStatus
name|fastCheckPrecisionScale
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|maxPrecision
parameter_list|,
name|int
name|maxScale
parameter_list|)
block|{
if|if
condition|(
name|fastSignum
operator|==
literal|0
condition|)
block|{
return|return
name|FastCheckPrecisionScaleStatus
operator|.
name|NO_CHANGE
return|;
block|}
specifier|final
name|int
name|maxIntegerDigitCount
init|=
name|maxPrecision
operator|-
name|maxScale
decl_stmt|;
if|if
condition|(
name|fastIntegerDigitCount
operator|>
name|maxIntegerDigitCount
condition|)
block|{
return|return
name|FastCheckPrecisionScaleStatus
operator|.
name|OVERFLOW
return|;
block|}
if|if
condition|(
name|fastScale
operator|>
name|maxScale
condition|)
block|{
return|return
name|FastCheckPrecisionScaleStatus
operator|.
name|UPDATE_SCALE_DOWN
return|;
block|}
return|return
name|FastCheckPrecisionScaleStatus
operator|.
name|NO_CHANGE
return|;
block|}
specifier|public
specifier|static
name|boolean
name|fastUpdatePrecisionScale
parameter_list|(
specifier|final
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|maxPrecision
parameter_list|,
name|int
name|maxScale
parameter_list|,
name|FastCheckPrecisionScaleStatus
name|status
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|UPDATE_SCALE_DOWN
case|:
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
name|fastSignum
expr_stmt|;
comment|// Throw away lower digits.
if|if
condition|(
operator|!
name|fastRoundFractionalHalfUp
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastScale
operator|-
name|maxScale
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|fastResult
operator|.
name|fastScale
operator|=
name|maxScale
expr_stmt|;
comment|// CONSIDER: For now, recompute integerDigitCount...
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|fastRawPrecision
argument_list|(
name|fastResult
argument_list|)
operator|-
name|fastResult
operator|.
name|fastScale
argument_list|)
expr_stmt|;
comment|// And, round up may cause us to exceed our precision/scale...
specifier|final
name|int
name|maxIntegerDigitCount
init|=
name|maxPrecision
operator|-
name|maxScale
decl_stmt|;
if|if
condition|(
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|>
name|maxIntegerDigitCount
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Scaling down may have opened up trailing zeroes...
specifier|final
name|int
name|trailingZeroCount
init|=
name|fastTrailingDecimalZeroCount
argument_list|(
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
name|fastResult
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastResult
operator|.
name|fastScale
argument_list|)
decl_stmt|;
if|if
condition|(
name|trailingZeroCount
operator|>
literal|0
condition|)
block|{
comment|// Scale down again.
name|doFastScaleDown
argument_list|(
name|fastResult
argument_list|,
name|trailingZeroCount
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|-=
name|trailingZeroCount
expr_stmt|;
block|}
block|}
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected fast check precision scale status "
operator|+
name|status
argument_list|)
throw|;
block|}
return|return
literal|true
return|;
block|}
comment|//************************************************************************************************
comment|// Decimal Addition / Subtraction.
specifier|public
specifier|static
name|boolean
name|doAddSameScaleSameSign
parameter_list|(
name|FastHiveDecimal
name|fastLeft
parameter_list|,
name|FastHiveDecimal
name|fastRight
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
return|return
name|doAddSameScaleSameSign
argument_list|(
comment|/* resultSignum */
name|fastLeft
operator|.
name|fastSignum
argument_list|,
name|fastLeft
operator|.
name|fast0
argument_list|,
name|fastLeft
operator|.
name|fast1
argument_list|,
name|fastLeft
operator|.
name|fast2
argument_list|,
name|fastRight
operator|.
name|fast0
argument_list|,
name|fastRight
operator|.
name|fast1
argument_list|,
name|fastRight
operator|.
name|fast2
argument_list|,
name|fastResult
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|doAddSameScaleSameSign
parameter_list|(
name|int
name|resultSignum
parameter_list|,
name|long
name|left0
parameter_list|,
name|long
name|left1
parameter_list|,
name|long
name|left2
parameter_list|,
name|long
name|right0
parameter_list|,
name|long
name|right1
parameter_list|,
name|long
name|right2
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
name|long
name|result0
decl_stmt|;
name|long
name|result1
decl_stmt|;
name|long
name|result2
decl_stmt|;
specifier|final
name|long
name|r0
init|=
name|left0
operator|+
name|right0
decl_stmt|;
name|result0
operator|=
name|r0
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r1
init|=
name|left1
operator|+
name|right1
operator|+
name|r0
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|result1
operator|=
name|r1
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|result2
operator|=
name|left2
operator|+
name|right2
operator|+
name|r1
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
if|if
condition|(
name|result0
operator|==
literal|0
operator|&&
name|result1
operator|==
literal|0
operator|&&
name|result2
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
name|resultSignum
expr_stmt|;
name|fastResult
operator|.
name|fast0
operator|=
name|result0
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|result1
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|result2
expr_stmt|;
block|}
return|return
operator|(
name|result2
operator|<=
name|MAX_HIGHWORD_DECIMAL
operator|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|doSubtractSameScaleNoUnderflow
parameter_list|(
name|int
name|resultSignum
parameter_list|,
name|FastHiveDecimal
name|fastLeft
parameter_list|,
name|FastHiveDecimal
name|fastRight
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
return|return
name|doSubtractSameScaleNoUnderflow
argument_list|(
name|resultSignum
argument_list|,
name|fastLeft
operator|.
name|fast0
argument_list|,
name|fastLeft
operator|.
name|fast1
argument_list|,
name|fastLeft
operator|.
name|fast2
argument_list|,
name|fastRight
operator|.
name|fast0
argument_list|,
name|fastRight
operator|.
name|fast1
argument_list|,
name|fastRight
operator|.
name|fast2
argument_list|,
name|fastResult
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|doSubtractSameScaleNoUnderflow
parameter_list|(
name|int
name|resultSignum
parameter_list|,
name|long
name|left0
parameter_list|,
name|long
name|left1
parameter_list|,
name|long
name|left2
parameter_list|,
name|long
name|right0
parameter_list|,
name|long
name|right1
parameter_list|,
name|long
name|right2
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
name|long
name|result0
decl_stmt|;
name|long
name|result1
decl_stmt|;
name|long
name|result2
decl_stmt|;
specifier|final
name|long
name|r0
init|=
name|left0
operator|-
name|right0
decl_stmt|;
name|long
name|r1
decl_stmt|;
if|if
condition|(
name|r0
operator|<
literal|0
condition|)
block|{
name|result0
operator|=
name|r0
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r1
operator|=
name|left1
operator|-
name|right1
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result0
operator|=
name|r0
expr_stmt|;
name|r1
operator|=
name|left1
operator|-
name|right1
expr_stmt|;
block|}
if|if
condition|(
name|r1
operator|<
literal|0
condition|)
block|{
name|result1
operator|=
name|r1
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|result2
operator|=
name|left2
operator|-
name|right2
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result1
operator|=
name|r1
expr_stmt|;
name|result2
operator|=
name|left2
operator|-
name|right2
expr_stmt|;
block|}
if|if
condition|(
name|result2
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|result0
operator|==
literal|0
operator|&&
name|result1
operator|==
literal|0
operator|&&
name|result2
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
name|resultSignum
expr_stmt|;
name|fastResult
operator|.
name|fast0
operator|=
name|result0
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|result1
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|result2
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
specifier|static
name|boolean
name|doSubtractSameScaleNoUnderflow
parameter_list|(
name|long
name|left0
parameter_list|,
name|long
name|left1
parameter_list|,
name|long
name|left2
parameter_list|,
name|long
name|right0
parameter_list|,
name|long
name|right1
parameter_list|,
name|long
name|right2
parameter_list|,
name|long
index|[]
name|result
parameter_list|)
block|{
name|long
name|result0
decl_stmt|;
name|long
name|result1
decl_stmt|;
name|long
name|result2
decl_stmt|;
specifier|final
name|long
name|r0
init|=
name|left0
operator|-
name|right0
decl_stmt|;
name|long
name|r1
decl_stmt|;
if|if
condition|(
name|r0
operator|<
literal|0
condition|)
block|{
name|result0
operator|=
name|r0
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r1
operator|=
name|left1
operator|-
name|right1
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result0
operator|=
name|r0
expr_stmt|;
name|r1
operator|=
name|left1
operator|-
name|right1
expr_stmt|;
block|}
if|if
condition|(
name|r1
operator|<
literal|0
condition|)
block|{
name|result1
operator|=
name|r1
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|result2
operator|=
name|left2
operator|-
name|right2
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result1
operator|=
name|r1
expr_stmt|;
name|result2
operator|=
name|left2
operator|-
name|right2
expr_stmt|;
block|}
if|if
condition|(
name|result2
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|result
index|[
literal|0
index|]
operator|=
name|result0
expr_stmt|;
name|result
index|[
literal|1
index|]
operator|=
name|result1
expr_stmt|;
name|result
index|[
literal|2
index|]
operator|=
name|result2
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
specifier|static
name|boolean
name|doAddSameScale
parameter_list|(
name|int
name|leftSignum
parameter_list|,
name|long
name|leftFast0
parameter_list|,
name|long
name|leftFast1
parameter_list|,
name|long
name|leftFast2
parameter_list|,
name|int
name|rightSignum
parameter_list|,
name|long
name|rightFast0
parameter_list|,
name|long
name|rightFast1
parameter_list|,
name|long
name|rightFast2
parameter_list|,
name|int
name|scale
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
if|if
condition|(
name|leftSignum
operator|==
name|rightSignum
condition|)
block|{
if|if
condition|(
operator|!
name|doAddSameScaleSameSign
argument_list|(
comment|/* resultSignum */
name|leftSignum
argument_list|,
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
name|rightFast0
argument_list|,
name|rightFast1
argument_list|,
name|rightFast2
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
comment|// Handle overflow precision issue.
if|if
condition|(
name|scale
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fastRoundFractionalHalfUp
argument_list|(
name|fastResult
operator|.
name|fastSignum
argument_list|,
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
literal|1
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|scale
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|// Overflow.
return|return
literal|false
return|;
block|}
block|}
name|fastResult
operator|.
name|fastScale
operator|=
name|scale
expr_stmt|;
block|}
else|else
block|{
comment|// Just compare the magnitudes (i.e. signums set to 1).
name|int
name|compareTo
init|=
name|fastCompareTo
argument_list|(
literal|1
argument_list|,
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|rightFast0
argument_list|,
name|rightFast1
argument_list|,
name|rightFast2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|compareTo
operator|==
literal|0
condition|)
block|{
comment|// They cancel each other.
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|compareTo
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|doSubtractSameScaleNoUnderflow
argument_list|(
comment|/* resultSignum */
name|leftSignum
argument_list|,
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
name|rightFast0
argument_list|,
name|rightFast1
argument_list|,
name|rightFast2
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected underflow"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|doSubtractSameScaleNoUnderflow
argument_list|(
comment|/* resultSignum */
name|rightSignum
argument_list|,
name|rightFast0
argument_list|,
name|rightFast1
argument_list|,
name|rightFast2
argument_list|,
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected underflow"
argument_list|)
throw|;
block|}
block|}
name|fastResult
operator|.
name|fastScale
operator|=
name|scale
expr_stmt|;
block|}
if|if
condition|(
name|fastResult
operator|.
name|fastSignum
operator|!=
literal|0
condition|)
block|{
specifier|final
name|int
name|precision
init|=
name|fastRawPrecision
argument_list|(
name|fastResult
argument_list|)
decl_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|precision
operator|-
name|fastResult
operator|.
name|fastScale
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|resultTrailingZeroCount
init|=
name|fastTrailingDecimalZeroCount
argument_list|(
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
name|fastResult
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastResult
operator|.
name|fastScale
argument_list|)
decl_stmt|;
if|if
condition|(
name|resultTrailingZeroCount
operator|>
literal|0
condition|)
block|{
name|doFastScaleDown
argument_list|(
name|fastResult
argument_list|,
name|resultTrailingZeroCount
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|fastResult
operator|.
name|fastSignum
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastScale
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastScale
operator|-=
name|resultTrailingZeroCount
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Handle the common logic at the end of fastAddDifferentScale / fastSubtractDifferentScale that    * takes the 5 intermediate result words and fits them into the 3 longword fast result.    *    */
specifier|private
specifier|static
name|boolean
name|doFinishAddSubtractDifferentScale
parameter_list|(
name|long
name|result0
parameter_list|,
name|long
name|result1
parameter_list|,
name|long
name|result2
parameter_list|,
name|long
name|result3
parameter_list|,
name|long
name|result4
parameter_list|,
name|int
name|resultScale
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
name|int
name|precision
decl_stmt|;
if|if
condition|(
name|result4
operator|!=
literal|0
condition|)
block|{
name|precision
operator|=
name|FOUR_X_LONGWORD_DECIMAL_DIGITS
operator|+
name|fastLongWordPrecision
argument_list|(
name|result4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result3
operator|!=
literal|0
condition|)
block|{
name|precision
operator|=
name|THREE_X_LONGWORD_DECIMAL_DIGITS
operator|+
name|fastLongWordPrecision
argument_list|(
name|result3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result2
operator|!=
literal|0
condition|)
block|{
name|precision
operator|=
name|TWO_X_LONGWORD_DECIMAL_DIGITS
operator|+
name|fastLongWordPrecision
argument_list|(
name|result2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result1
operator|!=
literal|0
condition|)
block|{
name|precision
operator|=
name|LONGWORD_DECIMAL_DIGITS
operator|+
name|fastLongWordPrecision
argument_list|(
name|result1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|precision
operator|=
name|fastLongWordPrecision
argument_list|(
name|result0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|precision
operator|>
name|HiveDecimal
operator|.
name|MAX_PRECISION
condition|)
block|{
specifier|final
name|int
name|scaleDown
init|=
name|precision
operator|-
name|HiveDecimal
operator|.
name|MAX_PRECISION
decl_stmt|;
name|resultScale
operator|-=
name|scaleDown
expr_stmt|;
if|if
condition|(
name|resultScale
operator|<
literal|0
condition|)
block|{
comment|// No room.
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|fastRoundFractionalHalfUp5Words
argument_list|(
literal|1
argument_list|,
name|result0
argument_list|,
name|result1
argument_list|,
name|result2
argument_list|,
name|result3
argument_list|,
name|result4
argument_list|,
name|scaleDown
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
comment|// Handle overflow precision issue.
if|if
condition|(
name|resultScale
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fastRoundFractionalHalfUp
argument_list|(
name|fastResult
operator|.
name|fastSignum
argument_list|,
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
literal|1
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected overflow"
argument_list|)
throw|;
block|}
if|if
condition|(
name|fastResult
operator|.
name|fastSignum
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
name|resultScale
operator|--
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
name|precision
operator|=
name|fastRawPrecision
argument_list|(
literal|1
argument_list|,
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|)
expr_stmt|;
comment|// Stick back into result variables...
name|result0
operator|=
name|fastResult
operator|.
name|fast0
expr_stmt|;
name|result1
operator|=
name|fastResult
operator|.
name|fast1
expr_stmt|;
name|result2
operator|=
name|fastResult
operator|.
name|fast2
expr_stmt|;
block|}
comment|// Caller will set signum.
name|fastResult
operator|.
name|fastSignum
operator|=
literal|1
expr_stmt|;
name|fastResult
operator|.
name|fast0
operator|=
name|result0
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|result1
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|result2
expr_stmt|;
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|precision
operator|-
name|resultScale
argument_list|)
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
name|resultScale
expr_stmt|;
specifier|final
name|int
name|resultTrailingZeroCount
init|=
name|fastTrailingDecimalZeroCount
argument_list|(
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
name|fastResult
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastResult
operator|.
name|fastScale
argument_list|)
decl_stmt|;
if|if
condition|(
name|resultTrailingZeroCount
operator|>
literal|0
condition|)
block|{
name|doFastScaleDown
argument_list|(
name|fastResult
argument_list|,
name|resultTrailingZeroCount
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|fastResult
operator|.
name|fastSignum
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastScale
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastScale
operator|-=
name|resultTrailingZeroCount
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Handle decimal subtraction when the values have different scales.    */
specifier|private
specifier|static
name|boolean
name|fastSubtractDifferentScale
parameter_list|(
name|long
name|leftFast0
parameter_list|,
name|long
name|leftFast1
parameter_list|,
name|long
name|leftFast2
parameter_list|,
name|int
name|leftIntegerDigitCount
parameter_list|,
name|int
name|leftScale
parameter_list|,
name|long
name|rightFast0
parameter_list|,
name|long
name|rightFast1
parameter_list|,
name|long
name|rightFast2
parameter_list|,
name|int
name|rightIntegerDigitCount
parameter_list|,
name|int
name|rightScale
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
name|int
name|diffScale
decl_stmt|;
name|int
name|resultScale
decl_stmt|;
name|long
name|result0
init|=
literal|0
decl_stmt|;
name|long
name|result1
init|=
literal|0
decl_stmt|;
name|long
name|result2
init|=
literal|0
decl_stmt|;
name|long
name|result3
init|=
literal|0
decl_stmt|;
name|long
name|result4
init|=
literal|0
decl_stmt|;
comment|// Since subtraction is not commutative, we can must subtract in the order passed in.
if|if
condition|(
name|leftScale
operator|>
name|rightScale
condition|)
block|{
comment|// Since left has a longer digit tail and it doesn't move; we will shift the right digits
comment|// as we do our addition into the result.
name|diffScale
operator|=
name|leftScale
operator|-
name|rightScale
expr_stmt|;
name|resultScale
operator|=
name|leftScale
expr_stmt|;
if|if
condition|(
name|diffScale
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|diffScale
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|diffScale
index|]
decl_stmt|;
specifier|final
name|long
name|r0
init|=
name|leftFast0
operator|-
operator|(
name|rightFast0
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
decl_stmt|;
name|long
name|r1
decl_stmt|;
if|if
condition|(
name|r0
operator|<
literal|0
condition|)
block|{
name|result0
operator|=
name|r0
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r1
operator|=
name|leftFast1
operator|-
name|rightFast0
operator|/
name|divideFactor
operator|-
operator|(
name|rightFast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result0
operator|=
name|r0
expr_stmt|;
name|r1
operator|=
name|leftFast1
operator|-
name|rightFast0
operator|/
name|divideFactor
operator|-
operator|(
name|rightFast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
expr_stmt|;
block|}
name|long
name|r2
decl_stmt|;
if|if
condition|(
name|r1
operator|<
literal|0
condition|)
block|{
name|result1
operator|=
name|r1
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r2
operator|=
name|leftFast2
operator|-
name|rightFast1
operator|/
name|divideFactor
operator|-
operator|(
name|rightFast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result1
operator|=
name|r1
expr_stmt|;
name|r2
operator|=
name|leftFast2
operator|-
name|rightFast1
operator|/
name|divideFactor
operator|-
operator|(
name|rightFast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
expr_stmt|;
block|}
name|long
name|r3
decl_stmt|;
if|if
condition|(
name|r2
operator|<
literal|0
condition|)
block|{
name|result2
operator|=
name|r2
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r3
operator|=
operator|-
operator|(
name|rightFast2
operator|/
name|divideFactor
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result2
operator|=
name|r2
expr_stmt|;
name|r3
operator|=
operator|-
operator|(
name|rightFast2
operator|/
name|divideFactor
operator|)
expr_stmt|;
block|}
name|long
name|r4
decl_stmt|;
if|if
condition|(
name|r3
operator|<
literal|0
condition|)
block|{
name|result3
operator|=
name|r3
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r4
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result3
operator|=
name|r3
expr_stmt|;
name|r4
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|r4
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected underflow"
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|diffScale
operator|==
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
name|result0
operator|=
name|leftFast0
expr_stmt|;
specifier|final
name|long
name|r1
init|=
name|leftFast1
operator|-
name|rightFast0
decl_stmt|;
name|long
name|r2
decl_stmt|;
if|if
condition|(
name|r1
operator|<
literal|0
condition|)
block|{
name|result1
operator|=
name|r1
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r2
operator|=
name|leftFast2
operator|-
name|rightFast1
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result1
operator|=
name|r1
expr_stmt|;
name|r2
operator|=
name|leftFast2
operator|-
name|rightFast1
expr_stmt|;
block|}
name|long
name|r3
decl_stmt|;
if|if
condition|(
name|r2
operator|<
literal|0
condition|)
block|{
name|result2
operator|=
name|r2
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r3
operator|=
operator|-
name|rightFast2
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result2
operator|=
name|r2
expr_stmt|;
name|r3
operator|=
operator|-
name|rightFast2
expr_stmt|;
block|}
if|if
condition|(
name|r3
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected underflow"
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|diffScale
operator|<
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|TWO_X_LONGWORD_DECIMAL_DIGITS
operator|-
name|diffScale
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|diffScale
operator|-
name|LONGWORD_DECIMAL_DIGITS
index|]
decl_stmt|;
name|result0
operator|=
name|leftFast0
expr_stmt|;
specifier|final
name|long
name|r1
init|=
name|leftFast1
operator|-
operator|(
name|rightFast0
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
decl_stmt|;
name|long
name|r2
decl_stmt|;
if|if
condition|(
name|r1
operator|<
literal|0
condition|)
block|{
name|result1
operator|=
name|r1
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r2
operator|=
name|leftFast2
operator|-
name|rightFast0
operator|/
name|divideFactor
operator|-
operator|(
name|rightFast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result1
operator|=
name|r1
expr_stmt|;
name|r2
operator|=
name|leftFast2
operator|-
name|rightFast0
operator|/
name|divideFactor
operator|-
operator|(
name|rightFast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
expr_stmt|;
block|}
name|long
name|r3
decl_stmt|;
if|if
condition|(
name|r2
operator|<
literal|0
condition|)
block|{
name|result2
operator|=
name|r2
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r3
operator|=
operator|-
name|rightFast1
operator|/
name|divideFactor
operator|-
operator|(
name|rightFast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result2
operator|=
name|r2
expr_stmt|;
name|r3
operator|=
operator|-
name|rightFast1
operator|/
name|divideFactor
operator|-
operator|(
name|rightFast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
expr_stmt|;
block|}
name|long
name|r4
decl_stmt|;
if|if
condition|(
name|r3
operator|<
literal|0
condition|)
block|{
name|result3
operator|=
name|r3
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r4
operator|=
operator|-
name|rightFast2
operator|/
name|divideFactor
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result3
operator|=
name|r3
expr_stmt|;
name|r4
operator|=
operator|-
name|rightFast2
operator|/
name|divideFactor
expr_stmt|;
block|}
name|long
name|r5
decl_stmt|;
if|if
condition|(
name|r4
operator|<
literal|0
condition|)
block|{
name|result4
operator|=
name|r4
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r5
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result4
operator|=
name|r4
expr_stmt|;
name|r5
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|r5
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected underflow"
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|diffScale
operator|==
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
name|result0
operator|=
name|leftFast0
expr_stmt|;
name|result1
operator|=
name|leftFast1
expr_stmt|;
specifier|final
name|long
name|r2
init|=
name|leftFast2
operator|-
name|rightFast0
decl_stmt|;
name|long
name|r3
decl_stmt|;
if|if
condition|(
name|r2
operator|<
literal|0
condition|)
block|{
name|result2
operator|=
name|r2
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r3
operator|=
operator|-
name|rightFast1
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result2
operator|=
name|r2
expr_stmt|;
name|r3
operator|=
operator|-
name|rightFast1
expr_stmt|;
block|}
name|long
name|r4
decl_stmt|;
if|if
condition|(
name|r3
operator|<
literal|0
condition|)
block|{
name|result3
operator|=
name|r3
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r4
operator|=
operator|-
name|rightFast2
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result3
operator|=
name|r3
expr_stmt|;
name|r4
operator|=
operator|-
name|rightFast2
expr_stmt|;
block|}
name|long
name|r5
decl_stmt|;
if|if
condition|(
name|r4
operator|<
literal|0
condition|)
block|{
name|result4
operator|=
name|r4
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r5
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result4
operator|=
name|r4
expr_stmt|;
name|r5
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|r5
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected underflow"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|THREE_X_LONGWORD_DECIMAL_DIGITS
operator|-
name|diffScale
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|diffScale
operator|-
name|TWO_X_LONGWORD_DECIMAL_DIGITS
index|]
decl_stmt|;
name|result0
operator|=
name|leftFast0
expr_stmt|;
name|result1
operator|=
name|leftFast1
expr_stmt|;
specifier|final
name|long
name|r2
init|=
name|leftFast2
operator|-
operator|(
name|rightFast0
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
decl_stmt|;
name|long
name|r3
decl_stmt|;
if|if
condition|(
name|r2
operator|<
literal|0
condition|)
block|{
name|result2
operator|=
name|r2
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r3
operator|=
operator|-
operator|(
name|rightFast0
operator|/
name|divideFactor
operator|)
operator|-
operator|(
name|rightFast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result2
operator|=
name|r2
expr_stmt|;
name|r3
operator|=
operator|-
operator|(
name|rightFast0
operator|/
name|divideFactor
operator|)
operator|-
operator|(
name|rightFast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
expr_stmt|;
block|}
name|long
name|r4
decl_stmt|;
if|if
condition|(
name|r3
operator|<
literal|0
condition|)
block|{
name|result3
operator|=
name|r3
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r4
operator|=
operator|-
operator|(
name|rightFast1
operator|/
name|divideFactor
operator|)
operator|-
operator|(
name|rightFast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result3
operator|=
name|r3
expr_stmt|;
name|r4
operator|=
operator|-
operator|(
name|rightFast1
operator|/
name|divideFactor
operator|)
operator|-
operator|(
name|rightFast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
expr_stmt|;
block|}
name|long
name|r5
decl_stmt|;
if|if
condition|(
name|r4
operator|<
literal|0
condition|)
block|{
name|result4
operator|=
name|r4
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r5
operator|=
operator|-
operator|(
name|rightFast2
operator|/
name|divideFactor
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result4
operator|=
name|r4
expr_stmt|;
name|r5
operator|=
operator|-
operator|(
name|rightFast2
operator|/
name|divideFactor
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|r5
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected underflow"
argument_list|)
throw|;
block|}
block|}
block|}
else|else
block|{
comment|// Since right has a longer digit tail and it doesn't move; we will shift the left digits
comment|// as we do our addition into the result.
name|diffScale
operator|=
name|rightScale
operator|-
name|leftScale
expr_stmt|;
name|resultScale
operator|=
name|rightScale
expr_stmt|;
if|if
condition|(
name|diffScale
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|diffScale
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|diffScale
index|]
decl_stmt|;
specifier|final
name|long
name|r0
init|=
operator|(
name|leftFast0
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|-
name|rightFast0
decl_stmt|;
name|long
name|r1
decl_stmt|;
if|if
condition|(
name|r0
operator|<
literal|0
condition|)
block|{
name|result0
operator|=
name|r0
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r1
operator|=
name|leftFast0
operator|/
name|divideFactor
operator|+
operator|(
name|leftFast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|-
name|rightFast1
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result0
operator|=
name|r0
expr_stmt|;
name|r1
operator|=
name|leftFast0
operator|/
name|divideFactor
operator|+
operator|(
name|leftFast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|-
name|rightFast1
expr_stmt|;
block|}
name|long
name|r2
decl_stmt|;
if|if
condition|(
name|r1
operator|<
literal|0
condition|)
block|{
name|result1
operator|=
name|r1
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r2
operator|=
name|leftFast1
operator|/
name|divideFactor
operator|+
operator|(
name|leftFast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|-
name|rightFast2
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result1
operator|=
name|r1
expr_stmt|;
name|r2
operator|=
name|leftFast1
operator|/
name|divideFactor
operator|+
operator|(
name|leftFast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|-
name|rightFast2
expr_stmt|;
block|}
name|long
name|r3
decl_stmt|;
if|if
condition|(
name|r2
operator|<
literal|0
condition|)
block|{
name|result2
operator|=
name|r2
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r3
operator|=
name|leftFast2
operator|/
name|divideFactor
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result2
operator|=
name|r2
expr_stmt|;
name|r3
operator|=
name|leftFast2
operator|/
name|divideFactor
expr_stmt|;
block|}
name|long
name|r4
decl_stmt|;
if|if
condition|(
name|r3
operator|<
literal|0
condition|)
block|{
name|result3
operator|=
name|r3
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r4
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result3
operator|=
name|r3
expr_stmt|;
name|r4
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|r4
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected underflow"
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|diffScale
operator|==
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
specifier|final
name|long
name|r0
init|=
operator|-
name|rightFast0
decl_stmt|;
name|long
name|r1
decl_stmt|;
if|if
condition|(
name|r0
operator|<
literal|0
condition|)
block|{
name|result0
operator|=
name|r0
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r1
operator|=
name|leftFast0
operator|-
name|rightFast1
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result0
operator|=
name|r0
expr_stmt|;
name|r1
operator|=
name|leftFast0
operator|-
name|rightFast1
expr_stmt|;
block|}
name|long
name|r2
decl_stmt|;
if|if
condition|(
name|r1
operator|<
literal|0
condition|)
block|{
name|result1
operator|=
name|r1
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r2
operator|=
name|leftFast1
operator|-
name|rightFast2
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result1
operator|=
name|r1
expr_stmt|;
name|r2
operator|=
name|leftFast1
operator|-
name|rightFast2
expr_stmt|;
block|}
name|long
name|r3
decl_stmt|;
if|if
condition|(
name|r2
operator|<
literal|0
condition|)
block|{
name|result2
operator|=
name|r2
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r3
operator|=
name|leftFast2
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result2
operator|=
name|r2
expr_stmt|;
name|r3
operator|=
name|leftFast2
expr_stmt|;
block|}
name|long
name|r4
decl_stmt|;
if|if
condition|(
name|r3
operator|<
literal|0
condition|)
block|{
name|result3
operator|=
name|r3
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r4
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result3
operator|=
name|r3
expr_stmt|;
name|r4
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|r4
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected underflow"
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|diffScale
operator|<
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|TWO_X_LONGWORD_DECIMAL_DIGITS
operator|-
name|diffScale
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|diffScale
operator|-
name|LONGWORD_DECIMAL_DIGITS
index|]
decl_stmt|;
specifier|final
name|long
name|r0
init|=
operator|-
name|rightFast0
decl_stmt|;
name|long
name|r1
decl_stmt|;
if|if
condition|(
name|r0
operator|<
literal|0
condition|)
block|{
name|result0
operator|=
name|r0
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r1
operator|=
operator|(
name|leftFast0
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|-
name|rightFast1
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result0
operator|=
name|r0
expr_stmt|;
name|r1
operator|=
operator|(
name|leftFast0
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|-
name|rightFast1
expr_stmt|;
block|}
name|long
name|r2
decl_stmt|;
if|if
condition|(
name|r1
operator|<
literal|0
condition|)
block|{
name|result1
operator|=
name|r1
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r2
operator|=
name|leftFast0
operator|/
name|divideFactor
operator|+
operator|(
name|leftFast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|-
name|rightFast2
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result1
operator|=
name|r1
expr_stmt|;
name|r2
operator|=
name|leftFast0
operator|/
name|divideFactor
operator|+
operator|(
name|leftFast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|-
name|rightFast2
expr_stmt|;
block|}
name|long
name|r3
decl_stmt|;
if|if
condition|(
name|r2
operator|<
literal|0
condition|)
block|{
name|result2
operator|=
name|r2
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r3
operator|=
name|leftFast1
operator|/
name|divideFactor
operator|+
operator|(
name|leftFast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result2
operator|=
name|r2
expr_stmt|;
name|r3
operator|=
name|leftFast1
operator|/
name|divideFactor
operator|+
operator|(
name|leftFast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
expr_stmt|;
block|}
name|long
name|r4
decl_stmt|;
if|if
condition|(
name|r3
operator|<
literal|0
condition|)
block|{
name|result3
operator|=
name|r3
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r4
operator|=
name|leftFast2
operator|/
name|divideFactor
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result3
operator|=
name|r3
expr_stmt|;
name|r4
operator|=
name|leftFast2
operator|/
name|divideFactor
expr_stmt|;
block|}
if|if
condition|(
name|r4
operator|<
literal|0
condition|)
block|{
name|result4
operator|=
name|r4
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
block|}
else|else
block|{
name|result4
operator|=
name|r4
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|diffScale
operator|==
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
specifier|final
name|long
name|r0
init|=
operator|-
name|rightFast0
decl_stmt|;
name|long
name|r1
decl_stmt|;
if|if
condition|(
name|r0
operator|<
literal|0
condition|)
block|{
name|result0
operator|=
name|r0
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r1
operator|=
operator|-
name|rightFast1
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result0
operator|=
name|r0
expr_stmt|;
name|r1
operator|=
operator|-
name|rightFast1
expr_stmt|;
block|}
name|long
name|r2
decl_stmt|;
if|if
condition|(
name|r1
operator|<
literal|0
condition|)
block|{
name|result1
operator|=
name|r1
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r2
operator|=
name|leftFast0
operator|-
name|rightFast2
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result1
operator|=
name|r1
expr_stmt|;
name|r2
operator|=
name|leftFast0
operator|-
name|rightFast2
expr_stmt|;
block|}
name|long
name|r3
decl_stmt|;
if|if
condition|(
name|r2
operator|<
literal|0
condition|)
block|{
name|result2
operator|=
name|r2
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r3
operator|=
name|leftFast1
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result2
operator|=
name|r2
expr_stmt|;
name|r3
operator|=
name|leftFast1
expr_stmt|;
block|}
name|long
name|r4
decl_stmt|;
if|if
condition|(
name|r3
operator|<
literal|0
condition|)
block|{
name|result3
operator|=
name|r3
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r4
operator|=
name|leftFast2
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result3
operator|=
name|r3
expr_stmt|;
name|r4
operator|=
name|leftFast2
expr_stmt|;
block|}
name|long
name|r5
decl_stmt|;
if|if
condition|(
name|r4
operator|<
literal|0
condition|)
block|{
name|result4
operator|=
name|r4
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r5
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result4
operator|=
name|r4
expr_stmt|;
name|r5
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|r5
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected underflow"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|THREE_X_LONGWORD_DECIMAL_DIGITS
operator|-
name|diffScale
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|diffScale
operator|-
name|TWO_X_LONGWORD_DECIMAL_DIGITS
index|]
decl_stmt|;
specifier|final
name|long
name|r0
init|=
operator|-
name|rightFast0
decl_stmt|;
name|long
name|r1
decl_stmt|;
if|if
condition|(
name|r0
operator|<
literal|0
condition|)
block|{
name|result0
operator|=
name|r0
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r1
operator|=
operator|-
name|rightFast1
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result0
operator|=
name|r0
expr_stmt|;
name|r1
operator|=
operator|-
name|rightFast1
expr_stmt|;
block|}
name|long
name|r2
decl_stmt|;
if|if
condition|(
name|r1
operator|<
literal|0
condition|)
block|{
name|result1
operator|=
name|r1
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r2
operator|=
operator|(
name|leftFast0
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|-
name|rightFast2
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result1
operator|=
name|r1
expr_stmt|;
name|r2
operator|=
operator|(
name|leftFast0
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|-
name|rightFast2
expr_stmt|;
block|}
name|long
name|r3
decl_stmt|;
if|if
condition|(
name|r2
operator|<
literal|0
condition|)
block|{
name|result2
operator|=
name|r2
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r3
operator|=
name|leftFast0
operator|/
name|divideFactor
operator|+
operator|(
name|leftFast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result2
operator|=
name|r2
expr_stmt|;
name|r3
operator|=
name|leftFast0
operator|/
name|divideFactor
operator|+
operator|(
name|leftFast1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
expr_stmt|;
block|}
name|long
name|r4
decl_stmt|;
if|if
condition|(
name|r3
operator|<
literal|0
condition|)
block|{
name|result3
operator|=
name|r3
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r4
operator|=
name|leftFast1
operator|/
name|divideFactor
operator|+
operator|(
name|leftFast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result3
operator|=
name|r3
expr_stmt|;
name|r4
operator|=
name|leftFast1
operator|/
name|divideFactor
operator|+
operator|(
name|leftFast2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
expr_stmt|;
block|}
name|long
name|r5
decl_stmt|;
if|if
condition|(
name|r4
operator|<
literal|0
condition|)
block|{
name|result4
operator|=
name|r4
operator|+
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|r5
operator|=
name|leftFast2
operator|/
name|divideFactor
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result4
operator|=
name|r4
expr_stmt|;
name|r5
operator|=
name|leftFast2
operator|/
name|divideFactor
expr_stmt|;
block|}
if|if
condition|(
name|r5
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected underflow"
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|doFinishAddSubtractDifferentScale
argument_list|(
name|result0
argument_list|,
name|result1
argument_list|,
name|result2
argument_list|,
name|result3
argument_list|,
name|result4
argument_list|,
name|resultScale
argument_list|,
name|fastResult
argument_list|)
return|;
block|}
comment|/**    * Handle decimal addition when the values have different scales.    */
specifier|private
specifier|static
name|boolean
name|fastAddDifferentScale
parameter_list|(
name|long
name|leftFast0
parameter_list|,
name|long
name|leftFast1
parameter_list|,
name|long
name|leftFast2
parameter_list|,
name|int
name|leftIntegerDigitCount
parameter_list|,
name|int
name|leftScale
parameter_list|,
name|long
name|rightFast0
parameter_list|,
name|long
name|rightFast1
parameter_list|,
name|long
name|rightFast2
parameter_list|,
name|int
name|rightIntegerDigitCount
parameter_list|,
name|int
name|rightScale
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
comment|// Arrange so result* has a longer digit tail and it lines up; we will shift the shift* digits
comment|// as we do our addition and them into the result.
name|long
name|result0
decl_stmt|;
name|long
name|result1
decl_stmt|;
name|long
name|result2
decl_stmt|;
name|long
name|shift0
decl_stmt|;
name|long
name|shift1
decl_stmt|;
name|long
name|shift2
decl_stmt|;
name|int
name|diffScale
decl_stmt|;
name|int
name|resultScale
decl_stmt|;
comment|// Since addition is commutative, we can add in any order.
if|if
condition|(
name|leftScale
operator|>
name|rightScale
condition|)
block|{
name|result0
operator|=
name|leftFast0
expr_stmt|;
name|result1
operator|=
name|leftFast1
expr_stmt|;
name|result2
operator|=
name|leftFast2
expr_stmt|;
name|shift0
operator|=
name|rightFast0
expr_stmt|;
name|shift1
operator|=
name|rightFast1
expr_stmt|;
name|shift2
operator|=
name|rightFast2
expr_stmt|;
name|diffScale
operator|=
name|leftScale
operator|-
name|rightScale
expr_stmt|;
name|resultScale
operator|=
name|leftScale
expr_stmt|;
block|}
else|else
block|{
name|result0
operator|=
name|rightFast0
expr_stmt|;
name|result1
operator|=
name|rightFast1
expr_stmt|;
name|result2
operator|=
name|rightFast2
expr_stmt|;
name|shift0
operator|=
name|leftFast0
expr_stmt|;
name|shift1
operator|=
name|leftFast1
expr_stmt|;
name|shift2
operator|=
name|leftFast2
expr_stmt|;
name|diffScale
operator|=
name|rightScale
operator|-
name|leftScale
expr_stmt|;
name|resultScale
operator|=
name|rightScale
expr_stmt|;
block|}
name|long
name|result3
init|=
literal|0
decl_stmt|;
name|long
name|result4
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|diffScale
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|diffScale
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|diffScale
index|]
decl_stmt|;
specifier|final
name|long
name|r0
init|=
name|result0
operator|+
operator|(
name|shift0
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
decl_stmt|;
name|result0
operator|=
name|r0
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r1
init|=
name|result1
operator|+
name|shift0
operator|/
name|divideFactor
operator|+
operator|(
name|shift1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|+
name|r0
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|result1
operator|=
name|r1
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r2
init|=
name|result2
operator|+
name|shift1
operator|/
name|divideFactor
operator|+
operator|(
name|shift2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|+
name|r1
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|result2
operator|=
name|r2
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r3
init|=
name|shift2
operator|/
name|divideFactor
operator|+
name|r2
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|result3
operator|=
name|r3
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diffScale
operator|==
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
specifier|final
name|long
name|r1
init|=
name|result1
operator|+
name|shift0
decl_stmt|;
name|result1
operator|=
name|r1
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r2
init|=
name|result2
operator|+
name|shift1
operator|+
name|r1
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|result2
operator|=
name|r2
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r3
init|=
name|shift2
operator|+
name|r2
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|result3
operator|=
name|r3
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|result4
operator|=
name|r3
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diffScale
operator|<
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|TWO_X_LONGWORD_DECIMAL_DIGITS
operator|-
name|diffScale
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|diffScale
operator|-
name|LONGWORD_DECIMAL_DIGITS
index|]
decl_stmt|;
specifier|final
name|long
name|r1
init|=
name|result1
operator|+
operator|(
name|shift0
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
decl_stmt|;
name|result1
operator|=
name|r1
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r2
init|=
name|result2
operator|+
name|shift0
operator|/
name|divideFactor
operator|+
operator|(
name|shift1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|+
name|r1
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|result2
operator|=
name|r2
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r3
init|=
name|shift1
operator|/
name|divideFactor
operator|+
operator|(
name|shift2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|+
name|r2
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|result3
operator|=
name|r3
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r4
init|=
name|shift2
operator|/
name|divideFactor
operator|+
name|r3
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|result4
operator|=
name|r4
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diffScale
operator|==
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
specifier|final
name|long
name|r2
init|=
name|result2
operator|+
name|shift0
decl_stmt|;
name|result2
operator|=
name|r2
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r3
init|=
name|shift1
operator|+
name|r2
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|result3
operator|=
name|r3
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r4
init|=
name|shift2
operator|+
name|r3
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|result4
operator|=
name|r4
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|long
name|divideFactor
init|=
name|powerOfTenTable
index|[
name|THREE_X_LONGWORD_DECIMAL_DIGITS
operator|-
name|diffScale
index|]
decl_stmt|;
specifier|final
name|long
name|multiplyFactor
init|=
name|powerOfTenTable
index|[
name|diffScale
operator|-
name|TWO_X_LONGWORD_DECIMAL_DIGITS
index|]
decl_stmt|;
specifier|final
name|long
name|r2
init|=
name|result2
operator|+
operator|(
name|shift0
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
decl_stmt|;
name|result2
operator|=
name|r2
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r3
init|=
name|shift0
operator|/
name|divideFactor
operator|+
operator|(
name|shift1
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|+
name|r2
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|result3
operator|=
name|r3
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
specifier|final
name|long
name|r4
init|=
name|shift1
operator|/
name|divideFactor
operator|+
operator|(
name|shift2
operator|%
name|divideFactor
operator|)
operator|*
name|multiplyFactor
operator|+
name|r3
operator|/
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|result4
operator|=
name|r4
operator|%
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
if|if
condition|(
name|shift2
operator|/
name|divideFactor
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected overflow"
argument_list|)
throw|;
block|}
block|}
return|return
name|doFinishAddSubtractDifferentScale
argument_list|(
name|result0
argument_list|,
name|result1
argument_list|,
name|result2
argument_list|,
name|result3
argument_list|,
name|result4
argument_list|,
name|resultScale
argument_list|,
name|fastResult
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|boolean
name|doAddDifferentScale
parameter_list|(
name|int
name|leftSignum
parameter_list|,
name|long
name|leftFast0
parameter_list|,
name|long
name|leftFast1
parameter_list|,
name|long
name|leftFast2
parameter_list|,
name|int
name|leftIntegerDigitCount
parameter_list|,
name|int
name|leftScale
parameter_list|,
name|int
name|rightSignum
parameter_list|,
name|long
name|rightFast0
parameter_list|,
name|long
name|rightFast1
parameter_list|,
name|long
name|rightFast2
parameter_list|,
name|int
name|rightIntegerDigitCount
parameter_list|,
name|int
name|rightScale
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
if|if
condition|(
name|leftSignum
operator|==
name|rightSignum
condition|)
block|{
if|if
condition|(
operator|!
name|fastAddDifferentScale
argument_list|(
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
name|leftIntegerDigitCount
argument_list|,
name|leftScale
argument_list|,
name|rightFast0
argument_list|,
name|rightFast1
argument_list|,
name|rightFast2
argument_list|,
name|rightIntegerDigitCount
argument_list|,
name|rightScale
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Sign stays the same.
name|fastResult
operator|.
name|fastSignum
operator|=
name|leftSignum
expr_stmt|;
block|}
else|else
block|{
comment|// Just compare the magnitudes (i.e. signums set to 1).
name|int
name|compareTo
init|=
name|fastCompareTo
argument_list|(
literal|1
argument_list|,
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
name|leftScale
argument_list|,
literal|1
argument_list|,
name|rightFast0
argument_list|,
name|rightFast1
argument_list|,
name|rightFast2
argument_list|,
name|rightScale
argument_list|)
decl_stmt|;
if|if
condition|(
name|compareTo
operator|==
literal|0
condition|)
block|{
comment|// They cancel each other.
name|fastResult
operator|.
name|fastSignum
operator|=
literal|0
expr_stmt|;
name|fastResult
operator|.
name|fast0
operator|=
literal|0
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
literal|0
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
literal|0
expr_stmt|;
name|fastResult
operator|.
name|fastScale
operator|=
literal|0
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|compareTo
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|fastSubtractDifferentScale
argument_list|(
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
name|leftIntegerDigitCount
argument_list|,
name|leftScale
argument_list|,
name|rightFast0
argument_list|,
name|rightFast1
argument_list|,
name|rightFast2
argument_list|,
name|rightIntegerDigitCount
argument_list|,
name|rightScale
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected overflow"
argument_list|)
throw|;
block|}
name|fastResult
operator|.
name|fastSignum
operator|=
name|leftSignum
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|fastSubtractDifferentScale
argument_list|(
name|rightFast0
argument_list|,
name|rightFast1
argument_list|,
name|rightFast2
argument_list|,
name|rightIntegerDigitCount
argument_list|,
name|rightScale
argument_list|,
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
name|leftIntegerDigitCount
argument_list|,
name|leftScale
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected overflow"
argument_list|)
throw|;
block|}
name|fastResult
operator|.
name|fastSignum
operator|=
name|rightSignum
expr_stmt|;
block|}
block|}
specifier|final
name|int
name|resultTrailingZeroCount
init|=
name|fastTrailingDecimalZeroCount
argument_list|(
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
name|fastResult
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastResult
operator|.
name|fastScale
argument_list|)
decl_stmt|;
if|if
condition|(
name|resultTrailingZeroCount
operator|>
literal|0
condition|)
block|{
name|doFastScaleDown
argument_list|(
name|fastResult
argument_list|,
name|resultTrailingZeroCount
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|fastResult
operator|.
name|fastSignum
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastScale
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastScale
operator|-=
name|resultTrailingZeroCount
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|public
specifier|static
name|boolean
name|fastAdd
parameter_list|(
name|FastHiveDecimal
name|fastLeft
parameter_list|,
name|FastHiveDecimal
name|fastRight
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
return|return
name|fastAdd
argument_list|(
name|fastLeft
operator|.
name|fastSignum
argument_list|,
name|fastLeft
operator|.
name|fast0
argument_list|,
name|fastLeft
operator|.
name|fast1
argument_list|,
name|fastLeft
operator|.
name|fast2
argument_list|,
name|fastLeft
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastLeft
operator|.
name|fastScale
argument_list|,
name|fastRight
operator|.
name|fastSignum
argument_list|,
name|fastRight
operator|.
name|fast0
argument_list|,
name|fastRight
operator|.
name|fast1
argument_list|,
name|fastRight
operator|.
name|fast2
argument_list|,
name|fastRight
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastRight
operator|.
name|fastScale
argument_list|,
name|fastResult
argument_list|)
return|;
block|}
comment|/**    * Add the two decimals.    *    * NOTE: Scale Determination for Addition/Subtraction    *    * One could take the Math.min of the scales and adjust the operand with the lower scale have a    * scale = higher scale.    *    * But this does not seem to work with decimals with widely varying scales as these:    *    *     598575157855521918987423259.94094                            dec1 (int digits 27,scale 5)    *  +                            0.0000000000006711991169422033     dec2 (int digits 0, scale 28)    *    * Trying to make dec1 to have a scale of 28 (i.e. by adding trailing zeroes) would exceed    * MAX_PRECISION (int digits 27 + 28> 38).    *    * In this example we need to make sure we have enough integer digit room in the result to    * handle dec1's digits.  In order to maintain that, we will need to get rid of lower    * fractional digits of dec2.  But when do we do that?    *    * OldHiveDecimal.add does the full arithmetic add with all the digits using BigDecimal and    * then adjusts the result to fit in MAX_PRECISION, etc.    *    * If we try to do pre-rounding dec2 it is problematic.  We'd need to know if there is a carry in    * the arithmetic in order to know at which scale to do the rounding.  This gets complicated.    *    * So, the simplest thing is to emulate what OldHiveDecimal does and do the full digit addition    * and then fit the result afterwards.    *    * @return True if the addition was successful; Otherwise, false is returned on overflow.    */
specifier|public
specifier|static
name|boolean
name|fastAdd
parameter_list|(
name|int
name|leftSignum
parameter_list|,
name|long
name|leftFast0
parameter_list|,
name|long
name|leftFast1
parameter_list|,
name|long
name|leftFast2
parameter_list|,
name|int
name|leftIntegerDigitCount
parameter_list|,
name|int
name|leftScale
parameter_list|,
name|int
name|rightSignum
parameter_list|,
name|long
name|rightFast0
parameter_list|,
name|long
name|rightFast1
parameter_list|,
name|long
name|rightFast2
parameter_list|,
name|int
name|rightIntegerDigitCount
parameter_list|,
name|int
name|rightScale
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
if|if
condition|(
name|rightSignum
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSet
argument_list|(
name|leftSignum
argument_list|,
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
name|leftIntegerDigitCount
argument_list|,
name|leftScale
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|leftSignum
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSet
argument_list|(
name|rightSignum
argument_list|,
name|rightFast0
argument_list|,
name|rightFast1
argument_list|,
name|rightFast2
argument_list|,
name|rightIntegerDigitCount
argument_list|,
name|rightScale
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|leftScale
operator|==
name|rightScale
condition|)
block|{
return|return
name|doAddSameScale
argument_list|(
name|leftSignum
argument_list|,
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
name|rightSignum
argument_list|,
name|rightFast0
argument_list|,
name|rightFast1
argument_list|,
name|rightFast2
argument_list|,
name|leftScale
argument_list|,
name|fastResult
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|doAddDifferentScale
argument_list|(
name|leftSignum
argument_list|,
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
name|leftIntegerDigitCount
argument_list|,
name|leftScale
argument_list|,
name|rightSignum
argument_list|,
name|rightFast0
argument_list|,
name|rightFast1
argument_list|,
name|rightFast2
argument_list|,
name|rightIntegerDigitCount
argument_list|,
name|rightScale
argument_list|,
name|fastResult
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
name|boolean
name|fastSubtract
parameter_list|(
name|FastHiveDecimal
name|fastLeft
parameter_list|,
name|FastHiveDecimal
name|fastRight
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
return|return
name|fastSubtract
argument_list|(
name|fastLeft
operator|.
name|fastSignum
argument_list|,
name|fastLeft
operator|.
name|fast0
argument_list|,
name|fastLeft
operator|.
name|fast1
argument_list|,
name|fastLeft
operator|.
name|fast2
argument_list|,
name|fastLeft
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastLeft
operator|.
name|fastScale
argument_list|,
name|fastRight
operator|.
name|fastSignum
argument_list|,
name|fastRight
operator|.
name|fast0
argument_list|,
name|fastRight
operator|.
name|fast1
argument_list|,
name|fastRight
operator|.
name|fast2
argument_list|,
name|fastRight
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastRight
operator|.
name|fastScale
argument_list|,
name|fastResult
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|fastSubtract
parameter_list|(
name|int
name|leftSignum
parameter_list|,
name|long
name|leftFast0
parameter_list|,
name|long
name|leftFast1
parameter_list|,
name|long
name|leftFast2
parameter_list|,
name|int
name|leftIntegerDigitCount
parameter_list|,
name|int
name|leftScale
parameter_list|,
name|int
name|rightSignum
parameter_list|,
name|long
name|rightFast0
parameter_list|,
name|long
name|rightFast1
parameter_list|,
name|long
name|rightFast2
parameter_list|,
name|int
name|rightIntegerDigitCount
parameter_list|,
name|int
name|rightScale
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
if|if
condition|(
name|rightSignum
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSet
argument_list|(
name|leftSignum
argument_list|,
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
name|leftIntegerDigitCount
argument_list|,
name|leftScale
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|final
name|int
name|flippedDecSignum
init|=
operator|(
name|rightSignum
operator|==
literal|1
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|leftSignum
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSet
argument_list|(
name|flippedDecSignum
argument_list|,
name|rightFast0
argument_list|,
name|rightFast1
argument_list|,
name|rightFast2
argument_list|,
name|rightIntegerDigitCount
argument_list|,
name|rightScale
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|leftScale
operator|==
name|rightScale
condition|)
block|{
return|return
name|doAddSameScale
argument_list|(
name|leftSignum
argument_list|,
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
name|flippedDecSignum
argument_list|,
name|rightFast0
argument_list|,
name|rightFast1
argument_list|,
name|rightFast2
argument_list|,
name|leftScale
argument_list|,
name|fastResult
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|doAddDifferentScale
argument_list|(
name|leftSignum
argument_list|,
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
name|leftIntegerDigitCount
argument_list|,
name|leftScale
argument_list|,
name|flippedDecSignum
argument_list|,
name|rightFast0
argument_list|,
name|rightFast1
argument_list|,
name|rightFast2
argument_list|,
name|rightIntegerDigitCount
argument_list|,
name|rightScale
argument_list|,
name|fastResult
argument_list|)
return|;
block|}
block|}
comment|//************************************************************************************************
comment|// Decimal Multiply.
specifier|private
specifier|static
name|boolean
name|doMultiply
parameter_list|(
name|int
name|leftSignum
parameter_list|,
name|long
name|leftFast0
parameter_list|,
name|long
name|leftFast1
parameter_list|,
name|long
name|leftFast2
parameter_list|,
name|int
name|leftIntegerDigitCount
parameter_list|,
name|int
name|leftScale
parameter_list|,
name|int
name|rightSignum
parameter_list|,
name|long
name|rightFast0
parameter_list|,
name|long
name|rightFast1
parameter_list|,
name|long
name|rightFast2
parameter_list|,
name|int
name|rightIntegerDigitCount
parameter_list|,
name|int
name|rightScale
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
comment|// Set signum before; if result is zero, fastMultiply will set signum to 0.
name|fastResult
operator|.
name|fastSignum
operator|=
operator|(
name|leftSignum
operator|==
name|rightSignum
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
expr_stmt|;
name|int
name|resultScale
init|=
name|leftScale
operator|+
name|rightScale
decl_stmt|;
comment|/*      * For multiplicands with scale 0, trim trailing zeroes.      */
if|if
condition|(
name|leftScale
operator|==
literal|0
condition|)
block|{
comment|// Pretend like it has fractional digits so we can get the trailing zero count.
specifier|final
name|int
name|leftTrailingZeroCount
init|=
name|fastTrailingDecimalZeroCount
argument_list|(
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
literal|0
argument_list|,
name|leftIntegerDigitCount
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftTrailingZeroCount
operator|>
literal|0
condition|)
block|{
name|doFastScaleDown
argument_list|(
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
name|leftTrailingZeroCount
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
name|resultScale
operator|-=
name|leftTrailingZeroCount
expr_stmt|;
name|leftFast0
operator|=
name|fastResult
operator|.
name|fast0
expr_stmt|;
name|leftFast1
operator|=
name|fastResult
operator|.
name|fast1
expr_stmt|;
name|leftFast2
operator|=
name|fastResult
operator|.
name|fast2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rightScale
operator|==
literal|0
condition|)
block|{
comment|// Pretend like it has fractional digits so we can get the trailing zero count.
specifier|final
name|int
name|rightTrailingZeroCount
init|=
name|fastTrailingDecimalZeroCount
argument_list|(
name|rightFast0
argument_list|,
name|rightFast1
argument_list|,
name|rightFast2
argument_list|,
literal|0
argument_list|,
name|rightIntegerDigitCount
argument_list|)
decl_stmt|;
if|if
condition|(
name|rightTrailingZeroCount
operator|>
literal|0
condition|)
block|{
name|doFastScaleDown
argument_list|(
name|rightFast0
argument_list|,
name|rightFast1
argument_list|,
name|rightFast2
argument_list|,
name|rightTrailingZeroCount
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
name|resultScale
operator|-=
name|rightTrailingZeroCount
expr_stmt|;
name|rightFast0
operator|=
name|fastResult
operator|.
name|fast0
expr_stmt|;
name|rightFast1
operator|=
name|fastResult
operator|.
name|fast1
expr_stmt|;
name|rightFast2
operator|=
name|fastResult
operator|.
name|fast2
expr_stmt|;
block|}
block|}
name|boolean
name|largeOverflow
init|=
operator|!
name|fastMultiply5x5HalfWords
argument_list|(
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
name|rightFast0
argument_list|,
name|rightFast1
argument_list|,
name|rightFast2
argument_list|,
name|fastResult
argument_list|)
decl_stmt|;
if|if
condition|(
name|largeOverflow
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fastResult
operator|.
name|fastSignum
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastScale
operator|=
literal|0
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|resultScale
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|-
name|resultScale
operator|>=
name|HiveDecimal
operator|.
name|MAX_SCALE
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|fastScaleUp
argument_list|(
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
operator|-
name|resultScale
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|resultScale
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|precision
decl_stmt|;
if|if
condition|(
name|fastResult
operator|.
name|fast2
operator|!=
literal|0
condition|)
block|{
name|precision
operator|=
name|TWO_X_LONGWORD_DECIMAL_DIGITS
operator|+
name|fastLongWordPrecision
argument_list|(
name|fastResult
operator|.
name|fast2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fastResult
operator|.
name|fast1
operator|!=
literal|0
condition|)
block|{
name|precision
operator|=
name|LONGWORD_DECIMAL_DIGITS
operator|+
name|fastLongWordPrecision
argument_list|(
name|fastResult
operator|.
name|fast1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|precision
operator|=
name|fastLongWordPrecision
argument_list|(
name|fastResult
operator|.
name|fast0
argument_list|)
expr_stmt|;
block|}
name|int
name|integerDigitCount
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|precision
operator|-
name|resultScale
argument_list|)
decl_stmt|;
if|if
condition|(
name|integerDigitCount
operator|>
name|HiveDecimal
operator|.
name|MAX_PRECISION
condition|)
block|{
comment|// Integer is too large -- cannot recover by trimming fractional digits.
return|return
literal|false
return|;
block|}
if|if
condition|(
name|precision
operator|>
name|HiveDecimal
operator|.
name|MAX_PRECISION
operator|||
name|resultScale
operator|>
name|HiveDecimal
operator|.
name|MAX_SCALE
condition|)
block|{
comment|// Trim off lower fractional digits but with NO ROUNDING.
specifier|final
name|int
name|maxScale
init|=
name|HiveDecimal
operator|.
name|MAX_SCALE
operator|-
name|integerDigitCount
decl_stmt|;
specifier|final
name|int
name|scaleDown
init|=
name|resultScale
operator|-
name|maxScale
decl_stmt|;
if|if
condition|(
operator|!
name|fastScaleDownNoRound
argument_list|(
name|fastResult
operator|.
name|fastSignum
argument_list|,
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
name|scaleDown
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
comment|// Round fractional must be 0.  Not allowed to throw away digits.
return|return
literal|false
return|;
block|}
name|resultScale
operator|-=
name|scaleDown
expr_stmt|;
block|}
name|fastResult
operator|.
name|fastScale
operator|=
name|resultScale
expr_stmt|;
comment|// This assume no round up...
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|=
name|integerDigitCount
expr_stmt|;
if|if
condition|(
name|fastResult
operator|.
name|fastScale
operator|>
name|HiveDecimal
operator|.
name|MAX_SCALE
condition|)
block|{
comment|// We are not allowed to lose digits in multiply to be compatible with OldHiveDecimal
comment|// behavior, so overflow.
comment|// CONSIDER: Does it make sense to be so restrictive.  If we just did repeated addition,
comment|//           it would succeed...
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|resultTrailingZeroCount
init|=
name|fastTrailingDecimalZeroCount
argument_list|(
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
name|fastResult
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastResult
operator|.
name|fastScale
argument_list|)
decl_stmt|;
if|if
condition|(
name|resultTrailingZeroCount
operator|>
literal|0
condition|)
block|{
name|doFastScaleDown
argument_list|(
name|fastResult
argument_list|,
name|resultTrailingZeroCount
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|fastResult
operator|.
name|fastSignum
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastScale
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fastResult
operator|.
name|fastScale
operator|-=
name|resultTrailingZeroCount
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|public
specifier|static
name|boolean
name|fastMultiply5x5HalfWords
parameter_list|(
name|FastHiveDecimal
name|fastLeft
parameter_list|,
name|FastHiveDecimal
name|fastRight
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
return|return
name|fastMultiply5x5HalfWords
argument_list|(
name|fastLeft
operator|.
name|fast0
argument_list|,
name|fastLeft
operator|.
name|fast1
argument_list|,
name|fastLeft
operator|.
name|fast2
argument_list|,
name|fastRight
operator|.
name|fast0
argument_list|,
name|fastRight
operator|.
name|fast1
argument_list|,
name|fastRight
operator|.
name|fast2
argument_list|,
name|fastResult
argument_list|)
return|;
block|}
comment|/**    * Fast decimal multiplication on two decimals that have been already scaled and whose results    * will fit in 38 digits.    *    * The caller is responsible checking for overflow within the highword and determining    * if scale down appropriate.    *    * @return  Returns false if the multiplication resulted in large overflow.  Values in result are    *          undefined in that case.    */
specifier|public
specifier|static
name|boolean
name|fastMultiply5x5HalfWords
parameter_list|(
name|long
name|left0
parameter_list|,
name|long
name|left1
parameter_list|,
name|long
name|left2
parameter_list|,
name|long
name|right0
parameter_list|,
name|long
name|right1
parameter_list|,
name|long
name|right2
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
name|long
name|product
decl_stmt|;
specifier|final
name|long
name|halfRight0
init|=
name|right0
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfRight1
init|=
name|right0
operator|/
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfRight2
init|=
name|right1
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfRight3
init|=
name|right1
operator|/
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfRight4
init|=
name|right2
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfLeft0
init|=
name|left0
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfLeft1
init|=
name|left0
operator|/
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfLeft2
init|=
name|left1
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfLeft3
init|=
name|left1
operator|/
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfLeft4
init|=
name|left2
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
comment|// v[0]
name|product
operator|=
name|halfRight0
operator|*
name|halfLeft0
expr_stmt|;
specifier|final
name|int
name|z0
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[1] where (product % MULTIPLER_INTWORD_DECIMAL) is the carry from v[0].
name|product
operator|=
name|halfRight0
operator|*
name|halfLeft1
operator|+
name|halfRight1
operator|*
name|halfLeft0
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
specifier|final
name|int
name|z1
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[2]
name|product
operator|=
name|halfRight0
operator|*
name|halfLeft2
operator|+
name|halfRight1
operator|*
name|halfLeft1
operator|+
name|halfRight2
operator|*
name|halfLeft0
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
specifier|final
name|int
name|z2
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[3]
name|product
operator|=
name|halfRight0
operator|*
name|halfLeft3
operator|+
name|halfRight1
operator|*
name|halfLeft2
operator|+
name|halfRight2
operator|*
name|halfLeft1
operator|+
name|halfRight3
operator|*
name|halfLeft0
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
specifier|final
name|int
name|z3
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[4]
name|product
operator|=
name|halfRight0
operator|*
name|halfLeft4
operator|+
name|halfRight1
operator|*
name|halfLeft3
operator|+
name|halfRight2
operator|*
name|halfLeft2
operator|+
name|halfRight3
operator|*
name|halfLeft1
operator|+
name|halfRight4
operator|*
name|halfLeft0
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
comment|// v[5] is not calculated since high integer is always 0 for our decimals.
comment|// These remaining combinations below definitely result in overflow.
if|if
condition|(
operator|(
name|halfRight4
operator|!=
literal|0
operator|&&
operator|(
name|halfLeft4
operator|!=
literal|0
operator|||
name|halfLeft3
operator|!=
literal|0
operator|||
name|halfLeft2
operator|!=
literal|0
operator|||
name|halfLeft1
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
name|halfRight3
operator|!=
literal|0
operator|&&
operator|(
name|halfLeft4
operator|!=
literal|0
operator|||
name|halfLeft3
operator|!=
literal|0
operator|||
name|halfLeft2
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
name|halfRight2
operator|!=
literal|0
operator|&&
operator|(
name|halfLeft4
operator|!=
literal|0
operator|||
name|halfLeft3
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
name|halfRight1
operator|!=
literal|0
operator|&&
name|halfLeft4
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|long
name|result0
init|=
operator|(
name|long
operator|)
name|z1
operator|*
name|MULTIPLER_INTWORD_DECIMAL
operator|+
operator|(
name|long
operator|)
name|z0
decl_stmt|;
specifier|final
name|long
name|result1
init|=
operator|(
name|long
operator|)
name|z3
operator|*
name|MULTIPLER_INTWORD_DECIMAL
operator|+
operator|(
name|long
operator|)
name|z2
decl_stmt|;
specifier|final
name|long
name|result2
init|=
name|product
decl_stmt|;
if|if
condition|(
name|result0
operator|==
literal|0
operator|&&
name|result1
operator|==
literal|0
operator|&&
name|result2
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastSignum
operator|=
literal|0
expr_stmt|;
block|}
name|fastResult
operator|.
name|fast0
operator|=
name|result0
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|result1
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|result2
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
specifier|static
name|boolean
name|fastMultiplyFullInternal
parameter_list|(
name|FastHiveDecimal
name|fastLeft
parameter_list|,
name|FastHiveDecimal
name|fastRight
parameter_list|,
name|long
index|[]
name|result
parameter_list|)
block|{
return|return
name|fastMultiplyFullInternal
argument_list|(
name|fastLeft
operator|.
name|fast0
argument_list|,
name|fastLeft
operator|.
name|fast1
argument_list|,
name|fastLeft
operator|.
name|fast2
argument_list|,
name|fastRight
operator|.
name|fast0
argument_list|,
name|fastRight
operator|.
name|fast1
argument_list|,
name|fastRight
operator|.
name|fast2
argument_list|,
name|result
argument_list|)
return|;
block|}
comment|/**    * Fast decimal multiplication on two decimals that have been already scaled and whose results    * will fit in 38 digits.    *    * The caller is responsible checking for overflow within the highword and determining    * if scale down appropriate.    *    * @return  Returns false if the multiplication resulted in large overflow.  Values in result are    *          undefined in that case.    */
specifier|public
specifier|static
name|boolean
name|fastMultiply5x5HalfWords
parameter_list|(
name|long
name|left0
parameter_list|,
name|long
name|left1
parameter_list|,
name|long
name|left2
parameter_list|,
name|long
name|right0
parameter_list|,
name|long
name|right1
parameter_list|,
name|long
name|right2
parameter_list|,
name|long
index|[]
name|result
parameter_list|)
block|{
name|long
name|product
decl_stmt|;
specifier|final
name|long
name|halfRight0
init|=
name|right0
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfRight1
init|=
name|right0
operator|/
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfRight2
init|=
name|right1
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfRight3
init|=
name|right1
operator|/
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfRight4
init|=
name|right2
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfLeft0
init|=
name|left0
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfLeft1
init|=
name|left0
operator|/
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfLeft2
init|=
name|left1
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfLeft3
init|=
name|left1
operator|/
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfLeft4
init|=
name|left2
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
comment|// v[0]
name|product
operator|=
name|halfRight0
operator|*
name|halfLeft0
expr_stmt|;
specifier|final
name|int
name|z0
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[1] where (product % MULTIPLER_INTWORD_DECIMAL) is the carry from v[0].
name|product
operator|=
name|halfRight0
operator|*
name|halfLeft1
operator|+
name|halfRight1
operator|*
name|halfLeft0
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
specifier|final
name|int
name|z1
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[2]
name|product
operator|=
name|halfRight0
operator|*
name|halfLeft2
operator|+
name|halfRight1
operator|*
name|halfLeft1
operator|+
name|halfRight2
operator|*
name|halfLeft0
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
specifier|final
name|int
name|z2
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[3]
name|product
operator|=
name|halfRight0
operator|*
name|halfLeft3
operator|+
name|halfRight1
operator|*
name|halfLeft2
operator|+
name|halfRight2
operator|*
name|halfLeft1
operator|+
name|halfRight3
operator|*
name|halfLeft0
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
specifier|final
name|int
name|z3
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[4]
name|product
operator|=
name|halfRight0
operator|*
name|halfLeft4
operator|+
name|halfRight1
operator|*
name|halfLeft3
operator|+
name|halfRight2
operator|*
name|halfLeft2
operator|+
name|halfRight3
operator|*
name|halfLeft1
operator|+
name|halfRight4
operator|*
name|halfLeft0
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
comment|// v[5] is not calculated since high integer is always 0 for our decimals.
comment|// These remaining combinations below definitely result in overflow.
if|if
condition|(
operator|(
name|halfRight4
operator|!=
literal|0
operator|&&
operator|(
name|halfLeft4
operator|!=
literal|0
operator|||
name|halfLeft3
operator|!=
literal|0
operator|||
name|halfLeft2
operator|!=
literal|0
operator|||
name|halfLeft1
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
name|halfRight3
operator|!=
literal|0
operator|&&
operator|(
name|halfLeft4
operator|!=
literal|0
operator|||
name|halfLeft3
operator|!=
literal|0
operator|||
name|halfLeft2
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
name|halfRight2
operator|!=
literal|0
operator|&&
operator|(
name|halfLeft4
operator|!=
literal|0
operator|||
name|halfLeft3
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
name|halfRight1
operator|!=
literal|0
operator|&&
name|halfLeft4
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|result
index|[
literal|0
index|]
operator|=
operator|(
name|long
operator|)
name|z1
operator|*
name|MULTIPLER_INTWORD_DECIMAL
operator|+
operator|(
name|long
operator|)
name|z0
expr_stmt|;
name|result
index|[
literal|1
index|]
operator|=
operator|(
name|long
operator|)
name|z3
operator|*
name|MULTIPLER_INTWORD_DECIMAL
operator|+
operator|(
name|long
operator|)
name|z2
expr_stmt|;
name|result
index|[
literal|2
index|]
operator|=
name|product
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Fast decimal multiplication on two decimals whose results are permitted to go beyond    * 38 digits to the maximum possible 76 digits.  The caller is responsible for scaling and    * rounding the results back to 38 or fewer digits.    *    * The caller is responsible for determining the signum.    *    * @param left0    * @param left1    * @param left2    * @param right0    * @param right1    * @param right2    * @param result  This full result has 5 longs.    * @return  Returns false if the multiplication resulted in an overflow.  Values in result are    *          undefined in that case.    */
specifier|public
specifier|static
name|boolean
name|fastMultiplyFullInternal
parameter_list|(
name|long
name|left0
parameter_list|,
name|long
name|left1
parameter_list|,
name|long
name|left2
parameter_list|,
name|long
name|right0
parameter_list|,
name|long
name|right1
parameter_list|,
name|long
name|right2
parameter_list|,
name|long
index|[]
name|result
parameter_list|)
block|{
assert|assert
operator|(
name|result
operator|.
name|length
operator|==
literal|5
operator|)
assert|;
if|if
condition|(
name|result
operator|.
name|length
operator|!=
literal|5
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Expecting result array length = 5"
argument_list|)
throw|;
block|}
name|long
name|product
decl_stmt|;
specifier|final
name|long
name|halfRight0
init|=
name|right0
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfRight1
init|=
name|right0
operator|/
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfRight2
init|=
name|right1
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfRight3
init|=
name|right1
operator|/
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfRight4
init|=
name|right2
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfLeft0
init|=
name|left0
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfLeft1
init|=
name|left0
operator|/
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfLeft2
init|=
name|left1
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfLeft3
init|=
name|left1
operator|/
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfLeft4
init|=
name|left2
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
comment|// v[0]
name|product
operator|=
name|halfRight0
operator|*
name|halfLeft0
expr_stmt|;
specifier|final
name|int
name|z0
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[1] where (product % MULTIPLER_INTWORD_DECIMAL) is the carry from v[0].
name|product
operator|=
name|halfRight0
operator|*
name|halfLeft1
operator|+
name|halfRight1
operator|*
name|halfLeft0
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
specifier|final
name|int
name|z1
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[2]
name|product
operator|=
name|halfRight0
operator|*
name|halfLeft2
operator|+
name|halfRight1
operator|*
name|halfLeft1
operator|+
name|halfRight2
operator|*
name|halfLeft0
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
specifier|final
name|int
name|z2
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[3]
name|product
operator|=
name|halfRight0
operator|*
name|halfLeft3
operator|+
name|halfRight1
operator|*
name|halfLeft2
operator|+
name|halfRight2
operator|*
name|halfLeft1
operator|+
name|halfRight3
operator|*
name|halfLeft0
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
specifier|final
name|int
name|z3
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[4]
name|product
operator|=
name|halfRight0
operator|*
name|halfLeft4
operator|+
name|halfRight1
operator|*
name|halfLeft3
operator|+
name|halfRight2
operator|*
name|halfLeft2
operator|+
name|halfRight3
operator|*
name|halfLeft1
operator|+
name|halfRight4
operator|*
name|halfLeft0
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
specifier|final
name|int
name|z4
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[5] -- since integer #5 is always 0, some products here are not included.
name|product
operator|=
name|halfRight1
operator|*
name|halfLeft4
operator|+
name|halfRight2
operator|*
name|halfLeft3
operator|+
name|halfRight3
operator|*
name|halfLeft2
operator|+
name|halfRight4
operator|*
name|halfLeft1
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
specifier|final
name|int
name|z5
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[6] -- since integer #5 is always 0, some products here are not included.
name|product
operator|=
name|halfRight2
operator|*
name|halfLeft4
operator|+
name|halfRight3
operator|*
name|halfLeft3
operator|+
name|halfRight4
operator|*
name|halfLeft2
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
specifier|final
name|int
name|z6
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[7] -- since integer #5 is always 0, some products here are not included.
name|product
operator|=
name|halfRight3
operator|*
name|halfLeft4
operator|+
name|halfRight4
operator|*
name|halfLeft3
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
specifier|final
name|int
name|z7
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[8] -- since integer #5 is always 0, some products here are not included.
name|product
operator|=
name|halfRight4
operator|*
name|halfLeft4
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
specifier|final
name|int
name|z8
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[9] -- since integer #5 is always 0, some products here are not included.
name|product
operator|=
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
if|if
condition|(
name|product
operator|>
name|FULL_MAX_HIGHWORD_DECIMAL
condition|)
block|{
return|return
literal|false
return|;
block|}
name|result
index|[
literal|0
index|]
operator|=
operator|(
name|long
operator|)
name|z1
operator|*
name|MULTIPLER_INTWORD_DECIMAL
operator|+
operator|(
name|long
operator|)
name|z0
expr_stmt|;
name|result
index|[
literal|1
index|]
operator|=
operator|(
name|long
operator|)
name|z3
operator|*
name|MULTIPLER_INTWORD_DECIMAL
operator|+
operator|(
name|long
operator|)
name|z2
expr_stmt|;
name|result
index|[
literal|2
index|]
operator|=
operator|(
name|long
operator|)
name|z5
operator|*
name|MULTIPLER_INTWORD_DECIMAL
operator|+
operator|(
name|long
operator|)
name|z4
expr_stmt|;
name|result
index|[
literal|3
index|]
operator|=
operator|(
name|long
operator|)
name|z7
operator|*
name|MULTIPLER_INTWORD_DECIMAL
operator|+
operator|(
name|long
operator|)
name|z6
expr_stmt|;
name|result
index|[
literal|4
index|]
operator|=
name|product
operator|*
name|MULTIPLER_INTWORD_DECIMAL
operator|+
operator|(
name|long
operator|)
name|z8
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Fast decimal multiplication on two decimals whose results are permitted to go beyond    * 38 digits to the maximum possible 76 digits.  The caller is responsible for scaling and    * rounding the results back to 38 or fewer digits.    *    * The caller is responsible for determining the signum.    *    * @param result  This full result has 5 longs.    * @return  Returns false if the multiplication resulted in an overflow.  Values in result are    *          undefined in that case.    */
specifier|public
specifier|static
name|boolean
name|fastMultiply5x6HalfWords
parameter_list|(
name|long
name|left0
parameter_list|,
name|long
name|left1
parameter_list|,
name|long
name|left2
parameter_list|,
name|long
name|right0
parameter_list|,
name|long
name|right1
parameter_list|,
name|long
name|right2
parameter_list|,
name|long
index|[]
name|result
parameter_list|)
block|{
if|if
condition|(
name|result
operator|.
name|length
operator|!=
literal|6
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Expecting result array length = 6"
argument_list|)
throw|;
block|}
name|long
name|product
decl_stmt|;
specifier|final
name|long
name|halfRight0
init|=
name|right0
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfRight1
init|=
name|right0
operator|/
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfRight2
init|=
name|right1
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfRight3
init|=
name|right1
operator|/
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfRight4
init|=
name|right2
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfRight5
init|=
name|right2
operator|/
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfLeft0
init|=
name|left0
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfLeft1
init|=
name|left0
operator|/
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfLeft2
init|=
name|left1
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfLeft3
init|=
name|left1
operator|/
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
specifier|final
name|long
name|halfLeft4
init|=
name|left2
operator|%
name|MULTIPLER_INTWORD_DECIMAL
decl_stmt|;
comment|// v[0]
name|product
operator|=
name|halfRight0
operator|*
name|halfLeft0
expr_stmt|;
specifier|final
name|int
name|z0
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[1] where (product % MULTIPLER_INTWORD_DECIMAL) is the carry from v[0].
name|product
operator|=
name|halfRight0
operator|*
name|halfLeft1
operator|+
name|halfRight1
operator|*
name|halfLeft0
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
specifier|final
name|int
name|z1
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[2]
name|product
operator|=
name|halfRight0
operator|*
name|halfLeft2
operator|+
name|halfRight1
operator|*
name|halfLeft1
operator|+
name|halfRight2
operator|*
name|halfLeft0
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
specifier|final
name|int
name|z2
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[3]
name|product
operator|=
name|halfRight0
operator|*
name|halfLeft3
operator|+
name|halfRight1
operator|*
name|halfLeft2
operator|+
name|halfRight2
operator|*
name|halfLeft1
operator|+
name|halfRight3
operator|*
name|halfLeft0
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
specifier|final
name|int
name|z3
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[4]
name|product
operator|=
name|halfRight0
operator|*
name|halfLeft4
operator|+
name|halfRight1
operator|*
name|halfLeft3
operator|+
name|halfRight2
operator|*
name|halfLeft2
operator|+
name|halfRight3
operator|*
name|halfLeft1
operator|+
name|halfRight4
operator|*
name|halfLeft0
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
specifier|final
name|int
name|z4
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[5] -- since left integer #5 is always 0, some products here are not included.
name|product
operator|=
name|halfRight1
operator|*
name|halfLeft4
operator|+
name|halfRight2
operator|*
name|halfLeft3
operator|+
name|halfRight3
operator|*
name|halfLeft2
operator|+
name|halfRight4
operator|*
name|halfLeft1
operator|+
name|halfRight5
operator|*
name|halfLeft0
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
specifier|final
name|int
name|z5
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[6] -- since left integer #5 is always 0, some products here are not included.
name|product
operator|=
name|halfRight2
operator|*
name|halfLeft4
operator|+
name|halfRight3
operator|*
name|halfLeft3
operator|+
name|halfRight4
operator|*
name|halfLeft2
operator|+
name|halfRight5
operator|*
name|halfLeft1
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
specifier|final
name|int
name|z6
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[7] -- since left integer #5 is always 0, some products here are not included.
name|product
operator|=
name|halfRight3
operator|*
name|halfLeft4
operator|+
name|halfRight4
operator|*
name|halfLeft3
operator|+
name|halfRight5
operator|*
name|halfLeft2
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
specifier|final
name|int
name|z7
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[8] -- since left integer #5 is always 0, some products here are not included.
name|product
operator|=
name|halfRight4
operator|*
name|halfLeft4
operator|+
name|halfRight5
operator|*
name|halfLeft3
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
specifier|final
name|int
name|z8
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[9] -- since left integer #5 is always 0, some products here are not included.
name|product
operator|=
name|halfRight5
operator|*
name|halfLeft4
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
specifier|final
name|int
name|z9
init|=
call|(
name|int
call|)
argument_list|(
name|product
operator|%
name|MULTIPLER_INTWORD_DECIMAL
argument_list|)
decl_stmt|;
comment|// v[10] -- since left integer #5 is always 0, some products here are not included.
name|product
operator|=
operator|+
operator|(
name|product
operator|/
name|MULTIPLER_INTWORD_DECIMAL
operator|)
expr_stmt|;
if|if
condition|(
name|product
operator|>
name|MULTIPLER_INTWORD_DECIMAL
condition|)
block|{
return|return
literal|false
return|;
block|}
name|result
index|[
literal|0
index|]
operator|=
operator|(
name|long
operator|)
name|z1
operator|*
name|MULTIPLER_INTWORD_DECIMAL
operator|+
operator|(
name|long
operator|)
name|z0
expr_stmt|;
name|result
index|[
literal|1
index|]
operator|=
operator|(
name|long
operator|)
name|z3
operator|*
name|MULTIPLER_INTWORD_DECIMAL
operator|+
operator|(
name|long
operator|)
name|z2
expr_stmt|;
name|result
index|[
literal|2
index|]
operator|=
operator|(
name|long
operator|)
name|z5
operator|*
name|MULTIPLER_INTWORD_DECIMAL
operator|+
operator|(
name|long
operator|)
name|z4
expr_stmt|;
name|result
index|[
literal|3
index|]
operator|=
operator|(
name|long
operator|)
name|z7
operator|*
name|MULTIPLER_INTWORD_DECIMAL
operator|+
operator|(
name|long
operator|)
name|z6
expr_stmt|;
name|result
index|[
literal|4
index|]
operator|=
operator|(
name|long
operator|)
name|z9
operator|*
name|MULTIPLER_INTWORD_DECIMAL
operator|+
operator|(
name|long
operator|)
name|z8
expr_stmt|;
name|result
index|[
literal|5
index|]
operator|=
name|product
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
specifier|static
name|boolean
name|fastMultiply
parameter_list|(
name|FastHiveDecimal
name|fastLeft
parameter_list|,
name|FastHiveDecimal
name|fastRight
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
return|return
name|fastMultiply
argument_list|(
name|fastLeft
operator|.
name|fastSignum
argument_list|,
name|fastLeft
operator|.
name|fast0
argument_list|,
name|fastLeft
operator|.
name|fast1
argument_list|,
name|fastLeft
operator|.
name|fast2
argument_list|,
name|fastLeft
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastLeft
operator|.
name|fastScale
argument_list|,
name|fastRight
operator|.
name|fastSignum
argument_list|,
name|fastRight
operator|.
name|fast0
argument_list|,
name|fastRight
operator|.
name|fast1
argument_list|,
name|fastRight
operator|.
name|fast2
argument_list|,
name|fastRight
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastRight
operator|.
name|fastScale
argument_list|,
name|fastResult
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|fastMultiply
parameter_list|(
name|int
name|leftSignum
parameter_list|,
name|long
name|leftFast0
parameter_list|,
name|long
name|leftFast1
parameter_list|,
name|long
name|leftFast2
parameter_list|,
name|int
name|leftIntegerDigitCount
parameter_list|,
name|int
name|leftScale
parameter_list|,
name|int
name|rightSignum
parameter_list|,
name|long
name|rightFast0
parameter_list|,
name|long
name|rightFast1
parameter_list|,
name|long
name|rightFast2
parameter_list|,
name|int
name|rightIntegerDigitCount
parameter_list|,
name|int
name|rightScale
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
if|if
condition|(
name|leftSignum
operator|==
literal|0
operator|||
name|rightSignum
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
name|doMultiply
argument_list|(
name|leftSignum
argument_list|,
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
name|leftIntegerDigitCount
argument_list|,
name|leftScale
argument_list|,
name|rightSignum
argument_list|,
name|rightFast0
argument_list|,
name|rightFast1
argument_list|,
name|rightFast2
argument_list|,
name|rightIntegerDigitCount
argument_list|,
name|rightScale
argument_list|,
name|fastResult
argument_list|)
return|;
block|}
comment|//************************************************************************************************
comment|// Decimal Division / Remainder.
comment|/**    * EXPERMIMENTAL: Division when divisor fits in a single decimal longword.    *    * @return  remainderSubexpr2    */
specifier|private
specifier|static
name|long
name|doSingleWordQuotient
parameter_list|(
name|long
name|leftFast0
parameter_list|,
name|long
name|leftFast1
parameter_list|,
name|long
name|leftFast2
parameter_list|,
name|long
name|rightFast0
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
name|long
name|quotient2
decl_stmt|;
name|long
name|quotient1
decl_stmt|;
name|long
name|quotient0
decl_stmt|;
name|long
name|remainderSubexpr2
decl_stmt|;
if|if
condition|(
name|leftFast2
operator|==
literal|0
operator|&&
name|leftFast1
operator|==
literal|0
condition|)
block|{
name|quotient2
operator|=
literal|0
expr_stmt|;
name|quotient1
operator|=
literal|0
expr_stmt|;
name|quotient0
operator|=
name|leftFast0
operator|/
name|rightFast0
expr_stmt|;
specifier|final
name|long
name|k0
init|=
name|leftFast0
operator|-
name|quotient0
operator|*
name|rightFast0
decl_stmt|;
name|remainderSubexpr2
operator|=
name|k0
operator|*
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leftFast2
operator|==
literal|0
condition|)
block|{
comment|// leftFast1 != 0.
name|quotient2
operator|=
literal|0
expr_stmt|;
name|quotient1
operator|=
name|leftFast1
operator|/
name|rightFast0
expr_stmt|;
specifier|final
name|long
name|k1
init|=
name|leftFast1
operator|-
name|quotient1
operator|*
name|rightFast0
decl_stmt|;
specifier|final
name|long
name|quotientSubexpr0
init|=
name|k1
operator|*
name|MULTIPLER_LONGWORD_DECIMAL
operator|+
name|leftFast0
decl_stmt|;
name|quotient0
operator|=
name|quotientSubexpr0
operator|/
name|rightFast0
expr_stmt|;
specifier|final
name|long
name|k0
init|=
name|quotientSubexpr0
operator|-
name|quotient0
operator|*
name|rightFast0
decl_stmt|;
name|remainderSubexpr2
operator|=
name|k0
operator|*
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leftFast1
operator|==
literal|0
condition|)
block|{
comment|// leftFast2 != 0&& leftFast1 == 0.
name|quotient2
operator|=
name|leftFast2
operator|/
name|rightFast0
expr_stmt|;
name|quotient1
operator|=
literal|0
expr_stmt|;
name|quotient0
operator|=
name|leftFast0
operator|/
name|rightFast0
expr_stmt|;
specifier|final
name|long
name|k0
init|=
name|leftFast0
operator|-
name|quotient0
operator|*
name|rightFast0
decl_stmt|;
name|remainderSubexpr2
operator|=
name|k0
operator|*
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
block|}
else|else
block|{
name|quotient2
operator|=
name|leftFast2
operator|/
name|rightFast0
expr_stmt|;
specifier|final
name|long
name|k2
init|=
name|leftFast2
operator|-
name|quotient2
operator|*
name|rightFast0
decl_stmt|;
specifier|final
name|long
name|quotientSubexpr1
init|=
name|k2
operator|*
name|MULTIPLER_LONGWORD_DECIMAL
operator|+
name|leftFast1
decl_stmt|;
name|quotient1
operator|=
name|quotientSubexpr1
operator|/
name|rightFast0
expr_stmt|;
specifier|final
name|long
name|k1
init|=
name|quotientSubexpr1
operator|-
name|quotient1
operator|*
name|rightFast0
decl_stmt|;
specifier|final
name|long
name|quotientSubexpr0
init|=
name|k1
operator|*
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|quotient0
operator|=
name|quotientSubexpr0
operator|/
name|rightFast0
expr_stmt|;
specifier|final
name|long
name|k0
init|=
name|quotientSubexpr0
operator|-
name|quotient0
operator|*
name|rightFast0
decl_stmt|;
name|remainderSubexpr2
operator|=
name|k0
operator|*
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
block|}
name|fastResult
operator|.
name|fast0
operator|=
name|quotient0
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|quotient1
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|quotient2
expr_stmt|;
return|return
name|remainderSubexpr2
return|;
block|}
specifier|private
specifier|static
name|int
name|doSingleWordRemainder
parameter_list|(
name|long
name|leftFast0
parameter_list|,
name|long
name|leftFast1
parameter_list|,
name|long
name|leftFast2
parameter_list|,
name|long
name|rightFast0
parameter_list|,
name|long
name|remainderSubexpr2
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
name|int
name|remainderDigitCount
decl_stmt|;
name|long
name|remainder2
decl_stmt|;
name|long
name|remainder1
decl_stmt|;
name|long
name|remainder0
decl_stmt|;
if|if
condition|(
name|remainderSubexpr2
operator|==
literal|0
condition|)
block|{
name|remainder2
operator|=
literal|0
expr_stmt|;
name|remainder1
operator|=
literal|0
expr_stmt|;
name|remainder0
operator|=
literal|0
expr_stmt|;
name|remainderDigitCount
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|remainder2
operator|=
name|remainderSubexpr2
operator|/
name|rightFast0
expr_stmt|;
specifier|final
name|long
name|k2
init|=
name|remainderSubexpr2
operator|-
name|remainder2
operator|*
name|rightFast0
decl_stmt|;
if|if
condition|(
name|k2
operator|==
literal|0
condition|)
block|{
name|remainder1
operator|=
literal|0
expr_stmt|;
name|remainder0
operator|=
literal|0
expr_stmt|;
name|remainderDigitCount
operator|=
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|fastLongWordTrailingZeroCount
argument_list|(
name|remainder2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|long
name|remainderSubexpr1
init|=
name|k2
operator|*
name|MULTIPLER_LONGWORD_DECIMAL
decl_stmt|;
name|long
name|remainderSubexpr0
decl_stmt|;
name|remainder1
operator|=
name|remainderSubexpr1
operator|/
name|rightFast0
expr_stmt|;
specifier|final
name|long
name|k1
init|=
name|remainderSubexpr1
operator|-
name|remainder1
operator|*
name|rightFast0
decl_stmt|;
if|if
condition|(
name|k1
operator|==
literal|0
condition|)
block|{
name|remainder0
operator|=
literal|0
expr_stmt|;
name|remainderDigitCount
operator|=
name|LONGWORD_DECIMAL_DIGITS
operator|+
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|fastLongWordTrailingZeroCount
argument_list|(
name|remainder1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|remainderSubexpr0
operator|=
name|k2
operator|*
name|MULTIPLER_LONGWORD_DECIMAL
expr_stmt|;
name|remainder0
operator|=
name|remainderSubexpr0
operator|/
name|rightFast0
expr_stmt|;
name|remainderDigitCount
operator|=
name|TWO_X_LONGWORD_DECIMAL_DIGITS
operator|+
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|fastLongWordTrailingZeroCount
argument_list|(
name|remainder0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fastResult
operator|.
name|fast0
operator|=
name|remainder0
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|remainder1
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|remainder2
expr_stmt|;
return|return
name|remainderDigitCount
return|;
block|}
comment|// EXPERIMENT
specifier|private
specifier|static
name|boolean
name|fastSingleWordDivision
parameter_list|(
name|int
name|leftSignum
parameter_list|,
name|long
name|leftFast0
parameter_list|,
name|long
name|leftFast1
parameter_list|,
name|long
name|leftFast2
parameter_list|,
name|int
name|leftScale
parameter_list|,
name|int
name|rightSignum
parameter_list|,
name|long
name|rightFast0
parameter_list|,
name|int
name|rightScale
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
name|long
name|remainderSubexpr2
init|=
name|doSingleWordQuotient
argument_list|(
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
name|rightFast0
argument_list|,
name|fastResult
argument_list|)
decl_stmt|;
name|long
name|quotient0
init|=
name|fastResult
operator|.
name|fast0
decl_stmt|;
name|long
name|quotient1
init|=
name|fastResult
operator|.
name|fast1
decl_stmt|;
name|long
name|quotient2
init|=
name|fastResult
operator|.
name|fast2
decl_stmt|;
name|int
name|quotientDigitCount
decl_stmt|;
if|if
condition|(
name|quotient2
operator|!=
literal|0
condition|)
block|{
name|quotientDigitCount
operator|=
name|fastLongWordPrecision
argument_list|(
name|quotient2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|quotient1
operator|!=
literal|0
condition|)
block|{
name|quotientDigitCount
operator|=
name|fastLongWordPrecision
argument_list|(
name|quotient1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|quotientDigitCount
operator|=
name|fastLongWordPrecision
argument_list|(
name|quotient0
argument_list|)
expr_stmt|;
block|}
name|int
name|remainderDigitCount
init|=
name|doSingleWordRemainder
argument_list|(
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
name|rightFast0
argument_list|,
name|remainderSubexpr2
argument_list|,
name|fastResult
argument_list|)
decl_stmt|;
name|long
name|remainder0
init|=
name|fastResult
operator|.
name|fast0
decl_stmt|;
name|long
name|remainder1
init|=
name|fastResult
operator|.
name|fast1
decl_stmt|;
name|long
name|remainder2
init|=
name|fastResult
operator|.
name|fast2
decl_stmt|;
name|fastResult
operator|.
name|fast0
operator|=
name|quotient0
expr_stmt|;
name|fastResult
operator|.
name|fast1
operator|=
name|quotient1
expr_stmt|;
name|fastResult
operator|.
name|fast2
operator|=
name|quotient2
expr_stmt|;
specifier|final
name|int
name|quotientScale
init|=
name|leftScale
operator|+
name|rightScale
decl_stmt|;
if|if
condition|(
name|remainderDigitCount
operator|==
literal|0
condition|)
block|{
name|fastResult
operator|.
name|fastScale
operator|=
name|quotientScale
expr_stmt|;
block|}
else|else
block|{
name|int
name|resultScale
init|=
name|quotientScale
operator|+
name|remainderDigitCount
decl_stmt|;
name|int
name|adjustedQuotientDigitCount
decl_stmt|;
if|if
condition|(
name|quotientScale
operator|>
literal|0
condition|)
block|{
name|adjustedQuotientDigitCount
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|quotientDigitCount
operator|-
name|quotientScale
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|adjustedQuotientDigitCount
operator|=
name|quotientDigitCount
expr_stmt|;
block|}
specifier|final
name|int
name|maxScale
init|=
name|HiveDecimal
operator|.
name|MAX_SCALE
operator|-
name|adjustedQuotientDigitCount
decl_stmt|;
name|int
name|scale
init|=
name|Math
operator|.
name|min
argument_list|(
name|resultScale
argument_list|,
name|maxScale
argument_list|)
decl_stmt|;
name|int
name|remainderScale
decl_stmt|;
name|remainderScale
operator|=
name|Math
operator|.
name|min
argument_list|(
name|remainderDigitCount
argument_list|,
name|maxScale
operator|-
name|quotientScale
argument_list|)
expr_stmt|;
if|if
condition|(
name|remainderScale
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|quotientDigitCount
operator|>
literal|0
condition|)
block|{
comment|// Make room for remainder.
name|fastScaleUp
argument_list|(
name|fastResult
argument_list|,
name|remainderScale
argument_list|,
name|fastResult
argument_list|)
expr_stmt|;
block|}
comment|// Copy in remainder digits... which start at the top of remainder2.
if|if
condition|(
name|remainderScale
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
specifier|final
name|long
name|remainderDivisor2
init|=
name|powerOfTenTable
index|[
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|remainderScale
index|]
decl_stmt|;
name|fastResult
operator|.
name|fast0
operator|+=
operator|(
name|remainder2
operator|/
name|remainderDivisor2
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|remainderScale
operator|==
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
name|fastResult
operator|.
name|fast0
operator|=
name|remainder2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|remainderScale
operator|<
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
specifier|final
name|long
name|remainderDivisor2
init|=
name|powerOfTenTable
index|[
name|remainderScale
operator|-
name|LONGWORD_DECIMAL_DIGITS
index|]
decl_stmt|;
name|fastResult
operator|.
name|fast1
operator|+=
operator|(
name|remainder2
operator|/
name|remainderDivisor2
operator|)
expr_stmt|;
name|fastResult
operator|.
name|fast0
operator|=
name|remainder1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|remainderScale
operator|==
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
name|fastResult
operator|.
name|fast1
operator|=
name|remainder2
expr_stmt|;
name|fastResult
operator|.
name|fast0
operator|=
name|remainder1
expr_stmt|;
block|}
block|}
comment|// UNDONE: Method is still under development.
name|fastResult
operator|.
name|fastScale
operator|=
name|scale
expr_stmt|;
comment|// UNDONE: Trim trailing zeroes...
block|}
return|return
literal|true
return|;
block|}
specifier|public
specifier|static
name|boolean
name|fastDivide
parameter_list|(
name|FastHiveDecimal
name|fastLeft
parameter_list|,
name|FastHiveDecimal
name|fastRight
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
return|return
name|fastDivide
argument_list|(
name|fastLeft
operator|.
name|fastSignum
argument_list|,
name|fastLeft
operator|.
name|fast0
argument_list|,
name|fastLeft
operator|.
name|fast1
argument_list|,
name|fastLeft
operator|.
name|fast2
argument_list|,
name|fastLeft
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastLeft
operator|.
name|fastScale
argument_list|,
name|fastRight
operator|.
name|fastSignum
argument_list|,
name|fastRight
operator|.
name|fast0
argument_list|,
name|fastRight
operator|.
name|fast1
argument_list|,
name|fastRight
operator|.
name|fast2
argument_list|,
name|fastRight
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastRight
operator|.
name|fastScale
argument_list|,
name|fastResult
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|fastDivide
parameter_list|(
name|int
name|leftSignum
parameter_list|,
name|long
name|leftFast0
parameter_list|,
name|long
name|leftFast1
parameter_list|,
name|long
name|leftFast2
parameter_list|,
name|int
name|leftIntegerDigitCount
parameter_list|,
name|int
name|leftScale
parameter_list|,
name|int
name|rightSignum
parameter_list|,
name|long
name|rightFast0
parameter_list|,
name|long
name|rightFast1
parameter_list|,
name|long
name|rightFast2
parameter_list|,
name|int
name|rightIntegerDigitCount
parameter_list|,
name|int
name|rightScale
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
comment|// Arithmetic operations reset the results.
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
if|if
condition|(
name|rightSignum
operator|==
literal|0
condition|)
block|{
comment|// Division by 0.
return|return
literal|false
return|;
block|}
if|if
condition|(
name|leftSignum
operator|==
literal|0
condition|)
block|{
comment|// Zero result.
return|return
literal|true
return|;
block|}
comment|/*     if (rightFast1 == 0&& rightFast2 == 0) {       return fastSingleWordDivision(           leftSignum, leftFast0, leftFast1, leftFast2, leftScale,           rightSignum, rightFast0, rightScale,           fastResult);     }     */
name|BigDecimal
name|denominator
init|=
name|fastBigDecimalValue
argument_list|(
name|leftSignum
argument_list|,
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
name|leftIntegerDigitCount
argument_list|,
name|leftScale
argument_list|)
decl_stmt|;
name|BigDecimal
name|divisor
init|=
name|fastBigDecimalValue
argument_list|(
name|rightSignum
argument_list|,
name|rightFast0
argument_list|,
name|rightFast1
argument_list|,
name|rightFast2
argument_list|,
name|rightIntegerDigitCount
argument_list|,
name|rightScale
argument_list|)
decl_stmt|;
name|BigDecimal
name|quotient
init|=
name|denominator
operator|.
name|divide
argument_list|(
name|divisor
argument_list|,
name|HiveDecimal
operator|.
name|MAX_SCALE
argument_list|,
name|BigDecimal
operator|.
name|ROUND_HALF_UP
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fastSetFromBigDecimal
argument_list|(
name|quotient
argument_list|,
literal|true
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
specifier|static
name|boolean
name|fastRemainder
parameter_list|(
name|int
name|leftSignum
parameter_list|,
name|long
name|leftFast0
parameter_list|,
name|long
name|leftFast1
parameter_list|,
name|long
name|leftFast2
parameter_list|,
name|int
name|leftIntegerDigitCount
parameter_list|,
name|int
name|leftScale
parameter_list|,
name|int
name|rightSignum
parameter_list|,
name|long
name|rightFast0
parameter_list|,
name|long
name|rightFast1
parameter_list|,
name|long
name|rightFast2
parameter_list|,
name|int
name|rightIntegerDigitCount
parameter_list|,
name|int
name|rightScale
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
comment|// Arithmetic operations reset the results.
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
if|if
condition|(
name|rightSignum
operator|==
literal|0
condition|)
block|{
comment|// Division by 0.
return|return
literal|false
return|;
block|}
if|if
condition|(
name|leftSignum
operator|==
literal|0
condition|)
block|{
comment|// Zero result.
return|return
literal|true
return|;
block|}
name|BigDecimal
name|denominator
init|=
name|fastBigDecimalValue
argument_list|(
name|leftSignum
argument_list|,
name|leftFast0
argument_list|,
name|leftFast1
argument_list|,
name|leftFast2
argument_list|,
name|leftIntegerDigitCount
argument_list|,
name|leftScale
argument_list|)
decl_stmt|;
name|BigDecimal
name|divisor
init|=
name|fastBigDecimalValue
argument_list|(
name|rightSignum
argument_list|,
name|rightFast0
argument_list|,
name|rightFast1
argument_list|,
name|rightFast2
argument_list|,
name|rightIntegerDigitCount
argument_list|,
name|rightScale
argument_list|)
decl_stmt|;
name|BigDecimal
name|remainder
init|=
name|denominator
operator|.
name|remainder
argument_list|(
name|divisor
argument_list|)
decl_stmt|;
name|fastResult
operator|.
name|fastReset
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fastSetFromBigDecimal
argument_list|(
name|remainder
argument_list|,
literal|true
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
specifier|static
name|boolean
name|fastPow
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|exponent
parameter_list|,
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
comment|// Arithmetic operations (re)set the results.
name|fastResult
operator|.
name|fastSet
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|)
expr_stmt|;
if|if
condition|(
name|exponent
operator|<
literal|0
condition|)
block|{
comment|// UNDONE: Currently, negative exponent is not supported.
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|e
init|=
literal|1
init|;
name|e
operator|<
name|exponent
condition|;
name|e
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|doMultiply
argument_list|(
name|fastResult
operator|.
name|fastSignum
argument_list|,
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
name|fastResult
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastResult
operator|.
name|fastScale
argument_list|,
name|fastResult
operator|.
name|fastSignum
argument_list|,
name|fastResult
operator|.
name|fast0
argument_list|,
name|fastResult
operator|.
name|fast1
argument_list|,
name|fastResult
operator|.
name|fast2
argument_list|,
name|fastResult
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastResult
operator|.
name|fastScale
argument_list|,
name|fastResult
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|//************************************************************************************************
comment|// Decimal String Formatting.
specifier|public
specifier|static
name|String
name|fastToFormatString
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|formatScale
parameter_list|)
block|{
name|byte
index|[]
name|scratchBuffer
init|=
operator|new
name|byte
index|[
name|FAST_SCRATCH_BUFFER_LEN_TO_BYTES
index|]
decl_stmt|;
specifier|final
name|int
name|index
init|=
name|doFastToFormatBytes
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|,
name|formatScale
argument_list|,
name|scratchBuffer
argument_list|)
decl_stmt|;
return|return
operator|new
name|String
argument_list|(
name|scratchBuffer
argument_list|,
name|index
argument_list|,
name|FAST_SCRATCH_BUFFER_LEN_TO_BYTES
operator|-
name|index
argument_list|)
return|;
block|}
comment|//************************************************************************************************
comment|// Decimal String Formatting.
specifier|public
specifier|static
name|String
name|fastToFormatString
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|formatScale
parameter_list|,
name|byte
index|[]
name|scratchBuffer
parameter_list|)
block|{
specifier|final
name|int
name|index
init|=
name|doFastToBytes
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|,
name|formatScale
argument_list|,
name|scratchBuffer
argument_list|)
decl_stmt|;
return|return
operator|new
name|String
argument_list|(
name|scratchBuffer
argument_list|,
name|index
argument_list|,
name|scratchBuffer
operator|.
name|length
operator|-
name|index
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|fastToFormatBytes
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|formatScale
parameter_list|,
name|byte
index|[]
name|scratchBuffer
parameter_list|)
block|{
return|return
name|doFastToFormatBytes
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|,
name|formatScale
argument_list|,
name|scratchBuffer
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|doFastToFormatBytes
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|formatScale
parameter_list|,
name|byte
index|[]
name|scratchBuffer
parameter_list|)
block|{
comment|// NOTE: OldHiveDecimal.toFormatString returns decimal strings with more than> 38 digits!
if|if
condition|(
name|formatScale
operator|>=
name|fastScale
condition|)
block|{
return|return
name|doFastToBytes
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|,
name|formatScale
argument_list|,
name|scratchBuffer
argument_list|)
return|;
block|}
else|else
block|{
name|FastHiveDecimal
name|fastTemp
init|=
operator|new
name|FastHiveDecimal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fastRound
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|,
name|formatScale
argument_list|,
name|BigDecimal
operator|.
name|ROUND_HALF_UP
argument_list|,
name|fastTemp
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|doFastToBytes
argument_list|(
name|fastTemp
operator|.
name|fastSignum
argument_list|,
name|fastTemp
operator|.
name|fast0
argument_list|,
name|fastTemp
operator|.
name|fast1
argument_list|,
name|fastTemp
operator|.
name|fast2
argument_list|,
name|fastTemp
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastTemp
operator|.
name|fastScale
argument_list|,
name|formatScale
argument_list|,
name|scratchBuffer
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
name|String
name|fastToString
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|fastTrailingZeroesScale
parameter_list|)
block|{
return|return
name|doFastToString
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|,
name|fastTrailingZeroesScale
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|String
name|fastToString
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|fastTrailingZeroesScale
parameter_list|,
name|byte
index|[]
name|scratchBuffer
parameter_list|)
block|{
return|return
name|doFastToString
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|,
name|fastTrailingZeroesScale
argument_list|,
name|scratchBuffer
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|String
name|fastToDigitsOnlyString
parameter_list|(
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|)
block|{
name|byte
index|[]
name|scratchBuffer
init|=
operator|new
name|byte
index|[
name|FAST_SCRATCH_BUFFER_LEN_TO_BYTES
index|]
decl_stmt|;
specifier|final
name|int
name|index
init|=
name|doFastToDigitsOnlyBytes
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|scratchBuffer
argument_list|)
decl_stmt|;
return|return
operator|new
name|String
argument_list|(
name|scratchBuffer
argument_list|,
name|index
argument_list|,
name|FAST_SCRATCH_BUFFER_LEN_TO_BYTES
operator|-
name|index
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|fastToBytes
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|fastTrailingZeroesScale
parameter_list|,
name|byte
index|[]
name|scratchBuffer
parameter_list|)
block|{
return|return
name|doFastToBytes
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|,
name|fastTrailingZeroesScale
argument_list|,
name|scratchBuffer
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|String
name|doFastToString
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|fastTrailingZeroesScale
parameter_list|)
block|{
name|byte
index|[]
name|scratchBuffer
init|=
operator|new
name|byte
index|[
name|FAST_SCRATCH_BUFFER_LEN_TO_BYTES
index|]
decl_stmt|;
specifier|final
name|int
name|index
init|=
name|doFastToBytes
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|,
name|fastTrailingZeroesScale
argument_list|,
name|scratchBuffer
argument_list|)
decl_stmt|;
return|return
operator|new
name|String
argument_list|(
name|scratchBuffer
argument_list|,
name|index
argument_list|,
name|FAST_SCRATCH_BUFFER_LEN_TO_BYTES
operator|-
name|index
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|String
name|doFastToString
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|fastTrailingZeroesScale
parameter_list|,
name|byte
index|[]
name|scratchBuffer
parameter_list|)
block|{
specifier|final
name|int
name|index
init|=
name|doFastToBytes
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|,
name|fastTrailingZeroesScale
argument_list|,
name|scratchBuffer
argument_list|)
decl_stmt|;
return|return
operator|new
name|String
argument_list|(
name|scratchBuffer
argument_list|,
name|index
argument_list|,
name|scratchBuffer
operator|.
name|length
operator|-
name|index
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|doFastToBytes
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|,
name|int
name|fastTrailingZeroesScale
parameter_list|,
name|byte
index|[]
name|scratchBuffer
parameter_list|)
block|{
name|int
name|index
init|=
name|scratchBuffer
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|int
name|trailingZeroCount
init|=
operator|(
name|fastTrailingZeroesScale
operator|!=
operator|-
literal|1
condition|?
name|fastTrailingZeroesScale
operator|-
name|fastScale
else|:
literal|0
operator|)
decl_stmt|;
comment|// Virtual trailing zeroes.
if|if
condition|(
name|trailingZeroCount
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|trailingZeroCount
condition|;
name|i
operator|++
control|)
block|{
name|scratchBuffer
index|[
name|index
operator|--
index|]
operator|=
name|BYTE_DIGIT_ZERO
expr_stmt|;
block|}
block|}
comment|// Scale fractional digits, dot, integer digits.
specifier|final
name|int
name|scale
init|=
name|fastScale
decl_stmt|;
specifier|final
name|boolean
name|isZeroFast1AndFast2
init|=
operator|(
name|fast1
operator|==
literal|0
operator|&&
name|fast2
operator|==
literal|0
operator|)
decl_stmt|;
specifier|final
name|boolean
name|isZeroFast2
init|=
operator|(
name|fast2
operator|==
literal|0
operator|)
decl_stmt|;
name|int
name|lowerLongwordScale
init|=
literal|0
decl_stmt|;
name|int
name|middleLongwordScale
init|=
literal|0
decl_stmt|;
name|int
name|highLongwordScale
init|=
literal|0
decl_stmt|;
name|long
name|longWord
init|=
name|fast0
decl_stmt|;
if|if
condition|(
name|scale
operator|>
literal|0
condition|)
block|{
comment|// Fraction digits from lower longword.
name|lowerLongwordScale
operator|=
name|Math
operator|.
name|min
argument_list|(
name|scale
argument_list|,
name|LONGWORD_DECIMAL_DIGITS
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lowerLongwordScale
condition|;
name|i
operator|++
control|)
block|{
name|scratchBuffer
index|[
name|index
operator|--
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|BYTE_DIGIT_ZERO
operator|+
name|longWord
operator|%
literal|10
argument_list|)
expr_stmt|;
name|longWord
operator|/=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|lowerLongwordScale
operator|==
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
name|longWord
operator|=
name|fast1
expr_stmt|;
block|}
if|if
condition|(
name|scale
operator|>
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Fraction digits continue into middle longword.
name|middleLongwordScale
operator|=
name|Math
operator|.
name|min
argument_list|(
name|scale
operator|-
name|LONGWORD_DECIMAL_DIGITS
argument_list|,
name|LONGWORD_DECIMAL_DIGITS
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|middleLongwordScale
condition|;
name|i
operator|++
control|)
block|{
name|scratchBuffer
index|[
name|index
operator|--
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|BYTE_DIGIT_ZERO
operator|+
name|longWord
operator|%
literal|10
argument_list|)
expr_stmt|;
name|longWord
operator|/=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|middleLongwordScale
operator|==
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
name|longWord
operator|=
name|fast2
expr_stmt|;
block|}
if|if
condition|(
name|scale
operator|>
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Fraction digit continue into highest longword.
name|highLongwordScale
operator|=
name|scale
operator|-
name|TWO_X_LONGWORD_DECIMAL_DIGITS
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|highLongwordScale
condition|;
name|i
operator|++
control|)
block|{
name|scratchBuffer
index|[
name|index
operator|--
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|BYTE_DIGIT_ZERO
operator|+
name|longWord
operator|%
literal|10
argument_list|)
expr_stmt|;
name|longWord
operator|/=
literal|10
expr_stmt|;
block|}
block|}
block|}
name|scratchBuffer
index|[
name|index
operator|--
index|]
operator|=
name|BYTE_DOT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|trailingZeroCount
operator|>
literal|0
condition|)
block|{
name|scratchBuffer
index|[
name|index
operator|--
index|]
operator|=
name|BYTE_DOT
expr_stmt|;
block|}
comment|// Integer digits; stop on zeroes above.
name|boolean
name|atLeastOneIntegerDigit
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|scale
operator|<=
name|LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Handle remaining lower long word digits as integer digits.
specifier|final
name|int
name|remainingLowerLongwordDigits
init|=
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|lowerLongwordScale
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|remainingLowerLongwordDigits
condition|;
name|i
operator|++
control|)
block|{
name|scratchBuffer
index|[
name|index
operator|--
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|BYTE_DIGIT_ZERO
operator|+
name|longWord
operator|%
literal|10
argument_list|)
expr_stmt|;
name|atLeastOneIntegerDigit
operator|=
literal|true
expr_stmt|;
name|longWord
operator|/=
literal|10
expr_stmt|;
if|if
condition|(
name|longWord
operator|==
literal|0
operator|&&
name|isZeroFast1AndFast2
condition|)
block|{
comment|// Suppress leading zeroes.
break|break;
block|}
block|}
if|if
condition|(
name|isZeroFast1AndFast2
condition|)
block|{
if|if
condition|(
operator|!
name|atLeastOneIntegerDigit
condition|)
block|{
name|scratchBuffer
index|[
name|index
operator|--
index|]
operator|=
name|BYTE_DIGIT_ZERO
expr_stmt|;
block|}
if|if
condition|(
name|fastSignum
operator|==
operator|-
literal|1
condition|)
block|{
name|scratchBuffer
index|[
name|index
operator|--
index|]
operator|=
name|BYTE_MINUS
expr_stmt|;
block|}
return|return
name|index
operator|+
literal|1
return|;
block|}
name|longWord
operator|=
name|fast1
expr_stmt|;
block|}
if|if
condition|(
name|scale
operator|<=
name|TWO_X_LONGWORD_DECIMAL_DIGITS
condition|)
block|{
comment|// Handle remaining middle long word digits.
specifier|final
name|int
name|remainingMiddleLongwordDigits
init|=
name|LONGWORD_DECIMAL_DIGITS
operator|-
name|middleLongwordScale
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|remainingMiddleLongwordDigits
condition|;
name|i
operator|++
control|)
block|{
name|scratchBuffer
index|[
name|index
operator|--
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|BYTE_DIGIT_ZERO
operator|+
name|longWord
operator|%
literal|10
argument_list|)
expr_stmt|;
name|atLeastOneIntegerDigit
operator|=
literal|true
expr_stmt|;
name|longWord
operator|/=
literal|10
expr_stmt|;
if|if
condition|(
name|longWord
operator|==
literal|0
operator|&&
name|isZeroFast2
condition|)
block|{
comment|// Suppress leading zeroes.
break|break;
block|}
block|}
if|if
condition|(
name|isZeroFast2
condition|)
block|{
if|if
condition|(
operator|!
name|atLeastOneIntegerDigit
condition|)
block|{
name|scratchBuffer
index|[
name|index
operator|--
index|]
operator|=
name|BYTE_DIGIT_ZERO
expr_stmt|;
block|}
if|if
condition|(
name|fastSignum
operator|==
operator|-
literal|1
condition|)
block|{
name|scratchBuffer
index|[
name|index
operator|--
index|]
operator|=
name|BYTE_MINUS
expr_stmt|;
block|}
return|return
name|index
operator|+
literal|1
return|;
block|}
name|longWord
operator|=
name|fast2
expr_stmt|;
block|}
specifier|final
name|int
name|remainingHighwordDigits
init|=
name|HIGHWORD_DECIMAL_DIGITS
operator|-
name|highLongwordScale
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|remainingHighwordDigits
condition|;
name|i
operator|++
control|)
block|{
name|scratchBuffer
index|[
name|index
operator|--
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|BYTE_DIGIT_ZERO
operator|+
name|longWord
operator|%
literal|10
argument_list|)
expr_stmt|;
name|atLeastOneIntegerDigit
operator|=
literal|true
expr_stmt|;
name|longWord
operator|/=
literal|10
expr_stmt|;
if|if
condition|(
name|longWord
operator|==
literal|0
condition|)
block|{
comment|// Suppress leading zeroes.
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|atLeastOneIntegerDigit
condition|)
block|{
name|scratchBuffer
index|[
name|index
operator|--
index|]
operator|=
name|BYTE_DIGIT_ZERO
expr_stmt|;
block|}
if|if
condition|(
name|fastSignum
operator|==
operator|-
literal|1
condition|)
block|{
name|scratchBuffer
index|[
name|index
operator|--
index|]
operator|=
name|BYTE_MINUS
expr_stmt|;
block|}
return|return
name|index
operator|+
literal|1
return|;
block|}
specifier|public
specifier|static
name|int
name|fastToDigitsOnlyBytes
parameter_list|(
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|byte
index|[]
name|scratchBuffer
parameter_list|)
block|{
return|return
name|doFastToDigitsOnlyBytes
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|scratchBuffer
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|doFastToDigitsOnlyBytes
parameter_list|(
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|byte
index|[]
name|scratchBuffer
parameter_list|)
block|{
name|int
name|index
init|=
name|scratchBuffer
operator|.
name|length
operator|-
literal|1
decl_stmt|;
comment|// Just digits.
specifier|final
name|boolean
name|isZeroFast1AndFast2
init|=
operator|(
name|fast1
operator|==
literal|0
operator|&&
name|fast2
operator|==
literal|0
operator|)
decl_stmt|;
specifier|final
name|boolean
name|isZeroFast2
init|=
operator|(
name|fast2
operator|==
literal|0
operator|)
decl_stmt|;
name|boolean
name|atLeastOneIntegerDigit
init|=
literal|false
decl_stmt|;
name|long
name|longWord
init|=
name|fast0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|;
name|i
operator|++
control|)
block|{
name|scratchBuffer
index|[
name|index
operator|--
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|BYTE_DIGIT_ZERO
operator|+
name|longWord
operator|%
literal|10
argument_list|)
expr_stmt|;
name|atLeastOneIntegerDigit
operator|=
literal|true
expr_stmt|;
name|longWord
operator|/=
literal|10
expr_stmt|;
if|if
condition|(
name|longWord
operator|==
literal|0
operator|&&
name|isZeroFast1AndFast2
condition|)
block|{
comment|// Suppress leading zeroes.
break|break;
block|}
block|}
if|if
condition|(
name|isZeroFast1AndFast2
condition|)
block|{
if|if
condition|(
operator|!
name|atLeastOneIntegerDigit
condition|)
block|{
name|scratchBuffer
index|[
name|index
operator|--
index|]
operator|=
name|BYTE_DIGIT_ZERO
expr_stmt|;
block|}
return|return
name|index
operator|+
literal|1
return|;
block|}
name|longWord
operator|=
name|fast1
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LONGWORD_DECIMAL_DIGITS
condition|;
name|i
operator|++
control|)
block|{
name|scratchBuffer
index|[
name|index
operator|--
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|BYTE_DIGIT_ZERO
operator|+
name|longWord
operator|%
literal|10
argument_list|)
expr_stmt|;
name|atLeastOneIntegerDigit
operator|=
literal|true
expr_stmt|;
name|longWord
operator|/=
literal|10
expr_stmt|;
if|if
condition|(
name|longWord
operator|==
literal|0
operator|&&
name|isZeroFast2
condition|)
block|{
comment|// Suppress leading zeroes.
break|break;
block|}
block|}
if|if
condition|(
name|isZeroFast2
condition|)
block|{
if|if
condition|(
operator|!
name|atLeastOneIntegerDigit
condition|)
block|{
name|scratchBuffer
index|[
name|index
operator|--
index|]
operator|=
name|BYTE_DIGIT_ZERO
expr_stmt|;
block|}
return|return
name|index
operator|+
literal|1
return|;
block|}
name|longWord
operator|=
name|fast2
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|HIGHWORD_DECIMAL_DIGITS
condition|;
name|i
operator|++
control|)
block|{
name|scratchBuffer
index|[
name|index
operator|--
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|BYTE_DIGIT_ZERO
operator|+
name|longWord
operator|%
literal|10
argument_list|)
expr_stmt|;
name|atLeastOneIntegerDigit
operator|=
literal|true
expr_stmt|;
name|longWord
operator|/=
literal|10
expr_stmt|;
if|if
condition|(
name|longWord
operator|==
literal|0
condition|)
block|{
comment|// Suppress leading zeroes.
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|atLeastOneIntegerDigit
condition|)
block|{
name|scratchBuffer
index|[
name|index
operator|--
index|]
operator|=
name|BYTE_DIGIT_ZERO
expr_stmt|;
block|}
return|return
name|index
operator|+
literal|1
return|;
block|}
comment|//************************************************************************************************
comment|// Decimal Validation.
specifier|public
specifier|static
name|boolean
name|fastIsValid
parameter_list|(
name|FastHiveDecimal
name|fastDec
parameter_list|)
block|{
return|return
name|fastIsValid
argument_list|(
name|fastDec
operator|.
name|fastSignum
argument_list|,
name|fastDec
operator|.
name|fast0
argument_list|,
name|fastDec
operator|.
name|fast1
argument_list|,
name|fastDec
operator|.
name|fast2
argument_list|,
name|fastDec
operator|.
name|fastIntegerDigitCount
argument_list|,
name|fastDec
operator|.
name|fastScale
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|fastIsValid
parameter_list|(
name|int
name|fastSignum
parameter_list|,
name|long
name|fast0
parameter_list|,
name|long
name|fast1
parameter_list|,
name|long
name|fast2
parameter_list|,
name|int
name|fastIntegerDigitCount
parameter_list|,
name|int
name|fastScale
parameter_list|)
block|{
name|boolean
name|isValid
decl_stmt|;
if|if
condition|(
name|fastSignum
operator|==
literal|0
condition|)
block|{
name|isValid
operator|=
operator|(
name|fast0
operator|==
literal|0
operator|&&
name|fast1
operator|==
literal|0
operator|&&
name|fast2
operator|==
literal|0
operator|&&
name|fastIntegerDigitCount
operator|==
literal|0
operator|&&
name|fastScale
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|isValid
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FAST_IS_VALID signum 0 but other fields not"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|isValid
operator|=
operator|(
operator|(
name|fast0
operator|>=
literal|0
operator|&&
name|fast0
operator|<=
name|MAX_LONGWORD_DECIMAL
operator|)
operator|&&
operator|(
name|fast1
operator|>=
literal|0
operator|&&
name|fast1
operator|<=
name|MAX_LONGWORD_DECIMAL
operator|)
operator|&&
operator|(
name|fast2
operator|>=
literal|0
operator|&&
name|fast2
operator|<=
name|MAX_HIGHWORD_DECIMAL
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|isValid
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FAST_IS_VALID fast0 .. fast2 out of range"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fastScale
argument_list|<
literal|0
operator|||
name|fastScale
argument_list|>
name|HiveDecimal
operator|.
name|MAX_SCALE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FAST_IS_VALID fastScale "
operator|+
name|fastScale
operator|+
literal|" out of range"
argument_list|)
expr_stmt|;
name|isValid
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fastIntegerDigitCount
argument_list|<
literal|0
operator|||
name|fastIntegerDigitCount
argument_list|>
name|HiveDecimal
operator|.
name|MAX_PRECISION
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FAST_IS_VALID fastIntegerDigitCount "
operator|+
name|fastIntegerDigitCount
operator|+
literal|" out of range"
argument_list|)
expr_stmt|;
name|isValid
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fastIntegerDigitCount
operator|+
name|fastScale
operator|>
name|HiveDecimal
operator|.
name|MAX_PRECISION
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FAST_IS_VALID exceeds max precision: fastIntegerDigitCount "
operator|+
name|fastIntegerDigitCount
operator|+
literal|" and fastScale "
operator|+
name|fastScale
argument_list|)
expr_stmt|;
name|isValid
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|// Verify integerDigitCount given fastScale.
specifier|final
name|int
name|rawPrecision
init|=
name|fastRawPrecision
argument_list|(
name|fastSignum
argument_list|,
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|)
decl_stmt|;
if|if
condition|(
name|fastIntegerDigitCount
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rawPrecision
operator|!=
name|fastIntegerDigitCount
operator|+
name|fastScale
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FAST_IS_VALID integer case: rawPrecision "
operator|+
name|rawPrecision
operator|+
literal|" fastIntegerDigitCount "
operator|+
name|fastIntegerDigitCount
operator|+
literal|" fastScale "
operator|+
name|fastScale
argument_list|)
expr_stmt|;
name|isValid
operator|=
literal|false
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|rawPrecision
operator|>
name|fastScale
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FAST_IS_VALID fraction only case: rawPrecision "
operator|+
name|rawPrecision
operator|+
literal|" fastIntegerDigitCount "
operator|+
name|fastIntegerDigitCount
operator|+
literal|" fastScale "
operator|+
name|fastScale
argument_list|)
expr_stmt|;
name|isValid
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isValid
condition|)
block|{
specifier|final
name|int
name|trailingZeroCount
init|=
name|fastTrailingDecimalZeroCount
argument_list|(
name|fast0
argument_list|,
name|fast1
argument_list|,
name|fast2
argument_list|,
name|fastIntegerDigitCount
argument_list|,
name|fastScale
argument_list|)
decl_stmt|;
if|if
condition|(
name|trailingZeroCount
operator|!=
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FAST_IS_VALID exceeds max precision: trailingZeroCount != 0"
argument_list|)
expr_stmt|;
name|isValid
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|isValid
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FAST_IS_VALID fast0 "
operator|+
name|fast0
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FAST_IS_VALID fast1 "
operator|+
name|fast1
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FAST_IS_VALID fast2 "
operator|+
name|fast2
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FAST_IS_VALID fastIntegerDigitCount "
operator|+
name|fastIntegerDigitCount
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FAST_IS_VALID fastScale "
operator|+
name|fastScale
argument_list|)
expr_stmt|;
block|}
return|return
name|isValid
return|;
block|}
specifier|public
specifier|static
name|void
name|fastRaiseInvalidException
parameter_list|(
name|FastHiveDecimal
name|fastResult
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid fast decimal "
operator|+
literal|" fastSignum "
operator|+
name|fastResult
operator|.
name|fastSignum
operator|+
literal|" fast0 "
operator|+
name|fastResult
operator|.
name|fast0
operator|+
literal|" fast1 "
operator|+
name|fastResult
operator|.
name|fast1
operator|+
literal|" fast2 "
operator|+
name|fastResult
operator|.
name|fast2
operator|+
literal|" fastIntegerDigitCount "
operator|+
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|+
literal|" fastScale "
operator|+
name|fastResult
operator|.
name|fastScale
operator|+
literal|" stack trace: "
operator|+
name|getStackTraceAsSingleLine
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getStackTrace
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
specifier|public
specifier|static
name|void
name|fastRaiseInvalidException
parameter_list|(
name|FastHiveDecimal
name|fastResult
parameter_list|,
name|String
name|parameters
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Parameters: "
operator|+
name|parameters
operator|+
literal|" --> "
operator|+
literal|"Invalid fast decimal "
operator|+
literal|" fastSignum "
operator|+
name|fastResult
operator|.
name|fastSignum
operator|+
literal|" fast0 "
operator|+
name|fastResult
operator|.
name|fast0
operator|+
literal|" fast1 "
operator|+
name|fastResult
operator|.
name|fast1
operator|+
literal|" fast2 "
operator|+
name|fastResult
operator|.
name|fast2
operator|+
literal|" fastIntegerDigitCount "
operator|+
name|fastResult
operator|.
name|fastIntegerDigitCount
operator|+
literal|" fastScale "
operator|+
name|fastResult
operator|.
name|fastScale
operator|+
literal|" stack trace: "
operator|+
name|getStackTraceAsSingleLine
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getStackTrace
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|//************************************************************************************************
comment|// Decimal Debugging.
specifier|static
name|int
name|STACK_LENGTH_LIMIT
init|=
literal|20
decl_stmt|;
specifier|public
specifier|static
name|String
name|getStackTraceAsSingleLine
parameter_list|(
name|StackTraceElement
index|[]
name|stackTrace
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Stack trace: "
argument_list|)
expr_stmt|;
name|int
name|length
init|=
name|stackTrace
operator|.
name|length
decl_stmt|;
name|boolean
name|isTruncated
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|length
operator|>
name|STACK_LENGTH_LIMIT
condition|)
block|{
name|length
operator|=
name|STACK_LENGTH_LIMIT
expr_stmt|;
name|isTruncated
operator|=
literal|true
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|stackTrace
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isTruncated
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", ..."
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|String
name|displayBytes
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|start
operator|+
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"\\%03d"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|bytes
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

