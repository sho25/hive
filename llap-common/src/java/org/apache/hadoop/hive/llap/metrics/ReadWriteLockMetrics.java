begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License a  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|metrics
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReadWriteLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|MetricsCollector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|MetricsInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|MetricsSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|annotation
operator|.
name|Metric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|annotation
operator|.
name|Metrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|MutableCounterLong
import|;
end_import

begin_comment
comment|/**  * Wrapper around a read/write lock to collect the lock wait times.  * Instances of this wrapper class can be used to collect/accumulate the wai  * times around R/W locks. This is helpful if the source of a performance issue  * might be related to lock contention and you need to identify the actual  * locks. Instances of this class can be wrapped around any<code>ReadWriteLock  *</code> implementation.  */
end_comment

begin_class
specifier|public
class|class
name|ReadWriteLockMetrics
implements|implements
name|ReadWriteLock
block|{
specifier|private
name|LockWrapper
name|readLock
decl_stmt|;
comment|///< wrapper around original read lock
specifier|private
name|LockWrapper
name|writeLock
decl_stmt|;
comment|///< wrapper around original write lock
comment|/**    * Helper class to compare two<code>LockMetricSource</code> instances.    * This<code>Comparator</code> class can be used to sort a list of<code>    * LockMetricSource</code> instances in descending order by their total lock    * wait time.    */
specifier|public
specifier|static
class|class
name|MetricsComparator
implements|implements
name|Comparator
argument_list|<
name|MetricsSource
argument_list|>
implements|,
name|Serializable
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
operator|-
literal|1
decl_stmt|;
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|MetricsSource
name|o1
parameter_list|,
name|MetricsSource
name|o2
parameter_list|)
block|{
if|if
condition|(
name|o1
operator|!=
literal|null
operator|&&
name|o2
operator|!=
literal|null
operator|&&
name|o1
operator|instanceof
name|LockMetricSource
operator|&&
name|o2
operator|instanceof
name|LockMetricSource
condition|)
block|{
name|LockMetricSource
name|lms1
init|=
operator|(
name|LockMetricSource
operator|)
name|o1
decl_stmt|;
name|LockMetricSource
name|lms2
init|=
operator|(
name|LockMetricSource
operator|)
name|o2
decl_stmt|;
name|long
name|totalMs1
init|=
operator|(
name|lms1
operator|.
name|readLockWaitTimeTotal
operator|.
name|value
argument_list|()
operator|/
literal|1000000L
operator|)
operator|+
operator|(
name|lms1
operator|.
name|writeLockWaitTimeTotal
operator|.
name|value
argument_list|()
operator|/
literal|1000000L
operator|)
decl_stmt|;
name|long
name|totalMs2
init|=
operator|(
name|lms2
operator|.
name|readLockWaitTimeTotal
operator|.
name|value
argument_list|()
operator|/
literal|1000000L
operator|)
operator|+
operator|(
name|lms2
operator|.
name|writeLockWaitTimeTotal
operator|.
name|value
argument_list|()
operator|/
literal|1000000L
operator|)
decl_stmt|;
comment|// sort descending by total lock time
if|if
condition|(
name|totalMs1
operator|<
name|totalMs2
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|totalMs1
operator|>
name|totalMs2
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|// sort by label (ascending) if lock time is the same
return|return
name|lms1
operator|.
name|lockLabel
operator|.
name|compareTo
argument_list|(
name|lms2
operator|.
name|lockLabel
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
comment|/**    * Wraps a<code>ReadWriteLock</code> into a monitored lock if required by    * configuration. This helper is checking the<code>    * hive.llap.lockmetrics.collect</code> configuration option and wraps the    * passed in<code>ReadWriteLock</code> into a monitoring container if the    * option is set to<code>true</code>. Otherwise, the original (passed in)    * lock instance is returned unmodified.    *    * @param conf Configuration instance to check for LLAP conf options    * @param lock The<code>ReadWriteLock</code> to wrap for monitoring    * @param metrics The target container for locking metrics    * @see #createLockMetricsSource    */
specifier|public
specifier|static
name|ReadWriteLock
name|wrap
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|ReadWriteLock
name|lock
parameter_list|,
name|MetricsSource
name|metrics
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|lock
argument_list|,
literal|"Caller has to provide valid input lock"
argument_list|)
expr_stmt|;
name|boolean
name|needsWrap
init|=
literal|false
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|conf
condition|)
block|{
name|needsWrap
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|LLAP_COLLECT_LOCK_METRICS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
operator|==
name|needsWrap
condition|)
block|{
return|return
name|lock
return|;
block|}
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|metrics
argument_list|,
literal|"Caller has to procide group specific metrics source"
argument_list|)
expr_stmt|;
return|return
operator|new
name|ReadWriteLockMetrics
argument_list|(
name|lock
argument_list|,
name|metrics
argument_list|)
return|;
block|}
comment|/**    * Factory method for new metric collections.    * You can create and use a single<code>MetricsSource</code> collection for    * multiple R/W locks. This makes sense if several locks belong to a single    * group and you're then interested in the accumulated values for the whole    * group, rather than the single lock instance. The passed in label is    * supposed to identify the group uniquely.    *    * @param label The group identifier for lock statistics    */
specifier|public
specifier|static
name|MetricsSource
name|createLockMetricsSource
parameter_list|(
name|String
name|label
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|!
name|label
operator|.
name|contains
argument_list|(
literal|"\""
argument_list|)
argument_list|,
literal|"Label can't contain quote (\")"
argument_list|)
expr_stmt|;
return|return
operator|new
name|LockMetricSource
argument_list|(
name|label
argument_list|)
return|;
block|}
comment|/**    * Returns a list with all created<code>MetricsSource</code> instances for    * the R/W lock metrics. The returned list contains the instances that were    * previously created via the<code>createLockMetricsSource</code> function.    *    * @return A list of all R/W lock based metrics sources    */
specifier|public
specifier|static
name|List
argument_list|<
name|MetricsSource
argument_list|>
name|getAllMetricsSources
parameter_list|()
block|{
name|ArrayList
argument_list|<
name|MetricsSource
argument_list|>
name|ret
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|LockMetricSource
operator|.
name|allInstances
init|)
block|{
name|ret
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|LockMetricSource
operator|.
name|allInstances
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/// Enumeration of metric info names and descriptions
annotation|@
name|VisibleForTesting
specifier|public
enum|enum
name|LockMetricInfo
implements|implements
name|MetricsInfo
block|{
name|ReadLockWaitTimeTotal
argument_list|(
literal|"The total wait time for read locks in nanoseconds"
argument_list|)
block|,
name|ReadLockWaitTimeMax
argument_list|(
literal|"The maximum wait time for a read lock in nanoseconds"
argument_list|)
block|,
name|ReadLockCount
argument_list|(
literal|"Total amount of read lock requests"
argument_list|)
block|,
name|WriteLockWaitTimeTotal
argument_list|(
literal|"The total wait time for write locks in nanoseconds"
argument_list|)
block|,
name|WriteLockWaitTimeMax
argument_list|(
literal|"The maximum wait time for a write lock in nanoseconds"
argument_list|)
block|,
name|WriteLockCount
argument_list|(
literal|"Total amount of write lock requests"
argument_list|)
block|;
specifier|private
specifier|final
name|String
name|description
decl_stmt|;
comment|///< metric description
comment|/**      * Creates a new<code>MetricsInfo</code> with the given description.      *      * @param desc The description of the info      */
specifier|private
name|LockMetricInfo
parameter_list|(
name|String
name|desc
parameter_list|)
block|{
name|description
operator|=
name|desc
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|description
parameter_list|()
block|{
return|return
name|this
operator|.
name|description
return|;
block|}
block|}
comment|/**    * Source of the accumulated lock times and counts.    * Instances of this<code>MetricSource</code> can be created via the static    * factory method<code>createLockMetricsSource</code> and shared across    * multiple instances of the outer<code>ReadWriteLockMetric</code> class.    */
annotation|@
name|Metrics
argument_list|(
name|about
operator|=
literal|"Lock Metrics"
argument_list|,
name|context
operator|=
literal|"locking"
argument_list|)
specifier|private
specifier|static
class|class
name|LockMetricSource
implements|implements
name|MetricsSource
block|{
specifier|private
specifier|static
specifier|final
name|ArrayList
argument_list|<
name|MetricsSource
argument_list|>
name|allInstances
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|String
name|lockLabel
decl_stmt|;
comment|///< identifier for the group of locks
comment|/// accumulated wait time for read locks
annotation|@
name|Metric
name|MutableCounterLong
name|readLockWaitTimeTotal
decl_stmt|;
comment|/// highest wait time for read locks
annotation|@
name|Metric
name|MutableCounterLong
name|readLockWaitTimeMax
decl_stmt|;
comment|/// total number of read lock calls
annotation|@
name|Metric
name|MutableCounterLong
name|readLockCounts
decl_stmt|;
comment|/// accumulated wait time for write locks
annotation|@
name|Metric
name|MutableCounterLong
name|writeLockWaitTimeTotal
decl_stmt|;
comment|/// highest wait time for write locks
annotation|@
name|Metric
name|MutableCounterLong
name|writeLockWaitTimeMax
decl_stmt|;
comment|/// total number of write lock calls
annotation|@
name|Metric
name|MutableCounterLong
name|writeLockCounts
decl_stmt|;
comment|/**      * Creates a new metrics collection instance.      * Several locks can share a single<code>MetricsSource</code> instances      * where all of them  increment the metrics counts together. This can be      * interesting to have a single instance for a group of related locks. The      * group should then be identified by the label.      *      * @param label The identifier of the metrics collection      */
specifier|private
name|LockMetricSource
parameter_list|(
name|String
name|label
parameter_list|)
block|{
name|lockLabel
operator|=
name|label
expr_stmt|;
name|readLockWaitTimeTotal
operator|=
operator|new
name|MutableCounterLong
argument_list|(
name|LockMetricInfo
operator|.
name|ReadLockWaitTimeTotal
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|readLockWaitTimeMax
operator|=
operator|new
name|MutableCounterLong
argument_list|(
name|LockMetricInfo
operator|.
name|ReadLockWaitTimeMax
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|readLockCounts
operator|=
operator|new
name|MutableCounterLong
argument_list|(
name|LockMetricInfo
operator|.
name|ReadLockCount
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writeLockWaitTimeTotal
operator|=
operator|new
name|MutableCounterLong
argument_list|(
name|LockMetricInfo
operator|.
name|WriteLockWaitTimeTotal
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writeLockWaitTimeMax
operator|=
operator|new
name|MutableCounterLong
argument_list|(
name|LockMetricInfo
operator|.
name|WriteLockWaitTimeMax
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writeLockCounts
operator|=
operator|new
name|MutableCounterLong
argument_list|(
name|LockMetricInfo
operator|.
name|WriteLockCount
argument_list|,
literal|0
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|allInstances
init|)
block|{
name|allInstances
operator|.
name|add
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|getMetrics
parameter_list|(
name|MetricsCollector
name|collector
parameter_list|,
name|boolean
name|all
parameter_list|)
block|{
name|collector
operator|.
name|addRecord
argument_list|(
name|this
operator|.
name|lockLabel
argument_list|)
operator|.
name|setContext
argument_list|(
literal|"Locking"
argument_list|)
operator|.
name|addCounter
argument_list|(
name|LockMetricInfo
operator|.
name|ReadLockWaitTimeTotal
argument_list|,
name|readLockWaitTimeTotal
operator|.
name|value
argument_list|()
argument_list|)
operator|.
name|addCounter
argument_list|(
name|LockMetricInfo
operator|.
name|ReadLockWaitTimeMax
argument_list|,
name|readLockWaitTimeMax
operator|.
name|value
argument_list|()
argument_list|)
operator|.
name|addCounter
argument_list|(
name|LockMetricInfo
operator|.
name|ReadLockCount
argument_list|,
name|readLockCounts
operator|.
name|value
argument_list|()
argument_list|)
operator|.
name|addCounter
argument_list|(
name|LockMetricInfo
operator|.
name|WriteLockWaitTimeTotal
argument_list|,
name|writeLockWaitTimeTotal
operator|.
name|value
argument_list|()
argument_list|)
operator|.
name|addCounter
argument_list|(
name|LockMetricInfo
operator|.
name|WriteLockWaitTimeMax
argument_list|,
name|writeLockWaitTimeMax
operator|.
name|value
argument_list|()
argument_list|)
operator|.
name|addCounter
argument_list|(
name|LockMetricInfo
operator|.
name|WriteLockCount
argument_list|,
name|writeLockCounts
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|long
name|avgRead
init|=
literal|0L
decl_stmt|;
name|long
name|avgWrite
init|=
literal|0L
decl_stmt|;
name|long
name|totalMillis
init|=
literal|0L
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|readLockCounts
operator|.
name|value
argument_list|()
condition|)
block|{
name|avgRead
operator|=
name|readLockWaitTimeTotal
operator|.
name|value
argument_list|()
operator|/
name|readLockCounts
operator|.
name|value
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<
name|writeLockCounts
operator|.
name|value
argument_list|()
condition|)
block|{
name|avgWrite
operator|=
name|writeLockWaitTimeTotal
operator|.
name|value
argument_list|()
operator|/
name|writeLockCounts
operator|.
name|value
argument_list|()
expr_stmt|;
block|}
name|totalMillis
operator|=
operator|(
name|readLockWaitTimeTotal
operator|.
name|value
argument_list|()
operator|/
literal|1000000L
operator|)
operator|+
operator|(
name|writeLockWaitTimeTotal
operator|.
name|value
argument_list|()
operator|/
literal|1000000L
operator|)
expr_stmt|;
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"{ \"type\" : \"R/W Lock Stats\", \"label\" : \""
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|lockLabel
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\", \"totalLockWaitTimeMillis\" : "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|totalMillis
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", \"readLock\" : { \"count\" : "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|readLockCounts
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", \"avgWaitTimeNanos\" : "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|avgRead
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", \"maxWaitTimeNanos\" : "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|readLockWaitTimeMax
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" }, \"writeLock\" : { \"count\" : "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|writeLockCounts
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", \"avgWaitTimeNanos\" : "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|avgWrite
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", \"maxWaitTimeNanos\" : "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|writeLockWaitTimeMax
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" } }"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Inner helper class to wrap the original lock with a monitored one.    * This inner class is delegating all actual locking operations to the wrapped    * lock, while itself is only responsible to measure the time that it took to    * acquire a specific lock.    */
specifier|private
specifier|static
class|class
name|LockWrapper
implements|implements
name|Lock
block|{
comment|/// the lock to delegate the work to
specifier|private
specifier|final
name|Lock
name|wrappedLock
decl_stmt|;
comment|/// total lock wait time in nanos
specifier|private
specifier|final
name|MutableCounterLong
name|lockWaitTotal
decl_stmt|;
comment|/// highest lock wait time (max)
specifier|private
specifier|final
name|MutableCounterLong
name|lockWaitMax
decl_stmt|;
comment|/// number of lock counts
specifier|private
specifier|final
name|MutableCounterLong
name|lockWaitCount
decl_stmt|;
comment|/**      * Creates a new wrapper around an existing lock.      *      * @param original The original lock to wrap by this monitoring lock      * @param total The (atomic) counter to increment for total lock wait time      * @param max The (atomic) counter to adjust to the maximum wait time      * @param cnt The (atomic) counter to increment with each lock call      */
name|LockWrapper
parameter_list|(
name|Lock
name|original
parameter_list|,
name|MutableCounterLong
name|total
parameter_list|,
name|MutableCounterLong
name|max
parameter_list|,
name|MutableCounterLong
name|cnt
parameter_list|)
block|{
name|wrappedLock
operator|=
name|original
expr_stmt|;
name|this
operator|.
name|lockWaitTotal
operator|=
name|total
expr_stmt|;
name|this
operator|.
name|lockWaitMax
operator|=
name|max
expr_stmt|;
name|this
operator|.
name|lockWaitCount
operator|=
name|cnt
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|lock
parameter_list|()
block|{
name|long
name|start
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|wrappedLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|incrementBy
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|lockInterruptibly
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|long
name|start
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|wrappedLock
operator|.
name|lockInterruptibly
argument_list|()
expr_stmt|;
name|incrementBy
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|tryLock
parameter_list|()
block|{
return|return
name|wrappedLock
operator|.
name|tryLock
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|tryLock
parameter_list|(
name|long
name|time
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|long
name|start
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|boolean
name|ret
init|=
name|wrappedLock
operator|.
name|tryLock
argument_list|(
name|time
argument_list|,
name|unit
argument_list|)
decl_stmt|;
name|incrementBy
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|unlock
parameter_list|()
block|{
name|wrappedLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Condition
name|newCondition
parameter_list|()
block|{
return|return
name|wrappedLock
operator|.
name|newCondition
argument_list|()
return|;
block|}
comment|/**      * Helper to increment the monitoring counters.      * Called from the lock implementations to increment the total/max/coun      * values of the monitoring counters.      *      * @param waitTime The actual wait time (in nanos) for the lock operation      */
specifier|private
name|void
name|incrementBy
parameter_list|(
name|long
name|waitTime
parameter_list|)
block|{
name|this
operator|.
name|lockWaitTotal
operator|.
name|incr
argument_list|(
name|waitTime
argument_list|)
expr_stmt|;
name|this
operator|.
name|lockWaitCount
operator|.
name|incr
argument_list|()
expr_stmt|;
if|if
condition|(
name|waitTime
operator|>
name|this
operator|.
name|lockWaitMax
operator|.
name|value
argument_list|()
condition|)
block|{
name|this
operator|.
name|lockWaitMax
operator|.
name|incr
argument_list|(
name|waitTime
operator|-
name|this
operator|.
name|lockWaitMax
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Creates a new monitoring wrapper around a R/W lock.    * The so created wrapper instance can be used instead of the original R/W    * lock, which then automatically updates the monitoring values in the<code>    * MetricsSource</code>. This allows easy "slide in" of lock monitoring where    * originally only a standard R/W lock was used.    *    * @param lock The original R/W lock to wrap for monitoring    * @param metrics The target for lock monitoring    */
specifier|private
name|ReadWriteLockMetrics
parameter_list|(
name|ReadWriteLock
name|lock
parameter_list|,
name|MetricsSource
name|metrics
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|metrics
operator|instanceof
name|LockMetricSource
argument_list|,
literal|"Invalid MetricsSource"
argument_list|)
expr_stmt|;
name|LockMetricSource
name|lms
init|=
operator|(
name|LockMetricSource
operator|)
name|metrics
decl_stmt|;
name|readLock
operator|=
operator|new
name|LockWrapper
argument_list|(
name|lock
operator|.
name|readLock
argument_list|()
argument_list|,
name|lms
operator|.
name|readLockWaitTimeTotal
argument_list|,
name|lms
operator|.
name|readLockWaitTimeMax
argument_list|,
name|lms
operator|.
name|readLockCounts
argument_list|)
expr_stmt|;
name|writeLock
operator|=
operator|new
name|LockWrapper
argument_list|(
name|lock
operator|.
name|writeLock
argument_list|()
argument_list|,
name|lms
operator|.
name|writeLockWaitTimeTotal
argument_list|,
name|lms
operator|.
name|writeLockWaitTimeMax
argument_list|,
name|lms
operator|.
name|writeLockCounts
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Lock
name|readLock
parameter_list|()
block|{
return|return
name|readLock
return|;
block|}
annotation|@
name|Override
specifier|public
name|Lock
name|writeLock
parameter_list|()
block|{
return|return
name|writeLock
return|;
block|}
block|}
end_class

end_unit

